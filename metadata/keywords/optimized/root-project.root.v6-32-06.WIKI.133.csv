quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Performance,". ROOT: tutorials/geom/tessellatedNav.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tessellatedNav.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Macro allowing to vizualize tessellations from Wavefront's .obj format. . ; #include <TROOT.h>; #include <TColor.h>; #include <TDatime.h>; #include <TRandom3.h>; #include <TGeoManager.h>; #include <TGeoTessellated.h>; #include <TVirtualGeoConverter.h>; #include <TView.h>; ; //______________________________________________________________________________; int randomColor(); {; gRandom = new TRandom3();; TDatime dt;; gRandom->SetSeed(dt.GetTime());; int ci = TColor::GetFreeColorIndex();; TColor *color = new TColor(ci, gRandom->Rndm(), gRandom->Rndm(), gRandom->Rndm());; return ci;; }; ; //______________________________________________________________________________; void tessellatedNav(const char *dot_obj_file = """", bool check = false); {; // Input a file in .obj format (https://en.wikipedia.org/wiki/Wavefront_.obj_file); // The file should have a single object inside, only vertex and faces information is used; TString name = dot_obj_file;; TString sfile = dot_obj_file;; if (sfile.IsNull()) {; sfile = gROOT->GetTutorialsDir();; sfile += ""/geom/teddy.obj"";; }; name.ReplaceAll("".obj"", """");; gROOT->GetListOfCanvases()->Delete();; if (gGeoManager); delete gGeoManager;; auto geom = new TGeoManager(name, ""Imported from .obj file"");; TGeoMaterial *mat = new TGeoMaterial(""Al"", 26.98, 13, 2.7);; TGeoMedium *med = new TGeoMedium(""MED"", 1, mat);; TGeoVolume *top = geom->MakeBox(""TOP"", med, 10, 10, 10);; geom->SetTopVolume(top);; ; auto tsl = TGeoTessellated::ImportFromObjFormat(sfile.Data(), check);; if (!tsl); return;; tsl->ResizeCenter(5.);; ; TGeoVolume *vol = new TGeoVolume(name, tsl, med);; vol->SetLineColor(randomColor());; vol->SetLineWidth(2);; top->AddNode(vol, 1);; geom->CloseGeometry();; ; // Convert to VecGeom tessellated solid; auto converter = TVi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tessellatedNav_8C.html:99,Load,Loading,99,doc/master/tessellatedNav_8C.html,https://root.cern,https://root.cern/doc/master/tessellatedNav_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/geom/visualizeWavefrontObj.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. visualizeWavefrontObj.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Macro allowing to vizualize tessellations from Wavefront's .obj format. . ; #include <TROOT.h>; #include <TColor.h>; #include <TDatime.h>; #include <TRandom3.h>; #include <TGeoManager.h>; #include <TGeoTessellated.h>; ; //______________________________________________________________________________; int randomColor(); {; gRandom = new TRandom3();; TDatime dt;; gRandom->SetSeed(dt.GetTime());; int ci = TColor::GetFreeColorIndex();; TColor *color = new TColor(ci, gRandom->Rndm(), gRandom->Rndm(), gRandom->Rndm());; return ci;; }; ; //______________________________________________________________________________; void visualizeWavefrontObj(const char *dot_obj_file="""", bool check = false); {; // Input a file in .obj format (https://en.wikipedia.org/wiki/Wavefront_.obj_file); // The file should have a single object inside, only vertex and faces information is used; ; TString name = dot_obj_file;; TString sfile = dot_obj_file;; if (sfile.IsNull()) {; sfile = gROOT->GetTutorialsDir();; sfile += ""/geom/teddy.obj"";; }; name.ReplaceAll("".obj"", """");; gROOT->GetListOfCanvases()->Delete();; if (gGeoManager); delete gGeoManager;; new TGeoManager(name, ""Imported from .obj file"");; TGeoMaterial *mat = new TGeoMaterial(""Al"", 26.98, 13, 2.7);; TGeoMedium *med = new TGeoMedium(""MED"", 1, mat);; TGeoVolume *top = gGeoManager->MakeBox(""TOP"", med, 10, 10, 10);; gGeoManager->SetTopVolume(top);; ; auto tsl = TGeoTessellated::ImportFromObjFormat(sfile.Data(), check);; if (!tsl) return;; tsl->ResizeCenter(5.);; ; TGeoVolume *vol = new TGeoVolume(name, tsl, med);; vol->SetLineColor(randomColor());; vol->SetLineWidth(2);; top->AddNode(vol, 1);; gGeoManager->CloseGeometry();; if (!gROOT->IsBatch()) top->Draw(""ogl"");; }; TColor.h; TDatime.h; namechar name[80]Defini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/visualizeWavefrontObj_8C.html:106,Load,Loading,106,doc/master/visualizeWavefrontObj_8C.html,https://root.cern,https://root.cern/doc/master/visualizeWavefrontObj_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/geom/xtruDraw.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. xtruDraw.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Draw a ""representative"" TXTRU shape. . ; void xtruDraw() {; TCanvas *canvas = new TCanvas(""xtru"",""Example XTRU object"",200,10,640,640);; ; // Create a new geometry; TGeometry* geometry = new TGeometry(""geometry"",""geometry"");; geometry->cd();; ; TXTRU* atxtru = new TXTRU(""atxtru"",""atxtru"",""void"",5,2);; ; // outline and z segment specifications; ; Float_t x[] =; { -177.292, -308.432, -308.432, -305.435, -292.456, -280.01; , -241.91, -241.91, -177.292, -177.292, 177.292, 177.292; , 241.91, 241.91, 280.06, 297.942, 305.435, 308.432; , 308.432, 177.292, 177.292, -177.292 };; Float_t y[] =; { 154.711, 23.5712, 1.1938, 1.1938, 8.6868, 8.6868; , -3.7592, -90.0938, -154.711, -190.602, -190.602, -154.711; , -90.0938, -3.7592, 8.6868, 8.6868, 1.1938, 1.1938; , 23.5712, 154.711, 190.602, 190.602 };; Float_t z[] =; { 0.00, 500.0 };; Float_t scale[] =; { 1.00, 1.00 };; Float_t x0[] =; { 0, 0 };; Float_t y0[] =; { 0, 0 };; ; Int_t i;; ; Int_t nxy = sizeof(x)/sizeof(Float_t);; for (i=0; i<nxy; i++) {; atxtru->DefineVertex(i,x[i],y[i]);; }; ; Int_t nz = sizeof(z)/sizeof(Float_t);; for (i=0; i<nz; i++) {; atxtru->DefineSection(i,z[i],scale[i],x0[i],y0[i]);; }; ; // Define a TNode where this example resides in the TGeometry; // Draw the TGeometry; ; TNode* anode = new TNode(""anode"",""anode"",atxtru);; anode->SetLineColor(1);; ; geometry->Draw();; ; // Tweak the pad scales so as not to distort the shape; ; TVirtualPad *thisPad = gPad;; if (thisPad) {; TView *view = thisPad->GetView();; if (!view) return;; Double_t min[3],max[3],center[3];; view->GetRange(min,max);; int i;; // Find the boxed center; for (i=0;i<3; i++) center[i] = 0.5*(max[i]+min[i]);; Double_t maxSide = 0;; // Find the largest side; for (i=0;i<3; i++) maxSide = TMath::Max(maxSide,max[i]-center[i]);; file://Adjust sca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/xtruDraw_8C.html:93,Load,Loading,93,doc/master/xtruDraw_8C.html,https://root.cern,https://root.cern/doc/master/xtruDraw_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/geom/xtruSamples.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. xtruSamples.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Draw a sample of TXTRU shapes some convex, concave (and possibly malformed) ; Change Bool_t's to test alternative specifications. ; void xtruSamples(); {; // One normally specifies the x-y points in counter-clockwise order;; // flip this to TRUE to test that it doesn't matter.; Bool_t makecw = kFALSE;; ; // One normally specifies the z points in increasing z order;; // flip this to TRUE to test that it doesn't matter.; Bool_t reversez = kFALSE;; ; // One shouldn't be creating malformed polygons; // but to test what happens when one does here's a flag.; // The effect will be only apparent in solid rendering mode; Bool_t domalformed = kFALSE;; // domalformed = kTRUE;; ; TCanvas* c1 = new TCanvas(""c1"",""sample TXTRU Shapes"",200,10,640,640);; ; // Create a new geometry; TGeometry* geom = new TGeometry(""sample"",""sample"");; geom->cd();; ; // Define the complexity of the drawing; Int_t zseg = 6; // either 2 or 6; Int_t extravis = 0; // make extra z ""arrow"" visible; ; Float_t unit = 1;; ; // Create a large BRIK to embed things into; Float_t bigdim = 12.5*unit;; TBRIK* world = new TBRIK(""world"",""world"",""void"",bigdim,bigdim,bigdim);; ; // Create the main node, make it invisible; TNode* worldnode = new TNode(""worldnode"",""world node"",world);; worldnode->SetVisibility(0);; worldnode->cd();; ; // Canonical shape ... gets further modified by scale factors; // to create convex (and malformed) versions; Float_t x[] = { -0.50, -1.20, 1.20, 0.50, 0.50, 1.20, -1.20, -0.50 };; Float_t y[] = { -0.75, -2.00, -2.00, -0.75, 0.75, 2.00, 2.00, 0.75 };; Float_t z[] = { -0.50, -1.50, -1.50, 1.50, 1.50, 0.50 };; Float_t s[] = { 0.50, 1.00, 1.50, 1.50, 1.00, 0.50 };; Int_t nxy = sizeof(x)/sizeof(Float_t);; Float_t convexscale[] = { 7.0, -1.0, 1.5 };; ; Int_t icolor[] = { 1, 2, 3, 2, 2, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/xtruSamples_8C.html:96,Load,Loading,96,doc/master/xtruSamples_8C.html,https://root.cern,https://root.cern/doc/master/xtruSamples_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/gl/glViewerExercise.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. glViewerExercise.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; Script showing how to use the GL viewer API to animate a picture. ; ; #include ""TGLViewer.h""; #include ""TGLOrthoCamera.h""; #include ""TTimer.h""; #include ""TRandom.h""; #include ""TVirtualPad.h""; ; TGLViewer::ECameraType camera;; TTimer timer(25);; TRandom randGen(0);; ; Int_t moveCount = 0;; ; void AnimateCamera(); {; // initialization; static Double_t fov = 30;; static Double_t zoom = 0.78;; static Double_t dolly = 1500.0;; static Double_t center[3] = {-164.0, -164.0, -180.0};; static Double_t hRotate = 0.0;; static Double_t vRotate = 0.0;; // steps; static Double_t fovStep = randGen.Rndm()*3.0 - 0.5;; static Double_t zoomStep = (20 - randGen.Rndm())/1000.;; static Double_t dollyStep = randGen.Rndm()*5.0 - 1.0;; static Double_t centerStep[3] = {randGen.Rndm()*4, randGen.Rndm()*4,; randGen.Rndm()*4 };; static Double_t hRotateStep = randGen.Rndm()*0.025;; static Double_t vRotateStep = randGen.Rndm()*0.05;; ; // move center; center[0] += centerStep[0];; center[1] += centerStep[1];; center[2] += centerStep[2];; Double_t mag = TMath::Sqrt(center[0]*center[0] + center[1]*center[1] +; center[2]*center[2]);; if(mag > 500); {; centerStep[0] = -centerStep[0];; centerStep[1] = -centerStep[1];; centerStep[2] = -centerStep[2];; }; ; // rotate; hRotate += hRotateStep;; vRotate += vRotateStep;; if (vRotate >= TMath::TwoPi() || vRotate <= 0.0); vRotateStep = -vRotateStep;; ; if (hRotate >= (TMath::PiOver2()- 0.02f) ||; hRotate <= (0.07f -TMath::PiOver2())) {; hRotateStep = -hRotateStep;; }; ; // dolly; dolly += dollyStep;; if (dolly >= 2000.0 || dolly <= 1500.0); dollyStep = -dollyStep;; ; // modify frustum; TGLViewer * v = (TGLViewer *)gPad->GetViewer3D();; if(camera < 3); {; fov += fovStep;; if (fov > 130.0 || fov < 5.0); fovStep = - fovStep; }; else; {; zoom += zo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/glViewerExercise_8C.html:99,Load,Loading,99,doc/master/glViewerExercise_8C.html,https://root.cern,https://root.cern/doc/master/glViewerExercise_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/gl/glViewerLOD.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. glViewerLOD.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; To set the Level Of Details when rendering geometry shapes. ; ; void glViewerLOD(Int_t reqNodes = 1000, Bool_t randomDist = kTRUE,; Bool_t reqSpheres = kTRUE, Bool_t reqTubes = kTRUE); {; TGeoManager * geom = new TGeoManager(""LODTest"", ""GL viewer LOD test"");; geom->SetNsegments(4); // Doesn't matter keep low; TGeoMaterial *matEmptySpace = new TGeoMaterial(""EmptySpace"", 0, 0, 0);; TGeoMaterial *matSolid = new TGeoMaterial(""Solid"" , .938, 1., 10000.);; ; TGeoMedium *medEmptySpace = new TGeoMedium(""Empty"", 1, matEmptySpace);; TGeoMedium *medSolid = new TGeoMedium(""Solid"", 1, matSolid);; ; Double_t sizeBase = 20.0;; Double_t worldRadius;; if (randomDist) {; worldRadius = pow(reqNodes,.5)*sizeBase;; } else {; worldRadius = pow(reqNodes,.3)*sizeBase;; }; ; TGeoVolume *top = geom->MakeBox; (""WORLD"", medEmptySpace, worldRadius, worldRadius, worldRadius);; geom->SetTopVolume(top);; ; gRandom->SetSeed();; ; // Create random number of unique sphere shapes - up to 25% of; // total placed sphere requested; UInt_t volumeCount = gRandom->Integer(reqNodes/4)+1;; TGeoVolume ** volumes = new TGeoVolume *[volumeCount];; TGeoVolume * volume;; UInt_t i;; Double_t dummy;; ; for (i = 0; i < volumeCount; i++) {; char name[128];; sprintf(name, ""Volume_%d"", i);; ; // Random volume shape; Int_t type = -1;; if (reqSpheres && reqTubes) {; type = gRandom->Integer(2);; if (type == 1); type += gRandom->Integer(3);; }; else if(reqSpheres); type = 0;; else if(reqTubes); type = 1 + gRandom->Integer(3);; ; // Random dimensions; Double_t rMin = gRandom->Rndm() * sizeBase;; Double_t rMax = rMin + gRandom->Rndm() * sizeBase * 2.0;; Double_t dz = pow(gRandom->Rndm(),2.0) * sizeBase * 15.0;; Double_t phi1 = gRandom->Rndm() * 90.0;; Double_t phi2 = phi1 + gRandom->Rndm() * 270.0;; ; // Pick random co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/glViewerLOD_8C.html:94,Load,Loading,94,doc/master/glViewerLOD_8C.html,https://root.cern,https://root.cern/doc/master/glViewerLOD_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/gl/glbox.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. glbox.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; Display a 3D histogram using GL (box option). . ; void glbox(); {; gStyle->SetCanvasPreferGL(kTRUE);; TCanvas *c = new TCanvas(""glbox"",""TH3 Drawing"", 100, 10, 850, 400);; TPaveLabel *title = new TPaveLabel(0.04, 0.86, 0.96, 0.98,; ""\""glbox\"" and \""glbox1\"" options for TH3."");; title->SetFillColor(32);; title->Draw();; ; TPad *boxPad = new TPad(""box"", ""box"", 0.02, 0.02, 0.48, 0.82);; TPad *box1Pad = new TPad(""box1"", ""box1"", 0.52, 0.02, 0.98, 0.82);; boxPad->Draw();; box1Pad->Draw();; ; TH3F *h31 = new TH3F(""h31"", ""h31"", 10, -1, 1, 10, -1, 1, 10, -1, 1);; TF3 * gxy = new TF3(""gaus2"",""xygaus"");; gxy->SetParameters(1,0,1,0,0.3);; h31->FillRandom(""gaus2"");; h31->SetFillColor(2);; boxPad->cd();; h31->Draw(""glbox"");; ; TH3F *h32 = new TH3F(""h32"", ""h32"", 10, -2, 2, 10, -1, 1, 10, -3, 3);; TF3 * g3 = new TF3(""gaus3"",""xyzgaus"");; g3->SetParameters(1,0,1,0,1,0,1);; h32->FillRandom(""gaus3"");; h32->SetFillColor(4);; box1Pad->cd();; h32->Draw(""glbox1"");; }; c#define c(i)Definition RSha256.hxx:101; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TCanvasThe Canvas class.Definition TCanvas.h:23; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF3A 3-Dim function with parameters.Definition TF3.h:28; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH3F3-D histogram with a float per channel (see TH1 documentation)Definition TH3.h:317; TH3::FillRandomvoid FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr) overrideFill histogram following distribution in function fname.Definition TH3.cxx:833; TPadThe m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/glbox_8C.html:88,Load,Loading,88,doc/master/glbox_8C.html,https://root.cern,https://root.cern/doc/master/glbox_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/gl/gldemos.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. gldemos.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; Menu for running GL demos. ; ; void gldemos(); {; TControlBar *bar = new TControlBar(""vertical"", ""GL painter demo"",20,20);; bar->AddButton(""Help on demos"", ""help()"", ""Description"");; bar->AddButton(""glsurfaces"", "".x $ROOTSYS/tutorials/gl/glsurfaces.C"", ""Surface painter example"");; bar->AddButton(""glrose"", "".x $ROOTSYS/tutorials/gl/glrose.C"", ""Surface in polar system"");; bar->AddButton(""gltf3"", "".x $ROOTSYS/tutorials/gl/gltf3.C"", ""TF3 painter"");; bar->AddButton(""glbox"", "".x $ROOTSYS/tutorials/gl/glbox.C"", ""BOX painter"");; bar->AddButton(""glparametric"", "".x $ROOTSYS/tutorials/gl/glparametric.C"", ""Parametric surface"");; bar->Show();; }; ; void help(); {; new TCanvas(""chelp"",""Help on gldemos"",200,10,700,600);; ; TPaveLabel *title = new TPaveLabel(0.04, 0.86, 0.96, 0.98, ""These demos show different gl painters."");; title->SetFillColor(32);; title->Draw();; ; TPaveText *hdemo = new TPaveText(0.04, 0.04, 0.96, 0.8);; hdemo->SetTextAlign(12);; hdemo->SetTextFont(52);; hdemo->SetTextColor(kBlue);; hdemo->AddText(""1. Glsurfaces demo shows glsurf4, glsurf1, glsurf3, glsurf1cyl, glsurfpol, gltf3 options."");; hdemo->AddText(""2. Glrose demontrates \""glsurf2pol\"" drawing option and user-defined palette."");; hdemo->AddText(""3. Gltf3 demo shows \""gltf3\"" option."");; hdemo->AddText(""4. Glbox demo shows \""glbox\"" and \""glbox1\"" options for TH3."");; hdemo->AddText(""5. Glparametric demo shows how to define and display parametric surfaces."");; hdemo->AddText(""You can zoom any plot: press 'J', 'K', 'j', 'k' keys, or use mouse wheel."");; hdemo->AddText(""Rotate any plot:"");; hdemo->AddText("" ---select plot with mouse cursor,"");; hdemo->AddText("" ---move mouse cursor, pressing and holding left mouse button "");; hdemo->AddText(""Pan plot:"");; hdemo->AddText("" ---select with mouse cursor a part ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gldemos_8C.html:90,Load,Loading,90,doc/master/gldemos_8C.html,https://root.cern,https://root.cern/doc/master/gldemos_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/gl/glh3c.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. glh3c.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; Display a 3D histogram using GL (box option). . ; void glh3c(); {; gStyle->SetCanvasPreferGL(kTRUE);; ; ; TGLTH3Composition * comp = new TGLTH3Composition;; TH3F * h1 = new TH3F(""h1"", ""h1"", 10, -1., 1., 10, -1., 1., 10, -1., 1.);; TF3 * g3 = new TF3(""gaus3"",""xyzgaus"");; g3->SetParameters(1,0,1,0,1,0,1);; h1->FillRandom(""gaus3"");; h1->SetFillColor(kRed);; TH3F * h2 = new TH3F(""h2"", ""h2"", 10, -1., 1., 10, -1., 1., 10, -1., 1.);; TF3 * l3 = new TF3(""landau3"",""landau(x,[0],[1],[2])*gaus(y,1,[3],[4])*gaus(z,1,[3],[4])"");; l3->SetParameters(1,0,1,0.,0.5);; h2->FillRandom(""landau3"");; h2->SetFillColor(kGreen);; TH3F * h3 = new TH3F(""h3"", ""h3"", 10, -1., 1., 10, -1., 1., 10, -1., 1.);; TF3 * gx = new TF3(""gaus1"",""gaus(x)"");; gx->SetParameters(1,0,1);; h3->FillRandom(""gaus1"");; h3->SetFillColor(kBlue);; ; comp->AddTH3(h1);; comp->AddTH3(h2, TGLTH3Composition::kSphere);; comp->AddTH3(h3);; ; comp->Draw();; ; TPaveLabel *title = new TPaveLabel(0.04, 0.86, 0.96, 0.98,; ""TH3 composition."");; title->SetFillColor(32);; title->Draw();; }; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF3A 3-Dim function with parameters.Definition TF3.h:28; TGLTH3CompositionDefinition TGLTH3Composition.h:27; TGLTH3Composition::AddTH3void AddTH3(const TH3 *hist, ETH3BinShape shape=kBox)Add TH3 into collection.Definition TGLTH3Composition.cxx:42; TGLTH3Composition::kSphere@ kSphereDefinition TGLTH3Composition.h:34; TH1::FillRandomvirtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/glh3c_8C.html:88,Load,Loading,88,doc/master/glh3c_8C.html,https://root.cern,https://root.cern/doc/master/glh3c_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/gl/glparametric.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. glparametric.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; Show rendering of parametric surfaces. ; A parametric surface is defined by three functions: S(u, v) : {x(u, v), y(u, v), z(u, v)}. To create parametric surface and draw it one has to:; Create canvas, which support OpenGL drawing (two ways):; Call gStyle->SetCanvasPreferGL(kTRUE); Or create canvas with name, wich contains ""gl"". create TGLParametricEquation object. TGLParametricEquation *eq = new TGLParametricEquation(""name"",; ""some FORMULA here - x(u, v)"",; ""some FORMULA here - y(u, v)"",; ""some FORMULA here - z(u, v)"",; uMin, uMax, vMin, vMax);; TGLParametricEquationA parametric surface is a surface defined by a parametric equation, involving two parameters (u,...Definition TGLParametric.h:35; where FORMULA is the same string (mathematical expression), as in TF2, but you should use 'u' (or 'U') instead of 'x' and 'v' (or 'V') instead of 'y'.; Call equation->Draw(); Parametric surfaces support 21 color ""schemes"", you can change the color:; place mouse cursor above surface (surface is selected in pad); press 's' or 'S'. ; void glparametric(); {; gStyle->SetCanvasPreferGL(kTRUE);; TCanvas *c = new TCanvas(""canvas"",""Parametric surfaces with gl"", 100, 10,; 700, 700);; c->SetFillColor(42);; gStyle->SetFrameFillColor(42);; ; c->Divide(2, 2);; c->cd(1);; TGLParametricEquation *p1 = new TGLParametricEquation(""Conchoid"",; ""1.2 ^ u * (1 + cos(v)) * cos(u)"",; ""1.2 ^ u * (1 + cos(v)) * sin(u)"",; ""1.2 ^ u * sin(v) - 1.5 * 1.2 ^ u"",; 0., 6 * TMath::Pi(), 0., TMath::TwoPi());; p1->Draw();; ; c->cd(2);; TGLParametricEquation *p2 = new TGLParametricEquation(""Apple"",; ""cos(u) * (4 + 3.8 * cos(v)) "",; ""sin(u) * (4 + 3.8 * cos(v))"",; ""(cos(v) + sin(v) - 1) * (1 + sin(v)) * log(1 - pi * v / 10) + 7.5 * sin(v)"",; 0, TMath::TwoPi(), -TMath::Pi(), TMath::Pi());; p2->Draw();; ; c->c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/glparametric_8C.html:95,Load,Loading,95,doc/master/glparametric_8C.html,https://root.cern,https://root.cern/doc/master/glparametric_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/gl/glparametrics2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. glparametrics2.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; Show rendering of parametric surfaces. ; A parametric surface is defined by three functions: S(u, v) : {x(u, v), y(u, v), z(u, v)}. To create parametric surface and draw it one has to:; Create canvas, which support OpenGL drawing (two ways):; Call gStyle->SetCanvasPreferGL(kTRUE); Or create canvas with name, wich contains ""gl"". create TGLParametricEquation object. TGLParametricEquation *eq = new TGLParametricEquation(""name"",; ""some FORMULA here - x(u, v)"",; ""some FORMULA here - y(u, v)"",; ""some FORMULA here - z(u, v)"",; uMin, uMax, vMin, vMax);; TGLParametricEquationA parametric surface is a surface defined by a parametric equation, involving two parameters (u,...Definition TGLParametric.h:35; where FORMULA is the same string (mathematical expression), as in TF2, but you should use 'u' (or 'U') instead of 'x' and 'v' (or 'V') instead of 'y'.; Call equation->Draw(); Parametric surfaces support 21 color ""schemes"", you can change the color:; place mouse cursor above surface (surface is selected in pad); press 's' or 'S'. ; void klein_bottle(TGLVertex3 &dst, Double_t u, Double_t v); {; using namespace TMath;; ; const Double_t r = 4. * (1. - Cos(u) / 2.);; if (u < Pi()) {; dst.X() = 6 * Cos(u) * (1. + Sin(u)) + r * Cos(u) * Cos(v);; dst.Y() = 16 * Sin(u) + r * Sin(u) * Cos(v);; } else {; dst.X() = 6 * Cos(u) * (1. + Sin(u)) + r * Cos(v + Pi());; dst.Y() = 16 * Sin(u);; }; dst.Z() = r * Sin(v);; }; ; void glparametrics2(); {; gStyle->SetCanvasPreferGL(kTRUE);; TCanvas *c = new TCanvas(""canvas"",""Parametric surfaces with gl"", 100, 10, 700, 700);; ; c->Divide(2, 2);; c->cd(1);; TGLParametricEquation *p1 = new TGLParametricEquation(""Shell"",; ""1.2 ^ v * sin(u) ^ 2 * sin(v)"",; ""1.2 ^ v * sin(u) * cos(u)"",; ""1.2 ^ v * sin(u) ^ 2 * cos(v)"",; 0., TMath::Pi(), // 0 <= ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/glparametrics2_8C.html:97,Load,Loading,97,doc/master/glparametrics2_8C.html,https://root.cern,https://root.cern/doc/master/glparametrics2_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/gl/glrose.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. glrose.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; Render a TF2 looking like a rose. ; It defines and set a user's palette, and use polar system. ; void glrose(); {; const Int_t paletteSize = 10;; Float_t rgb[paletteSize * 3] =; {0.80f, 0.55f, 0.40f,; 0.85f, 0.60f, 0.45f,; 0.90f, 0.65f, 0.50f,; 0.95f, 0.70f, 0.55f,; 1.f, 0.75f, 0.60f,; 1.f, 0.80f, 0.65f,; 1.f, 0.85f, 0.70f,; 1.f, 0.90f, 0.75f,; 1.f, 0.95f, 0.80f,; 1.f, 1.f, 0.85f};; ; Int_t palette[paletteSize] = {0};; ; for (Int_t i = 0; i < paletteSize; ++i); palette[i] = TColor::GetColor(rgb[i * 3], rgb[i * 3 + 1], rgb[i * 3 + 2]);; ; gStyle->SetPalette(paletteSize, palette);; ; gStyle->SetCanvasPreferGL(1);; TCanvas *cnv = new TCanvas(""glc"", ""Surface sample"", 200, 10, 600, 550);; ; TPaveLabel *title = new TPaveLabel(0.04, 0.86, 0.96, 0.98,; ""\""glsurf2pol\"" option + user defined palette."");; title->SetFillColor(32);; title->Draw();; ; TPad *rosePad = new TPad(""box"", ""box"", 0.04, 0.04, 0.96, 0.8);; rosePad->Draw();; ; ; TF2 *fun = new TF2(""a"", ""cos(y)*sin(x)+cos(x)*sin(y)"", -6, 6, -6, 6);; fun->SetContour(paletteSize);; fun->SetNpx(30);; fun->SetNpy(30);; rosePad->cd();; fun->Draw(""glsurf2pol"");; }; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TCanvasThe Canvas class.Definition TCanvas.h:23; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color number for color specified by hex color string of form: ""#rrggbb"",...Definition TColor.cxx:1920; TF1::SetNpxvirtual void SetNpx(Int_t npx=100)Set the number of points used to draw the function.Definition TF1.cxx:3433; TF2A 2-Dim function with parameters.Definition TF2.h:29; TF2::Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/glrose_8C.html:89,Load,Loading,89,doc/master/glrose_8C.html,https://root.cern,https://root.cern/doc/master/glrose_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/gl/glsurfaces.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. glsurfaces.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; Various surfaces rendered with GL. ; This example draws 6 surfaces using OpenGL in pad (one is remake of a classic surfaces.C, another contains 4 surfaces).; The commands used are exactly the same as with a normal pad. The only command to add is: gStyle->SetCanvasPreferGL(true);. ; void glsurfaces(); {; gStyle->SetPalette(0);; ; // after this command all legos surfaces (surf/surf1/surf2/surf4/tf3; // options) are automatically rendered with OpenGL.; gStyle->SetCanvasPreferGL(kTRUE);; ; TCanvas *c1 = new TCanvas(""glc1"",""Surfaces Drawing Options"",200,10,700,900);; c1->SetFillColor(42);; gStyle->SetFrameFillColor(42);; auto title = new TPaveText(0.2, 0.96, 0.8, 0.995);; title->SetFillColor(33);; title->AddText(""Examples of Surface options"");; title->Draw();; ; TPad *pad1 = new TPad(""pad1"",""Gouraud shading"", 0.03, 0.50, 0.98, 0.95, 21);; TPad *pad2 = new TPad(""pad2"",""Color mesh"", 0.03, 0.02, 0.98, 0.48, 21);; pad1->Draw();; pad2->Draw();; // We generate a 2-D function; TF2 *f2 = new TF2(""f2"",""x**2 + y**2 - x**3 -8*x*y**4"", -1., 1.2, -1.5, 1.5);; // Draw this function in pad1 with Gouraud shading option; pad1->cd();; pad1->SetLogz();; f2->SetFillColor(45);; f2->Draw(""glsurf4"");; ; TF2 *f2clone = new TF2(""f2clone"",""x**2 + y**2 - x**3 -8*x*y**4"",; -1., 1.2, -1.5, 1.5);; // Draw this function in pad2 with color mesh option; pad2->cd();; pad2->SetLogz();; f2clone->Draw(""glsurf1"");; ; //add axis titles. The titles are set on the intermediate; //histogram used for visualisation. We must force this histogram; //to be created, then force the redrawing of the two pads; pad2->Update();; f2->GetHistogram()->GetXaxis()->SetTitle(""x title"");; f2->GetHistogram()->GetYaxis()->SetTitle(""y title"");; f2->GetHistogram()->GetXaxis()->SetTitleOffset(1.4);; f2->GetHistogram()->GetYaxis()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/glsurfaces_8C.html:93,Load,Loading,93,doc/master/glsurfaces_8C.html,https://root.cern,https://root.cern/doc/master/glsurfaces_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/gl/gltf3.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. gltf3.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; Draws the Klein bottle. ; Klein bottle is closed non-orientable surface that has no inside or outside. TF3 can be drawn in several styles:; default - like surface4; kMaple0 - very nice colours; kMaple1 - nice colours and outlines; kMaple2 - nice colour outlines. To switch between them, you can press 's' key. ; void gltf3(); {; gStyle->SetCanvasPreferGL(1);; TCanvas *cnv = new TCanvas(""gltf3"", ""TF3: Klein bottle"", 200, 10, 600, 600);; ; TPaveLabel *title = new TPaveLabel(0.04, 0.86, 0.96, 0.98,; ""\""gl\"" option for TF3. Select plot and press 's' to change the color."");; title->SetFillColor(32);; title->Draw();; ; TPad *tf3Pad = new TPad(""box"", ""box"", 0.04, 0.04, 0.96, 0.8);; tf3Pad->Draw();; ; TFormula *f1 = new TFormula(""f1"", ""x*x + y*y + z*z + 2*y - 1"");; TFormula *f2 = new TFormula(""f2"", ""x*x + y*y + z*z - 2*y - 1"");; ; // Klein bottle with cut top&bottom parts; // The Klein bottle is a closed non-orientable surface that has no; // inside or outside.; ; TF3 *tf3 = new TF3(""Klein Bottle"",""f1*(f2*f2-8*z*z) + 16*x*z*f2"",; -3.5, 3.5, -3.5, 3.5, -2.5, 2.5);; ; tf3->SetFillColor(kRed);; tf3Pad->cd();; tf3->Draw(""gl"");; }; kRed@ kRedDefinition Rtypes.h:66; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TCanvasThe Canvas class.Definition TCanvas.h:23; TF3A 3-Dim function with parameters.Definition TF3.h:28; TF3::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TF3.cxx:194; TFormulaThe Formula class.Definition TFormula.h:89; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPad::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet Current pad.Definition TPad.cxx:693; TPad::Drawv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gltf3_8C.html:88,Load,Loading,88,doc/master/gltf3_8C.html,https://root.cern,https://root.cern/doc/master/gltf3_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/gl/glvox1.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. glvox1.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; This macro demonstrates how to use ""glcol"" option for TH3. . ; void glvox1(); {; //Create and fill TH3.; const UInt_t nX = 30;; const Double_t xMin = -1., xMax = 1., xStep = (xMax - xMin) / (nX - 1);; ; const UInt_t nY = 30;; const Double_t yMin = -1., yMax = 1., yStep = (yMax - yMin) / (nY - 1);; ; const UInt_t nZ = 30;; const Double_t zMin = -1., zMax = 1., zStep = (zMax - zMin) / (nZ - 1);; ; TH3F *hist = new TH3F(""glvoxel"", ""glvoxel"", 30, -1., 1., 30, -1., 1., 30, -1., 1.);; ; //Fill the histogram to create a ""sphere"".; for (UInt_t i = 0; i < nZ; ++i) {; const Double_t z = zMin + i * zStep;; ; for (UInt_t j = 0; j < nY; ++j) {; const Double_t y = yMin + j * yStep;; ; for (UInt_t k = 0; k < nX; ++k) {; const Double_t x = xMin + k * xStep;; ; const Double_t val = 1. - (x * x + y * y + z * z);; hist->SetBinContent(k + 1, j + 1, i + 1, val);; }; }; }; ; gStyle->SetCanvasPreferGL(1);; ; hist->Draw(""glcol"");; }; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Double_tdouble Double_tDefinition RtypesCore.h:59; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH3F3-D histogram with a float per channel (see TH1 documentation)Definition TH3.h:317; TH3::SetBinContentvoid SetBinContent(Int_t bin, Double_t content) overrideSet bin content.Definition TH3.cxx:3468; TStyle::SetCanvasPreferGLvoid SetCanvasPreferGL(Bool_t prefer=kTRUE)Definition TStyle.h:341; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; AuthorTimur Pocheptsov ; Definition in file glvox1.C. tutorialsglglvox1.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:28 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/glvox1_8C.html:89,Load,Loading,89,doc/master/glvox1_8C.html,https://root.cern,https://root.cern/doc/master/glvox1_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/gl/glvox2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. glvox2.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; This macro demonstrates how to use ""glcol"" option for TH3 and how to create user defined TRANSFER FUNCTION: transfer function maps bin value to voxel's opacity. ; codomain is [0, 1] (1. - non-transparent, 0.5 is semitransparent, etc.) To pass transparency function into painting algorithm, you have to:; Create TF1 object (with symbolic expression like ""0.5 * (sin(x) + 1)"": ...; TF1 * tf = new TF1(""TransferFunction"", ""0.5 * (sin(x) + 1)"", -10., 10.);; ...; TF11-Dim function classDefinition TF1.h:233; IMPORTANT, the name of TF1 object MUST be ""TransferFunction"".; Add this function into a hist's list of functions: ...; TList * lof = hist->GetListOfFunctions();; if (lof) lof->Add(tf);; ...; It's also possible to use your own function and pass it into TF1, please read TF1 documentation to learn how. This macro is to be compiled: TF1 is extremely slow with interpreted function as an argument. ; ; #include ""TStyle.h""; #include ""TList.h""; #include ""TH3.h""; #include ""TF1.h""; ; namespace {; ; Double_t my_transfer_function(const Double_t *x, const Double_t * /*param*/); {; // Bin values in our example range from -2 to 1.; // Let's make values from -2. to -1.5 more transparent:; if (*x < -1.5); return 0.008;; ; if (*x < -0.5); return 0.015;; ; if (*x < 0.); return 0.02;; ; if (*x < 0.5); return 0.03;; ; if (*x < 0.8); return 0.04;; ; return 0.05;; }; ; } // namespace; ; void glvox2(); {; //Create and fill TH3.; const UInt_t nX = 30;; const Double_t xMin = -1., xMax = 1., xStep = (xMax - xMin) / (nX - 1);; ; const UInt_t nY = 30;; const Double_t yMin = -1., yMax = 1., yStep = (yMax - yMin) / (nY - 1);; ; const UInt_t nZ = 30;; const Double_t zMin = -1., zMax = 1., zStep = (zMax - zMin) / (nZ - 1);; ; TH3F *hist = new TH3F(""glvoxel"", ""glvoxel"", nX, -1., 1., nY, -1., 1., nZ, -1., 1.);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/glvox2_8C.html:89,Load,Loading,89,doc/master/glvox2_8C.html,https://root.cern,https://root.cern/doc/master/glvox2_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/gl/grad.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. grad.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; This macro demonstrates how to create and use linear gradients to fill a histogram or a pad. . ; //Includes for ACLiC (cling does not need them).; #include ""TColorGradient.h""; #include ""TCanvas.h""; #include ""TColor.h""; #include ""TStyle.h""; #include ""TError.h""; #include ""TH1F.h""; ; //______________________________________________________________________; void grad(bool use_gl = true); {; //Make sure we enabled OpenGL support in a canvas.; gStyle->SetCanvasPreferGL(use_gl);; ; // Test if canvas supports OpenGL:; TCanvas *cnv = new TCanvas(""grad"", ""gradient demo 1"", 100, 100, 600, 600);; if (!cnv->UseGL() && !cnv->IsWeb()); ::Warning(""grad"", ""This macro requires either OpenGL or Web canvas to correctly handle gradient colors"");; ; // Create custom linear gradients.; // Linear gradient is defined by:; // 1) Direction in which gradient is changing (defined as angle in grad); // 2) colors (to interpolate between them), at least two of them; // 3) alpha parameter for the colors (if not specified - used from TColor directly); // 4) coordinates for these colors along the gradient axis [0., 1.] (must be sorted!).; ; auto fcol1 = TColor::GetColor((Float_t) 0.25, 0.25, 0.25, 0.55); // special frame color 1; auto fcol2 = TColor::GetColor((Float_t) 1., 1., 1., 0.05); // special frame color 2; ; auto frameGradient = TColor::GetLinearGradient(0., {fcol1, fcol2, fcol2, fcol1}, {0., 0.2, 0.8, 1.});; ; // This gradient is a mixture of two standard colors.; auto padGradient = TColor::GetLinearGradient(0., {30, 38});; ; // Another gradient built from three standard colors.; auto histGradient = TColor::GetLinearGradient(45., {kYellow, kOrange, kRed});; ; // Example of radial gradient, for stats box works properly only in web canvas; // Here first argument is radius [0..1] and then list of color",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gl_2grad_8C.html:87,Load,Loading,87,doc/master/gl_2grad_8C.html,https://root.cern,https://root.cern/doc/master/gl_2grad_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/gl/grad2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. grad2.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; Gradient fill with transparency and the ""SAME"" option. ; To use this macro you need OpenGL enabled in pad: either set OpenGL.CanvasPreferGL to 1 in $ROOTSYS/etc/system.rootrc; or call gStyle->SetCanvasPreferGL(kTRUE); before canvas created. ; //Includes for ACLiC (cling does not need them).; #include ""TColorGradient.h""; #include ""TCanvas.h""; #include ""TError.h""; #include ""TColor.h""; #include ""TStyle.h""; #include ""TH1F.h""; ; void grad2(bool gl = true); {; //Make sure canvas supports OpenGL.; gStyle->SetCanvasPreferGL(gl);; ; //2. Check that we have a canvas with an OpenGL support.; auto cnv = new TCanvas(""grad2"", ""gradient demo 2"", 100, 100, 800, 600);; if (!cnv->UseGL() && !cnv->IsWeb()); ::Warning(""grad2"", ""This macro requires either OpenGL or Web canvas to correctly handle gradient colors"");; ; //3. Custom colors:; // a) Custom semi-transparent red.; auto customRed = TColor::GetColor((Float_t) 1., 0., 0., 0.5);; ; // Custom semi-transparent green.; auto customGreen = TColor::GetColor((Float_t) 0., 1., 0., 0.5);; ; // 4. Linear gradient colors; // b) Gradient (from our semi-transparent red to ROOT's kOrange).; // Linear gradient is defined by: 1) angle in grad; // 2) colors (to interpolate between them),; // If necessary, TLinearGradient object can be retrieved and modified later; ; auto grad1 = TColor::GetLinearGradient(90., {customRed, kOrange});; ; //Vertical gradient fill.; auto grad2 = TColor::GetLinearGradient(90., {customGreen, kBlue});; ; auto hist = new TH1F(""a2"", ""b2"", 10, -2., 3.);; auto hist2 = new TH1F(""c3"", ""d3"", 10, -3., 3.);; hist->FillRandom(""landau"", 100000);; hist2->FillRandom(""gaus"", 100000);; ; hist->SetFillColor(grad1);; hist2->SetFillColor(grad2);; ; hist2->Draw();; hist->Draw(""SAME"");; }; Float_tfloat Float_tDefinition RtypesCore.h:57; kOrange@ k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gl_2grad2_8C.html:88,Load,Loading,88,doc/master/gl_2grad2_8C.html,https://root.cern,https://root.cern/doc/master/gl_2grad2_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/gl/gradients.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. gradients.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; Features: . Radial and linear gradients; Transparent/semitransparent colours. ; //Includes for ACLiC:; #include ""TColorGradient.h""; #include ""TCanvas.h""; #include ""TError.h""; #include ""TStyle.h""; #include ""TText.h""; #include ""TPie.h""; ; ; void gradients(bool gl = true); {; //Find free colour indices in the ROOT's palette for:; //1. A radial gradient for TPie;; //2. A linear gradient for TCanvas; //3. A fully transparent fill color for a nested pad.; ; gStyle->SetCanvasPreferGL(gl);; ; auto c = new TCanvas(""cpie"",""Gradient colours demo"", 700, 700);; //Before we allocated any new colour or created any object:; if (!c->UseGL() && !c->IsWeb()); ::Warning(""gradients"", ""This macro requires either OpenGL or Web canvas to correctly handle gradient colors"");; ; //Linear gradient is defined by: 1) colors (to interpolate between them),; //2) coordinates for these colors along the gradient axis [0., 1.] (must be sorted!).; //3) Start and end points for a gradient, you specify them in some NDC rect ([0,0 - 1,1]),; //and this rect is either: bounding rect of your polygon/object to fill; //(gradient->SetCoordinateMode(TColorGradient::kObjectBoundingMode)); //or bounding rect of a pad (gradient->SetCoordinateMode(TColorGradient::kPadMode)).; //kObjectBoundingMode is the default one.; ; ; //Draw a text in the canvas (the object above the text will be; //semi-transparent):; auto t = new TText(0.05, 0.7, ""Can you see the text?"");; t->Draw();; ; //We create a nested pad on top to render a TPie in,; //this way we still have a text (below) + TPie with; //a fancy colour on top.; auto pad = new TPad(""p"", ""p"", 0., 0., 1., 1.);; ; //TPad itself is fully transparent:; auto transparentFill = TColor::GetColor((Float_t) 1., 1., 1., 0.);; pad->SetFillColor(transparentFill);; //Add our pad into",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gl_2gradients_8C.html:92,Load,Loading,92,doc/master/gl_2gradients_8C.html,https://root.cern,https://root.cern/doc/master/gl_2gradients_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/gl/gviz3d.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. gviz3d.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; Simple TStructViewer tutorial. ; ; #include ""TRandom.h""; #include ""TList.h""; #include ""TROOT.h""; #include ""TStructViewer.h""; ; const Int_t ncl =12;; const char *clnames[ncl] = {""TH1F"",""TGraph"",""TGraphErrors"",""TF1"",""TPaveText"",; ""TAxis"",""TF2"",""TH2D"",""TLatex"",""TText"",""TCutG"",""THnSparseF""};; ; // Function creating elements of lists; void MakeCrazy(TList *list, Int_t maxDepth, Int_t maxObjects, Float_t pList); {; Int_t nobj = gRandom->Uniform(0,maxObjects);; for (Int_t i = 0; i < nobj; i++) {; if (maxDepth && gRandom->Rndm() < pList) {; TList *slist = new TList();; slist->SetName(Form(""list_%d_%d"",maxDepth,i));; list->Add(slist);; MakeCrazy(slist,maxDepth-1,maxObjects,pList);; } else {; Int_t icl = (Int_t)gRandom->Uniform(0,ncl);; TNamed *named = (TNamed*)gROOT->ProcessLine(Form(""new %s;"",clnames[icl]));; named->SetName(Form(""%s_%d_%d"",clnames[icl],maxDepth,i));; list->Add(named);; }; }; }; ; // function creating a hierarchy of objects to test the TStructViewer; TList *crazy(Int_t maxDepth=5, Int_t maxObjects=20, Float_t pList=0.2); {; TList *list = new TList();; list->SetName(""SuperList"");; MakeCrazy(list,maxDepth,maxObjects,pList);; gROOT->GetListOfTasks()->Add(list);; return list;; }; ; // function adding colors to viewer; void FillColorsMap(TStructViewer* sv); {; for (int i = 0; i < ncl ; i++); sv->SetColor(clnames[i], (Int_t)gRandom->Integer(8)+2);; }; ; void gviz3d(); {; // Creating a pointer to list; TList* pointer = crazy(2,10);; ; // Creating a viewer; TStructViewer* sv = new TStructViewer(pointer);; ; // adding colors; FillColorsMap(sv);; ; sv->Draw();; }; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; TList.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gviz3d_8C.html:89,Load,Loading,89,doc/master/gviz3d_8C.html,https://root.cern,https://root.cern/doc/master/gviz3d_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/gl/nucleus.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. nucleus.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; Model of a nucleus built from TGeo classes. ; ; void nucleus(Int_t nProtons = 40,Int_t nNeutrons = 60); {; Double_t NeutronRadius = 60,; ProtonRadius = 60,; NucleusRadius,; distance = 60;; Double_t vol = nProtons + nNeutrons;; vol = 3 * vol / (4 * TMath::Pi());; ; NucleusRadius = distance * TMath::Power(vol, 1./3.);; // cout << ""NucleusRadius: "" << NucleusRadius << endl;; ; TGeoManager * geom = new TGeoManager(""nucleus"", ""Model of a nucleus"");; geom->SetNsegments(40);; TGeoMaterial *matEmptySpace = new TGeoMaterial(""EmptySpace"", 0, 0, 0);; TGeoMaterial *matProton = new TGeoMaterial(""Proton"" , .938, 1., 10000.);; TGeoMaterial *matNeutron = new TGeoMaterial(""Neutron"" , .935, 0., 10000.);; ; TGeoMedium *EmptySpace = new TGeoMedium(""Empty"", 1, matEmptySpace);; TGeoMedium *Proton = new TGeoMedium(""Proton"", 1, matProton);; TGeoMedium *Neutron = new TGeoMedium(""Neutron"",1, matNeutron);; ; // the space where the nucleus lives (top container volume); ; Double_t worldx = 200.;; Double_t worldy = 200.;; Double_t worldz = 200.;; ; TGeoVolume *top = geom->MakeBox(""WORLD"", EmptySpace, worldx, worldy, worldz);; geom->SetTopVolume(top);; ; TGeoVolume * proton = geom->MakeSphere(""proton"", Proton, 0., ProtonRadius);; TGeoVolume * neutron = geom->MakeSphere(""neutron"", Neutron, 0., NeutronRadius);; proton->SetLineColor(kRed);; neutron->SetLineColor(kBlue);; ; Double_t x, y, z, dummy;; Int_t i = 0;; while ( i< nProtons) {; gRandom->Rannor(x, y);; gRandom->Rannor(z,dummy);; if ( TMath::Sqrt(x*x + y*y + z*z) < 1) {; x = (2 * x - 1) * NucleusRadius;; y = (2 * y - 1) * NucleusRadius;; z = (2 * z - 1) * NucleusRadius;; top->AddNode(proton, i, new TGeoTranslation(x, y, z));; i++;; }; }; i = 0;; while ( i < nNeutrons) {; gRandom->Rannor(x, y);; gRandom->Rannor(z,dummy);; if ( TMath::Sqrt(x*x + ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/nucleus_8C.html:90,Load,Loading,90,doc/master/nucleus_8C.html,https://root.cern,https://root.cern/doc/master/nucleus_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/gl/parallelcoordtrans.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. parallelcoordtrans.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; Script illustrating the use of transparency with ||-Coord. ; It displays the same data set twice. The first time without transparency and the second time with transparency. On the second plot, several clusters appear. ; #include ""TFile.h""; #include ""TCanvas.h""; #include ""TStyle.h""; #include ""TRandom.h""; #include ""TNtuple.h""; #include ""TParallelCoord.h""; #include ""TParallelCoordVar.h""; #include ""TParallelCoordRange.h""; ; Double_t r1,r2,r3,r4,r5,r6,r7,r8,r9;; Double_t dr = 3.5;; TRandom *r;; ; void generate_random(Int_t i) {; r->Rannor(r1,r4);; r->Rannor(r7,r9);; r2 = (2*dr*r->Rndm(i))-dr;; r3 = (2*dr*r->Rndm(i))-dr;; r5 = (2*dr*r->Rndm(i))-dr;; r6 = (2*dr*r->Rndm(i))-dr;; r8 = (2*dr*r->Rndm(i))-dr;; }; ; void parallelcoordtrans() {; Double_t x,y,z,u,v,w,a,b,c;; Double_t s1x, s1y, s1z;; Double_t s2x, s2y, s2z;; Double_t s3x, s3y, s3z;; r = new TRandom();;; ; auto c1 = new TCanvas(""c1"", ""c1"",0,0,900,1000);; c1->Divide(1,2);; ; auto nt = new TNtuple(""nt"",""Demo ntuple"",""x:y:z:u:v:w:a:b:c"");; ; int n=0;; for (Int_t i=0; i<1500; i++) {; r->Sphere(s1x, s1y, s1z, 0.1);; r->Sphere(s2x, s2y, s2z, 0.2);; r->Sphere(s3x, s3y, s3z, 0.05);; ; generate_random(i);; nt->Fill(r1, r2, r3, r4, r5, r6, r7, r8, r9);; n++;; ; generate_random(i);; nt->Fill(s1x, s1y, s1z, s2x, s2y, s2z, r7, r8, r9);; n++;; ; generate_random(i);; nt->Fill(r1, r2, r3, r4, r5, r6, r7, s3y, r9);; n++;; ; generate_random(i);; nt->Fill(s2x-1, s2y-1, s2z, s1x+.5, s1y+.5, s1z+.5, r7, r8, r9);; n++;; ; generate_random(i);; nt->Fill(r1, r2, r3, r4, r5, r6, r7, r8, r9);; n++;; ; generate_random(i);; nt->Fill(s1x+1, s1y+1, s1z+1, s3x-2, s3y-2, s3z-2, r7, r8, r9);; n++;; ; generate_random(i);; nt->Fill(r1, r2, r3, r4, r5, r6, s3x, r8, s3z );; n++;; }; ; TParallelCoordVar* pcv;; ; c1->cd(1);; ; // ||-C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gl_2parallelcoordtrans_8C.html:101,Load,Loading,101,doc/master/gl_2parallelcoordtrans_8C.html,https://root.cern,https://root.cern/doc/master/gl_2parallelcoordtrans_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/gl/radialgradients.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. radialgradients.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; This tutorial demonstrates how to use radial gradients, custom colors, transparency. ; Requires OpenGL or Web-based canvas. ; //Includes for ACLiC:; #include ""TColorGradient.h""; #include ""TEllipse.h""; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""TStyle.h""; #include ""TError.h""; ; //______________________________________________________________________; Color_t CreateRandomGradientFill(); {; std::vector<Int_t> colors;; ; for (int n = 0; n < 2; ++n); colors.emplace_back(gRandom->Integer(10) + 2);; ; auto indx = TColor::GetRadialGradient(0.5, colors);; ; // example how to modify gradient; auto gradient = dynamic_cast<TRadialGradient *> (gROOT->GetColor(indx));; if (gradient) {; // change center and radius; gradient->SetRadialGradient({0.3, 0.3}, 0.7);; // change alpha parameter for the colors; ; gradient->SetColorAlpha(0, 0.2 + gRandom->Rndm() * 0.8);; gradient->SetColorAlpha(1, 0.2 + gRandom->Rndm() * 0.8);; } else {; ::Error(""CreateRandomGradientFill"", ""failed to find new gradient color with index %d"", indx);; }; ; return indx;; }; ; //______________________________________________________________________; bool add_ellipse(const Double_t xC, const Double_t yC, const Double_t r); {; const Color_t newColor = CreateRandomGradientFill();; if (newColor == -1) {; ::Error(""add_ellipse"", ""failed to find a new color index for a gradient fill"");; return false;; }; ; TEllipse * const newEllipse = new TEllipse(xC, yC, r, r);; newEllipse->SetFillColor(newColor);; newEllipse->Draw();; ; return true;; }; ; //______________________________________________________________________; void radialgradients(bool gl = true); {; gRandom->SetSeed(4357);; ; gStyle->SetCanvasPreferGL(gl);; ; auto cnv = new TCanvas(""radialgradients"", ""radial gradients"", 800, 800);; if (!cn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gl_2radialgradients_8C.html:98,Load,Loading,98,doc/master/gl_2radialgradients_8C.html,https://root.cern,https://root.cern/doc/master/gl_2radialgradients_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/gl/transp.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. transp.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; This demo shows how to use transparency. . ; //Includes for ACLiC (cling does not need them).; #include ""TCanvas.h""; #include ""TColor.h""; #include ""TError.h""; #include ""TStyle.h""; #include ""TH1F.h""; ; void transp(bool gl = true); {; auto redIndex = TColor::GetColor((Float_t) 1., 0., 0., 0.85);; auto greeIndex = TColor::GetColor((Float_t) 0., 1., 0., 0.5);; ; gStyle->SetCanvasPreferGL(kTRUE);; auto cnv = new TCanvas(""trasnparency"", ""transparency demo"", 600, 400);; ; auto hist = new TH1F(""a5"", ""b5"", 10, -2., 3.);; auto hist2 = new TH1F(""c6"", ""d6"", 10, -3., 3.);; hist->FillRandom(""landau"", 100000);; hist2->FillRandom(""gaus"", 100000);; ; hist->SetFillColor(redIndex);; hist2->SetFillColor(greeIndex);; ; cnv->cd();; hist2->Draw();; hist->Draw(""SAME"");; }; Float_tfloat Float_tDefinition RtypesCore.h:57; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TCanvas.h; TColor.h; TError.h; TH1F.h; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color number for color specified by hex color string of form: ""#rrggbb"",...Definition TColor.cxx:1920; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TStyle::SetCanvasPreferGLvoid SetCanvasPreferGL(Bool_t prefer=kTRUE)Definition TStyle.h:341; AuthorsTimur Pocheptsov, Sergey Linev ; Definition in file transp.C. tutorialsgltransp.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gl_2transp_8C.html:89,Load,Loading,89,doc/master/gl_2transp_8C.html,https://root.cern,https://root.cern/doc/master/gl_2transp_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/gl/transp_text.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. transp_text.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; This macro is based on labels1.C by Rene Brun. ; Updated by Timur Pocheptsov to use transparent text. The macro requires OpenGL or Web-based canvas. ; //Includes for ACLiC (cling does not need them).; #include ""TPaveText.h""; #include ""TCanvas.h""; #include ""TRandom.h""; #include ""TError.h""; #include ""TColor.h""; #include ""TStyle.h""; #include ""TH1F.h""; ; void transp_text(bool gl = true); {; // 1. Create special transparent colors for both pavetext fill color and text color.; auto grayColorIndex = TColor::GetColor((Float_t) 0.8, 0.8, 0.8, 0.85);; auto blackColorIndex = TColor::GetColor((Float_t) 0., 0., 0., 0.5);; ; // 2. Create a TCanvas.; gStyle->SetCanvasPreferGL(gl);; ; auto c1 = new TCanvas(""transp_text"",""transparent text demo"", 10, 10, 900, 500);; if (!c1->UseGL() && !c1->IsWeb()); ::Warning(""transp_text"", ""to use this macro you need either OpenGL or Web"");; ; c1->SetGrid();; c1->SetBottomMargin(0.15);; ; const Int_t nx = 20;; const char *people[nx] = {""Jean"",""Pierre"",""Marie"",""Odile"",; ""Sebastien"",""Fons"",""Rene"",""Nicolas"",""Xavier"",""Greg"",; ""Bjarne"",""Anton"",""Otto"",""Eddy"",""Peter"",""Pasha"",; ""Philippe"",""Suzanne"",""Jeff"",""Valery""};; ; auto h = new TH1F(""h4"", ""test"", nx, 0, nx);; ; h->SetFillColor(38);; for (Int_t i = 0; i < 5000; ++i); h->Fill(gRandom->Gaus(0.5 * nx, 0.2 * nx));; ; h->SetStats(false);; for (Int_t i = 1; i <= nx; ++i); h->GetXaxis()->SetBinLabel(i, people[i - 1]);; ; h->Draw();; ; auto pt = new TPaveText(0.3, 0.3, 0.98, 0.98, ""brNDC"");; //Transparent 'rectangle' with transparent text.; pt->SetFillColor(grayColorIndex);; pt->SetTextColor(blackColorIndex);; ; pt->SetTextSize(0.5);; pt->SetTextAlign(12);; ; pt->AddText(""Hello"");; pt->Draw();; }; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gl_2transp__text_8C.html:94,Load,Loading,94,doc/master/gl_2transp__text_8C.html,https://root.cern,https://root.cern/doc/master/gl_2transp__text_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/gl/transparentpad.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. transparentpad.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; This macro demonstrates semi-transparent pads. ; Requires OpenGL or Web-based canvas. ; //Includes for ACLiC (cling does not need them).; #include ""TCanvas.h""; #include ""TStyle.h""; #include ""TError.h""; #include ""TColor.h""; #include ""TH1F.h""; ; void transparentpad(bool gl = true); {; gStyle->SetCanvasPreferGL(gl);; ; // 1. Create canvas and check if it support transparent colors; auto c1 = new TCanvas(""transparentpad"",""transparent pad demo"", 10, 10, 900, 500);; if (!c1->UseGL() && !c1->IsWeb()); ::Warning(""transparentpad"", ""You can see the transparency ONLY in a pdf or png output (\""File\""->\""Save As\"" ->...)\n""; ""To have transparency in a canvas graphics, you need either OpenGL or Web rendering enabled"");; ; // 2. Some arbitrary histograms.; auto h1 = new TH1F(""TH1F 1"", ""TH1F 1"", 100, -1.5, 1.5);; h1->FillRandom(""gaus"");; ; auto h2 = new TH1F(""TH1F 2"", ""TH1F 2"", 100, -1.5, 0.);; h2->FillRandom(""gaus"");; ; auto h3 = new TH1F(""TH1F 3"", ""TH1F 3"", 100, 0.5, 2.);; h3->FillRandom(""landau"");; ; // 3. Now overlapping transparent pads.; auto pad1 = new TPad(""transparent pad 1"", ""transparent pad 1"", 0.1, 0.1, 0.7, 0.7);; pad1->SetFillColor(TColor::GetColor((Float_t) 1., 0.2, 0.2, 0.25)); // transparent pink, here's the magic!; c1->cd();; pad1->Draw();; pad1->cd();; h1->Draw(""lego2"");; ; auto pad2 = new TPad(""transparent pad 2"", ""transparent pad 2"", 0.2, 0.2, 0.8, 0.8);; pad2->SetFillColor(TColor::GetColor((Float_t) 0.2, 1., 0.2, 0.25)); // transparent green, here's the magic!; c1->cd();; pad2->Draw();; pad2->cd();; h2->Draw();; ; auto pad3 = new TPad(""transparent pad 3"", ""transparent pad 3"", 0.3, 0.3, 0.9, 0.9);; pad3->SetFillColor(TColor::GetColor((Float_t) 0.2, 1., 1., 0.15)); // transparent blue, here's the magic!; c1->cd();; pad3->Draw();; pad3->cd();; h3->Dr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gl_2transparentpad_8C.html:97,Load,Loading,97,doc/master/gl_2transparentpad_8C.html,https://root.cern,https://root.cern/doc/master/gl_2transparentpad_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/gl/viewer3DLocal.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. viewer3DLocal.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; Demonstrates 3D viewer architecture TVirtualViewer3D and TBuffer3D in the local frame. ; Here each shape is described in a TBuffer3D class, with a suitible translation matrix to place each instance NOTE: to be executed via .x viewer3DLocal.C+; NOTE: We don't implement raw tesselation of sphere - hence this will not appear in viewers which don't support directly (non-OpenGL) Shows that viewers can at least deal gracefully with these cases; Our abstract base shape class.; As we overload TObject::Paint which is called directly from compiled code, this script must also be compiled to work correctly.; #if defined(__CINT__) && !defined(__MAKECINT__); {; gSystem->CompileMacro(""viewer3DLocal.C"");; viewer3DLocal();; }; #else; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::CompileMacrovirtual int CompileMacro(const char *filename, Option_t *opt="""", const char *library_name="""", const char *build_dir="""", UInt_t dirmode=0)This method compiles and loads a shared library containing the code from the file ""filename"".Definition TSystem.cxx:2836; ; #include ""TVirtualViewer3D.h""; #include ""TBuffer3D.h""; #include ""TBuffer3DTypes.h""; ; #include ""TObject.h""; #include ""TVirtualPad.h""; #include ""TAtt3D.h""; ; #include <vector>; ; class Shape : public TObject; {; public:; Shape(Int_t color, Double_t x, Double_t y, Double_t z);; ~Shape() override {};; virtual TBuffer3D & GetBuffer3D(UInt_t reqSections) = 0;; ; protected:; Double_t fX, fY, fZ; // Origin; Int_t fColor;; ; ClassDefOverride(Shape,0);; };; ; ClassImp(Shape);; ; Shape::Shape(Int_t color, Double_t x, Double_t y, Double_t z) :; fX(x), fY(y), fZ(z), fColor(color); {}; ; class Sphere : public Shape; {; public:; Sphere(Int_t color, Double_t x, Double_t y, Double_t z, Double_t radius);; ~Sphere() override",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/viewer3DLocal_8C.html:96,Load,Loading,96,doc/master/viewer3DLocal_8C.html,https://root.cern,https://root.cern/doc/master/viewer3DLocal_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/gl/viewer3DMaster.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. viewer3DMaster.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; Demonstrates 3D viewer architecture TVirtualViewer3D and TBuffer3D in the master frame. ; Here each shape is described directly in a TBuffer3D class, with identity translation matrix c.f. viewer3DLocal.C; Our abstract base shape class.; As we overload TObject::Paint which is called directly from compiled code, this script must also be compiled to work correctly.; ; ; #include ""TVirtualViewer3D.h""; #include ""TBuffer3D.h""; #include ""TBuffer3DTypes.h""; ; #include ""TObject.h""; #include ""TVirtualPad.h""; #include ""TAtt3D.h""; ; #include <vector>; ; class Shape : public TObject; {; public:; Shape(Int_t color, Double_t x, Double_t y, Double_t z);; ~Shape() override {};; virtual TBuffer3D & GetBuffer3D(UInt_t reqSections) = 0;; ; protected:; Double_t fX, fY, fZ; // Origin; Int_t fColor;; ; ClassDefOverride(Shape,0);; };; ; ClassImp(Shape);; ; Shape::Shape(Int_t color, Double_t x, Double_t y, Double_t z) :; fX(x), fY(y), fZ(z), fColor(color); {}; ; class Box : public Shape; {; public:; Box(Int_t color, Double_t x, Double_t y, Double_t z,; Double_t dX, Double_t dY, Double_t dZ);; ~Box() override {};; ; TBuffer3D & GetBuffer3D(UInt_t reqSections) override;; ; private:; Double_t fDX, fDY, fDZ; // Half lengths; ; ClassDefOverride(Box,0);; };; ; ClassImp(Box);; ; Box::Box(Int_t color, Double_t x, Double_t y, Double_t z,; Double_t dX, Double_t dY, Double_t dZ) :; Shape(color,x,y,z),; fDX(dX), fDY(dY), fDZ(dZ); {}; ; TBuffer3D & Box::GetBuffer3D(UInt_t reqSections); {; static TBuffer3D buffer(TBuffer3DTypes::kGeneric);; ; // Complete kCore section - this could be moved to Shape base class; if (reqSections & TBuffer3D::kCore) {; buffer.ClearSectionsValid();; buffer.fID = this;; buffer.fColor = fColor; // Color index - see gROOT->GetColor(); buffer.fTransparency = 0; // Tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/viewer3DMaster_8C.html:97,Load,Loading,97,doc/master/viewer3DMaster_8C.html,https://root.cern,https://root.cern/doc/master/viewer3DMaster_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/AtlasExample.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. AtlasExample.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Show how ATLAS Style looks like. ; It is based on a style file from BaBar. ; const Int_t GMAX=864;; ; const int nren=3;; static const double mur[nren] = {1.0,0.25,4.0};; static const double muf[nren] = {1.0,0.25,4.0};; const unsigned int NUMPDF=41;; ; TGraphErrors* GetGraph(Int_t ir, Int_t ifs,Int_t icut, Int_t ipdf);; void AddtoBand(TGraphErrors* g1, TGraphAsymmErrors* g2);; TGraphAsymmErrors* MakeBand(TGraphErrors* g0, TGraphErrors* g1,TGraphErrors* g2);; ; void AtlasExample(); {; gROOT->SetStyle(""ATLAS"");; ; Int_t icol1=5;; Int_t icol2=5;; ; auto canvas = new TCanvas(""canvas"",""single inclusive jets"",50,50,600,600);; canvas->SetLogy();; ; Double_t ymin = 1.e-3; Double_t ymax = 2e7;; Double_t xmin = 60.00; Double_t xmax = 3500.;; auto frame = canvas->DrawFrame(xmin,ymin,xmax,ymax);; frame->SetYTitle(""d#sigma_{jet}/dE_{T,jet} [fb/GeV]"");; frame->SetXTitle(""E_{T,jet} [GeV]"");; frame->GetYaxis()->SetTitleOffset(1.4);; frame->GetXaxis()->SetTitleOffset(1.4);; ; const Int_t ncut=1;; TGraphErrors *data[ncut];; ; for (Int_t icut=0; icut<ncut; icut++) { // loop over cuts; TGraphErrors *g1[nren][ncut];; for (Int_t ir=0; ir<nren; ir++) { // loop over ren scale; g1[ir][icut] = GetGraph(ir,ir,icut,0);; if (!g1[ir][icut]) {; cout << "" g1 not found "" << endl;; return;; }; g1[ir][icut]->SetLineColor(1);; g1[ir][icut]->SetMarkerStyle(0);; }; ; char daname[100];; sprintf(daname,""data_%d"",icut);; data[icut] = (TGraphErrors*)g1[0][icut]->Clone(daname);; data[icut]->SetMarkerStyle(20);; data[icut]->SetMarkerColor(1);; ; // Just invent some data; for (Int_t i=0; i< data[icut]->GetN(); i++) {; Double_t x1,y1,e,dx1=0.;; data[icut]->GetPoint(i,x1,y1);; Double_t r1 = 0.4*(gRandom->Rndm(1)+2);; Double_t r2 = 0.4*(gRandom->Rndm(1)+2);; Double_t y;; if (icut==0) y = r1*y1+r1*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/AtlasExample_8C.html:101,Load,Loading,101,doc/master/AtlasExample_8C.html,https://root.cern,https://root.cern/doc/master/AtlasExample_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/accessiblecolorschemes.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. accessiblecolorschemes.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Choosing an appropriate color scheme is essential for making results easy to understand and interpret. ; Factors like colorblindness and converting colors to grayscale for publications can impact accessibility. Furthermore, results should be aesthetically pleasing. The following three color schemes, recommended by M. Petroff in arXiv:2107.02270v2 and available on GitHub under the MIT License, meet these criteria. ; void box(double x1, double y1, double x2, double y2,int col) {; auto b1 = new TBox(x1, y1, x2, y2);; b1->SetFillColor(col);; b1->Draw();; ; TColor *c = gROOT->GetColor(col);; auto tc = new TLatex((x2+x1)/2., 0.01+(y2+y1)/2., Form(""#splitline{%s}{%s}"",c->GetName(),c->GetTitle()));; tc->SetTextFont(42);; tc->SetTextAlign(23);; tc->SetTextSize(0.020);; tc->Draw();; }; ; void accessiblecolorschemes() {; auto C = new TCanvas(""C"",""C"",600,800);; int c;; double x, y;; double w = 0.2;; double h = 0.08;; auto t = new TText();; t->SetTextSize(0.025);; t->SetTextFont(42);; ; // 6-colors scheme; x = 0.1;; y = 0.1;; t->DrawText(x, y-h/2., ""6-colors scheme"");; for (c=kP6Blue; c<kP6Blue+6; c++) {; box(x, y, x+w, y+h,c);; y = y+h;; }; ; // 8-color scheme; y = 0.1;; x = 0.4;; t->DrawText(x, y-h/2., ""8-colors scheme"");; for (c=kP8Blue; c<kP8Blue+8; c++) {; box(x, y, x+w, y+h,c);; y = y+h;; }; ; // 10-color scheme; y = 0.1;; x = 0.7;; t->DrawText(x, y-h/2., ""10-colors scheme"");; for (c=kP10Blue; c<kP10Blue+10; c++) {; box(x, y, x+w, y+h,c);; y = y+h;; }; }; c#define c(i)Definition RSha256.hxx:101; h#define h(i)Definition RSha256.hxx:106; kP8Blue@ kP8BlueDefinition Rtypes.h:70; kP10Blue@ kP10BlueDefinition Rtypes.h:71; kP6Blue@ kP6BlueDefinition Rtypes.h:69; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; x2Option_t Option_t TPoint TPoint",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/accessiblecolorschemes_8C.html:111,Load,Loading,111,doc/master/accessiblecolorschemes_8C.html,https://root.cern,https://root.cern/doc/master/accessiblecolorschemes_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/analyze.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. analyze.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This macro produces the flowchart of TFormula::Analyze. . ; ; void analyze() {; TCanvas *c1 = new TCanvas(""c1"",""Analyze.mac"",620,790);; c1->Range(-1,0,19,30);; TPaveLabel *pl1 = new TPaveLabel(0,27,3.5,29,""Analyze"");; pl1->SetFillColor(42);; pl1->Draw();; TPaveText *pt1 = new TPaveText(0,22.8,4,25.2);; TText *t1 = pt1->AddText(""Parenthesis matching"");; TText *t2 = pt1->AddText(""Remove unnecessary"");; TText *t2a = pt1->AddText(""parenthesis"");; pt1->Draw();; TPaveText *pt2 = new TPaveText(6,23,10,25);; TText *t3 = pt2->AddText(""break of"");; TText *t4 = pt2->AddText(""Analyze"");; pt2->Draw();; TPaveText *pt3 = new TPaveText(0,19,4,21);; t4=pt3->AddText(""look for simple"");; TText *t5 = pt3->AddText(""operators"");; pt3->Draw();; TPaveText *pt4 = new TPaveText(0,15,4,17);; TText *t6 = pt4->AddText(""look for an already"");; TText *t7 = pt4->AddText(""defined expression"");; pt4->Draw();; TPaveText *pt5 = new TPaveText(0,11,4,13);; TText *t8 = pt5->AddText(""look for usual"");; TText *t9 = pt5->AddText(""functions :cos sin .."");; pt5->Draw();; TPaveText *pt6 = new TPaveText(0,7,4,9);; TText *t10 = pt6->AddText(""look for a"");; TText *t11 = pt6->AddText(""numeric value"");; pt6->Draw();; TPaveText *pt7 = new TPaveText(6,18.5,10,21.5);; TText *t12 = pt7->AddText(""Analyze left and"");; TText *t13 = pt7->AddText(""right part of"");; TText *t14 = pt7->AddText(""the expression"");; pt7->Draw();; TPaveText *pt8 = new TPaveText(6,15,10,17);; TText *t15 = pt8->AddText(""Replace expression"");; pt8->Draw();; TPaveText *pt9 = new TPaveText(6,11,10,13);; TText *t16 = pt9->AddText(""Analyze"");; pt9->SetFillColor(42);; pt9->Draw();; TPaveText *pt10 = new TPaveText(6,7,10,9);; TText *t17 = pt10->AddText(""Error"");; TText *t18 = pt10->AddText(""Break of Analyze"");; pt10->Draw();; TPaveText *pt11 = new T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/analyze_8C.html:96,Load,Loading,96,doc/master/analyze_8C.html,https://root.cern,https://root.cern/doc/master/analyze_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/anim.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. anim.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Macro illustrating how to animate a picture using a Timer. ; ; #include ""TStyle.h""; #include ""TCanvas.h""; #include ""TF2.h""; #include ""TTimer.h""; ; Double_t pi;; TF2 *f2;; Float_t t = 0;; Float_t phi = 30;; void anim(); {; gStyle->SetCanvasPreferGL(true);; gStyle->SetFrameFillColor(42);; TCanvas *c1 = new TCanvas(""c1"");; c1->SetFillColor(17);; pi = TMath::Pi();; f2 = new TF2(""f2"",""sin(2*x)*sin(2*y)*[0]"",0,pi,0,pi);; f2->SetParameter(0,1);; f2->SetNpx(15);; f2->SetNpy(15);; f2->SetMaximum(1);; f2->SetMinimum(-1);; f2->Draw(""glsurf1"");; TTimer *timer = new TTimer(20);; timer->SetCommand(""Animate()"");; timer->TurnOn();; }; void Animate(); {; //just in case the canvas has been deleted; if (!gROOT->GetListOfCanvases()->FindObject(""c1"")) return;; t += 0.05*pi;; f2->SetParameter(0,TMath::Cos(t));; phi += 2;; gPad->SetPhi(phi);; gPad->Modified();; gPad->Update();; }; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; TCanvas.h; TF2.h; gROOT#define gROOTDefinition TROOT.h:406; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TTimer.h; gPad#define gPadDefinition TVirtualPad.h:308; TCanvasThe Canvas class.Definition TCanvas.h:23; TF1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Set the maximum value along Y for this function In case the function is already drawn,...Definition TF1.cxx:3394; TF1::SetNpxvirtual void SetNpx(Int_t npx=100)Set the number of points used to draw the function.Definition TF1.cxx:3433; TF1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Set the minimum value along Y for this function In case the function is already drawn,...Definition TF1.cxx:3407; TF1::SetParametervirtual void SetParameter(Int_t param, Double_t value)Definition TF1.h:667; TF2A 2-Dim function with par",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/anim_8C.html:93,Load,Loading,93,doc/master/anim_8C.html,https://root.cern,https://root.cern/doc/master/anim_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/archi.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. archi.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This macro displays the ROOT architecture. . ; void archi() {; TCanvas *c1 = new TCanvas(""c1"",""Dictionary Architecture"",20,10,750,930);; c1->SetBorderSize(0);; c1->Range(0,0,20.5,26);; ; ; TPaveLabel *title = new TPaveLabel(4,24,16,25.5,c1->GetTitle());; title->SetFillColor(46);; title->Draw();; ; TPavesText *dll = new TPavesText(0.5,19,4.5,23,5,""tr"");; dll->SetFillColor(39);; dll->SetTextSize(0.023);; dll->AddText("" "");; dll->AddText(""Dynamically"");; dll->AddText(""Linked"");; dll->AddText(""Libraries"");; dll->Draw();; TPaveLabel *dlltitle = new TPaveLabel(1.5,22.6,3.5,23.3,""DLLs"");; dlltitle->SetFillColor(28);; dlltitle->Draw();; ; TPavesText *cpp = new TPavesText(5.5,19,9.5,23,5,""tr"");; cpp->SetTextSize(0.023);; cpp->AddText("" "");; cpp->AddText(""Commented"");; cpp->AddText(""Header"");; cpp->AddText(""Files"");; cpp->Draw();; TPaveLabel *cpptitle = new TPaveLabel(6.5,22.6,8.5,23.3,""C++"");; cpptitle->SetFillColor(28);; cpptitle->Draw();; ; TPavesText *odl = new TPavesText(10.5,19,14.5,23,5,""tr"");; odl->SetTextSize(0.023);; odl->AddText("" "");; odl->AddText(""Objects"");; odl->AddText(""Description"");; odl->AddText(""Files"");; odl->Draw();; TPaveLabel *odltitle = new TPaveLabel(11.5,22.6,13.5,23.3,""ODL"");; odltitle->SetFillColor(28);; odltitle->Draw();; ; TPavesText *idl = new TPavesText(15.5,19,19.5,23,5,""tr"");; idl->SetTextSize(0.023);; idl->AddText("" "");; idl->AddText(""Interface"");; idl->AddText(""Definition"");; idl->AddText(""Language"");; idl->Draw();; TPaveLabel *idltitle = new TPaveLabel(16.5,22.6,18.5,23.3,""IDL"");; idltitle->SetFillColor(28);; idltitle->Draw();; ; TWbox *p1 = new TWbox(7.8,10,13.2,17,11,12,1);; p1->Draw();; TText *pro1 = new TText(10.5,15.8,""Process 1"");; pro1->SetTextAlign(21);; pro1->SetTextSize(0.03);; pro1->Draw();; TPaveText *p1dict = new TPaveText",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/archi_8C.html:94,Load,Loading,94,doc/master/archi_8C.html,https://root.cern,https://root.cern/doc/master/archi_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/arrows.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. arrows.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Draw arrows. . ; void arrows(){; auto c1 = new TCanvas(""c1"");; c1->Range(0,0,1,1);; ; auto par = new TPaveLabel(0.1,0.8,0.9,0.95,""Examples of various arrows formats"");; par->SetFillColor(42);; par->Draw();; ; auto ar1 = new TArrow(0.1,0.1,0.1,0.7);; ar1->Draw();; auto ar2 = new TArrow(0.2,0.1,0.2,0.7,0.05,""|>"");; ar2->SetAngle(40);; ar2->SetLineWidth(2);; ar2->Draw();; auto ar3 = new TArrow(0.3,0.1,0.3,0.7,0.05,""<|>"");; ar3->SetAngle(40);; ar3->SetLineWidth(2);; ar3->Draw();; auto ar4 = new TArrow(0.46,0.7,0.82,0.42,0.07,""|>"");; ar4->SetAngle(60);; ar4->SetLineWidth(2);; ar4->SetFillColor(2);; ar4->Draw();; auto ar5 = new TArrow(0.4,0.25,0.95,0.25,0.15,""<|>"");; ar5->SetAngle(60);; ar5->SetLineWidth(4);; ar5->SetLineColor(4);; ar5->SetFillStyle(3008);; ar5->SetFillColor(2);; ar5->Draw();; }; TArrowDraw all kinds of Arrows.Definition TArrow.h:29; TCanvasThe Canvas class.Definition TCanvas.h:23; TPaveLabelA Pave (see TPave) with a text centered in the Pave.Definition TPaveLabel.h:20; c1return c1Definition legend1.C:41; AuthorRene Brun ; Definition in file arrows.C. tutorialsgraphicsarrows.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/arrows_8C.html:95,Load,Loading,95,doc/master/arrows_8C.html,https://root.cern,https://root.cern/doc/master/arrows_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/basic3d.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. basic3d.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Show 3-D polylines and markers. . ; void basic3d(){; TCanvas *c1 = new TCanvas(""c1"",""PolyLine3D & PolyMarker3D Window"",200,10,700,500);; ; // create a pad; TPad *p1 = new TPad(""p1"",""p1"",0.05,0.02,0.95,0.82,46,3,1);; p1->Draw();; p1->cd();; ; // creating a view; TView *view = TView::CreateView(1);; view->SetRange(5,5,5,25,25,25);; ; // create a first PolyLine3D; TPolyLine3D *pl3d1 = new TPolyLine3D(5);; ; // set points; pl3d1->SetPoint(0, 10, 10, 10);; pl3d1->SetPoint(1, 15, 15, 10);; pl3d1->SetPoint(2, 20, 15, 15);; pl3d1->SetPoint(3, 20, 20, 20);; pl3d1->SetPoint(4, 10, 10, 20);; // set attributes; pl3d1->SetLineWidth(3);; pl3d1->SetLineColor(5);; ; // create a second PolyLine3D; TPolyLine3D *pl3d2 = new TPolyLine3D(4);; ; // set points; pl3d2->SetPoint(0, 5, 10, 5);; pl3d2->SetPoint(1, 10, 15, 8);; pl3d2->SetPoint(2, 15, 15, 18);; pl3d2->SetPoint(3, 5, 20, 20);; pl3d2->SetPoint(4, 10, 10, 5);; ; // set attributes; pl3d2->SetLineWidth(5);; pl3d2->SetLineColor(2);; ; // create a first PolyMarker3D; TPolyMarker3D *pm3d1 = new TPolyMarker3D(12);; ; // set points; pm3d1->SetPoint(0, 10, 10, 10);; pm3d1->SetPoint(1, 11, 15, 11);; pm3d1->SetPoint(2, 12, 15, 9);; pm3d1->SetPoint(3, 13, 17, 20);; pm3d1->SetPoint(4, 14, 16, 15);; pm3d1->SetPoint(5, 15, 20, 15);; pm3d1->SetPoint(6, 16, 18, 10);; pm3d1->SetPoint(7, 17, 15, 10);; pm3d1->SetPoint(8, 18, 22, 15);; pm3d1->SetPoint(9, 19, 28, 25);; pm3d1->SetPoint(10, 20, 12, 15);; pm3d1->SetPoint(11, 21, 12, 15);; ; // set marker size, color & style; pm3d1->SetMarkerSize(2);; pm3d1->SetMarkerColor(4);; pm3d1->SetMarkerStyle(2);; ; // create a second PolyMarker3D; TPolyMarker3D *pm3d2 = new TPolyMarker3D(8);; ; pm3d2->SetPoint(0, 22, 15, 15);; pm3d2->SetPoint(1, 23, 18, 21);; pm3d2->SetPoint(2, 24, 26, 13);; pm3d2->SetPoint",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/basic3d_8C.html:96,Load,Loading,96,doc/master/basic3d_8C.html,https://root.cern,https://root.cern/doc/master/basic3d_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/canvas.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. canvas.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Example of primitives in a canvas. ; One of the first actions in a ROOT session is the creation of a Canvas. Here we create a Canvas named ""c1"".; After having executed this macro, try now to point on any object on the screen: pad, text, lines, etc.; When the cursor points to sensitive areas in an object, the cursor shape changes and suggests the type of action that can be applied.; For example:; One can move, grow,shrink a pad.; A text can be moved.; A line can be moved or its end points can be modified.; One can move, grow and shrink PaveLabels and PavesText. Point to an object and click the right mouse button to change attributes. Try to change the canvas size.; In the canvas ""File"" menu, select the option ""Print"" to produce a PostScript file with a copy of the canvas. ; void canvas(){; TCanvas *c1 = new TCanvas(""c1"",""Canvas Example"",200,10,600,480);; ; gBenchmark->Start(""canvas"");; ; // Inside this canvas, we create two pads; TPad *pad1 = new TPad(""pad1"",""This is pad1"",0.05,0.52,0.95,0.97);; TPad *pad2 = new TPad(""pad2"",""This is pad2"",0.05,0.02,0.95,0.47);; pad1->SetFillColor(11);; pad2->SetFillColor(11);; pad1->Draw();; pad2->Draw();; ; // A pad may contain other pads and graphics objects.; // We set the current pad to pad2.; // Note that the current pad is always highlighted.; pad2->cd();; TPad *pad21 = new TPad(""pad21"",""First subpad of pad2"",0.02,0.05,0.48,0.95,17,3);; TPad *pad22 = new TPad(""pad22"",""Second subpad of pad2"",0.52,0.05,0.98,0.95,17,3);; pad21->Draw();; pad22->Draw();; ; // We enter some primitives in the created pads and set some attributes; pad1->cd();; float xt1 = 0.5;; float yt1 = 0.1;; TText *t1 = new TText(0.5,yt1,""ROOT"");; t1->SetTextAlign(22);; t1->SetTextSize(0.05);; t1->Draw();; TLine *line1 = new TLine(0.05,0.05,0.80,0.70);; line1-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/canvas_8C.html:95,Load,Loading,95,doc/master/canvas_8C.html,https://root.cern,https://root.cern/doc/master/canvas_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/canvas2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. canvas2.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Example of canvas partitioning. ; Sometimes the Divide() method is not appropriate to divide a Canvas. Because of the left and right margins, all the pads do not have the same width and height. CanvasPartition does that properly. This example also ensure that the axis labels and titles have the same sizes and that the tick marks length is uniform. In addition, XtoPad and YtoPad allow to place graphics objects like text in the right place in each sub-pads. ; void CanvasPartition(TCanvas *C,const Int_t Nx = 2,const Int_t Ny = 2,; Float_t lMargin = 0.15, Float_t rMargin = 0.05,; Float_t bMargin = 0.15, Float_t tMargin = 0.05);; double XtoPad(double x);; double YtoPad(double x);; ; void canvas2(); {; gStyle->SetOptStat(0);; ; auto C = (TCanvas*) gROOT->FindObject(""C"");; if (C) delete C;; C = new TCanvas(""C"",""canvas"",1024,640);; C->SetFillStyle(4000);; ; // Number of PADS; const Int_t Nx = 5;; const Int_t Ny = 5;; ; // Margins; Float_t lMargin = 0.12;; Float_t rMargin = 0.05;; Float_t bMargin = 0.15;; Float_t tMargin = 0.05;; ; // Canvas setup; CanvasPartition(C,Nx,Ny,lMargin,rMargin,bMargin,tMargin);; ; // Dummy histogram.; auto h = (TH1F*) gROOT->FindObject(""histo"");; if (h) delete h;; h = new TH1F(""histo"","""",100,-5.0,5.0);; h->FillRandom(""gaus"",10000);; h->GetXaxis()->SetTitle(""x axis"");; h->GetYaxis()->SetTitle(""y axis"");; ; TPad *pad[Nx][Ny];; ; for (Int_t i = 0; i < Nx; i++) {; for (Int_t j = 0; j < Ny; j++) {; C->cd(0);; ; // Get the pads previously created.; pad[i][j] = (TPad*) C->FindObject(TString::Format(""pad_%d_%d"",i,j).Data());; pad[i][j]->Draw();; pad[i][j]->SetFillStyle(4000);; pad[i][j]->SetFrameFillStyle(4000);; pad[i][j]->cd();; ; // Size factors; Float_t xFactor = pad[0][0]->GetAbsWNDC()/pad[i][j]->GetAbsWNDC();; Float_t yFactor = pad[0][0]->Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/canvas2_8C.html:96,Load,Loading,96,doc/master/canvas2_8C.html,https://root.cern,https://root.cern/doc/master/canvas2_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/compile.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. compile.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This macro produces the flowchart of TFormula::Compile . ; void compile(){; TCanvas *c1 = new TCanvas(""c1"");; c1->Range(0,0,1,1);; TPaveLabel *ptc = new TPaveLabel(0.02,0.42,0.2,0.58,""Compile"");; ptc->SetTextSize(0.40);; ptc->SetFillColor(32);; ptc->Draw();; TPaveText *psub = new TPaveText(0.28,0.4,0.65,0.6);; psub->Draw();; TText *t2 = psub->AddText(""Substitute some operators"");; TText *t3 = psub->AddText(""to C++ style"");; TPaveLabel *panal = new TPaveLabel(0.73,0.42,0.98,0.58,""Analyze"");; panal->SetTextSize(0.40);; panal->SetFillColor(42);; panal->Draw();; TArrow *ar1 = new TArrow(0.2,0.5,0.27,0.5,0.02,""|>"");; ar1->SetLineWidth(6);; ar1->SetLineColor(4);; ar1->Draw();; TArrow *ar2 = new TArrow(0.65,0.5,0.72,0.5,0.02,""|>"");; ar2->SetLineWidth(6);; ar2->SetLineColor(4);; ar2->Draw();; }; TArrowDraw all kinds of Arrows.Definition TArrow.h:29; TArrow::Drawvoid Draw(Option_t *option="""") overrideDraw this arrow with its current attributes.Definition TArrow.cxx:120; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TPaveLabelA Pave (see TPave) with a text centered in the Pave.Definition TPaveLabel.h:20; TPaveLabel::Drawvoid Draw(Option_t *option="""") overrideDraw this pavelabel with its current attributes.Definition TPaveLabel.cxx:88; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::Add",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/compile_8C.html:96,Load,Loading,96,doc/master/compile_8C.html,https://root.cern,https://root.cern/doc/master/compile_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/crown.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. crown.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Draw crowns. . ; void crown(){; auto c1 = new TCanvas(""c1"",""c1"",400,400);; auto cr1 = new TCrown(.5,.5,.3,.4);; cr1->SetLineStyle(2);; cr1->SetLineWidth(4);; cr1->Draw();; auto cr2 = new TCrown(.5,.5,.2,.3,45,315);; cr2->SetFillColor(38);; cr2->SetFillStyle(3010);; cr2->Draw();; auto cr3 = new TCrown(.5,.5,.2,.3,-45,45);; cr3->SetFillColor(50);; cr3->SetFillStyle(3025);; cr3->Draw();; auto cr4 = new TCrown(.5,.5,.0,.2);; cr4->SetFillColor(4);; cr4->SetFillStyle(3008);; cr4->Draw();; }; TCanvasThe Canvas class.Definition TCanvas.h:23; TCrownTo draw a Crown.Definition TCrown.h:19; c1return c1Definition legend1.C:41; AuthorOlivier Couet ; Definition in file crown.C. tutorialsgraphicscrown.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/crown_8C.html:94,Load,Loading,94,doc/master/crown_8C.html,https://root.cern,https://root.cern/doc/master/crown_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/diamond.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. diamond.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Draw a diamond. . ; void diamond(){; auto d = new TDiamond(.05,.1,.95,.8);; d->AddText(""A TDiamond can contain any text."");; d->Draw();; }; d#define d(i)Definition RSha256.hxx:102; TDiamondDraw a Diamond.Definition TDiamond.h:17; AuthorOlivier Couet ; Definition in file diamond.C. tutorialsgraphicsdiamond.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/diamond_8C.html:96,Load,Loading,96,doc/master/diamond_8C.html,https://root.cern,https://root.cern/doc/master/diamond_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/earth.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. earth.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This tutorial illustrates the special contour options. . ""AITOFF"" : Draw a contour via an AITOFF projection; ""MERCATOR"" : Draw a contour via an Mercator projection; ""SINUSOIDAL"" : Draw a contour via an Sinusoidal projection; ""PARABOLIC"" : Draw a contour via an Parabolic projection; ""MOLLWEIDE"" : Draw a contour via an Mollweide projection. ; TCanvas *earth(){; ; gStyle->SetOptTitle(1);; gStyle->SetOptStat(0);; ; TCanvas *c1 = new TCanvas(""c1"",""earth_projections"",700,1000);; c1->Divide(2,3);; ; TH2F *ha = new TH2F(""ha"",""Aitoff"", 180, -180, 180, 179, -89.5, 89.5);; TH2F *hm = new TH2F(""hm"",""Mercator"", 180, -180, 180, 161, -80.5, 80.5);; TH2F *hs = new TH2F(""hs"",""Sinusoidal"",180, -180, 180, 181, -90.5, 90.5);; TH2F *hp = new TH2F(""hp"",""Parabolic"", 180, -180, 180, 181, -90.5, 90.5);; TH2F *hw = new TH2F(""hw"",""Mollweide"", 180, -180, 180, 181, -90.5, 90.5);; ; TString dat = gROOT->GetTutorialDir();; dat.Append(""/graphics/earth.dat"");; dat.ReplaceAll(""/./"",""/"");; ; ifstream in;; in.open(dat.Data());; Float_t x,y;; while (1) {; in >> x >> y;; if (!in.good()) break;; ha->Fill(x,y, 1);; hm->Fill(x,y, 1);; hs->Fill(x,y, 1);; hp->Fill(x,y, 1);; hw->Fill(x,y, 1);; }; in.close();; ; c1->cd(1); ha->Draw(""aitoff"");; c1->cd(2); hm->Draw(""mercator"");; c1->cd(3); hs->Draw(""sinusoidal"");; c1->cd(4); hp->Draw(""parabolic"");; c1->cd(5); hw->Draw(""mollweide"");; ; return c1;; }; Float_tfloat Float_tDefinition RtypesCore.h:57; gROOT#define gROOTDefinition TROOT.h:406; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH2::FillInt_t Fill(Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/earth_8C.html:94,Load,Loading,94,doc/master/earth_8C.html,https://root.cern,https://root.cern/doc/master/earth_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/ellipse.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ellipse.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Draw ellipses. . ; void ellipse(){; auto c1 = new TCanvas(""c1"");; c1->Range(0,0,1,1);; auto pel = new TPaveLabel(0.1,0.8,0.9,0.95,""Examples of Ellipses"");; pel->SetFillColor(42);; pel->Draw();; auto el1 = new TEllipse(0.25,0.25,.1,.2);; el1->Draw();; auto el2 = new TEllipse(0.25,0.6,.2,.1);; el2->SetFillColor(6);; el2->SetFillStyle(3008);; el2->Draw();; auto el3 = new TEllipse(0.75,0.6,.2,.1,45,315);; el3->SetFillColor(2);; el3->SetFillStyle(1001);; el3->SetLineColor(4);; el3->Draw();; auto el4 = new TEllipse(0.75,0.25,.2,.15,45,315,62);; el4->SetFillColor(5);; el4->SetFillStyle(1001);; el4->SetLineColor(4);; el4->SetLineWidth(6);; el4->Draw();; }; TCanvasThe Canvas class.Definition TCanvas.h:23; TEllipseDraw Ellipses.Definition TEllipse.h:23; TPaveLabelA Pave (see TPave) with a text centered in the Pave.Definition TPaveLabel.h:20; c1return c1Definition legend1.C:41; AuthorRene Brun ; Definition in file ellipse.C. tutorialsgraphicsellipse.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ellipse_8C.html:96,Load,Loading,96,doc/master/ellipse_8C.html,https://root.cern,https://root.cern/doc/master/ellipse_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/eval.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. eval.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This macro produces the flowchart of TFormula::Eval. . ; void eval(){; ; TCanvas *c1 = new TCanvas(""c1"");; c1->Range(0,0,20,10);; TPaveLabel *pt1 = new TPaveLabel(0.2,4,3,6,""Eval"");; pt1->SetTextSize(0.5);; pt1->SetFillColor(42);; pt1->Draw();; TPaveText *pt2 = new TPaveText(4.5,4,7.8,6);; pt2->Draw();; TText *t1 = pt2->AddText(""Read Operator"");; TText *t2 = pt2->AddText(""number i"");; TPaveText *pt3 = new TPaveText(9,3.5,17.5,6.5);; TText *t4 = pt3->AddText(""Apply Operator to current stack values"");; TText *t5 = pt3->AddText(""Example: if operator +"");; TText *t6 = pt3->AddText(""value[i] += value[i-1]"");; t4->SetTextAlign(22);; t5->SetTextAlign(22);; t6->SetTextAlign(22);; t5->SetTextColor(4);; t6->SetTextColor(2);; pt3->Draw();; TPaveLabel *pt4 = new TPaveLabel(4,0.5,12,2.5,""return result = value[i]"");; pt4->Draw();; TArrow *ar1 = new TArrow(6,4,6,2.7,0.02,""|>"");; ar1->Draw();; TText *t7 = new TText(6.56,2.7,""if i = number of stack elements"");; t7->SetTextSize(0.04);; t7->Draw();; ar1->DrawArrow(6,8,6,6.2,0.02,""|>"");; TLine *l1 = new TLine(12,6.6,12,8);; l1->Draw();; l1->DrawLine(12,8,6,8);; ar1->DrawArrow(3,5,4.4,5,0.02,""|>"");; ar1->DrawArrow(7.8,5,8.9,5,0.02,""|>"");; }; ; TArrowDraw all kinds of Arrows.Definition TArrow.h:29; TArrow::DrawArrowvirtual TArrow * DrawArrow(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Float_t arrowsize=0, Option_t *option="""")Draw this arrow with new coordinates.Definition TArrow.cxx:135; TArrow::Drawvoid Draw(Option_t *option="""") overrideDraw this arrow with its current attributes.Definition TArrow.cxx:120; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/eval_8C.html:93,Load,Loading,93,doc/master/eval_8C.html,https://root.cern,https://root.cern/doc/master/eval_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/event.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. event.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Illustrate some basic primitives. . ; void event(){; TCanvas *c1 = new TCanvas(""c1"",""ROOT Event description"",700,500);; c1->Range(0,0,14,15.5);; TPaveText *event = new TPaveText(1,13,3,15);; event->SetFillColor(11);; event->Draw();; event->AddText(""Event"");; TLine *line = new TLine(1.1,13,1.1,1.5);; line->SetLineWidth(2);; line->Draw();; line->DrawLine(1.3,13,1.3,3.5);; line->DrawLine(1.5,13,1.5,5.5);; line->DrawLine(1.7,13,1.7,7.5);; line->DrawLine(1.9,13,1.9,9.5);; line->DrawLine(2.1,13,2.1,11.5);; TArrow *arrow = new TArrow(1.1,1.5,3.9,1.5,0.02,""|>"");; arrow->SetFillStyle(1001);; arrow->SetFillColor(1);; arrow->Draw();; arrow->DrawArrow(1.3,3.5,3.9,3.5,0.02,""|>"");; arrow->DrawArrow(1.5,5.5,3.9,5.5,0.02,""|>"");; arrow->DrawArrow(1.7,7.5,3.9,7.5,0.02,""|>"");; arrow->DrawArrow(1.9,9.5,3.9,9.5,0.02,""|>"");; arrow->DrawArrow(2.1,11.5,3.9,11.5,0.02,""|>"");; TPaveText *p1 = new TPaveText(4,1,11,2);; p1->SetTextAlign(12);; p1->SetFillColor(42);; p1->AddText(""1 Mbyte"");; p1->Draw();; TPaveText *p2 = new TPaveText(4,3,10,4);; p2->SetTextAlign(12);; p2->SetFillColor(42);; p2->AddText(""100 Kbytes"");; p2->Draw();; TPaveText *p3 = new TPaveText(4,5,9,6);; p3->SetTextAlign(12);; p3->SetFillColor(42);; p3->AddText(""10 Kbytes"");; p3->Draw();; TPaveText *p4 = new TPaveText(4,7,8,8);; p4->SetTextAlign(12);; p4->SetFillColor(42);; p4->AddText(""1 Kbytes"");; p4->Draw();; TPaveText *p5 = new TPaveText(4,9,7,10);; p5->SetTextAlign(12);; p5->SetFillColor(42);; p5->AddText(""100 bytes"");; p5->Draw();; TPaveText *p6 = new TPaveText(4,11,6,12);; p6->SetTextAlign(12);; p6->SetFillColor(42);; p6->AddText(""10 bytes"");; p6->Draw();; TText text;; text.SetTextAlign(12);; text.SetTextSize(0.04);; text.SetTextFont(72);; text.DrawText(6.2,11.5,""Header:Event_flag"");; text.DrawText(7.2,9.5,""Trigger_Info",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/event_8C.html:94,Load,Loading,94,doc/master/event_8C.html,https://root.cern,https://root.cern/doc/master/event_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/feynman.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. feynman.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Draw Feynman diagrams. . ; void feynman(); {; TCanvas *c1 = new TCanvas(""c1"", ""A canvas"", 10,10, 600, 300);; c1->Range(0, 0, 140, 60);; Int_t linsav = gStyle->GetLineWidth();; gStyle->SetLineWidth(3);; TLatex t;; t.SetTextAlign(22);; t.SetTextSize(0.1);; TLine * l;; l = new TLine(10, 10, 30, 30); l->Draw();; l = new TLine(10, 50, 30, 30); l->Draw();; TCurlyArc *ginit = new TCurlyArc(30, 30, 12.5*sqrt(2), 135, 225);; ginit->SetWavy();; ginit->Draw();; t.DrawLatex(7,6,""e^{-}"");; t.DrawLatex(7,55,""e^{+}"");; t.DrawLatex(7,30,""#gamma"");; ; TCurlyLine *Gamma = new TCurlyLine(30, 30, 55, 30);; Gamma->SetWavy();; Gamma->Draw();; t.DrawLatex(42.5,37.7,""#gamma"");; ; TArc *a = new TArc(70, 30, 15);; a->Draw();; t.DrawLatex(55, 45,""#bar{q}"");; t.DrawLatex(85, 15,""q"");; TCurlyLine *gluon = new TCurlyLine(70, 45, 70, 15);; gluon->Draw();; t.DrawLatex(77.5,30,""g"");; ; TCurlyLine *z0 = new TCurlyLine(85, 30, 110, 30);; z0->SetWavy();; z0->Draw();; t.DrawLatex(100, 37.5,""Z^{0}"");; ; l = new TLine(110, 30, 130, 10); l->Draw();; l = new TLine(110, 30, 130, 50); l->Draw();; ; TCurlyArc *gluon1 = new TCurlyArc(110, 30, 12.5*sqrt(2), 315, 45);; gluon1->Draw();; ; t.DrawLatex(135,6,""#bar{q}"");; t.DrawLatex(135,55,""q"");; t.DrawLatex(135,30,""g"");; c1->Update();; gStyle->SetLineWidth(linsav);; }; a#define a(i)Definition RSha256.hxx:99; Int_tint Int_tDefinition RtypesCore.h:45; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TArcCreate an Arc.Definition TArc.h:26; TAttLine::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttTe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/feynman_8C.html:96,Load,Loading,96,doc/master/feynman_8C.html,https://root.cern,https://root.cern/doc/master/feynman_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/first.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. first.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Show some basic primitives. . ; void first() {; ; TCanvas *nut = new TCanvas(""nut"", ""FirstSession"",100,10,700,900);; nut->Range(0,0,20,24);; nut->SetFillColor(10);; nut->SetBorderSize(2);; ; TPaveLabel *pl = new TPaveLabel(3,22,17,23.7,; ""My first ROOT interactive session"",""br"");; pl->SetFillColor(18);; pl->Draw();; ; TText t(0,0,""a"");; t.SetTextFont(62);; t.SetTextSize(0.025);; t.SetTextAlign(12);; t.DrawText(2,20.3,""ROOT is based on CLING, a powerful C/C++ interpreter."");; t.DrawText(2,19.3,""Blocks of lines can be entered within {...}."");; t.DrawText(2,18.3,""Previous typed lines can be recalled."");; ; t.SetTextFont(72);; t.SetTextSize(0.026);; t.DrawText(3,17,""Root > float x=5; float y=7;"");; t.DrawText(3,16,""Root > x*sqrt(y)"");; t.DrawText(3,14,; ""Root > for (int i=2;i<7;i++) printf(\""sqrt(%d) = %f\\n\"",i,sqrt(i));"");; t.DrawText(3,10,""Root > TF1 f1(\""f1\"",\""sin(x)/x\"",0,10)"");; t.DrawText(3, 9,""Root > f1.Draw()"");; t.SetTextFont(81);; t.SetTextSize(0.018);; t.DrawText(4,15,""(float) 13.2288f"");; t.DrawText(4,13.3,""sqrt(2) = 1.414214"");; t.DrawText(4,12.7,""sqrt(3) = 1.732051"");; t.DrawText(4,12.1,""sqrt(4) = 2.000000"");; t.DrawText(4,11.5,""sqrt(5) = 2.236068"");; t.DrawText(4,10.9,""sqrt(6) = 2.449490"");; ; TPad *pad = new TPad(""pad"",""pad"",.2,.05,.8,.35);; pad->Draw();; pad->cd();; pad->SetGrid();; TF1 *f1 = new TF1(""f1"",""sin(x)/x"",0,10);; f1->Draw();; }; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TCanvasThe Canvas class.Definition TCanvas.h:23; TF11-Dim function classDefinition TF1.h:233; TF1::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TF1.cxx:1333; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPad::SetB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/first_8C.html:94,Load,Loading,94,doc/master/first_8C.html,https://root.cern,https://root.cern/doc/master/first_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/formula1.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. formula1.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Display interpreted functions. . ; void formula1() {; TCanvas *c1 = new TCanvas(""c1"",""Example with Formula"",200,10,700,500);; //; // We create a formula object and compute the value of this formula; // for two different values of the x variable.; //; auto form1 = new TFormula(""form1"",""sqrt(abs(x))"");; form1->Eval(2);; form1->Eval(-45);; //; // Create a one dimensional function and draw it; //; auto fun1 = new TF1(""fun1"",""abs(sin(x)/x)"",0,10);; c1->SetGridx();; c1->SetGridy();; fun1->Draw();; c1->Update();; //; // Before leaving this demo, we print the list of objects known to ROOT; //; if (gObjectTable) gObjectTable->Print();; }; gObjectTableR__EXTERN TObjectTable * gObjectTableDefinition TObjectTable.h:82; TCanvasThe Canvas class.Definition TCanvas.h:23; TF11-Dim function classDefinition TF1.h:233; TFormulaThe Formula class.Definition TFormula.h:89; TObjectTable::Printvoid Print(Option_t *option="""") const overridePrint the object table.Definition TObjectTable.cxx:120; c1return c1Definition legend1.C:41; formula1Definition formula1.py:1; AuthorRene Brun ; Definition in file formula1.C. tutorialsgraphicsformula1.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/formula1_8C.html:97,Load,Loading,97,doc/master/formula1_8C.html,https://root.cern,https://root.cern/doc/master/formula1_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/framework.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. framework.C File ReferenceTutorials » Graphics tutorials. Detailed Description; An example with basic graphics illustrating the Object Oriented User Interface of ROOT. . ; void framework() {; TCanvas *c1 = new TCanvas(""c1"",""The ROOT Framework"",200,10,700,500);; c1->Range(0,0,19,12);; //; TPavesText *rootf = new TPavesText(0.4,0.6,18,2.3,20,""tr"");; rootf->AddText(""ROOT Framework"");; rootf->SetFillColor(42);; rootf->Draw();; //; TPavesText *eventg = new TPavesText(0.99,2.66,3.29,5.67,4,""tr"");; eventg->SetFillColor(38);; eventg->AddText(""Event"");; eventg->AddText(""Generators"");; eventg->Draw();; //; TPavesText *simul = new TPavesText(3.62,2.71,6.15,7.96,7,""tr"");; simul->SetFillColor(41);; simul->AddText(""Detector"");; simul->AddText(""Simulation"");; simul->Draw();; //; TPavesText *recon = new TPavesText(6.56,2.69,10.07,10.15,11,""tr"");; recon->SetFillColor(48);; recon->AddText(""Event"");; recon->AddText(""Reconstruction"");; recon->Draw();; //; TPavesText *daq = new TPavesText(10.43,2.74,14.0,10.81,11,""tr"");; daq->AddText(""Data"");; daq->AddText(""Acquisition"");; daq->Draw();; //; TPavesText *anal = new TPavesText(14.55,2.72,17.9,10.31,11,""tr"");; anal->SetFillColor(42);; anal->AddText(""Data"");; anal->AddText(""Analysis"");; anal->Draw();; c1->Update();; }; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TCanvasThe Canvas class.Definition TCanvas.h:23; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cxx:191; TPavesTextA PaveText (see TPaveText) with several stacked paves.Definition TPavesText.h:18; TPavesText::Drawvoid Draw(Option_t *option="""") overrideDraw this pavestext with its current attributes.Definition TPavesText.cxx:80; c1return c1Definition legend1.C:41; Auth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/framework_8C.html:98,Load,Loading,98,doc/master/framework_8C.html,https://root.cern,https://root.cern/doc/master/framework_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/gaxis.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. gaxis.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Simple example illustrating how to draw TGaxis objects in various formats. . ; void gaxis(){; auto c1 = new TCanvas(""c1"",""Examples of TGaxis"",10,10,700,500);; c1->Range(-10,-1,10,1);; ; auto axis1 = new TGaxis(-4.5,-0.2,5.5,-0.2,-6,8,510,"""");; axis1->Draw();; ; auto axis2 = new TGaxis(-4.5,0.2,5.5,0.2,0.001,10000,510,""G"");; axis2->Draw();; ; auto axis3 = new TGaxis(-9,-0.8,-9,0.8,-8,8,50510,"""");; axis3->SetTitle(""axis3"");; axis3->SetTitleOffset(0.5);; axis3->Draw();; ; auto axis4 = new TGaxis(-7,-0.8,-7,0.8,1,10000,50510,""G"");; axis4->SetTitle(""axis4"");; axis4->Draw();; ; auto axis5 = new TGaxis(-4.5,-0.6,5.5,-0.6,1.2,1.32,80506,""-+"");; axis5->SetLabelSize(0.03);; axis5->SetTextFont(72);; axis5->Draw();; ; auto axis6 = new TGaxis(-4.5,0.5,5.5,0.5,100,900,50510,""-"");; axis6->Draw();; ; auto axis7 = new TGaxis(-5.5,0.85,5.5,0.85,0,4.3e-6,510,"""");; axis7->Draw();; ; auto axis8 = new TGaxis(8,-0.8,8,0.8,0,9000,50510,""+L"");; axis8->Draw();; ; // One can make a vertical axis going top->bottom. However the two x values should be; // slightly different to avoid labels overlapping.; auto axis9 = new TGaxis(6.5,0.8,6.499,-0.8,0,90,50510,""-"");; axis9->Draw();; }; TCanvasThe Canvas class.Definition TCanvas.h:23; TGaxisThe axis painter class.Definition TGaxis.h:24; c1return c1Definition legend1.C:41; AuthorsRene Brun, Olivier Couet ; Definition in file gaxis.C. tutorialsgraphicsgaxis.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gaxis_8C.html:94,Load,Loading,94,doc/master/gaxis_8C.html,https://root.cern,https://root.cern/doc/master/gaxis_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/gaxis2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. gaxis2.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Example illustrating how to draw TGaxis with labels defined by a function. . ; void gaxis2(){; gStyle->SetOptStat(0);; ; TH2F *h2 = new TH2F(""h"",""Axes"",100,0,10,100,-2,2);; h2->Draw();; ; TF1 *f1 = new TF1(""f1"",""-x"",-10,10);; TGaxis *A1 = new TGaxis(0,2,10,2,""f1"",510,""-"");; A1->SetTitle(""axis with decreasing values"");; A1->Draw();; ; TF1 *f2 = new TF1(""f2"",""exp(x)"",0,2);; TGaxis *A2 = new TGaxis(1,1,9,1,""f2"");; A2->SetTitle(""exponential axis"");; A2->SetLabelSize(0.03);; A2->SetTitleSize(0.03);; A2->SetTitleOffset(1.2);; A2->Draw();; ; TF1 *f3 = new TF1(""f3"",""log10(x)"",1,1000);; TGaxis *A3 = new TGaxis(2,-2,2,0,""f3"",505,""G"");; A3->SetTitle(""logarithmic axis"");; A3->SetLabelSize(0.03);; A3->SetTitleSize(0.03);; A3->SetTitleOffset(1.2);; A3->Draw();; }; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TF11-Dim function classDefinition TF1.h:233; TGaxisThe axis painter class.Definition TGaxis.h:24; TGaxis::SetTitleOffsetvoid SetTitleOffset(Float_t titleoffset=1)Definition TGaxis.h:128; TGaxis::SetTitleSizevoid SetTitleSize(Float_t titlesize)Definition TGaxis.h:129; TGaxis::SetTitlevirtual void SetTitle(const char *title="""")Change the title of the axis.Definition TGaxis.cxx:2942; TGaxis::SetLabelSizevoid SetLabelSize(Float_t labelsize)Definition TGaxis.h:107; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; f1TF1 * f1Definition legend1.C:11; AuthorOlivier Couet ; Definition in file gaxis2.C. tutorialsgraphicsgaxis2.C. ROOT master - ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gaxis2_8C.html:95,Load,Loading,95,doc/master/gaxis2_8C.html,https://root.cern,https://root.cern/doc/master/gaxis2_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/gaxis3.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. gaxis3.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Example illustrating how to modify individual labels of a TGaxis. ; The method ChangeLabel allows to do that.; The first parameter of this method is the label number to be modified. If this number is negative labels are numbered from the last one. The other parameters are (in order):; the new angle value,; the new size (0 erase the label),; the new text alignment,; the new label color,; the new label text. ; void gaxis3() {; TCanvas* c1 = new TCanvas(""c1"",""Examples of TGaxis"",10,10,800,400);; c1->Range(-6,-0.1,6,0.1);; ; TGaxis *axis = new TGaxis(-5.5,0.,5.5,0.,0.0,100,510,"""");; axis->SetName(""axis"");; axis->SetTitle(""Axis Title"");; axis->SetTitleSize(0.05);; axis->SetTitleColor(kBlue);; axis->SetTitleFont(42);; ; // Change the 1st label color to red.; axis->ChangeLabel(1,-1,-1,-1,kRed);; ; // Erase the 3rd label; axis->ChangeLabel(3,-1,0.);; ; // 5th label is drawn with an angle of 30 degrees; axis->ChangeLabel(5,30.,-1,0);; ; // Change the text of the 6th label.; axis->ChangeLabel(6,-1,-1,-1,kGreen,-1,""6th label"");; ; // Change the text of the 2nd label to the end.; axis->ChangeLabel(-2,-1,-1,-1,kGreen,-1,""2nd to last label"");; ; // Change the text of value 30 by ""value of 30""; axis->ChangeLabelByValue(30.,-1,-1,-1,kBlue,-1,""value of 30"");; ; ; axis->Draw();; }; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCanvasThe Canvas class.Definition TCanvas.h:23; TGaxisThe axis painter class.Definition TGaxis.h:24; TGaxis::SetTitleSizevoid SetTitleSize(Float_t titlesize)Definition TGaxis.h:129; TGaxis::SetTitleFontvoid SetTitleFont(Int_t titlefont)Definition TGaxis.h:130; TGaxis::SetTitlevirtual void SetTitle(const char *title="""")Change the title of the axis.Definition TGaxis.cxx:2942; TGaxis::ChangeLabelB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gaxis3_8C.html:95,Load,Loading,95,doc/master/gaxis3_8C.html,https://root.cern,https://root.cern/doc/master/gaxis3_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/graph_edit_playback.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graph_edit_playback.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This macro plays a recorded ROOT session showing how to perform various interactive graphical editing operations. ; The initial graphics setup was created using the following root commands: TRecorder *t = new TRecorder();; t->Start(""graphedit_playback.root"");; gStyle->SetPalette(1);; TCanvas *c2 = new TCanvas(""c2"",""c2"",0,0,700,500);; TH2F* h2 = new TH2F(""h2"",""Random 2D Gaussian"",40,-4,4,40,-4,4);; h2->SetDirectory(0);; TRandom r;; for (int i=0;i<50000;i++) h2->Fill(r.Gaus(),r.Gaus());; h2->Draw();; gPad->Update();; TCanvas *c1 = new TCanvas(""c1"",""c1"",0,0,700,500);; TH1F* h1 = new TH1F(""h1"",""Random 1D Gaussian"",100,-4,4);; h1->SetDirectory(0);; h1->FillRandom(""gaus"",10000);; h1->Draw();; gPad->Update();; ; // Here the following ""sketch"" was done.; ; t->Stop();; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; gPad#define gPadDefinition TVirtualPad.h:308; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2F2-D histogram with a float",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/graph__edit__playback_8C.html:108,Load,Loading,108,doc/master/graph__edit__playback_8C.html,https://root.cern,https://root.cern/doc/master/graph__edit__playback_8C.html,2,"['Load', 'perform']","['Loading', 'perform']"
Performance,". ROOT: tutorials/graphics/greyscale.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. greyscale.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Create grey scale of 200 x 200 boxes. . ; void greyscale(); {; TCanvas *c = new TCanvas(""grey"", ""Grey Scale"", 500, 500);; c->SetBorderMode(0);; ; Int_t n = 200; // tunable parameter; Float_t n1 = 1./n;; for (int i = 0; i < n; i++) {; for (int j = 0; j < n; j++) {; TBox *b = new TBox(n1*j, n1*(n-1-i), n1*(j+1), n1*(n-i));; Float_t grey = Float_t(i*n+j)/(n*n);; b->SetFillColor(TColor::GetColor(grey, grey, grey));; b->Draw();; }; }; TPad *p = new TPad(""p"",""p"",0.3, 0.3, 0.7,0.7);; const char *guibackground = gEnv->GetValue(""Gui.BackgroundColor"", """");; p->SetFillColor(TColor::GetColor(guibackground));; p->Draw();; p->cd();; TText *t = new TText(0.5, 0.5, ""GUI Background Color"");; t->SetTextAlign(22);; t->SetTextSize(.09);; t->Draw();; ; c->SetEditable(kFALSE);; }; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TBoxCreate a Box.Definition TBox.h:22; TCanvasThe Canvas class.Definition TCanvas.h:23; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color number for color specified by hex color string of form: ""#rrggbb"",...Definition TColor.cxx:1920; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TObject::Drawvirtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/greyscale_8C.html:98,Load,Loading,98,doc/master/greyscale_8C.html,https://root.cern,https://root.cern/doc/master/greyscale_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/gtime.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. gtime.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Example of a graph of data moving in time. ; Use the canvas ""File/Quit ROOT"" to exit from this example; ; #include ""TCanvas.h""; #include ""TRandom3.h""; #include ""TMath.h""; #include ""TText.h""; #include ""TArrow.h""; #include ""TGraphTime.h""; #include <vector>; ; void gtime(Int_t nsteps = 500, Int_t np = 100); {; if (np > 1000) np = 1000;; std::vector<Int_t> color(np);; std::vector<Double_t> rr(np), phi(np), dr(np), size(np);; TRandom3 r;; Double_t xmin = -10, xmax = 10, ymin = -10, ymax = 10;; auto g = new TGraphTime(nsteps, xmin, ymin, xmax, ymax);; g->SetTitle(""TGraphTime demo;X domain;Y domain"");; for (Int_t i = 0; i < np; i++) { // calculate some object parameters; rr[i] = r.Uniform(0.1 * xmax, 0.2 * xmax);; phi[i] = r.Uniform(0, 2 * TMath::Pi());; dr[i] = r.Uniform(0, 1) * 0.9 * xmax / Double_t(nsteps);; Double_t rc = r.Rndm();; if (rc > 0.7); color[i] = kYellow;; else if (rc > 0.3); color[i] = kBlue;; else; color[i] = kRed;; ; size[i] = r.Uniform(0.5, 6);; }; for (Int_t s = 0; s < nsteps; s++) { // fill the TGraphTime step by step; for (Int_t i = 0; i < np; i++) {; Double_t newr = rr[i] + dr[i] * s;; Double_t newsize = 0.2 + size[i] * TMath::Abs(TMath::Sin(newr + 10));; Double_t newphi = phi[i] + 0.01 * s;; Double_t xx = newr * TMath::Cos(newphi);; Double_t yy = newr * TMath::Sin(newphi);; TMarker *m = new TMarker(xx, yy, 20);; m->SetMarkerColor(color[i]);; m->SetMarkerSize(newsize);; g->Add(m, s);; if (i == np - 1); g->Add(new TArrow(xmin, ymax, xx, yy, 0.02, ""-|>""), s);; }; g->Add(new TPaveLabel(.90, .92, .98, .97, TString::Format(""%d"", s + 1), ""brNDC""), s);; }; ; g->Draw();; ; // save object as animated gif; // g->SaveAnimatedGif(""gtime.gif"");; ; //save object to a file; auto f = TFile::Open(""gtime.root"",""recreate"");; f->WriteObject(g, ""g"");; delete f;; ; //t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/graphics_2gtime_8C.html:94,Load,Loading,94,doc/master/graphics_2gtime_8C.html,https://root.cern,https://root.cern/doc/master/graphics_2gtime_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/inside.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. inside.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Test the IsInside methods of various graphics primitives. . ; void inside() {; auto el = new TEllipse(0.75, 0.25, .2,.15,45,315,62);; el->Draw();; ; auto gr = new TGraph();; double gr_x1[5] = {0.1, 0.3388252, 0.03796561, 0.4176218, 0.1};; double gr_y1[5] = {0.5, 0.9644737, 0.7776316, 0.6960526, 0.5};; gr = new TGraph(5, gr_x1, gr_y1);; gr->Draw(""L"");; ; auto bx = new TBox(.7, .8, .9, .95);; bx->Draw();; ; auto pv = new TPave(.05, .1, .3, .2);; pv->Draw();; ; auto di = new TDiamond(.05, .25, .3, .4);; di->Draw();; ; auto cr = new TCrown(.5, .5, .1, .15);; cr->SetFillColor(19);; cr->Draw();; ; for (int i = 0; i < 10000; i++) {; double x = gRandom->Rndm();; double y = gRandom->Rndm();; auto p = new TMarker(x,y,7);; p->Draw();; if (el->IsInside(x,y) || bx->IsInside(x,y) || pv->IsInside(x,y) || di->IsInside(x,y) || cr->IsInside(x,y) ||; gr->IsInside(x,y)) {; p->SetMarkerColor(kGreen);; } else {; p->SetMarkerColor(kRed);; }; }; }; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TBoxCreate a Box.Definition TBox.h:22; TCrownTo draw a Crown.Definition TCrown.h:19; TDiamondDraw a Diamond.Definition TDiamond.h:17; TEllipseDraw Ellipses.Definition TEllipse.h:23; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::IsInsidevirtual Int_t IsInside(Double_t x, Double_t y) constReturn 1 if the point (x,y) is inside the polygon defined by the graph vertices 0 otherwise.Definition TGraph.cxx:1841; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TMarkerManages Markers.Definition TMarker.h:22;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/inside_8C.html:95,Load,Loading,95,doc/master/inside_8C.html,https://root.cern,https://root.cern/doc/master/inside_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/latex.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. latex.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This macro draws 5 Latex-style formula in a canvas and prints the canvas as a Postscript file. . ; void latex() {; TCanvas *c1 = new TCanvas(""c1"",""test"",600,700);; // write formulas; TLatex l;; l.SetTextAlign(12);; l.SetTextSize(0.04);; l.DrawLatex(0.1,0.9,""1) C(x) = d #sqrt{#frac{2}{#lambdaD}}\; #int^{x}_{0}cos(#frac{#pi}{2}t^{2})dt"");; l.DrawLatex(0.1,0.7,""2) C(x) = d #sqrt{#frac{2}{#lambdaD}}\; #int^{x}cos(#frac{#pi}{2}t^{2})dt"");; l.DrawLatex(0.1,0.5,""3) R = |A|^{2} = #frac{1}{2}#left(#[]{#frac{1}{2}+\; C(V)}^{2}+#[]{#frac{1}{2}+S(V)}^{2}#right)"");; l.DrawLatex(0.1,0.3,; ""4) F(t) = #sum_{i=-#infty}^{#infty}A(i)cos#[]{#frac{i}{t+i}}"");; l.DrawLatex(0.1,0.1,""5) {}_{3}^{7}Li"");; c1->Print(""latex.ps"");; }; TCanvasThe Canvas class.Definition TCanvas.h:23; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLine::Printvoid Print(Option_t *option="""") const overrideDump this line with its attributes.Definition TLine.cxx:419; c1return c1Definition legend1.C:41; lTLine lDefinition textangle.C:4; AuthorRene Brun ; Definition in file latex.C. tutorialsgraphicslatex.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/latex_8C.html:94,Load,Loading,94,doc/master/latex_8C.html,https://root.cern,https://root.cern/doc/master/latex_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/latex2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. latex2.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This macro draws 4 Latex-style formula in a canvas and prints the canvas as a Postscript file. . ; void latex2(){; TCanvas *c1 = new TCanvas(""c1"");; TLatex l;; l.SetTextAlign(23);; l.SetTextSize(0.1);; l.DrawLatex(0.5,0.95,""e^{+}e^{-}#rightarrowZ^{0}#rightarrowI#bar{I}, q#bar{q}"");; l.DrawLatex(0.5,0.75,""|#vec{a}#bullet#vec{b}|=#Sigmaa^{i}_{jk}+b^{bj}_{i}"");; l.DrawLatex(0.5,0.5,""i(#partial_{#mu}#bar{#psi}#gamma^{#mu}+m#bar{#psi})=0\; #Leftrightarrow(#Box+m^{2})#psi=0"");; l.DrawLatex(0.5,0.3,""L_{em}=eJ^{#mu}_{em}A_{#mu} , J^{#mu}_{em}=#bar{I}\; #gamma_{#mu}I , M^{j}_{i}=#SigmaA_{#alpha}#tau^{#alphaj}_{i}"");; c1->Print(""latex2.ps"");; }; TCanvasThe Canvas class.Definition TCanvas.h:23; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLine::Printvoid Print(Option_t *option="""") const overrideDump this line with its attributes.Definition TLine.cxx:419; c1return c1Definition legend1.C:41; lTLine lDefinition textangle.C:4; AuthorRene Brun ; Definition in file latex2.C. tutorialsgraphicslatex2.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/latex2_8C.html:95,Load,Loading,95,doc/master/latex2_8C.html,https://root.cern,https://root.cern/doc/master/latex2_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/latex3.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. latex3.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Example illustrating a TPaveText with Latex inside. . ; void latex3() {; ; TCanvas *c1 = new TCanvas(""c1"");; TPaveText *pt = new TPaveText(.05,.1,.95,.8);; ; pt->AddText(""#frac{2s}{#pi#alpha^{2}} #frac{d#sigma}{dcos#theta} ""; ""(e^{+}e^{-} #rightarrow f#bar{f} ) = #left| #frac{1}{1 - #Delta#alpha} ""; ""#right|^{2} (1+cos^{2}#theta)"");; ; pt->AddText(""+ 4 Re #left{ #frac{2}{1 - #Delta#alpha} #chi(s) ""; ""#[]{#hat{g}_{#nu}^{e}#hat{g}_{#nu}^{f} ""; ""(1 + cos^{2}#theta) + 2 #hat{g}_{a}^{e}#hat{g}_{a}^{f} cos#theta) } #right}"");; ; pt->AddText(""+ 16#left|#chi(s)#right|^{2} ""; ""#left[(#hat{g}_{a}^{e}^{2} + #hat{g}_{v}^{e}^{2})""; ""(#hat{g}_{a}^{f}^{2} + #hat{g}_{v}^{f}^{2})(1+cos^{2}#theta)""; ""+ 8 #hat{g}_{a}^{e} #hat{g}_{a}^{f} #hat{g}_{v}^{e}""; ""#hat{g}_{v}^{f}cos#theta#right] "");; ; pt->SetLabel(""Born equation"");; pt->Draw();; }; TCanvasThe Canvas class.Definition TCanvas.h:23; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cxx:191; TPaveText::SetLabelvirtual void SetLabel(const char *label)Definition TPaveText.h:61; TPaveText::Drawvoid Draw(Option_t *option="""") overrideDraw this pavetext with its current attributes.Definition TPaveText.cxx:242; ptTPaveText * ptDefinition entrylist_figure1.C:7; c1return c1Definition legend1.C:41; AuthorRene Brun ; Definition in file latex3.C. tutorialsgraphicslatex3.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/latex3_8C.html:95,Load,Loading,95,doc/master/latex3_8C.html,https://root.cern,https://root.cern/doc/master/latex3_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/latex4.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. latex4.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Draw the Greek letters as a table and save the result as GIF, PS, PDF and SVG files. ; Lowercase Greek letters are obtained by adding a # to the name of the letter. For an uppercase Greek letter, just capitalize the first letter of the command name. Some letter have two representations. The name of the second one (the ""variation"") starts with ""var"". png output:. pdf output:. svg output:. AuthorRene Brun ; Definition in file latex4.C. tutorialsgraphicslatex4.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/latex4_8C.html:95,Load,Loading,95,doc/master/latex4_8C.html,https://root.cern,https://root.cern/doc/master/latex4_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/latex5.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. latex5.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This draws the Mathematical Symbols letters as a table and save the result as GIF, PS, PDF and SVG files. . png output:. pdf output:. svg output:. AuthorRene Brun ; Definition in file latex5.C. tutorialsgraphicslatex5.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/latex5_8C.html:95,Load,Loading,95,doc/master/latex5_8C.html,https://root.cern,https://root.cern/doc/master/latex5_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/mandelbrot.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. mandelbrot.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Using TExec to handle keyboard events and TComplex to draw the Mandelbrot set. ; Pressing the keys 'z' and 'u' will zoom and unzoom the picture near the mouse location, 'r' will reset to the default view.; Try it (in compiled mode!) with: root mandelbrot.C+. Details; when a mouse event occurs the myexec() function is called (by using AddExec). Depending on the pressed key, the mygenerate() function is called, with the proper arguments. Note the last_x and last_y variables that are used in myexec() to store the last pointer coordinates (px is not a pointer position in kKeyPress events).; ; #include <TStyle.h>; #include <TROOT.h>; #include <TH2.h>; #include <TComplex.h>; #include <TVirtualPad.h>; #include <TCanvas.h>; ; TH2F *last_histo = nullptr;; ; void mygenerate(double factor, double cen_x, double cen_y); {; printf(""Regenerating...\n"");; // resize histo:; if(factor>0); {; double dx=last_histo->GetXaxis()->GetXmax()-last_histo->GetXaxis()->GetXmin();; double dy=last_histo->GetYaxis()->GetXmax()-last_histo->GetYaxis()->GetXmin();; last_histo->SetBins(; last_histo->GetNbinsX(),; cen_x-factor*dx/2,; cen_x+factor*dx/2,; last_histo->GetNbinsY(),; cen_y-factor*dy/2,; cen_y+factor*dy/2; );; last_histo->Reset();; }; else; {; if(last_histo) delete last_histo;; // allocate first view...; last_histo = new TH2F(""h2"",; ""Mandelbrot [move mouse and press z to zoom, u to unzoom, r to reset]"",; 200,-2,2,200,-2,2);; last_histo->SetStats(false);; }; const int max_iter=50;; for(int bx=1;bx<=last_histo->GetNbinsX();bx++); for(int by=1;by<=last_histo->GetNbinsY();by++); {; double x=last_histo->GetXaxis()->GetBinCenter(bx);; double y=last_histo->GetYaxis()->GetBinCenter(by);; TComplex point( x,y);; TComplex z=point;; int iter=0;; while (z.Rho()<2){; z=z*z+point;; last_histo-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/mandelbrot_8C.html:99,Load,Loading,99,doc/master/mandelbrot_8C.html,https://root.cern,https://root.cern/doc/master/mandelbrot_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/markerwarning.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. markerwarning.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This script illustrates the danger of using asymmetric symbols. . Non-symmetric symbols should be used carefully in plotting. These two graphs show how misleading a careless use of symbols can be. The two plots represent the same data sets but because of a bad symbol choice, the two plots on the top appear further apart than for the bottom example. AuthorOlivier Couet ; Definition in file markerwarning.C. tutorialsgraphicsmarkerwarning.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/markerwarning_8C.html:102,Load,Loading,102,doc/master/markerwarning_8C.html,https://root.cern,https://root.cern/doc/master/markerwarning_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/mass_spectrum.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. mass_spectrum.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This macro makes use of some basic graphics primitives such as line, arrow and text. ; It has been written using the TCanvas ToolBar to produce a first draft and was then modified for fine adjustments. Note also the use of C functions. They allow to simplify the macro reading and editing by avoiding code repetition or defining some graphics attributes in one single place. This technique to generate drawings may appear not very user friendly compare to all the ""wysiwyg"" graphics editors available. In some cases it can be more powerful than a GUI interface because it allows to generate very precise drawing and using computation to generate them. ; void hline (Double_t x, Double_t y); {; Double_t dx = 0.1;; TLine *l = new TLine(x,y,x+dx,y);; l->Draw();; l->SetLineWidth(4);; }; ; void DrawArrow (Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t ls); {; TArrow *arr = new TArrow(x1,y1,x2,y2,0.025,""|>"");; arr->SetFillColor(1);; arr->SetFillStyle(1001);; arr->SetLineStyle(ls);; arr->SetAngle(19);; arr->Draw();; }; ; void mass_spectrum(); {; TCanvas *C = new TCanvas(""C"",""C"",800,500);; ; hline (0.10,0.25);; hline (0.10,0.80);; hline (0.30,0.90);; hline (0.30,0.35);; hline (0.45,0.60);; hline (0.58,0.68);; hline (0.73,0.70);; hline (0.89,0.75);; ; DrawArrow(0.32, 0.90, 0.32, 0.35, 1);; DrawArrow(0.34, 0.90, 0.34, 0.35, 1);; DrawArrow(0.36, 0.90, 0.36, 0.60, 1);; DrawArrow(0.38, 0.90, 0.38, 0.70, 1);; ; DrawArrow(0.30, 0.90, 0.18, 0.25, 1);; DrawArrow(0.30, 0.35, 0.19, 0.25, 1);; DrawArrow(0.40, 0.90, 0.47, 0.61, 1);; ; DrawArrow(0.15, 0.25, 0.15, 0.19, 1);; DrawArrow(0.15, 0.80, 0.15, 0.74, 1);; ; DrawArrow(0.50, 0.60, 0.50, 0.54, 1);; DrawArrow(0.60, 0.68, 0.60, 0.62, 1);; DrawArrow(0.94, 0.75, 0.94, 0.69, 1);; ; DrawArrow(0.32, 0.35, 0.32, 0.19, 1)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/mass__spectrum_8C.html:102,Load,Loading,102,doc/master/mass__spectrum_8C.html,https://root.cern,https://root.cern/doc/master/mass__spectrum_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/palettes.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. palettes.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This macro draws all the high definition palettes available in ROOT. ; It generates a png file for each palette and one pdf file, with a table of content, containing all the palettes.; In ROOT, more than 60 high quality palettes are predefined with 255 colors each.; These palettes can be accessed ""by name"" with gStyle->SetPalette(num). num can be taken within the enum given in the previous link. As an example gStyle->SetPalette(kCividis) will select the following palette. ; TCanvas *c = nullptr;; ; void draw_palette(int p, TString n); {; delete c;; c = new TCanvas(""c"",""Contours"",0,0,500,500);; TF2 *f2 = new TF2(""f2"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",0.999,3.002,0.999,3.002);; f2->SetContour(99);; gStyle->SetPalette(p);; f2->SetLineWidth(1);; f2->SetLineColor(kBlack);; f2->Draw(""surf1z"");; ; // Title; TPaveText *pt = new TPaveText(10,11,10,11,""blNDC"");; pt->SetName(""title"");; pt->Draw();; TString num = n;; num.ReplaceAll("" "","""");; TLatex *l = new TLatex(-0.8704441,0.9779387,TString::Format(""Palette #%d: %s #scale[0.7]{(#font[82]{k%s})}"",p,n.Data(),num.Data()));; l->SetTextFont(42);; l->SetTextSize(0.035);; l->Draw();; c->Update();; c->Print(TString::Format(""palette_%d.png"", p));; ; TString opt = TString(""Title:"") + n;; if (p == kDeepSea); c->Print(""palettes.pdf("", opt.Data());; else if (p == kCividis); c->Print(""palettes.pdf)"", opt.Data());; else; c->Print(""palettes.pdf"", opt.Data());; }; ; void palettes(); {; gROOT->SetBatch(1);; draw_palette(kDeepSea, ""Deap Sea"");; draw_palette(kGreyScale, ""Grey Scale"");; draw_palette(kDarkBodyRadiator, ""Dark Body Radiator"");; draw_palette(kBlueYellow, ""Blue Yellow"");; draw_palette(kRainBow, ""Rain Bow"");; draw_palette(kInvertedDarkBodyRadiator, ""Inverted Dark Body Radiator"");; draw_palette(kBird, ""Bird"");; draw_palette",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/palettes_8C.html:97,Load,Loading,97,doc/master/palettes_8C.html,https://root.cern,https://root.cern/doc/master/palettes_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/pavetext.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. pavetext.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Draw a pave text. ; The text lines are added in order using the AddText method Line separator can be added using AddLine.; AddText returns a TText corresponding to the line added to the pave. This return value can be used to modify the text attributes.; Once the TPaveText is build the text of each line can be retrieved as a TText with GetLine and GetLineWith wich is also useful to modify the text attributes of a line. ; TCanvas *pavetext(){; TCanvas *c = new TCanvas(""c"");; TPaveText *pt = new TPaveText(.05,.1,.95,.8);; ; pt->AddText(""A TPaveText can contain severals line of text."");; pt->AddText(""They are added to the pave using the AddText method."");; pt->AddLine(.0,.5,1.,.5);; pt->AddText(""Even complex TLatex formulas can be added:"");; TText *t1 = pt->AddText(""F(t) = #sum_{i=-#infty}^{#infty}A(i)cos#[]{#frac{i}{t+i}}"");; ; t1->SetTextColor(kBlue);; ; pt->Draw();; ; TText *t2 = pt->GetLineWith(""Even"");; t2->SetTextColor(kOrange+1);; ; return c;; }; c#define c(i)Definition RSha256.hxx:101; kOrange@ kOrangeDefinition Rtypes.h:67; kBlue@ kBlueDefinition Rtypes.h:66; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TCanvasThe Canvas class.Definition TCanvas.h:23; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cxx:191; TPaveText::AddLinevirtual TLine * AddLine(Double_t x1=0, Double_t y1=0, Double_t x2=0, Double_t y2=0)Add a new graphics line to this pavetext.Definition TPaveText.cxx:177; TPaveText::Drawvoid Draw(Option_t *option="""") overrideDraw this pavetext with its current attributes.Definiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pavetext_8C.html:97,Load,Loading,97,doc/master/pavetext_8C.html,https://root.cern,https://root.cern/doc/master/pavetext_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/perceptualcolormap.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. perceptualcolormap.C File ReferenceTutorials » Graphics tutorials. Detailed Description; A “Perceptual” colormap explicitly identifies a fixed value in the data ; On geographical plot this fixed point can, for instance, the ""sea level"". A perceptual colormap provides a monotonic luminance variations above and below this fixed value. Unlike the rainbow colormap, this colormap provides a faithful representation of the structures in the data.; This macro demonstrates how to produce the perceptual colormap shown on the figure 2 in this article.; The function Perceptual_Colormap takes two parameters as input:; h, the TH2D to be drawn; val_cut, the Z value defining the ""sea level"". Having these parameters this function defines two color maps: one above val_cut and one below. ; void Perceptual_Colormap(TH2D *h, Double_t val_cut) {; Double_t max = h->GetMaximum(); // Histogram's maximum; Double_t min = h->GetMinimum(); // Histogram's minimum; Double_t per_cut = (val_cut-min)/(max-min); // normalized value of val_cut; Double_t eps = (max-min)*0.00001; // epsilon; ; // Definition of the two palettes below and above val_cut; const Int_t Number = 4;; Double_t Red[Number] = { 0.11, 0.19 , 0.30, 0.89};; Double_t Green[Number] = { 0.03, 0.304, 0.60, 0.91};; Double_t Blue[Number] = { 0.18, 0.827, 0.50, 0.70};; Double_t Stops[Number] = { 0., per_cut, per_cut+eps, 1. };; ; Int_t nb= 256;; h->SetContour(nb);; ; TColor::CreateGradientColorTable(Number,Stops,Red,Green,Blue,nb);; ; // Histogram drawing; h->Draw(""colz"");; }; ; void perceptualcolormap() {; TH2D *h = new TH2D(""h"",""Perceptual Colormap"",200,-4,4,200,-4,4);; h->SetStats(0);; ; Double_t a,b;; for (Int_t i=0;i<1000000;i++) {; gRandom->Rannor(a,b);; h->Fill(a-1.5,b-1.5,0.1);; h->Fill(a+2.,b-3.,0.07);; h->Fill(a-3.,b+3.,0.05);; gRandom->Rannor(a,b);; h->Fill(a+1.5,b+1.5,-0.08);; }; Percept",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/perceptualcolormap_8C.html:107,Load,Loading,107,doc/master/perceptualcolormap_8C.html,https://root.cern,https://root.cern/doc/master/perceptualcolormap_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/piechart.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. piechart.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Pie chart example. . ; void piechart(); {; Float_t vals[] = {.2,1.1,.6,.9,2.3};; Int_t colors[] = {2,3,4,5,6};; Int_t nvals = sizeof(vals)/sizeof(vals[0]);; ; TCanvas *cpie = new TCanvas(""cpie"",""TPie test"",700,700);; cpie->Divide(2,2);; ; TPie *pie1 = new TPie(""pie1"",; ""Pie with offset and no colors"",nvals,vals);; TPie *pie2 = new TPie(""pie2"",; ""Pie with radial labels"",nvals,vals,colors);; TPie *pie3 = new TPie(""pie3"",; ""Pie with tangential labels"",nvals,vals,colors);; TPie *pie4 = new TPie(""pie4"",; ""Pie with verbose labels"",nvals,vals,colors);; ; cpie->cd(1);; pie1->SetAngularOffset(30.);; pie1->SetEntryRadiusOffset( 4, 0.1);; pie1->SetRadius(.35);; pie1->Draw(""3d"");; ; cpie->cd(2);; pie2->SetEntryRadiusOffset(2,.05);; pie2->SetEntryLineColor(2,2);; pie2->SetEntryLineWidth(2,5);; pie2->SetEntryLineStyle(2,2);; pie2->SetEntryFillStyle(1,3030);; pie2->SetCircle(.5,.45,.3);; pie2->Draw(""rsc"");; ; cpie->cd(3);; pie3->SetY(.32);; pie3->GetSlice(0)->SetValue(.8);; pie3->GetSlice(1)->SetFillStyle(3031);; pie3->SetLabelsOffset(-.1);; pie3->Draw(""3d t nol"");; TLegend *pieleg = pie3->MakeLegend();; pieleg->SetY1(.56); pieleg->SetY2(.86);; ; cpie->cd(4);; pie4->SetRadius(.2);; pie4->SetLabelsOffset(.01);; pie4->SetLabelFormat(""#splitline{%val (%perc)}{%txt}"");; pie4->Draw(""nol <"");; }; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; colorsColor * colorsDefinition X3DBuffer.c:21; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet current canvas & pad.Definition TCanvas.cxx:719; TLegendThis class displays a legend box (TPaveText) containing several legend en",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/piechart_8C.html:97,Load,Loading,97,doc/master/piechart_8C.html,https://root.cern,https://root.cern/doc/master/piechart_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/polytest1.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. polytest1.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This macro is testing the ""compacting"" algorithm in TPadPainter. ; It reduces the number of polygon's vertices using actual pixel coordinates. It's not really useful, but just to test that the resulting polygon is still reasonable. Initial number of points is 1000000, after ""compression"" it's 523904 (with default canvas size, before you tried to resize it) - so almost half of vertices were removed but you can still see the reasonable shape. If you resize a canvas to a smaller size, the number of vertices after compression can be something like 5000 and even less. It's easy to 'fool' this algorithm though in this particular case (ellipse is a kind of fringe case, you can easily have a sequence of almost unique vertices (at a pixel level).; ; //Includes for ACLiC.; #include <cassert>; #include <vector>; ; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""TError.h""; #include ""Rtypes.h""; #include ""TNamed.h""; #include ""TMath.h""; ; class PolyTest1 : public TNamed, public TAttLine, public TAttFill {; public:; PolyTest1(unsigned nVertices);; ; void Paint(const Option_t *notUsed) override;; void Reset(unsigned nVertices);; ; private:; enum {; kNPointsDefault = 10000//minimal number of points.; };; ; std::vector<Double_t> fXs;; std::vector<Double_t> fYs;; };; ; //_____________________________________________________________; PolyTest1::PolyTest1(unsigned nVertices); : TNamed(""polygon_compression_test1"", ""polygon_compression_test1""); {; Reset(nVertices);; }; ; //_____________________________________________________________; void PolyTest1::Reset(unsigned nVertices); {; //Some canvas must already exist by this point.; assert(gPad != nullptr && ""Reset, gPad is null"");; //We need a gRandom to exist.; assert(gRandom != nullptr && ""Reset, gRandom is null"");; ; if (nV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/polytest1_8C.html:98,Load,Loading,98,doc/master/polytest1_8C.html,https://root.cern,https://root.cern/doc/master/polytest1_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/polytest2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. polytest2.C File ReferenceTutorials » Graphics tutorials. Detailed Description; ; This macro is testing the ""compacting"" algorithm in TPadPainter. ; It reduces the number of polygon's vertices using actual pixel coordinates. This macro is testing new ""compacting"" algorithm in TPadPainter (it reduces the number of polygon's vertices using actual pixel coordinates). In principle, this test case is what our histograms (fringe cases) are: ""saw-like"" polygon (bins == teeth).; ; //Includes for ACLiC.; #include <cassert>; #include <vector>; ; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""Rtypes.h""; #include ""TNamed.h""; ; class PolyTest2 : public TNamed, public TAttLine, public TAttFill {; public:; PolyTest2();; ; void Paint(const Option_t *notUsed) override;; ; private:; enum TestSize {; kNSawPoints = 10000; };; ; //Part 1.; std::vector<Double_t> fXs1;; std::vector<Double_t> fYs1;; //Part 2.; ; std::vector<Double_t> fXs2;; std::vector<Double_t> fYs2;; };; ; //_____________________________________________________________; PolyTest2::PolyTest2(); : TNamed(""polygon_compression_test2"", ""polygon_compression_test2""); {; //Polygon 1, n of points is 10003, after 'compression' : 1897; //Polygon 2, n of points is 10003, after 'compression' : 2093; ; //Some canvas must already exist by this point.; assert(gPad != nullptr && ""PolyTest2, gPad is null"");; //We need a gRandom to exist.; assert(gRandom != nullptr && ""PolyTest2, gRandom is null"");; ; Double_t xMin = 0., xMax = 0., yMin = 0., yMax = 0.;; gPad->GetRange(xMin, yMin, xMax, yMax);; assert(xMax - xMin > 0 && yMax - yMin > 0 && ""PolyTest2, invalid canvas' ranges"");; ; ; // .(0/the last)--------.(1); // | /; // | \; // | /; // .(kNSawPoints + 1)--.(kNSawPoints); ; const unsigned nVertices = 3 + kNSawPoints;; ; {; //Polygon 1, ""vertical saw"":; fXs1.resize(nVertices);; fYs1.resize(nVertices);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/polytest2_8C.html:98,Load,Loading,98,doc/master/polytest2_8C.html,https://root.cern,https://root.cern/doc/master/polytest2_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/pstable.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. pstable.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Display all possible types of ROOT/Postscript characters. ; ; void table(Float_t x1, Float_t x2, Float_t yrange, TText &t, const char **symbol, Bool_t octal);; ; void pstable(); {; const char *symbol1[] =; {""A"",""B"",""C"",""D"",""E"",""F"",""G"",""H"",""I"",""J"",""K"",""L"",""M"",""N"",; ""O"",""P"",""Q"",""R"",""S"",""T"",""U"",""V"",""W"",""X"",""Y"",""Z"",; ""0"",""1"",""2"",""3"",""4"",""5"",""6"",""7"",""8"",""9"",; ""."","","",""+"",""-"",""*"",""/"",""="",""("","")"",""{"",""}"",""END""};; ; const char *symbol2[] =; {""a"",""b"",""c"",""d"",""e"",""f"",""g"",""h"",""i"",""j"",""k"",""l"",""m"",""n"",; ""o"",""p"",""q"",""r"",""s"",""t"",""u"",""v"",""w"",""x"",""y"",""z"",; "":"","";"",""@"",""\\"",""_"",""|"",""%"",; ""@'"",""<"","">"",""["",""]"",""\42"",""@\43"",""@\136"",; ""@\77"",""@\41"",""@&"",""$"",""@\176"","" "",""END""};; ; const char *symbol3[] =; {""\241"",""\242"",""\243"",""\244"",""\245"",""\246"",""\247"",""\250"",; ""\251"",""\252"",""\253"",""\254"",""\255"",""\256"",""\257"",""\260"",; ""\261"",""\262"",""\263"",""\264"",""\265"",""\266"",""\267"",""\270"",; ""\271"",""\272"",""\273"",""\274"",""\275"",""\276"",""\277"",""\300"",; ""\301"",""\302"",""\303"",""\304"",""\305"",""\306"",""\307"",""\310"",; ""\311"",""\312"",""\313"",""\314"",""\315"",""\316"",""\317"",""END""};; ; const char *symbol4[] =; {""\321"",""\322"",""\323"",""\324"",""\325"",""\326"",""\327"",""\330"",; ""\331"",""\332"",""\333"",""\334"",""\335"",""\336"",""\337"",""\340"",; ""\341"",""\342"",""\343"",""\344"",""\345"",""\346"",""\347"",""\340"",; ""\351"",""\352"",""\353"",""\354"",""\355"",""\356"",""\357"",""\360"",; ""\361"",""\362"",""\363"",""\364"",""\365"",""\366"",""\367"",""\370"",; ""\371"",""\372"",""\373"",""\374"",""\375"",""\376"",""\377"",""END""};; ; const char *symbol5[] =; {""\177"",""\200"",""\201"",""\202"",""\203"",""\204"",""\205"",""\206"",; ""\207"",""\210"",""\211"",""\212"",""\213"",""\214"",""\215"",""\216"",; ""\217"",""\220"",""\221"",""\222"",""\223"",""\224"",""\225"",""\226"",; ""\227"",""\230"",""\231"",""\232"",""\233"",""\234"",""\235"",""\236"",; ""\237"",""\240"",""END""};; ; Float_t xrange = 18;; Float_t yrange = 25;; Int_t w = 650;; Int_t h = w*yrange/xrange;;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pstable_8C.html:96,Load,Loading,96,doc/master/pstable_8C.html,https://root.cern,https://root.cern/doc/master/pstable_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/psview.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. psview.C File ReferenceTutorials » Graphics tutorials. Detailed Description; An example how to display PS, EPS, PDF files in canvas. ; To load a PS file in a TCanvas, the ghostscript program needs to be install.; On most unix systems it is installed by default.; On Windows it has to be installed from http://pages.cs.wisc.edu/~ghost/ also the place where gswin32c.exe sits should be added in the PATH. One way to do it is:; Start the Control Panel; Double click on System 3, Open the ""Advanced"" tab; Click on the ""Environment Variables"" button; Find ""Path"" in ""System variable list"", click on it.; Click on the ""Edit"" button.; In the ""Variable value"" field add the path of gswin32c (after a "";"") it should be something like: ""C:\Program Files\gs\gs8.13\bin""; click ""OK"" as much as needed. ; #include ""TROOT.h""; #include ""TCanvas.h""; #include ""TImage.h""; ; void psview(); {; // set to batch mode -> do not display graphics; gROOT->SetBatch(1);; ; // create a PostScript file; TString dir = gROOT->GetTutorialDir();; dir.Append(""/graphics/feynman.C"");; gROOT->Macro(dir);; gPad->Print(""feynman.eps"");; ; // back to graphics mode; gROOT->SetBatch(0);; ; // create an image from PS file; TImage *ps = TImage::Open(""feynman.eps"");; ; if (!ps) {; printf(""GhostScript (gs) program must be installed\n"");; return;; }; ; new TCanvas(""psexam"", ""Example how to display PS file in canvas"", 600, 400);; TLatex *tex = new TLatex(0.06,0.9,""The picture below has been loaded from a PS file:"");; tex->Draw();; ; TPad *eps = new TPad(""eps"", ""eps"", 0., 0., 1., 0.75);; eps->Draw();; eps->cd();; ps->Draw(""xxx"");; }; TCanvas.h; TImage.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; gPad#define gPadDefinition TVirtualPad.h:308; TCanvasThe Canvas class.Definition TCanvas.h:23; TImageAn abstract interface to image processing library.Definition TImage.h:29; TImage::Openstatic TIma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/psview_8C.html:95,Load,Loading,95,doc/master/psview_8C.html,https://root.cern,https://root.cern/doc/master/psview_8C.html,2,"['Load', 'load']","['Loading', 'load']"
Performance,". ROOT: tutorials/graphics/quarks.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. quarks.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Example illustrating divided pads and Latex. . ; void quarks () {; TCanvas *c1 = new TCanvas(""c1"", ""c1"",10,10,630,760);; c1->SetFillColor(kBlack);; Int_t quarkColor = 50;; Int_t leptonColor = 16;; Int_t forceColor = 38;; Int_t titleColor = kYellow;; Int_t border = 8;; ; TLatex *texf = new TLatex(0.90,0.455,""Force Carriers"");; texf->SetTextColor(forceColor);; texf->SetTextAlign(22); texf->SetTextSize(0.07);; texf->SetTextAngle(90);; texf->Draw();; ; TLatex *texl = new TLatex(0.11,0.288,""Leptons"");; texl->SetTextColor(leptonColor);; texl->SetTextAlign(22); texl->SetTextSize(0.07);; texl->SetTextAngle(90);; texl->Draw();; ; TLatex *texq = new TLatex(0.11,0.624,""Quarks"");; texq->SetTextColor(quarkColor);; texq->SetTextAlign(22); texq->SetTextSize(0.07);; texq->SetTextAngle(90);; texq->Draw();; ; TLatex tex(0.5,0.5,""u"");; tex.SetTextColor(titleColor); tex.SetTextFont(32);; tex.SetTextAlign(22);; tex.SetTextSize(0.14);; tex.DrawLatex(0.5,0.93,""Elementary"");; tex.SetTextSize(0.12);; tex.DrawLatex(0.5,0.84,""Particles"");; tex.SetTextSize(0.05);; tex.DrawLatex(0.5,0.067,""Three Generations of Matter"");; ; tex.SetTextColor(kBlack); tex.SetTextSize(0.8);; ; // Create main pad and its subdivisions; TPad *pad = new TPad(""pad"", ""pad"",0.15,0.11,0.85,0.79);; pad->Draw();; pad->cd();; pad->Divide(4,4,0.0003,0.0003);; ; pad->cd(1); gPad->SetFillColor(quarkColor);; gPad->SetBorderSize(border);; tex.DrawLatex(.5,.5,""u"");; ; pad->cd(2); gPad->SetFillColor(quarkColor);; gPad->SetBorderSize(border);; tex.DrawLatex(.5,.5,""c"");; ; pad->cd(3); gPad->SetFillColor(quarkColor);; gPad->SetBorderSize(border);; tex.DrawLatex(.5,.5,""t"");; ; pad->cd(4); gPad->SetFillColor(forceColor);; gPad->SetBorderSize(border);; tex.DrawLatex(.5,.55,""#gamma"");; ; pad->cd(5); gPad->SetFillColor(quarkColor);; gP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/quarks_8C.html:95,Load,Loading,95,doc/master/quarks_8C.html,https://root.cern,https://root.cern/doc/master/quarks_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/save_batch.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. save_batch.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This macro demonstrates batch image mode of web canvas When enabled - several images converted into JSON before all together provided to headless browser to produce image files. ; Let significantly increase performance. Important - disable batch mode for flushing remaining images; ; void save_batch(); {; // 37 canvases will be collected together for conversion; TWebCanvas::BatchImageMode(37);; ; auto c = new TCanvas(""canvas"", ""Canvas with histogram"");; ; auto h1 = new TH1I(""hist"", ""Histogram with random data"", 100, -5., 5);; h1->SetDirectory(nullptr);; h1->FillRandom(""gaus"", 10000);; h1->Draw();; ; for(int n = 0; n < 100; ++n) {; h1->FillRandom(""gaus"", 10000);; c->SaveAs(TString::Format(""batch_image_%03d.png"", n));; }; ; // Important - disabling batch mode also flush remaining images; TWebCanvas::BatchImageMode(0);; }; c#define c(i)Definition RSha256.hxx:101; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1I1-D histogram with an int per channel (see TH1 documentation)Definition TH1.h:540; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TWebCanvas::BatchImageModestatic void BatchImageMode(UInt_t n=100)Configure batch image mode for web graphics.Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/save__batch_8C.html:99,Load,Loading,99,doc/master/save__batch_8C.html,https://root.cern,https://root.cern/doc/master/save__batch_8C.html,2,"['Load', 'perform']","['Loading', 'performance']"
Performance,". ROOT: tutorials/graphics/saveall.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. saveall.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Creates many canvases and save as images or pdf. ; This macro creates 100 canvases and store them in different images files using TCanvas::SaveAll() method. Demonstrated how different output format can be used in batch mode.; ; void saveall(); {; gROOT->SetBatch(kTRUE); // enforce batch mode to avoid appearance of multiple canvas windows; ; std::vector<TPad *> pads;; ; for(int n = 0; n < 100; ++n) {; auto c = new TCanvas(TString::Format(""canvas%d"", n), ""Canvas with histogram"");; ; auto h1 = new TH1I(TString::Format(""hist%d"", n), ""Histogram with random data"", 100, -5., 5);; h1->SetDirectory(nullptr);; h1->FillRandom(""gaus"", 10000);; ; h1->Draw();; ; pads.push_back(c);; }; ; TCanvas::SaveAll(pads, ""image%03d.png""); // create 100 PNG images; ; TCanvas::SaveAll(pads, ""image.svg""); // create 100 SVG images, %d pattern will be automatically append; ; TCanvas::SaveAll(pads, ""images.root""); // create single ROOT file with all canvases; ; TCanvas::SaveAll(); // save all existing canvases in allcanvases.pdf file; }; c#define c(i)Definition RSha256.hxx:101; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; gROOT#define gROOTDefinition TROOT.h:406; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::SaveAllstatic Bool_t SaveAll(const std::vector< TPad * > &={}, const char *filename="""", Option_t *option="""")Save provided pads/canvases into the image file(s) Filename can include printf argument for image num...Definition TCanvas.cxx:2654; TH1I1-D histogram with an int per channel (see TH1 documentation)Definition TH1.h:540; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::FillRandomvirtual void FillRandom(const char *fnam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/saveall_8C.html:96,Load,Loading,96,doc/master/saveall_8C.html,https://root.cern,https://root.cern/doc/master/saveall_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/schroedinger_hydrogen.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. schroedinger_hydrogen.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Plot the Amplitude of a Hydrogen Atom. ; Visualize the Amplitude of a Hydrogen Atom in the n = 2, l = 0, m = 0 state. Demonstrates how TH2F can be used in Quantum Mechanics.; The formula for Hydrogen in this energy state is \( \psi_{200} = \frac{1}{4\sqrt{2\pi}a_0 ^{\frac{3}{2}}}(2-\frac{\sqrt{x^2+y^2}}{a_0})e^{-\frac{\sqrt{x^2+y^2}}{2a_0}} \). ; #include <cmath>; ; double WaveFunction(double x, double y) {; double r = sqrt(x *x + y*y);; ; double w = (1/pow((4*sqrt(2*TMath::Pi())* 1), 1.5)) * (2 - (r / 1)*pow(TMath::E(), (-1 * r)/2)); // Wavefunction formula for psi 2,0,0; ; return w*w; // Amplitude; ; }; ; void schroedinger_hydrogen() {; TH2F *h2D = new TH2F(""Hydrogen Atom"",; ""Hydrogen in n = 2, l = 0, m = 0 state; Position in x direction; Position in y direction"",; 200, -10, 10, 200, -10, 10);; ; for (float i = -10; i < 10; i += 0.01) {; for (float j = -10; j < 10; j += 0.01) {; h2D->Fill(i, j, WaveFunction(i, j));; }; }; ; gStyle->SetPalette(kCividis);; gStyle->SetOptStat(0);; ; TCanvas *c1 = new TCanvas(""c1"", ""Schroedinger's Hydrogen Atom"", 750, 1500);; c1->Divide(1, 2);; ; auto c1_1 = c1->cd(1);; c1_1->SetRightMargin(0.14);; h2D->GetXaxis()->SetLabelSize(0.03);; h2D->GetYaxis()->SetLabelSize(0.03);; h2D->GetZaxis()->SetLabelSize(0.03);; h2D->SetContour(50);; h2D->Draw(""colz"");; ; TLatex *l = new TLatex(-10, -12.43, ""The Electron is more likely to be found in the yellow areas and less likely to be found in the blue areas."");; l->SetTextFont(42);; l->SetTextSize(0.02);; l->Draw();; ; auto c1_2 = c1->cd(2);; c1_2->SetTheta(42.);; ; TH2D *h2Dc = (TH2D*)h2D->Clone();; h2Dc->SetTitle(""3D view of probability amplitude;;"");; h2Dc->Draw(""surf2"");; }; kCividis@ kCividisDefinition TColor.h:136; wwinID wDefinition TGWin32VirtualGLProxy.cx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/schroedinger__hydrogen_8C.html:110,Load,Loading,110,doc/master/schroedinger__hydrogen_8C.html,https://root.cern,https://root.cern/doc/master/schroedinger__hydrogen_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/tmathtext.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmathtext.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This macro draws various formula in a canvas. ; It also prints the canvas as a Postscript file using TMathText. ; {; TCanvas *c1 = new TCanvas(""c1"");; ; TMathText l;; l.SetTextAlign(23);; l.SetTextSize(0.06);; l.DrawMathText(0.50, 1.000, ""\\prod_{j\\ge0} \\left(\\sum_{k\\ge0} a_{jk}z^k\\right) = \\sum_{n\\ge0} z^n \\left(\\sum_{k_0,k_1,\\ldots\\ge0\\atop k_0+k_1+\\cdots=n} a_{0k_0}a_{1k_1} \\cdots \\right)"");; l.DrawMathText(0.50, 0.800, ""W_{\\delta_1\\rho_1\\sigma_2}^{3\\beta} = U_{\\delta_1\\rho_1\\sigma_2}^{3\\beta} + {1\\over 8\\pi^2} \\int_{\\alpha_1}^{\\alpha_2} d\\alpha_2^\\prime \\left[ {U_{\\delta_1\\rho_1}^{2\\beta} - \\alpha_2^\\prime U_{\\rho_1\\sigma_2}^{1\\beta} \\over U_{\\rho_1\\sigma_2}^{0\\beta}} \\right]"");; l.DrawMathText(0.50, 0.600, ""d\\Gamma = {1\\over 2m_A} \\left( \\prod_f {d^3p_f\\over (2\\pi)^3} {1\\over 2E_f} \\right) \\left| \\mathscr{M} \\left(m_A - \\left\\{p_f\\right\\} \\right) \\right|^2 (2\\pi)^4 \\delta^{(4)} \\left(p_A - \\sum p_f \\right)"");; l.DrawMathText(0.50, 0.425, ""4\\mathrm{Re}\\left\\{{2\\over 1-\\Delta\\alpha} \\chi(s) \\left[ \\^{g}_\\nu^e \\^{g}_\\nu^f (1 + \\cos^2\\theta) + \\^{g}_a^e \\^{g}_a^f \\cos\\theta \\right] \\right\\}"");; l.DrawMathText(0.50, 0.330, ""p(n) = {1\\over\\pi\\sqrt{2}} \\sum_{k = 1}^\\infty \\sqrt{k} A_k(n) {d\\over dn} {\\sinh \\left\\{ {\\pi\\over k} \\sqrt{2\\over 3} \\sqrt{n - {1\\over 24}} \\right\\} \\over \\sqrt{n - {1\\over 24}}}"");; l.DrawMathText(0.13, 0.150, ""{(\\ell+1)C_{\\ell}^{TE} \\over 2\\pi}"");; l.DrawMathText(0.27, 0.110, ""\\mathbb{N} \\subset \\mathbb{R}"");; l.DrawMathText(0.63, 0.100, ""\\hbox{RHIC スピン物理 Нью-Йорк}"");; ; c1->Print(""c1.png"");; c1->Print(""c1.ps"");; ; return c1;; }; TCanvasThe Canvas class.Definition TCanvas.h:23; TLine::Printvoid Print(Option_t *option=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmathtext_8C.html:98,Load,Loading,98,doc/master/tmathtext_8C.html,https://root.cern,https://root.cern/doc/master/tmathtext_8C.html,1,['Load'],['Loading']
Performance,. ROOT: tutorials/graphics/tmathtext2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmathtext2.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This macro draw all possible symbols provided by TMathtext. . AuthorOlivier Couet ; Definition in file tmathtext2.C. tutorialsgraphicstmathtext2.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmathtext2_8C.html:99,Load,Loading,99,doc/master/tmathtext2_8C.html,https://root.cern,https://root.cern/doc/master/tmathtext2_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/tornado.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tornado.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Show 3-d polymarker. . ; void tornado() {; gBenchmark->Start(""tornado"");; ; double PI = 3.141592653;; int d = 16;; int numberOfPoints=200;; int numberOfCircles=40;; ; // create and open a canvas; TCanvas *sky = new TCanvas( ""sky"", ""Tornado"", 300, 10, 700, 500 );; sky->SetFillColor(14);; ; // creating view; TView *view = TView::CreateView(1,0,0);; float range = numberOfCircles*d;; view->SetRange( 0, 0, 0, 4.0*range, 2.0*range, range );; ; for( int j = d; j < numberOfCircles*d; j += d ) {; ; // create a PolyMarker3D; TPolyMarker3D *pm3d = new TPolyMarker3D( numberOfPoints );; ; float x, y, z;; ; // set points; for( int i = 1; i < numberOfPoints; i++ ) {; float csin = sin(2*PI / (double)numberOfPoints * (double)i) + 1;; float ccos = cos(2*PI / (double)numberOfPoints * (double)i) + 1;; float esin = sin(2*PI / (double)(numberOfCircles*d) * (double)j) + 1;; x = j * ( csin + esin );; y = j * ccos;; z = j;; pm3d->SetPoint( i, x, y, z );; }; ; // set marker size, color & style; pm3d->SetMarkerSize( 1 );; pm3d->SetMarkerColor( 2 + ( d == ( j & d ) ) );; pm3d->SetMarkerStyle( 3 );; ; //draw; pm3d->Draw();; }; ; char timeStr[60];; gBenchmark->Show(""tornado"");; ; Float_t ct = gBenchmark->GetCpuTime(""tornado"");; sprintf( timeStr, ""Execution time: %g sec."", ct);; ; TPaveText *text = new TPaveText( 0.1, 0.81, 0.9, 0.97 );; text->SetFillColor( 42 );; text->AddText(""ROOT example: tornado.C"");; text->AddText(timeStr);; text->Draw();; sky->Update();; }; d#define d(i)Definition RSha256.hxx:102; Float_tfloat Float_tDefinition RtypesCore.h:57; PI#define PIDefinition SpecFuncMathCore.cxx:23; gBenchmarkR__EXTERN TBenchmark * gBenchmarkDefinition TBenchmark.h:59; textOption_t Option_t TPoint TPoint const char textDefinition TGWin32VirtualXProxy.cxx:68; TAttFill::SetFillColorvirtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tornado_8C.html:96,Load,Loading,96,doc/master/tornado_8C.html,https://root.cern,https://root.cern/doc/master/tornado_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/transparency.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. transparency.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This macro demonstrates the use of color transparency. ; It is done by specifying the alpha value of a given color. For instance; ellipse->SetFillColorAlpha(9, 0.571);; changes the ellipse fill color to the index 9 with an alpha value of 0.571. 0. would be fully transparent (invisible) and 1. completely opaque (the default).; The transparency is available on all platforms when the flag OpenGL.CanvasPreferGL is set to 1 in $ROOTSYS/etc/system.rootrc, or on Mac with the Cocoa backend. X11 does not support transparency. On the file output it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript. ; void transparency(); {; auto c1 = new TCanvas(""c1"", ""c1"",224,330,700,527);; c1->Range(-0.125,-0.125,1.125,1.125);; ; auto tex = new TLatex(0.06303724,0.0194223,""This text is opaque and this line is transparent"");; tex->SetLineWidth(2);; tex->Draw();; ; auto arrow = new TArrow(0.5555158,0.07171314,0.8939828,0.6195219,0.05,""|>"");; arrow->SetLineWidth(4);; arrow->SetAngle(30);; arrow->Draw();; ; // Draw a transparent graph.; Double_t x[10] = {; 0.5232808, 0.8724928, 0.9280086, 0.7059456, 0.7399714,; 0.4659742, 0.8241404, 0.4838825, 0.7936963, 0.743553};; Double_t y[10] = {; 0.7290837, 0.9631474, 0.4775896, 0.6494024, 0.3555777,; 0.622012, 0.7938247, 0.9482072, 0.3904382, 0.2410359};; auto graph = new TGraph(10,x,y);; graph->SetLineColorAlpha(46, 0.1);; graph->SetLineWidth(7);; graph->Draw(""l"");; ; // Draw an ellipse with opaque colors.; auto ellipse = new TEllipse(0.1740688,0.8352632,0.1518625,0.1010526,0,360,0);; ellipse->SetFillColor(30);; ellipse->SetLineColor(51);; ellipse->SetLineWidth(3);; ellipse->Draw();; ; // Draw an ellipse with transparent colors, above the previous one.; ellipse = new TEllipse(0.2985315,0.7092105,0.1566977,0.1868421,0,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/transparency_8C.html:101,Load,Loading,101,doc/master/transparency_8C.html,https://root.cern,https://root.cern/doc/master/transparency_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphics/triangles.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. triangles.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Create small triangles at random positions on the canvas. ; Assign a unique ID to each triangle, and give each one a random color from the color palette.; root > .x triangles.C; When a triangle is clicked, a message displaying its unique number and color will be printed. ; void triangles(int ntriangles=50); {; auto c1 = new TCanvas(""c1"",""triangles"",10,10,700,700);; gStyle->SetPalette(kCMYK);; TRandom r;; double dx = 0.2; double dy = 0.2;; int ncolors = TColor::GetNumberOfColors();; double x[4],y[4];; for (int i=0;i<ntriangles;i++) {; x[0] = r.Uniform(.05,.95); y[0] = r.Uniform(.05,.95);; x[1] = x[0] + dx*r.Rndm(); y[1] = y[0] + dy*r.Rndm();; x[2] = x[1] - dx*r.Rndm(); y[2] = y[1] - dy*r.Rndm();; x[3] = x[0]; y[3] = y[0];; auto pl = new TPolyLine(4,x,y);; pl->SetUniqueID(i);; int ci = ncolors*r.Rndm();; TColor *c = gROOT->GetColor(TColor::GetColorPalette(ci));; c->SetAlpha(r.Rndm());; pl->SetFillColor(c->GetNumber());; pl->Draw(""f"");; }; c1->AddExec(""ex"",""TriangleClicked()"");; }; ; void TriangleClicked(); {; //this action function is called whenever you move the mouse; //it just prints the id of the picked triangle; //you can add graphics actions instead; int event = gPad->GetEvent();; if (event != 11) return; //may be comment this line; TObject *select = gPad->GetSelected();; if (!select) return;; if (select->InheritsFrom(TPolyLine::Class())) {; TPolyLine *pl = (TPolyLine*)select;; printf(""You have clicked triangle %d, color=%d\n"",; pl->GetUniqueID(),pl->GetFillColor());; }; }; c#define c(i)Definition RSha256.hxx:101; kCMYK@ kCMYKDefinition TColor.h:123; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Fl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/triangles_8C.html:98,Load,Loading,98,doc/master/triangles_8C.html,https://root.cern,https://root.cern/doc/master/triangles_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs Directory Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graphs Directory Reference. Directory dependency graph for graphs:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files;  annotation3d.C;   This example show how to put some annotation on a 3D plot using 3D polylines. ;  ;  approx.C;   Macro to test interpolation function Approx ;  ;  bent.C;   Bent error bars ;  ;  bent.py;   Bent error bars. ;  ;  exclusiongraph.C;   Draw three graphs with an exclusion zone. ;  ;  exclusiongraph2.C;   Draw several graphs with an exclusion zones. ;  ;  gerrors.C;   Draw a graph with error bars ;  ;  gerrors2.C;   Draw two graphs with error bars ;  ;  gmultierrors.C;   Draw a graph with multiple y errors ;  ;  graph.C;   Draw a simple graph. ;  ;  graph2derrorsfit.C;   Draw and fit a TGraph2DErrors ;  ;  graphApply.C;   A macro to demonstrate the functionality of TGraph::Apply() method. ;  ;  graphpalettecolor.C;   Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ;  ;  graphpolar.C;   Create and draw a polar graph. ;  ;  graphpolar2.C;   Create and draw a polar graph with PI axis ;  ;  graphpolar3.C;   Create and draw a polar graph with PI axis using a TF1. ;  ;  graphreverse.C;   This example test all the various case of reverse graphs combined with logarithmic scale. ;  ;  graphShade.C;   Show how to shade an area between two graphs ;  ;  graphstruct.C;   Draw a simple graph structure. ;  ;  graphtext.C;   Draw a graph with text attached to each point. ;  ;  gtime.C;   Example of TGraphTime. ;  ;  gtime2.C;   Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program. ;  ;  hlGraph1.C;  This tutorial demonstrates how to use the highlight mode on graph. ;  ;  hlGraph2.C;  This tutorial demonstrates ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html:89,Load,Loading,89,doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html,https://root.cern,https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/annotation3d.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. annotation3d.C File ReferenceTutorials » Graphs tutorials. Detailed Description; This example show how to put some annotation on a 3D plot using 3D polylines. ; It also demonstrates how the axis labels can be modified. It was created for the book: Statistical Methods for Data Analysis in Particle Physics . ; void annotation3d(); {; auto c = new TCanvas(""c"", ""c"", 600, 600);; c->SetTheta(30);; c->SetPhi(50);; gStyle->SetOptStat(0);; gStyle->SetHistTopMargin(0);; gStyle->SetOptTitle(kFALSE);; ; // Define and draw a surface; auto f = new TF2(""f"", ""[0]*cos(x)*cos(y)"", -1, 1, -1, 1);; f->SetParameter(0, 1);; double s = 1./f->Integral(-1, 1, -1, 1);; f->SetParameter(0, s);; f->SetNpx(50);; f->SetNpy(50);; ; f->GetXaxis()->SetTitle(""x"");; f->GetXaxis()->SetTitleOffset(1.4);; f->GetXaxis()->SetTitleSize(0.04);; f->GetXaxis()->CenterTitle();; f->GetXaxis()->SetNdivisions(505);; f->GetXaxis()->SetTitleOffset(1.3);; f->GetXaxis()->SetLabelSize(0.03);; f->GetXaxis()->ChangeLabelByValue(-0.5,-1,-1,-1,kRed,-1,""X_{0}"");; ; f->GetYaxis()->SetTitle(""y"");; f->GetYaxis()->CenterTitle();; f->GetYaxis()->SetTitleOffset(1.4);; f->GetYaxis()->SetTitleSize(0.04);; f->GetYaxis()->SetTitleOffset(1.3);; f->GetYaxis()->SetNdivisions(505);; f->GetYaxis()->SetLabelSize(0.03);; ; f->GetZaxis()->SetTitle(""dP/dx"");; f->GetZaxis()->CenterTitle();; f->GetZaxis()->SetTitleOffset(1.3);; f->GetZaxis()->SetNdivisions(505);; f->GetZaxis()->SetTitleSize(0.04);; f->GetZaxis()->SetLabelSize(0.03);; ; f->SetLineWidth(1);; f->SetLineColorAlpha(kAzure-2, 0.3);; ; f->Draw(""surf1 fb"");; ; // Lines for 3D annotation; double x[11] = {-0.500, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.500};; double y[11] = {-0.985, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 0.985};; double z[11];; for (int i = 0; i < 11; ++i) z[i] = s*cos(x[i])*cos(y[i]);; auto g2 = new TPolyLine3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/annotation3d_8C.html:99,Load,Loading,99,doc/master/annotation3d_8C.html,https://root.cern,https://root.cern/doc/master/annotation3d_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/approx.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. approx.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Macro to test interpolation function Approx . ; TCanvas *vC1;; TGraph *grxy, *grin, *grout;; ; void DrawSmooth(Int_t pad, const char *title, const char *xt, const char *yt); {; vC1->cd(pad);; TH1F *vFrame = gPad->DrawFrame(0,0,15,150);; vFrame->SetTitle(title);; vFrame->SetTitleSize(0.2);; vFrame->SetXTitle(xt);; vFrame->SetYTitle(yt);; grxy->SetMarkerColor(kBlue);; grxy->SetMarkerStyle(21);; grxy->SetMarkerSize(0.5);; grxy->Draw(""P"");; grin->SetMarkerColor(kRed);; grin->SetMarkerStyle(5);; grin->SetMarkerSize(0.7);; grin->Draw(""P"");; grout->DrawClone(""LP"");; }; ; void approx(); {; // Test data (square); Int_t n = 11;; Double_t x[] = {1,2,3,4,5,6,6,6,8,9,10};; Double_t y[] = {1,4,9,16,25,25,36,49,64,81,100};; grxy = new TGraph(n,x,y);; ; // X values, for which y values should be interpolated; Int_t nout = 14;; Double_t xout[] =; {1.2,1.7,2.5,3.2,4.4,5.2,5.7,6.5,7.6,8.3,9.7,10.4,11.3,13};; ; // Create Canvas; vC1 = new TCanvas(""vC1"",""square"",200,10,700,700);; vC1->Divide(2,2);; ; // Initialize graph with data; grin = new TGraph(n,x,y);; // Interpolate at equidistant points (use mean for tied x-values); TGraphSmooth *gs = new TGraphSmooth(""normal"");; grout = gs->Approx(grin,""linear"");; DrawSmooth(1,""Approx: ties = mean"",""X-axis"",""Y-axis"");; ; // Re-initialize graph with data; // (since graph points were set to unique vales); grin = new TGraph(n,x,y);; // Interpolate at given points xout; grout = gs->Approx(grin,""linear"", 14, xout, 0, 130);; DrawSmooth(2,""Approx: ties = mean"","""","""");; ; // Print output variables for given values xout; Int_t vNout = grout->GetN();; Double_t vXout, vYout;; for (Int_t k=0;k<vNout;k++) {; grout->GetPoint(k, vXout, vYout);; cout << ""k= "" << k << "" vXout[k]= "" << vXout; << "" vYout[k]= "" << vYout << endl;; }; ; // Re-initialize graph with da",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/approx_8C.html:93,Load,Loading,93,doc/master/approx_8C.html,https://root.cern,https://root.cern/doc/master/approx_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/bent.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. bent.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Bent error bars . ; void bent() ; {; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; TGraphBentErrors *gr = new TGraphBentErrors(; n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TGraphBentErrorsA TGraphBentErrors is a TGraph with bent, asymmetric error bars.Definition TGraphBentErrors.h:25; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TGraph::SetTitlevoid SetTitle(const char *title="""") overrideChange (i.e.Definition TGraph.cxx:2397; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; bentDefinition bent.py:1; AuthorOlivier Couet ; Definition in file bent.C. tutorialsgraphsbent.C. ROOT master - Reference Guide Generated o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/bent_8C.html:91,Load,Loading,91,doc/master/bent_8C.html,https://root.cern,https://root.cern/doc/master/bent_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/bent.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; bent.py File ReferenceTutorials » Graphs tutorials. Detailed Description; Bent error bars. ; Inspired from work of Olivier Couet. ; import ROOT; ; c1 = ROOT.TCanvas(); n = 10; x = ROOT.std.vector('double')(); for i in [-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95]: x.push_back(i); y = ROOT.std.vector('double')(); for i in [1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1]: y.push_back(i); exl = ROOT.std.vector('double')(); for i in [.05,.1,.07,.07,.04,.05,.06,.07,.08,.05]: exl.push_back(i); eyl = ROOT.std.vector('double')(); for i in [.8,.7,.6,.5,.4,.4,.5,.6,.7,.8]: eyl.push_back(i); exh = ROOT.std.vector('double')(); for i in [.02,.08,.05,.05,.03,.03,.04,.05,.06,.03]: exh.push_back(i); eyh = ROOT.std.vector('double')(); for i in [.6,.5,.4,.3,.2,.2,.3,.4,.5,.6]: eyh.push_back(i); exld = ROOT.std.vector('double')(); for i in [.0,.0,.0,.0,.0,.0,.0,.0,.0,.0]: exld.push_back(i); eyld = ROOT.std.vector('double')(); for i in [.0,.0,.05,.0,.0,.0,.0,.0,.0,.0]: eyld.push_back(i); exhd = ROOT.std.vector('double')(); for i in [.0,.0,.0,.0,.0,.0,.0,.0,.0,.0]: exhd.push_back(i); eyhd = ROOT.std.vector('double')(); for i in [.0,.0,.0,.0,.0,.0,.0,.0,.05,.0]: eyhd.push_back(i); ; gr = ROOT.TGraphBentErrors(; n,x.data(),y.data(),exl.data(),exh.data(),eyl.data(),eyh.data(),exld.data(),exhd.data(),eyld.data(),eyhd.data()); ; gr.SetTitle(""TGraphBentErrors Example""); gr.SetMarkerColor(4); gr.SetMarkerStyle(21); gr.Draw(""ALP""); AuthorAlberto Ferro ; Definition in file bent.py. tutorialsgraphsbent.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/bent_8py.html:92,Load,Loading,92,doc/master/bent_8py.html,https://root.cern,https://root.cern/doc/master/bent_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/exclusiongraph.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. exclusiongraph.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Draw three graphs with an exclusion zone. . ; TCanvas *exclusiongraph() {; TCanvas *c1 = new TCanvas(""c1"",""Exclusion graphs examples"",200,10,600,400);; c1->SetGrid();; ; TMultiGraph *mg = new TMultiGraph();; mg->SetTitle(""Exclusion graphs"");; ; const Int_t n = 35;; Double_t xvalues1[n], xvalues2[n], xvalues3[n], yvalues1[n], yvalues2[n], yvalues3[n];; for (Int_t i=0;i<n;i++) {; xvalues1[i] = i*0.1;; xvalues2[i] = xvalues1[i];; xvalues3[i] = xvalues1[i]+.5;; yvalues1[i] = 10*sin(xvalues1[i]);; yvalues2[i] = 10*cos(xvalues1[i]);; yvalues3[i] = 10*sin(xvalues1[i])-2;; }; ; TGraph *gr1 = new TGraph(n,xvalues1,yvalues1);; gr1->SetLineColor(2);; gr1->SetLineWidth(1504);; gr1->SetFillStyle(3005);; ; TGraph *gr2 = new TGraph(n,xvalues2,yvalues2);; gr2->SetLineColor(4);; gr2->SetLineWidth(-2002);; gr2->SetFillStyle(3004);; gr2->SetFillColor(9);; ; TGraph *gr3 = new TGraph(n,xvalues3,yvalues3);; gr3->SetLineColor(5);; gr3->SetLineWidth(-802);; gr3->SetFillStyle(3002);; gr3->SetFillColor(2);; ; mg->Add(gr1);; mg->Add(gr2);; mg->Add(gr3);; mg->Draw(""AC"");; ; return c1;; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TMultiGraphA TMultiG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/exclusiongraph_8C.html:101,Load,Loading,101,doc/master/exclusiongraph_8C.html,https://root.cern,https://root.cern/doc/master/exclusiongraph_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/exclusiongraph2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. exclusiongraph2.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Draw several graphs with an exclusion zones. . ; void exclusiongraph2(); {; TCanvas *c = new TCanvas(""c"",; ""Charged Higgs L300 Contour"",0,0,700,700);; c->SetTickx();; c->SetTicky();; c->SetGridx();; c->SetGridy();; ; TH1 *frame = new TH1F(""frame"","""",1000,50,500);; frame->SetMinimum(1);; frame->SetMaximum(50);; frame->SetDirectory(0);; frame->SetStats(0);; frame->GetXaxis()->SetTitle(""m_{A} (GeV)"");; frame->GetXaxis()->SetTickLength(0.02);; frame->GetXaxis()->SetLabelSize(0.03);; frame->GetYaxis()->SetTitle(""tan#beta"");; frame->GetYaxis()->SetMoreLogLabels();; frame->GetYaxis()->SetLabelSize(0.03);; frame->Draw("" "");; c->SetLogy();; ; TGraph *gr1 = new TGraph(10);; gr1->SetFillColor(6);; gr1->SetFillStyle(3005);; gr1->SetLineColor(6);; gr1->SetLineWidth(603);; gr1->SetPoint(0,140,0.5);; gr1->SetPoint(1,130,2.9);; gr1->SetPoint(2,124.677,3.83726);; gr1->SetPoint(3,113.362,6.06903);; gr1->SetPoint(4,108.513,8.00221);; gr1->SetPoint(5,111.746,10.0272);; gr1->SetPoint(6,119.828,12.8419);; gr1->SetPoint(7,135.991,30.0872);; gr1->SetPoint(8,140,40);; gr1->SetPoint(9,135,60);; gr1->Draw(""C"");; TLatex *tex = new TLatex(140.841,37.9762,; ""#leftarrow t #rightarrow bH^{+}, H^{+} #rightarrow #tau#nu"");; tex->SetTextColor(6);; tex->Draw();; ; TGraph *gr2 = new TGraph(15);; gr2->SetName(""Graph"");; gr2->SetTitle(""Graph"");; gr2->SetFillColor(1);; gr2->SetFillStyle(3005);; gr2->SetLineWidth(3);; gr2->SetPoint(0,499.192,3.02622);; gr2->SetPoint(1,427.748,3.06233);; gr2->SetPoint(2,358.244,3.10722);; gr2->SetPoint(3,305.711,3.24589);; gr2->SetPoint(4,244.289,3.36617);; gr2->SetPoint(5,206.304,3.7544);; gr2->SetPoint(6,178.017,4.50347);; gr2->SetPoint(7,148.114,6.20297);; gr2->SetPoint(8,131.142,8.00221);; gr2->SetPoint(9,111.746,8.48188);; gr2->SetPoint(10,102.047,9.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/exclusiongraph2_8C.html:102,Load,Loading,102,doc/master/exclusiongraph2_8C.html,https://root.cern,https://root.cern/doc/master/exclusiongraph2_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/gerrors.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. gerrors.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Draw a graph with error bars . ; void gerrors() {; TCanvas *c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; ; c1->SetGrid();; c1->GetFrame()->SetBorderSize(12);; ; const Int_t n = 10;; Float_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; TGraphErrors *gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; ; c1->Update();; }; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TGraph::SetTitlevoid SetTitle(const char *title="""") overrideChange (i.e.Definition TGraph.cxx:2397; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; exDouble_t ex[n]Definition legend1.C:17; gerrorsDefinition gerrors.py:1; AuthorRene Brun ; Definition in file gerrors.C. tutorialsgraphsgerrors.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gerrors_8C.html:94,Load,Loading,94,doc/master/gerrors_8C.html,https://root.cern,https://root.cern/doc/master/gerrors_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/gerrors2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. gerrors2.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Draw two graphs with error bars . ; void gerrors2() {; TCanvas *c1 = new TCanvas(""c1"",""gerrors2"",200,10,700,500);; c1->SetGrid();; ; // draw a frame to define the range; TH1F *hr = c1->DrawFrame(-0.4,0,1.2,12);; hr->SetXTitle(""X title"");; hr->SetYTitle(""Y title"");; c1->GetFrame()->SetBorderSize(12);; ; // create first graph; const Int_t n1 = 10;; Double_t xval1[] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t yval1[] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t ex1[] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t ey1[] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; TGraphErrors *gr1 = new TGraphErrors(n1,xval1,yval1,ex1,ey1);; gr1->SetMarkerColor(kBlue);; gr1->SetMarkerStyle(21);; gr1->Draw(""LP"");; ; // create second graph; const Int_t n2 = 10;; Float_t xval2[] = {-0.28, 0.005, 0.19, 0.29, 0.45, 0.56,0.65,0.80,0.90,1.01};; Float_t yval2[] = {0.82,3.86,7,9,10,10.55,9.64,7.26,5.42,2};; Float_t ex2[] = {.04,.12,.08,.06,.05,.04,.07,.06,.08,.04};; Float_t ey2[] = {.6,.8,.7,.4,.3,.3,.4,.5,.6,.7};; TGraphErrors *gr2 = new TGraphErrors(n2,xval2,yval2,ex2,ey2);; gr2->SetMarkerColor(kRed);; gr2->SetMarkerStyle(20);; gr2->Draw(""LP"");; }; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraph::Drawvoid Draw(Option_t *chopt=""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gerrors2_8C.html:95,Load,Loading,95,doc/master/gerrors2_8C.html,https://root.cern,https://root.cern/doc/master/gerrors2_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/gmultierrors.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. gmultierrors.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Draw a graph with multiple y errors . ; void gmultierrors() {; TCanvas *c1 = new TCanvas(""c1"", ""A Simple Graph with multiple y-errors"", 200, 10, 700, 500);; c1->SetGrid();; c1->GetFrame()->SetBorderSize(12);; ; const Int_t np = 5;; Double_t x[np] = {0, 1, 2, 3, 4};; Double_t y[np] = {0, 2, 4, 1, 3};; Double_t exl[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; Double_t exh[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; Double_t eylstat[np] = {1, 0.5, 1, 0.5, 1};; Double_t eyhstat[np] = {0.5, 1, 0.5, 1, 0.5};; Double_t eylsys[np] = {0.5, 0.4, 0.8, 0.3, 1.2};; Double_t eyhsys[np] = {0.6, 0.7, 0.6, 0.4, 0.8};; ; TGraphMultiErrors* gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", np, x, y, exl, exh, eylstat, eyhstat);; gme->AddYError(np, eylsys, eyhsys);; gme->SetMarkerStyle(20);; gme->SetLineColor(kRed);; gme->GetAttLine(0)->SetLineColor(kRed);; gme->GetAttLine(1)->SetLineColor(kBlue);; gme->GetAttFill(1)->SetFillStyle(0);; ; // Graph and x erros drawn with ""APS""; // Stat Errors drawn with ""Z""; // Sys Errors drawn with ""5 s=0.5""; gme->Draw(""APS ; Z ; 5 s=0.5"");; ; c1->Update();; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; npOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t npDefinition TGWin32VirtualXProx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gmultierrors_8C.html:99,Load,Loading,99,doc/master/gmultierrors_8C.html,https://root.cern,https://root.cern/doc/master/gmultierrors_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/graph.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graph.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Draw a simple graph. . ; void graph() {; TCanvas *c1 = new TCanvas(""c1"",""A Simple Graph Example"",200,10,700,500);; ; c1->SetGrid();; ; const Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; printf("" i %i %f %f \n"",i,x[i],y[i]);; }; TGraph *gr = new TGraph(n,x,y);; gr->SetLineColor(2);; gr->SetLineWidth(4);; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->SetTitle(""a simple graph"");; gr->GetXaxis()->SetTitle(""X title"");; gr->GetYaxis()->SetTitle(""Y title"");; gr->Draw(""ACP"");; ; // TCanvas::Update() draws the frame, after which one can change it; c1->Update();; c1->GetFrame()->SetBorderSize(12);; c1->Modified();; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TGraph::GetXaxisTAxis * GetXaxis() constGet x axis of the graph.Definition TGraph.cxx:1566; TGraph::GetYaxisTAxis * GetYaxis() constGet y axis of the graph.Definition TGraph.cxx:1575; TGraph::SetTitlevoid SetTitle(const char *title="""") overrideChange (i.e.Definition TGraph.cxx:2397; TNamed::SetTit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/graph_8C.html:92,Load,Loading,92,doc/master/graph_8C.html,https://root.cern,https://root.cern/doc/master/graph_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/graph2derrorsfit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graph2derrorsfit.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Draw and fit a TGraph2DErrors . ; #include <TMath.h>; #include <TGraph2DErrors.h>; #include <TRandom.h>; #include <TStyle.h>; #include <TCanvas.h>; #include <TF2.h>; ; void graph2derrorsfit(); {; TCanvas *c1 = new TCanvas(""c1"");; ; Double_t rnd, x, y, z, ex, ey, ez;; Double_t e = 0.3;; Int_t nd = 500;; ; TRandom r;; TF2 *f2 = new TF2(""f2"",""1000*(([0]*sin(x)/x)*([1]*sin(y)/y))+200"",-6,6,-6,6);; f2->SetParameters(1,1);; TGraph2DErrors *dte = new TGraph2DErrors(nd);; ; // Fill the 2D graph; Double_t zmax = 0;; for (Int_t i=0; i<nd; i++) {; f2->GetRandom2(x,y);; rnd = r.Uniform(-e,e); // Generate a random number in [-e,e]; z = f2->Eval(x,y)*(1+rnd);; if (z>zmax) zmax = z;; dte->SetPoint(i,x,y,z);; ex = 0.05*r.Rndm();; ey = 0.05*r.Rndm();; ez = TMath::Abs(z*rnd);; dte->SetPointError(i,ex,ey,ez);; }; ; f2->SetParameters(0.5,1.5);; dte->Fit(f2);; TF2 *fit2 = (TF2*)dte->FindObject(""f2"");; fit2->SetTitle(""Minuit fit result on the Graph2DErrors points"");; fit2->SetMaximum(zmax);; gStyle->SetHistTopMargin(0);; fit2->SetLineColor(1);; fit2->SetLineWidth(1);; fit2->Draw(""surf1"");; dte->Draw(""same p0"");; }; e#define e(i)Definition RSha256.hxx:103; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; TCanvas.h; TF2.h; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TGraph2DErrors.h; TMath.h; TRandom.h; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/graph2derrorsfit_8C.html:103,Load,Loading,103,doc/master/graph2derrorsfit_8C.html,https://root.cern,https://root.cern/doc/master/graph2derrorsfit_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/graph2derrorsfit.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graph2derrorsfit.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_graphs; 3/// \notebook; 4/// Draw and fit a TGraph2DErrors; 5///; 6/// \macro_image; 7/// \macro_code; 8///; 9/// \author Olivier Couet; 10 ; 11#include <TMath.h>; 12#include <TGraph2DErrors.h>; 13#include <TRandom.h>; 14#include <TStyle.h>; 15#include <TCanvas.h>; 16#include <TF2.h>; 17 ; 18void graph2derrorsfit(); 19{; 20 TCanvas *c1 = new TCanvas(""c1"");; 21 ; 22 Double_t rnd, x, y, z, ex, ey, ez;; 23 Double_t e = 0.3;; 24 Int_t nd = 500;; 25 ; 26 TRandom r;; 27 TF2 *f2 = new TF2(""f2"",""1000*(([0]*sin(x)/x)*([1]*sin(y)/y))+200"",-6,6,-6,6);; 28 f2->SetParameters(1,1);; 29 TGraph2DErrors *dte = new TGraph2DErrors(nd);; 30 ; 31 // Fill the 2D graph; 32 Double_t zmax = 0;; 33 for (Int_t i=0; i<nd; i++) {; 34 f2->GetRandom2(x,y);; 35 rnd = r.Uniform(-e,e); // Generate a random number in [-e,e]; 36 z = f2->Eval(x,y)*(1+rnd);; 37 if (z>zmax) zmax = z;; 38 dte->SetPoint(i,x,y,z);; 39 ex = 0.05*r.Rndm();; 40 ey = 0.05*r.Rndm();; 41 ez = TMath::Abs(z*rnd);; 42 dte->SetPointError(i,ex,ey,ez);; 43 }; 44 ; 45 f2->SetParameters(0.5,1.5);; 46 dte->Fit(f2);; 47 TF2 *fit2 = (TF2*)dte->FindObject(""f2"");; 48 fit2->SetTitle(""Minuit fit result on the Graph2DErrors points"");; 49 fit2->SetMaximum(zmax);; 50 gStyle->SetHistTopMargin(0);; 51 fit2->SetLineColor(1);; 52 fit2->SetLineWidth(1);; 53 fit2->Draw(""surf1"");; 54 dte->Draw(""same p0"");; 55}; e#define e(i)Definition RSha256.hxx:103; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; TCanvas.h; TF2.h; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TGraph2DErrors.h; TMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/graph2derrorsfit_8C_source.html:100,Load,Loading,100,doc/master/graph2derrorsfit_8C_source.html,https://root.cern,https://root.cern/doc/master/graph2derrorsfit_8C_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/graphApply.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graphApply.C File ReferenceTutorials » Graphs tutorials. Detailed Description; A macro to demonstrate the functionality of TGraph::Apply() method. ; TGraph::Apply applies a function f to all the data TGraph points. f may be a 1-D function TF1 or 2-d function TF2. The Y values of the graph are replaced by the new values computed using the function. ; void graphApply(); {; const Int_t npoints=3;; Double_t xaxis[npoints] = {1.,2.,3.};; Double_t yaxis[npoints] = {10.,20.,30.};; Double_t errorx[npoints] = {0.5,0.5,0.5};; Double_t errory[npoints] = {5.,5.,5.};; ; Double_t exl[npoints] = {0.5,0.5,0.5};; Double_t exh[npoints] = {0.5,0.5,0.5};; Double_t eyl[npoints] = {5.,5.,5.};; Double_t eyh[npoints] = {5.,5.,5.};; ; TGraph *gr1 = new TGraph(npoints,xaxis,yaxis);; TGraphErrors *gr2 = new TGraphErrors(npoints,xaxis,yaxis,errorx,errory);; TGraphAsymmErrors *gr3 = new TGraphAsymmErrors(npoints,xaxis,yaxis,exl,exh,eyl,eyh);; TF2 *ff = new TF2(""ff"",""-1./y"");; ; TCanvas *c1 = new TCanvas(""c1"",""c1"");; c1->Divide(2,3);; ; // TGraph; c1->cd(1);; gr1->DrawClone(""A*"");; c1->cd(2);; gr1->Apply(ff);; gr1->Draw(""A*"");; ; // TGraphErrors; c1->cd(3);; gr2->DrawClone(""A*"");; c1->cd(4);; gr2->Apply(ff);; gr2->Draw(""A*"");; ; // TGraphAsymmErrors; c1->cd(5);; gr3->DrawClone(""A*"");; c1->cd(6);; gr3->Apply(ff);; gr3->Draw(""A*"");; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; TCanvasThe Canvas class.Definition TCanvas.h:23; TF2A 2-Dim function with parameters.Definition TF2.h:29; TGraphAsymmErrorsTGraph with asymmetric error bars.Definition TGraphAsymmErrors.h:26; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphAsymmErrors.cxx:468; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphErrors::Applyvoid Apply(TF1 *f) overri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/graphApply_8C.html:97,Load,Loading,97,doc/master/graphApply_8C.html,https://root.cern,https://root.cern/doc/master/graphApply_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/graphShade.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graphShade.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Show how to shade an area between two graphs . ; void graphShade() {; TCanvas *c1 = new TCanvas(""c1"",; ""A Simple Graph Example"",200,10,700,500);; ; c1->SetGrid();; c1->DrawFrame(0,0,2.2,12);; ; const Int_t n = 20;; Double_t x[n], y[n],ymin[n], ymax[n];; Int_t i;; for (i=0;i<n;i++) {; x[i] = 0.1+i*0.1;; ymax[i] = 10*sin(x[i]+0.2);; ymin[i] = 8*sin(x[i]+0.1);; y[i] = 9*sin(x[i]+0.15);; }; TGraph *grmin = new TGraph(n,x,ymin);; TGraph *grmax = new TGraph(n,x,ymax);; TGraph *gr = new TGraph(n,x,y);; TGraph *grshade = new TGraph(2*n);; for (i=0;i<n;i++) {; grshade->SetPoint(i,x[i],ymax[i]);; grshade->SetPoint(n+i,x[n-i-1],ymin[n-i-1]);; }; grshade->SetFillStyle(3013);; grshade->SetFillColor(16);; grshade->Draw(""f"");; grmin->Draw(""l"");; grmax->Draw(""l"");; gr->SetLineWidth(4);; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""CP"");; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; yminfloat yminDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::SetPointvirtual void SetPoi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/graphShade_8C.html:97,Load,Loading,97,doc/master/graphShade_8C.html,https://root.cern,https://root.cern/doc/master/graphShade_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/graphpalettecolor.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graphpalettecolor.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; When one of these options is given to TGraph::Draw the TGraph get its color from the current color palette defined by gStyle->SetPalette(...). The color is determined according to the number of objects having palette coloring in the current pad.; In this example five graphs are displayed with palette coloring for lines and and filled area. The graphs are drawn with curves (C option) and one can see the color of each graph is picked inside the palette kSolar. The same is visible on filled polygons in the automatically built legend. ; void graphpalettecolor () {; ; gStyle->SetOptTitle(kFALSE);; gStyle->SetPalette(kSolar);; ; double x[5] = {1,2,3,4,5};; double y1[5] = {1.0,2.0,1.0,2.5,3.0};; double y2[5] = {1.1,2.1,1.1,2.6,3.1};; double y3[5] = {1.2,2.2,1.2,2.7,3.2};; double y4[5] = {1.3,2.3,1.3,2.8,3.3};; double y5[5] = {1.4,2.4,1.4,2.9,3.4};; ; TGraph *g1 = new TGraph(5,x,y1); g1->SetTitle(""Graph with a red star"");; TGraph *g2 = new TGraph(5,x,y2); g2->SetTitle(""Graph with a circular marker"");; TGraph *g3 = new TGraph(5,x,y3); g3->SetTitle(""Graph with an open square marker"");; TGraph *g4 = new TGraph(5,x,y4); g4->SetTitle(""Graph with a blue star"");; TGraph *g5 = new TGraph(5,x,y5); g5->SetTitle(""Graph with a full square marker"");; ; g1->SetLineWidth(3); g1->SetMarkerColor(kRed);; g2->SetLineWidth(3); g2->SetMarkerStyle(kCircle);; g3->SetLineWidth(3); g3->SetMarkerStyle(kOpenSquare);; g4->SetLineWidth(3); g4->SetMarkerColor(kBlue);; g5->SetLineWidth(3); g5->SetMarkerStyle(kFullSquare);; ; g1->Draw(""CA* PLC PFC"");; g2->Draw(""PC PLC PFC"");; g3->Draw(""PC PLC PFC"");; g4->Draw(""*C PLC PFC"");; g5->Draw(""PC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/graphpalettecolor_8C.html:104,Load,Loading,104,doc/master/graphpalettecolor_8C.html,https://root.cern,https://root.cern/doc/master/graphpalettecolor_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/graphpolar.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graphpolar.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Create and draw a polar graph. . ; void graphpolar(); {; // Illustrates how to use TGraphPolar; ; TCanvas * CPol = new TCanvas(""CPol"",""TGraphPolar Examples"",1200,600);; CPol->Divide(2,1);; CPol->cd(1);; ; Double_t xmin=0;; Double_t xmax=TMath::Pi()*2;; ; Double_t x[1000];; Double_t y[1000];; Double_t xval1[20];; Double_t yval1[20];; ; TF1 * fplot = new TF1(""fplot"",""cos(2*x)*cos(20*x)"",xmin,xmax);; ; for (Int_t ipt = 0; ipt < 1000; ipt++){; x[ipt] = ipt*(xmax-xmin)/1000+xmin;; y[ipt] = fplot->Eval(x[ipt]);; }; ; TGraphPolar * grP = new TGraphPolar(1000,x,y);; grP->SetLineColor(2);; grP->SetLineWidth(2);; grP->SetFillStyle(3012);; grP->SetFillColor(2);; grP->Draw(""AFL"");; ; for (Int_t ipt = 0; ipt < 20; ipt++){; xval1[ipt] = x[1000/20*ipt];; yval1[ipt] = y[1000/20*ipt];; }; ; TGraphPolar * grP1 = new TGraphPolar(20,xval1,yval1);; grP1->SetMarkerStyle(29);; grP1->SetMarkerSize(2);; grP1->SetMarkerColor(4);; grP1->SetLineColor(4);; grP1->Draw(""CP"");; ; // Update, otherwise GetPolargram returns 0; CPol->Update();; if (grP1->GetPolargram()) {; grP1->GetPolargram()->SetTextColor(8);; grP1->GetPolargram()->SetRangePolar(-TMath::Pi(),TMath::Pi());; grP1->GetPolargram()->SetNdivPolar(703);; grP1->GetPolargram()->SetToRadian();; }; ; CPol->cd(2);; Double_t x2[30];; Double_t y2[30];; Double_t ex[30];; Double_t ey[30];; for (Int_t ipt = 0; ipt < 30; ipt++){; x2[ipt] = x[1000/30*ipt];; y2[ipt] = 1.2 + 0.4*sin(TMath::Pi()*2*ipt/30);; ex[ipt] = 0.2+0.1*cos(2*TMath::Pi()/30*ipt);; ey[ipt] = 0.2;; }; ; TGraphPolar * grPE = new TGraphPolar(30,x2,y2,ex,ey);; grPE->SetMarkerStyle(22);; grPE->SetMarkerSize(1.5);; grPE->SetMarkerColor(5);; grPE->SetLineColor(6);; grPE->SetLineWidth(2);; grPE->Draw(""EP"");; // Update, otherwise GetPolargram returns 0; CPol->Update();; ; if (grPE->G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/graphpolar_8C.html:97,Load,Loading,97,doc/master/graphpolar_8C.html,https://root.cern,https://root.cern/doc/master/graphpolar_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/graphpolar2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graphpolar2.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Create and draw a polar graph with PI axis . ; void graphpolar2(); {; TCanvas * CPol = new TCanvas(""CPol"",""TGraphPolar Example"",500,500);; ; Double_t theta[8];; Double_t radius[8];; Double_t etheta[8];; Double_t eradius[8];; ; for (int i=0; i<8; i++) {; theta[i] = (i+1)*(TMath::Pi()/4.);; radius[i] = (i+1)*0.05;; etheta[i] = TMath::Pi()/8.;; eradius[i] = 0.05;; }; ; TGraphPolar * grP1 = new TGraphPolar(8, theta, radius, etheta, eradius);; grP1->SetTitle("""");; ; grP1->SetMarkerStyle(20);; grP1->SetMarkerSize(2.);; grP1->SetMarkerColor(4);; grP1->SetLineColor(2);; grP1->SetLineWidth(3);; grP1->Draw(""PE"");; ; CPol->Update();; ; if (grP1->GetPolargram()); grP1->GetPolargram()->SetToRadian();; }; Double_tdouble Double_tDefinition RtypesCore.h:59; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TAttMarker::SetMarkerSizevirtual void SetMarkerSize(Size_t msize=1)Set the marker size.Definition TAttMarker.h:45; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::Updatevoid Update() overrideUpdate canvas pad buffers.Definition TCanvas.cxx:2489; TGraphPolarTo draw a polar graph.Definition TGraphPolar.h:23; TGraphPolar::GetPolargramTGraphPolargram * GetPolargram()Definition TGraphPolar.h:39; TGraphPolar::Drawvoid Draw(Option_t *options="""") overrideDraw TGraphPolar.Definition TGraphPolar.cxx:100; TGraphPolargram::SetToRadianvoid SetToRadian()The Polar circle is l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/graphpolar2_8C.html:98,Load,Loading,98,doc/master/graphpolar2_8C.html,https://root.cern,https://root.cern/doc/master/graphpolar2_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/graphpolar3.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graphpolar3.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Create and draw a polar graph with PI axis using a TF1. . ; void graphpolar3(); {; TCanvas *CPol = new TCanvas(""CPol"",""TGraphPolar Examples"",500,500);; ; Double_t rmin = 0;; Double_t rmax = TMath::Pi()*2;; Double_t r[1000];; Double_t theta[1000];; ; TF1 *fp1 = new TF1(""fplot"",""cos(x)"",rmin,rmax);; for (Int_t ipt = 0; ipt < 1000; ipt++) {; r[ipt] = ipt*(rmax-rmin)/1000+rmin;; theta[ipt] = fp1->Eval(r[ipt]);; }; ; TGraphPolar *grP1 = new TGraphPolar(1000, r, theta);; grP1->SetTitle("""");; grP1->SetLineColor(2);; grP1->Draw(""AOL"");; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TF11-Dim function classDefinition TF1.h:233; TF1::Evalvirtual Double_t Eval(Double_t x, Double_t y=0, Double_t z=0, Double_t t=0) constEvaluate this function.Definition TF1.cxx:1439; TGraphPolarTo draw a polar graph.Definition TGraphPolar.h:23; TGraphPolar::Drawvoid Draw(Option_t *options="""") overrideDraw TGraphPolar.Definition TGraphPolar.cxx:100; TGraph::SetTitlevoid SetTitle(const char *title="""") overrideChange (i.e.Definition TGraph.cxx:2397; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; AuthorOlivier Couet ; Definition in file graphpolar3.C. tutorialsgraphsgraphpolar3.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/graphpolar3_8C.html:98,Load,Loading,98,doc/master/graphpolar3_8C.html,https://root.cern,https://root.cern/doc/master/graphpolar3_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/graphreverse.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graphreverse.C File ReferenceTutorials » Graphs tutorials. Detailed Description; This example test all the various case of reverse graphs combined with logarithmic scale. . ; void graphreverse() {; auto c = new TCanvas(""c"",""Reversed graphs"",0,0,900,900);; c->Divide(3,3);; ; // TGraphErrors; auto graphe = new TGraphErrors();; graphe->GetXaxis()->SetNdivisions(514);; graphe->GetYaxis()->SetNdivisions(514);; graphe->SetMarkerStyle(kCircle);; graphe->SetPoint(0,5,5);; graphe->SetPointError(0,1,3);; graphe->SetPoint(1,9,9);; graphe->SetPointError(1,1,3);; ; c->cd(1);; gPad->SetGrid();; graphe->Draw(""a pl "");; ; c->cd(2);; gPad->SetGrid();; graphe->Draw(""a pl rx ry "");; ; c->cd(3);; gPad->SetGrid();; gPad->SetLogx();; gPad->SetLogy();; graphe->GetXaxis()->SetMoreLogLabels();; graphe->GetYaxis()->SetMoreLogLabels();; graphe->Draw(""a pl rx ry"");; ; // TGraphAsymmErrors; auto graphae = new TGraphAsymmErrors();; graphae->GetXaxis()->SetNdivisions(514);; graphae->GetYaxis()->SetNdivisions(514);; graphae->SetMarkerStyle(kCircle);; graphae->SetPoint(0,5,5);; graphae->SetPointError(0,1,3,3,1);; graphae->SetPoint(1,9,9);; graphae->SetPointError(1,1,3,1,3);; ; c->cd(4);; gPad->SetGrid();; graphae->Draw(""a pl "");; ; c->cd(5);; gPad->SetGrid();; graphae->Draw(""a pl rx ry "");; ; c->cd(6);; gPad->SetGrid();; gPad->SetLogx();; gPad->SetLogy();; graphae->GetXaxis()->SetMoreLogLabels();; graphae->GetYaxis()->SetMoreLogLabels();; graphae->Draw(""a pl rx ry"");; ; // TGraphBentErrors; auto graphbe = new TGraphBentErrors();; graphbe->GetXaxis()->SetNdivisions(514);; graphbe->GetYaxis()->SetNdivisions(514);; graphbe->SetMarkerStyle(kCircle);; graphbe->SetPoint(0,5,5);; graphbe->SetPointError(0,1,3,3,1,.5,.2,.5,.2);; graphbe->SetPoint(1,9,9);; graphbe->SetPointError(1,1,3,1,3,-.5,-.2,-.5,-.2);; ; c->cd(7);; gPad->SetGrid();; graphbe->Draw(""a pl "");; ; c->cd(8);;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/graphreverse_8C.html:99,Load,Loading,99,doc/master/graphreverse_8C.html,https://root.cern,https://root.cern/doc/master/graphreverse_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/graphstruct.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graphstruct.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Draw a simple graph structure. ; The graph layout is made using graphviz. This macro creates some nodes and edges and change a few graphical attributes on some of them. ; TCanvas* graphstruct(); {; #if __has_include(""TGraphStruct.h"") // handy check on whether gviz was installed; TGraphStruct *gs = new TGraphStruct();; ; // create some nodes and put them in the graph in one go ...; TGraphNode *n0 = gs->AddNode(""n0"",""Node 0"");; TGraphNode *n1 = gs->AddNode(""n1"",""First node"");; TGraphNode *n2 = gs->AddNode(""n2"",""Second node"");; TGraphNode *n3 = gs->AddNode(""n3"",""Third node"");; TGraphNode *n4 = gs->AddNode(""n4"",""Fourth node"");; TGraphNode *n5 = gs->AddNode(""n5"",""5th node"");; TGraphNode *n6 = gs->AddNode(""n6"",""Node number six"");; TGraphNode *n7 = gs->AddNode(""n7"",""Node 7"");; TGraphNode *n8 = gs->AddNode(""n8"",""Node 8"");; TGraphNode *n9 = gs->AddNode(""n9"",""Node 9"");; ; n4->SetTextSize(0.03);; n6->SetTextSize(0.03);; n2->SetTextSize(0.04);; ; n3->SetTextFont(132);; ; n0->SetTextColor(kRed);; ; n9->SetFillColor(kRed-10);; n0->SetFillColor(kYellow-9);; n7->SetFillColor(kViolet-9);; ; // some edges ...; gs->AddEdge(n0,n1)->SetLineColor(kRed);; TGraphEdge *e06 = gs->AddEdge(n0,n6);; e06->SetLineColor(kRed-3);; e06->SetLineWidth(4);; gs->AddEdge(n1,n7);; gs->AddEdge(n4,n6);; gs->AddEdge(n3,n9);; gs->AddEdge(n6,n8);; gs->AddEdge(n7,n2);; gs->AddEdge(n8,n3);; gs->AddEdge(n2,n3);; gs->AddEdge(n9,n0);; gs->AddEdge(n1,n4);; gs->AddEdge(n1,n6);; gs->AddEdge(n2,n5);; gs->AddEdge(n3,n6);; gs->AddEdge(n4,n5);; ; TCanvas *c = new TCanvas(""c"",""c"",800,600);; c->SetFillColor(38);; gs->Draw();; return c;; #else; return new TCanvas(""c"",""c"",800,600);; #endif; }; c#define c(i)Definition RSha256.hxx:101; kRed@ kRedDefinition Rtypes.h:66; kYellow@ kYellowDefinition Rtypes.h:66; kViolet@",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/graphstruct_8C.html:98,Load,Loading,98,doc/master/graphstruct_8C.html,https://root.cern,https://root.cern/doc/master/graphstruct_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/graphtext.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graphtext.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Draw a graph with text attached to each point. ; The text is drawn in a TExec function attached to the TGraph, therefore if the a graph's point is moved interactively, the text will be automatically updated. ; void graphtext() {; TCanvas *c = new TCanvas(""c"",""A Simple Graph Example with Text"",700,500);; c->SetGrid();; ; const Int_t n = 10;; auto gr = new TGraph(n);; gr->SetTitle(""A Simple Graph Example with Text"");; gr->SetMarkerStyle(20);; auto ex = new TExec(""ex"",""drawtext();"");; gr->GetListOfFunctions()->Add(ex);; ; Double_t x, y;; for (Int_t i=0;i<n;i++) {; x = i*0.1;; y = 10*sin(x+0.2);; gr->SetPoint(i,x,y);; ; }; gr->Draw(""ALP"");; }; ; void drawtext(); {; Int_t i,n;; Double_t x,y;; TLatex l;; ; l.SetTextSize(0.025);; l.SetTextFont(42);; l.SetTextAlign(21);; l.SetTextColor(kBlue);; ; auto g = (TGraph*)gPad->GetListOfPrimitives()->FindObject(""Graph"");; n = g->GetN();; ; for (i=0; i<n; i++) {; g->GetPoint(i,x,y);; l.PaintText(x,y+0.2,Form(""(%4.2f,%4.2f)"",x,y));; }; }; ; c#define c(i)Definition RSha256.hxx:101; g#define g(i)Definition RSha256.hxx:105; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; kBlue@ kBlueDefinition Rtypes.h:66; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; gPad#define gPadDefinition TVirtualPad.h:308; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TExecTExec is a utility class that can be used to execute a C++ command when some event happens in a pad.Definition TExec.h:26; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::SetPointvirtual void SetPoin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/graphtext_8C.html:96,Load,Loading,96,doc/master/graphtext_8C.html,https://root.cern,https://root.cern/doc/master/graphtext_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/gtime.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. gtime.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Example of TGraphTime. . ; #include ""TCanvas.h""; #include ""TRandom3.h""; #include ""TMath.h""; #include ""TText.h""; #include ""TArrow.h""; #include ""TGraphTime.h""; #include <vector>; ; void gtime(Int_t nsteps = 500, Int_t np = 100); {; if (np > 1000) np = 1000;; std::vector<Int_t> color(np);; std::vector<Double_t> rr(np), phi(np), dr(np), size(np);; TRandom3 r;; Double_t xmin = -10, xmax = 10, ymin = -10, ymax = 10;; auto g = new TGraphTime(nsteps, xmin, ymin, xmax, ymax);; g->SetTitle(""TGraphTime demo;X domain;Y domain"");; for (Int_t i = 0; i < np; i++) { // calculate some object parameters; rr[i] = r.Uniform(0.1 * xmax, 0.2 * xmax);; phi[i] = r.Uniform(0, 2 * TMath::Pi());; dr[i] = r.Uniform(0, 1) * 0.9 * xmax / Double_t(nsteps);; Double_t rc = r.Rndm();; if (rc > 0.7); color[i] = kYellow;; else if (rc > 0.3); color[i] = kBlue;; else; color[i] = kRed;; ; size[i] = r.Uniform(0.5, 6);; }; for (Int_t s = 0; s < nsteps; s++) { // fill the TGraphTime step by step; for (Int_t i = 0; i < np; i++) {; Double_t newr = rr[i] + dr[i] * s;; Double_t newsize = 0.2 + size[i] * TMath::Abs(TMath::Sin(newr + 10));; Double_t newphi = phi[i] + 0.01 * s;; Double_t xx = newr * TMath::Cos(newphi);; Double_t yy = newr * TMath::Sin(newphi);; TMarker *m = new TMarker(xx, yy, 20);; m->SetMarkerColor(color[i]);; m->SetMarkerSize(newsize);; g->Add(m, s);; if (i == np - 1); g->Add(new TArrow(xmin, ymax, xx, yy, 0.02, ""-|>""), s);; }; g->Add(new TPaveLabel(.90, .92, .98, .97, TString::Format(""%d"", s + 1), ""brNDC""), s);; }; ; g->Draw();; ; // save object as animated gif; // g->SaveAnimatedGif(""gtime.gif"");; ; //save object to a file; auto f = TFile::Open(""gtime.root"",""recreate"");; f->WriteObject(g, ""g"");; delete f;; ; //to view this object in another session do; // TFile::Open(""gtime.root"");; // g->Draw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/graphs_2gtime_8C.html:92,Load,Loading,92,doc/master/graphs_2gtime_8C.html,https://root.cern,https://root.cern/doc/master/graphs_2gtime_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/gtime2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. gtime2.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program. . ; #include ""TRandom3.h""; #include ""TMath.h""; #include ""TMarker.h""; #include ""TPaveLabel.h""; #include ""TArrow.h""; #include ""TGraphTime.h""; #include <vector>; ; void gtime2(Int_t nsteps = 200, Int_t np = 5000); {; if (np > 5000) np = 5000;; std::vector<Int_t> color(np);; std::vector<Double_t> cosphi(np), sinphi(np), speed(np);; TRandom3 r;; Double_t xmin = 0, xmax = 10, ymin = -10, ymax = 10;; TGraphTime *g = new TGraphTime(nsteps,xmin,ymin,xmax,ymax);; g->SetTitle(""TGraphTime demo 2;X;Y"");; Double_t fact = xmax/Double_t(nsteps);; for (Int_t i = 0; i < np; i++) { // calculate some object parameters; speed[i] = r.Uniform(0.5, 1);; Double_t phi = r.Gaus(0, TMath::Pi() / 6.);; cosphi[i] = fact * speed[i] * TMath::Cos(phi);; sinphi[i] = fact * speed[i] * TMath::Sin(phi);; Double_t rc = r.Rndm();; color[i] = kRed;; if (rc > 0.3) color[i] = kBlue;; if (rc > 0.7) color[i] = kYellow;; }; for (Int_t s = 0; s < nsteps; s++) { // fill the TGraphTime step by step; for (Int_t i = 0; i < np; i++) {; Double_t xx = s*cosphi[i];; if (xx < xmin) continue;; Double_t yy = s*sinphi[i];; TMarker *m = new TMarker(xx,yy,25);; m->SetMarkerColor(color[i]);; m->SetMarkerSize(1.5 -s/(speed[i]*nsteps));; g->Add(m, s);; }; g->Add(new TPaveLabel(.70,.92,.98,.99,TString::Format(""shower at %5.3f nsec"",3.*s/nsteps),""brNDC""),s);; }; ; g->Draw();; ; // store object as animated gif; // g->SaveAnimatedGif(""gtime2.gif"");; ; // start animation, can be stopped with g->Animate(kFALSE);; // g->Animate();; }; ; ; ; g#define g(i)Definition RSha256.hxx:105; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; kRed@ kRedDefinition Rtypes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gtime2_8C.html:93,Load,Loading,93,doc/master/gtime2_8C.html,https://root.cern,https://root.cern/doc/master/gtime2_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/hlGraph1.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. hlGraph1.C File ReferenceTutorials » Graphs tutorials. Detailed Description; This tutorial demonstrates how to use the highlight mode on graph. ; ; TList *l = nullptr;; ; void HighlightHisto(TVirtualPad *pad, TObject *obj, Int_t ihp, Int_t y); {; auto Pad = (TVirtualPad *)pad->FindObject(""Pad"");; if (!Pad) return;; ; if (ihp == -1) { // after highlight disabled; Pad->Clear();; return;; }; ; if (l && l->At(ihp)) {; Pad->cd();; l->At(ihp)->Draw();; gPad->Update();; }; }; ; void hlGraph1(); {; auto Canvas = new TCanvas(""Canvas"", ""Canvas"", 0, 0, 700, 500);; Canvas->HighlightConnect(""HighlightHisto(TVirtualPad*,TObject*,Int_t,Int_t)"");; const Int_t n = 500;; Double_t x[n], y[n];; l = new TList();; ; for (Int_t i = 0; i < n; i++) {; auto h = new TH1F(TString::Format(""h_%03d"", i), """", 100, -3.0, 3.0);; h->FillRandom(""gaus"", 1000);; h->Fit(""gaus"", ""Q"");; h->SetMaximum(250.0); // for n > 200; l->Add(h);; x[i] = i;; y[i] = h->GetFunction(""gaus"")->GetParameter(2);; }; ; auto g = new TGraph(n, x, y);; g->SetMarkerStyle(6);; g->Draw(""AP"");; ; auto Pad = new TPad(""Pad"", ""Pad"", 0.3, 0.4, 1.0, 1.0);; Pad->SetFillColor(kBlue-10);; Pad->Draw();; Pad->cd();; auto info = new TText(0.5, 0.5, ""please move the mouse over the graPad"");; info->SetTextAlign(22);; info->Draw();; Canvas->cd();; ; g->SetHighlight();; }; g#define g(i)Definition RSha256.hxx:105; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; kBlue@ kBlueDefinition Rtypes.h:66; gPad#define gPadDefinition TVirtualPad.h:308; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TListA doubly linked list.Definition TList.h:38; TObjectMother o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hlGraph1_8C.html:95,Load,Loading,95,doc/master/hlGraph1_8C.html,https://root.cern,https://root.cern/doc/master/hlGraph1_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/hlGraph2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. hlGraph2.C File ReferenceTutorials » Graphs tutorials. Detailed Description; This tutorial demonstrates how to use the highlight mode on graph. ; ; TNtuple *ntuple = nullptr;; ; void HighlightBinId(TVirtualPad *pad, TObject *obj, Int_t ihp, Int_t y); {; auto Canvas2 = (TCanvas *)gROOT->GetListOfCanvases()->FindObject(""Canvas2"");; if (!Canvas2) return;; auto histo = (TH1F *)Canvas2->FindObject(""histo"");; if (!histo) return;; ; Double_t px = ntuple->GetV1()[ihp];; Double_t py = ntuple->GetV2()[ihp];; Double_t pz = ntuple->GetV3()[ihp];; Double_t i = ntuple->GetV4()[ihp];; Double_t p = TMath::Sqrt(px*px + py*py + pz*pz);; Int_t hbin = histo->FindBin(p);; ; Bool_t redraw = kFALSE;; auto bh = (TBox *)Canvas2->FindObject(""TBox"");; if (!bh) {; bh = new TBox();; bh->SetFillColor(kBlack);; bh->SetFillStyle(3001);; bh->SetBit(kCannotPick);; bh->SetBit(kCanDelete);; redraw = kTRUE;; }; bh->SetX1(histo->GetBinLowEdge(hbin));; bh->SetY1(histo->GetMinimum());; bh->SetX2(histo->GetBinWidth(hbin) + histo->GetBinLowEdge(hbin));; bh->SetY2(histo->GetBinContent(hbin));; ; auto th = (TText *)Canvas2->FindObject(""TText"");; if (!th) {; th = new TText();; th->SetName(""TText"");; th->SetTextColor(bh->GetFillColor());; th->SetBit(kCanDelete);; redraw = kTRUE;; }; th->SetText(histo->GetXaxis()->GetXmax()*0.75, histo->GetMaximum()*0.5,; TString::Format(""id = %d"", (Int_t)i));; ; if (ihp == -1) { // after highlight disabled; delete bh;; delete th;; }; Canvas2->Modified();; Canvas2->Update();; if (!redraw) return;; ; auto savepad = gPad;; Canvas2->cd();; bh->Draw();; th->Draw();; Canvas2->Update();; savepad->cd();; }; ; void hlGraph2(); {; auto dir = gROOT->GetTutorialDir();; dir.Append(""/hsimple.C"");; dir.ReplaceAll(""/./"",""/"");; if (!gInterpreter->IsLoaded(dir.Data())) gInterpreter->LoadMacro(dir.Data());; auto file = (TFile*)gROOT->ProcessLineFast(""hsimple(1)"");; i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hlGraph2_8C.html:95,Load,Loading,95,doc/master/hlGraph2_8C.html,https://root.cern,https://root.cern/doc/master/hlGraph2_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/labels1.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. labels1.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Setting alphanumeric labels in a 1-d histogram. . ; void labels1(); {; Int_t i;; const Int_t nx = 20;; const char *people[nx] = {""Jean"",""Pierre"",""Marie"",""Odile"",; ""Sebastien"",""Fons"",""Rene"",""Nicolas"",""Xavier"",""Greg"",; ""Bjarne"",""Anton"",""Otto"",""Eddy"",""Peter"",""Pasha"",; ""Philippe"",""Suzanne"",""Jeff"",""Valery""};; TCanvas *c1 = new TCanvas(""c1"",""demo bin labels"",10,10,900,500);; c1->SetGrid();; c1->SetBottomMargin(0.15);; TH1F *h = new TH1F(""h"",""test"",nx,0,nx);; h->SetFillColor(38);; for (i=0;i<5000;i++) h->Fill(gRandom->Gaus(0.5*nx,0.2*nx));; h->SetStats(0);; for (i=1;i<=nx;i++) h->GetXaxis()->SetBinLabel(i,people[i-1]);; h->Draw();; TPaveText *pt = new TPaveText(0.6,0.7,0.98,0.98,""brNDC"");; pt->SetFillColor(18);; pt->SetTextAlign(12);; pt->AddText(""Use the axis Context Menu LabelsOption"");; pt->AddText("" \""a\"" to sort by alphabetic order"");; pt->AddText("" \"">\"" to sort by decreasing values"");; pt->AddText("" \""<\"" to sort by increasing values"");; pt->Draw();; }; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cxx:191; TPaveText::Drawvoid Draw(Option_t *option="""") overrid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/labels1_8C.html:94,Load,Loading,94,doc/master/labels1_8C.html,https://root.cern,https://root.cern/doc/master/labels1_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/labels2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. labels2.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Setting alphanumeric labels. . ; void labels2(); {; Int_t i;; const Int_t nx = 12;; const Int_t ny = 20;; const char *month[nx] = {""January"",""February"",""March"",""April"",; ""May"",""June"",""July"",""August"",""September"",""October"",; ""November"",""December""};; const char *people[ny] = {""Jean"",""Pierre"",""Marie"",""Odile"",; ""Sebastien"",""Fons"",""Rene"",""Nicolas"",""Xavier"",""Greg"",; ""Bjarne"",""Anton"",""Otto"",""Eddy"",""Peter"",""Pasha"",; ""Philippe"",""Suzanne"",""Jeff"",""Valery""};; TCanvas *c1 = new TCanvas(""c1"",""demo bin labels"",; 10,10,800,800);; c1->SetGrid();; c1->SetLeftMargin(0.15);; c1->SetBottomMargin(0.15);; TH2F *h = new TH2F(""h"",""test"",nx,0,nx,ny,0,ny);; for (i=0;i<5000;i++) {; h->Fill(gRandom->Gaus(0.5*nx,0.2*nx),; gRandom->Gaus(0.5*ny,0.2*ny));; }; h->SetStats(0);; for (i=1;i<=nx;i++) h->GetXaxis()->SetBinLabel(i,month[i-1]);; for (i=1;i<=ny;i++) h->GetYaxis()->SetBinLabel(i,people[i-1]);; h->Draw(""text"");; ; TPaveText *pt = new TPaveText(0.6,0.85,0.98,0.98,""brNDC"");; pt->SetFillColor(18);; pt->SetTextAlign(12);; pt->AddText(""Use the axis Context Menu LabelsOption"");; pt->AddText("" \""a\"" to sort by alphabetic order"");; pt->AddText("" \"">\"" to sort by decreasing values"");; pt->AddText("" \""<\"" to sort by increasing values"");; pt->Draw();; }; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TCanvasThe Canvas class.Definition TCanvas.h:23; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TPaveTextA Pave (see TPave) with text, lines or/and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/labels2_8C.html:94,Load,Loading,94,doc/master/labels2_8C.html,https://root.cern,https://root.cern/doc/master/labels2_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/motorcycle.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. motorcycle.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Macro to test scatterplot smoothers: ksmooth, lowess, supsmu as described in: ; Modern Applied Statistics with S-Plus, 3rd Edition; W.N. Venables and B.D. Ripley; Chapter 9: Smooth Regression, Figure 9.1; Example is a set of data on 133 observations of acceleration against time for a simulated motorcycle accident, taken from Silverman (1985). ; #include ""TString.h""; #include ""TInterpreter.h""; #include <fstream>; #include ""TH1.h""; #include ""TGraphSmooth.h""; #include ""TCanvas.h""; #include ""TSystem.h""; ; ; TCanvas *vC1;; TGraph *grin, *grout;; ; void DrawSmooth(Int_t pad, const char *title, const char *xt, const char *yt); {; vC1->cd(pad);; TH1F *vFrame = gPad->DrawFrame(0,-130,60,70);; vFrame->SetTitle(title);; vFrame->SetTitleSize(0.2);; vFrame->SetXTitle(xt);; vFrame->SetYTitle(yt);; grin->Draw(""P"");; grout->DrawClone(""LPX"");; }; ; void motorcycle(); {; // data taken from R library MASS: mcycle.txt; TString dir = gROOT->GetTutorialDir();; dir.Append(""/graphs/"");; dir.ReplaceAll(""/./"",""/"");; ; // read file and add to fit object; Double_t *x = new Double_t[133];; Double_t *y = new Double_t[133];; Double_t vX, vY;; Int_t vNData = 0;; ifstream vInput;; vInput.open(Form(""%smotorcycle.dat"",dir.Data()));; while (1) {; vInput >> vX >> vY;; if (!vInput.good()) break;; x[vNData] = vX;; y[vNData] = vY;; vNData++;; }//while; vInput.close();; grin = new TGraph(vNData,x,y);; ; // draw graph; vC1 = new TCanvas(""vC1"",""Smooth Regression"",200,10,900,700);; vC1->Divide(2,3);; ; // Kernel Smoother; // create new kernel smoother and smooth data with bandwidth = 2.0; TGraphSmooth *gs = new TGraphSmooth(""normal"");; grout = gs->SmoothKern(grin,""normal"",2.0);; DrawSmooth(1,""Kernel Smoother: bandwidth = 2.0"",""times"",""accel"");; ; // redraw ksmooth with bandwidth = 5.0; grout = gs->Sm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/motorcycle_8C.html:97,Load,Loading,97,doc/master/motorcycle_8C.html,https://root.cern,https://root.cern/doc/master/motorcycle_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/multigraph.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. multigraph.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Create and Draw a TMultiGraph. . ; ; void multigraph(); {; gStyle->SetOptFit();; auto c1 = new TCanvas(""c1"",""multigraph"",700,500);; c1->SetGrid();; ; // draw a frame to define the range; auto mg = new TMultiGraph();; ; // create first graph; const Int_t n1 = 10;; Double_t px1[] = {-0.1, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t py1[] = {-1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t ex1[] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t ey1[] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; auto gr1 = new TGraphErrors(n1,px1,py1,ex1,ey1);; gr1->SetMarkerColor(kBlue);; gr1->SetMarkerStyle(21);; ; gr1->Fit(""gaus"",""q"");; auto func1 = (TF1 *) gr1->GetListOfFunctions()->FindObject(""gaus"");; func1->SetLineColor(kBlue);; ; mg->Add(gr1);; ; // create second graph; const Int_t n2 = 10;; Float_t x2[] = {-0.28, 0.005, 0.19, 0.29, 0.45, 0.56,0.65,0.80,0.90,1.01};; Float_t y2[] = {2.1,3.86,7,9,10,10.55,9.64,7.26,5.42,2};; Float_t ex2[] = {.04,.12,.08,.06,.05,.04,.07,.06,.08,.04};; Float_t ey2[] = {.6,.8,.7,.4,.3,.3,.4,.5,.6,.7};; auto gr2 = new TGraphErrors(n2,x2,y2,ex2,ey2);; gr2->SetMarkerColor(kRed);; gr2->SetMarkerStyle(20);; ; gr2->Fit(""pol5"",""q"");; auto func2 = (TF1 *) gr2->GetListOfFunctions()->FindObject(""pol5"");; func2->SetLineColor(kRed);; func2->SetLineStyle(2);; ; mg->Add(gr2);; ; mg->Draw(""ap"");; ; //force drawing of canvas to generate the fit TPaveStats; c1->Update();; ; auto stats1 = (TPaveStats*) gr1->GetListOfFunctions()->FindObject(""stats"");; auto stats2 = (TPaveStats*) gr2->GetListOfFunctions()->FindObject(""stats"");; ; if (stats1 && stats2) {; stats1->SetTextColor(kBlue);; stats2->SetTextColor(kRed);; stats1->SetX1NDC(0.12); stats1->SetX2NDC(0.32); stats1->SetY1NDC(0.82);; stats2->SetX1NDC(0.72); stats2->SetX2NDC(0.92); stats2->SetY1NDC(0.75)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/multigraph_8C.html:97,Load,Loading,97,doc/master/multigraph_8C.html,https://root.cern,https://root.cern/doc/master/multigraph_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/multigraphpalettecolor.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. multigraphpalettecolor.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Palette coloring for multi-graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; When one of these options is given to TMultiGraph::Draw the TGraphs in the TMultiGraphget their color from the current color palette defined by gStyle->SetPalette(...). The color is determined according to the number of TGraphs.; In this example four graphs are displayed with palette coloring for lines and and markers. The color of each graph is picked inside the default palette kBird. ; void multigraphpalettecolor(); {; auto mg = new TMultiGraph();; ; auto gr1 = new TGraph(); gr1->SetMarkerStyle(20);; auto gr2 = new TGraph(); gr2->SetMarkerStyle(21);; auto gr3 = new TGraph(); gr3->SetMarkerStyle(23);; auto gr4 = new TGraph(); gr4->SetMarkerStyle(24);; ; Double_t dx = 6.28/100;; Double_t x = -3.14;; ; for (int i=0; i<=100; i++) {; x = x+dx;; gr1->SetPoint(i,x,2.*TMath::Sin(x));; gr2->SetPoint(i,x,TMath::Cos(x));; gr3->SetPoint(i,x,TMath::Cos(x*x));; gr4->SetPoint(i,x,TMath::Cos(x*x*x));; }; ; mg->Add(gr4,""PL"");; mg->Add(gr3,""PL"");; mg->Add(gr2,""*L"");; mg->Add(gr1,""PL"");; ; mg->Draw(""A pmc plc"");; }; Double_tdouble Double_tDefinition RtypesCore.h:59; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects.Definition TMultiGraph.h:34; xDouble_t x[n]Definition legend1.C:17; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; AuthorOlivier Couet ; Definition in file multigraphpalettecolor.C. tutorialsgraphsmultigraphpalettecolor.C. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/multigraphpalettecolor_8C.html:109,Load,Loading,109,doc/master/multigraphpalettecolor_8C.html,https://root.cern,https://root.cern/doc/master/multigraphpalettecolor_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/multipalette.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. multipalette.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Draw color plots using different color palettes. ; As only one palette is active, one need to use TExec to be able to display plots using different palettes on the same pad.; When a pad is painted, all its elements are painted in the sequence of Draw calls (See the difference between Draw and Paint in the TPad documentation); for TExec it executes its command - which in the following example sets palette for painting all objects painted afterwards. If in the next pad another TExec changes the palette, it doesn’t affect the previous pad which was already painted, but it will affect the current and those painted later.; The following macro illustrate this feature. ; #include ""TStyle.h""; #include ""TColor.h""; #include ""TF2.h""; #include ""TExec.h""; #include ""TCanvas.h""; ; void Pal1(); {; static Int_t colors[50];; static Bool_t initialized = kFALSE;; ; Double_t Red[3] = { 1.00, 0.00, 0.00};; Double_t Green[3] = { 0.00, 1.00, 0.00};; Double_t Blue[3] = { 1.00, 0.00, 1.00};; Double_t Length[3] = { 0.00, 0.50, 1.00 };; ; if(!initialized){; Int_t FI = TColor::CreateGradientColorTable(3,Length,Red,Green,Blue,50);; for (int i=0; i<50; i++) colors[i] = FI+i;; initialized = kTRUE;; return;; }; gStyle->SetPalette(50,colors);; }; ; void Pal2(); {; static Int_t colors[50];; static Bool_t initialized = kFALSE;; ; Double_t Red[3] = { 1.00, 0.50, 0.00};; Double_t Green[3] = { 0.50, 0.00, 1.00};; Double_t Blue[3] = { 1.00, 0.00, 0.50};; Double_t Length[3] = { 0.00, 0.50, 1.00 };; ; if(!initialized){; Int_t FI = TColor::CreateGradientColorTable(3,Length,Red,Green,Blue,50);; for (int i=0; i<50; i++) colors[i] = FI+i;; initialized = kTRUE;; return;; }; gStyle->SetPalette(50,colors);; }; ; void multipalette() {; TCanvas *c3 = new TCanvas(""c3"",""C3"",0,0,600,400);; c3->Divide(2,1);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/multipalette_8C.html:99,Load,Loading,99,doc/master/multipalette_8C.html,https://root.cern,https://root.cern/doc/master/multipalette_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/scatter.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. scatter.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Draw a scatter plot. . ; void scatter(); {; auto canvas = new TCanvas();; canvas->SetRightMargin(0.14);; gStyle->SetPalette(kBird, 0, 0.6); // define a transparent palette; ; const int n = 175;; double x[n];; double y[n];; double c[n];; double s[n];; ; // Define four random data set; auto r = new TRandom();; for (int i=0; i<n; i++) {; x[i] = 100*r->Rndm(i);; y[i] = 200*r->Rndm(i);; c[i] = 300*r->Rndm(i);; s[i] = 400*r->Rndm(i);; }; ; auto scatter = new TScatter(n, x, y, c, s);; scatter->SetMarkerStyle(20);; scatter->SetTitle(""Scatter plot title;X title;Y title;Z title"");; scatter->GetXaxis()->SetRangeUser(20.,90.);; scatter->GetYaxis()->SetRangeUser(55.,90.);; scatter->GetZaxis()->SetRangeUser(10.,200.);; scatter->Draw(""A"");; }; c#define c(i)Definition RSha256.hxx:101; kBird@ kBirdDefinition TColor.h:118; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TScatterA TScatter is able to draw four variables scatter plot on a single plot.Definition TScatter.h:32; TStyle::SetPalettevoid SetPalette(Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.)See TColor::SetPalette.Definition TStyle.cxx:1888; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; AuthorOlivier Couet ; Definition in file scatter.C. tutorialsgraphsscatter.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/scatter_8C.html:94,Load,Loading,94,doc/master/scatter_8C.html,https://root.cern,https://root.cern/doc/master/scatter_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/seism.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. seism.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Strip chart example. . ; #include ""TStopwatch.h""; #include ""TDatime.h""; #include ""TStyle.h""; #include ""TH1F.h""; #include ""TCanvas.h""; #include ""TSystem.h""; #include ""TRandom.h""; #include <cstdio>; ; void seism() {; ; TStopwatch sw; sw.Start();; //set time offset; TDatime dtime;; gStyle->SetTimeOffset(dtime.Convert());; ; TCanvas *c1 = new TCanvas(""c1"",""Time on axis"",10,10,1000,500);; c1->SetGrid();; ; Float_t bintime = 1; //one bin = 1 second. change it to set the time scale; TH1F *ht = new TH1F(""ht"",""The ROOT seism"",10,0,10*bintime);; Float_t signalval = 1000;; ht->SetMaximum( signalval);; ht->SetMinimum(-signalval);; ht->SetStats(false);; ht->SetLineColor(2);; ht->GetXaxis()->SetTimeDisplay(1);; ht->GetYaxis()->SetNdivisions(520);; ht->Draw();; ; for (Int_t i=1;i<2300;i++) {; //======= Build a signal : noisy damped sine ======; Float_t noise = gRandom->Gaus(0,120);; if (i > 700) noise += signalval*sin((i-700.)*6.28/30)*exp((700.-i)/300.);; ht->SetBinContent(i,noise);; c1->Modified();; c1->Update();; gSystem->ProcessEvents(); //canvas can be edited during the loop; }; printf(""Real Time = %8.3fs, Cpu Time = %8.3fs\n"",sw.RealTime(),sw.CpuTime());; }; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; TCanvas.h; TDatime.h; TH1F.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TStopwatch.h; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TAttAxis::SetNdivisionsvirtual void SetNdivisions(Int_t n=510, Bool_t optim=kTRUE)Set the number of divisions for this axis.Definition TAttAxis.cxx:233; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAxis::SetTimeDisplayvirtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/seism_8C.html:92,Load,Loading,92,doc/master/seism_8C.html,https://root.cern,https://root.cern/doc/master/seism_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/splines_test.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. splines_test.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Examples of use of the spline classes. . ; void splines_test(Int_t np=23, Double_t a=-0.5, Double_t b=31); {; // array of points; Double_t *xx=0, *yy=0;; TSpline3 *spline3=0;; TSpline5 *spline5=0;; TLine *line5, *line3;; TText *text5, *text3, *textn;; char text[20];; const Double_t power=0.75;; ; // Define the original function; TF1 *f=new TF1(""f"",""sin(x)*sin(x/10)"",; a-0.05*(b-a),b+0.05*(b-a));; // Draw function; f->Draw(""lc"");; ; // Create text and legend; Double_t xx1, yy1, xx2, yy2, dx, dy;; gPad->Update();; gPad->GetRangeAxis(xx1,yy1,xx2,yy2);; dx = xx2-xx1;; dy = yy2-yy1;; line5=new TLine(xx1+dx*0.3,yy1+dy*1.02,; xx1+dx*0.38,yy1+dy*1.02);; line5->SetLineColor(kRed);; line5->SetLineWidth(2);; text5 = new TText(xx1+dx*0.4,; yy1+dy*1.03,""quintic spline"");; text5->SetTextAlign(12);; text5->SetTextSize(0.04);; line3=new TLine(xx1+dx*0.67,yy1+dy*1.02,; xx1+dx*0.75,yy1+dy*1.02);; line3->SetLineColor(kGreen);; line3->SetLineWidth(2);; text3 = new TText(xx1+dx*0.77,; yy1+dy*1.03,""third spline"");; text3->SetTextAlign(12);; text3->SetTextSize(0.04);; textn = new TText(xx1+dx*0.8,yy1+dy*0.91,"" "");; textn->SetTextAlign(12);; textn->SetTextSize(0.04);; textn->Draw();; ; // Draw legenda; line5->Draw();; text5->Draw();; line3->Draw();; text3->Draw();; ; for(Int_t nnp=2; nnp<=np; ++nnp) {; ; // Calculate the knots; if(xx) delete[] xx;; xx = new Double_t[nnp];; if(yy) delete[] yy;; yy = new Double_t[nnp];; for (Int_t i=0; i<nnp; ++i) {; xx[i]=a+(b-a)*TMath::Power(i/Double_t (nnp-1),power);; yy[i]=f->Eval(xx[i]);; }; ; // Evaluate fifth spline coefficients; Double_t eps=(b-a)*1.e-5;; if(spline5) delete spline5;; spline5 = new TSpline5(""Test"",xx,f,nnp,""b1e1b2e2"",; f->Derivative(a),f->Derivative(b),; (f->Derivative(a+eps)-f->Derivative(a))/eps,; (f->Derivative(b)-f->D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/splines__test_8C.html:99,Load,Loading,99,doc/master/splines__test_8C.html,https://root.cern,https://root.cern/doc/master/splines__test_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/surfaces.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. surfaces.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Draw 2-Dim functions. . ; void surfaces() {; TCanvas *c1 = new TCanvas(""c1"",""Surfaces Drawing Options"",200,10,700,900);; TPaveText *title = new TPaveText(.2,0.96,.8,.995);; title->AddText(""Examples of Surface options"");; title->Draw();; ; TPad *pad1 = new TPad(""pad1"",""Gouraud shading"",0.03,0.50,0.98,0.95);; TPad *pad2 = new TPad(""pad2"",""Color mesh"",0.03,0.02,0.98,0.48);; pad1->Draw();; pad2->Draw();; //; // We generate a 2-D function; TF2 *f2 = new TF2(""f2"",""x**2 + y**2 - x**3 -8*x*y**4"",-1,1.2,-1.5,1.5);; f2->SetContour(48);; f2->SetFillColor(45);; ; // Draw this function in pad1 with Gouraud shading option; pad1->cd();; pad1->SetPhi(-80);; pad1->SetLogz();; f2->Draw(""surf4"");; ; // Draw this function in pad2 with color mesh option; pad2->cd();; pad2->SetTheta(25);; pad2->SetPhi(-110);; pad2->SetLogz();; f2->SetLineWidth(1);; f2->SetLineColor(5);; f2->Draw(""surf1"");; ; //add axis titles. The titles are set on the intermediate; //histogram used for visualisation. We must force this histogram; //to be created, then force the redrawing of the two pads; pad2->Update();; f2->GetHistogram()->GetXaxis()->SetTitle(""x title"");; f2->GetHistogram()->GetYaxis()->SetTitle(""y title"");; f2->GetHistogram()->GetXaxis()->SetTitleOffset(1.4);; f2->GetHistogram()->GetYaxis()->SetTitleOffset(1.4);; pad1->Modified();; pad2->Modified();; }; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/surfaces_8C.html:95,Load,Loading,95,doc/master/surfaces_8C.html,https://root.cern,https://root.cern/doc/master/surfaces_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/timeSeriesFromCSV.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. timeSeriesFromCSV.C File ReferenceTutorials » Graphs tutorials. Detailed Description; This macro illustrates the use of the time axis on a TGraph with data read from a text file containing the SWAN usage statistics during July 2017. . ; void timeSeriesFromCSV(); {; // Open the data file. This csv contains the usage statistics of a CERN IT; // service, SWAN, during two weeks. We would like to plot this data with; // ROOT to draw some conclusions from it.; TString dir = gROOT->GetTutorialDir();; dir.Append(""/graphs/"");; dir.ReplaceAll(""/./"", ""/"");; FILE *f = fopen(Form(""%sSWAN2017.dat"", dir.Data()), ""r"");; ; // Create the time graph; auto g = new TGraph();; g->SetTitle(""SWAN Users during July 2017;Time;Number of Sessions"");; ; // Read the data and fill the graph with time along the X axis and number; // of users along the Y axis; char line[80];; float v;; char dt[20];; int i = 0;; while (fgets(line, 80, f)) {; sscanf(&line[20], ""%f"", &v);; strncpy(dt, line, 18);; dt[19] = '\0';; g->SetPoint(i, TDatime(dt).Convert(), v);; i++;; }; fclose(f);; ; // Draw the graph; auto c = new TCanvas(""c"", ""c"", 950, 500);; c->SetLeftMargin(0.07);; c->SetRightMargin(0.04);; c->SetGrid();; g->SetLineWidth(3);; g->SetLineColor(kBlue);; g->Draw(""al"");; g->GetYaxis()->CenterTitle();; ; // Make the X axis labelled with time.; auto xaxis = g->GetXaxis();; xaxis->SetTimeDisplay(1);; xaxis->CenterTitle();; xaxis->SetTimeFormat(""%a %d"");; xaxis->SetTimeOffset(0);; xaxis->SetNdivisions(-219);; xaxis->SetLimits(TDatime(2017, 7, 3, 0, 0, 0).Convert(), TDatime(2017, 7, 22, 0, 0, 0).Convert());; xaxis->SetLabelSize(0.025);; xaxis->CenterLabels();; }; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; g#define g(i)Definition RSha256.hxx:105; kBlue@ kBlueDefinition Rtypes.h:66; gROOT#define gROOTDefinition TROOT.h:406; Formchar * Form",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/timeSeriesFromCSV_8C.html:104,Load,Loading,104,doc/master/timeSeriesFromCSV_8C.html,https://root.cern,https://root.cern/doc/master/timeSeriesFromCSV_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/timeSeriesFromCSV.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; timeSeriesFromCSV.py File ReferenceTutorials » Graphs tutorials. Detailed Description; This macro illustrates the use of the time axis on a TGraph with data read from a text file containing the SWAN usage statistics during July 2017. . ; import ROOT; ; # Open the data file. This csv contains the usage statistics of a CERN IT; # service, SWAN, during two weeks. We would like to plot this data with; # ROOT to draw some conclusions from it.; dirName = str(ROOT.gROOT.GetTutorialDir()); dirName += ""/graphs/""; dirName= dirName.replace(""/./"", ""/""); inputFileName = ""%s/SWAN2017.dat"" %dirName; ; # Create the time graph; g = ROOT.TGraph(); g.SetTitle(""SWAN Users during July 2017;Time;Number of Sessions""); ; # Read the data and fill the graph with time along the X axis and number; # of users along the Y axis; ; lines = open(inputFileName, ""r"").readlines(); ; for i, line in enumerate(lines):; d, h, value = line.split(); g.SetPoint(i, ROOT.TDatime(""%s %s"" %(d,h)).Convert(), float(value)); ; # Draw the graph; c = ROOT.TCanvas(""c"", ""c"", 950, 500); c.SetLeftMargin(0.07); c.SetRightMargin(0.04); c.SetGrid(); g.SetLineWidth(3); g.SetLineColor(ROOT.kBlue); g.Draw(""al""); g.GetYaxis().CenterTitle(); ; # Make the X axis labelled with time; xaxis = g.GetXaxis(); xaxis.SetTimeDisplay(1); xaxis.CenterTitle(); xaxis.SetTimeFormat(""%a %d""); xaxis.SetTimeOffset(0); xaxis.SetNdivisions(-219); xaxis.SetLimits(ROOT.TDatime(2017, 7, 3, 0, 0, 0).Convert(), ROOT.TDatime(2017, 7, 22, 0, 0, 0).Convert()); xaxis.SetLabelSize(0.025); xaxis.CenterLabels(); ; AuthorsDanilo Piparo, Olivier Couet ; Definition in file timeSeriesFromCSV.py. tutorialsgraphstimeSeriesFromCSV.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/timeSeriesFromCSV_8py.html:105,Load,Loading,105,doc/master/timeSeriesFromCSV_8py.html,https://root.cern,https://root.cern/doc/master/timeSeriesFromCSV_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/timeSeriesFromCSV_TDF.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. timeSeriesFromCSV_TDF.C File ReferenceTutorials » Graphs tutorials. Detailed Description; This macro illustrates the use of the time axis on a TGraph with data read from a text file containing the SWAN usage statistics during July 2017. ; We exploit the TDataFrame for reading from the file. ; void timeSeriesFromCSV_TDF(); {; // Open the data file. This csv contains the usage statistics of a CERN IT; // service, SWAN, during two weeks. We would like to plot this data with; // ROOT to draw some conclusions from it.; TString dir = gROOT->GetTutorialDir();; dir.Append(""/graphs/"");; dir.ReplaceAll(""/./"", ""/"");; ; // Read the data from the file using TDataFrame. We do not have headers and; // we would like the delimiter to be a space; auto tdf = ROOT::RDF::FromCSV(Form(""%sSWAN2017.dat"", dir.Data()), false, ' ');; ; // We now prepare the graph input; auto d = tdf.Define(""TimeStamp"", ""auto s = string(Col0) + ' ' + Col1; return (float) TDatime(s.c_str()).Convert();""); .Define(""Value"", ""(float)Col2"");; auto timeStamps = d.Take<float>(""TimeStamp"");; auto values = d.Take<float>(""Value"");; ; // Create the time graph; auto g = new TGraph(values->size(), timeStamps->data(), values->data());; g->SetTitle(""SWAN Users during July 2017;Time;Number of Sessions"");; ; // Draw the graph; auto c = new TCanvas(""c"", ""c"", 950, 500);; c->SetLeftMargin(0.07);; c->SetRightMargin(0.04);; c->SetGrid();; g->SetLineWidth(3);; g->SetLineColor(kBlue);; g->Draw(""al"");; g->GetYaxis()->CenterTitle();; ; // Make the X axis labelled with time.; auto xaxis = g->GetXaxis();; xaxis->SetTimeDisplay(1);; xaxis->CenterTitle();; xaxis->SetTimeFormat(""%a %d"");; xaxis->SetTimeOffset(0);; xaxis->SetNdivisions(-219);; xaxis->SetLimits(TDatime(2017, 7, 3, 0, 0, 0).Convert(), TDatime(2017, 7, 22, 0, 0, 0).Convert());; xaxis->SetLabelSize(0.025);; xaxis->CenterLabels();; }; d#d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/timeSeriesFromCSV__TDF_8C.html:108,Load,Loading,108,doc/master/timeSeriesFromCSV__TDF_8C.html,https://root.cern,https://root.cern/doc/master/timeSeriesFromCSV__TDF_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/timeonaxis.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. timeonaxis.C File ReferenceTutorials » Graphs tutorials. Detailed Description; This macro illustrates the use of the time mode on the axis with different time intervals and time formats. ; Through all this script, the time is expressed in UTC. some information about this format (and others like GPS) may be found at http://tycho.usno.navy.mil/systime.html or http://www.topology.org/sci/time.html; The start time is: almost NOW (the time at which the script is executed) actually, the nearest preceding hour beginning. The time is in general expressed in UTC time with the C time() function This will obviously most of the time not be the time displayed on your watch since it is a universal time. See the C time functions for converting this time into more useful structures. ; #include <time.h>; ; void timeonaxis(); {; ; time_t script_time;; script_time = time(0);; script_time = 3600*(int)(script_time/3600);; ; // The time offset is the one that will be used by all graphs.; // If one changes it, it will be changed even on the graphs already defined; gStyle->SetTimeOffset(script_time);; ; auto ct = new TCanvas(""ct"",""Time on axis"",10,10,700,900);; ct->Divide(1,3);; ; int i;; ; //### Build a signal: noisy damped sine; // Time interval: 30 minutes; ; gStyle->SetTitleH(0.08);; float noise;; auto ht = new TH1F(""ht"",""Love at first sight"",3000,0.,2000.);; for (i=1;i<3000;i++) {; noise = gRandom->Gaus(0,120);; if (i>700) {; noise += 1000*sin((i-700)*6.28/30)*exp((double)(700-i)/300);; }; ht->SetBinContent(i,noise);; }; ct->cd(1);; ht->SetLineColor(2);; ht->GetXaxis()->SetLabelSize(0.05);; ht->Draw();; // Sets time on the X axis; // The time used is the one set as time offset added to the value; // of the axis. This is converted into day/month/year hour:min:sec and; // a reasonable tick interval value is chosen.; ht->GetXaxis()->SetTimeDisplay(1);; ; /",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/timeonaxis_8C.html:97,Load,Loading,97,doc/master/timeonaxis_8C.html,https://root.cern,https://root.cern/doc/master/timeonaxis_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/timeonaxis2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. timeonaxis2.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Define the time offset as 2003, January 1st. . ; void timeonaxis2() {; auto ct2 = new TCanvas(""ct2"",""ct2"",10,10,700,500);; ; TDatime T0(2003, 1, 1, 0, 0, 0);; int X0 = T0.Convert();; gStyle->SetTimeOffset(X0);; ; // Define the lowest histogram limit as 2002, September 23rd; TDatime T1(2002, 9, 23, 0, 0, 0);; int X1 = T1.Convert()-X0;; ; // Define the highest histogram limit as 2003, March 7th; TDatime T2(2003, 3, 7, 0, 0, 0);; int X2 = T2.Convert(1)-X0;; ; auto h1 = new TH1F(""h1"",""test"",100,X1,X2);; ; TRandom r;; for (Int_t i=0;i<30000;i++) {; Double_t noise = r.Gaus(0.5*(X1+X2),0.1*(X2-X1));; h1->Fill(noise);; }; ; h1->GetXaxis()->SetTimeDisplay(1);; h1->GetXaxis()->SetLabelSize(0.03);; h1->GetXaxis()->SetTimeFormat(""%Y/%m/%d"");; h1->Draw();; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TAttAxis::SetLabelSizevirtual void SetLabelSize(Float_t size=0.04)Set size of axis labels.Definition TAttAxis.cxx:203; TAxis::SetTimeDisplayvirtual void SetTimeDisplay(Int_t value)Definition TAxis.h:171; TAxis::SetTimeFormatvirtual void SetTimeFormat(const char *format="""")Change the format used for time plotting.Definition TAxis.cxx:1157; TCanvasThe Canvas class.Definition TCanvas.h:23; TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::GetXaxis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/timeonaxis2_8C.html:98,Load,Loading,98,doc/master/timeonaxis2_8C.html,https://root.cern,https://root.cern/doc/master/timeonaxis2_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/timeonaxis3.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. timeonaxis3.C File ReferenceTutorials » Graphs tutorials. Detailed Description; This example compares what the system time function gmtime and localtime give with what gives TGaxis. ; It can be used as referenced test to check if TGaxis is working properly. The original code was developed by Philippe Gras (CEA Saclay. IRFU/SEDI). ; #include ""TAxis.h""; #include ""TGaxis.h""; #include ""TCanvas.h""; #include ""TString.h""; #include ""TLine.h""; #include ""TLatex.h""; #include <ctime>; #include <cstdio>; ; TString stime(time_t* t, bool utc = false, bool display_time_zone = true) {; struct tm* tt;; if (utc) tt = gmtime(t);; else tt = localtime(t);; char buf[256];; if (display_time_zone) strftime(buf, sizeof(buf), ""%Y-%m-%d %H:%M:%S %Z"", tt);; else strftime(buf, sizeof(buf), ""%Y-%m-%d %H:%M:%S"", tt);; return TString(buf);; }; ; ; void timeonaxis3() {; double f = 1.8;; ; auto c = new TCanvas;; ; TLatex tex1;; tex1.SetNDC();; tex1.SetTextFont(102);; tex1.SetTextSize(0.055*f);; ; TLatex tex3;; tex3.SetNDC();; tex3.SetTextFont(102);; tex3.SetTextSize(0.07*f);; tex3.SetTextColor(kBlue+2);; ; TLatex tex2;; tex2.SetNDC();; tex2.SetTextFont(102);; tex2.SetTextSize(0.07*f);; tex2.SetTextColor(kOrange+3);; ; time_t offset[] = {0, 0, 1325376000, 1341100800};; time_t t[] = {1331150400, 1336417200, 0, 36000};; ; c->SetTopMargin(0); c->SetBottomMargin(0);; c->SetLeftMargin(0); c->SetRightMargin(0);; c->Divide(2, 4, -1, -1);; TLine l;; l.DrawLine(0.5, 0, 0.5, 1.);; ; for(int i = 0; i < 4; ++i){; for(int gmt = 0; gmt < 2; ++gmt){; const char* opt = (gmt ? ""gmt"" : ""local"");; TVirtualPad* p = c->cd(2*i + gmt + 1);; p->SetTopMargin(0); p->SetBottomMargin(0);; p->SetLeftMargin(0); p->SetRightMargin(0);; p->SetFillStyle(4000);; ; TGaxis* ga = new TGaxis (.4, .25, 5., .25, t[i], t[i] + 1, 1, ""t"");; ga->SetTimeFormat(""TGaxis label: #color[2]{%Y-%m-%d %H:%M:%S}"");; ga->Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/timeonaxis3_8C.html:98,Load,Loading,98,doc/master/timeonaxis3_8C.html,https://root.cern,https://root.cern/doc/master/timeonaxis3_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/waves.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. waves.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Hint: Spherical waves . ; #include ""TROOT.h""; #include ""TCanvas.h""; #include ""TColor.h""; #include ""TArc.h""; #include ""TGraph.h""; #include ""TF2.h""; #include ""TLine.h""; #include ""TLatex.h""; #include ""TMath.h""; #include ""TStyle.h""; ; //______________________________________________________________; Double_t interference( Double_t *x, Double_t *par); {; Double_t x_p2 = x[0] * x[0];; Double_t d_2 = 0.5 * par[2];; Double_t ym_p2 = (x[1] - d_2) * (x[1] - d_2);; Double_t yp_p2 = (x[1] + d_2) * (x[1] + d_2);; Double_t tpi_l = TMath::Pi() / par[1];; Double_t amplitude = par[0] * (cos(tpi_l * sqrt(x_p2 + ym_p2)); + par[3] * cos(tpi_l * sqrt(x_p2 + yp_p2)));; return amplitude * amplitude;; }; ; ; //_____________________________________________________________; Double_t result( Double_t *x, Double_t *par); {; Double_t xint[2];; Double_t maxintens = 0, xcur = 14;; Double_t dlambda = 0.1 * par[1];; for(Int_t i=0; i<10; i++){; xint[0] = xcur;; xint[1] = x[1];; Double_t intens = interference(xint, par);; if(intens > maxintens) maxintens = intens;; xcur -= dlambda;; }; return maxintens;; }; ; ; //_____________________________________________________________; void waves( Double_t d = 3, Double_t lambda = 1, Double_t amp = 10); {; TCanvas *c1 = new TCanvas(""waves"", ""A double slit experiment"", 300, 40, 1004, 759);; c1->Range(0, -10, 30, 10);; c1->SetFillColor(0);; TPad *pad = new TPad(""pr"",""pr"", 0.5, 0 , 1., 1);; pad->Range(0, -10, 15, 10);; pad->Draw();; ; const Int_t colNum = 30;; Int_t palette[colNum];; for (Int_t i=0;i<colNum;i++) {; Float_t level = 1.*i/colNum;; palette[i] = TColor::GetColor((Float_t) TMath::Power(level,0.3), (Float_t) TMath::Power(level,0.3), (Float_t) 0.5*level);; // palette[i] = 1001+i;; }; gStyle->SetPalette(colNum, palette);; ; c1->cd();; ; TF2 *f0 = new TF2(""r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/waves_8C.html:92,Load,Loading,92,doc/master/waves_8C.html,https://root.cern,https://root.cern/doc/master/waves_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/zdemo.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. zdemo.C File ReferenceTutorials » Graphs tutorials. Detailed Description; This macro is an example of graphs in log scales with annotations. ; The presented results are predictions of invariant cross-section of Direct Photons produced at RHIC energies, based on the universality of scaling function H(z).; These Figures were published in JINR preprint E2-98-64, Dubna, 1998 and submitted to CPC.; Note that the way greek symbols, super/subscripts are obtained illustrate the current limitations of Root in this area. ; #include ""TCanvas.h""; #include ""TPad.h""; #include ""TPaveLabel.h""; #include ""TLatex.h""; #include ""TGraph.h""; #include ""TFrame.h""; ; #ifdef HZ; #undef HZ; #endif; ; const Int_t NMAX = 20;; Int_t NLOOP;; Float_t Z[NMAX], HZ[NMAX], PT[NMAX], INVSIG[NMAX];; ; void hz_calc(Float_t, Float_t, Float_t, Float_t, Float_t, Float_t);; ; //__________________________________________________________________; void zdemo(); {; ; Float_t energ;; Float_t dens;; Float_t tgrad;; Float_t ptmin;; Float_t ptmax;; Float_t delp;; ; // Create a new canvas.; TCanvas *c1 = new TCanvas(""zdemo"",; ""Monte Carlo Study of Z scaling"",10,40,800,600);; c1->Range(0,0,25,18);; c1->SetFillColor(40);; ; TPaveLabel *pl = new TPaveLabel(1,16.3,24,17.5,""Z-scaling of \; Direct Photon Productions in pp Collisions at RHIC Energies"",""br"");; pl->SetFillColor(18);; pl->SetTextFont(32);; pl->SetTextColor(49);; pl->Draw();; ; TLatex t0;; t0.SetTextFont(32);; t0.SetTextColor(1);; t0.SetTextSize(0.03);; t0.SetTextAlign(12);; t0.DrawLatex(3.1,15.5,""M.Tokarev, E.Potrebenikova "");; t0.DrawLatex(14.,15.5,""JINR preprint E2-98-64, Dubna, 1998 "");; ; TPad *pad1 = new TPad(""pad1"",""This is pad1"",0.02,0.02,0.48,0.83,33);; TPad *pad2 = new TPad(""pad2"",""This is pad2"",0.52,0.02,0.98,0.83,33);; ; pad1->Draw();; pad2->Draw();; ; //; // Cross-section of direct photon production in pp collisions; // at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/zdemo_8C.html:92,Load,Loading,92,doc/master/zdemo_8C.html,https://root.cern,https://root.cern/doc/master/zdemo_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/zones.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. zones.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Example of script showing how to divide a canvas into adjacent subpads + axis labels on the top and right side of the pads. . ; void zones() {; TCanvas *c1 = new TCanvas(""c1"",""multipads"",900,700);; gStyle->SetOptStat(0);; c1->Divide(2,2,0,0);; TH2F *h1 = new TH2F(""h1"",""test1"",10,0,1,20,0,20);; TH2F *h2 = new TH2F(""h2"",""test2"",10,0,1,20,0,100);; TH2F *h3 = new TH2F(""h3"",""test3"",10,0,1,20,-1,1);; TH2F *h4 = new TH2F(""h4"",""test4"",10,0,1,20,0,1000);; ; c1->cd(1);; gPad->SetTickx(2);; h1->Draw();; ; c1->cd(2);; gPad->SetTickx(2);; gPad->SetTicky(2);; h2->GetYaxis()->SetLabelOffset(0.01);; h2->Draw();; ; c1->cd(3);; h3->Draw();; ; c1->cd(4);; gPad->SetTicky(2);; h4->Draw();; }; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; gPad#define gPadDefinition TVirtualPad.h:308; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; c1return c1Definition legend1.C:41; h1TH1F * h1Definition legend1.C:5; zonesDefinition zones.py:1; AuthorRene Brun ; Definition in file zones.C. tutorialsgraphszones.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/zones_8C.html:92,Load,Loading,92,doc/master/zones_8C.html,https://root.cern,https://root.cern/doc/master/zones_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/graphs/zones.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; zones.py File ReferenceTutorials » Graphs tutorials. Detailed Description; Example of script showing how to divide a canvas into adjacent subpads + axis labels on the top and right side of the pads. ; Original tutorial by Rene Brun. ; import ROOT; ; c1 = ROOT.TCanvas(""c1"",""multipads"",900,700); ROOT.gStyle.SetOptStat(0); ; c1.Divide(2,2,0,0); h1 = ROOT.TH2F(""h1"",""test1"",10,0,1,20,0,20); h2 = ROOT.TH2F(""h2"",""test2"",10,0,1,20,0,100); h3 = ROOT.TH2F(""h3"",""test3"",10,0,1,20,-1,1); h4 = ROOT.TH2F(""h4"",""test4"",10,0,1,20,0,1000); ; c1.cd(1); ROOT.gPad.SetTickx(2); h1.Draw(); c1.cd(2); ROOT.gPad.SetTickx(2); ROOT.gPad.SetTicky(2); h2.GetYaxis().SetLabelOffset(0.01); h2.Draw(); c1.cd(3); h3.Draw(); c1.cd(4); ROOT.gPad.SetTicky(2); h4.Draw(); ; AuthorAlberto Ferro ; Definition in file zones.py. tutorialsgraphszones.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/zones_8py.html:93,Load,Loading,93,doc/master/zones_8py.html,https://root.cern,https://root.cern/doc/master/zones_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist Directory Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. hist Directory Reference. Directory dependency graph for hist:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files;  candledecay.C;   Candle Decay, illustrate a time development of a certain value. ;  ;  candlehisto.C;   Example showing how to combine the various candle plot options. ;  ;  candleplot.C;   Example of candle plot with 2-D histograms. ;  ;  candleplotoption.C;   Example showing how to combine the various candle plot options. ;  ;  candleplotstack.C;   Example showing how a THStack with candle plot option. ;  ;  candleplotwhiskers.C;   Example of candle plot showing the whiskers definition. ;  ;  candlescaled.C;   Candle Scaled, illustrates what scaling does on candle and violin charts. ;  ;  ContourList.C;   Getting Contours From TH2D. ;  ;  cumulative.C;   Illustrate use of the TH1::GetCumulative method. ;  ;  draw2dopt.C;   Display the various 2-d drawing options ;  ;  DynamicSlice.C;   Show the slice of a TH2 following the mouse position. ;  ;  exec1.C;  Echo object at mouse position. ;  ;  exec2.C;  Echo object at mouse position and show a graphics line. ;  ;  Fibonacci.C;   A TH2Poly build with Fibonacci numbers. ;  ;  fillhistosauto2p.C;  Fill multiple histograms with different functions and automatic binning. ;  ;  fillrandom.C;   Fill a 1-D histogram from a parametric function. ;  ;  fillrandom.py;   Fill a 1-D histogram from a parametric function. ;  ;  FirstContour.C;   Make a contour plot and get the first contour in a TPolyMarker. ;  ;  h1ReadAndDraw.C;   Read a 1-D histogram from a ROOT File and draw it. ;  ;  h2_cut.C;   This example demonstrates how to display a 2D histogram and use TCutG object to select bins for drawing. ;  ;  h2proj.C;   This example demonstrates how to display a histogram and its two projections. ;  ;  hbars.C;   Example of bar charts with 1-d histograms. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html:87,Load,Loading,87,doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,https://root.cern,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/ContourList.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ContourList.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Getting Contours From TH2D. ; Image produced by .x ContourList.C; The contours values are drawn next to each contour. . Output produced by .x ContourList.C; It shows that 6 contours and 12 graphs were found. ; TotalConts = 6; Contour 0 has 2 Graphs; Contour 1 has 2 Graphs; Contour 2 has 2 Graphs; Contour 3 has 2 Graphs; Contour 4 has 2 Graphs; Contour 5 has 2 Graphs; Z-Level Passed in as: Z = -0.100000; Graph: 1 -- 147 Elements; Graph: 2 -- 147 Elements; Z-Level Passed in as: Z = -0.500000; Graph: 3 -- 93 Elements; Graph: 4 -- 93 Elements; Z-Level Passed in as: Z = -0.700000; Graph: 5 -- 65 Elements; Graph: 6 -- 65 Elements; Z-Level Passed in as: Z = 0.100000; Graph: 7 -- 147 Elements; Graph: 8 -- 147 Elements; Z-Level Passed in as: Z = 0.400000; Graph: 9 -- 107 Elements; Graph: 10 -- 107 Elements; Z-Level Passed in as: Z = 0.800000; Graph: 11 -- 49 Elements; Graph: 12 -- 49 Elements; ; ; Extracted 6 Contours and 12 Graphs ; (TCanvas *) 0x5649202575c0; ContourList.C; ; Double_t SawTooth(Double_t x, Double_t WaveLen);; ; TCanvas *ContourList(){; ; const Double_t PI = TMath::Pi();; ; TCanvas* c = new TCanvas(""c"",""Contour List"",0,0,600,600);; c->SetRightMargin(0.15);; c->SetTopMargin(0.15);; ; Int_t i, j;; ; Int_t nZsamples = 80;; Int_t nPhiSamples = 80;; ; Double_t HofZwavelength = 4.0; // 4 meters; Double_t dZ = HofZwavelength/(Double_t)(nZsamples - 1);; Double_t dPhi = 2*PI/(Double_t)(nPhiSamples - 1);; ; TArrayD z(nZsamples);; TArrayD HofZ(nZsamples);; TArrayD phi(nPhiSamples);; TArrayD FofPhi(nPhiSamples);; ; // Discretized Z and Phi Values; for ( i = 0; i < nZsamples; i++) {; z[i] = (i)*dZ - HofZwavelength/2.0;; HofZ[i] = SawTooth(z[i], HofZwavelength);; }; ; for(Int_t i=0; i < nPhiSamples; i++){; phi[i] = (i)*dPhi;; FofPhi[i] = sin(phi[i]);; }; ; //",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ContourList_8C.html:96,Load,Loading,96,doc/master/ContourList_8C.html,https://root.cern,https://root.cern/doc/master/ContourList_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/DynamicSlice.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. DynamicSlice.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Show the slice of a TH2 following the mouse position. . ; ; void DynamicSlice(); {; // Create a new canvas.; TCanvas* c1 = new TCanvas(""c1"",""Dynamic Slice Example"", 10, 10, 700, 500);; ; //create a 2-d histogram, fill and draw it; TH2F *hpxpy = new TH2F(""hpxpy"", ""py vs px"", 40,-4,4, 40,-4,4);; hpxpy->SetStats(0);; Double_t px,py;; for (Int_t i = 0; i < 50000; i++) {; gRandom->Rannor(px,py);; hpxpy->Fill(px,py);; }; hpxpy->Draw(""col"");; ; //Add a TExec object to the canvas; c1->AddExec(""dynamic"", ""DynamicExec()"");; }; ; void DynamicExec(); {; // Example of function called when a mouse event occurs in a pad.; // When moving the mouse in the canvas, a second canvas shows the; // projection along X of the bin corresponding to the Y position; // of the mouse. The resulting histogram is fitted with a gaussian.; // A ""dynamic"" line shows the current bin position in Y.; // This more elaborated example can be used as a starting point; // to develop more powerful interactive applications exploiting Cling; // as a development engine.; ; static int pyold = 0;; ; float uxmin = gPad->GetUxmin();; float uxmax = gPad->GetUxmax();; int pxmin = gPad->XtoAbsPixel(uxmin);; int pxmax = gPad->XtoAbsPixel(uxmax);; int px = gPad->GetEventX();; int py = gPad->GetEventY();; TObject *select = gPad->GetSelected();; ; gPad->GetCanvas()->FeedbackMode(kTRUE);; if (pyold) {; // erase line at old position; gVirtualX->DrawLine(pxmin, pyold, pxmax, pyold);; pyold = 0;; }; ; if(!select || !select->InheritsFrom(TH2::Class())); return;; ; TH2 *h = (TH2*)select;; ; // draw a line at current position; gVirtualX->DrawLine(pxmin, py, pxmax, py);; pyold = py;; ; Float_t upy = gPad->AbsPixeltoY(py);; Float_t y = gPad->PadtoY(upy);; ; //create or set the new canvas c2; TVirtualPad *padsav = gPad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DynamicSlice_8C.html:97,Load,Loading,97,doc/master/DynamicSlice_8C.html,https://root.cern,https://root.cern/doc/master/DynamicSlice_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/Fibonacci.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Fibonacci.C File ReferenceTutorials » Histograms tutorials. Detailed Description; A TH2Poly build with Fibonacci numbers. ; In mathematics, the Fibonacci sequence is a suite of integer in which every number is the sum of the two preceding one.; The first 10 Fibonacci numbers are:; 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...; This tutorial computes Fibonacci numbers and uses them to build a TH2Poly producing the ""Fibonacci spiral"" created by drawing circular arcs connecting the opposite corners of squares in the Fibonacci tiling. ; void Arc(int n, double a, double r, double *px, double *py);; void AddFibonacciBin(TH2Poly *h2pf, double N);; ; void Fibonacci(int N=7) {; // N = number of Fibonacci numbers > 1; ; TCanvas *C = new TCanvas(""C"", ""C"", 800, 600);; C->SetFrameLineWidth(0);; ; TH2Poly *h2pf = new TH2Poly(); // TH2Poly containing Fibonacci bins.; h2pf->SetTitle(Form(""The first %d Fibonacci numbers"",N));; h2pf->SetMarkerColor(kRed-2);; h2pf->SetStats(0);; ; double f0 = 0.;; double f1 = 1.;; double ft;; ; AddFibonacciBin(h2pf, f1);; ; for (int i=0; i<=N; i++) {; ft = f1;; f1 = f0 + f1;; f0 = ft;; AddFibonacciBin(h2pf, f1);; }; ; h2pf->Draw(""A COL L TEXT"");; }; ; void Arc(int n, double a, double r, double *px, double *py) {; // Add points on a arc of circle from point 2 to n-2; ; double da = TMath::Pi()/(2*(n-2)); // Angle delta; ; for (int i = 2; i<=n-2; i++) {; a = a+da;; px[i] = r*TMath::Cos(a) + px[0];; py[i] = r*TMath::Sin(a) + py[0];; }; }; ; void AddFibonacciBin(TH2Poly *h2pf, double N) {; // Add to h2pf the bin corresponding to the Fibonacci number N; ; double X1 = 0.; //; double Y1 = 0.; // Current Fibonacci; double X2 = 1.; // square position.; double Y2 = 1.; //; ; static int MoveId = 0;; ; static double T = 1.; //Current Top limit of the bins; static double B = 0.; //Current Bottom limit of the bins; static double L = 0.; //Curren",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fibonacci_8C.html:94,Load,Loading,94,doc/master/Fibonacci_8C.html,https://root.cern,https://root.cern/doc/master/Fibonacci_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/FirstContour.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. FirstContour.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Make a contour plot and get the first contour in a TPolyMarker. ; This macro generates a color contour plot by selecting entries from an ntuple file. The TGraph object corresponding to the first contour line is accessed and displayed into a separate canvas.; ; void FirstContour(); {; TString dir = gROOT->GetTutorialDir();; dir.Append(""/hsimple.C"");; dir.ReplaceAll(""/./"",""/"");; if (!gInterpreter->IsLoaded(dir.Data())) gInterpreter->LoadMacro(dir.Data());; TFile *file = (TFile*)gROOT->ProcessLineFast(""hsimple(1)"");; if (!file) return;; TTree *ntuple = (TTree*)file->Get(""ntuple"");; ; TCanvas *c1 = new TCanvas(""c1"",""Contours"",10,10,800,600);; ntuple->Draw(""py:px"",""px*px+py*py < 20"", ""contz,list"");; ; //we must call Update to force the canvas to be painted. When; //painting the contour plot, the list of contours is generated; //and a reference to it added to the Root list of special objects; c1->Update();; ; TCanvas *c2 = new TCanvas(""c2"",""First contour"",100,100,800,600);; ; ; TObjArray *contours =; (TObjArray*)gROOT->GetListOfSpecials()->FindObject(""contours"");; if (!contours) return;; TList *lcontour1 = (TList*)contours->At(0);; if (!lcontour1) return;; TGraph *gc1 = (TGraph*)lcontour1->First();; if (!gc1) return;; if (gc1->GetN() < 10) return;; gc1->SetMarkerStyle(21);; gc1->Draw(""alp"");; ; //We make a TCutG object with the array obtained from this graph; TCutG *cutg = new TCutG(""cutg"",gc1->GetN(),gc1->GetX(),gc1->GetY());; ; //We create a polymarker object with npmax points.; const Int_t npmax = 50000;; TPolyMarker *pm = new TPolyMarker(npmax);; Int_t np = 0;; while(1) {; Double_t x = -4 +8*gRandom->Rndm();; Double_t y = -4 +8*gRandom->Rndm();; if (cutg->IsInside(x,y)) {; pm->SetPoint(np,x,y);; np++;; if (np == npmax) break;; }; }; pm->Draw();; }; Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FirstContour_8C.html:97,Load,Loading,97,doc/master/FirstContour_8C.html,https://root.cern,https://root.cern/doc/master/FirstContour_8C.html,2,['Load'],"['LoadMacro', 'Loading']"
Performance,". ROOT: tutorials/hist/NormalizeHistogram.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. NormalizeHistogram.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Normalizing a Histogram ; Image produced by .x NormalizeHistogram.C Two different methods of normalizing histograms are shown, each with the original histogram. next to the normalized one. . ; #include ""TH2F.h""; #include ""TRandom.h""; #include ""TCanvas.h""; ; void NormalizeHistogram(); {; ; std::array<double, 6> binsx{0, 5, 10, 20, 50, 100};; TH1F *orig = new TH1F(""orig"", ""Original histogram before normalization"", binsx.size() - 1, &binsx[0]);; ; gStyle->SetTitleFontSize(0.06);; ; TRandom2 rand;; ; // Filling histogram with random entries; for (int i = 0; i < 100'000; ++i) {; double r = rand.Rndm() * 100;; orig->Fill(r);; }; ; TH1F *norm = (TH1F *)orig->Clone(""norm"");; norm->SetTitle(""Normalized Histogram"");; ; // Normalizing the Histogram by scaling by 1 / the integral and taking width into account; norm->Scale(1. / norm->Integral(), ""width"");; ; // Drawing everything; TCanvas *c1 = new TCanvas(""c1"", ""Histogram Normalization"", 700, 900);; c1->Divide(1, 2);; ; c1->cd(1);; orig->Draw();; c1->cd(2);; norm->Draw();; }; TCanvas.h; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TH2F.h; TRandom.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::SetTitlevoid SetTitle(const char *title) overrideChange/set the title.Definition TH1.cxx:6718; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NormalizeHistogram_8C.html:103,Load,Loading,103,doc/master/NormalizeHistogram_8C.html,https://root.cern,https://root.cern/doc/master/NormalizeHistogram_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/ZoomHistogram.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ZoomHistogram.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Changing the Range on the X-Axis of a Histogram ; Image produced by .x ZoomHistogram.C; This demonstrates how to zoom into a histogram by changing the range on one of the axes (or both). ; void ZoomHistogram(); {; TH1F *orig = new TH1F(""Normal Histogram"", ""Normal Histogram"", 100, 0, 100);; ; for (int i = 0; i < 100; ++i) {; Double_t x = gRandom->Gaus(50, 10);; orig->Fill(x);; }; ; TH1F *zoom = (TH1F *)orig->Clone(""zoom"");; zoom->SetTitle(""Zoomed-in Histogram"");; zoom->GetXaxis()->SetRangeUser(50, 100);; ; TCanvas *c1 = new TCanvas(""c1"", ""Histogram"", 1500, 700);; c1->Divide(2, 1);; ; c1->cd(1);; orig->Draw();; c1->cd(2);; zoom->Draw();; }; Double_tdouble Double_tDefinition RtypesCore.h:59; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TAxis::SetRangeUservirtual void SetRangeUser(Double_t ufirst, Double_t ulast)Set the viewing range for the axis from ufirst to ulast (in user coordinates, that is,...Definition TAxis.cxx:1080; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::SetTitlevoid SetTitle(const char *title) overrideChange/set the title.Definition TH1.cxx:6718; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::CloneTObject * Clone(const char *newname="""") const overrideMake a complete copy of the underlying object.Definition TH1.cxx:2752; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ZoomHistogram_8C.html:98,Load,Loading,98,doc/master/ZoomHistogram_8C.html,https://root.cern,https://root.cern/doc/master/ZoomHistogram_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/candledecay.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. candledecay.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Candle Decay, illustrate a time development of a certain value. . ; void candledecay(); {; auto c1 = new TCanvas(""c1"",""Candle Decay"",800,600);; c1->Divide(2,1);; auto rng = new TRandom();; auto h1 = new TH2I(""h1"",""Decay"",1000,0,1000,20,0,20);; ; float myRand;; for (int i = 0; i < 19; i++) {; for (int j = 0; j < 1000000; j++) {; myRand = rng->Gaus(350+i*8,20+2*i);; h1->Fill(myRand,i);; }; }; h1->SetBarWidth(3);; h1->SetFillStyle(0);; h1->SetFillColor(kGray);; h1->SetLineColor(kBlue);; h1->GetYaxis()->SetTitle(""time"");; h1->GetXaxis()->SetTitle(""probability density"");; ; c1->cd(1);; h1->Draw(""violiny(112000000)"");; c1->cd(2);; auto h2 = (TH2I*)h1->Clone(""h2"");; h2->SetBarWidth(0.8);; h2->DrawCopy(""candley2"");; }; kGray@ kGrayDefinition Rtypes.h:65; kBlue@ kBlueDefinition Rtypes.h:66; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::CloneTObject * Clone(const char *newname="""") const overrideMake a complete copy of the underlying object.Definition TH1.cxx:2752; TH1::SetBarWidthvirtual void SetBarWidth(Float_t width=0.5)Set the width of bars as fraction of the bin width for drawing mode ""B"".Definition TH1.h:365; TH2I2-D ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/candledecay_8C.html:96,Load,Loading,96,doc/master/candledecay_8C.html,https://root.cern,https://root.cern/doc/master/candledecay_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/candlehisto.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. candlehisto.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Example showing how to combine the various candle plot options. . ; void candlehisto(); {; TCanvas *c1 = new TCanvas(""c1"", ""Candle Presets"", 800, 600);; c1->Divide(3, 2);; ; TRandom *rng = new TRandom();; TH2I *h1 = new TH2I(""h1"", ""Sin"", 18, 0, 360, 100, -1.5, 1.5);; h1->GetXaxis()->SetTitle(""Deg"");; ; float myRand;; for (int i = 0; i < 360; i+= 10) {; for (int j = 0; j < 100; j++) {; myRand = rng->Gaus(sin(i * 3.14 / 180), 0.2);; h1->Fill(i, myRand);; }; }; ; for (int i = 1; i < 7; i++) {; c1->cd(i);; TString title = TString::Format(""CANDLEX%d"", i);; TH2I *myhist = (TH2I*)h1->DrawCopy(title);; myhist->SetTitle(title);; }; ; TCanvas *c2 = new TCanvas(""c2"", ""Violin Presets"", 800, 300);; c2->Divide(2, 1);; ; for (int i = 1; i < 3; i++) {; c2->cd(i);; TString title = TString::Format(""VIOLINX%d"", i);; TH2I *myhist = (TH2I*)h1->DrawCopy(title);; myhist->SetFillColor(kGray + 2);; }; ; TCanvas *c3 = new TCanvas(""c3"", ""Playing with candle and violin-options"", 800, 600);; c3->Divide(3, 2);; TString myopt[6] = {""1000000"", ""2000000"", ""3000000"", ""1112111"", ""112111"", ""112111""};; for (int i = 0; i < 6; i++) {; c3->cd(i + 1);; TString title = TString::Format(""candlex(%s)"", myopt[i].Data());; TH2I *myhist = (TH2I*)h1->DrawCopy(title);; myhist->SetFillColor(kYellow);; if (i == 4) {; TH2I *myhist2 = (TH2I*)h1->DrawCopy(""candlex(1000000) same"");; myhist2->SetFillColor(kRed);; }; if (i == 5) {; myhist->SetBarWidth(0.2);; myhist->SetBarOffset(0.25);; TH2I *myhist2 = (TH2I*)h1->DrawCopy(""candlex(2000000) same"");; myhist2->SetFillColor(kRed);; myhist2->SetBarWidth(0.6);; myhist2->SetBarOffset(-0.5);; }; myhist->SetTitle(title);; }; }; kGray@ kGrayDefinition Rtypes.h:65; kRed@ kRedDefinition Rtypes.h:66; kYellow@ kYellowDefinition Rtypes.h:66; TAttFill::SetFillColorvirtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/candlehisto_8C.html:96,Load,Loading,96,doc/master/candlehisto_8C.html,https://root.cern,https://root.cern/doc/master/candlehisto_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/candleplot.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. candleplot.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Example of candle plot with 2-D histograms. . ; void candleplot() {; ; gStyle->SetTimeOffset(0);; TDatime dateBegin(2010,1,1,0,0,0);; TDatime dateEnd(2011,1,1,0,0,0);; ; auto h1 = new TH2I(""h1"",""Machine A + B"",12,dateBegin.Convert(),dateEnd.Convert(),1000,0,1000);; auto h2 = new TH2I(""h2"",""Machine B"",12,dateBegin.Convert(),dateEnd.Convert(),1000,0,1000);; ; h1->GetXaxis()->SetTimeDisplay(1);; h1->GetXaxis()->SetTimeFormat(""%d/%m/%y"");; h1->GetXaxis()->SetNdivisions(-6);; h1->GetXaxis()->SetTitle(""Date [day/month/year]"");; ; float Rand;; for (int i = dateBegin.Convert(); i < dateEnd.Convert(); i+=86400*30) {; for (int j = 0; j < 1000; j++) {; Rand = gRandom->Gaus(500+sin(i/10000000.)*100,50); h1->Fill(i,Rand);; Rand = gRandom->Gaus(500+sin(i/11000000.)*100,70); h2->Fill(i,Rand);; }; }; ; h1->SetBarWidth(0.4);; h1->SetBarOffset(-0.25);; h1->SetFillColor(kYellow);; h1->SetFillStyle(1001);; ; h2->SetBarWidth(0.4);; h2->SetBarOffset(0.25);; h2->SetLineColor(kRed);; h2->SetFillColor(kGreen);; ; auto c1 = new TCanvas();; ; h1->Draw(""candle2"");; h2->Draw(""candle3 same"");; ; gPad->BuildLegend(0.78,0.695,0.980,0.935,"""",""f"");; }; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; kYellow@ kYellowDefinition Rtypes.h:66; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; gPad#define gPadDefinition TVirtualPad.h:308; TAttAxis::SetNdivisionsvirtual void SetNdivisions(Int_t n=510, Bool_t optim=kTRUE)Set the number of divisions for this axis.Definition TAttAxis.cxx:233; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/candleplot_8C.html:95,Load,Loading,95,doc/master/candleplot_8C.html,https://root.cern,https://root.cern/doc/master/candleplot_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/candleplot.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. candleplot.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_hist; 3/// \notebook; 4/// Example of candle plot with 2-D histograms.; 5///; 6/// \macro_image; 7/// \macro_code; 8///; 9/// \author Georg Troska; 10 ; 11void candleplot() {; 12 ; 13 gStyle->SetTimeOffset(0);; 14 TDatime dateBegin(2010,1,1,0,0,0);; 15 TDatime dateEnd(2011,1,1,0,0,0);; 16 ; 17 auto h1 = new TH2I(""h1"",""Machine A + B"",12,dateBegin.Convert(),dateEnd.Convert(),1000,0,1000);; 18 auto h2 = new TH2I(""h2"",""Machine B"",12,dateBegin.Convert(),dateEnd.Convert(),1000,0,1000);; 19 ; 20 h1->GetXaxis()->SetTimeDisplay(1);; 21 h1->GetXaxis()->SetTimeFormat(""%d/%m/%y"");; 22 h1->GetXaxis()->SetNdivisions(-6);; 23 h1->GetXaxis()->SetTitle(""Date [day/month/year]"");; 24 ; 25 float Rand;; 26 for (int i = dateBegin.Convert(); i < dateEnd.Convert(); i+=86400*30) {; 27 for (int j = 0; j < 1000; j++) {; 28 Rand = gRandom->Gaus(500+sin(i/10000000.)*100,50); h1->Fill(i,Rand);; 29 Rand = gRandom->Gaus(500+sin(i/11000000.)*100,70); h2->Fill(i,Rand);; 30 }; 31 }; 32 ; 33 h1->SetBarWidth(0.4);; 34 h1->SetBarOffset(-0.25);; 35 h1->SetFillColor(kYellow);; 36 h1->SetFillStyle(1001);; 37 ; 38 h2->SetBarWidth(0.4);; 39 h2->SetBarOffset(0.25);; 40 h2->SetLineColor(kRed);; 41 h2->SetFillColor(kGreen);; 42 ; 43 auto c1 = new TCanvas();; 44 ; 45 h1->Draw(""candle2"");; 46 h2->Draw(""candle3 same"");; 47 ; 48 gPad->BuildLegend(0.78,0.695,0.980,0.935,"""",""f"");; 49}; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; kYellow@ kYellowDefinition Rtypes.h:66; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; gPad#define gPadDefinition TVirtualPad.h:308; TAttAxis::SetNdivisionsvirtual void SetNdivisions(Int_t n=510, Bool_t optim=kTRUE)Set the number of divisions for this axis.Definition TAttAxis.cxx:233; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/candleplot_8C_source.html:92,Load,Loading,92,doc/master/candleplot_8C_source.html,https://root.cern,https://root.cern/doc/master/candleplot_8C_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/candleplotoption.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. candleplotoption.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Example showing how to combine the various candle plot options. . ; void candleplotoption(); {; TCanvas *c1 = new TCanvas(""c1"",""Candle Presets"",800,600);; c1->Divide(3,2);; ; TRandom *rng = new TRandom();; TH2I *h1 = new TH2I(""h1"",""Sin"",18,0,360,300,-1.5,1.5);; h1->GetXaxis()->SetTitle(""Deg"");; float myRand;; for (int i = 0; i < 360; i+=10) {; for (int j = 0; j < 100; j++) {; myRand = rng->Gaus(sin(i*3.14/180),0.2);; h1->Fill(i,myRand);; }; }; for (int i = 1; i < 7; i++) {; c1->cd(i);; char str[16];; sprintf(str,""candlex%d"",i);; TH2I * myhist = (TH2I*)h1->DrawCopy(str);; myhist->SetTitle(str);; }; ; TCanvas *c2 = new TCanvas(""c2"",""Candle Individual"",800,600);; c2->Divide(4,4);; char myopt[16][8] = {""0"",""1"",""11"",""21"",""31"",""30"",""111"",""311"",""301"",""1111"",""2321"",""12111"",""112111"",""212111"",""312111""};; for (int i = 0; i < 15; i++) {; c2->cd(i+1);; char str[16];; sprintf(str, ""candlex(%s)"",myopt[i]);; TH2I * myhist = (TH2I*)h1->DrawCopy(str);; myhist->SetTitle(str);; }; }; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1::SetTitlevoid SetTitle(const char *title) overrideChange/set the title.Definition TH1.cxx:6718; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::DrawCopyvirtual TH1 * DrawCopy(Option_t *option="""", const char *name_postfix=""_copy"") constCopy this histogram and Draw in the current pad.Definition TH1.cxx:3113; TH2I2-D histogram with an int per channel (see TH1 documentation)Definition TH2.h:225; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::Gausvirtual Double_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/candleplotoption_8C.html:101,Load,Loading,101,doc/master/candleplotoption_8C.html,https://root.cern,https://root.cern/doc/master/candleplotoption_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/candleplotstack.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. candleplotstack.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Example showing how a THStack with candle plot option. . ; void candleplotstack(); {; gStyle->SetTimeOffset(0);; auto rng = new TRandom();; auto dateBegin = new TDatime(2010,1,1,0,0,0);; auto dateEnd = new TDatime(2011,1,1,0,0,0);; int bins = 1000;; auto h1 = new TH2I(""h1"",""Machine A"",6,dateBegin->Convert(),dateEnd->Convert(),bins,0,1000);; auto h2 = new TH2I(""h2"",""Machine B"",6,dateBegin->Convert(),dateEnd->Convert(),bins,0,1000);; auto hsum = new TH2I(""h4"",""Sum"",6,dateBegin->Convert(),dateEnd->Convert(),bins,0,1000);; ; float Rand;; for (int i = dateBegin->Convert(); i < dateEnd->Convert(); i+=86400*30) {; for (int j = 0; j < 1000; j++) {; Rand = rng->Gaus(500+sin(i/10000000.)*100,50); h1->Fill(i,Rand); hsum->Fill(i,Rand);; Rand = rng->Gaus(500+sin(i/12000000.)*100,50); h2->Fill(i,Rand); hsum->Fill(i,Rand);; }; }; ; h2->SetLineColor(kRed);; hsum->SetFillColor(kGreen);; TCanvas *c1 = new TCanvas();; ; auto hs = new THStack(""hs"",""Machine A+B"");; hs->Add(h1);; hs->Add(h2,""candle2"");; hs->Add(hsum, ""violin1"");; hs->Draw(""candle3"");; hs->GetXaxis()->SetNdivisions(410);; ; gPad->SetGrid(1,0);; ; hs->GetXaxis()->SetTimeDisplay(1);; hs->GetXaxis()->SetTimeFormat(""%d/%m/%y"");; hs->GetXaxis()->SetNdivisions(-6);; hs->GetXaxis()->SetTitle(""Date [day/month/year]"");; c1->Modified();; ; gPad->BuildLegend(0.75,0.75,0.95,0.95,"""");; }; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; gPad#define gPadDefinition TVirtualPad.h:308; TCanvasThe Canvas class.Definition TCanvas.h:23; TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/candleplotstack_8C.html:100,Load,Loading,100,doc/master/candleplotstack_8C.html,https://root.cern,https://root.cern/doc/master/candleplotstack_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/candleplotwhiskers.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. candleplotwhiskers.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Example of candle plot showing the whiskers definition. . ; Q1 (-25%): -0.675525 Median: 0.00168511 Q3 (+25%): 0.676189; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 11.7941; NDf = 17; Edm = 1.90451e-06; NCalls = 131; Constant = 3728.5 +/- 182.159 ; Mean = -0.110704 +/- 0.0721072 ; Sigma = 0.959495 +/- 0.025154 (limited); ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 8.0469; NDf = 17; Edm = 1.56503e-05; NCalls = 132; Constant = 4071.09 +/- 244.49 ; Mean = -0.0289155 +/- 0.087166 ; Sigma = 1.00961 +/- 0.0288274 (limited); ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 6.93238; NDf = 11; Edm = 3.27894e-08; NCalls = 107; Constant = 3970.02 +/- 25.7596 ; Mean = -0.000189021 +/- 0.0118284 ; Sigma = 1.02465 +/- 0.0335469 (limited); ; void candleplotwhiskers() {; auto c1 = new TCanvas(""c1"",""Candle Presets"",700,800);; c1->Divide(1,2);; ; auto rng = new TRandom();; auto h1 = new TH2I(""h1"",""Gaus"",100,-5,5,1,0,1);; auto h2 = new TH1I(""h2"",""Gaus"",100,-5,5);; ; h1->GetXaxis()->SetTitle(""Standard deviation #sigma"");; h2->GetXaxis()->SetTitle(""Standard deviation #sigma"");; h2->GetYaxis()->SetTitle(""dN/d#sigma"");; ; float myRand;; for (int i = 0; i < 100000; i++) {; myRand = rng->Gaus(0,1);; h1->Fill(myRand,0);; h2->Fill(myRand);; }; ; Double_t *q = new Double_t[3];; Double_t *p = new Double_t[3];; q[0] = 0.; q[1] = 0.; q[2] = 0.;; p[0] = 0.25; p[1] = 0.5; p[2] = 0.75;; ; h2->GetQuantiles(3,q,p);; cout << ""Q1 (-25%): "" << q[0] << "" Median: "" << q[1] << "" Q3 (+25%): "" << q[2] << endl;; double iqr = q[2]-q[0];; auto mygaus_1_middle = new TF1(""mygaus_1_middle"",""gaus"",q[0],q[2]);; auto mygaus_1_left = new TF1(""mygaus_1_left"",""gaus"",q[0]-1.5*iqr,q[0]);; mygaus",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/candleplotwhiskers_8C.html:103,Load,Loading,103,doc/master/candleplotwhiskers_8C.html,https://root.cern,https://root.cern/doc/master/candleplotwhiskers_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/candlescaled.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. candlescaled.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Candle Scaled, illustrates what scaling does on candle and violin charts. ; Please try to modify the static functions SetScaledCandle and SetScaledViolin. ; void candlescaled(); {; TCanvas *c1 = new TCanvas(""c1"",""TCandle Scaled"",800,600);; c1->Divide(2,2);; TH2I *h1 = new TH2I(""h1"",""GausXY"",20,-5,5,100,-5,5);; TH2I *h3 = new TH2I(""h3"",""GausXY"",100,-5,5,20,-5,5);; ; for (int j = 0; j < 100000; j++) {; auto myRand1 = gRandom->Gaus(0,1);; auto myRand2 = gRandom->Gaus(0,1);; h1->Fill(myRand1, myRand2);; h3->Fill(myRand1, myRand2);; }; ; c1->cd(1);; ; TCandle::SetScaledCandle(true); /* This is a global option for all existing candles, default is false */; ; h1->SetTitle(""CandleX scaled"");; h1->DrawCopy(""candleX2"");; c1->cd(2);; ; h3->SetTitle(""CandleY scaled"");; h3->DrawCopy(""candleY2"");; ; TCandle::SetScaledViolin(false); /* This is a global option for all existing violin, default is true */; TH2I *h2 = (TH2I*)h1->Clone();; h2->SetFillStyle(0);; h2->SetFillColor(kGray+2);; h2->SetLineColor(kBlue);; TH2I *h4 = (TH2I*)h3->Clone();; h4->SetFillStyle(0);; h4->SetFillColor(kGray+2);; h4->SetLineColor(kBlue);; ; c1->cd(3);; h2->SetTitle(""ViolinX unscaled"");; h2->DrawCopy(""ViolinX"");; c1->cd(4);; h4->SetTitle(""ViolinY unscaled"");; h4->DrawCopy(""ViolinY"");; }; kGray@ kGrayDefinition Rtypes.h:65; kBlue@ kBlueDefinition Rtypes.h:66; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCandle::SetScaledViolinstatic void SetScaledVi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/candlescaled_8C.html:97,Load,Loading,97,doc/master/candlescaled_8C.html,https://root.cern,https://root.cern/doc/master/candlescaled_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/cumulative.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. cumulative.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Illustrate use of the TH1::GetCumulative method. . ; #include <cassert>; #include <cmath>; ; #include ""TH1.h""; #include ""TH1D.h""; #include ""TCanvas.h""; #include ""TRandom.h""; ; TCanvas *cumulative(); {; TH1* h = new TH1D(""h"", ""h"", 100, -5., 5.);; gRandom->SetSeed();; h->FillRandom(""gaus"", 1u << 16);; // get the cumulative of h; TH1* hc = h->GetCumulative();; // check that c has the ""right"" contents; Double_t* integral = h->GetIntegral();; for (Int_t i = 1; i <= hc->GetNbinsX(); ++i) {; assert(std::abs(integral[i] * h->GetEntries() - hc->GetBinContent(i)) < 1e-7);; }; // draw histogram together with its cumulative distribution; TCanvas* c = new TCanvas;; c->Divide(1,2);; c->cd(1);; h->Draw();; c->cd(2);; hc->Draw();; c->Update();; ; return c;; }; c#define c(i)Definition RSha256.hxx:101; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; TCanvas.h; TH1D.h; TH1.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetCumulativeTH1 * GetCumulative(Bool_t forward=kTRUE, const char *suffix=""_cumulative"") constReturn a pointer to a histogram containing the cumulative content.Definition TH1.cxx:2616; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::GetIntegralvirtual Double_t * GetIntegral()Return a pointer to the array of bins integral.Definition TH1.cxx:2586; TH1::GetBinContent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/cumulative_8C.html:95,Load,Loading,95,doc/master/cumulative_8C.html,https://root.cern,https://root.cern/doc/master/cumulative_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/draw2dopt.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. draw2dopt.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Display the various 2-d drawing options . ; void draw2dopt(); {; gStyle->SetOptStat(0);; gStyle->SetCanvasColor(33);; gStyle->SetFrameFillColor(18);; TF2 *f2 = new TF2(""f2"",""xygaus + xygaus(5) + xylandau(10)"",-4,4,-4,4);; Double_t params[] = {130,-1.4,1.8,1.5,1, 150,2,0.5,-2,0.5, 3600,-2,0.7,-3,0.3};; f2->SetParameters(params);; auto h2 = new TH2F(""h2"",""xygaus + xygaus(5) + xylandau(10)"",20,-4,4,20,-4,4);; h2->SetFillColor(46);; h2->FillRandom(""f2"",40000);; TPaveLabel pl;; ; //basic 2-d options; Float_t xMin=0.67, yMin=0.875, xMax=0.85, yMax=0.95;; Int_t cancolor = 17;; auto c2h = new TCanvas(""c2h"",""2-d options"",10,10,800,600);; c2h->Divide(2,2);; c2h->SetFillColor(cancolor);; c2h->cd(1);; h2->Draw(); pl.DrawPaveLabel(xMin,yMin,xMax,yMax,""SCAT"",""brNDC"");; c2h->cd(2);; h2->Draw(""box""); pl.DrawPaveLabel(xMin,yMin,xMax,yMax,""BOX"",""brNDC"");; c2h->cd(3);; h2->Draw(""arr""); pl.DrawPaveLabel(xMin,yMin,xMax,yMax,""ARR"",""brNDC"");; c2h->cd(4);; h2->Draw(""colz""); pl.DrawPaveLabel(xMin,yMin,xMax,yMax,""COLZ"",""brNDC"");; c2h->Update();; ; //text option; auto ctext = new TCanvas(""ctext"",""text option"",50,50,800,600);; gPad->SetGrid();; ctext->SetFillColor(cancolor);; ctext->SetGrid();; h2->Draw(""text""); pl.DrawPaveLabel(xMin,yMin,xMax,yMax,""TEXT"",""brNDC"");; ctext->Update();; ; //contour options; auto cont = new TCanvas(""contours"",""contours"",100,100,800,600);; cont->Divide(2,2);; gPad->SetGrid();; cont->SetFillColor(cancolor);; cont->cd(1);; h2->Draw(""contz""); pl.DrawPaveLabel(xMin,yMin,xMax,yMax,""CONTZ"",""brNDC"");; cont->cd(2);; gPad->SetGrid();; h2->Draw(""cont1""); pl.DrawPaveLabel(xMin,yMin,xMax,yMax,""CONT1"",""brNDC"");; cont->cd(3);; gPad->SetGrid();; h2->Draw(""cont2""); pl.DrawPaveLabel(xMin,yMin,xMax,yMax,""CONT2"",""brNDC"");; cont->cd(4);; gPad->SetGrid();; h2->Draw(""cont3""); p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/draw2dopt_8C.html:94,Load,Loading,94,doc/master/draw2dopt_8C.html,https://root.cern,https://root.cern/doc/master/draw2dopt_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/exec1.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. exec1.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Echo object at mouse position. ; Example of macro called when a pad is redrawn one must create a TExec object in the following way gPad->AddExec(""ex1"", "".x exec1.C"");; gPad#define gPadDefinition TVirtualPad.h:308; this macro prints the bin number and the bin content when one clicks on the histogram contour of any histogram in a pad; ; ; void exec1(); {; if (!gPad) {; Error(""exec1"", ""gPad is null, you are not supposed to run this macro"");; return;; }; ; Int_t event = gPad->GetEvent();; int px = gPad->GetEventX();; TObject *select = gPad->GetSelected();; ; if (select && select->InheritsFrom(TH1::Class())) {; TH1 *h = (TH1*)select;; Float_t xx = gPad->AbsPixeltoX(px);; Float_t x = gPad->PadtoX(xx);; Int_t binx = h->GetXaxis()->FindBin(x);; printf(""event=%d, hist:%s, bin=%d, content=%f\n"", event, h->GetName(), binx, h->GetBinContent(binx));; }; }; ; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TAxis::FindBinvirtual Int_t FindBin(Double_t x)Find bin number corresponding to abscissa x.Definition TAxis.cxx:293; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::Classstatic TClass * Class(); TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; xDouble_t x[n]Definition legend1.C:17; AuthorsRene Brun, Sergey Linev ; Definition in file exec1.C. tutorialshistexec1.C. ROOT master - Reference Guide Generated on Tue N",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/exec1_8C.html:90,Load,Loading,90,doc/master/exec1_8C.html,https://root.cern,https://root.cern/doc/master/exec1_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/exec2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. exec2.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Echo object at mouse position and show a graphics line. ; Example of macro called when a mouse event occurs in a pad.; Example: TFile::Open(""hsimple.root"");; hpxpy->Draw(""colz"");; gPad->AddExec(""ex2"", "".x exec2.C"");; gPad#define gPadDefinition TVirtualPad.h:308; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; When moving the mouse in the canvas, a second canvas shows the projection along X of the bin corresponding to the Y position of the mouse. The resulting histogram is fitted with a gaussian. A ""dynamic"" line shows the current bin position in Y. This more elaborated example can be used as a starting point to develop more powerful interactive applications exploiting CLING as a development engine.; ; void exec2(); {; if (!gPad) {; Error(""exec2"", ""gPad is null, you are not supposed to run this macro"");; return;; }; ; int px = gPad->GetEventX();; int py = gPad->GetEventY();; float uxmin = gPad->GetUxmin();; float uxmax = gPad->GetUxmax();; int pxmin = gPad->XtoAbsPixel(uxmin);; int pxmax = gPad->XtoAbsPixel(uxmax);; TObject *select = gPad->GetSelected();; TCanvas *c2 = (TCanvas*)gROOT->GetListOfCanvases()->FindObject(""c2"");; ; gPad->GetCanvas()->FeedbackMode(kTRUE);; ; int pyold = gPad->GetUniqueID(); // misuse of pad unique for last draw position; ; if (pyold && c2) {; // erase line at old position; gVirtualX->DrawLine(pxmin, pyold, pxmax, pyold);; gPad->SetUniqueID(0);; }; ; TH2 *h = dynamic_cast<TH2 *>(select);; if(!h) return;; ; //erase old position and draw a line at current position; gVirtualX->DrawLine(pxmin, py, pxmax, py);; gPad->SetUniqueID(py);; ; Float_t upy = gPad->AbsPixelt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/exec2_8C.html:90,Load,Loading,90,doc/master/exec2_8C.html,https://root.cern,https://root.cern/doc/master/exec2_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/fillhistosauto2p.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. fillhistosauto2p.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Fill multiple histograms with different functions and automatic binning. ; Illustrates merging with the power-of-two autobin algorithm; ; OBJ: TStatistic min Mean = -0.219 +- 0.09858 RMS = 0.31172 Count = 10 Min = -0.7688 Max = 0.187; OBJ: TStatistic max Mean = 6.2275 +- 0.1806 RMS = 0.57103 Count = 10 Min = 5.5275 Max = 7.3222; OBJ: TStatistic dif Mean = 6.4465 +- 0.2203 RMS = 0.69652 Count = 10 Min = 5.3405 Max = 7.6243; OBJ: TStatistic mean Mean = 3.0008 +- 0.005044 RMS = 0.01595 Count = 10 Min = 2.9789 Max = 3.0264; OBJ: TStatistic rms Mean = 1.005 +- 0.01028 RMS = 0.032511 Count = 10 Min = 0.95837 Max = 1.0666; ent: 10010; TH1.Print Name = myh0, Entries= 10010, Total sum= 10004; TH1.Print Name = myhref, Entries= 10010, Total sum= 10010; ; #include ""TF1.h""; #include ""TH1D.h""; #include ""TMath.h""; #include ""TF1.h""; #include ""TCanvas.h""; #include ""TRandom3.h""; #include ""TStatistic.h""; #include ""TFile.h""; #include ""TStyle.h""; ; TF1 *gam = new TF1(""gam"", ""1/(1+0.1*x*0.1*x)"", -100., 100.);; TF1 *gam1 = new TF1(""gam"", ""1/(1+0.1*x*0.1*x)"", -1., .25);; TF1 *iga = new TF1(""inv gam"", ""1.-1/(1+0.1*x*0.1*x)"", -100., 100.);; TF1 *iga1 = new TF1(""inv gam"", ""1.-1/(1+0.1*x*0.1*x)"", -.5, 1.);; ; void fillhistosauto2p(unsigned opt = 1, unsigned n = 1001); {; ; UInt_t nh = 10;; UInt_t bsize = 1000;; ; TRandom3 rndm((Long64_t)time(0));; ; // Standard autobinning reference; auto href = new TH1D(""myhref"", ""current"", 50, 0., -1.);; href->SetBuffer(bsize);; ; // New autobinning 1-histo reference; auto href2 = new TH1D(""myhref"", ""Auto P2, sequential"", 50, 0., -1.);; href2->SetBit(TH1::kAutoBinPTwo);; href2->SetBuffer(bsize);; ; TList *hlist = new TList;; ; Int_t nbins = 50;; ; TStatistic x(""min""), y(""max""), d(""dif""), a(""mean""), r(""rms"");; for (UInt_t j = 0; j < nh;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/fillhistosauto2p_8C.html:101,Load,Loading,101,doc/master/fillhistosauto2p_8C.html,https://root.cern,https://root.cern/doc/master/fillhistosauto2p_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/fillrandom.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. fillrandom.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Fill a 1-D histogram from a parametric function. . ; void fillrandom(int plot=1) {; gBenchmark->Start(""fillrandom"");; ; // A function (any dimension) or a formula may reference; // an already defined formula; auto form1 = new TFormula(""form1"",""abs(sin(x)/x)"");; auto sqroot = new TF1(""sqroot"",""x*gaus(0) + [3]*form1"",0,10);; sqroot->SetLineColor(4);; sqroot->SetLineWidth(6);; sqroot->SetParameters(10,4,1,20);; ; // Create a one dimensional histogram (one float per bin); // and fill it following the distribution in function sqroot.; auto h1f = new TH1F(""h1f"",""Test random numbers"",200,0,10);; h1f->FillRandom(""sqroot"",10000);; ; // Open a ROOT file and save the formula, function and histogram; TFile myfile(""fillrandom.root"",""RECREATE"");; form1->Write();; sqroot->Write();; h1f->Write();; ; // Produce a plot if requested; if (plot) {; TCanvas *c1 = new TCanvas(""c1"",""The FillRandom example"",200,10,700,900);; ; auto pad1 = new TPad(""pad1"",""The pad with the function"",0.05,0.50,0.95,0.95);; auto pad2 = new TPad(""pad2"",""The pad with the histogram"",0.05,0.05,0.95,0.45);; pad1->Draw();; pad2->Draw();; pad1->cd();; ; pad1->SetGridx();; pad1->SetGridy();; pad1->GetFrame()->SetBorderMode(-1);; pad1->GetFrame()->SetBorderSize(5);; ; sqroot->Draw();; auto lfunction = new TPaveLabel(5,39,9.8,46,""The sqroot function"");; lfunction->Draw();; c1->Update();; ; pad2->cd();; pad2->GetFrame()->SetBorderMode(-1);; pad2->GetFrame()->SetBorderSize(5);; ; h1f->SetFillColor(45);; h1f->Draw();; c1->Update();; }; ; gBenchmark->Show(""fillrandom"");; }; gBenchmarkR__EXTERN TBenchmark * gBenchmarkDefinition TBenchmark.h:59; plotwinID h TVirtualViewer3D TVirtualGLPainter char TVirtualGLPainter plotDefinition TGWin32VirtualGLProxy.cxx:53; TBenchmark::Startvirtual void Start(const char *name)Star",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/fillrandom_8C.html:95,Load,Loading,95,doc/master/fillrandom_8C.html,https://root.cern,https://root.cern/doc/master/fillrandom_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/fillrandom.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; fillrandom.py File ReferenceTutorials » Histograms tutorials. Detailed Description; Fill a 1-D histogram from a parametric function. ; Original tutorial by Rene Brun. ; import ROOT; ; c1 = ROOT.TCanvas(""c1"",""The FillRandom example"",200,10,700,900); pad1 = ROOT.TPad(""pad1"",""The pad with the function"",0.05,0.50,0.95,0.95); pad2 = ROOT.TPad(""pad2"",""The pad with the histogram"",0.05,0.05,0.95,0.45); pad1.Draw(); pad2.Draw(); pad1.cd(); ROOT.gBenchmark.Start(""fillrandom""); ; form1 = ROOT.TFormula(""form1"",""abs(sin(x)/x)""); sqroot = ROOT.TF1(""sqroot"",""x*gaus(0) + [3]*form1"",0,10); sqroot.SetParameters(10,4,1,20); pad1.SetGridx(); pad1.SetGridy(); pad1.GetFrame().SetBorderMode(-1); pad1.GetFrame().SetBorderSize(5); sqroot.SetLineColor(4); sqroot.SetLineWidth(6); sqroot.Draw(); lfunction = ROOT.TPaveLabel(5,39,9.8,46,""The sqroot function""); lfunction.Draw(); c1.Update(); ; pad2.cd(); pad2.GetFrame().SetBorderMode(-1); pad2.GetFrame().SetBorderSize(5); h1f = ROOT.TH1F(""h1f"",""Test random numbers"",200,0,10); h1f.SetFillColor(45); h1f.FillRandom(""sqroot"",10000); h1f.Draw(); c1.Update(); ; f = ROOT.TFile(""fillrandom-py.root"",""RECREATE""); form1.Write(); sqroot.Write(); h1f.Write(); ROOT.gBenchmark.Show(""fillrandom""); SetBorderSizec SetBorderSize(2); AuthorAlberto Ferro ; Definition in file fillrandom.py. tutorialshistfillrandom.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/fillrandom_8py.html:96,Load,Loading,96,doc/master/fillrandom_8py.html,https://root.cern,https://root.cern/doc/master/fillrandom_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/h1ReadAndDraw.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. h1ReadAndDraw.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Read a 1-D histogram from a ROOT File and draw it. ; We attach (or generate) the ROOT file in $ROOTSYS/tutorials/hsimple.root or $PWD/hsimple.root We draw one histogram in different formats. ; #include ""TInterpreter.h""; #include ""TCanvas.h""; #include ""TSystem.h""; #include ""TFile.h""; #include ""TH2.h""; #include ""TNtuple.h""; #include ""TPaveLabel.h""; #include ""TPaveText.h""; #include ""TFrame.h""; #include ""TSystem.h""; #include ""TInterpreter.h""; ; void h1ReadAndDraw(); {; // Fetch and open the hsimple.root File; TFile *example = TFile::Open(gROOT->GetTutorialDir() + ""/hsimple.root"");; ; example->ls(); // Show the file contents; // Get the histogram from the ROOT File; TH1 *hpx = nullptr; // pointer to base class TH1 is enough; example->GetObject(""hpx"", hpx);; ; TCanvas *c1 = new TCanvas(""c1"",""Histogram Drawing Options"",200,10,700,900);; TPad *pad1 = new TPad(""pad1"",; ""The pad with the function"",0.03,0.62,0.50,0.92);; TPad *pad2 = new TPad(""pad2"",; ""The pad with the histogram"",0.51,0.62,0.98,0.92);; TPad *pad3 = new TPad(""pad3"",; ""The pad with the histogram"",0.03,0.02,0.97,0.57);; pad1->Draw();; pad2->Draw();; pad3->Draw();; ; // Draw a global picture title; TPaveLabel *title = new TPaveLabel(0.1,0.94,0.9,0.98,; ""Drawing options for one dimensional histograms"");; title->SetTextFont(52);; title->Draw();; ; // Draw histogram hpx in first pad with the default option.; pad1->cd();; pad1->GetFrame()->SetFillColor(18);; hpx->SetFillColor(45);; hpx->DrawCopy();; TPaveLabel *label1 = new TPaveLabel(-3.5,700,-1,800,""Default option"");; label1->Draw();; ; // Draw hpx as a lego. Clicking on the lego area will show; // a ""transparent cube"" to guide you rotating the lego in real time.; pad2->cd();; hpx->DrawCopy(""lego1"");; TPaveLabel *label2 = new TPaveLabel(-0.72,0.74,-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1ReadAndDraw_8C.html:98,Load,Loading,98,doc/master/h1ReadAndDraw_8C.html,https://root.cern,https://root.cern/doc/master/h1ReadAndDraw_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/h2_cut.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. h2_cut.C File ReferenceTutorials » Histograms tutorials. Detailed Description; This example demonstrates how to display a 2D histogram and use TCutG object to select bins for drawing. ; Moving TCutG object one can change displayed region of histogram. ; void h2_cut(); {; const int n = 6;; Float_t x[6] = { 1, 2, 1, -1, -2, -1 };; Float_t y[6] = { 2, 0, -2, -2, 0, 2 };; TCutG *cut = new TCutG(""cut"", 6, x, y);; TH2F *hist = new TH2F(""hist"", ""Histogram with cut"", 40, -10., 10., 40, -10., 10.);; for (int i = 0; i < 100000; i++); hist->Fill(gRandom->Gaus(0., 3.), gRandom->Gaus(0., 3.));; TCanvas *c1 = new TCanvas(""c1"", ""Histogram draw with TCutG"", 600, 900);; hist->Draw(""col [cut]"");; cut->Draw(""l"");; }; Float_tfloat Float_tDefinition RtypesCore.h:57; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TCanvasThe Canvas class.Definition TCanvas.h:23; TCutGGraphical cut class.Definition TCutG.h:20; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH2::FillInt_t Fill(Double_t) overrideInvalid Fill method.Definition TH2.cxx:393; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; AuthorSergey Linev ; Definition in file h2_cut.C. tutorialshisth2_cut.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h2__cut_8C.html:91,Load,Loading,91,doc/master/h2__cut_8C.html,https://root.cern,https://root.cern/doc/master/h2__cut_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/h2proj.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. h2proj.C File ReferenceTutorials » Histograms tutorials. Detailed Description; This example demonstrates how to display a histogram and its two projections. ; A TExec allows to redraw automatically the projections when a zoom is performed on the 2D histogram. ; TH2F *h2;; TH1D * projh2X;; TH1D * projh2Y;; TPad *right_pad, *top_pad;; ; void h2proj(); {; auto c1 = new TCanvas(""c1"", ""c1"",900,900);; gStyle->SetOptStat(0);; ; TPad *center_pad = new TPad(""center_pad"", ""center_pad"",0.0,0.0,0.6,0.6);; center_pad->Draw();; ; right_pad = new TPad(""right_pad"", ""right_pad"",0.55,0.0,1.0,0.6);; right_pad->Draw();; ; top_pad = new TPad(""top_pad"", ""top_pad"",0.0,0.55,0.6,1.0);; top_pad->Draw();; ; h2 = new TH2F(""h2"","""",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; h2->Fill(px,5*py);; }; projh2X = h2->ProjectionX();; projh2Y = h2->ProjectionY();; ; center_pad->cd();; gStyle->SetPalette(1);; h2->Draw(""COL"");; ; top_pad->cd();; projh2X->SetFillColor(kBlue+1);; projh2X->Draw(""bar"");; ; right_pad->cd();; projh2Y->SetFillColor(kBlue-2);; projh2Y->Draw(""hbar"");; ; c1->cd();; TLatex t;; t.SetTextFont(42);; t.SetTextSize(0.02);; t.DrawLatex(0.6,0.88,""This example demonstrates how to display"");; t.DrawLatex(0.6,0.85,""a histogram and its two projections."");; ; auto ex = new TExec(""zoom"",""ZoomExec()"");; h2->GetListOfFunctions()->Add(ex);; }; ; void ZoomExec(); {; int xfirst = h2->GetXaxis()->GetFirst();; int xlast = h2->GetXaxis()->GetLast();; double xmin = h2->GetXaxis()->GetBinLowEdge(xfirst);; double xmax = h2->GetXaxis()->GetBinUpEdge(xlast);; projh2X->GetXaxis()->SetRangeUser(xmin, xmax);; top_pad->Modified();; ; int yfirst = h2->GetYaxis()->GetFirst();; int ylast = h2->GetYaxis()->GetLast();; double ymin = h2->GetYaxis()->GetBinLowEdge(yfirst);; double ymax = h2->GetYaxis()->GetBinUpEdge(ylast);; projh2Y->GetX",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h2proj_8C.html:91,Load,Loading,91,doc/master/h2proj_8C.html,https://root.cern,https://root.cern/doc/master/h2proj_8C.html,2,"['Load', 'perform']","['Loading', 'performed']"
Performance,". ROOT: tutorials/hist/hbars.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. hbars.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Example of bar charts with 1-d histograms. . ; TCanvas *hbars(); {; // Try to open first the file cernstaff.root in tutorials/tree directory; TString filedir = gROOT->GetTutorialDir();; filedir += TString(""/tree/"");; TString filename = ""cernstaff.root"";; bool fileNotFound = gSystem->AccessPathName(filename); // note opposite return code; ; // If file is not found try to generate it using the macro tree/cernbuild.C; if (fileNotFound) {; TString macroName = filedir + ""cernbuild.C"";; if (!gInterpreter->IsLoaded(macroName)) gInterpreter->LoadMacro(macroName);; gROOT->ProcessLineFast(""cernbuild()"");; }; TFile * f = TFile::Open(filename);; if (!f) {; Error(""hbars"", ""file cernstaff.root not found"");; return nullptr;; }; TTree *T = (TTree*)f->Get(""T"");; if (!T) {; Error(""hbars"", ""Tree T is not present in file %s"", f->GetName());; return nullptr;; }; T->SetFillColor(45);; TCanvas *c1 = new TCanvas(""c1"",""histograms with bars"",700,800);; c1->SetFillColor(42);; c1->Divide(1,2);; ; // Horizontal bar chart; c1->cd(1);; gPad->SetGrid();; gPad->SetLogx();; gPad->SetFrameFillColor(33);; T->Draw(""Nation"","""",""hbar2"");; ; // Vertical bar chart; c1->cd(2);; gPad->SetGrid();; gPad->SetFrameFillColor(33);; T->Draw(""Division>>hDiv"","""",""goff"");; TH1F *hDiv = (TH1F*)gDirectory->Get(""hDiv"");; hDiv->SetStats(0);; TH1F *hDivFR = (TH1F*)hDiv->Clone(""hDivFR"");; T->Draw(""Division>>hDivFR"",""Nation==\""FR\"""",""goff"");; hDiv->SetBarWidth(0.45);; hDiv->SetBarOffset(0.1);; hDiv->SetFillColor(49);; TH1 *h1 = hDiv->DrawCopy(""bar2"");; hDivFR->SetBarWidth(0.4);; hDivFR->SetBarOffset(0.55);; hDivFR->SetFillColor(50);; TH1 *h2 = hDivFR->DrawCopy(""bar2,same"");; ; TLegend *legend = new TLegend(0.55,0.65,0.76,0.82);; legend->AddEntry(h1,""All nations"",""f"");; legend->AddEntry(h2,""French only"",""f"");; legend->Draw()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hbars_8C.html:90,Load,Loading,90,doc/master/hbars_8C.html,https://root.cern,https://root.cern/doc/master/hbars_8C.html,2,['Load'],"['LoadMacro', 'Loading']"
Performance,". ROOT: tutorials/hist/histpalettecolor.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. histpalettecolor.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Palette coloring for histogram is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; When one of these options is given to TH1::Draw the histogram get its color from the current color palette defined by gStyle->SetPalette(...). The color is determined according to the number of objects having palette coloring in the current pad.; In this example five histograms are displayed with palette coloring for lines and and marker. The histograms are drawn with markers and error bars and one can see the color of each histogram is picked inside the default palette kBird. ; void histpalettecolor(); {; auto C = new TCanvas();; ; gStyle->SetOptTitle(kFALSE);; gStyle->SetOptStat(0);; ; auto h1 = new TH1F(""h1"",""Histogram drawn with full circles"",100,-4,4);; auto h2 = new TH1F(""h2"",""Histogram drawn with full squares"",100,-4,4);; auto h3 = new TH1F(""h3"",""Histogram drawn with full triangles up"",100,-4,4);; auto h4 = new TH1F(""h4"",""Histogram drawn with full triangles down"",100,-4,4);; auto h5 = new TH1F(""h5"",""Histogram drawn with empty circles"",100,-4,4);; ; TRandom3 rng;; Double_t px,py;; for (Int_t i = 0; i < 25000; i++) {; rng.Rannor(px,py);; h1->Fill(px,10.);; h2->Fill(px, 8.);; h3->Fill(px, 6.);; h4->Fill(px, 4.);; h5->Fill(px, 2.);; }; ; h1->SetMarkerStyle(kFullCircle);; h2->SetMarkerStyle(kFullSquare);; h3->SetMarkerStyle(kFullTriangleUp);; h4->SetMarkerStyle(kFullTriangleDown);; h5->SetMarkerStyle(kOpenCircle);; ; h1->Draw(""PLC PMC"");; h2->Draw(""SAME PLC PMC"");; h3->Draw(""SAME PLC PMC"");; h4->Draw(""SAME PLC PMC"");; h5->Draw(""SAME PLC PMC"");; ; gPad->BuildLegend();; }; Int_tint Int_tDefinition RtypesCore.h:45; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/histpalettecolor_8C.html:101,Load,Loading,101,doc/master/histpalettecolor_8C.html,https://root.cern,https://root.cern/doc/master/histpalettecolor_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/hksimple.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. hksimple.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Illustrates the advantages of a TH1K histogram . ; void canvasRefresh(TCanvas *c1); {; for (Int_t j = 0; j < 3; j++); c1->GetPad(j+1)->Modified();; ; c1->Modified();; c1->Update();; ; gSystem->ProcessEvents();; }; ; void hksimple(); {; // Create a new canvas.; TCanvas* c1 = new TCanvas(""c1"",""Dynamic Filling Example"",200,10,600,900);; ; // Create a normal histogram and two TH1K histograms; TH1 *hpx[3];; hpx[0] = new TH1F(""hp0"",""Normal histogram"",1000,-4,4);; hpx[1] = new TH1K(""hk1"",""Nearest Neighbour of order 3"",1000,-4,4);; hpx[2] = new TH1K(""hk2"",""Nearest Neighbour of order 16"",1000,-4,4,16);; c1->Divide(1,3);; for (Int_t j = 0; j < 3; j++) {; c1->cd(j + 1);; hpx[j]->SetFillColor(48);; hpx[j]->Draw();; }; ; // Fill histograms randomly; gRandom->SetSeed(12345);; Float_t px, py, pz;; const Int_t kUPDATE = 10;; for (Int_t i = 0; i <= 300; i++) {; gRandom->Rannor(px,py);; for (Int_t j = 0; j < 3; j++); hpx[j]->Fill(px);; if (i && (i % kUPDATE) == 0); canvasRefresh(c1);; }; ; for (Int_t j = 0; j < 3; j++); hpx[j]->Fit(""gaus"");; ; canvasRefresh(c1);; }; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; kUPDATE@ kUPDATEDefinition TFitParametersDialog.cxx:46; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1KTH1K class supports the nearest K Neighbours method, widely used in cluster analysis.Definition TH1K.h:26; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::Drawvoid Draw(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hksimple_8C.html:93,Load,Loading,93,doc/master/hksimple_8C.html,https://root.cern,https://root.cern/doc/master/hksimple_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/hlHisto1.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. hlHisto1.C File ReferenceTutorials » Histograms tutorials. Detailed Description; This tutorial demonstrates how the highlight mechanism can be used on an histogram. ; A 2D histogram is booked an filled with a random gaussian distribution. Then an highlight method is connected to the histogram. Moving the mouse on the histogram will update the histogram title in real time according to the highlighted bin.; ; TText *info = nullptr;; ; void HighlightTitle(TVirtualPad *pad, TObject *obj, Int_t xhb, Int_t yhb); {; auto h2 = dynamic_cast<TH2F*>(obj);; if (!h2) return;; if (!h2->IsHighlight()) { // after highlight disabled; h2->SetTitle(""Disable highlight"");; return;; }; if (info) info->SetTitle("""");; TString t;; t.Form(""bin[%02d, %02d] (%5.2f, %5.2f) content %g"", xhb, yhb,; h2->GetXaxis()->GetBinCenter(xhb), h2->GetYaxis()->GetBinCenter(yhb),; h2->GetBinContent(xhb, yhb));; h2->SetTitle(t.Data());; pad->Update();; }; ; void hlHisto1(); {; auto c1 = new TCanvas();; c1->HighlightConnect(""HighlightTitle(TVirtualPad*,TObject*,Int_t,Int_t)"");; ; auto h2 = new TH2F(""h2"", """", 50, -5.0, 5.0, 50, -5.0, 5.0);; for (Int_t i = 0; i < 10000; i++) h2->Fill(gRandom->Gaus(), gRandom->Gaus());; h2->Draw();; ; info = new TText(0.0, -4.0, ""please move the mouse over the frame"");; info->SetTextAlign(22);; info->SetTextColor(kRed+1);; info->SetBit(kCannotPick);; info->Draw();; c1->Update();; ; // call after update to apply changes in the histogram painter; h2->SetHighlight();; }; Int_tint Int_tDefinition RtypesCore.h:45; kRed@ kRedDefinition Rtypes.h:66; kCannotPick@ kCannotPickDefinition TObject.h:372; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hlHisto1_8C.html:93,Load,Loading,93,doc/master/hlHisto1_8C.html,https://root.cern,https://root.cern/doc/master/hlHisto1_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/hlHisto2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. hlHisto2.C File ReferenceTutorials » Histograms tutorials. Detailed Description; This tutorial demonstrates how the highlight mechanism can be used on an histogram. ; A 2D histogram is booked an filled with a random gaussian distribution and drawn with the ""col"" option. Then an highlight method is connected to the histogram. Moving the mouse on the histogram open a new canvas displaying the two X and Y projections at the highlighted bin.; ; TText *info = nullptr;; ; void Highlight2(TVirtualPad *pad, TObject *obj, Int_t xhb, Int_t yhb); {; auto h2 = dynamic_cast<TH2F *>(obj);; if(!h2) return;; auto CanvasProj = (TCanvas *) gROOT->GetListOfCanvases()->FindObject(""CanvasProj"");; if (!h2->IsHighlight()) { // after highlight disabled; if (CanvasProj) delete CanvasProj;; h2->SetTitle(""Disable highlight"");; return;; }; ; if (info) info->SetTitle("""");; ; auto px = h2->ProjectionX(""_px"", yhb, yhb);; auto py = h2->ProjectionY(""_py"", xhb, xhb);; px->SetTitle(TString::Format(""ProjectionX of biny[%02d]"", yhb));; py->SetTitle(TString::Format(""ProjectionY of binx[%02d]"", xhb));; ; if (!CanvasProj) {; CanvasProj = new TCanvas(""CanvasProj"", ""CanvasProj"", 505, 0, 600, 600);; CanvasProj->Divide(1, 2);; CanvasProj->cd(1);; px->Draw();; CanvasProj->cd(2);; py->Draw();; }; ; h2->SetTitle(TString::Format(""Highlight bin [%02d, %02d]"", xhb, yhb).Data());; pad->Modified();; pad->Update();; ; CanvasProj->GetPad(1)->Modified();; CanvasProj->GetPad(2)->Modified();; CanvasProj->Update();; }; ; void hlHisto2(); {; auto c1 = new TCanvas(""Canvas"", ""Canvas"", 0, 0, 500, 500);; c1->HighlightConnect(""Highlight2(TVirtualPad*,TObject*,Int_t,Int_t)"");; ; auto h2 = new TH2F(""h2"", """", 50, -5.0, 5.0, 50, -5.0, 5.0);; for (Int_t i = 0; i < 10000; i++) h2->Fill(gRandom->Gaus(), gRandom->Gaus());; h2->Draw(""col"");; ; info = new TText(0.0, -4.0, ""please move the mouse over the frame"")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hlHisto2_8C.html:93,Load,Loading,93,doc/master/hlHisto2_8C.html,https://root.cern,https://root.cern/doc/master/hlHisto2_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/hlHisto3.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. hlHisto3.C File ReferenceTutorials » Histograms tutorials. Detailed Description; This tutorial demonstrates how the highlight mechanism can be used on a ntuple. ; The ntuple in hsimple.root is drawn with three different selections. Moving the mouse over the two 1D representation display the on 2D plot the events contributing to the highlighted bin.; ; TList *list1 = nullptr, *list2 = nullptr;; ; TList *InitGraphs(TNtuple *nt, TH1F *histo, Bool_t is_top); {; Long64_t nev = nt->GetSelectedRows();; Double_t *px = nt->GetV1();; Double_t *py = nt->GetV2();; Double_t *pz = nt->GetV3();; ; auto list = new TList();; ; Int_t nbins = histo->GetNbinsX();; for (Int_t bin = 0; bin < nbins; bin++) {; auto g = new TGraph();; g->SetName(TString::Format(""g%sbin_%d"", histo->GetName(), bin+1));; g->SetBit(kCannotPick);; g->SetMarkerStyle(25);; g->SetMarkerColor(histo->GetLineColor());; list->Add(g);; }; ; for (Long64_t ie = 0; ie < nev; ie++) {; Double_t value = is_top ? pz[ie] : px[ie]*py[ie]*pz[ie];; Int_t bin = histo->FindBin(value) - 1;; auto g = dynamic_cast<TGraph *>(list->At(bin));; if (g) g->SetPoint(g->GetN(), py[ie], px[ie]);; }; ; return list;; }; ; void Highlight3(TVirtualPad *pad, TObject *obj, Int_t xhb, Int_t yhb); {; auto histo = dynamic_cast<TH1F *>(obj);; if(!histo) return;; ; TCanvas *Canvas2 = (TCanvas *)gROOT->GetListOfCanvases()->FindObject(""Canvas2"");; if (!Canvas2) return;; TGraph *gcommon = (TGraph *)Canvas2->FindObject(""Graph"");; if (!gcommon) return;; ; TList *list = nullptr;; if (!strcmp(histo->GetName(), ""histo1"")); list = list1;; else if (!strcmp(histo->GetName(), ""histo2"")); list = list2;; if (!list) return;; TGraph *g = (TGraph *)list->At(xhb);; if (!g) return;; ; TVirtualPad *savepad = gPad;; Canvas2->cd();; gcommon->Draw(""AP"");; //gcommon->SetTitle(TString::Format(""%d / %d"", g->GetN(), gcommon->GetN()));; if (histo->IsHighl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hlHisto3_8C.html:93,Load,Loading,93,doc/master/hlHisto3_8C.html,https://root.cern,https://root.cern/doc/master/hlHisto3_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/hlHisto4.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. hlHisto4.C File ReferenceTutorials » Histograms tutorials. Detailed Description; This tutorial demonstrates how the highlight mechanism can be used on an histogram. ; A 1D histogram is created. Then an highlight method is connected to the histogram. Moving the mouse on the histogram will open a new canvas showing in real time a zoom around the highlighted bin.; ; TText *info = nullptr;; TH1 *hz = nullptr;; ; void HighlightZoom(TVirtualPad *pad, TObject *obj, Int_t xhb, Int_t yhb); {; auto h = dynamic_cast<TH1F *>(obj);; if(!h) return;; ; auto Canvas2 = (TCanvas *)gROOT->GetListOfCanvases()->FindObject(""Canvas2"");; if (!h->IsHighlight()) { // after highlight disabled; if (Canvas2) delete Canvas2;; if (hz) { delete hz; hz = nullptr; }; return;; }; ; if (info) info->SetTitle("""");; ; if (!Canvas2) {; Canvas2 = new TCanvas(""Canvas2"", ""Canvas2"", 605, 0, 400, 400);; Canvas2->SetGrid();; if (hz) hz->Draw(); // after reopen this canvas; }; if (!hz) {; hz = (TH1 *)h->Clone(""hz"");; hz->SetTitle(TString::Format(""%s (zoomed)"", hz->GetTitle()));; hz->SetStats(kFALSE);; hz->Draw();; Canvas2->Update();; hz->SetHighlight(kFALSE);; }; ; Int_t zf = hz->GetNbinsX()*0.05; // zoom factor; hz->GetXaxis()->SetRange(xhb-zf, xhb+zf);; ; Canvas2->Modified();; Canvas2->Update();; }; ; void hlHisto4(); {; auto Canvas1 = new TCanvas(""Canvas1"", """", 0, 0, 600, 400);; Canvas1->HighlightConnect(""HighlightZoom(TVirtualPad*,TObject*,Int_t,Int_t)"");; ; auto f1 = new TF1(""f1"", ""x*gaus(0) + [3]*abs(sin(x)/x)"", -50.0, 50.0);; f1->SetParameters(20.0, 4.0, 1.0, 20.0);; auto h1 = new TH1F(""h1"", ""Test random numbers"", 200, -50.0, 50.0);; h1->FillRandom(""f1"", 100000);; h1->Draw();; h1->Fit(f1, ""Q"");; gStyle->SetGridColor(kGray);; Canvas1->SetGrid();; ; info = new TText(0.0, h1->GetMaximum()*0.7, ""please move the mouse over the frame"");; info->SetTextSize(0.04);; info->SetTextAlign(2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hlHisto4_8C.html:93,Load,Loading,93,doc/master/hlHisto4_8C.html,https://root.cern,https://root.cern/doc/master/hlHisto4_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/hlabels1.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. hlabels1.C File ReferenceTutorials » Histograms tutorials. Detailed Description; 1-D histograms with alphanumeric labels . ; TCanvas *hlabels1(); {; const Int_t nx = 20;; const char *people[nx] = {""Jean"",""Pierre"",""Marie"",""Odile"",""Sebastien"",; ""Fons"",""Rene"",""Nicolas"",""Xavier"",""Greg"",""Bjarne"",""Anton"",""Otto"",; ""Eddy"",""Peter"",""Pasha"",""Philippe"",""Suzanne"",""Jeff"",""Valery""};; TCanvas *c1 = new TCanvas(""c1"",""demo bin labels"",10,10,900,500);; c1->SetGrid();; c1->SetTopMargin(0.15);; TH1F *h = new TH1F(""h"",""test"",3,0,3);; h->SetStats(0);; h->SetFillColor(38);; h->SetCanExtend(TH1::kAllAxes);; for (Int_t i=0;i<5000;i++) {; Int_t r = gRandom->Rndm()*20;; h->Fill(people[r],1);; }; h->LabelsDeflate();; h->Draw();; TPaveText *pt = new TPaveText(0.7,0.85,0.98,0.98,""brNDC"");; pt->SetFillColor(18);; pt->SetTextAlign(12);; pt->AddText(""Use the axis Context Menu LabelsOption"");; pt->AddText("" \""a\"" to sort by alphabetic order"");; pt->AddText("" \"">\"" to sort by decreasing values"");; pt->AddText("" \""<\"" to sort by increasing values"");; pt->Draw();; return c1;; }; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::kAllAxes@ kAllAxesDefinition TH1.h:76; TPaveTextA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hlabels1_8C.html:93,Load,Loading,93,doc/master/hlabels1_8C.html,https://root.cern,https://root.cern/doc/master/hlabels1_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/hlabels2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. hlabels2.C File ReferenceTutorials » Histograms tutorials. Detailed Description; 2-D histograms with alphanumeric labels. . ; TCanvas *hlabels2(); {; const Int_t nx = 12;; const Int_t ny = 20;; const char *month[nx] = {""January"",""February"",""March"",""April"",""May"",; ""June"",""July"",""August"",""September"",""October"",""November"",; ""December""};; const char *people[ny] = {""Jean"",""Pierre"",""Marie"",""Odile"",""Sebastien"",; ""Fons"",""Rene"",""Nicolas"",""Xavier"",""Greg"",""Bjarne"",""Anton"",; ""Otto"",""Eddy"",""Peter"",""Pasha"",""Philippe"",""Suzanne"",""Jeff"",; ""Valery""};; TCanvas *c1 = new TCanvas(""c1"",""demo bin labels"",10,10,600,600);; c1->SetGrid();; c1->SetLeftMargin(0.15);; c1->SetBottomMargin(0.15);; TH2F *h = new TH2F(""h"",""test"",3,0,3,2,0,2);; h->SetCanExtend(TH1::kAllAxes);; h->SetStats(0);; gRandom->SetSeed();; for (Int_t i=0;i<15000;i++) {; Int_t rx = gRandom->Rndm()*nx;; Int_t ry = gRandom->Rndm()*ny;; h->Fill(people[ry],month[rx],1);; }; h->LabelsDeflate(""X"");; h->LabelsDeflate(""Y"");; h->LabelsOption(""v"");; h->Draw(""text"");; ; TPaveText *pt = new TPaveText(0.6,0.85,0.98,0.98,""brNDC"");; pt->SetFillColor(18);; pt->SetTextAlign(12);; pt->AddText(""Use the axis Context Menu LabelsOption"");; pt->AddText("" \""a\"" to sort by alphabetic order"");; pt->AddText("" \"">\"" to sort by decreasing values"");; pt->AddText("" \""<\"" to sort by increasing values"");; pt->Draw();; return c1;; }; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1::kAllAxes@ kAllAxesDefinition TH1.h:76; TH2F2-D histogram with a float per channel (se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hlabels2_8C.html:93,Load,Loading,93,doc/master/hlabels2_8C.html,https://root.cern,https://root.cern/doc/master/hlabels2_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/hstack.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. hstack.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Example of stacked histograms: class THStack. . ; void hstack(); {; auto hs = new THStack(""hs"",""Stacked 1D histograms"");; //create three 1-d histograms; auto h1st = new TH1F(""h1st"",""test hstack"",100,-4,4);; h1st->FillRandom(""gaus"",20000);; h1st->SetFillColor(kRed);; h1st->SetMarkerStyle(21);; h1st->SetMarkerColor(kRed);; hs->Add(h1st);; auto h2st = new TH1F(""h2st"",""test hstack"",100,-4,4);; h2st->FillRandom(""gaus"",15000);; h2st->SetFillColor(kBlue);; h2st->SetMarkerStyle(21);; h2st->SetMarkerColor(kBlue);; hs->Add(h2st);; auto h3st = new TH1F(""h3st"",""test hstack"",100,-4,4);; h3st->FillRandom(""gaus"",10000);; h3st->SetFillColor(kGreen);; h3st->SetMarkerStyle(21);; h3st->SetMarkerColor(kGreen);; hs->Add(h3st);; ; auto cst = new TCanvas(""cst"",""stacked hists"",10,10,700,700);; cst->Divide(2,2);; // in top left pad, draw the stack with defaults; cst->cd(1);; hs->Draw();; // in top right pad, draw the stack in non-stack mode; // and errors option; cst->cd(2);; gPad->SetGrid();; hs->Draw(""nostack,e1p"");; //in bottom left, draw in stack mode with ""lego1"" option; cst->cd(3);; gPad->SetFrameFillColor(17);; gPad->SetTheta(3.77);; gPad->SetPhi(2.9);; hs->Draw(""lego1"");; ; cst->cd(4);; //create two 2-D histograms and draw them in stack mode; gPad->SetFrameFillColor(17);; auto a = new THStack(""a"",""Stacked 2D histograms"");; auto f1 = new TF2(""f1"",; ""xygaus + xygaus(5) + xylandau(10)"",-4,4,-4,4);; Double_t params1[] = {130,-1.4,1.8,1.5,1, 150,2,0.5,-2,0.5,; 3600,-2,0.7,-3,0.3};; f1->SetParameters(params1);; auto h2sta = new TH2F(""h2sta"",""h2sta"",20,-4,4,20,-4,4);; h2sta->SetFillColor(38);; h2sta->FillRandom(""f1"",4000);; auto f2 = new TF2(""f2"",""xygaus + xygaus(5)"",-4,4,-4,4);; Double_t params2[] = {100,-1.4,1.9,1.1,2, 80,2,0.7,-2,0.5};; f2->SetParameters(params2);; auto h2stb = new T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hstack_8C.html:91,Load,Loading,91,doc/master/hstack_8C.html,https://root.cern,https://root.cern/doc/master/hstack_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/hstack.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. hstack.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_hist; 3/// \notebook; 4/// Example of stacked histograms: class THStack.; 5///; 6/// \macro_image; 7/// \macro_code; 8///; 9/// \author Rene Brun; 10 ; 11void hstack(); 12{; 13 auto hs = new THStack(""hs"",""Stacked 1D histograms"");; 14 //create three 1-d histograms; 15 auto h1st = new TH1F(""h1st"",""test hstack"",100,-4,4);; 16 h1st->FillRandom(""gaus"",20000);; 17 h1st->SetFillColor(kRed);; 18 h1st->SetMarkerStyle(21);; 19 h1st->SetMarkerColor(kRed);; 20 hs->Add(h1st);; 21 auto h2st = new TH1F(""h2st"",""test hstack"",100,-4,4);; 22 h2st->FillRandom(""gaus"",15000);; 23 h2st->SetFillColor(kBlue);; 24 h2st->SetMarkerStyle(21);; 25 h2st->SetMarkerColor(kBlue);; 26 hs->Add(h2st);; 27 auto h3st = new TH1F(""h3st"",""test hstack"",100,-4,4);; 28 h3st->FillRandom(""gaus"",10000);; 29 h3st->SetFillColor(kGreen);; 30 h3st->SetMarkerStyle(21);; 31 h3st->SetMarkerColor(kGreen);; 32 hs->Add(h3st);; 33 ; 34 auto cst = new TCanvas(""cst"",""stacked hists"",10,10,700,700);; 35 cst->Divide(2,2);; 36 // in top left pad, draw the stack with defaults; 37 cst->cd(1);; 38 hs->Draw();; 39 // in top right pad, draw the stack in non-stack mode; 40 // and errors option; 41 cst->cd(2);; 42 gPad->SetGrid();; 43 hs->Draw(""nostack,e1p"");; 44 //in bottom left, draw in stack mode with ""lego1"" option; 45 cst->cd(3);; 46 gPad->SetFrameFillColor(17);; 47 gPad->SetTheta(3.77);; 48 gPad->SetPhi(2.9);; 49 hs->Draw(""lego1"");; 50 ; 51 cst->cd(4);; 52 //create two 2-D histograms and draw them in stack mode; 53 gPad->SetFrameFillColor(17);; 54 auto a = new THStack(""a"",""Stacked 2D histograms"");; 55 auto f1 = new TF2(""f1"",; 56 ""xygaus + xygaus(5) + xylandau(10)"",-4,4,-4,4);; 57 Double_t params1[] = {130,-1.4,1.8,1.5,1, 150,2,0.5,-2,0.5,; 58 3600,-2,0.7,-3,0.3};; 59 f1->SetParameters(params1);; 60 auto h2sta = new TH2F(""h2sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hstack_8C_source.html:88,Load,Loading,88,doc/master/hstack_8C_source.html,https://root.cern,https://root.cern/doc/master/hstack_8C_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/hstackpads.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. hstackpads.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Drawing stack histograms on subpads. ; In this example three histograms are displayed on separate pads. If canvas divided in advance - provided subpads will be used by the THStack. ; void hstackpads(); {; auto hs = new THStack(""hs"", ""Stacked 1D histograms"");; ; // Create three 1-d histograms and add them in the stack; auto h1st = new TH1F(""h1st"", ""test hstack 1"", 100, -4, 4);; h1st->FillRandom(""gaus"", 20000);; hs->Add(h1st);; ; auto h2st = new TH1F(""h2st"", ""test hstack 2"", 100, -4, 4);; h2st->FillRandom(""gaus"", 15000);; hs->Add(h2st);; ; auto h3st = new TH1F(""h3st"", ""test hstack 3"", 100, -4, 4);; h3st->FillRandom(""gaus"", 10000);; hs->Add(h3st);; ; auto c1 = new TCanvas(""c1"", ""THStack drawing on pads"", 800, 800);; ; // prepare subpads for drawing of histograms; c1->Divide(1, 3);; ; // draw thstack on canvas with ""pads"" draw option; c1->Add(hs, ""pads"");; }; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; THStackThe Histogram stack class.Definition THStack.h:40; c1return c1Definition legend1.C:41; AuthorSergey Linev ; Definition in file hstackpads.C. tutorialshisthstackpads.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hstackpads_8C.html:95,Load,Loading,95,doc/master/hstackpads_8C.html,https://root.cern,https://root.cern/doc/master/hstackpads_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/hsum.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. hsum.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Histograms filled and drawn in a loop. ; Simple example illustrating how to use the C++ interpreter to fill histograms in a loop and show the graphics results. ; void hsum(); {; TCanvas *c1 = new TCanvas(""c1"",""The HSUM example"",200,10,600,400);; c1->SetGrid();; ; gBenchmark->Start(""hsum"");; ; // Create some histograms.; auto total = new TH1F(""total"",""This is the total distribution"",100,-4,4);; auto main = new TH1F(""main"",""Main contributor"",100,-4,4);; auto s1 = new TH1F(""s1"",""This is the first signal"",100,-4,4);; auto s2 = new TH1F(""s2"",""This is the second signal"",100,-4,4);; total->Sumw2(); // store the sum of squares of weights; total->SetMarkerStyle(21);; total->SetMarkerSize(0.7);; main->SetFillColor(16);; s1->SetFillColor(42);; s2->SetFillColor(46);; TSlider *slider = nullptr;; ; // Fill histograms randomly; gRandom->SetSeed();; const Int_t kUPDATE = 500;; Float_t xs1, xs2, xmain;; for ( Int_t i=0; i<10000; i++) {; xmain = gRandom->Gaus(-1,1.5);; xs1 = gRandom->Gaus(-0.5,0.5);; xs2 = gRandom->Landau(1,0.15);; main->Fill(xmain);; s1->Fill(xs1,0.3);; s2->Fill(xs2,0.2);; total->Fill(xmain);; total->Fill(xs1,0.3);; total->Fill(xs2,0.2);; if (i && (i%kUPDATE) == 0) {; if (i == kUPDATE) {; total->Draw(""e1p"");; main->Draw(""same"");; s1->Draw(""same"");; s2->Draw(""same"");; c1->Update();; slider = new TSlider(""slider"",; ""test"",4.2,0,4.6,total->GetMaximum(),38);; slider->SetFillColor(46);; }; if (slider) slider->SetRange(0., 1.*i/10000.);; c1->Modified();; c1->Update();; }; }; slider->SetRange(0., 1.);; c1->Modified();; gBenchmark->Show(""hsum"");; }; mainint main()Definition Prototype.cxx:12; s1#define s1(x)Definition RSha256.hxx:91; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; gBenchmarkR__EXTERN TBenchmark * gBenchmarkDefinition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsum_8C.html:89,Load,Loading,89,doc/master/hsum_8C.html,https://root.cern,https://root.cern/doc/master/hsum_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/hsumTimer.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. hsumTimer.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Demo of Timers. ; Simple example illustrating how to use the C++ interpreter to fill histograms in a loop and show the graphics results This program is a variant of the tutorial ""hsum"". It illustrates the use of Timers. ; Float_t progressRatio = 0.;; TSlider *slider = nullptr;; TCanvas *c1 = nullptr;; ; void hsumUpdate(); {; // called when Timer times out; if (slider) slider->SetRange(0., progressRatio);; c1->Modified();; c1->Update();; }; ; void hsumTimer(Int_t nfill=100000); {; c1 = new TCanvas(""c1"",""The HSUM example"",200,10,600,400);; c1->SetGrid();; ; // Create some histograms.; auto total = new TH1F(""total"",""This is the total distribution"",100,-4,4);; auto main = new TH1F(""main"",""Main contributor"",100,-4,4);; auto s1 = new TH1F(""s1"",""This is the first signal"",100,-4,4);; auto s2 = new TH1F(""s2"",""This is the second signal"",100,-4,4);; total->Sumw2(); // store the sum of squares of weights; total->SetMarkerStyle(21);; total->SetMarkerSize(0.7);; main->SetFillColor(16);; s1->SetFillColor(42);; s2->SetFillColor(46);; total->SetMaximum(nfill/20.);; total->Draw(""e1p"");; main->Draw(""same"");; s1->Draw(""same"");; s2->Draw(""same"");; c1->Update();; ; slider = new TSlider(""slider"",""test"",4.2,0,4.6,0.8*total->GetMaximum(),38);; slider->SetFillColor(46);; ; // Create a TTimer (hsumUpdate called every 300 msec); TTimer timer(""hsumUpdate()"",300);; timer.TurnOn();; ; // Fill histograms randomly; Float_t xs1, xs2, xmain;; gRandom->SetSeed();; for (Int_t i=0; i<nfill; i++) {; progressRatio = i * 1. / nfill;; if (gSystem->ProcessEvents()) break;; xmain = gRandom->Gaus(-1,1.5);; xs1 = gRandom->Gaus(-0.5,0.5);; xs2 = gRandom->Landau(1,0.15);; main->Fill(xmain);; s1->Fill(xs1,0.3);; s2->Fill(xs2,0.2);; total->Fill(xmain);; total->Fill(xs1,0.3);; total->Fill(xs2,0.2);; }; time",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsumTimer_8C.html:94,Load,Loading,94,doc/master/hsumTimer_8C.html,https://root.cern,https://root.cern/doc/master/hsumTimer_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/legendautoplaced.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. legendautoplaced.C File ReferenceTutorials » Histograms tutorials. Detailed Description; The legend can be placed automatically in the current pad in an empty space found at painting time. ; The following example illustrate this facility. Only the width and height of the legend is specified in percentage of the pad size. ; void legendautoplaced(); {; auto c4 = new TCanvas(""c"", ""c"", 600,500);; auto hpx = new TH1D(""hpx"",""This is the hpx distribution"",100,-4.,4.);; hpx->FillRandom(""gaus"", 50000);; hpx->Draw(""E"");; hpx->GetYaxis()->SetTitle(""Y Axis title"");; hpx->GetYaxis()->SetTitleOffset(1.3); hpx->GetYaxis()->CenterTitle(true);; hpx->GetXaxis()->SetTitle(""X Axis title"");; hpx->GetXaxis()->CenterTitle(true);; ; auto h1 = new TH1D(""h1"",""A green histogram"",100,-2.,2.);; h1->FillRandom(""gaus"", 10000);; h1->SetLineColor(kGreen);; h1->Draw(""same"");; ; auto g = new TGraph();; g->SetPoint(0, -3.5, 100 );; g->SetPoint(1, -3.0, 300 );; g->SetPoint(2, -2.0, 1000 );; g->SetPoint(3, 1.0, 800 );; g->SetPoint(4, 0.0, 200 );; g->SetPoint(5, 3.0, 200 );; g->SetPoint(6, 3.0, 700 );; g->Draw(""L"");; g->SetTitle(""This is a TGraph"");; g->SetLineColor(kRed);; g->SetFillColor(0);; ; // TPad::BuildLegend() default placement values are such that they trigger; // the automatic placement.; c4->BuildLegend();; }; g#define g(i)Definition RSha256.hxx:105; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/legendautoplaced_8C.html:101,Load,Loading,101,doc/master/legendautoplaced_8C.html,https://root.cern,https://root.cern/doc/master/legendautoplaced_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/logscales.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. logscales.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Draw parametric functions with log scales. . ; void logscales() {; TCanvas *c1 = new TCanvas(""c1"", ""Various options on LOG scales plots"",0,0,700,900);; c1->SetFillColor(30);; ; TPad *pad1 = new TPad(""pad1"",""pad1"",0.03,0.62,0.50,0.92,32);; TPad *pad2 = new TPad(""pad2"",""pad2"",0.51,0.62,0.98,0.92,33);; TPad *pad3 = new TPad(""pad3"",""pad3"",0.03,0.02,0.97,0.535,38);; pad1->Draw(); pad2->Draw(); pad3->Draw();; ; TPaveLabel *title = new TPaveLabel(0.1,0.94,0.9,0.98, ""Various options on LOG scales plots"");; title->SetFillColor(16);; title->SetTextFont(42);; title->Draw();; ; TPaveText *pave = new TPaveText(0.1,0.55,0.9,0.61);; pave->SetFillColor(42);; pave->SetTextAlign(12);; pave->SetTextFont(42);; pave->AddText(""When more Log labels are requested, the overlapping labels are removed"");; pave->Draw();; ; pad1->cd();; pad1->SetLogy();; pad1->SetGridy();; TF1 *f1 = new TF1(""f1"",""x*sin(x)*exp(-0.1*x)+15"",-10.,10.);; TF1 *f2 = new TF1(""f2"",""(sin(x)+cos(x))**5+15"",-10.,10.);; TF1 *f3 = new TF1(""f3"",""(sin(x)/(x)-x*cos(x))+15"",-10.,10.);; f1->SetLineWidth(1); f1->SetLineColor(2);; f2->SetLineWidth(1); f2->SetLineColor(3);; f3->SetLineWidth(1); f3->SetLineColor(4);; f1->Draw();; f2->Draw(""same"");; f3->Draw(""same"");; f1->GetYaxis()->SetMoreLogLabels();; TPaveText *pave1 = new TPaveText(-6,2,6,6);; pave1->SetFillColor(42);; pave1->SetTextAlign(12);; pave1->SetTextFont(42);; pave1->AddText(""Log scale along Y axis."");; pave1->AddText(""More Log labels requested."");; pave1->Draw();; ; pad2->cd();; double x[10] = { 200, 300, 400, 500, 600, 650, 700, 710, 900,1000 };; double y[10] = { 200, 1000, 900, 400, 500, 250, 800, 150, 201, 220 };; TGraph *g_2 = new TGraph(10,x,y);; g_2->Draw(""AL*"");; g_2->SetMarkerColor(2);; g_2->GetYaxis()->SetMoreLogLabels();; g_2->GetYaxis()->SetNoExponen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/logscales_8C.html:94,Load,Loading,94,doc/master/logscales_8C.html,https://root.cern,https://root.cern/doc/master/logscales_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/movepalette.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. movepalette.C File ReferenceTutorials » Histograms tutorials. Detailed Description; When an histogram is drawn with the option COLZ, a palette is automatically drawn vertically on the right side of the plot. ; It is possible to move and resize this vertical palette as shown on the left plot. The right plot demonstrates that, when the width of the palette is larger than its height, the palette is automatically drawn horizontally. ; void movepalette(); {; auto c = new TCanvas("""", """",0,0,1100,550);; c->Divide(2,1);; gStyle->SetOptStat(0);; ; auto h1 = new TH2D(""h1"",""h1"",40,-4,4,40,-20,20);; auto h2 = new TH2D(""h2"",""h2"",40,-4,4,40,-20,20);; float px, py;; for (int i = 0; i < 25000; i++) {; gRandom->Rannor(px,py); h1->Fill(px,5*py);; gRandom->Rannor(px,py); h2->Fill(px,5*py);; }; ; TPad *p1 = (TPad *)c->cd(1);; TPad *p2 = (TPad *)c->cd(2);; ; p1->SetRightMargin(0.15);; auto palette1 = new TPaletteAxis(4.05,-15,4.5,15,h1);; h1->GetListOfFunctions()->Add(palette1);; ; p2->SetBottomMargin(0.2);; auto palette2 = new TPaletteAxis(-3.,-25,3.,-23,h2);; h2->GetListOfFunctions()->Add(palette2);; ; p1->cd(); h1->Draw(""colz"");; p2->cd(); h2->Draw(""colz"");; }; c#define c(i)Definition RSha256.hxx:101; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TAttPad::SetBottomMarginvirtual void SetBottomMargin(Float_t bottommargin)Set Pad bottom margin in fraction of the pad height.Definition TAttPad.cxx:99; TAttPad::SetRightMarginvirtual void SetRightMargin(Float_t rightmargin)Set Pad right margin in fraction of the pad width.Definition TAttPad.cxx:119; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/movepalette_8C.html:96,Load,Loading,96,doc/master/movepalette_8C.html,https://root.cern,https://root.cern/doc/master/movepalette_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/multicolor.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. multicolor.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Use a THStack to show a 2-D hist with cells with different colors. ; root > .x multicolor.C; root > .x multicolor.C(1); . ; #include ""TCanvas.h""; #include ""TH2.h""; #include ""THStack.h""; #include ""TRandom.h""; ; void multicolor(Int_t isStack=0) {; TCanvas *c1 = new TCanvas;; Int_t nbins = 20;; TH2F *h1 = new TH2F(""h1"",""h1"",nbins,-4,4,nbins,-4,4);; h1->SetFillColor(kBlue);; TH2F *h2 = new TH2F(""h2"",""h2"",nbins,-4,4,nbins,-4,4);; h2->SetFillColor(kRed);; TH2F *h3 = new TH2F(""h3"",""h3"",nbins,-4,4,nbins,-4,4);; h3->SetFillColor(kYellow);; THStack *hs = new THStack(""hs"",""three plots"");; hs->Add(h1);; hs->Add(h2);; hs->Add(h3);; TRandom r;; Int_t i;; for (i=0;i<20000;i++) h1->Fill(r.Gaus(),r.Gaus());; for (i=0;i<200;i++) {; Int_t ix = (Int_t)r.Uniform(0,nbins);; Int_t iy = (Int_t)r.Uniform(0,nbins);; Int_t bin = h1->GetBin(ix,iy);; Double_t val = h1->GetBinContent(bin);; if (val <= 0) continue;; if (!isStack) h1->SetBinContent(bin,0);; if (r.Rndm() > 0.5) {; if (!isStack) h2->SetBinContent(bin,0);; h3->SetBinContent(bin,val);; } else {; if (!isStack) h3->SetBinContent(bin,0);; h2->SetBinContent(bin,val);; }; }; hs->Draw(""lego1"");; }; ; ; ; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; kYellow@ kYellowDefinition Rtypes.h:66; TCanvas.h; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TH2.h; THStack.h; TRandom.h; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TCanvasThe Canvas class.Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/multicolor_8C.html:95,Load,Loading,95,doc/master/multicolor_8C.html,https://root.cern,https://root.cern/doc/master/multicolor_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/ratioplot1.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ratioplot1.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Example creating a simple ratio plot of two histograms using the pois division option. ; Two histograms are set up and filled with random numbers. The constructor of TRatioPlot takes the two histograms, name and title for the object, drawing options for the histograms (hist and E in this case) and a drawing option for the output graph. The histograms drawing options can be changed with SetH1DrawOpt and SetH2DrawOpt. ; void ratioplot1() {; gStyle->SetOptStat(0);; auto C = new TCanvas(""C"", ""A ratio example"");; auto h1 = new TH1D(""h1"", ""TRatioPlot Example; x; y"", 50, 0, 10);; auto h2 = new TH1D(""h2"", ""h2"", 50, 0, 10);; auto f1 = new TF1(""f1"", ""exp(- x/[0] )"");; f1->SetParameter(0, 3);; h1->FillRandom(""f1"", 1900);; h2->FillRandom(""f1"", 2000);; h1->Sumw2();; h2->Scale(1.9 / 2.);; h2->SetLineColor(kRed);; ; // Create and draw the ratio plot; auto rp = new TRatioPlot(h1, h2);; C->SetTicks(0, 1);; rp->Draw();; rp->GetLowYaxis()->SetNdivisions(505);; ; // Add a legend to the ratio plot; rp->GetUpperPad()->cd();; TLegend *legend = new TLegend(0.3,0.7,0.7,0.85);; legend->AddEntry(""h1"",""First histogram"",""l"");; legend->AddEntry(""h2"",""Second histogram"",""le"");; legend->Draw();; }; kRed@ kRedDefinition Rtypes.h:66; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TF11-Dim function classDefinition TF1.h:233; TF1::SetParametervirtual void SetParameter(Int_t param, Double_t value)Definition TF1.h:667; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ratioplot1_8C.html:95,Load,Loading,95,doc/master/ratioplot1_8C.html,https://root.cern,https://root.cern/doc/master/ratioplot1_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/ratioplot1.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; ratioplot1.py File ReferenceTutorials » Histograms tutorials. Detailed Description; Example creating a simple ratio plot of two histograms using the pois division option. ; Two histograms are set up and filled with random numbers. The constructor of TRatioPlot takes the to histograms, name and title for the object, drawing options for the histograms (hist and E in this case) and a drawing option for the output graph. Inspired by the tutorial of Paul Gessinger. ; import ROOT; ; ROOT.gStyle.SetOptStat(0); ; c1 = ROOT.TCanvas(""c1"", ""A ratio example""); h1 = ROOT.TH1D(""h1"", ""h1"", 50, 0, 10); h2 = ROOT.TH1D(""h2"", ""h2"", 50, 0, 10); f1 = ROOT.TF1(""f1"", ""exp(- x/[0] )""); f1.SetParameter(0,3); ; h1.FillRandom(""f1"",1900); h2.FillRandom(""f1"", 2000); h1.Sumw2(); h2.Scale(1.9/2.); ; h1.GetXaxis().SetTitle(""x""); h1.GetYaxis().SetTitle(""y""); ; rp = ROOT.TRatioPlot(h1,h2); ; c1.SetTicks(0,1); rp.GetLowYaxis().SetNdivisions(505); c1.Update(); c1.Draw(); rp.Draw(); ; AuthorAlberto Ferro ; Definition in file ratioplot1.py. tutorialshistratioplot1.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ratioplot1_8py.html:96,Load,Loading,96,doc/master/ratioplot1_8py.html,https://root.cern,https://root.cern/doc/master/ratioplot1_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/ratioplot2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ratioplot2.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Example of a fit residual plot. ; Creates a histogram filled with random numbers from a gaussian distribution and fits it with a standard gaussian function. The result is passed to the TRatioPlot constructor. Additionally, after calling TRatioPlot::Draw the upper and lower y axis titles are modified. Confidence interval bands are automatically drawn on the bottom (but can be disabled by draw option nobands). ; void ratioplot2() {; gStyle->SetOptStat(0);; auto c1 = new TCanvas(""c1"", ""fit residual simple"");; auto h1 = new TH1D(""h1"", ""h1"", 50, -5, 5);; h1->FillRandom(""gaus"", 2000);; h1->Fit(""gaus"", ""0"");; h1->GetXaxis()->SetTitle(""x"");; auto rp1 = new TRatioPlot(h1);; rp1->Draw();; rp1->GetLowerRefYaxis()->SetTitle(""ratio"");; rp1->GetUpperRefYaxis()->SetTitle(""entries"");; }; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TRatioPlotClass for displaying ratios, differences and fit residuals.Definition TRatioPlot.h:43; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:16",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ratioplot2_8C.html:95,Load,Loading,95,doc/master/ratioplot2_8C.html,https://root.cern,https://root.cern/doc/master/ratioplot2_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/ratioplot2.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; ratioplot2.py File ReferenceTutorials » Histograms tutorials. Detailed Description; Example of a fit residual plot. ; Creates a histogram filled with random numbers from a gaussian distribution and fits it with a standard gaussian function. The result is passed to the TRatioPlot constructor. Additionally, after calling TRatioPlot::Draw the upper and lower y axis titles are modified. Confidence interval bands are automatically drawn on the bottom (but can be disabled by draw option nobands). Inspired by the tutorial of Paul Gessinger. . ; import ROOT; ; ROOT.gStyle.SetOptStat(0); ; c1 = ROOT.TCanvas(""c1"", ""fit residual simple""); h1 = ROOT.TH1D(""h1"", ""h1"", 50, -5, 5); ; h1.FillRandom(""gaus"", 2000); h1.Fit(""gaus""); h1.GetXaxis().SetTitle(""x""); ; rp1 = ROOT.TRatioPlot(h1); rp1.Draw(); rp1.GetLowerRefYaxis().SetTitle(""ratio""); rp1.GetUpperRefYaxis().SetTitle(""entries""); ; c1.Update(); ; AuthorAlberto Ferro ; Definition in file ratioplot2.py. tutorialshistratioplot2.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ratioplot2_8py.html:96,Load,Loading,96,doc/master/ratioplot2_8py.html,https://root.cern,https://root.cern/doc/master/ratioplot2_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/ratioplot3.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ratioplot3.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Example which shows how you can get the graph of the lower plot and set the y axis range for it. ; Since the lower plot is not created until TRatioPlot::Draw is called, you can only use the method afterwards. ; void ratioplot3() {; gStyle->SetOptStat(0);; auto c1 = new TCanvas(""c1"", ""fit residual simple"");; c1->SetLogy();; auto h1 = new TH1D(""h1"", ""h1"", 50, -5, 5);; h1->FillRandom(""gaus"", 2000);; h1->Fit(""gaus"", ""0"");; h1->SetMinimum(0.001);; h1->GetXaxis()->SetTitle(""x"");; h1->GetYaxis()->SetTitle(""y"");; auto rp1 = new TRatioPlot(h1);; rp1->Draw();; rp1->GetLowerRefGraph()->SetMinimum(-2);; rp1->GetLowerRefGraph()->SetMaximum(2);; }; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TRatioPlotClass for displaying ratios, differences and fit residuals.Definition TRatioPlot.h:43; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ratioplot3_8C.html:95,Load,Loading,95,doc/master/ratioplot3_8C.html,https://root.cern,https://root.cern/doc/master/ratioplot3_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/ratioplot3.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; ratioplot3.py File ReferenceTutorials » Histograms tutorials. Detailed Description; Example which shows how you can get the graph of the lower plot and set the y axis range for it. ; Since the lower plot is not created until TRatioPlot::Draw is called, you can only use the method afterwards. Inspired by the tutorial of Paul Gessinger. ; import ROOT; ; ROOT.gStyle.SetOptStat(0); c1 = ROOT.TCanvas(""c1"", ""fit residual simple""); c1.SetLogy(); ; h1 = ROOT.TH1D(""h1"", ""h1"", 50, -5, 5); h1.FillRandom(""gaus"", 2000); h1.Fit(""gaus""); h1.SetMinimum(0.001); h1.GetXaxis().SetTitle(""x""); h1.GetYaxis().SetTitle(""y""); ; rp1 = ROOT.TRatioPlot(h1); rp1.Draw(); rp1.GetLowerRefGraph().SetMinimum(-2); rp1.GetLowerRefGraph().SetMaximum(2); ; c1.Update(); AuthorAlberto Ferro ; Definition in file ratioplot3.py. tutorialshistratioplot3.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ratioplot3_8py.html:96,Load,Loading,96,doc/master/ratioplot3_8py.html,https://root.cern,https://root.cern/doc/master/ratioplot3_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/ratioplot4.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ratioplot4.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Example that shows custom dashed lines on the lower plot, specified by a vector of floats. ; By default, dashed lines are drawn at certain points. You can either disable them, or specify where you want them to appear. ; void ratioplot4() {; gStyle->SetOptStat(0);; auto c1 = new TCanvas(""c1"", ""fit residual simple"");; auto h1 = new TH1D(""h1"", ""h1"", 50, -5, 5);; h1->FillRandom(""gaus"", 2000);; h1->Fit(""gaus"", ""0"");; h1->GetXaxis()->SetTitle(""x"");; h1->GetYaxis()->SetTitle(""y"");; auto rp1 = new TRatioPlot(h1);; std::vector<double> lines = {-3, -2, -1, 0, 1, 2, 3};; rp1->SetGridlines(lines);; rp1->Draw();; rp1->GetLowerRefGraph()->SetMinimum(-4);; rp1->GetLowerRefGraph()->SetMaximum(4);; }; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TRatioPlotClass for displaying ratios, differences and fit residuals.Definition TRatioPlot.h:43; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; c1return c1Definition legend1.C:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ratioplot4_8C.html:95,Load,Loading,95,doc/master/ratioplot4_8C.html,https://root.cern,https://root.cern/doc/master/ratioplot4_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/ratioplot4.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; ratioplot4.py File ReferenceTutorials » Histograms tutorials. Detailed Description; Example that shows custom dashed lines on the lower plot, specified by a vector of floats. ; By default, dashed lines are drawn at certain points. You can either disable them, or specify where you want them to appear. Inspired by the tutorial of Paul Gessinger. ; import ROOT; ; ROOT.gStyle.SetOptStat(0); ; c1 = ROOT.TCanvas(""c1"", ""fit residual simple""); h1 = ROOT.TH1D(""h1"", ""h1"", 50, -5, 5); h1.FillRandom(""gaus"", 2000); h1.Fit(""gaus""); h1.GetXaxis().SetTitle(""x""); h1.GetYaxis().SetTitle(""y""); ; rp1 = ROOT.TRatioPlot(h1); ; lines = ROOT.std.vector('double')(); for i in range(-3,4):lines.push_back(i); rp1.SetGridlines(lines); ; rp1.Draw(); rp1.GetLowerRefGraph().SetMinimum(-4); rp1.GetLowerRefGraph().SetMaximum(4); ; c1.Update(); AuthorAlberto Ferro ; Definition in file ratioplot4.py. tutorialshistratioplot4.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ratioplot4_8py.html:96,Load,Loading,96,doc/master/ratioplot4_8py.html,https://root.cern,https://root.cern/doc/master/ratioplot4_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/ratioplot5.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ratioplot5.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors. . ; void ratioplot5() {; gStyle->SetOptStat(0);; auto c1 = new TCanvas(""c1"", ""fit residual simple"");; auto h1 = new TH1D(""h1"", ""h1"", 50, -5, 5);; h1->FillRandom(""gaus"", 2000);; h1->Fit(""gaus"",""0"");; h1->GetXaxis()->SetTitle(""x"");; h1->GetYaxis()->SetTitle(""y"");; auto rp1 = new TRatioPlot(h1);; rp1->SetConfidenceIntervalColors(kBlue, kRed);; rp1->Draw();; }; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TRatioPlotClass for displaying ratios, differences and fit residuals.Definition TRatioPlot.h:43; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; c1return c1Definition legend1.C:41; h1TH1F * h1Definition legend1.C:5; ratioplot5Definition ratioplot5.py:1; AuthorPaul Gessinger ; Definition in file ratio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ratioplot5_8C.html:95,Load,Loading,95,doc/master/ratioplot5_8C.html,https://root.cern,https://root.cern/doc/master/ratioplot5_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/ratioplot5.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; ratioplot5.py File ReferenceTutorials » Histograms tutorials. Detailed Description; Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors. ; Inspired by the tutorial of Paul Gessinger. ; import ROOT; ; ROOT.gStyle.SetOptStat(0); ; c1 = ROOT.TCanvas(""c1"", ""fit residual simple""); h1 = ROOT.TH1D(""h1"", ""h1"", 50, -5, 5); h1.FillRandom(""gaus"", 2000); h1.Fit(""gaus""); h1.GetXaxis().SetTitle(""x""); h1.GetYaxis().SetTitle(""y""); ; rp1 = ROOT.TRatioPlot(h1); rp1.SetConfidenceIntervalColors(ROOT.kBlue, ROOT.kRed); rp1.Draw(); c1.Update(); AuthorAlberto Ferro ; Definition in file ratioplot5.py. tutorialshistratioplot5.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ratioplot5_8py.html:96,Load,Loading,96,doc/master/ratioplot5_8py.html,https://root.cern,https://root.cern/doc/master/ratioplot5_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/ratioplot6.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ratioplot6.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Example showing a fit residual plot, where the separation margin has been set to 0. ; The last label of the lower plot's y axis is hidden automatically. ; void ratioplot6() {; gStyle->SetOptStat(0);; auto c1 = new TCanvas(""c1"", ""fit residual simple"");; gPad->SetFrameFillStyle(0);; auto h1 = new TH1D(""h1"", ""h1"", 50, -5, 5);; h1->FillRandom(""gaus"", 5000);; TFitResultPtr fitres = h1->Fit(""gaus"", ""S0"");; h1->Sumw2();; h1->GetXaxis()->SetTitle(""x"");; h1->GetYaxis()->SetTitle(""y"");; auto rp1 = new TRatioPlot(h1, ""errfunc"");; rp1->SetGraphDrawOpt(""L"");; rp1->SetSeparationMargin(0.0);; rp1->Draw();; rp1->GetLowerRefGraph()->SetMinimum(-2);; rp1->GetLowerRefGraph()->SetMaximum(2);; }; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; gPad#define gPadDefinition TVirtualPad.h:308; TCanvasThe Canvas class.Definition TCanvas.h:23; TFitResultPtrProvides an indirection to the TFitResult class and with a semantics identical to a TFitResult pointe...Definition TFitResultPtr.h:32; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create structure to store sum of squares of weights.Definition TH1.cxx:9020; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ratioplot6_8C.html:95,Load,Loading,95,doc/master/ratioplot6_8C.html,https://root.cern,https://root.cern/doc/master/ratioplot6_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/ratioplot6.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; ratioplot6.py File ReferenceTutorials » Histograms tutorials. Detailed Description; Example showing a fit residual plot, where the separation margin has been set to 0. ; The last label of the lower plot's y axis is hidden automatically. Inspired by the tutorial of Paul Gessinger. ; import ROOT; ; ROOT.gStyle.SetOptStat(0); ; c1 = ROOT.TCanvas(""c1"", ""fit residual simple""); ROOT.gPad.SetFrameFillStyle(0); ; h1 = ROOT.TH1D(""h1"", ""h1"", 50, -5, 5); h1.FillRandom(""gaus"", 5000); h1.Fit(""gaus"", ""S""); ; h1.Sumw2(); h1.GetXaxis().SetTitle(""x""); h1.GetYaxis().SetTitle(""y""); ; rp1 = ROOT.TRatioPlot(h1, ""errfunc""); rp1.SetGraphDrawOpt(""L""); rp1.SetSeparationMargin(0.0); rp1.Draw(); rp1.GetLowerRefGraph().SetMinimum(-2); rp1.GetLowerRefGraph().SetMaximum(2); ; c1.Update(); AuthorAlberto Ferro ; Definition in file ratioplot6.py. tutorialshistratioplot6.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ratioplot6_8py.html:96,Load,Loading,96,doc/master/ratioplot6_8py.html,https://root.cern,https://root.cern/doc/master/ratioplot6_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/ratioplotOld.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ratioplotOld.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Example displaying two histograms and their ratio. ; This macro does not use the class TRatioPlot. For ROOT version >= 6.08 TRatioPlot should be used. See the other ratio plots examples in this folder. ; void ratioplotOld( ) {; // Define two gaussian histograms. Note the X and Y title are defined; // at booking time using the convention ""Hist_title ; X_title ; Y_title""; TH1F *h1 = new TH1F(""h1"", ""Two gaussian plots and their ratio;x title; h1 and h2 gaussian histograms"", 100, -5, 5);; TH1F *h2 = new TH1F(""h2"", ""h2"", 100, -5, 5);; h1->FillRandom(""gaus"");; h2->FillRandom(""gaus"");; ; // Define the Canvas; TCanvas *c = new TCanvas(""c"", ""canvas"", 800, 800);; ; // Upper plot will be in pad1; TPad *pad1 = new TPad(""pad1"", ""pad1"", 0, 0.3, 1, 1.0);; pad1->SetBottomMargin(0); // Upper and lower plot are joined; pad1->SetGridx(); // Vertical grid; pad1->Draw(); // Draw the upper pad: pad1; pad1->cd(); // pad1 becomes the current pad; h1->SetStats(0); // No statistics on upper plot; h1->Draw(); // Draw h1; h2->Draw(""same""); // Draw h2 on top of h1; ; #if ROOT_VERSION_CODE >= ROOT_VERSION(6,8,0); // Avoid the first label (0) to be clipped.; TAxis *axis = h1->GetYaxis();; axis->ChangeLabel(1, -1, -1, -1, -1, -1, "" "");; axis->SetLabelFont(43); // Absolute font size in pixel (precision 3); axis->SetLabelSize(15);; #else; // Do not draw the Y axis label on the upper plot and redraw a small; // axis instead, in order to avoid the first label (0) to be clipped.; h1->GetYaxis()->SetLabelSize(0.);; TGaxis *axis = new TGaxis( -5, 20, -5, 220, 20,220,510,"""");; axis->SetLabelFont(43); // Absolute font size in pixel (precision 3); axis->SetLabelSize(15);; axis->Draw();; #endif; ; // lower plot will be in pad; c->cd(); // Go back to the main canvas before defining pad2; TPad *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ratioplotOld_8C.html:97,Load,Loading,97,doc/master/ratioplotOld_8C.html,https://root.cern,https://root.cern/doc/master/ratioplotOld_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/rebin.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rebin.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Rebin a variable bin-width histogram. ; This tutorial illustrates how to:; create a variable bin-width histogram with a binning such that the population per bin is about the same.; rebin a variable bin-width histogram into another one. ; #include ""TH1.h""; #include ""TCanvas.h""; void rebin() {; //create a fix bin histogram; TH1F *h = new TH1F(""h"",""test rebin"",100,-3,3);; Int_t nentries = 1000;; h->FillRandom(""gaus"",nentries);; Double_t xbins[1001];; Int_t k=0;; TAxis *axis = h->GetXaxis();; for (Int_t i=1;i<=100;i++) {; Int_t y = (Int_t)h->GetBinContent(i);; if (y <=0) continue;; Double_t dx = axis->GetBinWidth(i)/y;; Double_t xmin = axis->GetBinLowEdge(i);; for (Int_t j=0;j<y;j++) {; xbins[k] = xmin +j*dx;; k++;; }; }; xbins[k] = axis->GetXmax();; //create a variable bin-width histogram out of fix bin histogram; //new rebinned histogram should have about 10 entries per bin; TH1F *hnew = new TH1F(""hnew"",""rebinned"",k,xbins);; hnew->FillRandom(""gaus"",10*nentries);; ; //rebin hnew keeping only 50% of the bins; Double_t xbins2[501];; Int_t kk=0;; for (Int_t j=0;j<k;j+=2) {; xbins2[kk] = xbins[j];; kk++;; }; xbins2[kk] = xbins[k];; TH1F *hnew2 = (TH1F*)hnew->Rebin(kk,""hnew2"",xbins2);; ; //draw the 3 histograms; TCanvas *c1 = new TCanvas(""c1"",""c1"",800,1000);; c1->Divide(1,3);; c1->cd(1);; h->Draw();; c1->cd(2);; hnew->Draw();; c1->cd(3);; hnew2->Draw();; }; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; TCanvas.h; TH1.h; xminfloat xminDefinition THbookFile.cxx:95; nentriesint nentriesDefinition THbookFile.cxx:91; TAxisClass to manage histogram axis.Definition TAxis.h:31; TAxis::GetXmaxDouble_t GetXmax() constDefinition TAxis.h:140; TAxis::GetBinLowEdgevirtual Double_t GetBinLowEdge(Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rebin_8C.html:90,Load,Loading,90,doc/master/rebin_8C.html,https://root.cern,https://root.cern/doc/master/rebin_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/rebin.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rebin.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_hist; 3/// \notebook -js; 4/// Rebin a variable bin-width histogram.; 5///; 6/// This tutorial illustrates how to:; 7/// - create a variable bin-width histogram with a binning such; 8/// that the population per bin is about the same.; 9/// - rebin a variable bin-width histogram into another one.; 10///; 11/// \macro_image; 12/// \macro_code; 13///; 14/// \author Rene Brun; 15 ; 16#include ""TH1.h""; 17#include ""TCanvas.h""; 18void rebin() {; 19 //create a fix bin histogram; 20 TH1F *h = new TH1F(""h"",""test rebin"",100,-3,3);; 21 Int_t nentries = 1000;; 22 h->FillRandom(""gaus"",nentries);; 23 Double_t xbins[1001];; 24 Int_t k=0;; 25 TAxis *axis = h->GetXaxis();; 26 for (Int_t i=1;i<=100;i++) {; 27 Int_t y = (Int_t)h->GetBinContent(i);; 28 if (y <=0) continue;; 29 Double_t dx = axis->GetBinWidth(i)/y;; 30 Double_t xmin = axis->GetBinLowEdge(i);; 31 for (Int_t j=0;j<y;j++) {; 32 xbins[k] = xmin +j*dx;; 33 k++;; 34 }; 35 }; 36 xbins[k] = axis->GetXmax();; 37 //create a variable bin-width histogram out of fix bin histogram; 38 //new rebinned histogram should have about 10 entries per bin; 39 TH1F *hnew = new TH1F(""hnew"",""rebinned"",k,xbins);; 40 hnew->FillRandom(""gaus"",10*nentries);; 41 ; 42 //rebin hnew keeping only 50% of the bins; 43 Double_t xbins2[501];; 44 Int_t kk=0;; 45 for (Int_t j=0;j<k;j+=2) {; 46 xbins2[kk] = xbins[j];; 47 kk++;; 48 }; 49 xbins2[kk] = xbins[k];; 50 TH1F *hnew2 = (TH1F*)hnew->Rebin(kk,""hnew2"",xbins2);; 51 ; 52 //draw the 3 histograms; 53 TCanvas *c1 = new TCanvas(""c1"",""c1"",800,1000);; 54 c1->Divide(1,3);; 55 c1->cd(1);; 56 h->Draw();; 57 c1->cd(2);; 58 hnew->Draw();; 59 c1->cd(3);; 60 hnew2->Draw();; 61}; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; TCanvas.h; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rebin_8C_source.html:87,Load,Loading,87,doc/master/rebin_8C_source.html,https://root.cern,https://root.cern/doc/master/rebin_8C_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/reverseaxis.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. reverseaxis.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Example showing an histogram with reverse axis. . ; void ReverseXAxis (TH1 *h);; void ReverseYAxis (TH1 *h);; ; void reverseaxis(); {; TH2F *hpxpy = new TH2F(""hpxpy"",""py vs px"",40,-4,4,40,-4,4);; Float_t px, py;; TRandom r;; for (Int_t i = 0; i < 25000; i++) {; r.Rannor(px,py);; hpxpy->Fill(px,py);; }; TCanvas *c1 = new TCanvas(""c1"");; hpxpy->Draw(""colz"");; ReverseXAxis(hpxpy);; ReverseYAxis(hpxpy);; }; ; void ReverseXAxis(TH1 *h); {; // Remove the current axis; h->GetXaxis()->SetLabelOffset(999);; h->GetXaxis()->SetTickLength(0);; ; // Redraw the new axis; gPad->Update();; TGaxis *newaxis = new TGaxis(gPad->GetUxmax(),; gPad->GetUymin(),; gPad->GetUxmin(),; gPad->GetUymin(),; h->GetXaxis()->GetXmin(),; h->GetXaxis()->GetXmax(),; 510,""-"");; newaxis->SetLabelOffset(-0.03);; newaxis->Draw();; }; ; void ReverseYAxis(TH1 *h); {; // Remove the current axis; h->GetYaxis()->SetLabelOffset(999);; h->GetYaxis()->SetTickLength(0);; ; // Redraw the new axis; gPad->Update();; TGaxis *newaxis = new TGaxis(gPad->GetUxmin(),; gPad->GetUymax(),; gPad->GetUxmin()-0.001,; gPad->GetUymin(),; h->GetYaxis()->GetXmin(),; h->GetYaxis()->GetXmax(),; 510,""+"");; newaxis->SetLabelOffset(-0.03);; newaxis->Draw();; }; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gPad#define gPadDefinition TVirtualPad.h:308; TCanvasThe Canvas class.Definition TCanvas.h:23; TGaxisThe axis painter class.Definition TGaxis.h:24; TGaxis::SetLabelOffsetvoid SetLabelOffset(F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/reverseaxis_8C.html:96,Load,Loading,96,doc/master/reverseaxis_8C.html,https://root.cern,https://root.cern/doc/master/reverseaxis_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/sparsehist.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. sparsehist.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Evaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension. ; The script calculates the bandwidth for filling and retrieving bin contents (in million entries per second) for these two histogramming techniques, where ""seconds"" is CPU and real time.; The first line of the plots contains the bandwidth based on the CPU time (THnSpase, TH1/2/3/nF*, ratio), the second line shows the plots for real time, and the third line shows the fraction of filled bins and memory used by THnSparse vs. TH1/2/3/nF.; The timing depends on the distribution and the amount of entries in the histograms; here, a Gaussian distribution (center is contained in the histograms) is used to fill each histogram with 1000 entries. The filling and reading is repeated until enough statistics have been collected.; tutorials/tree/drawsparse.C shows an example for visualizing a THnSparse. It creates a TTree which is then drawn using TParallelCoord.; This macro should be run in compiled mode due to the many nested loops that force CLING to disable its optimization. If run interpreted one would not benchmark THnSparse but CLING.; Run as: root[0] .L $ROOTSYS/tutorials/hist/sparsehist.C+; root[1] sparsehist(); ; #include ""TH1.h""; #include ""TH2.h""; #include ""TH3.h""; #include ""THn.h""; #include ""THnSparse.h""; #include ""TStopwatch.h""; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""TFile.h""; #include ""TStyle.h""; #include ""TSystem.h""; ; #ifndef INT_MAX; #define INT_MAX std::numeric_limits<int>::max(); #endif; ; class TTimeHists {; public:; enum EHist { kHist, kSparse, kNumHist };; enum ETime { kReal, kCPU, kNumTime };; TTimeHists(Int_t dim, Int_t bins, Long_t num):; fValue(nullptr), fDim(dim), fBins(bins), fNum(num),; fSparse(nullptr), fHist(nullpt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/sparsehist_8C.html:95,Load,Loading,95,doc/master/sparsehist_8C.html,https://root.cern,https://root.cern/doc/master/sparsehist_8C.html,2,"['Load', 'perform']","['Loading', 'performance']"
Performance,". ROOT: tutorials/hist/statsEditing.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. statsEditing.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Edit statistics box. ; This example shows:; how to remove a stat element from the stat box; how to add a new one. ; TCanvas *statsEditing() {; // Create and plot a test histogram with stats; TCanvas *se = new TCanvas;; TH1F *h = new TH1F(""h"",""test"",100,-3,3);; h->FillRandom(""gaus"",3000);; gStyle->SetOptStat();; h->Draw();; se->Update();; ; // Retrieve the stat box; TPaveStats *ps = (TPaveStats*)se->GetPrimitive(""stats"");; ps->SetName(""mystats"");; TList *listOfLines = ps->GetListOfLines();; ; // Remove the RMS line; TText *tconst = ps->GetLineWith(""RMS"");; listOfLines->Remove(tconst);; ; // Add a new line in the stat box.; // Note that ""="" is a control character; TLatex *myt = new TLatex(0,0,""Test = 10"");; myt ->SetTextFont(42);; myt ->SetTextSize(0.04);; myt ->SetTextColor(kRed);; listOfLines->Add(myt);; ; // the following line is needed to avoid that the automatic redrawing of stats; h->SetStats(0);; ; se->Modified();; return se;; }; h#define h(i)Definition RSha256.hxx:106; kRed@ kRedDefinition Rtypes.h:66; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::Updatevoid Update() overrideUpdate canvas pad buffers.Definition TCanvas.cxx:2489; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/statsEditing_8C.html:97,Load,Loading,97,doc/master/statsEditing_8C.html,https://root.cern,https://root.cern/doc/master/statsEditing_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/testSmooth.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. testSmooth.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Histogram smoothing. . ; int ipad = 1;; TCanvas * c1 = 0;; ; void smooth_hist(const char * fname, double xmin, double xmax, int n1, int n2) {; ; std::cout << ""smoothing a "" << fname << "" histogram"" << std::endl;; ; TH1D * h1 = new TH1D(""h1"",""h1"",100,xmin,xmax);; TH1D * h2 = new TH1D(""h2"",""h2"",100,xmin,xmax);; h1->FillRandom(fname,n1);; ; TH1D * h1_s = new TH1D(*h1);; h1_s->SetName(""h1_s"");; h1_s->Smooth();; ; h2->FillRandom(fname,n2);; ; double p1 = h1->Chi2Test(h2,"""");; double p2 = h1_s->Chi2Test(h2,""UU"");; if (p2 < p1) Error(""testSmooth"",""TH1::Smooth is not working correctly - a worst chi2 is obtained"");; ; std::cout << "" chi2 test non-smoothed histo "" << p1 << std::endl;; std::cout << "" chi2 test smoothed histo "" << p2 << std::endl;; ; double a1 = h1->AndersonDarlingTest(h2);; double a2 = h1_s->AndersonDarlingTest(h2);; ; std::cout << "" AD test non-smoothed histo "" << a1 << std::endl;; std::cout << "" AD test smoothed histo "" << a2 << std::endl;; ; double k1 = h1->KolmogorovTest(h2);; double k2 = h1_s->KolmogorovTest(h2);; ; std::cout << "" KS test non-smoothed histo "" << k1 << std::endl;; std::cout << "" KS test smoothed histo "" << k2 << std::endl;; ; c1->cd(ipad++);; h1->Draw(""E"");; h1_s->SetLineColor(kRed);; h1_s->Draw(""same"");; h2->Scale(double(n1)/n2);; h2->SetLineColor(kGreen);; h2->Draw(""same"");; }; ; void testSmooth(int n1 = 1000, int n2 = 1000000) {; ; TH1::AddDirectory(false);; ; c1 = new TCanvas();; c1->Divide(1,3);; ; ; smooth_hist(""gaus"",-5,5,n1,n2);; smooth_hist(""landau"",-5,15,n1,n2);; smooth_hist(""expo"",-5,0,n1,n2);; ; }; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; xminfloat xminDefi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/testSmooth_8C.html:95,Load,Loading,95,doc/master/testSmooth_8C.html,https://root.cern,https://root.cern/doc/master/testSmooth_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/th2polyBoxes.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. th2polyBoxes.C File ReferenceTutorials » Histograms tutorials. Detailed Description; This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly). ; The bins are boxes. ; TCanvas *th2polyBoxes() {; TCanvas *ch2p2 = new TCanvas(""ch2p2"",""ch2p2"",600,400);; gStyle->SetPalette(57);; TH2Poly *h2p = new TH2Poly();; h2p->SetName(""Boxes"");; h2p->SetTitle(""Boxes"");; ; Int_t i,j;; Int_t nx = 40;; Int_t ny = 40;; Double_t xval1,yval1,xval2,yval2;; Double_t dx=0.2, dy=0.1;; xval1 = 0.;; xval2 = dx;; ; for (i = 0; i<nx; i++) {; yval1 = 0.;; yval2 = dy;; for (j = 0; j<ny; j++) {; h2p->AddBin(xval1, yval1, xval2, yval2);; yval1 = yval2;; yval2 = yval2+yval2*dy;; }; xval1 = xval2;; xval2 = xval2+xval2*dx;; }; ; TRandom ran;; for (i = 0; i<300000; i++) {; h2p->Fill(50*ran.Gaus(2.,1), ran.Gaus(2.,1));; }; ; h2p->Draw(""COLZ"");; return ch2p2;; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1::SetTitlevoid SetTitle(const char *title) overrideChange/set the title.Definition TH1.cxx:6718; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH2Poly2D Histogram with Polygonal BinsDefinition TH2Poly.h:66; TH2Poly::FillInt_t Fill(Double_t x, Double_t y) overrideIncrement the bin containing (x,y) by 1.Definition TH2Poly.cxx:664; TH2Poly::AddBinvirtual Int_t AddBin(TObject *poly)Adds a new bin to the histogram.Definition TH2Poly.cxx:297; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/th2polyBoxes_8C.html:97,Load,Loading,97,doc/master/th2polyBoxes_8C.html,https://root.cern,https://root.cern/doc/master/th2polyBoxes_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/th2polyEurope.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. th2polyEurope.C File ReferenceTutorials » Histograms tutorials. Detailed Description; This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it. ; The initial data are stored in TMultiGraphs. They represent the european countries. The histogram filling is done according to a Mercator projection, therefore the bin contains should be proportional to the real surface of the countries.; The initial data have been downloaded from: http://www.maproom.psu.edu/dcw/ This database was developed in 1991/1992 and national boundaries reflect political reality as of that time.; The script is shooting npoints (script argument) randomly over the Europe area. The number of points inside the countries should be proportional to the country surface The estimated surface is compared to the surfaces taken from wikipedia. ; Partitioning: Real Time = 1.31 seconds Cpu Time = 1.31 seconds; Filling : Real Time = 4.01 seconds Cpu Time = 4.01 seconds; THPoly Europe surface estimation error wrt wikipedia = 1.260096 per cent when using 500000 points; ; void th2polyEurope(Int_t npoints=500000); {; Int_t i,j;; Double_t lon1 = -25;; Double_t lon2 = 35;; Double_t lat1 = 34;; Double_t lat2 = 72;; Double_t R = (lat2-lat1)/(lon2-lon1);; Int_t W = 800;; Int_t H = (Int_t)(R*800);; gStyle->SetStatX(0.28);; gStyle->SetStatY(0.45);; gStyle->SetStatW(0.15);; ; // Canvas used to draw TH2Poly (the map); TCanvas *ce = new TCanvas(""ce"", ""ce"",0,0,W,H);; ce->ToggleEventStatus();; ce->SetGridx();; ce->SetGridy();; ; // Real surfaces taken from Wikipedia.; const Int_t nx = 36;; // see http://en.wikipedia.org/wiki/Area_and_population_of_European_countries; const char *countries[nx] = {; ""france"", ""spain"", ""sweden"", ""germany"", ""finland"",; ""norway"", ""poland"", ""italy"", ""yugoslavia"", ""united_kingdom"",; ""romania"", ""belarus"",""greece"", ""czechoslov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/th2polyEurope_8C.html:98,Load,Loading,98,doc/master/th2polyEurope_8C.html,https://root.cern,https://root.cern/doc/master/th2polyEurope_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/th2polyHoneycomb.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. th2polyHoneycomb.C File ReferenceTutorials » Histograms tutorials. Detailed Description; This tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly). ; The method TH2Poly::Honeycomb allows to build automatically an honeycomb binning.; ; void th2polyHoneycomb(){; TCanvas *C = new TCanvas(""C"", ""C"", 1200, 600);; C->Divide(2,1);; ; TH2Poly *hc1 = new TH2Poly();; hc1->Honeycomb(0, 0, .1, 5, 5);; hc1->SetTitle(""Option V (default)"");; hc1->SetStats(0);; hc1->Fill(.1, .1, 15.);; hc1->Fill(.4, .4, 10.);; hc1->Fill(.5, .5, 20.);; ; TH2Poly *hc2 = new TH2Poly();; hc2->Honeycomb(0, 0, .1, 5, 5, ""h"");; hc2->SetTitle(""Option H"");; hc2->SetStats(0);; hc2->Fill(.1, .1, 15.);; hc2->Fill(.4, .4, 10.);; hc2->Fill(.5, .5, 20.);; ; C->cd(1)->SetGrid();; hc1->Draw(""colz L"");; C->cd(2)->SetGrid();; hc2->Draw(""colz L"");; }; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1::SetTitlevoid SetTitle(const char *title) overrideChange/set the title.Definition TH1.cxx:6718; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::SetStatsvirtual void SetStats(Bool_t stats=kTRUE)Set statistics option on/off.Definition TH1.cxx:8990; TH2Poly2D Histogram with Polygonal BinsDefinition TH2Poly.h:66; TH2Poly::FillInt_t Fill(Double_t x, Double_t y) overrideIncrement the bin containing (x,y) by 1.Definition TH2Poly.cxx:664; TH2Poly::Honeycombvoid Honeycomb(Double_t xstart, Double_t ystart, Double_t a, Int_t k, Int_t s, Option_t *option=""v"")Bins the histogram using a honeycomb structure If the option ""v"" is specified, the hexagons are drawn...Definition TH2Poly.cxx:1026; . AuthorOlivier Couet ; Definition in file th2polyHoneycomb.C. tutorialshistth2polyHoneycomb.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/th2polyHoneycomb_8C.html:101,Load,Loading,101,doc/master/th2polyHoneycomb_8C.html,https://root.cern,https://root.cern/doc/master/th2polyHoneycomb_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/th2polyUSA.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. th2polyUSA.C File ReferenceTutorials » Histograms tutorials. Detailed Description; This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option. ; The initial data are stored in TMultiGraphs. They represent the USA map. Such histograms can be rendered in 3D using the option legogl.; The initial data have been downloaded from: http://www.maproom.psu.edu/dcw/ This database was developed in 1991/1992 and national boundaries reflect political reality as of that time.; ; void th2polyUSA(); {; Int_t i, bin;; const Int_t nx = 48;; const char *states [nx] = {; ""alabama"", ""arizona"", ""arkansas"", ""california"",; ""colorado"", ""connecticut"", ""delaware"", ""florida"",; ""georgia"", ""idaho"", ""illinois"", ""indiana"",; ""iowa"", ""kansas"", ""kentucky"", ""louisiana"",; ""maine"", ""maryland"", ""massachusetts"", ""michigan"",; ""minnesota"", ""mississippi"", ""missouri"", ""montana"",; ""nebraska"", ""nevada"", ""new_hampshire"", ""new_jersey"",; ""new_mexico"", ""new_york"", ""north_carolina"", ""north_dakota"",; ""ohio"", ""oklahoma"", ""oregon"", ""pennsylvania"",; ""rhode_island"", ""south_carolina"", ""south_dakota"", ""tennessee"",; ""texas"", ""utah"", ""vermont"", ""virginia"",; ""washington"", ""west_virginia"", ""wisconsin"", ""wyoming""; };; Double_t pop[nx] = {; 4708708, 6595778, 2889450, 36961664, 5024748, 3518288, 885122, 18537969,; 9829211, 1545801, 12910409, 6423113, 3007856, 2818747, 4314113, 4492076,; 1318301, 5699478, 6593587, 9969727, 5266214, 2951996, 5987580, 974989,; 1796619, 2643085, 1324575, 8707739, 2009671, 19541453, 9380884, 646844,; 11542645, 3687050, 3825657, 12604767, 1053209, 4561242, 812383, 6296254,; 24782302, 2784572, 621760, 7882590, 6664195, 1819777, 5654774, 544270; };; ; TCanvas *usa = new TCanvas(""USA"", ""USA"");; usa->ToggleEventStatus();; Double_t lon1 = -130;; Double_t lon2 = -65;; Double_t lat1 = 24;; Double_t lat2 = 50;; TH2Po",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/th2polyUSA_8C.html:95,Load,Loading,95,doc/master/th2polyUSA_8C.html,https://root.cern,https://root.cern/doc/master/th2polyUSA_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/thstack2palettecolor.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. thstack2palettecolor.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Palette coloring for 2D histograms' stack is activated thanks to the option PFC (Palette Fill Color). ; When this option is given to THStack::Draw the histograms in the THStack get their color from the current color palette defined by gStyle->SetPalette(...). The color is determined according to the number of histograms.; In this example four 2D histograms are displayed with palette coloring. The color of each graph is picked inside the palette number 1. ; void thstack2palettecolor() ; {; gStyle->SetPalette(1);; auto h1 = new TH2F(""h1"",""h1"",20,0,6,20,-4,4);; auto h2 = new TH2F(""h2"",""h2"",20,0,6,20,-4,4);; auto h3 = new TH2F(""h3"",""h3"",20,0,6,20,-4,4);; auto h4 = new TH2F(""h4"",""h4"",20,0,6,20,-4,4);; auto h5 = new TH2F(""h5"",""h5"",20,0,6,20,-4,4);; h2->Fill(2.,0.,5);; h3->Fill(3.,0.,10);; h4->Fill(4.,0.,15);; h5->Fill(5.,0.,20);; auto hs = new THStack(""hs"",""Test of palette colored lego stack"");; hs->Add(h1);; hs->Add(h2);; hs->Add(h3);; hs->Add(h4);; hs->Add(h5);; hs->Draw(""0lego1 PFC"");; }; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; THStackThe Histogram stack class.Definition THStack.h:40; TStyle::SetPalettevoid SetPalette(Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.)See TColor::SetPalette.Definition TStyle.cxx:1888; h1TH1F * h1Definition legend1.C:5; AuthorOlivier Couet ; Definition in file thstack2palettecolor.C. tutorialshistthstack2palettecolor.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/thstack2palettecolor_8C.html:105,Load,Loading,105,doc/master/thstack2palettecolor_8C.html,https://root.cern,https://root.cern/doc/master/thstack2palettecolor_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/thstackcolorscheme.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. thstackcolorscheme.C File ReferenceTutorials » Histograms tutorials. Detailed Description; This example demonstrates how to use the accessible color schemes with THStack. ; In this example, the color scheme with six colors is used. It also shows that the grayscale version is an acceptable alternative. ; void thstackcolorscheme(); {; auto c1 = new TCanvas();; auto hs = new THStack(""hs"",""Stacked 1D histograms colored using 6-colors scheme"");; ; // Create six 1-d histograms and add them in the stack; auto h1st = new TH1F(""h1st"",""A"",100,-4,4);; h1st->FillRandom(""gaus"",20000);; h1st->SetFillColor(kP6Blue);; hs->Add(h1st);; ; auto h2st = new TH1F(""h2st"",""B"",100,-4,4);; h2st->FillRandom(""gaus"",15000);; h2st->SetFillColor(kP6Yellow);; hs->Add(h2st);; ; auto h3st = new TH1F(""h3st"",""C"",100,-4,4);; h3st->FillRandom(""gaus"",10000);; h3st->SetFillColor(kP6Red);; hs->Add(h3st);; ; auto h4st = new TH1F(""h4st"",""D"",100,-4,4);; h4st->FillRandom(""gaus"",10000);; h4st->SetFillColor(kP6Grape);; hs->Add(h4st);; ; auto h5st = new TH1F(""h5st"",""E"",100,-4,4);; h5st->FillRandom(""gaus"",10000);; h5st->SetFillColor(kP6Gray);; hs->Add(h5st);; ; auto h6st = new TH1F(""h6st"",""F"",100,-4,4);; h6st->FillRandom(""gaus"",10000);; h6st->SetFillColor(kP6Violet);; hs->Add(h6st);; ; // draw the stack with colors; hs->Draw();; TLegend *l = gPad->BuildLegend(.8,.55,1.,.9,"""",""F"");; l->SetLineWidth(0);; l->SetFillStyle(0);; ; // draw the stack using gray-scale; auto c2 = new TCanvas();; c2->SetGrayscale();; hs->Draw();; l->Draw();; }; kP6Red@ kP6RedDefinition Rtypes.h:69; kP6Grape@ kP6GrapeDefinition Rtypes.h:69; kP6Gray@ kP6GrayDefinition Rtypes.h:69; kP6Yellow@ kP6YellowDefinition Rtypes.h:69; kP6Violet@ kP6VioletDefinition Rtypes.h:69; kP6Blue@ kP6BlueDefinition Rtypes.h:69; gPad#define gPadDefinition TVirtualPad.h:308; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/thstackcolorscheme_8C.html:103,Load,Loading,103,doc/master/thstackcolorscheme_8C.html,https://root.cern,https://root.cern/doc/master/thstackcolorscheme_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/thstackpalettecolor.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. thstackpalettecolor.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Palette coloring for histograms' stack is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; When one of these options is given to THStack::Draw the histograms in the THStack get their color from the current color palette defined by gStyle->SetPalette(...). The color is determined according to the number of histograms.; In this example four histograms are displayed with palette coloring. The color of each histogram is picked inside the palette kOcean. ; void thstackpalettecolor(); {; auto hs = new THStack(""hs"",""Stacked 1D histograms colored using kOcean palette"");; ; gStyle->SetPalette(kOcean);; ; // Create three 1-d histograms and add them in the stack; auto h1st = new TH1F(""h1st"",""test hstack"",100,-4,4);; h1st->FillRandom(""gaus"",20000);; hs->Add(h1st);; ; auto h2st = new TH1F(""h2st"",""test hstack"",100,-4,4);; h2st->FillRandom(""gaus"",15000);; hs->Add(h2st);; ; auto h3st = new TH1F(""h3st"",""test hstack"",100,-4,4);; h3st->FillRandom(""gaus"",10000);; hs->Add(h3st);; ; // draw the stack; hs->Draw(""pfc nostack"");; }; kOcean@ kOceanDefinition TColor.h:119; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; THStackThe Histogram stack class.Definition THStack.h:40; TStyle::SetPalettevoid SetPalette(Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.)See TColor::SetPalette.Definition TStyle.cxx:1888; AuthorOlivier Couet ; Definition in file thstackpalettecolor.C. tutorialshistthstackpalettecolor.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/thstackpalettecolor_8C.html:104,Load,Loading,104,doc/master/thstackpalettecolor_8C.html,https://root.cern,https://root.cern/doc/master/thstackpalettecolor_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/tprofile2polyRealistic.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tprofile2polyRealistic.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Different charges depending on region . ; #include <iostream>; #include <fstream>; #include <TProfile2Poly.h>; #include <TProfile2D.h>; #include <TCanvas.h>; #include <TRandom.h>; #include <TROOT.h>; ; void tprofile2polyRealistic(Int_t numEvents=100000); {; int NUM_LS = 8;; TCanvas *c1 = new TCanvas(""c1"", ""moving charge"", 900, 400);; TCanvas *c2 = new TCanvas(""c2"", ""Merge Individual moving charge plots"", 800, 400);; ; c1->Divide(NUM_LS, 3);; c2->Divide(3,1);; ; // -------------------- Construct Reference plot bins ------------------------; auto new_avg = new TProfile2Poly();; ; auto tot_avg_ls = new TProfile2Poly[NUM_LS];; auto det_avg_ls = new TProfile2Poly[NUM_LS];; auto det_err_ls = new TProfile2Poly[NUM_LS];; auto tot_merge = new TProfile2Poly();; auto det_avg_merge = new TProfile2Poly();; auto det_err_merge = new TProfile2Poly();; ; float minx = -15;; float maxx = 15;; float miny = -15;; float maxy = 15;; float binsz = 0.5;; ; for (float i = minx; i < maxx; i += binsz) {; for (float j = miny; j < maxy; j += binsz) {; tot_merge->AddBin(i, j, i + binsz, j + binsz);; for (int l = 0; l < NUM_LS; ++l) {; tot_avg_ls[l].AddBin(i, j, i + binsz, j + binsz);; }; }; }; ; // -------------------- Construct detector bins ------------------------; auto h2p = new TH2Poly();; auto tp2p = new TProfile2Poly();; std::ifstream infile;; TString dir = gROOT->GetTutorialDir();; dir.Append(""/hist/data/tprofile2poly_tutorial.data"");; infile.open(dir.Data());; ; if (!infile) // Verify that the file was open successfully; {; std::cerr << dir.Data() << std::endl; // Report error; std::cerr << ""Error code: "" << std::strerror(errno) << std::endl; // Get some info as to why; return;; }; std::cout << "" WE ARE AFTER LOADING DATA "" << std::endl;; ; std::vector<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tprofile2polyRealistic_8C.html:107,Load,Loading,107,doc/master/tprofile2polyRealistic_8C.html,https://root.cern,https://root.cern/doc/master/tprofile2polyRealistic_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/tprofile2polyRealisticModuleError.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tprofile2polyRealisticModuleError.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Simulate faulty detector panel w.r.t. ; particle charge. ; #include <iostream>; #include <fstream>; #include <vector>; ; void tprofile2polyRealisticModuleError(Int_t numEvents = 1000000); {; TCanvas *c1 = new TCanvas(""c1"", ""4 Malfunctioning Panels"", 800, 400);; c1->Divide(3, 1);; ; // -------------------- Construct detector bins ------------------------; auto th2p = new TH2Poly();; auto avg = new TProfile2Poly();; auto err = new TProfile2Poly();; ; std::ifstream infile;; TString dir = gROOT->GetTutorialDir();; dir.Append(""/hist/data/tprofile2poly_tutorial.data"");; infile.open(dir.Data());; ; if (!infile) // Verify that the file was open successfully; {; std::cerr << dir.Data() << std::endl; // Report error; std::cerr << ""Error code: "" << std::strerror(errno) << std::endl; // Get some info as to why; return;; }; ; std::vector<std::pair<Double_t, Double_t>> allCoords;; Double_t a, b;; while (infile >> a >> b) ; allCoords.emplace_back(a, b);; ; if (allCoords.size() % 3 != 0) {; std::cout << ""[ERROR] Bad file"" << std::endl;; return;; }; ; Double_t x[3], y[3];; for (Int_t i = 0; i < allCoords.size(); i += 3) {; x[0] = allCoords[i + 0].first;; y[0] = allCoords[i + 0].second;; x[1] = allCoords[i + 1].first;; y[1] = allCoords[i + 1].second;; x[2] = allCoords[i + 2].first;; y[2] = allCoords[i + 2].second;; th2p->AddBin(3, x, y);; avg->AddBin(3, x, y);; err->AddBin(3, x, y);; }; ; // -------------------- Generate particles ------------------------; TRandom ran;; for (int j = 0; j < numEvents; ++j) {; Double_t r1 = ran.Gaus(0, 10);; Double_t r2 = ran.Gaus(0, 8);; Double_t rok = ran.Gaus(20, 2);; Double_t rbad1 = ran.Gaus(1, 2);; Double_t rbad2 = ran.Gaus(2, 0);; ; Double_t val = rok;; // -------------------- Malfunctioni",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tprofile2polyRealisticModuleError_8C.html:118,Load,Loading,118,doc/master/tprofile2polyRealisticModuleError_8C.html,https://root.cern,https://root.cern/doc/master/tprofile2polyRealisticModuleError_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/transpad.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. transpad.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Example of a canvas showing two histograms with different scales. ; The second histogram is drawn in a transparent pad. ; void transpad(); {; TCanvas *c1 = new TCanvas(""c1"",""transparent pad"",200,10,700,500);; TPad *pad1 = new TPad(""pad1"","""",0,0,1,1);; TPad *pad2 = new TPad(""pad2"","""",0,0,1,1);; pad2->SetFillStyle(4000); //will be transparent; pad1->Draw();; pad1->cd();; ; TH1F *h1 = new TH1F(""h1"",""h1"",100,-3,3);; TH1F *h2 = new TH1F(""h2"",""h2"",100,-3,3);; TRandom r;; for (Int_t i=0;i<100000;i++) {; Double_t x1 = r.Gaus(-1,0.5);; Double_t x2 = r.Gaus(1,1.5);; if (i <1000) h1->Fill(x1);; h2->Fill(x2);; }; h1->Draw();; pad1->Update(); //this will force the generation of the ""stats"" box; TPaveStats *ps1 = (TPaveStats*)h1->GetListOfFunctions()->FindObject(""stats"");; ps1->SetX1NDC(0.4); ps1->SetX2NDC(0.6);; pad1->Modified();; c1->cd();; ; //compute the pad range with suitable margins; Double_t ymin = 0;; Double_t ymax = 2000;; Double_t dy = (ymax-ymin)/0.8; //10 per cent margins top and bottom; Double_t xmin = -3;; Double_t xmax = 3;; Double_t dx = (xmax-xmin)/0.8; //10 per cent margins left and right; pad2->Range(xmin-0.1*dx,ymin-0.1*dy,xmax+0.1*dx,ymax+0.1*dy);; pad2->Draw();; pad2->cd();; h2->SetLineColor(kRed);; h2->Draw(""][sames"");; pad2->Update();; TPaveStats *ps2 = (TPaveStats*)h2->GetListOfFunctions()->FindObject(""stats"");; ps2->SetX1NDC(0.65); ps2->SetX2NDC(0.85);; ps2->SetTextColor(kRed);; ; // draw axis on the right side of the pad; TGaxis *axis = new TGaxis(xmax,ymin,xmax,ymax,ymin,ymax,50510,""+L"");; axis->SetLabelColor(kRed);; axis->Draw();; }; ; ; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; kRed@ kRedDefinition Rtypes.h:66; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/transpad_8C.html:93,Load,Loading,93,doc/master/transpad_8C.html,https://root.cern,https://root.cern/doc/master/transpad_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/twoscales.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. twoscales.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad. . ; #include ""TCanvas.h""; #include ""TStyle.h""; #include ""TH1.h""; #include ""TGaxis.h""; #include ""TRandom.h""; ; void twoscales(); {; TCanvas *c1 = new TCanvas(""c1"",""hists with different scales"",600,400);; ; //create/fill draw h1; gStyle->SetOptStat(kFALSE);; TH1F *h1 = new TH1F(""h1"",""my histogram"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) h1->Fill(gRandom->Gaus(0,1));; h1->Draw();; c1->Update();; ; //create hint1 filled with the bins integral of h1; TH1F *hint1 = new TH1F(""hint1"",""h1 bins integral"",100,-3,3);; Float_t sum = 0;; for (i=1;i<=100;i++) {; sum += h1->GetBinContent(i);; hint1->SetBinContent(i,sum);; }; ; //scale hint1 to the pad coordinates; Float_t rightmax = 1.1*hint1->GetMaximum();; Float_t scale = gPad->GetUymax()/rightmax;; hint1->SetLineColor(kRed);; hint1->Scale(scale);; hint1->Draw(""same"");; ; //draw an axis on the right side; TGaxis *axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; gPad->GetUxmax(), gPad->GetUymax(),0,rightmax,510,""+L"");; axis->SetLineColor(kRed);; axis->SetLabelColor(kRed);; axis->Draw();; }; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kRed@ kRedDefinition Rtypes.h:66; TCanvas.h; TGaxis.h; TH1.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; gPad#define gPadDefinition TVirtualPad.h:308; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TGaxisThe axis painter class.Definition TGaxis.h:24; TGaxis::SetLabelColorvoid SetL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/twoscales_8C.html:94,Load,Loading,94,doc/master/twoscales_8C.html,https://root.cern,https://root.cern/doc/master/twoscales_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/twoscales.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. twoscales.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_hist; 3/// \notebook; 4/// Example of macro illustrating how to superimpose two histograms; 5/// with different scales in the ""same"" pad.; 6///; 7/// \macro_image; 8/// \macro_code; 9///; 10/// \author Rene Brun; 11 ; 12#include ""TCanvas.h""; 13#include ""TStyle.h""; 14#include ""TH1.h""; 15#include ""TGaxis.h""; 16#include ""TRandom.h""; 17 ; 18void twoscales(); 19{; 20 TCanvas *c1 = new TCanvas(""c1"",""hists with different scales"",600,400);; 21 ; 22 //create/fill draw h1; 23 gStyle->SetOptStat(kFALSE);; 24 TH1F *h1 = new TH1F(""h1"",""my histogram"",100,-3,3);; 25 Int_t i;; 26 for (i=0;i<10000;i++) h1->Fill(gRandom->Gaus(0,1));; 27 h1->Draw();; 28 c1->Update();; 29 ; 30 //create hint1 filled with the bins integral of h1; 31 TH1F *hint1 = new TH1F(""hint1"",""h1 bins integral"",100,-3,3);; 32 Float_t sum = 0;; 33 for (i=1;i<=100;i++) {; 34 sum += h1->GetBinContent(i);; 35 hint1->SetBinContent(i,sum);; 36 }; 37 ; 38 //scale hint1 to the pad coordinates; 39 Float_t rightmax = 1.1*hint1->GetMaximum();; 40 Float_t scale = gPad->GetUymax()/rightmax;; 41 hint1->SetLineColor(kRed);; 42 hint1->Scale(scale);; 43 hint1->Draw(""same"");; 44 ; 45 //draw an axis on the right side; 46 TGaxis *axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; 47 gPad->GetUxmax(), gPad->GetUymax(),0,rightmax,510,""+L"");; 48 axis->SetLineColor(kRed);; 49 axis->SetLabelColor(kRed);; 50 axis->Draw();; 51}; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kRed@ kRedDefinition Rtypes.h:66; TCanvas.h; TGaxis.h; TH1.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; gPad#define gPadDefinition TVirtualPad.h:308; TAttLine::SetLineC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/twoscales_8C_source.html:91,Load,Loading,91,doc/master/twoscales_8C_source.html,https://root.cern,https://root.cern/doc/master/twoscales_8C_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/twoscales.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; twoscales.py File ReferenceTutorials » Histograms tutorials. Detailed Description; Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad. ; Inspired by work of Rene Brun. ; #include ""TCanvas.h""; #include ""TStyle.h""; #include ""TH1.h""; #include ""TGaxis.h""; #include ""TRandom.h""; ; import ROOT; ; c1 = ROOT.TCanvas(""c1"",""hists with different scales"",600,400); ; ROOT.gStyle.SetOptStat(False); ; h1 = ROOT.TH1F(""h1"",""my histogram"",100,-3,3); ; for i in range(10000) :; h1.Fill(ROOT.gRandom.Gaus(0,1)); ; h1.Draw(); c1.Update(); ; hint1 = ROOT.TH1F(""hint1"",""h1 bins integral"",100,-3,3); ; sum = 0; for i in range(1,101) :; sum += h1.GetBinContent(i); hint1.SetBinContent(i,sum); ; rightmax = 1.1*hint1.GetMaximum(); scale = ROOT.gPad.GetUymax()/rightmax; hint1.SetLineColor(ROOT.kRed); hint1.Scale(scale); hint1.Draw(""same""); ; axis = ROOT.TGaxis(ROOT.gPad.GetUxmax(),ROOT.gPad.GetUymin(),; ROOT.gPad.GetUxmax(), ROOT.gPad.GetUymax(),0,rightmax,510,""+L""); axis.SetLineColor(ROOT.kRed); axis.SetLabelColor(ROOT.kRed); axis.Draw(); AuthorAlberto Ferro ; Definition in file twoscales.py. tutorialshisttwoscales.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/twoscales_8py.html:95,Load,Loading,95,doc/master/twoscales_8py.html,https://root.cern,https://root.cern/doc/master/twoscales_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/twoscales.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. twoscales.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_hist; 3## \notebook; 4## Example of macro illustrating how to superimpose two histograms; 5## with different scales in the ""same"" pad.; 6## Inspired by work of Rene Brun.; 7##; 8## \macro_image; 9## \macro_code; 10##; 11## \author Alberto Ferro; 12 ; 13#include ""TCanvas.h""; 14#include ""TStyle.h""; 15#include ""TH1.h""; 16#include ""TGaxis.h""; 17#include ""TRandom.h""; 18 ; 19import ROOT; 20 ; 21c1 = ROOT.TCanvas(""c1"",""hists with different scales"",600,400); 22 ; 23ROOT.gStyle.SetOptStat(False); 24 ; 25h1 = ROOT.TH1F(""h1"",""my histogram"",100,-3,3); 26 ; 27for i in range(10000) :; 28 h1.Fill(ROOT.gRandom.Gaus(0,1)); 29 ; 30h1.Draw(); 31c1.Update(); 32 ; 33hint1 = ROOT.TH1F(""hint1"",""h1 bins integral"",100,-3,3); 34 ; 35sum = 0; 36for i in range(1,101) :; 37 sum += h1.GetBinContent(i); 38 hint1.SetBinContent(i,sum); 39 ; 40rightmax = 1.1*hint1.GetMaximum(); 41scale = ROOT.gPad.GetUymax()/rightmax; 42hint1.SetLineColor(ROOT.kRed); 43hint1.Scale(scale); 44hint1.Draw(""same""); 45 ; 46axis = ROOT.TGaxis(ROOT.gPad.GetUxmax(),ROOT.gPad.GetUymin(),; 47 ROOT.gPad.GetUxmax(), ROOT.gPad.GetUymax(),0,rightmax,510,""+L""); 48axis.SetLineColor(ROOT.kRed); 49axis.SetLabelColor(ROOT.kRed); 50axis.Draw(). tutorialshisttwoscales.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:09 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/twoscales_8py_source.html:92,Load,Loading,92,doc/master/twoscales_8py_source.html,https://root.cern,https://root.cern/doc/master/twoscales_8py_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/xyplot.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. xyplot.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Example showing how to produce a plot with an orthogonal axis system centered at (0,0). . ; void xyplot(); {; TCanvas *c = new TCanvas(""c"",""XY plot"",200,10,700,500);; ; // Remove the frame; c->SetFillColor(kWhite);; c->SetFrameLineColor(kWhite);; c->SetFrameBorderMode(0);; ; // Define and draw a curve the frame; const Int_t n = 4;; Double_t x[n] = {-1, -3, -9, 3};; Double_t y[n] = {-1000, 900, 300, 300};; TGraph* gr = new TGraph(n,x,y);; gr->SetTitle(""XY plot"");; gr->SetMinimum(-1080);; gr->SetMaximum(1080);; gr->SetLineColor(kRed);; gr->Draw(""AC*"");; ; // Remove the frame's axis; gr->GetHistogram()->GetYaxis()->SetTickLength(0);; gr->GetHistogram()->GetXaxis()->SetTickLength(0);; gr->GetHistogram()->GetYaxis()->SetLabelSize(0);; gr->GetHistogram()->GetXaxis()->SetLabelSize(0);; gr->GetHistogram()->GetXaxis()->SetAxisColor(0);; gr->GetHistogram()->GetYaxis()->SetAxisColor(0);; ; gPad->Update();; ; // Draw orthogonal axis system centered at (0,0).; // Draw the Y axis. Note the 4th label is erased with SetLabelAttributes; TGaxis *yaxis = new TGaxis(0, gPad->GetUymin(),; 0, gPad->GetUymax(),; gPad->GetUymin(),gPad->GetUymax(),6,""+LN"");; yaxis->ChangeLabel(4,-1,0.);; yaxis->Draw();; ; // Draw the Y-axis title.; TLatex *ytitle = new TLatex(-0.5,gPad->GetUymax(),""Y axis"");; ytitle->Draw();; ytitle->SetTextSize(0.03);; ytitle->SetTextAngle(90.);; ytitle->SetTextAlign(31);; ; // Draw the X axis; TGaxis *xaxis = new TGaxis(gPad->GetUxmin(), 0,; gPad->GetUxmax(), 0,; gPad->GetUxmin(),gPad->GetUxmax(),510,""+L"");; xaxis->Draw();; ; // Draw the X axis title.; TLatex *xtitle = new TLatex(gPad->GetUxmax(),-200.,""X axis"");; xtitle->Draw();; xtitle->SetTextAlign(31);; xtitle->SetTextSize(0.03);; }; c#define c(i)Definition RSha256.hxx:101; Int_tint Int_tDefinition RtypesCore.h:45;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/xyplot_8C.html:91,Load,Loading,91,doc/master/xyplot_8C.html,https://root.cern,https://root.cern/doc/master/xyplot_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hist/xyplot.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. xyplot.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_hist; 3/// \notebook; 4/// Example showing how to produce a plot with an orthogonal axis system; 5/// centered at (0,0).; 6///; 7/// \macro_image; 8/// \macro_code; 9///; 10/// \author Olivier Couet; 11 ; 12void xyplot(); 13{; 14 TCanvas *c = new TCanvas(""c"",""XY plot"",200,10,700,500);; 15 ; 16 // Remove the frame; 17 c->SetFillColor(kWhite);; 18 c->SetFrameLineColor(kWhite);; 19 c->SetFrameBorderMode(0);; 20 ; 21 // Define and draw a curve the frame; 22 const Int_t n = 4;; 23 Double_t x[n] = {-1, -3, -9, 3};; 24 Double_t y[n] = {-1000, 900, 300, 300};; 25 TGraph* gr = new TGraph(n,x,y);; 26 gr->SetTitle(""XY plot"");; 27 gr->SetMinimum(-1080);; 28 gr->SetMaximum(1080);; 29 gr->SetLineColor(kRed);; 30 gr->Draw(""AC*"");; 31 ; 32 // Remove the frame's axis; 33 gr->GetHistogram()->GetYaxis()->SetTickLength(0);; 34 gr->GetHistogram()->GetXaxis()->SetTickLength(0);; 35 gr->GetHistogram()->GetYaxis()->SetLabelSize(0);; 36 gr->GetHistogram()->GetXaxis()->SetLabelSize(0);; 37 gr->GetHistogram()->GetXaxis()->SetAxisColor(0);; 38 gr->GetHistogram()->GetYaxis()->SetAxisColor(0);; 39 ; 40 gPad->Update();; 41 ; 42 // Draw orthogonal axis system centered at (0,0).; 43 // Draw the Y axis. Note the 4th label is erased with SetLabelAttributes; 44 TGaxis *yaxis = new TGaxis(0, gPad->GetUymin(),; 45 0, gPad->GetUymax(),; 46 gPad->GetUymin(),gPad->GetUymax(),6,""+LN"");; 47 yaxis->ChangeLabel(4,-1,0.);; 48 yaxis->Draw();; 49 ; 50 // Draw the Y-axis title.; 51 TLatex *ytitle = new TLatex(-0.5,gPad->GetUymax(),""Y axis"");; 52 ytitle->Draw();; 53 ytitle->SetTextSize(0.03);; 54 ytitle->SetTextAngle(90.);; 55 ytitle->SetTextAlign(31);; 56 ; 57 // Draw the X axis; 58 TGaxis *xaxis = new TGaxis(gPad->GetUxmin(), 0,; 59 gPad->GetUxmax(), 0,; 60 gPad->GetUxmin(),gPad->GetUxmax(),510,""+L"");; 61 xax",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/xyplot_8C_source.html:88,Load,Loading,88,doc/master/xyplot_8C_source.html,https://root.cern,https://root.cern/doc/master/xyplot_8C_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/hsimple.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. hsimple.C File ReferenceTutorials. Detailed Description; This program creates : . a one dimensional histogram; a two dimensional histogram; a profile histogram; a memory-resident ntuple. These objects are filled with some random numbers and saved on a file. If get=1 the macro returns a pointer to the TFile of ""hsimple.root"" if this file exists, otherwise it is created. The file ""hsimple.root"" is created in $ROOTSYS/tutorials if the caller has write access to this directory, otherwise the file is created in $PWD. ; hsimple : Real Time = 0.08 seconds Cpu Time = 0.08 seconds; (TFile *) 0x55fa02b55090; ; #include <TFile.h>; #include <TNtuple.h>; #include <TH2.h>; #include <TProfile.h>; #include <TCanvas.h>; #include <TFrame.h>; #include <TROOT.h>; #include <TSystem.h>; #include <TRandom3.h>; #include <TBenchmark.h>; #include <TInterpreter.h>; ; TFile *hsimple(Int_t getFile=0); {; TString filename = ""hsimple.root"";; TString dir = gROOT->GetTutorialDir();; dir.ReplaceAll(""/./"",""/"");; TFile *hfile = nullptr;; if (getFile) {; // if the argument getFile =1 return the file ""hsimple.root""; // if the file does not exist, it is created; TString fullPath = dir+""hsimple.root"";; if (!gSystem->AccessPathName(fullPath,kFileExists)) {; hfile = TFile::Open(fullPath); //in $ROOTSYS/tutorials; if (hfile) return hfile;; }; //otherwise try $PWD/hsimple.root; if (!gSystem->AccessPathName(""hsimple.root"",kFileExists)) {; hfile = TFile::Open(""hsimple.root""); //in current dir; if (hfile) return hfile;; }; }; //no hsimple.root file found. Must generate it !; //generate hsimple.root in current directory if we have write access; if (gSystem->AccessPathName(""."",kWritePermission)) {; printf(""you must run the script in a directory with write access\n"");; return nullptr;; }; hfile = (TFile*)gROOT->FindObject(filename); if (hfile) hfile->Close();; hfile = new TFile(filename,""RECRE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsimple_8C.html:87,Load,Loading,87,doc/master/hsimple_8C.html,https://root.cern,https://root.cern/doc/master/hsimple_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/io Directory Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. io Directory Reference. Directory dependency graph for io:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files;  copyFiles.C;   Example of script showing how to copy all objects (including directories) from a source file. ;  ;  dirs.C;   This macro illustrates how to create a hierarchy of directories in a Root file. ;  ;  double32.C;   Tutorial illustrating use and precision of the Double32_t data type You should run this tutorial with ACLIC: a dictionary will be automatically created. ;  ;  fildir.C;   This macro displays the ROOT Directory data structure ;  ;  file.C;   This macro displays the physical ROOT file structure ;  ;  float16.C;   Tutorial illustrating use and precision of the Float16_t data type. ;  ;  hadd.C;   Macro to add histogram files This macro is kept for didactical purposes only: use instead the executable $ROOTSYS/bin/hadd ! ;  ;  importCode.C;   Example of script showing how to create a ROOT file with subdirectories. ;  ;  loopdir.C;   Example script to loop over all the objects of a ROOT file directory and print in Postscript all the TH1 derived objects. ;  ;  loopdir11.C;   Example script to loop over all the objects of a ROOT file directory and print in Postscript all the TH1 derived objects. ;  ;  mergeSelective.C;   Merge only part of the content of a set of files. ;  ;  readCode.C;   Example of script showing how to navigate in a ROOT file with sub-directories and read the objects in each sub-directory. ;  ;  testMergeCont.C;   Macro demonstrating the merging of containers. ;  ;  testTMPIFile.C;  This macro shows the usage of TMPIFile to simulate event reconstruction and merging them in parallel. ;  . tutorialsio. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_715fafd9bc85e47ed5557926189f8f1b.html:85,Load,Loading,85,doc/master/dir_715fafd9bc85e47ed5557926189f8f1b.html,https://root.cern,https://root.cern/doc/master/dir_715fafd9bc85e47ed5557926189f8f1b.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/io/double32.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. double32.C File ReferenceTutorials » IO tutorials. Detailed Description; Tutorial illustrating use and precision of the Double32_t data type You should run this tutorial with ACLIC: a dictionary will be automatically created. ; root > .x double32.C+; The following cases are supported for streaming a Double32_t type depending on the range declaration in the comment field of the data member:. Case Declaration . A Double32_t fNormal; . B Double32_t fTemperature; //[0,100] . C Double32_t fCharge; //[-1,1,2] . D Double32_t fVertex[3]; //[-30,30,10] . E Double32_t fChi2; //[0,0,6] . F Int_t fNsp;; Double32_t* fPointValue; //[fNsp][0,3] . Case A fNormal is converted from a Double_t to a Float_t; Case B fTemperature is converted to a 32 bit unsigned integer; Case C fCharge is converted to a 2 bits unsigned integer; Case D the array elements of fVertex are converted to an unsigned 10 bits integer; Case E fChi2 is converted to a Float_t with truncated precision at 6 bits; Case F the fNsp elements of array fPointvalue are converted to an unsigned 32 bit integer. Note that the range specifier must follow the dimension specifier. Case B has more precision than case A: 9 to 10 significative digits and 6 to 7 digits respectively. The range specifier has the general format: [xmin,xmax] or [xmin,xmax,nbits]. Examples; [0,1]; [-10,100];; [-pi,pi], [-pi/2,pi/4],[-2pi,2*pi]; [-10,100,16]; [0,0,8] Note that:; If nbits is not specified, or nbits <2 or nbits>32 it is set to 32; If (xmin==0 and xmax==0 and nbits <=14) the double word will be converted to a float and its mantissa truncated to nbits significative bits. IMPORTANT NOTE; Lets assume an original variable double x. When using the format [0,0,8] (i.e. range not specified) you get the best relative precision when storing and reading back the truncated x, say xt. The variance of (x-xt)/x will be better than",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/double32_8C.html:91,Load,Loading,91,doc/master/double32_8C.html,https://root.cern,https://root.cern/doc/master/double32_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/io/double32.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. double32.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_io; 3/// \notebook -js; 4/// Tutorial illustrating use and precision of the Double32_t data type; 5/// You should run this tutorial with ACLIC: a dictionary will be automatically; 6/// created.; 7/// ~~~{.bash}; 8/// root > .x double32.C+; 9/// ~~~; 10/// The following cases are supported for streaming a Double32_t type; 11/// depending on the range declaration in the comment field of the data member:; 12///; 13/// Case | Declaration; 14/// -----|------------; 15/// A | Double32_t fNormal;; 16/// B | Double32_t fTemperature; //[0,100]; 17/// C | Double32_t fCharge; //[-1,1,2]; 18/// D | Double32_t fVertex[3]; //[-30,30,10]; 19/// E | Double32_t fChi2; //[0,0,6]; 20/// F | Int_t fNsp;<br>Double32_t* fPointValue; //[fNsp][0,3]; 21///; 22/// * Case A fNormal is converted from a Double_t to a Float_t; 23/// * Case B fTemperature is converted to a 32 bit unsigned integer; 24/// * Case C fCharge is converted to a 2 bits unsigned integer; 25/// * Case D the array elements of fVertex are converted to an unsigned 10 bits integer; 26/// * Case E fChi2 is converted to a Float_t with truncated precision at 6 bits; 27/// * Case F the fNsp elements of array fPointvalue are converted to an unsigned 32 bit integer. Note that the range specifier must follow the dimension specifier.; 28///; 29/// Case B has more precision than case A: 9 to 10 significative digits and 6 to 7 digits respectively.; 30/// The range specifier has the general format: [xmin,xmax] or [xmin,xmax,nbits]. Examples; 31/// * [0,1]; 32/// * [-10,100];; 33/// * [-pi,pi], [-pi/2,pi/4],[-2pi,2*pi]; 34/// * [-10,100,16]; 35/// * [0,0,8]; 36/// Note that:; 37/// * If nbits is not specified, or nbits <2 or nbits>32 it is set to 32; 38/// * If (xmin==0 and xmax==0 and nbits <=14) the double word will be converted t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/double32_8C_source.html:88,Load,Loading,88,doc/master/double32_8C_source.html,https://root.cern,https://root.cern/doc/master/double32_8C_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/io/file.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. file.C File ReferenceTutorials » IO tutorials. Detailed Description; This macro displays the physical ROOT file structure . ; void file(){; ; TCanvas *c1 = new TCanvas(""c1"",""ROOT File description"",200,10,700,550);; ; c1->Range(0,-0.25,21,14);; TPaveLabel *title = new TPaveLabel(5,12,15,13.7,c1->GetTitle());; title->SetFillColor(16);; title->Draw();; ; // horizontal file layout; TPave *file = new TPave(1,8.5,20,11);; file->SetFillColor(11);; file->Draw();; TPave *fileh = new TPave(1,8.5,2.5,11);; fileh->SetFillColor(44);; fileh->Draw();; TPave *lrh = new TPave(2.5,8.5,3.3,11,1);; lrh->SetFillColor(33);; lrh->Draw();; lrh->DrawPave(6.9,8.5,7.7,11,1);; lrh->DrawPave(10.5,8.5,11.3,11,1);; lrh->DrawPave(14.5,8.5,15.3,11,1);; TLine *ldot = new TLine(1,8.5,0.5,6.5);; ldot->SetLineStyle(2);; ldot->Draw();; ldot->DrawLine(2.5, 8.5, 9.4, 6.5);; ldot->DrawLine(10.5, 8.5, 10, 6.5);; ldot->DrawLine(11.3, 8.5, 19.5, 6.5);; TLine *line = new TLine(2.6,11,2.6,11.5);; line->Draw();; line->DrawLine(2.6,11.5,7,11.5);; TArrow *arrow = new TArrow(7,11.5,7,11.1,0.01,""|>"");; arrow->SetFillStyle(1001);; arrow->Draw();; line->DrawLine( 7, 8.5, 7, 8.0);; line->DrawLine( 7, 8.0, 10.6, 8);; arrow->DrawArrow( 10.6,8, 10.6, 8.4,0.01,""|>"");; line->DrawLine( 10.6, 11, 10.6, 11.5);; line->DrawLine( 10.6, 11.5, 14.6, 11.5);; arrow->DrawArrow( 14.6,11.5, 14.6,11.1,0.01,""|>"");; line->DrawLine( 14.6, 8.5, 14.6, 8.0);; line->DrawLine( 14.6, 8.0, 16, 8);; ldot->DrawLine(16, 8, 19, 8);; TText *vert = new TText(1.5,9.75,""File"");; vert->SetTextAlign(21);; vert->SetTextAngle(90);; vert->SetTextSize(0.025);; vert->Draw();; vert->DrawText(2.0, 9.75,""Header"");; vert->DrawText(2.9, 9.75,""Logical Record"");; vert->DrawText(3.2, 9.75,""Header"");; vert->DrawText(7.3, 9.75,""Logical Record"");; vert->DrawText(7.6, 9.75,""Header"");; vert->DrawText(10.9,9.75,""Logical Record"");; vert->DrawText(11.2,9.7",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/file_8C.html:87,Load,Loading,87,doc/master/file_8C.html,https://root.cern,https://root.cern/doc/master/file_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/math/exampleFunctor.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. exampleFunctor.C File ReferenceTutorials » Math tutorials. Detailed Description; Tutorial illustrating how creating a TF1 class using functor or class member functions ; can be run with:; root > .x exampleFunctor.C; root > .x exampleFunctor.C+ with ACLIC. ; #include ""TF1.h""; #include ""TMath.h""; #include ""TLegend.h""; ; ; double MyFunc (double *x, double *p ) {; return TMath::Gaus(x[0],p[0],p[1] );; }; ; // function object (functor); struct MyDerivFunc {; MyDerivFunc(TF1 * f): fFunc(f) {}; double operator() (double *x, double * ) const {; return fFunc->Derivative(*x);; }; TF1 * fFunc;; };; // function class with a member function; struct MyIntegFunc {; MyIntegFunc(TF1 * f): fFunc(f) {}; double Integral (double *x, double * ) const {; double a = fFunc->GetXmin();; return fFunc->Integral(a, *x);; }; TF1 * fFunc;; };; ; ; ; void exampleFunctor() {; ; double xmin = -10; double xmax = 10;; ; // create TF1 using a free C function; TF1 * f1 = new TF1(""f1"",MyFunc,xmin,xmax,2);; f1->SetParameters(0.,1.);; f1->SetMaximum(3); f1->SetMinimum(-1);; f1->Draw();; ; // Derivative function; // example to create TF1 using a functor; ; // in order to work with interpreter the function object must be created and lived all time for all time; // of the TF1. In compiled mode, the function object can be passed by value (recommended) and there; // is also no need to specify the type of the function class. Example is as follows:; //; // `TF1 * f2 = new TF1(""f2"",MyDerivFunc(f1), xmin, xmax,0); // only for C++ compiled mode`; ; MyDerivFunc * deriv = new MyDerivFunc(f1);; TF1 * f2 = new TF1(""f2"",deriv, xmin, xmax, 0);; ; f2->SetLineColor(kBlue);; f2->Draw(""same"");; ; ; // integral function; // example to create a TF1 using a member function of a user class; ; // in order to work with interpreter the function object must be created and lived all time for all time;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/exampleFunctor_8C.html:99,Load,Loading,99,doc/master/exampleFunctor_8C.html,https://root.cern,https://root.cern/doc/master/exampleFunctor_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/math/principal.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. principal.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_math; 3## \notebook; 4## Principal Components Analysis (PCA) example; 5##; 6## Example of using TPrincipal as a stand alone class.; 7##; 8## I create n-dimensional data points, where c = trunc(n / 5) + 1; 9## are correlated with the rest n - c randomly distributed variables.; 10##; 11## Based on principal.C by Rene Brun and Christian Holm Christensen; 12##; 13## \macro_output; 14## \macro_code; 15##; 16## \authors Juan Fernando, Jaramillo Botero; 17 ; 18from ROOT import TPrincipal, gRandom, TBrowser, vector; 19 ; 20 ; 21n = 10; 22m = 10000; 23 ; 24c = int(n / 5) + 1; 25 ; 26print (""""""*************************************************; 27* Principal Component Analysis *; 28* *; 29* Number of variables: {0:4d} *; 30* Number of data points: {1:8d} *; 31* Number of dependent variables: {2:4d} *; 32* *; 33*************************************************"""""".format(n, m, c)); 34 ; 35# Initilase the TPrincipal object. Use the empty string for the; 36# final argument, if you don't wan't the covariance; 37# matrix. Normalising the covariance matrix is a good idea if your; 38# variables have different orders of magnitude.; 39principal = TPrincipal(n, ""ND""); 40 ; 41# Use a pseudo-random number generator; 42randomNum = gRandom; 43 ; 44# Make the m data-points; 45# Make a variable to hold our data; 46# Allocate memory for the data point; 47data = vector('double')(); 48for i in range(m):; 49 # First we create the un-correlated, random variables, according; 50 # to one of three distributions; 51 for j in range(n - c):; 52 if j % 3 == 0:; 53 data.push_back(randomNum.Gaus(5, 1)); 54 elif j % 3 == 1:; 55 data.push_back(randomNum.Poisson(8)); 56 else:; 57 data.push_back(randomNum.Exp(2)); 58 ; 59 # Then we create the correlated variables; 60 for j in range(c):; 61 data.push_b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/principal_8py_source.html:92,Load,Loading,92,doc/master/principal_8py_source.html,https://root.cern,https://root.cern/doc/master/principal_8py_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/math/testrandom.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. testrandom.C File ReferenceTutorials » Math tutorials. Detailed Description; Performance test of all the ROOT random generator (TRandom, TRandom1, TRandom2 and TRandom3) Tests the generator TRandom3 against some ref values and creates a timing table against TRandom, TRandom1 and TRandom2. ; E.g. on an an Intel Xeon Quad-core Harpertown (E5410) 2.33 GHz running Linux SLC4 64 bit and compiled with gcc 3.4; Distribution nanoseconds/call; TRandom TRandom1 TRandom2 TRandom3; Rndm.............. 5.000 105.000 7.000 10.000; RndmArray......... 4.000 104.000 6.000 9.000; Gaus.............. 36.000 180.000 40.000 48.000; Rannor............ 118.000 220.000 120.000 124.000; Landau............ 22.000 123.000 26.000 31.000; Exponential....... 93.000 198.000 98.000 104.000; Binomial(5,0.5)... 30.000 548.000 46.000 65.000; Binomial(15,0.5).. 75.000 1615.000 125.000 178.000; Poisson(3)........ 96.000 494.000 109.000 125.000; Poisson(10)....... 138.000 1236.000 165.000 203.000; Poisson(70)....... 818.000 1195.000 835.000 844.000; Poisson(100)...... 837.000 1218.000 849.000 864.000; GausTF1........... 83.000 180.000 87.000 88.000; LandauTF1......... 80.000 180.000 83.000 86.000; GausUNURAN........ 40.000 139.000 41.000 44.000; PoissonUNURAN(10). 85.000 271.000 92.000 102.000; PoissonUNURAN(100) 62.000 256.000 69.000 78.000; TRandom1The Ranlux Random number generator class.Definition TRandom1.h:27; TRandom2Random number generator class based on the maximally quidistributed combined Tausworthe generator by ...Definition TRandom2.h:27; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; Note that this tutorial can be executed in interpreted or compiled mode; Root > .x testrandom.C; Root > .x testrandom.C++; ; Distribution nanoseconds/call; TRando",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/testrandom_8C.html:95,Load,Loading,95,doc/master/testrandom_8C.html,https://root.cern,https://root.cern/doc/master/testrandom_8C.html,2,"['Load', 'Perform']","['Loading', 'Performance']"
Performance,". ROOT: tutorials/pyroot Directory Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. pyroot Directory Reference. Directory dependency graph for pyroot:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files;  demo.py;  To run, do ""python <path-to>/demo.py"". ;  ;  demoshelp.py;   Display demo help. ;  ;  DynamicSlice.py;   Example of function called when a mouse event occurs in a pad. ;  ;  fit1.py;   Fit example. ;  ;  fit1_py.py;  ;  formula1.py;   TF1 example. ;  ;  geometry.py;   Geometry ;  ;  gerrors.py;   A Simple Graph with error bars ;  ;  graph.py;   A Simple Graph Example ;  ;  gui_ex.py;  A Simple GUI Example. ;  ;  h1ReadAndDraw.py;   A Simple histogram drawing example ;  ;  hsimple.py;   This program creates : ;  ;  hsum.py;   Simple example illustrating how to use the C++ interpreter ;  ;  mrt.py;   Build ROOT Ntuple from other source. ;  ;  na49geomfile.py;  Before executing this macro, the file makegeometry.C must have been executed. ;  ;  na49view.py;  This macro generates two views of the NA49 detector. ;  ;  na49visible.py;  Set visibility attributes for the NA49 geometry Set Shape attributes. ;  ;  ntuple1.py;   Ntuple drawing example. ;  ;  numberEntry.py;  Example frame with one box where the user can increase or decrease a number and the shown value will be updated accordingly. ;  ;  parse_CSV_file_with_TTree_ReadStream.py;  This function provides an example of how one might massage a csv data file to read into a ROOT TTree via TTree::ReadStream. ;  ;  pyroot001_arrayInterface.py;   This tutorial illustrates the conversion of STL vectors and TVec to numpy arrays without copying the data. ;  ;  pyroot002_pythonizationDecorator.py;   This tutorial shows how to use the @pythonization decorator to add extra behaviour to C++ user classes that are used from Python via PyROOT. ;  ;  pyroot003_prettyPrinting.py;   This tutorial illustrates the pretty printing feature of PyRO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_d39463c0be040a84eab8424485bc26d4.html:89,Load,Loading,89,doc/master/dir_d39463c0be040a84eab8424485bc26d4.html,https://root.cern,https://root.cern/doc/master/dir_d39463c0be040a84eab8424485bc26d4.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/DynamicSlice.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; DynamicSlice.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; Example of function called when a mouse event occurs in a pad. ; When moving the mouse in the canvas, a second canvas shows the projection along X of the bin corresponding to the Y position of the mouse. The resulting histogram is fitted with a gaussian. A ""dynamic"" line shows the current bin position in Y. This more elaborated example can be used as a starting point to develop more powerful interactive applications exploiting CINT as a development engine.; Note that a class is used to hold on to the canvas that display the selected slice. ; import sys; import ctypes; ; from ROOT import gRandom, gPad, gROOT, gVirtualX; from ROOT import kTRUE, kRed; from ROOT import TCanvas, TH2, TH2F; ; ; class DynamicExec:; ; def __init__( self ):; self._cX = None; self._cY = None; self._old = None; ; def __call__( self ):; ; h = gPad.GetSelected();; if not h:; return; ; if not isinstance( h, TH2 ):; return; ; gPad.GetCanvas().FeedbackMode( kTRUE ); ; # erase old position and draw a line at current position; px = gPad.GetEventX(); py = gPad.GetEventY(); ; uxmin, uxmax = gPad.GetUxmin(), gPad.GetUxmax(); uymin, uymax = gPad.GetUymin(), gPad.GetUymax(); pxmin, pxmax = gPad.XtoAbsPixel( uxmin ), gPad.XtoAbsPixel( uxmax ); pymin, pymax = gPad.YtoAbsPixel( uymin ), gPad.YtoAbsPixel( uymax ); ; if self._old != None:; gVirtualX.DrawLine( pxmin, self._old[1], pxmax, self._old[1] ); gVirtualX.DrawLine( self._old[0], pymin, self._old[0], pymax ); gVirtualX.DrawLine( pxmin, py, pxmax, py ); gVirtualX.DrawLine( px, pymin, px, pymax ); ; self._old = px, py; ; upx = gPad.AbsPixeltoX( px ); x = gPad.PadtoX( upx ); upy = gPad.AbsPixeltoY( py ); y = gPad.PadtoY( upy ); ; padsav = gPad; ; # create or set the display canvases; if not self._cX:; self._cX = TCanvas( 'c2', 'P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DynamicSlice_8py.html:100,Load,Loading,100,doc/master/DynamicSlice_8py.html,https://root.cern,https://root.cern/doc/master/DynamicSlice_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/demo.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; demo.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; To run, do ""python <path-to>/demo.py"". ; ; import os, sys; import ROOT; ; # To run, do ""python <path-to>/demo.py""; ; # enable running from another directory than the one where demo.py resides; workdir = os.path.dirname( sys.argv[0] ); if workdir:; os.chdir( workdir ); ; # This macro generates a Controlbar menu.; # To execute an item, click with the left mouse button.; # To see the HELP of a button, click on the right mouse button.; ; ROOT.gStyle.SetScreenFactor(1) # if you have a large screen, select 1.2 or 1.4; ; bar = ROOT.TControlBar( 'vertical', 'Demos', 10, 10 ); ; # The callbacks to python work by having CLING call the python interpreter through; # the ""TPython"" class. Note the use of ""raw strings.""; to_run = 'exec(open(\'{}\').read())'; ; ; bar.AddButton( 'Help on Demos', r'TPython::Exec( ""' + to_run.format('demoshelp.py') + '"" );', 'Click Here For Help on Running the Demos' ); bar.AddButton( 'browser', r'TPython::Exec( ""b = ROOT.TBrowser()"" );', 'Start the ROOT browser' ); bar.AddButton( 'framework', r'TPython::Exec( ""' + to_run.format('../legacy/pyroot/framework.py') + '"" );', 'An Example of Object Oriented User Interface' ); bar.AddButton( 'first', r'TPython::Exec( ""' + to_run.format('../legacy/pyroot/first.py') + '"" );', 'An Example of Slide with Root' ); bar.AddButton( 'hsimple', r'TPython::Exec( ""' + to_run.format('hsimple.py') + '"" );', 'Creating histograms/Ntuples on file', ""button"" ); bar.AddButton( 'hsum', r'TPython::Exec( ""' + to_run.format('hsum.py') + '"" );', 'Filling Histograms and Some Graphics Options' ); bar.AddButton( 'formula1', r'TPython::Exec( ""' + to_run.format('formula1.py') + '"" );', 'Simple Formula and Functions' ); bar.AddButton( 'surfaces', r'TPython::Exec( ""' + to_run.format('surfaces.py') + '"" );', 'Surface Drawing Opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/demo_8py.html:92,Load,Loading,92,doc/master/demo_8py.html,https://root.cern,https://root.cern/doc/master/demo_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/demoshelp.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; demoshelp.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; Display demo help. ; ; import os; from ROOT import TCanvas, TPaveText; from ROOT import gROOT; ; ; ; chelp = TCanvas( 'chelp', 'Help to run demos', 200, 10, 700, 500 ); ; welcome = TPaveText( .1, .8, .9, .97 ); welcome.AddText( 'Welcome to the ROOT demos' ); welcome.SetTextFont( 32 ); welcome.SetTextColor( 4 ); welcome.SetFillColor( 24 ); welcome.Draw(); ; hdemo = TPaveText( .05, .05, .95, .7 ); hdemo.SetTextAlign( 12 ); hdemo.SetTextFont( 52 ); ; text = """"""- Run demo hsimple.py first. Then in any order; - Click left mouse button to execute one demo; - Click right mouse button to see the title of the demo; - Click on 'Close Bar' to exit from the demo menu; - Select 'File/Print' to print a Postscript view of the canvas; - You can execute a demo with the mouse or type commands; - During the demo (try on this canvas) you can:; .... Use left button to move/grow/etc objects; .... Use middle button to pop overlapping objects; .... Use right button to get an object sensitive pop-up; """"""; for line in text.split( os.linesep ):; hdemo.AddText( line ); ; hdemo.SetAllWith( '....', 'color', 2 ); hdemo.SetAllWith( '....', 'font', 72 ); hdemo.SetAllWith( '....', 'size', 0.04 ); ; hdemo.Draw(); chelp.Update(); TCanvasThe Canvas class.Definition TCanvas.h:23; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; AuthorWim Lavrijsen ; Definition in file demoshelp.py. tutorialspyrootdemoshelp.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/demoshelp_8py.html:97,Load,Loading,97,doc/master/demoshelp_8py.html,https://root.cern,https://root.cern/doc/master/demoshelp_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/fit1.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; fit1.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; Fit example. . TFile** fillrandom-py.root ; TFile* fillrandom-py.root ; KEY: TFormula form1;1 abs(sin(x)/x); KEY: TF1 sqroot;1 x*gaus(0) + [3]*form1; KEY: TH1F h1f;1 Test random numbers; Formula based function: sqroot ; sqroot : x*gaus(0) + [3]*form1 Ndim= 1, Npar= 4, Number= 0 ; Formula expression: ; x*[p0]*exp(-0.5*((x-[p1])/[p2])*((x-[p1])/[p2]))+[p3]*(abs(sin(x)/x)) ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 198.935; NDf = 190; Edm = 1.49283e-07; NCalls = 149; p0 = 33.1658 +/- 0.545703 ; p1 = 4.00667 +/- 0.0165304 ; p2 = 0.984663 +/- 0.0128238 ; p3 = 63.4464 +/- 1.33233 ; fit1 : Real Time = 0.36 seconds Cpu Time = 0.37 seconds; ; import ROOT; from os import path; from ROOT import TCanvas, TFile, TPaveText; from ROOT import gROOT, gBenchmark; ; c1 = TCanvas( 'c1', 'The Fit Canvas', 200, 10, 700, 500 ); c1.SetGridx(); c1.SetGridy(); c1.GetFrame().SetFillColor( 21 ); c1.GetFrame().SetBorderMode(-1 ); c1.GetFrame().SetBorderSize( 5 ); ; gBenchmark.Start( 'fit1' ); #; # We connect the ROOT file generated in a previous tutorial; #; File = ""fillrandom-py.root""; if (ROOT.gSystem.AccessPathName(File)) :; ROOT.Info(""fit1.py"", File+"" does not exist""); exit(); ; fill = TFile(File); ; #; # The function ""ls()"" lists the directory contents of this file; #; fill.ls(); ; #; # Get object ""sqroot"" from the file.; #; ; sqroot = gROOT.FindObject( 'sqroot' ); sqroot.Print(); ; #; # Now fit histogram h1f with the function sqroot; #; h1f = gROOT.FindObject( 'h1f' ); h1f.SetFillColor( 45 ); h1f.Fit( 'sqroot' ); ; # We now annotate the picture by creating a PaveText object; # and displaying the list of commands in this macro; #; fitlabel = TPaveText( 0.6, 0.3, 0.9, 0.80, 'NDC' ); fitlabel.SetTextAlign( 12 ); fitlabel.SetFillColor( 42 ); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/fit1_8py.html:92,Load,Loading,92,doc/master/fit1_8py.html,https://root.cern,https://root.cern/doc/master/fit1_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/formula1.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; formula1.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; TF1 example. . ; from ROOT import TCanvas, TFormula, TF1; from ROOT import gROOT, gObjectTable; ; c1 = TCanvas( 'c1', 'Example with Formula', 200, 10, 700, 500 ); ; # We create a formula object and compute the value of this formula; # for two different values of the x variable.; form1 = TFormula( 'form1', 'sqrt(abs(x))' ); form1.Eval( 2 ); form1.Eval( -45 ); ; # Create a one dimensional function and draw it; fun1 = TF1( 'fun1', 'abs(sin(x)/x)', 0, 10 ); c1.SetGridx(); c1.SetGridy(); fun1.Draw(); c1.Update(); ; # Before leaving this demo, we print the list of objects known to ROOT; #; if ( gObjectTable ):; gObjectTable.Print(); TCanvasThe Canvas class.Definition TCanvas.h:23; TF11-Dim function classDefinition TF1.h:233; TFormulaThe Formula class.Definition TFormula.h:89; AuthorWim Lavrijsen ; Definition in file formula1.py. tutorialspyrootformula1.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/formula1_8py.html:96,Load,Loading,96,doc/master/formula1_8py.html,https://root.cern,https://root.cern/doc/master/formula1_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/geometry.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; geometry.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; Geometry ; ; import os; import ROOT; ; macrodir = os.path.join(str(ROOT.gROOT.GetTutorialDir()), 'pyroot'); ; # the na49.C file was generated, so no python conversion is provided; ROOT.gROOT.Macro( ROOT.gSystem.UnixPathName( os.path.join( macrodir, os.pardir, 'geom', 'na49.C' ) ) ); ; exec(open(os.path.join( macrodir, 'na49visible.py')).read()); exec(open(os.path.join( macrodir, 'na49geomfile.py')).read()); AuthorWim Lavrijsen ; Definition in file geometry.py. tutorialspyrootgeometry.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/geometry_8py.html:96,Load,Loading,96,doc/master/geometry_8py.html,https://root.cern,https://root.cern/doc/master/geometry_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/gerrors.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; gerrors.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; A Simple Graph with error bars . ; from ROOT import TCanvas, TGraphErrors; from ROOT import gROOT; from array import array; ; c1 = TCanvas( 'c1', 'A Simple Graph with error bars', 200, 10, 700, 500 ); ; c1.SetGrid(); c1.GetFrame().SetFillColor( 21 ); c1.GetFrame().SetBorderSize( 12 ); ; n = 10;; x = array( 'f', [ -0.22, 0.05, 0.25, 0.35, 0.5, 0.61, 0.7, 0.85, 0.89, 0.95 ] ); ex = array( 'f', [ 0.05, 0.1, 0.07, 0.07, 0.04, 0.05, 0.06, 0.07, 0.08, 0.05 ] ); y = array( 'f', [ 1, 2.9, 5.6, 7.4, 9.0, 9.6, 8.7, 6.3, 4.5, 1 ] ); ey = array( 'f', [ 0.8, 0.7, 0.6, 0.5, 0.4, 0.4, 0.5, 0.6, 0.7, 0.8 ] ); ; gr = TGraphErrors( n, x, y, ex, ey ); gr.SetTitle( 'TGraphErrors Example' ); gr.SetMarkerColor( 4 ); gr.SetMarkerStyle( 21 ); gr.Draw( 'ALP' ); ; c1.Update(); SetFillColorOption_t Option_t SetFillColorDefinition TGWin32VirtualXProxy.cxx:50; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; SetBorderSizec SetBorderSize(2); AuthorWim Lavrijsen ; Definition in file gerrors.py. tutorialspyrootgerrors.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gerrors_8py.html:95,Load,Loading,95,doc/master/gerrors_8py.html,https://root.cern,https://root.cern/doc/master/gerrors_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/graph.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; graph.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; A Simple Graph Example . i 0 0.000000 1.986693 ; i 1 0.100000 2.955202 ; i 2 0.200000 3.894183 ; i 3 0.300000 4.794255 ; i 4 0.400000 5.646425 ; i 5 0.500000 6.442177 ; i 6 0.600000 7.173561 ; i 7 0.700000 7.833269 ; i 8 0.800000 8.414710 ; i 9 0.900000 8.912074 ; i 10 1.000000 9.320391 ; i 11 1.100000 9.635582 ; i 12 1.200000 9.854497 ; i 13 1.300000 9.974950 ; i 14 1.400000 9.995736 ; i 15 1.500000 9.916648 ; i 16 1.600000 9.738476 ; i 17 1.700000 9.463001 ; i 18 1.800000 9.092974 ; i 19 1.900000 8.632094 ; ; from __future__ import print_function; from ROOT import TCanvas, TGraph; from ROOT import gROOT; from math import sin; from array import array; ; ; c1 = TCanvas( 'c1', 'A Simple Graph Example', 200, 10, 700, 500 ); ; c1.SetFillColor( 42 ); c1.SetGrid(); ; n = 20; x, y = array( 'd' ), array( 'd' ); ; for i in range( n ):; x.append( 0.1*i ); y.append( 10*sin( x[i]+0.2 ) ); print(' i %i %f %f ' % (i,x[i],y[i])); ; gr = TGraph( n, x, y ); gr.SetLineColor( 2 ); gr.SetLineWidth( 4 ); gr.SetMarkerColor( 4 ); gr.SetMarkerStyle( 21 ); gr.SetTitle( 'a simple graph' ); gr.GetXaxis().SetTitle( 'X title' ); gr.GetYaxis().SetTitle( 'Y title' ); gr.Draw( 'ACP' ); ; # TCanvas.Update() draws the frame, after which one can change it; c1.Update(); c1.GetFrame().SetFillColor( 21 ); c1.GetFrame().SetBorderSize( 12 ); c1.Modified(); c1.Update(); # If the graph does not appear, try using the ""i"" flag, e.g. ""python3 -i graph.py""; # This will access the interactive mode after executing the script, and thereby persist; # long enough for the graph to appear.; SetFillColorOption_t Option_t SetFillColorDefinition TGWin32VirtualXProxy.cxx:50; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/graph_8py.html:93,Load,Loading,93,doc/master/graph_8py.html,https://root.cern,https://root.cern/doc/master/graph_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/graph.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graph.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_pyroot; 3## \notebook; 4## A Simple Graph Example; 5##; 6## \macro_image; 7## \macro_output; 8## \macro_code; 9##; 10## \author Wim Lavrijsen; 11 ; 12from __future__ import print_function; 13from ROOT import TCanvas, TGraph; 14from ROOT import gROOT; 15from math import sin; 16from array import array; 17 ; 18 ; 19c1 = TCanvas( 'c1', 'A Simple Graph Example', 200, 10, 700, 500 ); 20 ; 21c1.SetFillColor( 42 ); 22c1.SetGrid(); 23 ; 24n = 20; 25x, y = array( 'd' ), array( 'd' ); 26 ; 27for i in range( n ):; 28 x.append( 0.1*i ); 29 y.append( 10*sin( x[i]+0.2 ) ); 30 print(' i %i %f %f ' % (i,x[i],y[i])); 31 ; 32gr = TGraph( n, x, y ); 33gr.SetLineColor( 2 ); 34gr.SetLineWidth( 4 ); 35gr.SetMarkerColor( 4 ); 36gr.SetMarkerStyle( 21 ); 37gr.SetTitle( 'a simple graph' ); 38gr.GetXaxis().SetTitle( 'X title' ); 39gr.GetYaxis().SetTitle( 'Y title' ); 40gr.Draw( 'ACP' ); 41 ; 42# TCanvas.Update() draws the frame, after which one can change it; 43c1.Update(); 44c1.GetFrame().SetFillColor( 21 ); 45c1.GetFrame().SetBorderSize( 12 ); 46c1.Modified(); 47c1.Update(); 48# If the graph does not appear, try using the ""i"" flag, e.g. ""python3 -i graph.py""; 49# This will access the interactive mode after executing the script, and thereby persist; 50# long enough for the graph to appear.; SetFillColorOption_t Option_t SetFillColorDefinition TGWin32VirtualXProxy.cxx:50; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; SetBorderSizec SetBorderSize(2). tutorialspyrootgraph.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/graph_8py_source.html:90,Load,Loading,90,doc/master/graph_8py_source.html,https://root.cern,https://root.cern/doc/master/graph_8py_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/gui_ex.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; gui_ex.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; A Simple GUI Example. ; from __future__ import print_function; ; import os, sys, ROOT; ; def pygaus( x, par ):; import math; if (par[2] != 0.0):; arg1 = (x[0]-par[1])/par[2]; arg2 = (0.01*0.39894228)/par[2]; arg3 = par[0]/(1+par[3]); ; gauss = arg3*arg2*math.exp(-0.5*arg1*arg1); else:; print('returning 0'); gauss = 0.; return gauss; ; tpygaus = ROOT.TF1( 'pygaus', pygaus, -4, 4, 4 ); tpygaus.SetParameters( 1., 0., 1. ); ; def MyDraw():; btn = ROOT.BindObject( ROOT.gTQSender, ROOT.TGTextButton ); if btn.WidgetId() == 10:; global tpygaus, window; tpygaus.Draw(); ROOT.gPad.Update(); ; m = ROOT.TPyDispatcher( MyDraw ); ; ; class pMainFrame( ROOT.TGMainFrame ):; def __init__( self, parent, width, height ):; ROOT.TGMainFrame.__init__( self, parent, width, height ); ; self.Canvas = ROOT.TRootEmbeddedCanvas( 'Canvas', self, 200, 200 ); self.AddFrame( self.Canvas, ROOT.TGLayoutHints(ROOT.kLHintsExpandX | ROOT.kLHintsExpandY) ); self.ButtonsFrame = ROOT.TGHorizontalFrame( self, 200, 40 ); ; self.DrawButton = ROOT.TGTextButton( self.ButtonsFrame, '&Draw', 10 ); self.DrawButton.Connect( 'Clicked()', ""TPyDispatcher"", m, 'Dispatch()' ); self.ButtonsFrame.AddFrame( self.DrawButton, ROOT.TGLayoutHints() ); ; self.ExitButton = ROOT.TGTextButton( self.ButtonsFrame, '&Exit', 20 ); self.ExitButton.SetCommand( 'TPython::Exec( ""raise SystemExit"" )' ); self.ButtonsFrame.AddFrame( self.ExitButton, ROOT.TGLayoutHints() ); ; self.AddFrame( self.ButtonsFrame, ROOT.TGLayoutHints() ); ; self.SetWindowName( 'My first GUI' ); self.MapSubwindows(); self.Resize( self.GetDefaultSize() ); self.MapWindow(); ; def __del__(self):; self.Cleanup(); ; ; if __name__ == '__main__':; window = pMainFrame( ROOT.gClient.GetRoot(), 200, 200 ); AuthorWim Lavrijsen ; Definition in file gui_ex.py. tu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gui__ex_8py.html:94,Load,Loading,94,doc/master/gui__ex_8py.html,https://root.cern,https://root.cern/doc/master/gui__ex_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/h1ReadAndDraw.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; h1ReadAndDraw.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; A Simple histogram drawing example ; ; import ROOT; from ROOT import TCanvas, TPad, TFile, TPaveLabel, TPaveText; from ROOT import gROOT; ; c1 = TCanvas( 'c1', 'Histogram Drawing Options', 200, 10, 700, 900 ); ; pad1 = TPad( 'pad1', 'The pad with the function', 0.03, 0.62, 0.50, 0.92, 21 ); pad2 = TPad( 'pad2', 'The pad with the histogram', 0.51, 0.62, 0.98, 0.92, 21 ); pad3 = TPad( 'pad3', 'The pad with the histogram', 0.03, 0.02, 0.97, 0.57, 21 ); pad1.Draw(); pad2.Draw(); pad3.Draw(); #; # We connect the ROOT file generated in a previous tutorial; #; File = ""py-hsimple.root""; if (ROOT.gSystem.AccessPathName(File)) :; ROOT.Info(""h1ReadAndDraw.py"", File+"" does not exist""); exit(); ; example = TFile(File); example.ls(); ; # Draw a global picture title; title = TPaveLabel( 0.1, 0.94, 0.9, 0.98,; 'Drawing options for one dimensional histograms' ); title.SetFillColor( 16 ); title.SetTextFont( 52 ); title.Draw(); #; # Draw histogram hpx in first pad with the default option.; pad1.cd(); pad1.GetFrame().SetFillColor( 18 ); hpx = gROOT.FindObject( 'hpx' ); hpx.SetFillColor( 45 ); hpx.DrawCopy(); label1 = TPaveLabel( -3.5, 700, -1, 800, 'Default option' ); label1.SetFillColor( 42 ); label1.Draw(); #; # Draw hpx as a lego. Clicking on the lego area will show; # a ""transparent cube"" to guide you rotating the lego in real time.; pad2.cd(); hpx.DrawCopy( 'lego1' ); label2 = TPaveLabel( -0.72, 0.74, -0.22, 0.88, 'option Lego1' ); label2.SetFillColor( 42 ); label2.Draw(); label2a = TPaveLabel( -0.93, -1.08, 0.25, -0.92, 'Click on lego to rotate' ); label2a.SetFillColor( 42 ); label2a.Draw(); #; # Draw hpx with its errors and a marker.; pad3.cd(); pad3.SetGridx(); pad3.SetGridy(); pad3.GetFrame().SetFillColor( 18 ); hpx.SetMarkerStyle( 21 ); hpx.Draw(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1ReadAndDraw_8py.html:101,Load,Loading,101,doc/master/h1ReadAndDraw_8py.html,https://root.cern,https://root.cern/doc/master/h1ReadAndDraw_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/hsimple.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; hsimple.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This program creates : . a one dimensional histogram; a two dimensional histogram; a profile histogram; a memory-resident ntuple. These objects are filled with some random numbers and saved on a file. ; from ROOT import TCanvas, TFile, TProfile, TNtuple, TH1F, TH2F; from ROOT import gROOT, gBenchmark, gRandom, gSystem; import ctypes; ; # Create a new canvas, and customize it.; c1 = TCanvas( 'c1', 'Dynamic Filling Example', 200, 10, 700, 500 ); c1.SetFillColor( 42 ); c1.GetFrame().SetFillColor( 21 ); c1.GetFrame().SetBorderSize( 6 ); c1.GetFrame().SetBorderMode( -1 ); ; # Create a new ROOT binary machine independent file.; # Note that this file may contain any kind of ROOT objects, histograms,; # pictures, graphics objects, detector geometries, tracks, events, etc..; # This file is now becoming the current directory.; ; hfile = gROOT.FindObject( 'py-hsimple.root' ); if hfile:; hfile.Close(); hfile = TFile( 'py-hsimple.root', 'RECREATE', 'Demo ROOT file with histograms' ); ; # Create some histograms, a profile histogram and an ntuple; hpx = TH1F( 'hpx', 'This is the px distribution', 100, -4, 4 ); hpxpy = TH2F( 'hpxpy', 'py vs px', 40, -4, 4, 40, -4, 4 ); hprof = TProfile( 'hprof', 'Profile of pz versus px', 100, -4, 4, 0, 20 ); ntuple = TNtuple( 'ntuple', 'Demo ntuple', 'px:py:pz:random:i' ); ; # Set canvas/frame attributes.; hpx.SetFillColor( 48 ); ; gBenchmark.Start( 'hsimple' ); ; # Initialize random number generator.; gRandom.SetSeed(); rannor, rndm = gRandom.Rannor, gRandom.Rndm; ; # For speed, bind and cache the Fill member functions,; histos = [ 'hpx', 'hpxpy', 'hprof', 'ntuple' ]; for name in histos:; exec('%sFill = %s.Fill' % (name,name)); ; # Fill histograms randomly.; px_ref, py_ref = ctypes.c_double(), ctypes.c_double(); kUPDATE = 1000; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsimple_8py.html:95,Load,Loading,95,doc/master/hsimple_8py.html,https://root.cern,https://root.cern/doc/master/hsimple_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/hsimple.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. hsimple.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_pyroot; 3## \notebook -js; 4## This program creates :; 5## - a one dimensional histogram; 6## - a two dimensional histogram; 7## - a profile histogram; 8## - a memory-resident ntuple; 9##; 10## These objects are filled with some random numbers and saved on a file.; 11##; 12## \macro_image; 13## \macro_code; 14##; 15## \author Wim Lavrijsen, Enric Tejedor; 16 ; 17from ROOT import TCanvas, TFile, TProfile, TNtuple, TH1F, TH2F; 18from ROOT import gROOT, gBenchmark, gRandom, gSystem; 19import ctypes; 20 ; 21# Create a new canvas, and customize it.; 22c1 = TCanvas( 'c1', 'Dynamic Filling Example', 200, 10, 700, 500 ); 23c1.SetFillColor( 42 ); 24c1.GetFrame().SetFillColor( 21 ); 25c1.GetFrame().SetBorderSize( 6 ); 26c1.GetFrame().SetBorderMode( -1 ); 27 ; 28# Create a new ROOT binary machine independent file.; 29# Note that this file may contain any kind of ROOT objects, histograms,; 30# pictures, graphics objects, detector geometries, tracks, events, etc..; 31# This file is now becoming the current directory.; 32 ; 33hfile = gROOT.FindObject( 'py-hsimple.root' ); 34if hfile:; 35 hfile.Close(); 36hfile = TFile( 'py-hsimple.root', 'RECREATE', 'Demo ROOT file with histograms' ); 37 ; 38# Create some histograms, a profile histogram and an ntuple; 39hpx = TH1F( 'hpx', 'This is the px distribution', 100, -4, 4 ); 40hpxpy = TH2F( 'hpxpy', 'py vs px', 40, -4, 4, 40, -4, 4 ); 41hprof = TProfile( 'hprof', 'Profile of pz versus px', 100, -4, 4, 0, 20 ); 42ntuple = TNtuple( 'ntuple', 'Demo ntuple', 'px:py:pz:random:i' ); 43 ; 44# Set canvas/frame attributes.; 45hpx.SetFillColor( 48 ); 46 ; 47gBenchmark.Start( 'hsimple' ); 48 ; 49# Initialize random number generator.; 50gRandom.SetSeed(); 51rannor, rndm = gRandom.Rannor, gRandom.Rndm; 52 ; 53# For speed, bind and cache the Fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsimple_8py_source.html:92,Load,Loading,92,doc/master/hsimple_8py_source.html,https://root.cern,https://root.cern/doc/master/hsimple_8py_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/hsum.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; hsum.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; Simple example illustrating how to use the C++ interpreter . ; from ROOT import TCanvas, TH1F, TSlider; from ROOT import gROOT, gBenchmark, gRandom; ; # Create a new canvas, and customize it.; c1 = TCanvas( 'c1', 'The HSUM example', 200, 10, 600, 400 ); c1.SetGrid();; ; gBenchmark.Start( 'hsum' ); ; # Create some histograms.; total = TH1F( 'total', 'This is the total distribution', 100, -4, 4 ); main = TH1F( 'main', 'Main contributor', 100, -4, 4 ); s1 = TH1F( 's1', 'This is the first signal', 100, -4, 4 ); s2 = TH1F( 's2', 'This is the second signal', 100, -4, 4 ); total.Sumw2() # this makes sure that the sum of squares of weights will be stored; ; # Set canvas/frame attributes.; total.SetMarkerStyle( 21 ); total.SetMarkerSize( 0.7 ); main.SetFillColor( 16 ); s1.SetFillColor( 42 ); s2.SetFillColor( 46 ); ; # Initialize random number generator.; gRandom.SetSeed(); gauss, landau = gRandom.Gaus, gRandom.Landau; ; # for speed, bind and cache the Fill member functions; histos = [ 'total', 'main', 's1', 's2' ]; for name in histos:; exec('%sFill = %s.Fill' % (name,name)); ; # Fill histograms randomly; kUPDATE = 500; for i in range( 10000 ):; # Generate random values.; xmain = gauss( -1, 1.5 ); xs1 = gauss( -0.5, 0.5 ); xs2 = landau( 1, 0.15 ); mainFill( xmain ); ; # Fill histograms.; s1Fill( xs1, 0.3 ); s2Fill( xs2, 0.2 ); totalFill( xmain ); totalFill( xs1, 0.3 ); totalFill( xs2, 0.2 ); ; # Update display every kUPDATE events.; if i and (i%kUPDATE) == 0 :; if i == kUPDATE :; total.Draw( 'e1p' ); main.Draw( 'same' ); s1.Draw( 'same' ); s2.Draw( 'same' ); c1.Update(); slider = TSlider( 'slider', 'test', 4.2, 0, 4.6, total.GetMaximum(), 38 ); slider.SetFillColor( 46 ); ; if slider:; slider.SetRange( 0, float(i) / 10000. ); ; c1.Modified(); c1.Update(); ; # Destr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsum_8py.html:92,Load,Loading,92,doc/master/hsum_8py.html,https://root.cern,https://root.cern/doc/master/hsum_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/hsum.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. hsum.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_pyroot; 3## \notebook -js; 4## Simple example illustrating how to use the C++ interpreter; 5##; 6## \macro_image; 7## \macro_code; 8##; 9## \author Wim Lavrijsen; 10 ; 11from ROOT import TCanvas, TH1F, TSlider; 12from ROOT import gROOT, gBenchmark, gRandom; 13 ; 14# Create a new canvas, and customize it.; 15c1 = TCanvas( 'c1', 'The HSUM example', 200, 10, 600, 400 ); 16c1.SetGrid();; 17 ; 18gBenchmark.Start( 'hsum' ); 19 ; 20# Create some histograms.; 21total = TH1F( 'total', 'This is the total distribution', 100, -4, 4 ); 22main = TH1F( 'main', 'Main contributor', 100, -4, 4 ); 23s1 = TH1F( 's1', 'This is the first signal', 100, -4, 4 ); 24s2 = TH1F( 's2', 'This is the second signal', 100, -4, 4 ); 25total.Sumw2() # this makes sure that the sum of squares of weights will be stored; 26 ; 27# Set canvas/frame attributes.; 28total.SetMarkerStyle( 21 ); 29total.SetMarkerSize( 0.7 ); 30main.SetFillColor( 16 ); 31s1.SetFillColor( 42 ); 32s2.SetFillColor( 46 ); 33 ; 34# Initialize random number generator.; 35gRandom.SetSeed(); 36gauss, landau = gRandom.Gaus, gRandom.Landau; 37 ; 38# for speed, bind and cache the Fill member functions; 39histos = [ 'total', 'main', 's1', 's2' ]; 40for name in histos:; 41 exec('%sFill = %s.Fill' % (name,name)); 42 ; 43# Fill histograms randomly; 44kUPDATE = 500; 45for i in range( 10000 ):; 46 # Generate random values.; 47 xmain = gauss( -1, 1.5 ); 48 xs1 = gauss( -0.5, 0.5 ); 49 xs2 = landau( 1, 0.15 ); 50 mainFill( xmain ); 51 ; 52 # Fill histograms.; 53 s1Fill( xs1, 0.3 ); 54 s2Fill( xs2, 0.2 ); 55 totalFill( xmain ); 56 totalFill( xs1, 0.3 ); 57 totalFill( xs2, 0.2 ); 58 ; 59 # Update display every kUPDATE events.; 60 if i and (i%kUPDATE) == 0 :; 61 if i == kUPDATE :; 62 total.Draw( 'e1p' ); 63 main.Draw( 'same' ); 64 s1.Draw( 'same' )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsum_8py_source.html:89,Load,Loading,89,doc/master/hsum_8py_source.html,https://root.cern,https://root.cern/doc/master/hsum_8py_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/mrt.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; mrt.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; Build ROOT Ntuple from other source. ; This program reads the ‘aptuple.txt’ file row by row, then creates the Ntuple by adding row by row.; opening file /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/pyroot/aptuple.txt ...; writing file aptuple.root ...; done; ; import sys, os; from ROOT import TFile, TNtuple, TROOT; ; ; ifn = os.path.join(str(TROOT.GetTutorialDir()), 'pyroot', 'aptuple.txt'); ofn = 'aptuple.root'; ; print('opening file %s ...' % ifn); infile = open( ifn, 'r' ); lines = infile.readlines(); title = lines[0]; labels = lines[1].split(); ; print('writing file %s ...' % ofn); outfile = TFile( ofn, 'RECREATE', 'ROOT file with an NTuple' ); ntuple = TNtuple( 'ntuple', title, ':'.join( labels ) ); ; for line in lines[2:]:; words = line.split(); row = map( float, words ); ntuple.Fill(*row); ; outfile.Write(); ; print('done'); TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TROOT::GetTutorialDirstatic const TString & GetTutorialDir()Get the tutorials directory in the installation. Static utility function.Definition TROOT.cxx:3119; AuthorWim Lavrijsen ; Definition in file mrt.py. tutorialspyrootmrt.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/mrt_8py.html:91,Load,Loading,91,doc/master/mrt_8py.html,https://root.cern,https://root.cern/doc/master/mrt_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/na49geomfile.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; na49geomfile.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; Before executing this macro, the file makegeometry.C must have been executed. ; ; import ROOT; ; ROOT.gBenchmark.Start( 'geometry' ); na = ROOT.TFile( 'py-na49.root', 'RECREATE' ); n49 = ROOT.gROOT.FindObject( 'na49' ); n49.Write(); na.Write(); na.Close(); ROOT.gBenchmark.Show( 'geometry' ); ; AuthorWim Lavrijsen ; Definition in file na49geomfile.py. tutorialspyrootna49geomfile.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/na49geomfile_8py.html:100,Load,Loading,100,doc/master/na49geomfile_8py.html,https://root.cern,https://root.cern/doc/master/na49geomfile_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/na49view.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; na49view.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This macro generates two views of the NA49 detector. ; To have a better and dynamic view of any of these pads, you can click with the middle button of your mouse to select it. Then select ""View with x3d"" in the VIEW menu of the Canvas. Once in x3d, you are in wireframe mode by default. You can switch to:; Hidden Line mode by typing E; Solid mode by typing R; Wireframe mode by typing W; Stereo mode by clicking S (and you need special glasses); To leave x3d type Q. ; import ROOT; ; c1 = ROOT.TCanvas( 'c1', 'The NA49 canvas', 200, 10, 700, 780 ); ; ROOT.gBenchmark.Start( 'na49view' ); ; all = ROOT.TPad( 'all', 'A Global view of NA49', 0.02, 0.02, 0.48, 0.82, 28 ); tof = ROOT.TPad( 'tof', 'One Time Of Flight element', 0.52, 0.02, 0.98, 0.82, 28 ); all.Draw();; tof.Draw();; na49title = ROOT.TPaveLabel( 0.04, 0.86, 0.96, 0.98, 'Two views of the NA49 detector' ); na49title.SetFillColor( 32 ); na49title.Draw(); #; nageom = ROOT.TFile( 'py-na49.root' ); n49 = ROOT.gROOT.FindObject( 'na49' ); n49.SetBomb( 1.2 ); n49.cd() # Set current geometry; all.cd() # Set current pad; n49.Draw(); c1.Update(); tof.cd(); TOFR1 = n49.GetNode( 'TOFR1' ); TOFR1.Draw(); c1.Update(); ; ROOT.gBenchmark.Show( 'na49view' ); AuthorWim Lavrijsen ; Definition in file na49view.py. tutorialspyrootna49view.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/na49view_8py.html:96,Load,Loading,96,doc/master/na49view_8py.html,https://root.cern,https://root.cern/doc/master/na49view_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/na49visible.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; na49visible.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; Set visibility attributes for the NA49 geometry Set Shape attributes. ; ; import ROOT; ; ROOT.YK01.SetVisibility( 0 ); ROOT.YK03.SetLineColor( 2 ); ROOT.YK04.SetLineColor( 5 ); ROOT.SEC1.SetLineColor( 6 ); ROOT.SEC2.SetLineColor( 6 ); ROOT.SEC3.SetLineColor( 3 ); ROOT.SEC4.SetLineColor( 3 ); ROOT.TOFR.SetLineColor( 5 ); ROOT.COI1.SetLineColor( 4 ); ROOT.COI2.SetLineColor( 4 ); ROOT.COI3.SetLineColor( 4 ); ROOT.COI4.SetLineColor( 4 ); ROOT.CS38.SetLineColor( 5 ); ROOT.CS28.SetLineColor( 5 ); ROOT.CS18.SetLineColor( 5 ); ROOT.TF4D.SetLineColor( 3 ); ROOT.OGB4.SetLineColor( 3 ); ROOT.TF3D.SetLineColor( 3 ); ROOT.OGB3.SetLineColor( 3 ); ROOT.TF4A.SetLineColor( 3 ); ROOT.OGB4.SetLineColor( 3 ); ROOT.TF3A.SetLineColor( 3 ); ROOT.OGB3.SetLineColor( 3 ); ; # Copy shape attributes (colors,etc) in nodes referencing the shapse; CAVE1 = ROOT.gGeometry.FindObject( 'CAVE1' ); CAVE1.ImportShapeAttributes( ); ; # Set Node attributes; CAVE1.SetVisibility( 2 ) # node is not drawn but its sons are drawn; ROOT.gGeometry.FindObject( 'VT1_1' ).SetVisibility( -4 ) # Node is not drawn.; # Its immediate sons are drawn; ROOT.gGeometry.FindObject( 'VT2_1' ).SetVisibility( -4 ); ROOT.gGeometry.FindObject( 'MTL_1' ).SetVisibility( -4 ); ROOT.gGeometry.FindObject( 'MTR_1' ).SetVisibility( -4 ); ROOT.gGeometry.FindObject( 'TOFR1' ).SetVisibility( -4 ); ; AuthorWim Lavrijsen ; Definition in file na49visible.py. tutorialspyrootna49visible.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/na49visible_8py.html:99,Load,Loading,99,doc/master/na49visible_8py.html,https://root.cern,https://root.cern/doc/master/na49visible_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/ntuple1.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; ntuple1.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; Ntuple drawing example. ; ; from ROOT import TCanvas, TPad, TFile, TPaveText; from ROOT import gBenchmark, gStyle, gROOT; ; c1 = TCanvas('c1','The Ntuple canvas',200,10,700,780); ; gBenchmark.Start('ntuple1'); ; #; # Connect ROOT histogram/ntuple demonstration file; # generated by example hsimple.C.; f1 = TFile('py-hsimple.root'); ; #; # Inside this canvas, we create 4 pads; pad1 = TPad('pad1','This is pad1',0.02,0.52,0.48,0.98,21); pad2 = TPad('pad2','This is pad2',0.52,0.52,0.98,0.98,21); pad3 = TPad('pad3','This is pad3',0.02,0.02,0.48,0.48,21); pad4 = TPad('pad4','This is pad4',0.52,0.02,0.98,0.48,1); pad1.Draw(); pad2.Draw(); pad3.Draw(); pad4.Draw(); ; #; # Change default style for the statistics box; gStyle.SetStatW(0.30); gStyle.SetStatH(0.20); gStyle.SetStatColor(42); ; #; # Display a function of one ntuple column imposing a condition; # on another column.; pad1.cd(); pad1.SetGrid(); pad1.SetLogy(); pad1.GetFrame().SetFillColor(15); ntuple = gROOT.FindObject('ntuple'); ntuple.SetLineColor(1); ntuple.SetFillStyle(1001); ntuple.SetFillColor(45); ntuple.Draw('3*px+2','px**2+py**2>1'); ntuple.SetFillColor(38); ntuple.Draw('2*px+2','pz>2','same'); ntuple.SetFillColor(5); ntuple.Draw('1.3*px+2','(px^2+py^2>4) && py>0','same'); c1.Update(); ; #; # Display the profile of two columns; # The profile histogram produced is saved in the current directory with; # the name hprofs; pad2.cd(); pad2.SetGrid(); pad2.GetFrame().SetFillColor(32); ntuple.Draw('pz:px>>hprofs','','goffprofs'); hprofs = gROOT.FindObject('hprofs'); hprofs.SetMarkerColor(5); hprofs.SetMarkerSize(0.7); hprofs.SetMarkerStyle(21); hprofs.Fit('pol2'); ; #; # Get pointer to fitted function and modify its attributes; fpol2 = hprofs.GetFunction('pol2'); fpol2.SetLineWidth(4); fpol2.SetLine",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ntuple1_8py.html:95,Load,Loading,95,doc/master/ntuple1_8py.html,https://root.cern,https://root.cern/doc/master/ntuple1_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/numberEntry.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; numberEntry.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; Example frame with one box where the user can increase or decrease a number and the shown value will be updated accordingly. ; ; import ROOT; ; ; class pMyMainFrame(ROOT.TGMainFrame):; def __init__(self, parent, width, height):; ROOT.TGMainFrame.__init__(self, parent, width, height); ; self.fHor1 = ROOT.TGHorizontalFrame(self, 60, 20, ROOT.kFixedWidth); self.fExit = ROOT.TGTextButton(self.fHor1, ""&Exit"", ""gApplication->Terminate(0)""); self.fExit.SetCommand('TPython::Exec( ""raise SystemExit"" )'); self.fHor1.AddFrame(self.fExit, ROOT.TGLayoutHints(; ROOT.kLHintsTop | ROOT.kLHintsLeft | ROOT.kLHintsExpandX, 4, 4, 4, 4)); self.AddFrame(self.fHor1, ROOT.TGLayoutHints(ROOT.kLHintsBottom | ROOT.kLHintsRight, 2, 2, 5, 1)); ; self.fNumber = ROOT.TGNumberEntry(self, 0, 9, 999, ROOT.TGNumberFormat.kNESInteger,; ROOT.TGNumberFormat.kNEANonNegative,; ROOT.TGNumberFormat.kNELLimitMinMax,; 0, 99999); self.fLabelDispatch = ROOT.TPyDispatcher(self.DoSetlabel); self.fNumber.Connect(""ValueSet(Long_t)"", ""TPyDispatcher"", self.fLabelDispatch, ""Dispatch()""); self.fNumber.GetNumberEntry().Connect(""ReturnPressed()"", ""TPyDispatcher"", self.fLabelDispatch, ""Dispatch()""); self.AddFrame(self.fNumber, ROOT.TGLayoutHints(ROOT.kLHintsTop | ROOT.kLHintsLeft, 5, 5, 5, 5)); self.fGframe = ROOT.TGGroupFrame(self, ""Value""); self.fLabel = ROOT.TGLabel(self.fGframe, ""No input.""); self.fGframe.AddFrame(self.fLabel, ROOT.TGLayoutHints(ROOT.kLHintsTop | ROOT.kLHintsLeft, 5, 5, 5, 5)); self.AddFrame(self.fGframe, ROOT.TGLayoutHints(ROOT.kLHintsExpandX, 2, 2, 1, 1)); ; self.SetCleanup(ROOT.kDeepCleanup); self.SetWindowName(""Number Entry""); self.MapSubwindows(); self.Resize(self.GetDefaultSize()); self.MapWindow(); ; def __del__(self):; self.Cleanup(); ; def DoSetlabel(self):; self.fLa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/numberEntry_8py.html:99,Load,Loading,99,doc/master/numberEntry_8py.html,https://root.cern,https://root.cern/doc/master/numberEntry_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/parse_CSV_file_with_TTree_ReadStream.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; parse_CSV_file_with_TTree_ReadStream.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This function provides an example of how one might massage a csv data file to read into a ROOT TTree via TTree::ReadStream. ; This could be useful if the data read out from some DAQ program doesn't 'quite' match the formatting expected by ROOT (e.g. comma- separated, tab-separated with white-space strings, headers not matching the expected format, etc.); This example is shipped with a data file that looks like:; Date/Time Synchro Capacity Temp.Cold Head Temp. Electrode HV Supply Voltage Electrode 1 Electrode 2 Electrode 3 Electrode 4; # Example data to read out. Some data have oddities that might need to; # dealt with, including the 'NaN' in Electrode 4 and the empty string in Date/Time (last row); 08112010.160622 7 5.719000E-10 8.790500 24.237700 -0.008332 0 0 0 0; 8112010.160626 7 5.710000E-10 8.828400 24.237500 -0.008818 0 0 0 0; 08112010.160626 7 5.719000E-10 8.828400 24.237500 -0.008818 0 0 0 0; 08112010.160627 7 5.719000E-10 9.014300 24.237400 -0.028564 0 0 0 NaN; 08112010.160627 7 5.711000E-10 8.786000 24.237400 -0.008818 0 0 0 0; 08112010.160628 7 5.702000E-10 8.786000 24.237400 -0.009141 0 0 0 0; 08112010.160633 7 5.710000E-10 9.016200 24.237200 -0.008818 0 0 0 0; 7 5.710000E-10 8.903400 24.237200 -0.008818 0 0 0 0; NaN#define NaNDefinition RooLagrangianMorphFunc.cxx:87; These data require some massaging, including:. Date/Time has a blank ('') entry that must be handled; The headers are not in the correct format; Tab-separated entries with additional white space; NaN entries. from __future__ import print_function; ; import ROOT; import sys; import os; ; def parse_CSV_file_with_TTree_ReadStream(tree_name, afile):; ; ; ROOT.gROOT.SetBatch(); # The mapping dictionary defines the proper",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/parse__CSV__file__with__TTree__ReadStream_8py.html:124,Load,Loading,124,doc/master/parse__CSV__file__with__TTree__ReadStream_8py.html,https://root.cern,https://root.cern/doc/master/parse__CSV__file__with__TTree__ReadStream_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/pyroot001_arrayInterface.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; pyroot001_arrayInterface.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This tutorial illustrates the conversion of STL vectors and TVec to numpy arrays without copying the data. ; The memory-adoption is achieved by the dictionary array_interface, which is added dynamically to the Python objects by PyROOT.; ; import ROOT; from sys import exit; ; try:; import numpy as np; except:; exit(); ; # Create a vector ROOT object and assign values; # Note that this works as well with a TVec; vec = ROOT.std.vector(""float"")(2); vec[0] = 1; vec[1] = 2; print(""Content of the ROOT vector object: {}"".format([x for x in vec])); ; # Interface ROOT vector with a numpy array; array = np.asarray(vec); print(""Content of the associated numpy array: {}"".format([x for x in array])); ; # The numpy array adopts the memory of the vector without copying the content.; # Note that the first entry of the numpy array changes when assigning a new; # value to the first entry of the ROOT vector.; vec[0] = 42; print(; ""Content of the numpy array after changing the first entry of the ROOT vector: {}"".; format([x for x in array])); ; # Use numpy features on data of ROOT objects; print(""Mean of the numpy array entries: {}"".format(np.mean(array))); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot001__arrayInterface_8py.html:112,Load,Loading,112,doc/master/pyroot001__arrayInterface_8py.html,https://root.cern,https://root.cern/doc/master/pyroot001__arrayInterface_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/pyroot002_pythonizationDecorator.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; pyroot002_pythonizationDecorator.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This tutorial shows how to use the @pythonization decorator to add extra behaviour to C++ user classes that are used from Python via PyROOT. ; ; import ROOT; from ROOT import pythonization; ; # Let's first define a new C++ class. In this tutorial, we will see how we can; # ""pythonize"" this class, i.e. how we can add some extra behaviour to it to; # make it more pythonic or easier to use from Python.; #; # Note: In this example, the class is defined dynamically for demonstration; # purposes, but it could also be a C++ class defined in some library or header.; # For more information about loading C++ user code to be used from Python with; # PyROOT, please see:; # https://root.cern.ch/manual/python/#loading-user-libraries-and-just-in-time-compilation-jitting; ROOT.gInterpreter.Declare('''; class MyClass {};; '''); ; # Next, we define a pythonizor function: the function that will be responsible; # for injecting new behaviour in our C++ class `MyClass`.; #; # To convert a given Python function into a pythonizor, we need to decorate it; # with the @pythonization decorator. Such decorator allows us to define which; # which class we want to pythonize by providing its class name and its; # namespace (if the latter is not specified, it defaults to the global; # namespace, i.e. '::').; #; # The decorated function - the pythonizor - must accept either one or two; # parameters:; # 1. The class to be pythonized (proxy object where new behaviour can be; # injected); # 2. The fully-qualified name of that class (optional).; #; # Let's see all this with a simple example. Suppose I would like to define how; # `MyClass` objects are represented as a string in Python (i.e. what would be; # shown when I print that object)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py.html:120,Load,Loading,120,doc/master/pyroot002__pythonizationDecorator_8py.html,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py.html,2,"['Load', 'load']","['Loading', 'loading']"
Performance,". ROOT: tutorials/pyroot/pyroot002_pythonizationDecorator.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. pyroot002_pythonizationDecorator.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_pyroot; 3## \notebook -nodraw; 4## This tutorial shows how to use the `@pythonization` decorator to add extra; 5## behaviour to C++ user classes that are used from Python via PyROOT.; 6##; 7## \macro_code; 8## \macro_output; 9##; 10## \date November 2021; 11## \author Enric Tejedor; 12 ; 13import ROOT; 14from ROOT import pythonization; 15 ; 16# Let's first define a new C++ class. In this tutorial, we will see how we can; 17# ""pythonize"" this class, i.e. how we can add some extra behaviour to it to; 18# make it more pythonic or easier to use from Python.; 19#; 20# Note: In this example, the class is defined dynamically for demonstration; 21# purposes, but it could also be a C++ class defined in some library or header.; 22# For more information about loading C++ user code to be used from Python with; 23# PyROOT, please see:; 24# https://root.cern.ch/manual/python/#loading-user-libraries-and-just-in-time-compilation-jitting; 25ROOT.gInterpreter.Declare('''; 26class MyClass {};; 27'''); 28 ; 29# Next, we define a pythonizor function: the function that will be responsible; 30# for injecting new behaviour in our C++ class `MyClass`.; 31#; 32# To convert a given Python function into a pythonizor, we need to decorate it; 33# with the @pythonization decorator. Such decorator allows us to define which; 34# which class we want to pythonize by providing its class name and its; 35# namespace (if the latter is not specified, it defaults to the global; 36# namespace, i.e. '::').; 37#; 38# The decorated function - the pythonizor - must accept either one or two; 39# parameters:; 40# 1. The class to be pythonized (proxy object where new behaviour can be; 41# injected); 42# 2. The fully-qualified name of that class (optional).;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py_source.html:117,Load,Loading,117,doc/master/pyroot002__pythonizationDecorator_8py_source.html,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/pyroot003_prettyPrinting.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; pyroot003_prettyPrinting.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This tutorial illustrates the pretty printing feature of PyROOT, which reveals the content of the object if a string representation is requested, e.g., by Python's print statement. ; The printing behaves similar to the ROOT prompt powered by the C++ interpreter cling.; ; import ROOT; ; # Create an object with PyROOT; obj = ROOT.std.vector(""int"")(3); for i in range(obj.size()):; obj[i] = i; ; # Print the object, which reveals the content. Note that `print` calls the special; # method `__str__` of the object internally.; print(obj); ; # The output can be retrieved as string by any function that triggers the `__str__`; # special method of the object, e.g., `str` or `format`.; print(str(obj)); print(""{}"".format(obj)); ; # Note that the interactive Python prompt does not call `__str__`, it calls; # `__repr__`, which implements a formal and unique string representation of; # the object.; print(repr(obj)); obj; ; # The print output behaves similar to the ROOT prompt, e.g., here for a ROOT histogram.; hist = ROOT.TH1F(""name"", ""title"", 10, 0, 1); print(hist); ; # If cling cannot produce any nice representation for the class, we fall back to a; # ""<ClassName at address>"" format, which is what `__repr__` returns; ROOT.gInterpreter.Declare('class MyClass {};'); m = ROOT.MyClass(); print(m); print(str(m) == repr(m)); ; formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot003__prettyPrinting_8py.html:112,Load,Loading,112,doc/master/pyroot003__prettyPrinting_8py.html,https://root.cern,https://root.cern/doc/master/pyroot003__prettyPrinting_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/pyroot004_NumbaDeclare.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; pyroot004_NumbaDeclare.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This tutorial illustrates how PyROOT supports declaring C++ callables from Python callables making them, for example, usable with RDataFrame. ; The feature uses the numba Python package for just-in-time compilation of the Python callable and supports fundamental types and ROOT::RVec thereof.; ; import ROOT; ; # To mark a Python callable to be used from C++, you have to use the decorator; # provided by PyROOT passing the C++ types of the input arguments and the return; # value.; @ROOT.Numba.Declare(['float', 'int'], 'float'); def pypow(x, y):; return x**y; ; # The Python callable is now available from C++ in the Numba namespace.; # For example, we can use it from the interpreter.; ROOT.gInterpreter.ProcessLine('cout << ""2^3 = "" << Numba::pypow(2, 3) << endl;'); ; # Or we can use the callable as well within a RDataFrame workflow.; data = ROOT.RDataFrame(4).Define('x', '(float)rdfentry_')\; .Define('x_pow3', 'Numba::pypow(x, 3)')\; .AsNumpy(); ; print('pypow({}, 3) = {}'.format(data['x'], data['x_pow3'])); ; # ROOT uses the numba Python package to create C++ functions from python ones.; # We support as input and return types of the callable fundamental types and; # ROOT::RVec thereof. See the following callable computing the power of the; # elements in an array.; @ROOT.Numba.Declare(['RVecF', 'int'], 'RVecF'); def pypowarray(x, y):; return x**y; ; ROOT.gInterpreter.ProcessLine('''; ROOT::RVecF x = {0, 1, 2, 3};; cout << ""pypowarray("" << x << "", 3) = "" << Numba::pypowarray(x, 3) << endl;; '''); ; # and now with RDataFrame; s = ROOT.RDataFrame(1).Define('x', 'ROOT::RVecF{1,2,3}')\; .Define('x2', 'Numba::pypowarray(x, 2)')\; .Sum('x2') # 1 + 4 + 9 == 14; print('sum(pypowarray({ 1, 2, 3 }, 2)) = ', s.GetValue()); formatOption",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot004__NumbaDeclare_8py.html:110,Load,Loading,110,doc/master/pyroot004__NumbaDeclare_8py.html,https://root.cern,https://root.cern/doc/master/pyroot004__NumbaDeclare_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/pyroot004_NumbaDeclare.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. pyroot004_NumbaDeclare.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_pyroot; 3## \notebook -nodraw; 4## This tutorial illustrates how PyROOT supports declaring C++ callables from; 5## Python callables making them, for example, usable with RDataFrame. The feature; 6## uses the numba Python package for just-in-time compilation of the Python callable; 7## and supports fundamental types and ROOT::RVec thereof.; 8##; 9## \macro_code; 10## \macro_output; 11##; 12## \date March 2020; 13## \author Stefan Wunsch; 14 ; 15import ROOT; 16 ; 17# To mark a Python callable to be used from C++, you have to use the decorator; 18# provided by PyROOT passing the C++ types of the input arguments and the return; 19# value.; 20@ROOT.Numba.Declare(['float', 'int'], 'float'); 21def pypow(x, y):; 22 return x**y; 23 ; 24# The Python callable is now available from C++ in the Numba namespace.; 25# For example, we can use it from the interpreter.; 26ROOT.gInterpreter.ProcessLine('cout << ""2^3 = "" << Numba::pypow(2, 3) << endl;'); 27 ; 28# Or we can use the callable as well within a RDataFrame workflow.; 29data = ROOT.RDataFrame(4).Define('x', '(float)rdfentry_')\; 30 .Define('x_pow3', 'Numba::pypow(x, 3)')\; 31 .AsNumpy(); 32 ; 33print('pypow({}, 3) = {}'.format(data['x'], data['x_pow3'])); 34 ; 35# ROOT uses the numba Python package to create C++ functions from python ones.; 36# We support as input and return types of the callable fundamental types and; 37# ROOT::RVec thereof. See the following callable computing the power of the; 38# elements in an array.; 39@ROOT.Numba.Declare(['RVecF', 'int'], 'RVecF'); 40def pypowarray(x, y):; 41 return x**y; 42 ; 43ROOT.gInterpreter.ProcessLine('''; 44ROOT::RVecF x = {0, 1, 2, 3};; 45cout << ""pypowarray("" << x << "", 3) = "" << Numba::pypowarray(x, 3) << endl;; 46'''); 47 ; 48# and now w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot004__NumbaDeclare_8py_source.html:107,Load,Loading,107,doc/master/pyroot004__NumbaDeclare_8py_source.html,https://root.cern,https://root.cern/doc/master/pyroot004__NumbaDeclare_8py_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/pyroot005_tfile_context_manager.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; pyroot005_tfile_context_manager.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This tutorial demonstrates the usage of the TFile class as a Python context manager. ; import os; ; import ROOT; from ROOT import TFile; ; # By default, objects of some ROOT types such as `TH1` and its derived types; # are automatically attached to a ROOT.TDirectory when they are created.; # Specifically, at any given point of a ROOT application, the ROOT.gDirectory; # object tells which is the current directory where objects will be attached to.; # The next line will print 'PyROOT' as the name of the current directory.; # That is the global directory created when using ROOT from Python, which is; # the ROOT.gROOT object.; print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); ; # We can check to which directory a newly created histogram is attached.; histo_1 = ROOT.TH1F(""histo_1"", ""histo_1"", 10, 0, 10); print(""Histogram '{}' is attached to: '{}'.\n"".format(histo_1.GetName(), histo_1.GetDirectory().GetName())); ; # For quick saving and forgetting of objects into ROOT files, it is possible to; # open a TFile as a Python context manager. In the context, objects can be; # created, modified and finally written to the file. At the end of the context,; # the file will be automatically closed.; with TFile.Open(""pyroot005_file_1.root"", ""recreate"") as f:; histo_2 = ROOT.TH1F(""histo_2"", ""histo_2"", 10, 0, 10); # Inside the context, the current directory is the open file; print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); # And the created histogram is automatically attached to the file; print(""Histogram '{}' is attached to: '{}'.\n"".format(histo_2.GetName(), histo_2.GetDirectory().GetName())); # Before exiting the context, objects can be written to the file; f.WriteObject(hist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot005__tfile__context__manager_8py.html:119,Load,Loading,119,doc/master/pyroot005__tfile__context__manager_8py.html,https://root.cern,https://root.cern/doc/master/pyroot005__tfile__context__manager_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/pyroot006_tcontext_context_manager.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; pyroot006_tcontext_context_manager.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This tutorial demonstrates the usage of the TContext class as a Python context manager. ; This functionality is related with how TFile works, so it is suggested to also take a look at the pyroot005 tutorial.; import os; ; import ROOT; from ROOT import TDirectory, TFile; ; # Sometimes it is useful to have multiple open files at once. In such cases,; # the current directory will always be the file that was open last.; file_1 = TFile(""pyroot006_file_1.root"", ""recreate""); file_2 = TFile(""pyroot006_file_2.root"", ""recreate""); print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); # Changing directory into another file can be safely done through a TContext; # context manager.; with TDirectory.TContext(file_1):; # Inside the statement, the current directory is file_1; print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); histo_1 = ROOT.TH1F(""histo_1"", ""histo_1"", 10, 0, 10); file_1.WriteObject(histo_1, ""my_histogram""); ; # After the context, the current directory is restored back to file_2. Also, the; # two files are kept open. This means that objects read, written or modified; # inside the context are still available afterwards.; print(""Current directory: '{}'.\n"".format(ROOT.gDirectory.GetName())); if file_1.IsOpen() and file_2.IsOpen():; print(""'{}' and '{}' are open.\n"".format(file_1.GetName(), file_2.GetName())); ; # TContext and TFile context managers can also be used in conjunction, allowing; # for safely:; # - Opening a file, creating, modifying, writing and reading objects in it.; # - Closing the file, storing it on disk.; # - Restoring the previous value of gDirectory to the latest file opened before; # this context, rather than to the global ROOT.gROOT; # Remem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot006__tcontext__context__manager_8py.html:122,Load,Loading,122,doc/master/pyroot006__tcontext__context__manager_8py.html,https://root.cern,https://root.cern/doc/master/pyroot006__tcontext__context__manager_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/ratioplot.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; ratioplot.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; Display two histograms and their ratio. ; This program illustrates how to plot two histograms and their ratio on the same canvas. Original macro by Olivier Couet.; ; from ROOT import TCanvas, TColor, TGaxis, TH1F, TPad; from ROOT import kBlack, kBlue, kRed; ; ; def createH1():; h1 = TH1F(""h1"", (""Two gaussian plots and their ratio; x title; h1 and h2""; "" histograms""), 100, -5, 5); h1.SetLineColor(kBlue+1); h1.SetLineWidth(2); h1.FillRandom(""gaus""); h1.GetYaxis().SetTitleSize(20); h1.GetYaxis().SetTitleFont(43); h1.GetYaxis().SetTitleOffset(1.55); h1.SetStats(0); return h1; ; ; def createH2():; h2 = TH1F(""h2"", ""h2"", 100, -5, 5); h2.FillRandom(""gaus""); h2.SetLineColor(kRed); h2.SetLineWidth(2); return h2; ; ; def createRatio(h1, h2):; h3 = h1.Clone(""h3""); h3.SetLineColor(kBlack); h3.SetMarkerStyle(21); h3.SetTitle(""""); h3.SetMinimum(0.8); h3.SetMaximum(1.35); # Set up plot for markers and errors; h3.Sumw2(); h3.SetStats(0); h3.Divide(h2); ; # Adjust y-axis settings; y = h3.GetYaxis(); y.SetTitle(""ratio h1/h2 ""); y.SetNdivisions(505); y.SetTitleSize(20); y.SetTitleFont(43); y.SetTitleOffset(1.55); y.SetLabelFont(43); y.SetLabelSize(15); ; # Adjust x-axis settings; x = h3.GetXaxis(); x.SetTitleSize(20); x.SetTitleFont(43); x.SetTitleOffset(4.0); x.SetLabelFont(43); x.SetLabelSize(15); ; return h3; ; ; def createCanvasPads():; c = TCanvas(""c"", ""canvas"", 800, 800); # Upper histogram plot is pad1; pad1 = TPad(""pad1"", ""pad1"", 0, 0.3, 1, 1.0); pad1.SetBottomMargin(0) # joins upper and lower plot; pad1.SetGridx(); pad1.Draw(); # Lower ratio plot is pad2; c.cd() # returns to main canvas before defining pad2; pad2 = TPad(""pad2"", ""pad2"", 0, 0.05, 1, 0.3); pad2.SetTopMargin(0) # joins upper and lower plot; pad2.SetBottomMargin(0.2); pad2.SetGridx(); pad2.Draw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ratioplot_8py.html:97,Load,Loading,97,doc/master/ratioplot_8py.html,https://root.cern,https://root.cern/doc/master/ratioplot_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/shapes.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; shapes.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; Draw the geometry using the x3d viewver. ; Note that this viewver may also be invoked from the ""View"" menu in the canvas tool bar; once in x3d viewer, type m to see the menu. For example typing r will show a solid model of this geometry.; ; import ROOT; ; c1 = ROOT.TCanvas( 'c1', 'Geometry Shapes', 200, 10, 700, 500 ); ; # delete previous geometry objects in case this script is reexecuted; if hasattr(ROOT, 'gGeometry') and ROOT.gGeometry:; ROOT.gGeometry.GetListOfNodes().Delete(); ROOT.gGeometry.GetListOfShapes().Delete(); ; # Define some volumes; brik = ROOT.TBRIK( 'BRIK', 'BRIK', 'void', 200, 150, 150 ); trd1 = ROOT.TTRD1( 'TRD1', 'TRD1', 'void', 200, 50, 100, 100 ); trd2 = ROOT.TTRD2( 'TRD2', 'TRD2', 'void', 200, 50, 200, 50, 100 ); trap = ROOT.TTRAP( 'TRAP', 'TRAP', 'void', 190, 0, 0, 60, 40, 90, 15, 120, 80, 180, 15 ); para = ROOT.TPARA( 'PARA', 'PARA', 'void', 100, 200, 200, 15, 30, 30 ); gtra = ROOT.TGTRA( 'GTRA', 'GTRA', 'void', 390, 0, 0, 20, 60, 40, 90, 15, 120, 80, 180, 15 ); tube = ROOT.TTUBE( 'TUBE', 'TUBE', 'void', 150, 200, 400 ); tubs = ROOT.TTUBS( 'TUBS', 'TUBS', 'void', 80, 100, 100, 90, 235 ); cone = ROOT.TCONE( 'CONE', 'CONE', 'void', 100, 50, 70, 120, 150 ); cons = ROOT.TCONS( 'CONS', 'CONS', 'void', 50, 100, 100, 200, 300, 90, 270 ); sphe = ROOT.TSPHE( 'SPHE', 'SPHE', 'void', 25, 340, 45, 135, 0, 270 ); sphe1 = ROOT.TSPHE( 'SPHE1', 'SPHE1', 'void', 0, 140, 0, 180, 0, 360 ); sphe2 = ROOT.TSPHE( 'SPHE2', 'SPHE2', 'void', 0, 200, 10, 120, 45, 145 ); ; pcon = ROOT.TPCON( 'PCON', 'PCON', 'void', 180, 270, 4 ); pcon.DefineSection( 0, -200, 50, 100 ); pcon.DefineSection( 1, -50, 50, 80 ); pcon.DefineSection( 2, 50, 50, 80 ); pcon.DefineSection( 3, 200, 50, 100 ); ; pgon = ROOT.TPGON( 'PGON', 'PGON', 'void', 180, 270, 8, 4 ); pgon.Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/shapes_8py.html:94,Load,Loading,94,doc/master/shapes_8py.html,https://root.cern,https://root.cern/doc/master/shapes_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/staff.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; staff.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; example of macro to read data from an ascii file and create a root file with a Tree. ; NOTE: comparing the results of this macro with those of staff.C, you'll notice that the resultant file is a couple of bytes smaller, because the code below strips all white-spaces, whereas the .C version does not.; ; import re, array, os; import ROOT; from ROOT import TFile, TTree, gROOT, addressof; ; ## A C/C++ structure is required, to allow memory based access; gROOT.ProcessLine(; ""struct staff_t {\; Int_t Category;\; UInt_t Flag;\; Int_t Age;\; Int_t Service;\; Int_t Children;\; Int_t Grade;\; Int_t Step;\; Int_t Hrweek;\; Int_t Cost;\; Char_t Division[4];\; Char_t Nation[3];\; };"" );; ; ## Function to read in data from ASCII file and fill the ROOT tree; def staff():; ; staff = ROOT.staff_t(); ; # The input file cern.dat is a copy of the CERN staff data base; # from 1988; ; f = TFile( 'staff.root', 'RECREATE' ); tree = TTree( 'T', 'staff data from ascii file' ); tree.Branch( 'staff', staff, 'Category/I:Flag:Age:Service:Children:Grade:Step:Hrweek:Cost' ); tree.Branch( 'Divisions', addressof( staff, 'Division' ), 'Division/C' ); tree.Branch( 'Nation', addressof( staff, 'Nation' ), 'Nation/C' ); ; # note that the branches Division and Nation cannot be on the first branch; fname = os.path.join(str(ROOT.gROOT.GetTutorialDir()), 'tree', 'cernstaff.dat'); for line in open(fname).readlines():; t = list(filter( lambda x: x, re.split( '\s+', line ) ) ); staff.Category = int(t[0]) # assign as integers; staff.Flag = int(t[1]); staff.Age = int(t[2]); staff.Service = int(t[3]); staff.Children = int(t[4]); staff.Grade = int(t[5]); staff.Step = int(t[6]); staff.Hrweek = int(t[7]); staff.Cost = int(t[8]); staff.Division = t[9] # assign as strings; staff.Nation = t[10]; ; tree.Fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/staff_8py.html:93,Load,Loading,93,doc/master/staff_8py.html,https://root.cern,https://root.cern/doc/master/staff_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/surfaces.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; surfaces.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; Surfaces example . ; from ROOT import TCanvas, TPaveText, TPad, TF2; from ROOT import gROOT, gStyle; ; ; ; c1 = TCanvas( 'c1', 'Surfaces Drawing Options', 200, 10, 700, 900 ); c1.SetFillColor( 42 ); gStyle.SetFrameFillColor( 42 ); title = TPaveText( .2, 0.96, .8, .995 ); title.SetFillColor( 33 ); title.AddText( 'Examples of Surface options' ); title.Draw(); ; pad1 = TPad( 'pad1', 'Gouraud shading', 0.03, 0.50, 0.98, 0.95, 21 ); pad2 = TPad( 'pad2', 'Color mesh', 0.03, 0.02, 0.98, 0.48, 21 ); pad1.Draw(); pad2.Draw(); ; # We generate a 2-D function; f2 = TF2( 'f2', 'x**2 + y**2 - x**3 -8*x*y**4', -1, 1.2, -1.5, 1.5 ); f2.SetContour( 48 ); f2.SetFillColor( 45 ); ; # Draw this function in pad1 with Gouraud shading option; pad1.cd(); pad1.SetPhi( -80 ); pad1.SetLogz(); f2.Draw( 'surf4' ); ; # Draw this function in pad2 with color mesh option; pad2.cd(); pad2.SetTheta( 25 ); pad2.SetPhi( -110 ); pad2.SetLogz(); f2.Draw( 'surf1' ); ; c1.Update(); TCanvasThe Canvas class.Definition TCanvas.h:23; TF2A 2-Dim function with parameters.Definition TF2.h:29; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; AuthorWim Lavrijsen ; Definition in file surfaces.py. tutorialspyrootsurfaces.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/surfaces_8py.html:96,Load,Loading,96,doc/master/surfaces_8py.html,https://root.cern,https://root.cern/doc/master/surfaces_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/tornado.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tornado.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; Tornado example. ; . ; from ROOT import TCanvas, TView, TPolyMarker3D, TPaveText; from ROOT import gROOT, gBenchmark; from math import cos, sin, pi; ; gBenchmark.Start( 'tornado' ); ; d = 16; numberOfPoints = 200; numberOfCircles = 40; ; # create and open a canvas; sky = TCanvas( 'sky', 'Tornado', 300, 10, 700, 500 ); sky.SetFillColor( 14 ); ; # creating view; view = TView.CreateView(); rng = numberOfCircles * d; view.SetRange( 0, 0, 0, 4.0*rng, 2.0*rng, rng ); ; polymarkers = []; for j in range( d, numberOfCircles * d, d ):; ; # create a PolyMarker3D; pm3d = TPolyMarker3D( numberOfPoints ); ; # set points; for i in range( 1, numberOfPoints ) :; csin = sin( 2*pi / numberOfPoints * i ) + 1; ccos = cos( 2*pi / numberOfPoints * i ) + 1; esin = sin( 2*pi / (numberOfCircles*d) * j ) + 1; x = j * ( csin + esin );; y = j * ccos;; z = j;; pm3d.SetPoint( i, x, y, z );; ; # set marker size, color & style; pm3d.SetMarkerSize( 1 ); pm3d.SetMarkerColor( 2 + ( d == ( j & d ) ) ); pm3d.SetMarkerStyle( 3 ); ; # draw; pm3d.Draw(); ; # save a reference; polymarkers.append( pm3d ); ; gBenchmark.Show( 'tornado' ); ; ct = gBenchmark.GetCpuTime( 'tornado' ); timeStr = 'Execution time: %g sec.' % ct; ; text = TPaveText( 0.1, 0.81, 0.9, 0.97 ); text.SetFillColor( 42 ); text.AddText( 'PyROOT example: tornado.py' ); text.AddText( timeStr ); text.Draw(); ; sky.Update(); TCanvasThe Canvas class.Definition TCanvas.h:23; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPolyMarker3DA 3D polymarker.Definition TPolyMarker3D.h:33; TView::CreateViewstatic TView * CreateView(Int_t system=1, const Double_t *rmin=nullptr, const Double_t *rmax=nullptr)Create a concrete default 3-d view via the plug-in manager.Definition TView.cxx:27; AuthorWim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tornado_8py.html:95,Load,Loading,95,doc/master/tornado_8py.html,https://root.cern,https://root.cern/doc/master/tornado_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/pyroot/zdemo.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; zdemo.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This macro is an example of graphs in log scales with annotations. ; The presented results are predictions of invariant cross-section of Direct Photons produced at RHIC energies, based on the universality of scaling function H(z).; These Figures were published in JINR preprint E2-98-64, Dubna, 1998 and submitted to CPC. ; import ROOT; from array import array; ; NMAX = 20; Z = array( 'f', [0.]*NMAX ); HZ = array( 'f', [0.]*NMAX ); PT = array( 'f', [0.]*NMAX ); INVSIG = array( 'f', [0.]*NMAX ); ; NLOOP = 0; saves = {}; ; #_______________________________________________________________________________; def hz_calc( ENERG, DENS, TGRAD, PTMIN, PTMAX, DELP ):; from math import sin, cos, sqrt; global NLOOP; global Z, HZ, PT, INVSIG; ; CSEFT= 1.; GM1 = 0.00001; GM2 = 0.00001; A1 = 1.; A2 = 1.; ALX = 2.; BETA = 1.; KF1 = 8.E-7; KF2 = 5.215; ; MN = 0.9383; DEGRAD=0.01745329; ; # print 'ENR= %f DENS= %f PTMIN= %f PTMAX= %f DELP= %f ' % (ENERG,DENS,PTMIN,PTMAX,DELP); ; DNDETA= DENS; MB1 = MN*A1; MB2 = MN*A2; EB1 = ENERG/2.*A1; EB2 = ENERG/2.*A2; M1 = GM1; M2 = GM2; THET = TGRAD*DEGRAD; NLOOP = int((PTMAX-PTMIN)/DELP); ; for I in range(NLOOP):; PT[I]=PTMIN+I*DELP; PTOT = PT[I]/sin(THET); ; ETOT = sqrt(M1*M1 + PTOT*PTOT); PB1 = sqrt(EB1*EB1 - MB1*MB1); PB2 = sqrt(EB2*EB2 - MB2*MB2); P2P3 = EB2*ETOT+PB2*PTOT*cos(THET); P1P2 = EB2*EB1+PB2*PB1; P1P3 = EB1*ETOT-PB1*PTOT*cos(THET); ; X1 = P2P3/P1P2; X2 = P1P3/P1P2; Y1 = X1+sqrt(X1*X2*(1.-X1)/(1.-X2)); Y2 = X2+sqrt(X1*X2*(1.-X2)/(1.-X1)); ; S = (MB1*MB1)+2.*P1P2+(MB2*MB2); SMIN = 4.*((MB1*MB1)*(X1*X1) +2.*X1*X2*P1P2+(MB2*MB2)*(X2*X2)); SX1 = 4.*( 2*(MB1*MB1)*X1+2*X2*P1P2); SX2 = 4.*( 2*(MB2*MB2)*X2+2*X1*P1P2); SX1X2= 4.*(2*P1P2); DELM = pow((1.-Y1)*(1.-Y2),ALX); ; Z[I] = sqrt(SMIN)/DELM/pow(DNDETA,BETA); ; Y1X1 = 1. +X2*(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/zdemo_8py.html:93,Load,Loading,93,doc/master/zdemo_8py.html,https://root.cern,https://root.cern/doc/master/zdemo_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/quadp/portfolio.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. portfolio.C File ReferenceTutorials » Quadratic programming package. Detailed Description; This macro shows in detail the use of the quadratic programming package quadp . ; Running this macro :; .x portfolio.C+; or; gSystem->Load(""libQuadp"");; .L portFolio.C+; portfolio(); gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; Let's first review what we exactly mean by ""quadratic programming"" :; We want to minimize the following objective function :; \( c^T x + ( 1/2 ) x^T Q x \) wrt. the vector \( x \); \( c \) is a vector and \( Q \) a symmetric positive definite matrix; You might wonder what is so special about this objective which is quadratic in the unknowns, that can not be done by Minuit/Fumili . Well, we have in addition the following boundary conditions on \( x \):. \[; A x = b \\; clo \le C x \le cup \\; xlo \le x \le xup; \]. where A and C are arbitrary matrices and the rest are vectors; Not all these constraints have to be defined . Our example will only use \( xlo \), \( A \) and \( b \) Still, this could be handled by a general non-linear minimizer like Minuit by introducing so-called ""slack"" variables . However, quadp is tailored to objective functions not more complex than being quadratic . This allows usage of solving techniques which are even stable for problems involving for instance 500 variables, 100 inequality conditions and 50 equality conditions .; Enough said about quadratic programming, let's return to our example . Suppose, after a long day of doing physics, you have a look at your investments and realize that an early retirement is not possible, given the returns of your stocks . So what now ? ROOT to the rescue ...; In 1990 Harry Markowitz was awarded the Nobel ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/portfolio_8C.html:95,Load,Loading,95,doc/master/portfolio_8C.html,https://root.cern,https://root.cern/doc/master/portfolio_8C.html,5,['Load'],"['Load', 'Loading', 'Loadvirtual']"
Performance,". ROOT: tutorials/roofit/rf101_basics.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf101_basics.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: fitting, plotting, toy data generation on one-dimensional PDFs. ; pdf = gauss(x,m,s). ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""RooPlot.h""; #include ""TAxis.h""; using namespace RooFit;; ; void rf101_basics(); {; // S e t u p m o d e l; // ---------------------; ; // Declare variables x,mean,sigma with associated name, title, initial value and allowed range; RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar mean(""mean"", ""mean of gaussian"", 1, -10, 10);; RooRealVar sigma(""sigma"", ""width of gaussian"", 1, 0.1, 10);; ; // Build gaussian pdf in terms of x,mean and sigma; RooGaussian gauss(""gauss"", ""gaussian PDF"", x, mean, sigma);; ; // Construct plot frame in 'x'; RooPlot *xframe = x.frame(Title(""Gaussian pdf.""));; ; // P l o t m o d e l a n d c h a n g e p a r a m e t e r v a l u e s; // ---------------------------------------------------------------------------; ; // Plot gauss in frame (i.e. in x); gauss.plotOn(xframe);; ; // Change the value of sigma to 3; sigma.setVal(3);; ; // Plot gauss in frame (i.e. in x) and draw frame on canvas; gauss.plotOn(xframe, LineColor(kRed));; ; // G e n e r a t e e v e n t s; // -----------------------------; ; // Generate a dataset of 1000 events in x from gauss; std::unique_ptr<RooDataSet> data{gauss.generate(x, 10000)};; ; // Make a second plot frame in x and draw both the; // data and the pdf in the frame; RooPlot *xframe2 = x.frame(Title(""Gaussian pdf with data""));; data->plotOn(xframe2);; gauss.plotOn(xframe2);; ; // F i t m o d e l t o d a t a; // -----------------------------; ; // Fit pdf to data; gauss.fitTo(*data, PrintLevel(-1));; ; // Print values of mean and sigma (that now reflect fitted values and errors); mean.Print();; sigm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf101__basics_8C.html:99,Load,Loading,99,doc/master/rf101__basics_8C.html,https://root.cern,https://root.cern/doc/master/rf101__basics_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf101_basics.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf101_basics.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; This tutorial illustrates the basic features of RooFit. . ; import ROOT; ; # Set up model; # ---------------------; # Declare variables x,mean,sigma with associated name, title, initial; # value and allowed range; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); mean = ROOT.RooRealVar(""mean"", ""mean of gaussian"", 1, -10, 10); sigma = ROOT.RooRealVar(""sigma"", ""width of gaussian"", 1, 0.1, 10); ; # Build gaussian pdf in terms of x,mean and sigma; gauss = ROOT.RooGaussian(""gauss"", ""gaussian PDF"", x, mean, sigma); ; # Construct plot frame in 'x'; xframe = x.frame(Title=""Gaussian pdf"") # RooPlot; ; # Plot model and change parameter values; # ---------------------------------------------------------------------------; # Plot gauss in frame (i.e. in x); gauss.plotOn(xframe); ; # Change the value of sigma to 3; sigma.setVal(3); ; # Plot gauss in frame (i.e. in x) and draw frame on canvas; gauss.plotOn(xframe, LineColor=""r""); ; # Generate events; # -----------------------------; # Generate a dataset of 1000 events in x from gauss; data = gauss.generate({x}, 10000) # ROOT.RooDataSet; ; # Make a second plot frame in x and draw both the; # data and the pdf in the frame; xframe2 = x.frame(Title=""Gaussian pdf with data"") # RooPlot; data.plotOn(xframe2); gauss.plotOn(xframe2); ; # Fit model to data; # -----------------------------; # Fit pdf to data; gauss.fitTo(data, PrintLevel=-1); ; # Print values of mean and sigma (that now reflect fitted values and; # errors); mean.Print(); sigma.Print(); ; # Draw all frames on a canvas; c = ROOT.TCanvas(""rf101_basics"", ""rf101_basics"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.6); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); xframe2.GetYaxis().SetTitleOffset(1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf101__basics_8py.html:100,Load,Loading,100,doc/master/rf101__basics_8py.html,https://root.cern,https://root.cern/doc/master/rf101__basics_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf102_dataimport.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf102_dataimport.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: importing data from ROOT TTrees and THx histograms. . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooDataHist.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""RooPlot.h""; #include ""TTree.h""; #include ""TH1D.h""; #include ""TRandom.h""; using namespace RooFit;; ; TH1 *makeTH1();; TTree *makeTTree();; ; void rf102_dataimport(); {; // ---------------------------------------------------; // I m p o r t i n g R O O T h i s t o g r a m s; // ===================================================; ; // I m p o r t T H 1 i n t o a R o o D a t a H i s t; // ---------------------------------------------------------; ; // Create a ROOT TH1 histogram; TH1 *hh = makeTH1();; ; // Declare observable x; RooRealVar x(""x"", ""x"", -10, 10);; ; // Create a binned dataset that imports contents of TH1 and associates its contents to observable 'x'; RooDataHist dh(""dh"", ""dh"", x, Import(*hh));; ; // P l o t a n d f i t a R o o D a t a H i s t; // ---------------------------------------------------; ; // Make plot of binned dataset showing Poisson error bars (RooFit default); RooPlot *frame = x.frame(Title(""Imported TH1 with Poisson error bars""));; dh.plotOn(frame);; ; // Fit a Gaussian pdf to the data; RooRealVar mean(""mean"", ""mean"", 0, -10, 10);; RooRealVar sigma(""sigma"", ""sigma"", 3, 0.1, 10);; RooGaussian gauss(""gauss"", ""gauss"", x, mean, sigma);; gauss.fitTo(dh, PrintLevel(-1));; gauss.plotOn(frame);; ; // P l o t a n d f i t a R o o D a t a H i s t w i t h i n t e r n a l e r r o r s; // ---------------------------------------------------------------------------------------------; ; // If histogram has custom error (i.e. its contents is does not originate from a Poisson process; // but e.g. is a sum of weighted events) you c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf102__dataimport_8C.html:103,Load,Loading,103,doc/master/rf102__dataimport_8C.html,https://root.cern,https://root.cern/doc/master/rf102__dataimport_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf102_dataimport.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf102_dataimport.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'BASIC FUNCTIONALITY' RooFit tutorial macro #102 Importing data from ROOT TTrees and THx histograms . ; import ROOT; from array import array; ; ; def makeTH1():; ; # Create ROOT ROOT.TH1 filled with a Gaussian distribution; ; hh = ROOT.TH1D(""hh"", ""hh"", 25, -10, 10); for i in range(100):; hh.Fill(ROOT.gRandom.Gaus(0, 3)); return hh; ; ; def makeTTree():; # Create ROOT ROOT.TTree filled with a Gaussian distribution in x and a; # uniform distribution in y; ; tree = ROOT.TTree(""tree"", ""tree""); px = array(""d"", [0]); py = array(""d"", [0]); tree.Branch(""x"", px, ""x/D""); tree.Branch(""y"", py, ""y/D""); for i in range(100):; px[0] = ROOT.gRandom.Gaus(0, 3); py[0] = ROOT.gRandom.Uniform() * 30 - 15; tree.Fill(); return tree; ; ; ############################; # Importing ROOT histograms; ############################; # Import ROOT TH1 into a RooDataHist; # ---------------------------------------------------------; # Create a ROOT TH1 histogram; hh = makeTH1(); ; # Declare observable x; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); ; # Create a binned dataset that imports contents of ROOT.TH1 and associates; # its contents to observable 'x'; dh = ROOT.RooDataHist(""dh"", ""dh"", [x], Import=hh); ; # Plot and fit a RooDataHist; # ---------------------------------------------------; # Make plot of binned dataset showing Poisson error bars (RooFit default); frame = x.frame(Title=""Imported ROOT.TH1 with Poisson error bars""); dh.plotOn(frame); ; # Fit a Gaussian p.d.f to the data; mean = ROOT.RooRealVar(""mean"", ""mean"", 0, -10, 10); sigma = ROOT.RooRealVar(""sigma"", ""sigma"", 3, 0.1, 10); gauss = ROOT.RooGaussian(""gauss"", ""gauss"", x, mean, sigma); gauss.fitTo(dh, PrintLevel=-1); gauss.plotOn(frame); ; # Plot and fit a RooDataHist with internal errors; # -----------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf102__dataimport_8py.html:104,Load,Loading,104,doc/master/rf102__dataimport_8py.html,https://root.cern,https://root.cern/doc/master/rf102__dataimport_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf103_interprfuncs.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf103_interprfuncs.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: interpreted functions and PDFs. . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooFitResult.h""; #include ""RooGenericPdf.h""; ; using namespace RooFit;; ; void rf103_interprfuncs(); {; // ----------------------------------------------------; // G e n e r i c i n t e r p r e t e d p . d . f .; // ====================================================; ; // Declare observable x; RooRealVar x(""x"", ""x"", -20, 20);; ; // C o n s t r u c t g e n e r i c p d f f r o m i n t e r p r e t e d e x p r e s s i o n; // -------------------------------------------------------------------------------------------------; ; // To construct a proper pdf, the formula expression is explicitly normalized internally by dividing; // it by a numeric integral of the expression over x in the range [-20,20]; //; RooRealVar alpha(""alpha"", ""alpha"", 5, 0.1, 10);; RooGenericPdf genpdf(""genpdf"", ""genpdf"", ""(1+0.1*abs(x)+sin(sqrt(abs(x*alpha+0.1))))"", RooArgSet(x, alpha));; ; // S a m p l e , f i t a n d p l o t g e n e r i c p d f; // ---------------------------------------------------------------; ; // Generate a toy dataset from the interpreted pdf; std::unique_ptr<RooDataSet> data{genpdf.generate(x, 10000)};; ; // Fit the interpreted pdf to the generated data; genpdf.fitTo(*data, PrintLevel(-1));; ; // Make a plot of the data and the pdf overlaid; RooPlot *xframe = x.frame(Title(""Interpreted expression pdf""));; data->plotOn(xframe);; genpdf.plotOn(xframe);; ; // -----------------------------------------------------------------------------------------------------------; // S t a n d a r d p . d . f a d j u s t w i t h i n t e r p r e t e d h e l p e r ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf103__interprfuncs_8C.html:105,Load,Loading,105,doc/master/rf103__interprfuncs_8C.html,https://root.cern,https://root.cern/doc/master/rf103__interprfuncs_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf103_interprfuncs.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf103_interprfuncs.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: interpreted functions and pdfs . ; import ROOT; ; # Generic interpreted pdf; # ------------------------------; ; # Declare observable x; x = ROOT.RooRealVar(""x"", ""x"", -20, 20); ; # Construct generic pdf from interpreted expression; # ------------------------------------------------------; ; # ROOT.To construct a proper pdf, the formula expression is explicitly normalized internally by dividing; # it by a numeric integral of the expression over x in the range [-20,20]; #; alpha = ROOT.RooRealVar(""alpha"", ""alpha"", 5, 0.1, 10); genpdf = ROOT.RooGenericPdf(""genpdf"", ""genpdf"", ""(1+0.1*abs(x)+sin(sqrt(abs(x*alpha+0.1))))"", [x, alpha]); ; # Sample, fit and plot generic pdf; # ---------------------------------------------------------------; ; # Generate a toy dataset from the interpreted pdf; data = genpdf.generate({x}, 10000); ; # Fit the interpreted pdf to the generated data; genpdf.fitTo(data, PrintLevel=-1); ; # Make a plot of the data and the pdf overlaid; xframe = x.frame(Title=""Interpreted expression pdf""); data.plotOn(xframe); genpdf.plotOn(xframe); ; # Standard pdf adjust with interpreted helper function; # ------------------------------------------------------------------------------------------------------------; # Make a gauss(x,sqrt(mean2),sigma) from a standard ROOT.RooGaussian #; #; # Construct standard pdf with formula replacing parameter; # ------------------------------------------------------------------------------------------------------------; ; # Construct parameter mean2 and sigma; mean2 = ROOT.RooRealVar(""mean2"", ""mean^2"", 10, 0, 200); sigma = ROOT.RooRealVar(""sigma"", ""sigma"", 3, 0.1, 10); ; # Construct interpreted function mean = sqrt(mean^2); mean = ROOT.RooFormulaVar(""mean"", ""mean"", ""sq",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf103__interprfuncs_8py.html:106,Load,Loading,106,doc/master/rf103__interprfuncs_8py.html,https://root.cern,https://root.cern/doc/master/rf103__interprfuncs_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf104_classfactory.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf104_classfactory.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: The class factory for functions and pdfs ; NOTE: This demo uses code that is generated by the macro, therefore it cannot be compiled in one step by ACliC. To run this macro compiled with ACliC do; root>.x rf104_classfactory.C // run interpreted to generate code; root>.L MyPdfV3.cxx+ // Compile and load created class; root>.x rf104_classfactory.C+ // run compiled code; rf104_classfactoryDefinition rf104_classfactory.py:1. ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooClassFactory.h""; #include ""TROOT.h""; ; using namespace RooFit;; ; void rf104_classfactory(); {; // W r i t e c l a s s s k e l e t o n c o d e; // --------------------------------------------------; ; // Write skeleton pdf class with variable x,a,b; // To use this class,; // - Edit the file MyPdfV1.cxx and implement the evaluate() method in terms of x,a and b; // - Compile and link class with '.x MyPdfV1.cxx+'; //; RooClassFactory::makePdf(""MyPdfV1"", ""x,A,B"");; ; // W i t h a d d e d i n i t i a l v a l u e e x p r e s s i o n; // ---------------------------------------------------------------------; ; // Write skeleton pdf class with variable x,a,b and given formula expression; // To use this class,; // - Compile and link class with '.x MyPdfV2.cxx+'; //; RooClassFactory::makePdf(""MyPdfV2"", ""x,A,B"", """", ""A*fabs(x)+pow(x-B,2)"");; ; // W i t h a d d e d a n a l y t i c a l i n t e g r a l e x p r e s s i o n; // ---------------------------------------------------------------------------------; ; // Write skeleton pdf class with variable x,a,b, given formula expression _and_; // given expression for analytical integral over x; // To use this class,; // -",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf104__classfactory_8C.html:105,Load,Loading,105,doc/master/rf104__classfactory_8C.html,https://root.cern,https://root.cern/doc/master/rf104__classfactory_8C.html,2,"['Load', 'load']","['Loading', 'load']"
Performance,". ROOT: tutorials/roofit/rf104_classfactory.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf104_classfactory.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: the class factory for functions and pdfs ; NOTE: This demo uses code that is generated by the macro, which can be compiled on the fly (set to MyPdfV3 below). To use MyPdfV1 or MyPdfV2, adjust lines below accordingly. ; import ROOT; ; # Write class skeleton code; # --------------------------------------------------; ; # Write skeleton pdf class with variable x,a,b; # To use this class,; # - Edit the file MyPdfV1.cxx and implement the evaluate() method in terms of x,a and b; # - Compile and link class with '.x MyPdfV1.cxx+'; #; ROOT.RooClassFactory.makePdf(""MyPdfV1"", ""x,A,B""); ; # With added initial value expression; # ---------------------------------------------------------------------; ; # Write skeleton pdf class with variable x,a,b and given formula expression; # To use this class,; # - Compile and link class with '.x MyPdfV2.cxx+'; #; ROOT.RooClassFactory.makePdf(""MyPdfV2"", ""x,A,B"", """", ""A*fabs(x)+pow(x-B,2)""); ; # With added analytical integral expression; # ---------------------------------------------------------------------------------; ; # Write skeleton pdf class with variable x,a,b, given formula expression _and_; # given expression for analytical integral over x; # To use this class,; # - Compile and link class with '.x MyPdfV3.cxx+'; #; ROOT.RooClassFactory.makePdf(; ""MyPdfV3"",; ""x,A,B"",; """",; ""A*fabs(x)+pow(x-B,2)"",; True,; False,; ""x:(A/2)*(pow(x.max(rangeName),2)+pow(x.min(rangeName),2))+(1./3)*(pow(x.max(rangeName)-B,3)-pow(x.min(rangeName)-B,3))"",; ); ; # Use instance of created class; # ---------------------------------------------------------; ; # Compile MyPdfV3 class; ROOT.gROOT.ProcessLineSync("".x MyPdfV3.cxx+""); ; # Creat instance of MyPdfV3 class; a = ROOT.RooRealVar(""a"", ""a"", 1); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf104__classfactory_8py.html:106,Load,Loading,106,doc/master/rf104__classfactory_8py.html,https://root.cern,https://root.cern/doc/master/rf104__classfactory_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf105_funcbinding.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf105_funcbinding.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: binding ROOT math functions as RooFit functions and pdfs . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TMath.h""; #include ""TF1.h""; #include ""Math/DistFunc.h""; #include ""RooTFnBinding.h""; ; using namespace RooFit;; ; void rf105_funcbinding(); {; ; // B i n d T M a t h : : E r f C f u n c t i o n; // ---------------------------------------------------; ; // Bind one-dimensional TMath::Erf function as RooAbsReal function; RooRealVar x(""x"", ""x"", -3, 3);; RooAbsReal *errorFunc = bindFunction(""erf"", TMath::Erf, x);; ; // Print erf definition; errorFunc->Print();; ; // Plot erf on frame; RooPlot *frame1 = x.frame(Title(""TMath::Erf bound as RooFit function""));; errorFunc->plotOn(frame1);; ; // B i n d R O O T : : M a t h : : b e t a _ p d f C f u n c t i o n; // -----------------------------------------------------------------------; ; // Bind pdf ROOT::Math::Beta with three variables as RooAbsPdf function; RooRealVar x2(""x2"", ""x2"", 0, 0.999);; RooRealVar a(""a"", ""a"", 5, 0, 10);; RooRealVar b(""b"", ""b"", 2, 0, 10);; RooAbsPdf *beta = bindPdf(""beta"", ROOT::Math::beta_pdf, x2, a, b);; ; // Perf beta definition; beta->Print();; ; // Generate some events and fit; std::unique_ptr<RooDataSet> data{beta->generate(x2, 10000)};; beta->fitTo(*data, PrintLevel(-1));; ; // Plot data and pdf on frame; RooPlot *frame2 = x2.frame(Title(""ROOT::Math::Beta bound as RooFit pdf""));; data->plotOn(frame2);; beta->plotOn(frame2);; ; // B i n d R O O T T F 1 a s R o o F i t f u n c t i o n; // ---------------------------------------------------------------; ; // Create a ROOT TF1 function; TF1 *fa1 = new TF1(""fa1"", ""sin(x)/x"", 0, 10);; ; // Create an ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf105__funcbinding_8C.html:104,Load,Loading,104,doc/master/rf105__funcbinding_8C.html,https://root.cern,https://root.cern/doc/master/rf105__funcbinding_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf105_funcbinding.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf105_funcbinding.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'BASIC FUNCTIONALITY' RooFit tutorial macro #105 Demonstration of binding ROOT Math functions as RooFit functions and pdfs . ; import ROOT; ; # Bind ROOT TMath::Erf C function; # ---------------------------------------------------; ; # Bind one-dimensional ROOT.TMath.Erf function as ROOT.RooAbsReal function; x = ROOT.RooRealVar(""x"", ""x"", -3, 3); erf = ROOT.RooFit.bindFunction(""erf"", ROOT.TMath.Erf, x); ; # Print erf definition; erf.Print(); ; # Plot erf on frame; frame1 = x.frame(Title=""TMath.Erf bound as ROOT.RooFit function""); erf.plotOn(frame1); ; # Bind ROOT::Math::beta_pdf C function; # -----------------------------------------------------------------------; ; # Bind pdf ROOT.Math.Beta with three variables as ROOT.RooAbsPdf function; x2 = ROOT.RooRealVar(""x2"", ""x2"", 0, 0.999); a = ROOT.RooRealVar(""a"", ""a"", 5, 0, 10); b = ROOT.RooRealVar(""b"", ""b"", 2, 0, 10); beta = ROOT.RooFit.bindPdf(""beta"", ROOT.Math.beta_pdf, x2, a, b); ; # Perf beta definition; beta.Print(); ; # Generate some events and fit; data = beta.generate({x2}, 10000); beta.fitTo(data, PrintLevel=-1); ; # Plot data and pdf on frame; frame2 = x2.frame(Title=""ROOT.Math.Beta bound as ROOT.RooFit pdf""); data.plotOn(frame2); beta.plotOn(frame2); ; # Bind ROOT TF1 as RooFit function; # ---------------------------------------------------------------; ; # Create a ROOT TF1 function; fa1 = ROOT.TF1(""fa1"", ""sin(x)/x"", 0, 10); ; # Create an observable; x3 = ROOT.RooRealVar(""x3"", ""x3"", 0.01, 20); ; # Create binding of TF1 object to above observable; rfa1 = ROOT.RooFit.bindFunction(fa1, x3); ; # Print rfa1 definition; rfa1.Print(); ; # Make plot frame in observable, TF1 binding function; frame3 = x3.frame(Title=""TF1 bound as ROOT.RooFit function""); rfa1.plotOn(frame3); ; c = R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf105__funcbinding_8py.html:105,Load,Loading,105,doc/master/rf105__funcbinding_8py.html,https://root.cern,https://root.cern/doc/master/rf105__funcbinding_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf106_plotdecoration.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf106_plotdecoration.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: adding boxes with parameters, statistics to RooPlots, decorating with arrows, text etc... . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TText.h""; #include ""TArrow.h""; #include ""TFile.h""; using namespace RooFit;; ; void rf106_plotdecoration(); {; // S e t u p m o d e l; // ---------------------; ; // Create observables; RooRealVar x(""x"", ""x"", -10, 10);; ; // Create Gaussian; RooRealVar sigma(""sigma"", ""sigma"", 1, 0.1, 10);; RooRealVar mean(""mean"", ""mean"", -3, -10, 10);; RooGaussian gauss(""gauss"", ""gauss"", x, mean, sigma);; ; // Generate a sample of 1000 events with sigma=3; std::unique_ptr<RooDataSet> data{gauss.generate(x, 1000)};; ; // Fit pdf to data; gauss.fitTo(*data, PrintLevel(-1));; ; // P l o t p . d . f a n d d a t a; // -------------------------------------; ; // Overlay projection of gauss on data; RooPlot *frame = x.frame(Name(""xframe""), Title(""RooPlot with decorations""), Bins(40));; data->plotOn(frame);; gauss.plotOn(frame);; ; // A d d b o x w i t h p d f p a r a m e t e r s; // -----------------------------------------------------; ; // Left edge of box starts at 55% of Xaxis); gauss.paramOn(frame, Layout(0.55));; ; // A d d b o x w i t h d a t a s t a t i s t i c s; // -------------------------------------------------------; ; // X size of box is from 55% to 99% of Xaxis range, top of box is at 80% of Yaxis range); data->statOn(frame, Layout(0.55, 0.99, 0.8));; ; // A d d t e x t a n d a r r o w; // -----------------------------------; ; // Add text to frame; TText *txt = new TText(2, 100, ""Signal"");; txt->SetTextSize(0.04);; txt->SetTextColor(kRed);; frame->addObject(txt);; ; // Add arrow to fra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf106__plotdecoration_8C.html:107,Load,Loading,107,doc/master/rf106__plotdecoration_8C.html,https://root.cern,https://root.cern/doc/master/rf106__plotdecoration_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf106_plotdecoration.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf106_plotdecoration.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: adding boxes with parameters to RooPlots and decorating with arrows, etc... . ; import ROOT; ; # Set up model; # ---------------------; ; # Create observables; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); ; # Create Gaussian; sigma = ROOT.RooRealVar(""sigma"", ""sigma"", 1, 0.1, 10); mean = ROOT.RooRealVar(""mean"", ""mean"", -3, -10, 10); gauss = ROOT.RooGaussian(""gauss"", ""gauss"", x, mean, sigma); ; # Generate a sample of 1000 events with sigma=3; data = gauss.generate({x}, 1000); ; # Fit pdf to data; gauss.fitTo(data, PrintLevel=-1); ; # Plot pdf and data; # -------------------------------------; ; # Overlay projection of gauss on data; frame = x.frame(Name=""xframe"", Title=""RooPlot with decorations"", Bins=40); data.plotOn(frame); gauss.plotOn(frame); ; # Add box with pdf parameters; # -----------------------------------------------------; ; # Left edge of box starts at 55% of Xaxis); gauss.paramOn(frame, Layout=0.55); ; # Add box with data statistics; # -------------------------------------------------------; ; # X size of box is from 55% to 99% of Xaxis range, of box is at 80% of; # Yaxis range); data.statOn(frame, Layout=(0.55, 0.99, 0.8)); ; # Add text and arrow; # -----------------------------------; ; # Add text to frame; txt = ROOT.TText(2, 100, ""Signal""); txt.SetTextSize(0.04); txt.SetTextColor(ROOT.kRed); frame.addObject(txt); ; # Add arrow to frame; arrow = ROOT.TArrow(2, 100, -1, 50, 0.01, ""|>""); arrow.SetLineColor(ROOT.kRed); arrow.SetFillColor(ROOT.kRed); arrow.SetLineWidth(3); frame.addObject(arrow); ; # Persist frame with all decorations in ROOT file; # ---------------------------------------------------------------------------------------------; ; f = ROOT.TFile(""rf106_plotdecoration.root"", ""RECREA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf106__plotdecoration_8py.html:108,Load,Loading,108,doc/master/rf106__plotdecoration_8py.html,https://root.cern,https://root.cern/doc/master/rf106__plotdecoration_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf107_plotstyles.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf107_plotstyles.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: various plotting styles of data, functions in a RooPlot . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf107_plotstyles(); {; ; // S e t u p m o d e l; // ---------------------; ; // Create observables; RooRealVar x(""x"", ""x"", -10, 10);; ; // Create Gaussian; RooRealVar sigma(""sigma"", ""sigma"", 3, 0.1, 10);; RooRealVar mean(""mean"", ""mean"", -3, -10, 10);; RooGaussian gauss(""gauss"", ""gauss"", x, mean, sigma);; ; // Generate a sample of 100 events with sigma=3; std::unique_ptr<RooDataSet> data{gauss.generate(x, 100)};; ; // Fit pdf to data; gauss.fitTo(*data, PrintLevel(-1));; ; // M a k e p l o t f r a m e s; // -------------------------------; ; // Make four plot frames to demonstrate various plotting features; RooPlot *frame1 = x.frame(Name(""xframe""), Title(""Red Curve / SumW2 Histo errors""), Bins(20));; RooPlot *frame2 = x.frame(Name(""xframe""), Title(""Dashed Curve / No XError bars""), Bins(20));; RooPlot *frame3 = x.frame(Name(""xframe""), Title(""Filled Curve / Blue Histo""), Bins(20));; RooPlot *frame4 = x.frame(Name(""xframe""), Title(""Partial Range / Filled Bar chart""), Bins(20));; ; // D a t a p l o t t i n g s t y l e s; // ---------------------------------------; ; // Use sqrt(sum(weights^2)) error instead of Poisson errors; data->plotOn(frame1, DataError(RooAbsData::SumW2));; ; // Remove horizontal error bars; data->plotOn(frame2, XErrorSize(0));; ; // Blue markers and error bors; data->plotOn(frame3, MarkerColor(kBlue), LineColor(kBlue));; ; // Filled bar chart; data->plotOn(frame4, DrawOption(""B""), DataError(RooAbsData::None), XErrorSize(0), FillColor(kGray));; ; // F u n c t i o n p l o t t i n g ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf107__plotstyles_8C.html:103,Load,Loading,103,doc/master/rf107__plotstyles_8C.html,https://root.cern,https://root.cern/doc/master/rf107__plotstyles_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf107_plotstyles.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf107_plotstyles.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: demonstration of various plotting styles of data, functions in a RooPlot . ; import ROOT; ; ; # Set up model; # ---------------------; ; # Create observables; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); ; # Create Gaussian; sigma = ROOT.RooRealVar(""sigma"", ""sigma"", 3, 0.1, 10); mean = ROOT.RooRealVar(""mean"", ""mean"", -3, -10, 10); gauss = ROOT.RooGaussian(""gauss"", ""gauss"", x, mean, sigma); ; # Generate a sample of 100 events with sigma=3; data = gauss.generate({x}, 100); ; # Fit pdf to data; gauss.fitTo(data, PrintLevel=-1); ; # Make plot frames; # -------------------------------; ; # Make four plot frames to demonstrate various plotting features; frame1 = x.frame(Name=""xframe"", Title=""Red Curve / SumW2 Histo errors"", Bins=20); frame2 = x.frame(Name=""xframe"", Title=""Dashed Curve / No XError bars"", Bins=20); frame3 = x.frame(Name=""xframe"", Title=""Filled Curve / Blue Histo"", Bins=20); frame4 = x.frame(Name=""xframe"", Title=""Partial Range / Filled Bar chart"", Bins=20); ; # Data plotting styles; # ---------------------------------------; ; # Use sqrt(sum(weights^2)) error instead of Poisson errors; data.plotOn(frame1, DataError=""SumW2""); ; # Remove horizontal error bars; data.plotOn(frame2, XErrorSize=0); ; # Blue markers and error bors; data.plotOn(frame3, MarkerColor=""b"", LineColor=""b""); ; # Filled bar chart; data.plotOn(frame4, DrawOption=""B"", DataError=None, XErrorSize=0, FillColor=""kGray""); ; # Function plotting styles; # -----------------------------------------------; ; # Change line color to red; gauss.plotOn(frame1, LineColor=""r""); ; # Change line style to dashed; gauss.plotOn(frame2, LineStyle=""--""); ; # Filled shapes in green color; gauss.plotOn(frame3, MoveToBack=True, DrawOption=""F"", FillColor=""kOrange""); ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf107__plotstyles_8py.html:104,Load,Loading,104,doc/master/rf107__plotstyles_8py.html,https://root.cern,https://root.cern/doc/master/rf107__plotstyles_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf108_plotbinning.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf108_plotbinning.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: plotting unbinned data with alternate and variable binnings . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussModel.h""; #include ""RooDecay.h""; #include ""RooBMixDecay.h""; #include ""RooCategory.h""; #include ""RooBinning.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf108_plotbinning(); {; ; // S e t u p m o d e l; // ---------------------; ; // Build a B decay pdf with mixing; RooRealVar dt(""dt"", ""dt"", -20, 20);; RooRealVar dm(""dm"", ""dm"", 0.472);; RooRealVar tau(""tau"", ""tau"", 1.547);; RooRealVar w(""w"", ""mistag rate"", 0.1);; RooRealVar dw(""dw"", ""delta mistag rate"", 0.);; ; RooCategory mixState(""mixState"", ""B0/B0bar mixing state"");; mixState.defineType(""mixed"", -1);; mixState.defineType(""unmixed"", 1);; RooCategory tagFlav(""tagFlav"", ""Flavour of the tagged B0"");; tagFlav.defineType(""B0"", 1);; tagFlav.defineType(""B0bar"", -1);; ; // Build a gaussian resolution model; RooRealVar bias1(""bias1"", ""bias1"", 0);; RooRealVar sigma1(""sigma1"", ""sigma1"", 0.1);; RooGaussModel gm1(""gm1"", ""gauss model 1"", dt, bias1, sigma1);; ; // Construct Bdecay (x) gauss; RooBMixDecay bmix(""bmix"", ""decay"", dt, mixState, tagFlav, tau, dm, w, dw, gm1, RooBMixDecay::DoubleSided);; ; // S a m p l e d a t a f r o m m o d e l; // --------------------------------------------; ; // Sample 2000 events in (dt,mixState,tagFlav) from bmix; std::unique_ptr<RooDataSet> data{bmix.generate(RooArgSet(dt, mixState, tagFlav), 2000)};; ; // S h o w d t d i s t r i b u t i o n w i t h c u s t o m b i n n i n g; // -------------------------------------------------------------------------------; ; // Make plot of dt distribution of data in range (-15,15) with fine binning for dt>0 and coa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf108__plotbinning_8C.html:104,Load,Loading,104,doc/master/rf108__plotbinning_8C.html,https://root.cern,https://root.cern/doc/master/rf108__plotbinning_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf108_plotbinning.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf108_plotbinning.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: plotting unbinned data with alternate and variable binnings . ; import ROOT; ; # Set up model; # ---------------------; ; # Build a B decay pdf with mixing; dt = ROOT.RooRealVar(""dt"", ""dt"", -20, 20); dm = ROOT.RooRealVar(""dm"", ""dm"", 0.472); tau = ROOT.RooRealVar(""tau"", ""tau"", 1.547); w = ROOT.RooRealVar(""w"", ""mistag rate"", 0.1); dw = ROOT.RooRealVar(""dw"", ""delta mistag rate"", 0.0); ; mixState = ROOT.RooCategory(""mixState"", ""B0/B0bar mixing state"", {""mixed"": -1, ""unmixed"": 1}); tagFlav = ROOT.RooCategory(""tagFlav"", ""Flavour of the tagged B0"", {""B0"": 1, ""B0bar"": -1}); ; # Build a gaussian resolution model; dterr = ROOT.RooRealVar(""dterr"", ""dterr"", 0.1, 1.0); bias1 = ROOT.RooRealVar(""bias1"", ""bias1"", 0); sigma1 = ROOT.RooRealVar(""sigma1"", ""sigma1"", 0.1); gm1 = ROOT.RooGaussModel(""gm1"", ""gauss model 1"", dt, bias1, sigma1); ; # Construct Bdecay (x) gauss; bmix = ROOT.RooBMixDecay(""bmix"", ""decay"", dt, mixState, tagFlav, tau, dm, w, dw, gm1, type=""DoubleSided""); ; # Sample data from model; # --------------------------------------------; ; # Sample 2000 events in (dt,mixState,tagFlav) from bmix; data = bmix.generate({dt, mixState, tagFlav}, 2000); ; # Show dt distribution with custom binning; # -------------------------------------------------------------------------------; ; # Make plot of dt distribution of data in range (-15,15) with fine binning; # for dt>0 and coarse binning for dt<0; ; # Create binning object with range (-15,15); tbins = ROOT.RooBinning(-15, 15); ; # Add 60 bins with uniform spacing in range (-15,0); tbins.addUniform(60, -15, 0); ; # Add 15 bins with uniform spacing in range (0,15); tbins.addUniform(15, 0, 15); ; # Make plot with specified binning; dtframe = dt.frame(Range=(-15, 15), Title=""dt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf108__plotbinning_8py.html:105,Load,Loading,105,doc/master/rf108__plotbinning_8py.html,https://root.cern,https://root.cern/doc/master/rf108__plotbinning_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf109_chi2residpull.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf109_chi2residpull.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: Calculating chi^2 from histograms and curves in RooPlots, making histogram of residual and pull distributions . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooHist.h""; using namespace RooFit;; ; void rf109_chi2residpull(); {; ; // S e t u p m o d e l; // ---------------------; ; // Create observables; RooRealVar x(""x"", ""x"", -10, 10);; ; // Create Gaussian; RooRealVar sigma(""sigma"", ""sigma"", 3, 0.1, 10);; RooRealVar mean(""mean"", ""mean"", 0, -10, 10);; RooGaussian gauss(""gauss"", ""gauss"", x, 0.0, sigma);; ; // Generate a sample of 1000 events with sigma=3; std::unique_ptr<RooDataSet> data{gauss.generate(x, 10000)};; ; // Change sigma to 3.15; sigma.setVal(3.15);; ; // P l o t d a t a a n d s l i g h t l y d i s t o r t e d m o d e l; // ---------------------------------------------------------------------------; ; // Overlay projection of gauss with sigma=3.15 on data with sigma=3.0; RooPlot *frame1 = x.frame(Title(""Data with distorted Gaussian pdf""), Bins(40));; data->plotOn(frame1, DataError(RooAbsData::SumW2));; gauss.plotOn(frame1);; ; // C a l c u l a t e c h i ^ 2; // ------------------------------; ; // Show the chi^2 of the curve w.r.t. the histogram; // If multiple curves or datasets live in the frame you can specify; // the name of the relevant curve and/or dataset in chiSquare(); cout << ""chi^2 = "" << frame1->chiSquare() << endl;; ; // S h o w r e s i d u a l a n d p u l l d i s t s; // -------------------------------------------------------; ; // Construct a histogram with the residuals of the data w.r.t. the curve; RooHist *hresid = frame1->residHist();; ; // Construct a histogram with the pulls of the d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf109__chi2residpull_8C.html:106,Load,Loading,106,doc/master/rf109__chi2residpull_8C.html,https://root.cern,https://root.cern/doc/master/rf109__chi2residpull_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf109_chi2residpull.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf109_chi2residpull.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'BASIC FUNCTIONALITY' RooFit tutorial macro #109 Calculating chi^2 from histograms and curves in ROOT.RooPlots, making histogram of residual and pull distributions . ; from __future__ import print_function; import ROOT; ; # Set up model; # ---------------------; ; # Create observables; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); ; # Create Gaussian; sigma = ROOT.RooRealVar(""sigma"", ""sigma"", 3, 0.1, 10); mean = ROOT.RooRealVar(""mean"", ""mean"", 0, -10, 10); gauss = ROOT.RooGaussian(""gauss"", ""gauss"", x, mean, sigma); ; # Generate a sample of 1000 events with sigma=3; data = gauss.generate({x}, 10000); ; # Change sigma to 3.15; sigma.setVal(3.15); ; # Plot data and slightly distorted model; # ---------------------------------------------------------------------------; ; # Overlay projection of gauss with sigma=3.15 on data with sigma=3.0; frame1 = x.frame(Title=""Data with distorted Gaussian pdf"", Bins=40); data.plotOn(frame1, DataError=""SumW2""); gauss.plotOn(frame1); ; # Calculate chi^2; # ------------------------------; ; # Show the chi^2 of the curve w.r.t. the histogram; # If multiple curves or datasets live in the frame you can specify; # the name of the relevant curve and/or dataset in chiSquare(); print(""chi^2 = "", frame1.chiSquare()); ; # Show residual and pull dists; # -------------------------------------------------------; ; # Construct a histogram with the residuals of the data w.r.t. the curve; hresid = frame1.residHist(); ; # Construct a histogram with the pulls of the data w.r.t the curve; hpull = frame1.pullHist(); ; # Create a frame to draw the residual distribution and add the; # distribution to the frame; frame2 = x.frame(Title=""Residual Distribution""); frame2.addPlotable(hresid, ""P""); ; # Create a frame to draw the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf109__chi2residpull_8py.html:107,Load,Loading,107,doc/master/rf109__chi2residpull_8py.html,https://root.cern,https://root.cern/doc/master/rf109__chi2residpull_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf110_normintegration.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf110_normintegration.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: normalization and integration of pdfs, construction of cumulative distribution monodimensional functions . ; #include ""RooRealVar.h""; #include ""RooGaussian.h""; #include ""RooAbsReal.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; using namespace RooFit;; ; void rf110_normintegration(); {; // S e t u p m o d e l; // ---------------------; ; // Create observables x,y; RooRealVar x(""x"", ""x"", -10, 10);; ; // Create pdf gaussx(x,-2,3); RooGaussian gx(""gx"", ""gx"", x, -2.0, 3.0);; ; // R e t r i e v e r a w & n o r m a l i z e d v a l u e s o f R o o F i t p . d . f . s; // --------------------------------------------------------------------------------------------------; ; // Return 'raw' unnormalized value of gx; cout << ""gx = "" << gx.getVal() << endl;; ; // Return value of gx normalized over x in range [-10,10]; RooArgSet nset(x);; cout << ""gx_Norm[x] = "" << gx.getVal(&nset) << endl;; ; // Create object representing integral over gx; // which is used to calculate gx_Norm[x] == gx / gx_Int[x]; std::unique_ptr<RooAbsReal> igx{gx.createIntegral(x)};; cout << ""gx_Int[x] = "" << igx->getVal() << endl;; ; // I n t e g r a t e n o r m a l i z e d p d f o v e r s u b r a n g e; // ----------------------------------------------------------------------------; ; // Define a range named ""signal"" in x from -5,5; x.setRange(""signal"", -5, 5);; ; // Create an integral of gx_Norm[x] over x in range ""signal""; // This is the fraction of of pdf gx_Norm[x] which is in the; // range named ""signal""; std::unique_ptr<RooAbsReal> igx_sig{gx.createIntegral(x, NormSet(x), Range(""signal""))};; cout << ""gx_Int[x|signal]_Norm[x] = "" << igx_sig->getVal() << endl;; ; // C o n s t r u c t c u m u l a t i v e d i s t r i b u t i o n f u ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf110__normintegration_8C.html:108,Load,Loading,108,doc/master/rf110__normintegration_8C.html,https://root.cern,https://root.cern/doc/master/rf110__normintegration_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf110_normintegration.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf110_normintegration.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: examples on normalization and integration of pdfs, construction of cumulative distribution functions from monodimensional pdfs . ; from __future__ import print_function; import ROOT; ; # Set up model; # ---------------------; ; # Create observables x,y; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); ; # Create pdf gaussx(x,-2,3); gx = ROOT.RooGaussian(""gx"", ""gx"", x, -2, 3); ; # Retrieve raw & normalized values of RooFit pdfs; # --------------------------------------------------------------------------------------------------; ; # Return 'raw' unnormalized value of gx; print(""gx = "", gx.getVal()); ; # Return value of gx normalized over x in range [-10,10]; nset = {x}; print(""gx_Norm[x] = "", gx.getVal(nset)); ; # Create object representing integral over gx; # which is used to calculate gx_Norm[x] == gx / gx_Int[x]; igx = gx.createIntegral({x}); print(""gx_Int[x] = "", igx.getVal()); ; # Integrate normalized pdf over subrange; # ----------------------------------------------------------------------------; ; # Define a range named ""signal"" in x from -5,5; x.setRange(""signal"", -5, 5); ; # Create an integral of gx_Norm[x] over x in range ""signal""; # ROOT.This is the fraction of of pdf gx_Norm[x] which is in the; # range named ""signal""; xset = {x}; igx_sig = gx.createIntegral(xset, NormSet=xset, Range=""signal""); print(""gx_Int[x|signal]_Norm[x] = "", igx_sig.getVal()); ; # Construct cumulative distribution function from pdf; # -----------------------------------------------------------------------------------------------------; ; # Create the cumulative distribution function of gx; # i.e. calculate Int[-10,x] gx(x') dx'; gx_cdf = gx.createCdf({x}); ; # Plot cdf of gx versus x; frame = x.frame(Title=""cdf of Gaussian pd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf110__normintegration_8py.html:109,Load,Loading,109,doc/master/rf110__normintegration_8py.html,https://root.cern,https://root.cern/doc/master/rf110__normintegration_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf111_derivatives.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf111_derivatives.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: numerical 1st,2nd and 3rd order derivatives w.r.t. ; observables and parameters; pdf = gauss(x,m,s); xDouble_t x[n]Definition legend1.C:17; mTMarker mDefinition textangle.C:8. ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf111_derivatives(); {; // S e t u p m o d e l; // ---------------------; ; // Declare variables x,mean,sigma with associated name, title, initial value and allowed range; RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar mean(""mean"", ""mean of gaussian"", 1, -10, 10);; RooRealVar sigma(""sigma"", ""width of gaussian"", 1, 0.1, 10);; ; // Build gaussian pdf in terms of x,mean and sigma; RooGaussian gauss(""gauss"", ""gaussian PDF"", x, mean, sigma);; ; // C r e a t e a n d p l o t d e r i v a t i v e s w . r . t . x; // ----------------------------------------------------------------------; ; // Derivative of normalized gauss(x) w.r.t. observable x; RooAbsReal *dgdx = gauss.derivative(x, 1);; ; // Second and third derivative of normalized gauss(x) w.r.t. observable x; RooAbsReal *d2gdx2 = gauss.derivative(x, 2);; RooAbsReal *d3gdx3 = gauss.derivative(x, 3);; ; // Construct plot frame in 'x'; RooPlot *xframe = x.frame(Title(""d(Gauss)/dx""));; ; // Plot gauss in frame (i.e. in x); gauss.plotOn(xframe);; ; // Plot derivatives in same frame; dgdx->plotOn(xframe, LineColor(kMagenta));; d2gdx2->plotOn(xframe, LineColor(kRed));; d3gdx3->plotOn(xframe, LineColor(kOrange));; ; // C r e a t e a n d p l o t d e r i v a t i v e s w . r . t . s i g m a; // ------------------------------------------------------------------------------; ; // Derivative of normalized gauss(x) w.r.t. parameter sigma; RooAbsReal ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf111__derivatives_8C.html:104,Load,Loading,104,doc/master/rf111__derivatives_8C.html,https://root.cern,https://root.cern/doc/master/rf111__derivatives_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf111_derivatives.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf111_derivatives.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Basic functionality: numerical 1st, and 3rd order derivatives w.r.t. ; observables and parameters; pdf = gauss(x,m,s). ; import ROOT; ; # Set up model; # ---------------------; ; # Declare variables x,mean, with associated name, title, value and allowed; # range; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); mean = ROOT.RooRealVar(""mean"", ""mean of gaussian"", 1, -10, 10); sigma = ROOT.RooRealVar(""sigma"", ""width of gaussian"", 1, 0.1, 10); ; # Build gaussian pdf in terms of x, and sigma; gauss = ROOT.RooGaussian(""gauss"", ""gaussian PDF"", x, mean, sigma); ; # Create and plot derivatives w.r.t. x; # ----------------------------------------------------------------------; ; # Derivative of normalized gauss(x) w.r.t. observable x; dgdx = gauss.derivative(x, 1); ; # Second and third derivative of normalized gauss(x) w.r.t. observable x; d2gdx2 = gauss.derivative(x, 2); d3gdx3 = gauss.derivative(x, 3); ; # Construct plot frame in 'x'; xframe = x.frame(Title=""d(Gauss)/dx""); ; # Plot gauss in frame (i.e. in x); gauss.plotOn(xframe); ; # Plot derivatives in same frame; dgdx.plotOn(xframe, LineColor=""m""); d2gdx2.plotOn(xframe, LineColor=""r""); d3gdx3.plotOn(xframe, LineColor=""kOrange""); ; # Create and plot derivatives w.r.t. sigma; # ------------------------------------------------------------------------------; ; # Derivative of normalized gauss(x) w.r.t. parameter sigma; dgds = gauss.derivative(sigma, 1); ; # Second and third derivative of normalized gauss(x) w.r.t. parameter sigma; d2gds2 = gauss.derivative(sigma, 2); d3gds3 = gauss.derivative(sigma, 3); ; # Construct plot frame in 'sigma'; sframe = sigma.frame(Title=""d(Gauss)/d(sigma)"", Range=(0.0, 2.0)); ; # Plot gauss in frame (i.e. in x); gauss.plotOn(sframe); ; # Plot derivatives in same fram",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf111__derivatives_8py.html:105,Load,Loading,105,doc/master/rf111__derivatives_8py.html,https://root.cern,https://root.cern/doc/master/rf111__derivatives_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf201_composite.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf201_composite.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Addition and convolution: composite pdf with signal and background component ; pdf = f_bkg * bkg(x,a0,a1) + (1-fbkg) * (f_sig1 * sig1(x,m,s1 + (1-f_sig1) * sig2(x,m,s2))); s1#define s1(x)Definition RSha256.hxx:91; xDouble_t x[n]Definition legend1.C:17; mTMarker mDefinition textangle.C:8. ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooAddPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf201_composite(); {; // S e t u p c o m p o n e n t p d f s; // ---------------------------------------; ; // Declare observable x; RooRealVar x(""x"", ""x"", 0, 10);; ; // Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and their parameters; RooRealVar mean(""mean"", ""mean of gaussians"", 5);; RooRealVar sigma1(""sigma1"", ""width of gaussians"", 0.5);; RooRealVar sigma2(""sigma2"", ""width of gaussians"", 1);; ; RooGaussian sig1(""sig1"", ""Signal component 1"", x, mean, sigma1);; RooGaussian sig2(""sig2"", ""Signal component 2"", x, mean, sigma2);; ; // Build Chebychev polynomial pdf; RooRealVar a0(""a0"", ""a0"", 0.5, 0., 1.);; RooRealVar a1(""a1"", ""a1"", 0.2, 0., 1.);; RooChebychev bkg(""bkg"", ""Background"", x, RooArgSet(a0, a1));; ; // ---------------------------------------------; // M E T H O D 1 - T w o R o o A d d P d f s; // =============================================; ; // A d d s i g n a l c o m p o n e n t s; // ------------------------------------------; ; // Sum the signal components into a composite signal pdf; RooRealVar sig1frac(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0., 1.);; RooAddPdf sig(""sig"", ""Signal"", RooArgList(sig1, sig2), sig1frac);; ; // A d d s i g n a l a n d b a c k g r o u n d; // --------------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf201__composite_8C.html:102,Load,Loading,102,doc/master/rf201__composite_8C.html,https://root.cern,https://root.cern/doc/master/rf201__composite_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf201_composite.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf201_composite.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Addition and convolution: composite pdf with signal and background component ; pdf = f_bkg * bkg(x,a0,a1) + (1-fbkg) * (f_sig1 * sig1(x,m,s1 + (1-f_sig1) * sig2(x,m,s2))). ; import ROOT; ; # Setup component pdfs; # ---------------------------------------; ; # Declare observable x; x = ROOT.RooRealVar(""x"", ""x"", 0, 10); ; # Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and; # their parameters; mean = ROOT.RooRealVar(""mean"", ""mean of gaussians"", 5); sigma1 = ROOT.RooRealVar(""sigma1"", ""width of gaussians"", 0.5); sigma2 = ROOT.RooRealVar(""sigma2"", ""width of gaussians"", 1); ; sig1 = ROOT.RooGaussian(""sig1"", ""Signal component 1"", x, mean, sigma1); sig2 = ROOT.RooGaussian(""sig2"", ""Signal component 2"", x, mean, sigma2); ; # Build Chebychev polynomial pdf; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.2, 0.0, 1.0); bkg = ROOT.RooChebychev(""bkg"", ""Background"", x, [a0, a1]); ; ; # Method 1 - Two RooAddPdfs; # ------------------------------------------; # Add signal components; ; # Sum the signal components into a composite signal pdf; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Add signal and background; # ------------------------------------------------; ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Sample, fit and plot model; # ---------------------------------------------------; ; # Generate a data sample of 1000 events in x from model; data = model.generate({x}, 1000); ; # Fit model to data; model.fitTo(data, PrintLevel=-1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf201__composite_8py.html:103,Load,Loading,103,doc/master/rf201__composite_8py.html,https://root.cern,https://root.cern/doc/master/rf201__composite_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf202_extendedmlfit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf202_extendedmlfit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Setting up an extended maximum likelihood fit. . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooAddPdf.h""; #include ""RooExtendPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf202_extendedmlfit(); {; ; // S e t u p c o m p o n e n t p d f s; // ---------------------------------------; ; // Declare observable x; RooRealVar x(""x"", ""x"", 0, 10);; ; // Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and their parameters; RooRealVar mean(""mean"", ""mean of gaussians"", 5);; RooRealVar sigma1(""sigma1"", ""width of gaussians"", 0.5);; RooRealVar sigma2(""sigma2"", ""width of gaussians"", 1);; ; RooGaussian sig1(""sig1"", ""Signal component 1"", x, mean, sigma1);; RooGaussian sig2(""sig2"", ""Signal component 2"", x, mean, sigma2);; ; // Build Chebychev polynomial pdf; RooRealVar a0(""a0"", ""a0"", 0.5, 0., 1.);; RooRealVar a1(""a1"", ""a1"", 0.2, 0., 1.);; RooChebychev bkg(""bkg"", ""Background"", x, RooArgSet(a0, a1));; ; // Sum the signal components into a composite signal pdf; RooRealVar sig1frac(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0., 1.);; RooAddPdf sig(""sig"", ""Signal"", RooArgList(sig1, sig2), sig1frac);; ; //----------------; // M E T H O D 1; //================; ; // C o n s t r u c t e x t e n d e d c o m p o s i t e m o d e l; // -------------------------------------------------------------------; ; // Sum the composite signal and background into an extended pdf nsig*sig+nbkg*bkg; RooRealVar nsig(""nsig"", ""number of signal events"", 500, 0., 10000);; RooRealVar nbkg(""nbkg"", ""number of background events"", 500, 0, 10000);; RooAddPdf model(""model"", ""(g1+g2)+a"", RooArgList(bkg, sig), RooArgList(nbkg, nsig));; ; // ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf202__extendedmlfit_8C.html:106,Load,Loading,106,doc/master/rf202__extendedmlfit_8C.html,https://root.cern,https://root.cern/doc/master/rf202__extendedmlfit_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf202_extendedmlfit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf202_extendedmlfit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Addition and convolution: setting up an extended maximum likelihood fit . ; import ROOT; ; # Set up component pdfs; # ---------------------------------------; ; # Declare observable x; x = ROOT.RooRealVar(""x"", ""x"", 0, 10); ; # Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and; # their parameters; mean = ROOT.RooRealVar(""mean"", ""mean of gaussians"", 5); sigma1 = ROOT.RooRealVar(""sigma1"", ""width of gaussians"", 0.5); sigma2 = ROOT.RooRealVar(""sigma2"", ""width of gaussians"", 1); ; sig1 = ROOT.RooGaussian(""sig1"", ""Signal component 1"", x, mean, sigma1); sig2 = ROOT.RooGaussian(""sig2"", ""Signal component 2"", x, mean, sigma2); ; # Build Chebychev polynomial pdf; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.2, 0.0, 1.0); bkg = ROOT.RooChebychev(""bkg"", ""Background"", x, [a0, a1]); ; # Sum the signal components into a composite signal pdf; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Method 1 - Construct extended composite model; # -------------------------------------------------------------------; ; # Sum the composite signal and background into an extended pdf; # nsig*sig+nbkg*bkg; nsig = ROOT.RooRealVar(""nsig"", ""number of signal events"", 500, 0.0, 10000); nbkg = ROOT.RooRealVar(""nbkg"", ""number of background events"", 500, 0, 10000); model = ROOT.RooAddPdf(""model"", ""(g1+g2)+a"", [bkg, sig], [nbkg, nsig]); ; # Sample, fit and plot extended model; # ---------------------------------------------------------------------; ; # Generate a data sample of expected number events in x from model; # = model.expectedEvents() = nsig+nbkg; data = model.generate({x}); ; # Fit model ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf202__extendedmlfit_8py.html:107,Load,Loading,107,doc/master/rf202__extendedmlfit_8py.html,https://root.cern,https://root.cern/doc/master/rf202__extendedmlfit_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf203_ranges.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf203_ranges.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Fitting and plotting in sub ranges. . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooAddPdf.h""; #include ""RooFitResult.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf203_ranges(); {; // S e t u p m o d e l; // ---------------------; ; // Construct observables x; RooRealVar x(""x"", ""x"", -10, 10);; ; // Construct gaussx(x,mx,1); RooRealVar mx(""mx"", ""mx"", 0, -10, 10);; RooGaussian gx(""gx"", ""gx"", x, mx, 1.0);; ; // Construct px = 1 (flat in x); RooPolynomial px(""px"", ""px"", x);; ; // Construct model = f*gx + (1-f)px; RooRealVar f(""f"", ""f"", 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgList(gx, px), f);; ; // Generated 10000 events in (x,y) from pdf model; std::unique_ptr<RooDataSet> modelData{model.generate(x, 10000)};; ; // F i t f u l l r a n g e; // ---------------------------; ; // Fit pdf to all data; std::unique_ptr<RooFitResult> r_full{model.fitTo(*modelData, Save(true), PrintLevel(-1))};; ; // F i t p a r t i a l r a n g e; // ----------------------------------; ; // Define ""signal"" range in x as [-3,3]; x.setRange(""signal"", -3, 3);; ; // Fit pdf only to data in ""signal"" range; std::unique_ptr<RooFitResult> r_sig{model.fitTo(*modelData, Save(true), Range(""signal""), PrintLevel(-1))};; ; // P l o t / p r i n t r e s u l t s; // ---------------------------------------; ; // Make plot frame in x and add data and fitted model; RooPlot *frame = x.frame(Title(""Fitting a sub range""));; modelData->plotOn(frame);; model.plotOn(frame, Range(""""), LineStyle(kDashed), LineColor(kRed)); // Add shape in full ranged dashed; model.plotOn(frame); // By default only fitted range is shown; ; // Print fit results; cout << ""res",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf203__ranges_8C.html:99,Load,Loading,99,doc/master/rf203__ranges_8C.html,https://root.cern,https://root.cern/doc/master/rf203__ranges_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf203_ranges.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf203_ranges.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Addition and convolution: fitting and plotting in sub ranges . ; from __future__ import print_function; import ROOT; ; # Set up model; # ---------------------; ; # Construct observables x; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); ; # Construct gaussx(x,mx,1); mx = ROOT.RooRealVar(""mx"", ""mx"", 0, -10, 10); gx = ROOT.RooGaussian(""gx"", ""gx"", x, mx, 1.0); ; # px = 1 (flat in x); px = ROOT.RooPolynomial(""px"", ""px"", x); ; # model = f*gx + (1-f)px; f = ROOT.RooRealVar(""f"", ""f"", 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gx, px], [f]); ; # Generated 10000 events in (x,y) from pdf model; modelData = model.generate({x}, 10000); ; # Fit full range; # ---------------------------; ; # Fit pdf to all data; r_full = model.fitTo(modelData, Save=True, PrintLevel=-1); ; # Fit partial range; # ----------------------------------; ; # Define ""signal"" range in x as [-3,3]; x.setRange(""signal"", -3, 3); ; # Fit pdf only to data in ""signal"" range; r_sig = model.fitTo(modelData, Save=True, Range=""signal"", PrintLevel=-1); ; # Plot/print results; # ---------------------------------------; ; # Make plot frame in x and add data and fitted model; frame = x.frame(Title=""Fitting a sub range""); modelData.plotOn(frame); model.plotOn(frame, Range=""Full"", LineColor=""r"", LineStyle=""--"") # Add shape in full ranged dashed; model.plotOn(frame) # By default only fitted range is shown; ; # Print fit results; print(""result of fit on all data ""); r_full.Print(); print(""result of fit in in signal region (note increased error on signal fraction)""); r_sig.Print(); ; # Draw frame on canvas; c = ROOT.TCanvas(""rf203_ranges"", ""rf203_ranges"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf203_ranges.png""); [#1] INFO:Fittin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf203__ranges_8py.html:100,Load,Loading,100,doc/master/rf203__ranges_8py.html,https://root.cern,https://root.cern/doc/master/rf203__ranges_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf204a_extendedLikelihood.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf204a_extendedLikelihood.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Extended maximum likelihood fit in multiple ranges. ; When an extended pdf and multiple ranges are used, the RooExtendPdf cannot correctly interpret the coefficients used for extension. This can be solved by using a RooAddPdf for extending the model.; ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooAddPdf.h""; #include ""RooExtendPdf.h""; #include ""RooFitResult.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit ;; ; ; void rf204a_extendedLikelihood(); {; ; ; // S e t u p c o m p o n e n t p d f s; // ---------------------------------------; ; // Declare observable x; RooRealVar x(""x"",""x"",0,11) ;; ; // Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and their parameters; RooRealVar mean(""mean"",""mean of gaussians"",5) ;; RooRealVar sigma1(""sigma1"",""width of gaussians"",0.5) ;; RooRealVar sigma2(""sigma2"",""width of gaussians"",1) ;; ; RooGaussian sig1(""sig1"",""Signal component 1"",x,mean,sigma1) ;; RooGaussian sig2(""sig2"",""Signal component 2"",x,mean,sigma2) ;; ; // Build Chebychev polynomial pdf; RooRealVar a0(""a0"",""a0"",0.5,0.,1.) ;; RooRealVar a1(""a1"",""a1"",0.2,0.,1.) ;; RooChebychev bkg(""bkg"",""Background"",x,RooArgSet(a0,a1)) ;; ; // Sum the signal components into a composite signal pdf; RooRealVar sig1frac(""sig1frac"",""fraction of component 1 in signal"",0.8,0.,1.) ;; RooAddPdf sig(""sig"",""Signal"",RooArgList(sig1,sig2),sig1frac) ;; ; ; // E x t e n d t h e p d f s; // -----------------------------; ; ; // Define signal range in which events counts are to be defined; x.setRange(""signalRange"",4,6) ;; ; // Associated nsig/nbkg as expected number of events with sig/bkg _in_the_range_ ""signalRange""; RooRealVar nsig(""nsi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf204a__extendedLikelihood_8C.html:112,Load,Loading,112,doc/master/rf204a__extendedLikelihood_8C.html,https://root.cern,https://root.cern/doc/master/rf204a__extendedLikelihood_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf204a_extendedLikelihood.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf204a_extendedLikelihood.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Extended maximum likelihood fit in multiple ranges. ; ; import ROOT; ; ; # Setup component pdfs; # ---------------------; ; # Declare observable x; x = ROOT.RooRealVar(""x"", ""x"", 0, 11); ; # Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and their parameters; mean = ROOT.RooRealVar(""mean"", ""mean of gaussians"", 5); sigma1 = ROOT.RooRealVar(""sigma1"", ""width of gaussians"", 0.5); sigma2 = ROOT.RooRealVar(""sigma2"", ""width of gaussians"", 1); ; sig1 = ROOT.RooGaussian(""sig1"", ""Signal component 1"", x, mean, sigma1); sig2 = ROOT.RooGaussian(""sig2"", ""Signal component 2"", x, mean, sigma2); ; # Build Chebychev polynomial pdf; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", 0.2, 0.0, 1.0); bkg = ROOT.RooChebychev(""bkg"", ""Background"", x, [a0, a1]); ; # Sum the signal components into a composite signal pdf; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], sig1frac); ; ; # Extend the pdfs; # -----------------------------; ; # Define signal range in which events counts are to be defined; x.setRange(""signalRange"", 4, 6); ; # Associated nsig/nbkg as expected number of events with sig/bkg _in_the_range_ ""signalRange""; nsig = ROOT.RooRealVar(""nsig"", ""number of signal events in signalRange"", 500, 0.0, 10000); nbkg = ROOT.RooRealVar(""nbkg"", ""number of background events in signalRange"", 500, 0, 10000); ; # Use AddPdf to extend the model. Giving as many coefficients as pdfs switches on extension.; model = ROOT.RooAddPdf(""model"", ""(g1+g2)+a"", [bkg, sig], [nbkg, nsig]); ; # Sample data, fit model; # -------------------------------------------; ; # Generate 1000 events from model so that nsig,nbkg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf204a__extendedLikelihood_8py.html:113,Load,Loading,113,doc/master/rf204a__extendedLikelihood_8py.html,https://root.cern,https://root.cern/doc/master/rf204a__extendedLikelihood_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf204b_extendedLikelihood_rangedFit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf204b_extendedLikelihood_rangedFit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; This macro demonstrates how to set up a fit in two ranges for plain likelihoods and extended likelihoods. . 1. Shape fits (plain likelihood); If you fit a non-extended pdf in two ranges, e.g. pdf->fitTo(data,Range(""Range1,Range2"")), it will fit the shapes in the two selected ranges and also take into account the relative predicted yields in those ranges.; This is useful for example to represent a full-range fit, but with a blinded signal region inside it. 2. Shape+rate fits (extended likelihood); If your pdf is extended, i.e. measuring both the distribution in the observable as well as the event count in the fitted region, some intervention is needed to make fits in ranges work in a way that corresponds to intuition.; If an extended fit is performed in a sub-range, the observed yield is only that of the subrange, hence the expected event count will converge to a number that is smaller than what's visible in a plot. In such cases, it is often preferred to interpret the extended term with respect to the full range that's plotted, i.e., apply a correction to the extended likelihood term in such a way that the interpretation of the expected event count remains that of the full range. This can be done by applying a correcion factor (equal to the fraction of the pdf that is contained in the fitted range) in the Poisson term that represents the extended likelihood term.; If an extended likelihood fit is performed over two sub-ranges, this correction is even more important: without it, each component likelihood would have a different interpretation of the expected event count (each corresponding to the count in its own region), and a joint fit of these regions with different interpretations of the same model paramet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8C.html:122,Load,Loading,122,doc/master/rf204b__extendedLikelihood__rangedFit_8C.html,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf204b_extendedLikelihood_rangedFit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf204b_extendedLikelihood_rangedFit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; This macro demonstrates how to set up a fit in two ranges for plain likelihoods and extended likelihoods. . 1. Shape fits (plain likelihood); If you fit a non-extended pdf in two ranges, e.g. pdf.fitTo(data,Range=""Range1,Range2""), it will fit the shapes in the two selected ranges and also take into account the relative predicted yields in those ranges.; This is useful for example to represent a full-range fit, but with a blinded signal region inside it. 2. Shape+rate fits (extended likelihood); If your pdf is extended, i.e. measuring both the distribution in the observable as well as the event count in the fitted region, some intervention is needed to make fits in ranges work in a way that corresponds to intuition.; If an extended fit is performed in a sub-range, the observed yield is only that of the subrange, hence the expected event count will converge to a number that is smaller than what's visible in a plot. In such cases, it is often preferred to interpret the extended term with respect to the full range that's plotted, i.e., apply a correction to the extended likelihood term in such a way that the interpretation of the expected event count remains that of the full range. This can be done by applying a correcion factor (equal to the fraction of the pdf that is contained in the fitted range) in the Poisson term that represents the extended likelihood term.; If an extended likelihood fit is performed over two sub-ranges, this correction is even more important: without it, each component likelihood would have a different interpretation of the expected event count (each corresponding to the count in its own region), and a joint fit of these regions with different interpretations of the same ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8py.html:123,Load,Loading,123,doc/master/rf204b__extendedLikelihood__rangedFit_8py.html,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf205_compplot.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf205_compplot.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Addition and convolution: options for plotting components of composite pdfs. . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooAddPdf.h""; #include ""RooChebychev.h""; #include ""RooExponential.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf205_compplot(); {; // S e t u p c o m p o s i t e p d f; // --------------------------------------; ; // Declare observable x; RooRealVar x(""x"", ""x"", 0, 10);; ; // Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and their parameters; RooRealVar mean(""mean"", ""mean of gaussians"", 5);; RooRealVar sigma1(""sigma1"", ""width of gaussians"", 0.5);; RooRealVar sigma2(""sigma2"", ""width of gaussians"", 1);; RooGaussian sig1(""sig1"", ""Signal component 1"", x, mean, sigma1);; RooGaussian sig2(""sig2"", ""Signal component 2"", x, mean, sigma2);; ; // Sum the signal components into a composite signal pdf; RooRealVar sig1frac(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0., 1.);; RooAddPdf sig(""sig"", ""Signal"", {sig1, sig2}, sig1frac);; ; // Build Chebychev polynomial pdf; RooRealVar a0(""a0"", ""a0"", 0.5, 0., 1.);; RooRealVar a1(""a1"", ""a1"", 0.2, 0., 1.);; RooChebychev bkg1(""bkg1"", ""Background 1"", x, {a0, a1});; ; // Build exponential pdf; RooRealVar alpha(""alpha"", ""alpha"", -1);; RooExponential bkg2(""bkg2"", ""Background 2"", x, alpha);; ; // Sum the background components into a composite background pdf; RooRealVar bkg1frac(""bkg1frac"", ""fraction of component 1 in background"", 0.8, 0., 1.);; RooAddPdf bkg(""bkg"", ""Total background"", {bkg1, bkg2}, bkg1frac);; ; // Sum the composite signal and background; RooRealVar bkgfrac(""bkgfrac"", ""fraction of background"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""g1+g2+a"", {bkg, sig}, bkgfrac);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf205__compplot_8C.html:101,Load,Loading,101,doc/master/rf205__compplot_8C.html,https://root.cern,https://root.cern/doc/master/rf205__compplot_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf205_compplot.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf205_compplot.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Addition and convolution: options for plotting components of composite pdfs. . ; import ROOT; ; # Set up composite pdf; # --------------------------------------; ; # Declare observable x; x = ROOT.RooRealVar(""x"", ""x"", 0, 10); ; # Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and; # their parameters; mean = ROOT.RooRealVar(""mean"", ""mean of gaussians"", 5); sigma1 = ROOT.RooRealVar(""sigma1"", ""width of gaussians"", 0.5); sigma2 = ROOT.RooRealVar(""sigma2"", ""width of gaussians"", 1); sig1 = ROOT.RooGaussian(""sig1"", ""Signal component 1"", x, mean, sigma1); sig2 = ROOT.RooGaussian(""sig2"", ""Signal component 2"", x, mean, sigma2); ; # Sum the signal components into a composite signal pdf; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Build Chebychev polynomial pdf; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.2, 0.0, 1.0); bkg1 = ROOT.RooChebychev(""bkg1"", ""Background 1"", x, [a0, a1]); ; # Build expontential pdf; alpha = ROOT.RooRealVar(""alpha"", ""alpha"", -1); bkg2 = ROOT.RooExponential(""bkg2"", ""Background 2"", x, alpha); ; # Sum the background components into a composite background pdf; bkg1frac = ROOT.RooRealVar(""bkg1frac"", ""fraction of component 1 in background"", 0.8, 0.0, 1.0); bkg = ROOT.RooAddPdf(""bkg"", ""Total background"", [bkg1, bkg2], [bkg1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Set up basic plot with data and full pdf; # ------------------------------------------------------------------------------; ; # Generate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf205__compplot_8py.html:102,Load,Loading,102,doc/master/rf205__compplot_8py.html,https://root.cern,https://root.cern/doc/master/rf205__compplot_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf206_treevistools.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf206_treevistools.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Addition and convolution: tools for visualization of RooAbsArg expression trees ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooAddPdf.h""; #include ""RooExponential.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf206_treevistools(); {; // S e t u p c o m p o s i t e p d f; // --------------------------------------; ; // Declare observable x; RooRealVar x(""x"", ""x"", 0, 10);; ; // Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and their parameters; RooRealVar mean(""mean"", ""mean of gaussians"", 5);; RooRealVar sigma1(""sigma1"", ""width of gaussians"", 0.5);; RooRealVar sigma2(""sigma2"", ""width of gaussians"", 1);; RooGaussian sig1(""sig1"", ""Signal component 1"", x, mean, sigma1);; RooGaussian sig2(""sig2"", ""Signal component 2"", x, mean, sigma2);; ; // Sum the signal components into a composite signal pdf; RooRealVar sig1frac(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0., 1.);; RooAddPdf sig(""sig"", ""Signal"", RooArgList(sig1, sig2), sig1frac);; ; // Build Chebychev polynomial pdf; RooRealVar a0(""a0"", ""a0"", 0.5, 0., 1.);; RooRealVar a1(""a1"", ""a1"", 0.2, 0., 1.);; RooChebychev bkg1(""bkg1"", ""Background 1"", x, RooArgSet(a0, a1));; ; // Build expontential pdf; RooRealVar alpha(""alpha"", ""alpha"", -1);; RooExponential bkg2(""bkg2"", ""Background 2"", x, alpha);; ; // Sum the background components into a composite background pdf; RooRealVar bkg1frac(""bkg1frac"", ""fraction of component 1 in background"", 0.2, 0., 1.);; RooAddPdf bkg(""bkg"", ""Signal"", RooArgList(bkg1, bkg2), bkg1frac);; ; // Sum the composite signal and background; RooRealVar bkgfrac(""bkgfrac"", ""fraction of background"", 0.5, 0., 1.);; RooAddPdf model(""model",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf206__treevistools_8C.html:105,Load,Loading,105,doc/master/rf206__treevistools_8C.html,https://root.cern,https://root.cern/doc/master/rf206__treevistools_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf206_treevistools.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf206_treevistools.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Addition and convolution: tools for visualization of ROOT.RooAbsArg expression trees ; ; import ROOT; ; # Set up composite pdf; # --------------------------------------; ; # Declare observable x; x = ROOT.RooRealVar(""x"", ""x"", 0, 10); ; # Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and; # their parameters; mean = ROOT.RooRealVar(""mean"", ""mean of gaussians"", 5); sigma1 = ROOT.RooRealVar(""sigma1"", ""width of gaussians"", 0.5); sigma2 = ROOT.RooRealVar(""sigma2"", ""width of gaussians"", 1); sig1 = ROOT.RooGaussian(""sig1"", ""Signal component 1"", x, mean, sigma1); sig2 = ROOT.RooGaussian(""sig2"", ""Signal component 2"", x, mean, sigma2); ; # Sum the signal components into a composite signal pdf; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Build Chebychev polynomial pdf; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.2, 0.0, 1.0); bkg1 = ROOT.RooChebychev(""bkg1"", ""Background 1"", x, [a0, a1]); ; # Build expontential pdf; alpha = ROOT.RooRealVar(""alpha"", ""alpha"", -1); bkg2 = ROOT.RooExponential(""bkg2"", ""Background 2"", x, alpha); ; # Sum the background components into a composite background pdf; bkg1frac = ROOT.RooRealVar(""bkg1frac"", ""fraction of component 1 in background"", 0.2, 0.0, 1.0); bkg = ROOT.RooAddPdf(""bkg"", ""Signal"", [bkg1, bkg2], [bkg1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Print composite tree in ASCII; # -----------------------------------------------------------; ; # Print tree to stdout; model.Prin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf206__treevistools_8py.html:106,Load,Loading,106,doc/master/rf206__treevistools_8py.html,https://root.cern,https://root.cern/doc/master/rf206__treevistools_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf207_comptools.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf207_comptools.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Addition and convolution: tools and utilities for manipulation of composite objects ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooExponential.h""; #include ""RooAddPdf.h""; #include ""RooPlot.h""; #include ""RooCustomizer.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf207_comptools(); {; ; // S e t u p c o m p o s i t e p d f, d a t a s e t; // --------------------------------------------------------; ; // Declare observable x; RooRealVar x(""x"", ""x"", 0, 10);; ; // Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and their parameters; RooRealVar mean(""mean"", ""mean of gaussians"", 5);; RooRealVar sigma(""sigma"", ""width of gaussians"", 0.5);; RooGaussian sig(""sig"", ""Signal component 1"", x, mean, sigma);; ; // Build Chebychev polynomial pdf; RooRealVar a0(""a0"", ""a0"", 0.5, 0., 1.);; RooRealVar a1(""a1"", ""a1"", 0.2, 0., 1.);; RooChebychev bkg1(""bkg1"", ""Background 1"", x, RooArgSet(a0, a1));; ; // Build exponential pdf; RooRealVar alpha(""alpha"", ""alpha"", -1);; RooExponential bkg2(""bkg2"", ""Background 2"", x, alpha);; ; // Sum the background components into a composite background pdf; RooRealVar bkg1frac(""bkg1frac"", ""fraction of component 1 in background"", 0.2, 0., 1.);; RooAddPdf bkg(""bkg"", ""Signal"", RooArgList(bkg1, bkg2), bkg1frac);; ; // Sum the composite signal and background; RooRealVar bkgfrac(""bkgfrac"", ""fraction of background"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), bkgfrac);; ; // Create dummy dataset that has more observables than the above pdf; RooRealVar y(""y"", ""y"", -10, 10);; RooDataSet data(""data"", ""data"", RooArgSet(x, y));; ; // ---------------------------------------------------; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf207__comptools_8C.html:102,Load,Loading,102,doc/master/rf207__comptools_8C.html,https://root.cern,https://root.cern/doc/master/rf207__comptools_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf207_comptools.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf207_comptools.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'ADDITION AND CONVOLUTION' RooFit tutorial macro #207 Tools and utilities for manipulation of composite objects ; ; import ROOT; ; # Set up composite pdf dataset; # --------------------------------------------------------; ; # Declare observable x; x = ROOT.RooRealVar(""x"", ""x"", 0, 10); ; # Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and; # their parameters; mean = ROOT.RooRealVar(""mean"", ""mean of gaussians"", 5); sigma = ROOT.RooRealVar(""sigma"", ""width of gaussians"", 0.5); sig = ROOT.RooGaussian(""sig"", ""Signal component 1"", x, mean, sigma); ; # Build Chebychev polynomial p.d.f.; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", 0.2, 0.0, 1.0); bkg1 = ROOT.RooChebychev(""bkg1"", ""Background 1"", x, [a0, a1]); ; # Build expontential pdf; alpha = ROOT.RooRealVar(""alpha"", ""alpha"", -1); bkg2 = ROOT.RooExponential(""bkg2"", ""Background 2"", x, alpha); ; # Sum the background components into a composite background p.d.f.; bkg1frac = ROOT.RooRealVar(""bkg1frac"", ""fraction of component 1 in background"", 0.2, 0.0, 1.0); bkg = ROOT.RooAddPdf(""bkg"", ""Signal"", [bkg1, bkg2], [bkg1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Create dummy dataset that has more observables than the above pdf; y = ROOT.RooRealVar(""y"", ""y"", -10, 10); data = ROOT.RooDataSet(""data"", ""data"", {x, y}); ; # Basic information requests; # ---------------------------------------------; ; ; # Get list of observables; # ---------------------------------------------; ; # Get list of observables of pdf in context of a dataset; #; # Observables are define each context as the variable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf207__comptools_8py.html:103,Load,Loading,103,doc/master/rf207__comptools_8py.html,https://root.cern,https://root.cern/doc/master/rf207__comptools_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf208_convolution.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf208_convolution.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Addition and convolution: one-dimensional numeric convolution ; pdf = landau(t) (x) gauss(t); xDouble_t x[n]Definition legend1.C:17; This tutorial requires FFT3 to be enabled. ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooLandau.h""; #include ""RooFFTConvPdf.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf208_convolution(); {; // S e t u p c o m p o n e n t p d f s; // ---------------------------------------; ; // Construct observable; RooRealVar t(""t"", ""t"", -10, 30);; ; // Construct landau(t,ml,sl) ;; RooRealVar ml(""ml"", ""mean landau"", 5., -20, 20);; RooRealVar sl(""sl"", ""sigma landau"", 1, 0.1, 10);; RooLandau landau(""lx"", ""lx"", t, ml, sl);; ; // Construct gauss(t,mg,sg); RooRealVar mg(""mg"", ""mg"", 0);; RooRealVar sg(""sg"", ""sg"", 2, 0.1, 10);; RooGaussian gauss(""gauss"", ""gauss"", t, mg, sg);; ; // C o n s t r u c t c o n v o l u t i o n p d f; // ---------------------------------------; ; // Set #bins to be used for FFT sampling to 10000; t.setBins(10000, ""cache"");; ; // Construct landau (x) gauss; RooFFTConvPdf lxg(""lxg"", ""landau (X) gauss"", t, landau, gauss);; ; // S a m p l e , f i t a n d p l o t c o n v o l u t e d p d f; // ----------------------------------------------------------------------; ; // Sample 1000 events in x from gxlx; std::unique_ptr<RooDataSet> data{lxg.generate(t, 10000)};; ; // Fit gxlx to data; lxg.fitTo(*data, PrintLevel(-1));; ; // Plot data, landau pdf, landau (X) gauss pdf; RooPlot *frame = t.frame(Title(""landau (x) gauss convolution""));; data->plotOn(frame);; lxg.plotOn(frame);; landau.plotOn(frame, LineStyle(kDashed));; ; // Draw frame on canvas; new TCanvas(""rf208_convolution"", ""rf208_convolution"", 60",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf208__convolution_8C.html:104,Load,Loading,104,doc/master/rf208__convolution_8C.html,https://root.cern,https://root.cern/doc/master/rf208__convolution_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf208_convolution.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf208_convolution.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'ADDITION AND CONVOLUTION' RooFit tutorial macro #208 One-dimensional numeric convolution (require ROOT to be compiled with –enable-fftw3) ; pdf = landau(t) (x) gauss(t). ; import ROOT; ; # Set up component pdfs; # ---------------------------------------; ; # Construct observable; t = ROOT.RooRealVar(""t"", ""t"", -10, 30); ; # Construct landau(t,ml,sl); ml = ROOT.RooRealVar(""ml"", ""mean landau"", 5.0, -20, 20); sl = ROOT.RooRealVar(""sl"", ""sigma landau"", 1, 0.1, 10); landau = ROOT.RooLandau(""lx"", ""lx"", t, ml, sl); ; # Construct gauss(t,mg,sg); mg = ROOT.RooRealVar(""mg"", ""mg"", 0); sg = ROOT.RooRealVar(""sg"", ""sg"", 2, 0.1, 10); gauss = ROOT.RooGaussian(""gauss"", ""gauss"", t, mg, sg); ; # Construct convolution pdf; # ---------------------------------------; ; # Set #bins to be used for FFT sampling to 10000; t.setBins(10000, ""cache""); ; # Construct landau (x) gauss; lxg = ROOT.RooFFTConvPdf(""lxg"", ""landau (X) gauss"", t, landau, gauss); ; # Sample, fit and plot convoluted pdf; # ----------------------------------------------------------------------; ; # Sample 1000 events in x from gxlx; data = lxg.generate({t}, 10000); ; # Fit gxlx to data; lxg.fitTo(data, PrintLevel=-1); ; # Plot data, pdf, landau (X) gauss pdf; frame = t.frame(Title=""landau (x) gauss convolution""); data.plotOn(frame); lxg.plotOn(frame); landau.plotOn(frame, LineStyle=""--""); ; # Draw frame on canvas; c = ROOT.TCanvas(""rf208_convolution"", ""rf208_convolution"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf208_convolution.png""); [#1] INFO:Eval -- RooRealVar::setRange(t) new range named 'refrange_fft_lxg' created with bounds [-10,30]; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lxg) creating new cache 0x85ab260 w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf208__convolution_8py.html:105,Load,Loading,105,doc/master/rf208__convolution_8py.html,https://root.cern,https://root.cern/doc/master/rf208__convolution_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf209_anaconv.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf209_anaconv.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Addition and convolution: decay function pdfs with optional B physics effects (mixing and CP violation) ; that can be analytically convolved with e.g. Gaussian resolution functions; pdf1 = decay(t,tau) (x) delta(t); pdf2 = decay(t,tau) (x) gauss(t,m,s); pdf3 = decay(t,tau) (x) (f*gauss1(t,m1,s1) + (1-f)*gauss2(t,m1,s1)); f#define f(i)Definition RSha256.hxx:104; s1#define s1(x)Definition RSha256.hxx:91; xDouble_t x[n]Definition legend1.C:17; mTMarker mDefinition textangle.C:8. ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussModel.h""; #include ""RooAddModel.h""; #include ""RooTruthModel.h""; #include ""RooDecay.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf209_anaconv(); {; // B - p h y s i c s p d f w i t h t r u t h r e s o l u t i o n; // ---------------------------------------------------------------------; ; // Variables of decay pdf; RooRealVar dt(""dt"", ""dt"", -10, 10);; RooRealVar tau(""tau"", ""tau"", 1.548);; ; // Build a truth resolution model (delta function); RooTruthModel tm1(""tm"", ""truth model"", dt);; ; // Construct decay(t) (x) delta(t); RooDecay decay_tm(""decay_tm"", ""decay"", dt, tau, tm1, RooDecay::DoubleSided);; ; // Plot pdf (dashed); RooPlot *frame = dt.frame(Title(""Bdecay (x) resolution""));; decay_tm.plotOn(frame, LineStyle(kDashed));; ; // B - p h y s i c s p d f w i t h G a u s s i a n r e s o l u t i o n; // ----------------------------------------------------------------------------; ; // Build a gaussian resolution model; RooRealVar bias1(""bias1"", ""bias1"", 0);; RooRealVar sigma1(""sigma1"", ""sigma1"", 1);; RooGaussModel gm1(""gm1"", ""gauss model 1"", dt, bias1, sigma1);; ; // Construct decay(t) (x) gauss1(t); RooDecay decay_gm1(""decay_gm1"", ""decay"", ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf209__anaconv_8C.html:100,Load,Loading,100,doc/master/rf209__anaconv_8C.html,https://root.cern,https://root.cern/doc/master/rf209__anaconv_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf209_anaconv.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf209_anaconv.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Addition and convolution: decay function pdfs with optional B physics effects (mixing and CP violation) that can be analytically convolved with e.g. ; Gaussian resolution functions; pdf1 = decay(t,tau) (x) delta(t); pdf2 = decay(t,tau) (x) gauss(t,m,s); pdf3 = decay(t,tau) (x) (f*gauss1(t,m1,s1) + (1-f)*gauss2(t,m1,s1)). ; import ROOT; ; # B-physics pdf with truth resolution; # ---------------------------------------------------------------------; ; # Variables of decay pdf; dt = ROOT.RooRealVar(""dt"", ""dt"", -10, 10); tau = ROOT.RooRealVar(""tau"", ""tau"", 1.548); ; # Build a truth resolution model (delta function); tm = ROOT.RooTruthModel(""tm"", ""truth model"", dt); ; # Construct decay(t) (x) delta(t); decay_tm = ROOT.RooDecay(""decay_tm"", ""decay"", dt, tau, tm, type=""DoubleSided""); ; # Plot pdf (dashed); frame = dt.frame(Title=""Bdecay (x) resolution""); decay_tm.plotOn(frame, LineStyle=""--""); ; # B-physics pdf with Gaussian resolution; # ----------------------------------------------------------------------------; ; # Build a gaussian resolution model; bias1 = ROOT.RooRealVar(""bias1"", ""bias1"", 0); sigma1 = ROOT.RooRealVar(""sigma1"", ""sigma1"", 1); gm1 = ROOT.RooGaussModel(""gm1"", ""gauss model 1"", dt, bias1, sigma1); ; # Construct decay(t) (x) gauss1(t); decay_gm1 = ROOT.RooDecay(""decay_gm1"", ""decay"", dt, tau, gm1, type=""DoubleSided""); ; # Plot pdf; decay_gm1.plotOn(frame); ; # B-physics pdf with double Gaussian resolution; # ------------------------------------------------------------------------------------------; ; # Build another gaussian resolution model; bias2 = ROOT.RooRealVar(""bias2"", ""bias2"", 0); sigma2 = ROOT.RooRealVar(""sigma2"", ""sigma2"", 5); gm2 = ROOT.RooGaussModel(""gm2"", ""gauss model 2"", dt, bias2, sigma2); ; # Build a composite reso",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf209__anaconv_8py.html:101,Load,Loading,101,doc/master/rf209__anaconv_8py.html,https://root.cern,https://root.cern/doc/master/rf209__anaconv_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf210_angularconv.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf210_angularconv.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Addition and convolution: convolution in cyclical angular observables theta ; and construction of pdf in terms of transformed angular coordinates, e.g. cos(theta), where the convolution is performed in theta rather than cos(theta); pdf(theta) = T(theta) (x) gauss(theta); pdf(cosTheta) = T(acos(cosTheta)) (x) gauss(acos(cosTheta)); xDouble_t x[n]Definition legend1.C:17; This tutorial requires FFT3 to be enabled. ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooGenericPdf.h""; #include ""RooFormulaVar.h""; #include ""RooFFTConvPdf.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf210_angularconv(); {; // S e t u p c o m p o n e n t p d f s; // ---------------------------------------; ; // Define angle psi; RooRealVar psi(""psi"", ""psi"", 0, 3.14159268);; ; // Define physics pdf T(psi); RooGenericPdf Tpsi(""Tpsi"", ""1+sin(2*@0)"", psi);; ; // Define resolution R(psi); RooRealVar gbias(""gbias"", ""gbias"", 0.2, 0., 1);; RooRealVar greso(""greso"", ""greso"", 0.3, 0.1, 1.0);; RooGaussian Rpsi(""Rpsi"", ""Rpsi"", psi, gbias, greso);; ; // Define cos(psi) and function psif that calculates psi from cos(psi); RooRealVar cpsi(""cpsi"", ""cos(psi)"", -1, 1);; RooFormulaVar psif(""psif"", ""acos(cpsi)"", cpsi);; ; // Define physics pdf also as function of cos(psi): T(psif(cpsi)) = T(cpsi) ;; RooGenericPdf Tcpsi(""T"", ""1+sin(2*@0)"", psif);; ; // C o n s t r u c t c o n v o l u t i o n p d f i n p s i; // --------------------------------------------------------------; ; // Define convoluted pdf as function of psi: M=[T(x)R](psi) = M(psi); RooFFTConvPdf Mpsi(""Mf"", ""Mf"", psi, Tpsi, Rpsi);; ; // Set the buffer fraction to zero to obtain a true cyclical convolution; Mpsi.setBuffer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf210__angularconv_8C.html:104,Load,Loading,104,doc/master/rf210__angularconv_8C.html,https://root.cern,https://root.cern/doc/master/rf210__angularconv_8C.html,2,"['Load', 'perform']","['Loading', 'performed']"
Performance,". ROOT: tutorials/roofit/rf210_angularconv.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf210_angularconv.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Convolution in cyclical angular observables theta, and construction of p.d.f in terms of transformed angular coordinates, e.g. ; cos(theta), the convolution is performed in theta rather than cos(theta); (require ROOT to be compiled with –enable-fftw3); pdf(theta) = ROOT.T(theta) (x) gauss(theta) pdf(cosTheta) = ROOT.T(acos(cosTheta)) (x) gauss(acos(cosTheta)). ; import ROOT; ; # Set up component pdfs; # ---------------------------------------; ; # Define angle psi; psi = ROOT.RooRealVar(""psi"", ""psi"", 0, 3.14159268); ; # Define physics p.d.f T(psi); Tpsi = ROOT.RooGenericPdf(""Tpsi"", ""1+sin(2*@0)"", [psi]); ; # Define resolution R(psi); gbias = ROOT.RooRealVar(""gbias"", ""gbias"", 0.2, 0.0, 1); greso = ROOT.RooRealVar(""greso"", ""greso"", 0.3, 0.1, 1.0); Rpsi = ROOT.RooGaussian(""Rpsi"", ""Rpsi"", psi, gbias, greso); ; # Define cos(psi) and function psif that calculates psi from cos(psi); cpsi = ROOT.RooRealVar(""cpsi"", ""cos(psi)"", -1, 1); psif = ROOT.RooFormulaVar(""psif"", ""acos(cpsi)"", [cpsi]); ; # Define physics p.d.f. also as function of cos(psi): T(psif(cpsi)) = T(cpsi); Tcpsi = ROOT.RooGenericPdf(""T"", ""1+sin(2*@0)"", [psif]); ; # Construct convolution pdf in psi; # --------------------------------------------------------------; ; # Define convoluted p.d.f. as function of psi: M=[T(x)R](psi) = M(psi); Mpsi = ROOT.RooFFTConvPdf(""Mf"", ""Mf"", psi, Tpsi, Rpsi); ; # Set the buffer fraction to zero to obtain a ROOT.True cyclical; # convolution; Mpsi.setBufferFraction(0); ; # Sample, fit and plot convoluted pdf (psi); # --------------------------------------------------------------------------------; ; # Generate some events in observable psi; data_psi = Mpsi.generate({psi}, 10000); ; # Fit convoluted model as function of angle psi; Mpsi.fitTo(dat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf210__angularconv_8py.html:105,Load,Loading,105,doc/master/rf210__angularconv_8py.html,https://root.cern,https://root.cern/doc/master/rf210__angularconv_8py.html,2,"['Load', 'perform']","['Loading', 'performed']"
Performance,". ROOT: tutorials/roofit/rf211_paramconv.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf211_paramconv.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Addition and convolution: working with a pdf with a convolution operator in terms of a parameter ; This tutorial requires FFT3 to be enabled. ; #include ""RooRealVar.h""; #include ""RooDataHist.h""; #include ""RooGaussian.h""; #include ""RooGenericPdf.h""; #include ""RooFormulaVar.h""; #include ""RooFFTConvPdf.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH2.h""; using namespace RooFit;; ; void rf211_paramconv(); {; // S e t u p c o m p o n e n t p d f s; // ---------------------------------------; ; // Gaussian g(x ; mean,sigma); RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar mean(""mean"", ""mean"", -3, 3);; RooRealVar sigma(""sigma"", ""sigma"", 0.5, 0.1, 10);; RooGaussian modelx(""gx"", ""gx"", x, mean, sigma);; ; // Block function in mean; RooRealVar a(""a"", ""a"", 2, 1, 10);; RooGenericPdf model_mean(""model_mean"", ""abs(mean)<a"", RooArgList(mean, a));; ; // Convolution in mean parameter model = g(x,mean,sigma) (x) block(mean); x.setBins(1000, ""cache"");; mean.setBins(50, ""cache"");; RooFFTConvPdf model(""model"", ""model"", mean, modelx, model_mean);; ; // Configure convolution to construct a 2-D cache in (x,mean); // rather than a 1-d cache in mean that needs to be recalculated; // for each value of x; model.setCacheObservables(x);; model.setBufferFraction(1.0);; ; // Integrate model over mean projModel = Int model dmean; RooAbsPdf *projModel = model.createProjection(mean);; ; // Generate 1000 toy events; std::unique_ptr<RooDataHist> d{projModel->generateBinned(x, 1000)};; ; // Fit pdf to toy data; projModel->fitTo(*d, Verbose(), PrintLevel(-1));; ; // Plot data and fitted pdf; RooPlot *frame = x.frame(Bins(25));; d->plotOn(frame);; projModel->plotOn(frame);; ; // Make 2d histogram of model(x;mean); TH1 *hh = model.createHistogram(""hh"", x, Bin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf211__paramconv_8C.html:102,Load,Loading,102,doc/master/rf211__paramconv_8C.html,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf211_paramconv.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf211_paramconv.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'ADDITION AND CONVOLUTION' RooFit tutorial macro #211 Working a with a p.d.f. ; with a convolution operator in terms of a parameter; (require ROOT to be compiled with –enable-fftw3). ; import ROOT; ; # Set up component pdfs; # ---------------------------------------; ; # Gaussian g(x ; mean,sigma); x = ROOT.RooRealVar(""x"", ""x"", -10, 10); mean = ROOT.RooRealVar(""mean"", ""mean"", -3, 3); sigma = ROOT.RooRealVar(""sigma"", ""sigma"", 0.5, 0.1, 10); modelx = ROOT.RooGaussian(""gx"", ""gx"", x, mean, sigma); ; # Block function in mean; a = ROOT.RooRealVar(""a"", ""a"", 2, 1, 10); model_mean = ROOT.RooGenericPdf(""model_mean"", ""abs(mean)<a"", [mean, a]); ; # Convolution in mean model = g(x,mean,sigma) (x) block(mean); x.setBins(1000, ""cache""); mean.setBins(50, ""cache""); model = ROOT.RooFFTConvPdf(""model"", ""model"", mean, modelx, model_mean); ; # Configure convolution to construct a 2-D cache in (x,mean); # rather than a 1-d cache in mean that needs to be recalculated; # for each value of x; model.setCacheObservables({x}); model.setBufferFraction(1.0); ; # Integrate model over projModel = Int model dmean; projModel = model.createProjection({mean}); ; # Generate 1000 toy events; d = projModel.generateBinned({x}, 1000); ; # Fit p.d.f. to toy data; projModel.fitTo(d, Verbose=True, PrintLevel=-1); ; # Plot data and fitted p.d.f.; frame = x.frame(Bins=25); d.plotOn(frame); projModel.plotOn(frame); ; # Make 2d histogram of model(x;mean); hh = model.createHistogram(; ""hh"",; x,; Binning=50,; YVar=dict(var=mean, Binning=50),; ConditionalObservables={mean},; ); hh.SetTitle(""histogram of model(x|mean)""); hh.SetLineColor(ROOT.kBlue); ; # Draw frame on canvas; c = ROOT.TCanvas(""rf211_paramconv"", ""rf211_paramconv"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf211__paramconv_8py.html:103,Load,Loading,103,doc/master/rf211__paramconv_8py.html,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8py.html,3,"['Load', 'cache']","['Loading', 'cache']"
Performance,". ROOT: tutorials/roofit/rf212_plottingInRanges_blinding.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf212_plottingInRanges_blinding.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Plot a PDF in disjunct ranges, and get normalisation right. ; Usually, when comparing a fit to data, one should first plot the data, and then the PDF. In this case, the PDF is automatically normalised to match the number of data events in the plot. However, when plotting only a sub-range, when e.g. a signal region has to be blinded, one has to exclude the blinded region from the computation of the normalisation.; In this tutorial, we show how to explicitly choose the normalisation when plotting using NormRange().; Thanks to Marc Escalier for asking how to do this correctly. ; #include <RooDataSet.h>; #include <RooExponential.h>; #include <RooPlot.h>; #include <RooRealVar.h>; #include <TCanvas.h>; ; using namespace RooFit;; ; void rf212_plottingInRanges_blinding(); {; // Make a fit model; RooRealVar x(""x"", ""The observable"", 1, 30);; RooRealVar tau(""tau"", ""The exponent"", -0.1337, -10., -0.1);; RooExponential expo(""expo"", ""A falling exponential function"", x, tau);; ; // Define the sidebands (e.g. background regions); x.setRange(""full"", 1, 30);; x.setRange(""left"", 1, 10);; x.setRange(""right"", 20, 30);; ; // Generate toy data, and cut out the blinded region.; std::unique_ptr<RooDataSet> data{expo.generate(x, 1000)};; std::unique_ptr<RooAbsData> blindedData{data->reduce(CutRange(""left,right""))};; ; // Kick tau a bit, and run an unbinned fit where the blinded data are missing.; // ----------------------------------------------------------------------------------------------------------; // The fit should be done only in the unblinded regions, otherwise it would; // try to make the model adapt to the empty bins in the blinded region.; tau.setVal(-2.);; expo.fitTo(*blindedData, Range(""left,right""), PrintLevel(-1));; ; // Cle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8C.html:118,Load,Loading,118,doc/master/rf212__plottingInRanges__blinding_8C.html,https://root.cern,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf212_plottingInRanges_blinding.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf212_plottingInRanges_blinding.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Plot a PDF in disjunct ranges, and get normalisation right. ; Usually, when comparing a fit to data, one should first plot the data, and then the PDF. In this case, the PDF is automatically normalised to match the number of data events in the plot. However, when plotting only a sub-range, when e.g. a signal region has to be blinded, one has to exclude the blinded region from the computation of the normalisation.; In this tutorial, we show how to explicitly choose the normalisation when plotting using NormRange(). ; import ROOT; ; # Make a fit model; x = ROOT.RooRealVar(""x"", ""The observable"", 1, 30); tau = ROOT.RooRealVar(""tau"", ""The exponent"", -0.1337, -10.0, -0.1); expo = ROOT.RooExponential(""expo"", ""A falling exponential function"", x, tau); ; # Define the sidebands (e.g. background regions); x.setRange(""full"", 1, 30); x.setRange(""left"", 1, 10); x.setRange(""right"", 20, 30); ; # Generate toy data, and cut out the blinded region.; data = expo.generate(x, 1000); blindedData = data.reduce(CutRange=""left,right""); ; # Kick tau a bit, and run an unbinned fit where the blinded data are missing.; # ----------------------------------------------------------------------------------------------------------; # The fit should be done only in the unblinded regions, otherwise it would try; # to make the model adapt to the empty bins in the blinded region.; tau.setVal(-2.0); expo.fitTo(blindedData, Range=""left,right"", PrintLevel=-1); ; # Clear the ""fitrange"" attribute of the PDF. Otherwise, the fitrange would be; # automatically taken as the NormRange() for plotting. We want to avoid this,; # because the point of this tutorial is to show what can go wrong when the; # NormRange() is not specified.; expo.removeStringAt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8py.html:119,Load,Loading,119,doc/master/rf212__plottingInRanges__blinding_8py.html,https://root.cern,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf301_composition.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf301_composition.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: multi-dimensional pdfs through composition e.g. ; substituting a pdf parameter with a function that depends on other observables; pdf = gauss(x,f(y),s) with f(y) = a0 + a1*y. ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolyVar.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf301_composition(); {; // S e t u p c o m p o s e d m o d e l g a u s s ( x , m ( y ) , s ); // -----------------------------------------------------------------------; ; // Create observables; RooRealVar x(""x"", ""x"", -5, 5);; RooRealVar y(""y"", ""y"", -5, 5);; ; // Create function f(y) = a0 + a1*y; RooRealVar a0(""a0"", ""a0"", -0.5, -5, 5);; RooRealVar a1(""a1"", ""a1"", -0.5, -1, 1);; RooPolyVar fy(""fy"", ""fy"", y, RooArgSet(a0, a1));; ; // Create gauss(x,f(y),s); RooRealVar sigma(""sigma"", ""width of gaussian"", 0.5);; RooGaussian model(""model"", ""Gaussian with shifting mean"", x, fy, sigma);; ; // S a m p l e d a t a , p l o t d a t a a n d p d f o n x a n d y; // ---------------------------------------------------------------------------------; ; // Generate 10000 events in x and y from model; std::unique_ptr<RooDataSet> data{model.generate({x, y}, 10000)};; ; // Plot x distribution of data and projection of model on x = Int(dy) model(x,y); RooPlot *xframe = x.frame();; data->plotOn(xframe);; model.plotOn(xframe);; ; // Plot x distribution of data and projection of model on y = Int(dx) model(x,y); RooPlot *yframe = y.frame();; data->plotOn(yframe);; model.plotOn(yframe);; ; // Make two-dimensional plot in x vs y; TH1 *hh_model = model.createHistogram(""hh_model"", x, Binning(50), YVar(y, Binning(50)));; hh_model->SetLineColor(kBlue);; ; // Make can",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf301__composition_8C.html:104,Load,Loading,104,doc/master/rf301__composition_8C.html,https://root.cern,https://root.cern/doc/master/rf301__composition_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf301_composition.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf301_composition.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: multi-dimensional pdfs through composition, e.g. ; substituting a pdf parameter with a function that depends on other observables; pdf = gauss(x,f(y),s) with f(y) = a0 + a1*y. ; import ROOT; ; # Setup composed model gauss(x, m(y), s); # -----------------------------------------------------------------------; ; # Create observables; x = ROOT.RooRealVar(""x"", ""x"", -5, 5); y = ROOT.RooRealVar(""y"", ""y"", -5, 5); ; # Create function f(y) = a0 + a1*y; a0 = ROOT.RooRealVar(""a0"", ""a0"", -0.5, -5, 5); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -1, 1); fy = ROOT.RooPolyVar(""fy"", ""fy"", y, [a0, a1]); ; # Creat gauss(x,f(y),s); sigma = ROOT.RooRealVar(""sigma"", ""width of gaussian"", 0.5); model = ROOT.RooGaussian(""model"", ""Gaussian with shifting mean"", x, fy, sigma); ; # Sample data, plot data and pdf on x and y; # ---------------------------------------------------------------------------------; ; # Generate 10000 events in x and y from model; data = model.generate({x, y}, 10000); ; # Plot x distribution of data and projection of model x = Int(dy); # model(x,y); xframe = x.frame(); data.plotOn(xframe); model.plotOn(xframe); ; # Plot x distribution of data and projection of model y = Int(dx); # model(x,y); yframe = y.frame(); data.plotOn(yframe); model.plotOn(yframe); ; # Make two-dimensional plot in x vs y; hh_model = model.createHistogram(""hh_model"", x, Binning=50, YVar=dict(var=y, Binning=50)); hh_model.SetLineColor(ROOT.kBlue); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf301_composition"", ""rf301_composition"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); yframe.GetYaxis().SetTitleOffset(1.4); yf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf301__composition_8py.html:105,Load,Loading,105,doc/master/rf301__composition_8py.html,https://root.cern,https://root.cern/doc/master/rf301__composition_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf302_utilfuncs.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf302_utilfuncs.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: utility functions classes available for use in tailoring of composite (multidimensional) pdfs . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooFormulaVar.h""; #include ""RooAddition.h""; #include ""RooProduct.h""; #include ""RooPolyVar.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; ; using namespace RooFit;; ; void rf302_utilfuncs(); {; // C r e a t e o b s e r v a b l e s , p a r a m e t e r s; // -----------------------------------------------------------; ; // Create observables; RooRealVar x(""x"", ""x"", -5, 5);; RooRealVar y(""y"", ""y"", -5, 5);; ; // Create parameters; RooRealVar a0(""a0"", ""a0"", -1.5, -5, 5);; RooRealVar a1(""a1"", ""a1"", -0.5, -1, 1);; RooRealVar sigma(""sigma"", ""width of gaussian"", 0.5);; ; // U s i n g R o o F o r m u l a V a r t o t a i l o r p d f; // -----------------------------------------------------------------------; ; // Create interpreted function f(y) = a0 - a1*sqrt(10*abs(y)); RooFormulaVar fy_1(""fy_1"", ""a0-a1*sqrt(10*abs(y))"", RooArgSet(y, a0, a1));; ; // Create gauss(x,f(y),s); RooGaussian model_1(""model_1"", ""Gaussian with shifting mean"", x, fy_1, sigma);; ; // U s i n g R o o P o l y V a r t o t a i l o r p d f; // -----------------------------------------------------------------------; ; // Create polynomial function f(y) = a0 + a1*y; RooPolyVar fy_2(""fy_2"", ""fy_2"", y, RooArgSet(a0, a1));; ; // Create gauss(x,f(y),s); RooGaussian model_2(""model_2"", ""Gaussian with shifting mean"", x, fy_2, sigma);; ; // U s i n g R o o A d d i t i o n t o t a i l o r p d f; // -----------------------------------------------------------------------; ; // Create sum function f(y) = a0 + y; RooAdd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf302__utilfuncs_8C.html:102,Load,Loading,102,doc/master/rf302__utilfuncs_8C.html,https://root.cern,https://root.cern/doc/master/rf302__utilfuncs_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf302_utilfuncs.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf302_utilfuncs.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: utility functions classes available for use in tailoring of composite (multidimensional) pdfs . ; import ROOT; ; # Create observables, parameters; # -----------------------------------------------------------; ; # Create observables; x = ROOT.RooRealVar(""x"", ""x"", -5, 5); y = ROOT.RooRealVar(""y"", ""y"", -5, 5); ; # Create parameters; a0 = ROOT.RooRealVar(""a0"", ""a0"", -1.5, -5, 5); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -1, 1); sigma = ROOT.RooRealVar(""sigma"", ""width of gaussian"", 0.5); ; # Using RooFormulaVar to tailor pdf; # -----------------------------------------------------------------------; ; # Create interpreted function f(y) = a0 - a1*sqrt(10*abs(y)); fy_1 = ROOT.RooFormulaVar(""fy_1"", ""a0-a1*sqrt(10*abs(y))"", [y, a0, a1]); ; # Create gauss(x,f(y),s); model_1 = ROOT.RooGaussian(""model_1"", ""Gaussian with shifting mean"", x, fy_1, sigma); ; # Using RooPolyVar to tailor pdf; # -----------------------------------------------------------------------; ; # Create polynomial function f(y) = a0 + a1*y; fy_2 = ROOT.RooPolyVar(""fy_2"", ""fy_2"", y, [a0, a1]); ; # Create gauss(x,f(y),s); model_2 = ROOT.RooGaussian(""model_2"", ""Gaussian with shifting mean"", x, fy_2, sigma); ; # Using RooAddition to tailor pdf; # -----------------------------------------------------------------------; ; # Create sum function f(y) = a0 + y; fy_3 = ROOT.RooAddition(""fy_3"", ""a0+y"", [a0, y]); ; # Create gauss(x,f(y),s); model_3 = ROOT.RooGaussian(""model_3"", ""Gaussian with shifting mean"", x, fy_3, sigma); ; # Using RooProduct to tailor pdf; # -----------------------------------------------------------------------; ; # Create product function f(y) = a1*y; fy_4 = ROOT.RooProduct(""fy_4"", ""a1*y"", [a1, y]); ; # Create gauss(x,f(y),s); model_4 = ROOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf302__utilfuncs_8py.html:103,Load,Loading,103,doc/master/rf302__utilfuncs_8py.html,https://root.cern,https://root.cern/doc/master/rf302__utilfuncs_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf303_conditional.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf303_conditional.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: use of tailored pdf as conditional pdfs.s ; pdf = gauss(x,f(y),sx | y ) with f(y) = a0 + a1*y. ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooDataHist.h""; #include ""RooGaussian.h""; #include ""RooPolyVar.h""; #include ""RooProdPdf.h""; #include ""RooPlot.h""; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; ; using namespace RooFit;; ; RooDataSet *makeFakeDataXY();; ; void rf303_conditional(); {; // S e t u p c o m p o s e d m o d e l g a u s s ( x , m ( y ) , s ); // -----------------------------------------------------------------------; ; // Create observables; RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar y(""y"", ""y"", -10, 10);; ; // Create function f(y) = a0 + a1*y; RooRealVar a0(""a0"", ""a0"", -0.5, -5, 5);; RooRealVar a1(""a1"", ""a1"", -0.5, -1, 1);; RooPolyVar fy(""fy"", ""fy"", y, RooArgSet(a0, a1));; ; // Create gauss(x,f(y),s); RooRealVar sigma(""sigma"", ""width of gaussian"", 0.5, 0.1, 2.0);; RooGaussian model(""model"", ""Gaussian with shifting mean"", x, fy, sigma);; ; // Obtain fake external experimental dataset with values for x and y; RooDataSet *expDataXY = makeFakeDataXY();; ; // G e n e r a t e d a t a f r o m c o n d i t i o n a l p . d . f m o d e l ( x | y ); // ---------------------------------------------------------------------------------------------; ; // Make subset of experimental data with only y values; std::unique_ptr<RooAbsData> expAbsDataY{expDataXY->reduce(y)};; RooDataSet *expDataY = static_cast<RooDataSet*>(expAbsDataY.get());; ; // Generate 10000 events in x obtained from _conditional_ model(x|y) with y values taken from experimental data; std::unique_ptr<RooDataSet> data{model.generate(x, ProtoData(*expDataY))};; data->Print();; ; // F i t c o n d i t i o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf303__conditional_8C.html:104,Load,Loading,104,doc/master/rf303__conditional_8C.html,https://root.cern,https://root.cern/doc/master/rf303__conditional_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf303_conditional.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf303_conditional.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'MULTIDIMENSIONAL MODELS' RooFit tutorial macro #303 Use of tailored p.d.f as conditional p.d.fs.s ; pdf = gauss(x,f(y),sx | y ) with f(y) = a0 + a1*y. ; import ROOT; ; ; def makeFakeDataXY():; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); y = ROOT.RooRealVar(""y"", ""y"", -10, 10); coord = {x, y}; ; d = ROOT.RooDataSet(""d"", ""d"", coord); ; for i in range(10000):; tmpy = ROOT.gRandom.Gaus(0, 10); tmpx = ROOT.gRandom.Gaus(0.5 * tmpy, 1); if (abs(tmpy) < 10) and (abs(tmpx) < 10):; x.setVal(tmpx); y.setVal(tmpy); d.add(coord); ; return d; ; ; # Set up composed model gauss(x, m(y), s); # -----------------------------------------------------------------------; ; # Create observables; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); y = ROOT.RooRealVar(""y"", ""y"", -10, 10); ; # Create function f(y) = a0 + a1*y; a0 = ROOT.RooRealVar(""a0"", ""a0"", -0.5, -5, 5); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -1, 1); fy = ROOT.RooPolyVar(""fy"", ""fy"", y, [a0, a1]); ; # Creat gauss(x,f(y),s); sigma = ROOT.RooRealVar(""sigma"", ""width of gaussian"", 0.5, 0.1, 2.0); model = ROOT.RooGaussian(""model"", ""Gaussian with shifting mean"", x, fy, sigma); ; # Obtain fake external experimental dataset with values for x and y; expDataXY = makeFakeDataXY(); ; # Generate data from conditional p.d.f. model(x|y); # ---------------------------------------------------------------------------------------------; ; # Make subset of experimental data with only y values; expDataY = expDataXY.reduce({y}); ; # Generate 10000 events in x obtained from _conditional_ model(x|y) with y; # values taken from experimental data; data = model.generate({x}, ProtoData=expDataY); data.Print(); ; # Fit conditional p.d.f model(x|y) to data; # ---------------------------------------------------------------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf303__conditional_8py.html:105,Load,Loading,105,doc/master/rf303__conditional_8py.html,https://root.cern,https://root.cern/doc/master/rf303__conditional_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf304_uncorrprod.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf304_uncorrprod.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: simple uncorrelated multi-dimensional pdfs ; pdf = gauss(x,mx,sx) * gauss(y,my,sy). ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooProdPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf304_uncorrprod(); {; ; // C r e a t e c o m p o n e n t p d f s i n x a n d y; // ----------------------------------------------------------------; ; // Create two pdfs gaussx(x,meanx,sigmax) gaussy(y,meany,sigmay) and its variables; RooRealVar x(""x"", ""x"", -5, 5);; RooRealVar y(""y"", ""y"", -5, 5);; ; RooRealVar meanx(""mean1"", ""mean of gaussian x"", 2);; RooRealVar meany(""mean2"", ""mean of gaussian y"", -2);; RooRealVar sigmax(""sigmax"", ""width of gaussian x"", 1);; RooRealVar sigmay(""sigmay"", ""width of gaussian y"", 5);; ; RooGaussian gaussx(""gaussx"", ""gaussian PDF"", x, meanx, sigmax);; RooGaussian gaussy(""gaussy"", ""gaussian PDF"", y, meany, sigmay);; ; // C o n s t r u c t u n c o r r e l a t e d p r o d u c t p d f; // -------------------------------------------------------------------; ; // Multiply gaussx and gaussy into a two-dimensional pdf gaussxy; RooProdPdf gaussxy(""gaussxy"", ""gaussx*gaussy"", RooArgList(gaussx, gaussy));; ; // S a m p l e p d f , p l o t p r o j e c t i o n o n x a n d y; // ---------------------------------------------------------------------------; ; // Generate 10000 events in x and y from gaussxy; std::unique_ptr<RooDataSet> data{gaussxy.generate({x, y}, 10000)};; ; // Plot x distribution of data and projection of gaussxy on x = Int(dy) gaussxy(x,y); RooPlot *xframe = x.frame(Title(""X projection of gauss(x)*gauss(y)""));; data->plotOn(xframe);; gaussxy.plotOn(xframe);; ; // Plot x distribution of data and projection of ga",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf304__uncorrprod_8C.html:103,Load,Loading,103,doc/master/rf304__uncorrprod_8C.html,https://root.cern,https://root.cern/doc/master/rf304__uncorrprod_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf304_uncorrprod.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf304_uncorrprod.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: simple uncorrelated multi-dimensional pdfs ; pdf = gauss(x,mx,sx) * gauss(y,my,sy). ; import ROOT; ; ; # Create component pdfs in x and y; # ----------------------------------------------------------------; ; # Create two pdfs gaussx(x,meanx,sigmax) gaussy(y,meany,sigmay) and its; # variables; x = ROOT.RooRealVar(""x"", ""x"", -5, 5); y = ROOT.RooRealVar(""y"", ""y"", -5, 5); ; meanx = ROOT.RooRealVar(""mean1"", ""mean of gaussian x"", 2); meany = ROOT.RooRealVar(""mean2"", ""mean of gaussian y"", -2); sigmax = ROOT.RooRealVar(""sigmax"", ""width of gaussian x"", 1); sigmay = ROOT.RooRealVar(""sigmay"", ""width of gaussian y"", 5); ; gaussx = ROOT.RooGaussian(""gaussx"", ""gaussian PDF"", x, meanx, sigmax); gaussy = ROOT.RooGaussian(""gaussy"", ""gaussian PDF"", y, meany, sigmay); ; # Construct uncorrelated product pdf; # -------------------------------------------------------------------; ; # Multiply gaussx and gaussy into a two-dimensional pdf gaussxy; gaussxy = ROOT.RooProdPdf(""gaussxy"", ""gaussx*gaussy"", [gaussx, gaussy]); ; # Sample pdf, plot projection on x and y; # ---------------------------------------------------------------------------; ; # Generate 10000 events in x and y from gaussxy; data = gaussxy.generate({x, y}, 10000); ; # Plot x distribution of data and projection of gaussxy x = Int(dy); # gaussxy(x,y); xframe = x.frame(Title=""X projection of gauss(x)*gauss(y)""); data.plotOn(xframe); gaussxy.plotOn(xframe); ; # Plot x distribution of data and projection of gaussxy y = Int(dx); # gaussxy(x,y); yframe = y.frame(Title=""Y projection of gauss(x)*gauss(y)""); data.plotOn(yframe); gaussxy.plotOn(yframe); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf304_uncorrprod"", ""rf304_uncorrprod"", 800, 400); c.Divide(2); c.c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf304__uncorrprod_8py.html:104,Load,Loading,104,doc/master/rf304__uncorrprod_8py.html,https://root.cern,https://root.cern/doc/master/rf304__uncorrprod_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf305_condcorrprod.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf305_condcorrprod.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: multi-dimensional pdfs with conditional pdfs in product ; pdf = gauss(x,f(y),sx | y ) * gauss(y,ms,sx) with f(y) = a0 + a1*y. ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolyVar.h""; #include ""RooProdPdf.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf305_condcorrprod(); {; // C r e a t e c o n d i t i o n a l p d f g x ( x | y ); // -----------------------------------------------------------; ; // Create observables; RooRealVar x(""x"", ""x"", -5, 5);; RooRealVar y(""y"", ""y"", -5, 5);; ; // Create function f(y) = a0 + a1*y; RooRealVar a0(""a0"", ""a0"", -0.5, -5, 5);; RooRealVar a1(""a1"", ""a1"", -0.5, -1, 1);; RooPolyVar fy(""fy"", ""fy"", y, RooArgSet(a0, a1));; ; // Create gaussx(x,f(y),sx); RooRealVar sigmax(""sigma"", ""width of gaussian"", 0.5);; RooGaussian gaussx(""gaussx"", ""Gaussian in x with shifting mean in y"", x, fy, sigmax);; ; // C r e a t e p d f g y ( y ); // -----------------------------------------------------------; ; // Create gaussy(y,0,5); RooGaussian gaussy(""gaussy"", ""Gaussian in y"", y, 0.0, 3.0);; ; // C r e a t e p r o d u c t g x ( x | y ) * g y ( y ); // -------------------------------------------------------; ; // Create gaussx(x,sx|y) * gaussy(y); RooProdPdf model(""model"", ""gaussx(x|y)*gaussy(y)"", gaussy, Conditional(gaussx, x));; ; // S a m p l e , f i t a n d p l o t p r o d u c t p d f; // ---------------------------------------------------------------; ; // Generate 1000 events in x and y from model; std::unique_ptr<RooDataSet> data{model.generate({x, y}, 10000)};; ; // Plot x distribution of data and projection of model on x = Int(dy) model(x,y); RooPlot *xframe = x.frame();; data->plotOn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf305__condcorrprod_8C.html:105,Load,Loading,105,doc/master/rf305__condcorrprod_8C.html,https://root.cern,https://root.cern/doc/master/rf305__condcorrprod_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf305_condcorrprod.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf305_condcorrprod.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: multi-dimensional pdfs with conditional pdfs in product ; pdf = gauss(x,f(y),sx | y ) * gauss(y,ms,sx) with f(y) = a0 + a1*y. ; import ROOT; ; # Create conditional pdf gx(x|y); # -----------------------------------------------------------; ; # Create observables; x = ROOT.RooRealVar(""x"", ""x"", -5, 5); y = ROOT.RooRealVar(""y"", ""y"", -5, 5); ; # Create function f(y) = a0 + a1*y; a0 = ROOT.RooRealVar(""a0"", ""a0"", -0.5, -5, 5); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -1, 1); fy = ROOT.RooPolyVar(""fy"", ""fy"", y, [a0, a1]); ; # Create gaussx(x,f(y),sx); sigmax = ROOT.RooRealVar(""sigma"", ""width of gaussian"", 0.5); gaussx = ROOT.RooGaussian(""gaussx"", ""Gaussian in x with shifting mean in y"", x, fy, sigmax); ; # Create pdf gy(y); # -----------------------------------------------------------; ; # Create gaussy(y,0,5); gaussy = ROOT.RooGaussian(""gaussy"", ""Gaussian in y"", y, 0.0, 3.0); ; # Create product gx(x|y)*gy(y); # -------------------------------------------------------; ; # Create gaussx(x,sx|y) * gaussy(y); model = ROOT.RooProdPdf(""model"", ""gaussx(x|y)*gaussy(y)"", {gaussy}, Conditional=({gaussx}, {x})); ; # Sample, fit and plot product pdf; # ---------------------------------------------------------------; ; # Generate 1000 events in x and y from model; data = model.generate({x, y}, 10000); ; # Plot x distribution of data and projection of model x = Int(dy); # model(x,y); xframe = x.frame(); data.plotOn(xframe); model.plotOn(xframe); ; # Plot x distribution of data and projection of model y = Int(dx); # model(x,y); yframe = y.frame(); data.plotOn(yframe); model.plotOn(yframe); ; # Make two-dimensional plot in x vs y; hh_model = model.createHistogram(""hh_model"", x, ROOT.RooFit.Binning(50), ROOT.RooFit.YVar(y, ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf305__condcorrprod_8py.html:106,Load,Loading,106,doc/master/rf305__condcorrprod_8py.html,https://root.cern,https://root.cern/doc/master/rf305__condcorrprod_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf306_condpereventerrors.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf306_condpereventerrors.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: conditional pdf with per-event errors . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooGaussModel.h""; #include ""RooDecay.h""; #include ""RooLandau.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf306_condpereventerrors(); {; // B - p h y s i c s p d f w i t h p e r - e v e n t G a u s s i a n r e s o l u t i o n; // ----------------------------------------------------------------------------------------------; ; // Observables; RooRealVar dt(""dt"", ""dt"", -10, 10);; RooRealVar dterr(""dterr"", ""per-event error on dt"", 0.01, 10);; ; // Build a gaussian resolution model scaled by the per-event error = gauss(dt,bias,sigma*dterr); RooRealVar bias(""bias"", ""bias"", 0, -10, 10);; RooRealVar sigma(""sigma"", ""per-event error scale factor"", 1, 0.1, 10);; RooGaussModel gm(""gm1"", ""gauss model scaled bt per-event error"", dt, bias, sigma, dterr);; ; // Construct decay(dt) (x) gauss1(dt|dterr); RooRealVar tau(""tau"", ""tau"", 1.548);; RooDecay decay_gm(""decay_gm"", ""decay"", dt, tau, gm, RooDecay::DoubleSided);; ; // C o n s t r u c t f a k e ' e x t e r n a l ' d a t a w i t h p e r - e v e n t e r r o r; // ------------------------------------------------------------------------------------------------------; ; // Use landau pdf to get somewhat realistic distribution with long tail; RooLandau pdfDtErr(""pdfDtErr"", ""pdfDtErr"", dterr, 1.0, 0.25);; std::unique_ptr<RooDataSet> expDataDterr{pdfDtErr.generate(dterr, 10000)};; ; // S a m p l e d a t a f r o m c o n d i t i o n a l d e c a y _ g m ( d t | d t e r r ); // ---------------------------------------------------------------------------------------------; ; // Specify",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf306__condpereventerrors_8C.html:111,Load,Loading,111,doc/master/rf306__condpereventerrors_8C.html,https://root.cern,https://root.cern/doc/master/rf306__condpereventerrors_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf306_condpereventerrors.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf306_condpereventerrors.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: complete example with use of conditional pdf with per-event errors . ; import ROOT; ; # B-physics pdf with per-event Gaussian resolution; # ----------------------------------------------------------------------------------------------; ; # Observables; dt = ROOT.RooRealVar(""dt"", ""dt"", -10, 10); dterr = ROOT.RooRealVar(""dterr"", ""per-event error on dt"", 0.01, 10); ; # Build a gaussian resolution model scaled by the per-error =; # gauss(dt,bias,sigma*dterr); bias = ROOT.RooRealVar(""bias"", ""bias"", 0, -10, 10); sigma = ROOT.RooRealVar(""sigma"", ""per-event error scale factor"", 1, 0.1, 10); gm = ROOT.RooGaussModel(""gm1"", ""gauss model scaled bt per-event error"", dt, bias, sigma, dterr); ; # Construct decay(dt) (x) gauss1(dt|dterr); tau = ROOT.RooRealVar(""tau"", ""tau"", 1.548); decay_gm = ROOT.RooDecay(""decay_gm"", ""decay"", dt, tau, gm, type=""DoubleSided""); ; # Construct fake 'external' data with per-event error; # ------------------------------------------------------------------------------------------------------; ; # Use landau pdf to get somewhat realistic distribution with long tail; pdfDtErr = ROOT.RooLandau(""pdfDtErr"", ""pdfDtErr"", dterr, 1.0, 0.25); expDataDterr = pdfDtErr.generate({dterr}, 10000); ; # Sample data from conditional decay_gm(dt|dterr); # ---------------------------------------------------------------------------------------------; ; # Specify external dataset with dterr values to use decay_dm as; # conditional pdf; data = decay_gm.generate({dt}, ProtoData=expDataDterr); ; # Fit conditional decay_dm(dt|dterr); # ---------------------------------------------------------------------; ; # Specify dterr as conditional observable; decay_gm.fitTo(data, ConditionalObservables={dterr}, Pri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf306__condpereventerrors_8py.html:112,Load,Loading,112,doc/master/rf306__condpereventerrors_8py.html,https://root.cern,https://root.cern/doc/master/rf306__condpereventerrors_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf307_fullpereventerrors.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf307_fullpereventerrors.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: full pdf with per-event errors ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooGaussModel.h""; #include ""RooDecay.h""; #include ""RooLandau.h""; #include ""RooProdPdf.h""; #include ""RooHistPdf.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf307_fullpereventerrors(); {; // B - p h y s i c s p d f w i t h p e r - e v e n t G a u s s i a n r e s o l u t i o n; // ----------------------------------------------------------------------------------------------; ; // Observables; RooRealVar dt(""dt"", ""dt"", -10, 10);; RooRealVar dterr(""dterr"", ""per-event error on dt"", 0.01, 10);; ; // Build a gaussian resolution model scaled by the per-event error = gauss(dt,bias,sigma*dterr); RooRealVar bias(""bias"", ""bias"", 0, -10, 10);; RooRealVar sigma(""sigma"", ""per-event error scale factor"", 1, 0.1, 10);; RooGaussModel gm(""gm1"", ""gauss model scaled bt per-event error"", dt, bias, sigma, dterr);; ; // Construct decay(dt) (x) gauss1(dt|dterr); RooRealVar tau(""tau"", ""tau"", 1.548);; RooDecay decay_gm(""decay_gm"", ""decay"", dt, tau, gm, RooDecay::DoubleSided);; ; // C o n s t r u c t e m p i r i c a l p d f f o r p e r - e v e n t e r r o r; // -----------------------------------------------------------------; ; // Use landau pdf to get empirical distribution with long tail; RooLandau pdfDtErr(""pdfDtErr"", ""pdfDtErr"", dterr, 1.0, 0.25);; std::unique_ptr<RooDataSet> expDataDterr{pdfDtErr.generate(dterr, 10000)};; ; // Construct a histogram pdf to describe the shape of the dtErr distribution; std::unique_ptr<RooDataHist> expHistDterr{expDataDterr->binnedClone()};; RooHistPdf pdfErr(""pdfErr"", ""pdfErr"", dterr, *expHistDterr);; ; //",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf307__fullpereventerrors_8C.html:111,Load,Loading,111,doc/master/rf307__fullpereventerrors_8C.html,https://root.cern,https://root.cern/doc/master/rf307__fullpereventerrors_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf307_fullpereventerrors.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf307_fullpereventerrors.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: usage of full pdf with per-event errors ; ; import ROOT; ; # B-physics pdf with per-event Gaussian resolution; # ----------------------------------------------------------------------------------------------; ; # Observables; dt = ROOT.RooRealVar(""dt"", ""dt"", -10, 10); dterr = ROOT.RooRealVar(""dterr"", ""per-event error on dt"", 0.01, 10); ; # Build a gaussian resolution model scaled by the per-error =; # gauss(dt,bias,sigma*dterr); bias = ROOT.RooRealVar(""bias"", ""bias"", 0, -10, 10); sigma = ROOT.RooRealVar(""sigma"", ""per-event error scale factor"", 1, 0.1, 10); gm = ROOT.RooGaussModel(""gm1"", ""gauss model scaled bt per-event error"", dt, bias, sigma, dterr); ; # Construct decay(dt) (x) gauss1(dt|dterr); tau = ROOT.RooRealVar(""tau"", ""tau"", 1.548); decay_gm = ROOT.RooDecay(""decay_gm"", ""decay"", dt, tau, gm, type=""DoubleSided""); ; # Construct empirical pdf for per-event error; # -----------------------------------------------------------------; ; # Use landau pdf to get empirical distribution with long tail; pdfDtErr = ROOT.RooLandau(""pdfDtErr"", ""pdfDtErr"", dterr, 1.0, 0.25); expDataDterr = pdfDtErr.generate({dterr}, 10000); ; # Construct a histogram pdf to describe the shape of the dtErr distribution; expHistDterr = expDataDterr.binnedClone(); pdfErr = ROOT.RooHistPdf(""pdfErr"", ""pdfErr"", {dterr}, expHistDterr); ; # Construct conditional product decay_dm(dt|dterr)*pdf(dterr); # ----------------------------------------------------------------------------------------------------------------------; ; # Construct production of conditional decay_dm(dt|dterr) with empirical; # pdfErr(dterr); model = ROOT.RooProdPdf(""model"", ""model"", {pdfErr}, Conditional=({decay_gm}, {dt})); ; # (Alternatively you could als",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf307__fullpereventerrors_8py.html:112,Load,Loading,112,doc/master/rf307__fullpereventerrors_8py.html,https://root.cern,https://root.cern/doc/master/rf307__fullpereventerrors_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf308_normintegration2d.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf308_normintegration2d.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: normalization and integration of pdfs, construction of cumulative distribution functions from pdfs in two dimensions . ; #include ""RooRealVar.h""; #include ""RooGaussian.h""; #include ""RooProdPdf.h""; #include ""RooAbsReal.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf308_normintegration2d(); {; // S e t u p m o d e l; // ---------------------; ; // Create observables x,y; RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar y(""y"", ""y"", -10, 10);; ; // Create pdf gaussx(x,-2,3), gaussy(y,2,2); RooGaussian gx(""gx"", ""gx"", x, -2.0, 3.0);; RooGaussian gy(""gy"", ""gy"", y, +2.0, 2.0);; ; // Create gxy = gx(x)*gy(y); RooProdPdf gxy(""gxy"", ""gxy"", RooArgSet(gx, gy));; ; // R e t r i e v e r a w & n o r m a l i z e d v a l u e s o f R o o F i t p . d . f . s; // --------------------------------------------------------------------------------------------------; ; // Return 'raw' unnormalized value of gx; cout << ""gxy = "" << gxy.getVal() << endl;; ; // Return value of gxy normalized over x _and_ y in range [-10,10]; RooArgSet nset_xy(x, y);; cout << ""gx_Norm[x,y] = "" << gxy.getVal(&nset_xy) << endl;; ; // Create object representing integral over gx; // which is used to calculate gx_Norm[x,y] == gx / gx_Int[x,y]; std::unique_ptr<RooAbsReal> igxy{gxy.createIntegral(RooArgSet(x, y))};; cout << ""gx_Int[x,y] = "" << igxy->getVal() << endl;; ; // NB: it is also possible to do the following; ; // Return value of gxy normalized over x in range [-10,10] (i.e. treating y as parameter); RooArgSet nset_x(x);; cout << ""gx_Norm[x] = "" << gxy.getVal(&nset_x) << endl;; ; // Return value of gxy normalized over y in range [-10,10] (i.e. treating x as parameter); RooArgSet nset_y(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf308__normintegration2d_8C.html:110,Load,Loading,110,doc/master/rf308__normintegration2d_8C.html,https://root.cern,https://root.cern/doc/master/rf308__normintegration2d_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf308_normintegration2d.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf308_normintegration2d.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: normalization and integration of pdfs, construction of cumulative distribution functions from pdfs in two dimensions . ; from __future__ import print_function; import ROOT; ; # Set up model; # ---------------------; ; # Create observables x,y; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); y = ROOT.RooRealVar(""y"", ""y"", -10, 10); ; # Create pdf gaussx(x,-2,3), gaussy(y,2,2); gx = ROOT.RooGaussian(""gx"", ""gx"", x, -2.0, 3.0); gy = ROOT.RooGaussian(""gy"", ""gy"", y, +2.0, 2.0); ; # gxy = gx(x)*gy(y); gxy = ROOT.RooProdPdf(""gxy"", ""gxy"", [gx, gy]); ; # Retrieve raw & normalized values of RooFit pdfs; # --------------------------------------------------------------------------------------------------; ; # Return 'raw' unnormalized value of gx; print(""gxy = "", gxy.getVal()); ; # Return value of gxy normalized over x _and_ y in range [-10,10]; nset_xy = {x, y}; print(""gx_Norm[x,y] = "", gxy.getVal(nset_xy)); ; # Create object representing integral over gx; # which is used to calculate gx_Norm[x,y] == gx / gx_Int[x,y]; x_and_y = {x, y}; igxy = gxy.createIntegral(x_and_y); print(""gx_Int[x,y] = "", igxy.getVal()); ; # NB: it is also possible to do the following; ; # Return value of gxy normalized over x in range [-10,10] (i.e. treating y; # as parameter); nset_x = {x}; print(""gx_Norm[x] = "", gxy.getVal(nset_x)); ; # Return value of gxy normalized over y in range [-10,10] (i.e. treating x; # as parameter); nset_y = {y}; print(""gx_Norm[y] = "", gxy.getVal(nset_y)); ; # Integrate normalized pdf over subrange; # ----------------------------------------------------------------------------; ; # Define a range named ""signal"" in x from -5,5; x.setRange(""signal"", -5, 5); y.setRange(""signal"", -3, 3); ; # Create an integral of g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf308__normintegration2d_8py.html:111,Load,Loading,111,doc/master/rf308__normintegration2d_8py.html,https://root.cern,https://root.cern/doc/master/rf308__normintegration2d_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf309_ndimplot.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf309_ndimplot.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: making 2/3 dimensional plots of pdfs and datasets . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooProdPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf309_ndimplot(); {; ; // C r e a t e 2 D m o d e l a n d d a t a s e t; // -----------------------------------------------------; ; // Create observables; RooRealVar x(""x"", ""x"", -5, 5);; RooRealVar y(""y"", ""y"", -5, 5);; ; // Create parameters; RooRealVar a0(""a0"", ""a0"", -3.5, -5, 5);; RooRealVar a1(""a1"", ""a1"", -1.5, -1, 1);; RooRealVar sigma(""sigma"", ""width of gaussian"", 1.5);; ; // Create interpreted function f(y) = a0 - a1*sqrt(10*abs(y)); RooFormulaVar fy(""fy"", ""a0-a1*sqrt(10*abs(y))"", RooArgSet(y, a0, a1));; ; // Create gauss(x,f(y),s); RooGaussian model(""model"", ""Gaussian with shifting mean"", x, fy, sigma);; ; // Sample dataset from gauss(x,y); std::unique_ptr<RooDataSet> data{model.generate({x, y}, 10000)};; ; // M a k e 2 D p l o t s o f d a t a a n d m o d e l; // -------------------------------------------------------------; ; // Create and fill ROOT 2D histogram (20x20 bins) with contents of dataset; TH1 *hh_data = data->createHistogram(""x,y"", Binning(20), Binning(20));; ; // Create and fill ROOT 2D histogram (50x50 bins) with sampling of pdf; // TH2D* hh_pdf = model.createHistogram(""hh_model"",x,Binning(50),YVar(y,Binning(50))) ;; TH1 *hh_pdf = model.createHistogram(""x,y"", 50, 50);; hh_pdf->SetLineColor(kBlue);; ; // C r e a t e 3 D m o d e l a n d d a t a s e t; // -----------------------------------------------------; ; // Create observables; RooRealVar z(""z"", ""z"", -5, 5);; ; RooGaussian gz(""gz"", ""gz"", z, 0.0, 2.0);; RooProdPdf model3(""model3"", ""mode",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf309__ndimplot_8C.html:101,Load,Loading,101,doc/master/rf309__ndimplot_8C.html,https://root.cern,https://root.cern/doc/master/rf309__ndimplot_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf309_ndimplot.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf309_ndimplot.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: making 2/3 dimensional plots of pdfs and datasets . ; import ROOT; ; # Create 2D model and dataset; # -----------------------------------------------------; ; # Create observables; x = ROOT.RooRealVar(""x"", ""x"", -5, 5); y = ROOT.RooRealVar(""y"", ""y"", -5, 5); ; # Create parameters; a0 = ROOT.RooRealVar(""a0"", ""a0"", -3.5, -5, 5); a1 = ROOT.RooRealVar(""a1"", ""a1"", -1.5, -1, 1); sigma = ROOT.RooRealVar(""sigma"", ""width of gaussian"", 1.5); ; # Create interpreted function f(y) = a0 - a1*sqrt(10*abs(y)); fy = ROOT.RooFormulaVar(""fy"", ""a0-a1*sqrt(10*abs(y))"", [y, a0, a1]); ; # Create gauss(x,f(y),s); model = ROOT.RooGaussian(""model"", ""Gaussian with shifting mean"", x, fy, sigma); ; # Sample dataset from gauss(x,y); data = model.generate({x, y}, 10000); ; # Make 2D plots of data and model; # -------------------------------------------------------------; ; # Create and fill ROOT 2D histogram (20x20 bins) with contents of dataset; hh_data = data.createHistogram(""x,y"", x, Binning=20, YVar=dict(var=y, Binning=20)); ; # Create and fill ROOT 2D histogram (50x50 bins) with sampling of pdf; # hh_pdf = model.createHistogram(""hh_model"", x, Binning=50, YVar=dict(var=y, Binning=50)); hh_pdf = model.createHistogram(""x,y"", 50, 50); hh_pdf.SetLineColor(ROOT.kBlue); ; # Create 3D model and dataset; # -----------------------------------------------------; ; # Create observables; z = ROOT.RooRealVar(""z"", ""z"", -5, 5); ; gz = ROOT.RooGaussian(""gz"", ""gz"", z, 0.0, 2.0); model3 = ROOT.RooProdPdf(""model3"", ""model3"", [model, gz]); ; data3 = model3.generate({x, y, z}, 10000); ; # Make 3D plots of data and model; # -------------------------------------------------------------; ; # Create and fill ROOT 2D histogram (8x8x8 bins) with contents of dataset",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf309__ndimplot_8py.html:102,Load,Loading,102,doc/master/rf309__ndimplot_8py.html,https://root.cern,https://root.cern/doc/master/rf309__ndimplot_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf310_sliceplot.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf310_sliceplot.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: projecting pdf and data slices in discrete observables . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussModel.h""; #include ""RooDecay.h""; #include ""RooBMixDecay.h""; #include ""RooCategory.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf310_sliceplot(); {; ; // C r e a t e B d e c a y p d f w it h m i x i n g; // ----------------------------------------------------------; ; // Decay time observables; RooRealVar dt(""dt"", ""dt"", -20, 20);; ; // Discrete observables mixState (B0tag==B0reco?) and tagFlav (B0tag==B0(bar)?); RooCategory mixState(""mixState"", ""B0/B0bar mixing state"");; RooCategory tagFlav(""tagFlav"", ""Flavour of the tagged B0"");; ; // Define state labels of discrete observables; mixState.defineType(""mixed"", -1);; mixState.defineType(""unmixed"", 1);; tagFlav.defineType(""B0"", 1);; tagFlav.defineType(""B0bar"", -1);; ; // Model parameters; RooRealVar dm(""dm"", ""delta m(B)"", 0.472, 0., 1.0);; RooRealVar tau(""tau"", ""B0 decay time"", 1.547, 1.0, 2.0);; RooRealVar w(""w"", ""Flavor Mistag rate"", 0.03, 0.0, 1.0);; RooRealVar dw(""dw"", ""Flavor Mistag rate difference between B0 and B0bar"", 0.01);; ; // Build a gaussian resolution model; RooRealVar bias1(""bias1"", ""bias1"", 0);; RooRealVar sigma1(""sigma1"", ""sigma1"", 0.01);; RooGaussModel gm1(""gm1"", ""gauss model 1"", dt, bias1, sigma1);; ; // Construct a decay pdf, smeared with single gaussian resolution model; RooBMixDecay bmix_gm1(""bmix"", ""decay"", dt, mixState, tagFlav, tau, dm, w, dw, gm1, RooBMixDecay::DoubleSided);; ; // Generate BMixing data with above set of event errors; std::unique_ptr<RooDataSet> data{bmix_gm1.generate({dt, tagFlav, mixState}, 20000)};; ; // P l o t f u l l d e c a y d i s t r i b u t i o n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf310__sliceplot_8C.html:102,Load,Loading,102,doc/master/rf310__sliceplot_8C.html,https://root.cern,https://root.cern/doc/master/rf310__sliceplot_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf310_sliceplot.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf310_sliceplot.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: projecting pdf and data slices in discrete observables . ; import ROOT; ; # Create B decay pdf with mixing; # ----------------------------------------------------------; ; # Decay time observables; dt = ROOT.RooRealVar(""dt"", ""dt"", -20, 20); ; # Discrete observables mixState (B0tag==B0reco?) and tagFlav; # (B0tag==B0(bar)?); # Define state labels of discrete observables; mixState = ROOT.RooCategory(""mixState"", ""B0/B0bar mixing state"", {""mixed"": -1, ""unmixed"": 1}); tagFlav = ROOT.RooCategory(""tagFlav"", ""Flavour of the tagged B0"", {""B0"": 1, ""B0bar"": -1}); ; # Model parameters; dm = ROOT.RooRealVar(""dm"", ""delta m(B)"", 0.472, 0.0, 1.0); tau = ROOT.RooRealVar(""tau"", ""B0 decay time"", 1.547, 1.0, 2.0); w = ROOT.RooRealVar(""w"", ""Flavor Mistag rate"", 0.03, 0.0, 1.0); dw = ROOT.RooRealVar(""dw"", ""Flavor Mistag rate difference between B0 and B0bar"", 0.01); ; # Build a gaussian resolution model; bias1 = ROOT.RooRealVar(""bias1"", ""bias1"", 0); sigma1 = ROOT.RooRealVar(""sigma1"", ""sigma1"", 0.01); gm1 = ROOT.RooGaussModel(""gm1"", ""gauss model 1"", dt, bias1, sigma1); ; # Construct a decay pdf, with single gaussian resolution model; bmix_gm1 = ROOT.RooBMixDecay(""bmix"", ""decay"", dt, mixState, tagFlav, tau, dm, w, dw, gm1, type=""DoubleSided""); ; # Generate BMixing data with above set of event errors; data = bmix_gm1.generate({dt, tagFlav, mixState}, 20000); ; # Plot full decay distribution; # ----------------------------------------------------------; ; # Create frame, data and pdf projection (integrated over tagFlav and; # mixState); frame = dt.frame(Title=""Inclusive decay distribution""); data.plotOn(frame); bmix_gm1.plotOn(frame); ; # Plot decay distribution for mixed and unmixed slice of mixState; # ------------------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf310__sliceplot_8py.html:103,Load,Loading,103,doc/master/rf310__sliceplot_8py.html,https://root.cern,https://root.cern/doc/master/rf310__sliceplot_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf311_rangeplot.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf311_rangeplot.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: projecting pdf and data ranges in continuous observables . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooConstVar.h""; #include ""RooProdPdf.h""; #include ""RooAddPdf.h""; #include ""RooPolynomial.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf311_rangeplot(); {; ; // C r e a t e 3 D p d f a n d d a t a; // -------------------------------------------; ; // Create observables; RooRealVar x(""x"", ""x"", -5, 5);; RooRealVar y(""y"", ""y"", -5, 5);; RooRealVar z(""z"", ""z"", -5, 5);; ; // Create signal pdf gauss(x)*gauss(y)*gauss(z); RooGaussian gx(""gx"", ""gx"", x, 0.0, 1.0);; RooGaussian gy(""gy"", ""gy"", y, 0.0, 1.0);; RooGaussian gz(""gz"", ""gz"", z, 0.0, 1.0);; RooProdPdf sig(""sig"", ""sig"", RooArgSet(gx, gy, gz));; ; // Create background pdf poly(x)*poly(y)*poly(z); RooPolynomial px(""px"", ""px"", x, RooArgSet(-0.1, 0.004));; RooPolynomial py(""py"", ""py"", y, RooArgSet(0.1, -0.004));; RooPolynomial pz(""pz"", ""pz"", z);; RooProdPdf bkg(""bkg"", ""bkg"", RooArgSet(px, py, pz));; ; // Create composite pdf sig+bkg; RooRealVar fsig(""fsig"", ""signal fraction"", 0.1, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgList(sig, bkg), fsig);; ; std::unique_ptr<RooDataSet> data{model.generate({x, y, z}, 20000)};; ; // P r o j e c t p d f a n d d a t a o n x; // -------------------------------------------------; ; // Make plain projection of data and pdf on x observable; RooPlot *frame = x.frame(Title(""Projection of 3D data and pdf on X""), Bins(40));; data->plotOn(frame);; model.plotOn(frame);; ; // P r o j e c t p d f a n d d a t a o n x i n s i g n a l r a n g e; // ----------------------------------------------------------------------------------; ; // Define signal regi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf311__rangeplot_8C.html:102,Load,Loading,102,doc/master/rf311__rangeplot_8C.html,https://root.cern,https://root.cern/doc/master/rf311__rangeplot_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf311_rangeplot.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf311_rangeplot.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: projecting pdf and data ranges in continuous observables . ; import ROOT; ; # Create 3D pdf and data; # -------------------------------------------; ; # Create observables; x = ROOT.RooRealVar(""x"", ""x"", -5, 5); y = ROOT.RooRealVar(""y"", ""y"", -5, 5); z = ROOT.RooRealVar(""z"", ""z"", -5, 5); ; # Create signal pdf gauss(x)*gauss(y)*gauss(z); gx = ROOT.RooGaussian(""gx"", ""gx"", x, 0.0, 1.0); gy = ROOT.RooGaussian(""gy"", ""gy"", y, 0.0, 1.0); gz = ROOT.RooGaussian(""gz"", ""gz"", z, 0.0, 1.0); sig = ROOT.RooProdPdf(""sig"", ""sig"", [gx, gy, gz]); ; # Create background pdf poly(x)*poly(y)*poly(z); px = ROOT.RooPolynomial(""px"", ""px"", x, [-0.1, 0.004]); py = ROOT.RooPolynomial(""py"", ""py"", y, [0.1, -0.004]); pz = ROOT.RooPolynomial(""pz"", ""pz"", z); bkg = ROOT.RooProdPdf(""bkg"", ""bkg"", [px, py, pz]); ; # Create composite pdf sig+bkg; fsig = ROOT.RooRealVar(""fsig"", ""signal fraction"", 0.1, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [sig, bkg], [fsig]); ; data = model.generate({x, y, z}, 20000); ; # Project pdf and data on x; # -------------------------------------------------; ; # Make plain projection of data and pdf on x observable; frame = x.frame(Title=""Projection of 3D data and pdf on X"", Bins=40); data.plotOn(frame); model.plotOn(frame); ; # Project pdf and data on x in signal range; # ----------------------------------------------------------------------------------; ; # Define signal region in y and z observables; y.setRange(""sigRegion"", -1, 1); z.setRange(""sigRegion"", -1, 1); ; # Make plot frame; frame2 = x.frame(Title=""Same projection on X in signal range of (Y,Z)"", Bins=40); ; # Plot subset of data in which all observables are inside ""sigRegion""; # For observables that do not have an explicit ""sigRegion"" range defined",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf311__rangeplot_8py.html:103,Load,Loading,103,doc/master/rf311__rangeplot_8py.html,https://root.cern,https://root.cern/doc/master/rf311__rangeplot_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf312_multirangefit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf312_multirangefit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: performing fits in multiple (disjoint) ranges in one or more dimensions ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooProdPdf.h""; #include ""RooAddPdf.h""; #include ""RooPolynomial.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooFitResult.h""; using namespace RooFit;; ; void rf312_multirangefit(); {; ; // C r e a t e 2 D p d f a n d d a t a; // -------------------------------------------; ; // Define observables x,y; RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar y(""y"", ""y"", -10, 10);; ; // Construct the signal pdf gauss(x)*gauss(y); RooRealVar mx(""mx"", ""mx"", 1, -10, 10);; RooRealVar my(""my"", ""my"", 1, -10, 10);; ; RooGaussian gx(""gx"", ""gx"", x, mx, 1.0);; RooGaussian gy(""gy"", ""gy"", y, my, 1.0);; ; RooProdPdf sig(""sig"", ""sig"", gx, gy);; ; // Construct the background pdf (flat in x,y); RooPolynomial px(""px"", ""px"", x);; RooPolynomial py(""py"", ""py"", y);; RooProdPdf bkg(""bkg"", ""bkg"", px, py);; ; // Construct the composite model sig+bkg; RooRealVar f(""f"", ""f"", 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgList(sig, bkg), f);; ; // Sample 10000 events in (x,y) from the model; std::unique_ptr<RooDataSet> modelData{model.generate({x, y}, 10000)};; ; // D e f i n e s i g n a l a n d s i d e b a n d r e g i o n s; // -------------------------------------------------------------------; ; // Construct the SideBand1,SideBand2,Signal regions; //; // |; // +-------------+-----------+; // | | |; // | Side | Sig |; // | Band1 | nal |; // | | |; // --+-------------+-----------+--; // | |; // | Side |; // | Band2 |; // | |; // +-------------+-----------+; // |; ; x.setRange(""SB1"", -10, +10);; y.setRange(""SB1"", -10, 0);; ; x.setRange(""SB2"", -10, 0);; y.setRang",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf312__multirangefit_8C.html:106,Load,Loading,106,doc/master/rf312__multirangefit_8C.html,https://root.cern,https://root.cern/doc/master/rf312__multirangefit_8C.html,2,"['Load', 'perform']","['Loading', 'performing']"
Performance,". ROOT: tutorials/roofit/rf312_multirangefit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf312_multirangefit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: performing fits in multiple (disjoint) ranges in one or more dimensions ; ; import ROOT; ; ; # Create 2D pdf and data; # -------------------------------------------; ; # Define observables x,y; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); y = ROOT.RooRealVar(""y"", ""y"", -10, 10); ; # Construct the signal pdf gauss(x)*gauss(y); mx = ROOT.RooRealVar(""mx"", ""mx"", 1, -10, 10); my = ROOT.RooRealVar(""my"", ""my"", 1, -10, 10); ; gx = ROOT.RooGaussian(""gx"", ""gx"", x, mx, 1.0); gy = ROOT.RooGaussian(""gy"", ""gy"", y, my, 1.0); ; sig = ROOT.RooProdPdf(""sig"", ""sig"", gx, gy); ; # Construct the background pdf (flat in x,y); px = ROOT.RooPolynomial(""px"", ""px"", x); py = ROOT.RooPolynomial(""py"", ""py"", y); bkg = ROOT.RooProdPdf(""bkg"", ""bkg"", px, py); ; # Construct the composite model sig+bkg; f = ROOT.RooRealVar(""f"", ""f"", 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [sig, bkg], [f]); ; # Sample 10000 events in (x,y) from the model; modelData = model.generate({x, y}, 10000); ; # Define signal and sideband regions; # -------------------------------------------------------------------; ; # Construct the SideBand1,SideBand2, regions; #; # |; # +-------------+-----------+; # | | |; # | Side | Sig |; # | Band1 | nal |; # | | |; # --+-------------+-----------+--; # | |; # | Side |; # | Band2 |; # | |; # +-------------+-----------+; # |; ; x.setRange(""SB1"", -10, +10); y.setRange(""SB1"", -10, 0); ; x.setRange(""SB2"", -10, 0); y.setRange(""SB2"", 0, +10); ; x.setRange(""SIG"", 0, +10); y.setRange(""SIG"", 0, +10); ; x.setRange(""FULL"", -10, +10); y.setRange(""FULL"", -10, +10); ; # Perform fits in individual sideband regions; # -------------------------------------------------------------------------------------; ; # Perform fit in SideBand1 re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf312__multirangefit_8py.html:107,Load,Loading,107,doc/master/rf312__multirangefit_8py.html,https://root.cern,https://root.cern/doc/master/rf312__multirangefit_8py.html,2,"['Load', 'perform']","['Loading', 'performing']"
Performance,". ROOT: tutorials/roofit/rf313_paramranges.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf313_paramranges.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: working with parametrized ranges to define non-rectangular regions for fitting and integration . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooProdPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf313_paramranges(); {; ; // C r e a t e 3 D p d f; // -------------------------; ; // Define observable (x,y,z); RooRealVar x(""x"", ""x"", 0, 10);; RooRealVar y(""y"", ""y"", 0, 10);; RooRealVar z(""z"", ""z"", 0, 10);; ; // Define 3 dimensional pdf; RooRealVar z0(""z0"", ""z0"", -0.1, 1);; RooPolynomial px(""px"", ""px"", x, RooConst(0.0));; RooPolynomial py(""py"", ""py"", y, RooConst(0.0));; RooPolynomial pz(""pz"", ""pz"", z, z0);; RooProdPdf pxyz(""pxyz"", ""pxyz"", RooArgSet(px, py, pz));; ; // D e f i n e d n o n - r e c t a n g u l a r r e g i o n R i n ( x , y , z ); // -------------------------------------------------------------------------------------; ; //; // R = Z[0 - 0.1*Y^2] * Y[0.1*X - 0.9*X] * X[0 - 10]; //; ; // Construct range parametrized in ""R"" in y [ 0.1*x, 0.9*x ]; RooFormulaVar ylo(""ylo"", ""0.1*x"", x);; RooFormulaVar yhi(""yhi"", ""0.9*x"", x);; y.setRange(""R"", ylo, yhi);; ; // Construct parametrized ranged ""R"" in z [ 0, 0.1*y^2 ]; RooFormulaVar zlo(""zlo"", ""0.0*y"", y);; RooFormulaVar zhi(""zhi"", ""0.1*y*y"", y);; z.setRange(""R"", zlo, zhi);; ; // C a l c u l a t e i n t e g r a l o f n o r m a l i z e d p d f i n R; // ----------------------------------------------------------------------------------; ; // Create integral over normalized pdf model over x,y,z in ""R"" region; std::unique_ptr<RooAbsReal> intPdf{pxyz.createIntegral(RooArgSet(x, y, z), RooArgSet(x, y, z), ""R"")};; ; // Plot value of integral as function ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf313__paramranges_8C.html:104,Load,Loading,104,doc/master/rf313__paramranges_8C.html,https://root.cern,https://root.cern/doc/master/rf313__paramranges_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf313_paramranges.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf313_paramranges.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: working with parameterized ranges to define non-rectangular regions for fitting and integration . ; import ROOT; ; ; # Create 3D pdf; # -------------------------; ; # Define observable (x,y,z); x = ROOT.RooRealVar(""x"", ""x"", 0, 10); y = ROOT.RooRealVar(""y"", ""y"", 0, 10); z = ROOT.RooRealVar(""z"", ""z"", 0, 10); ; # Define 3 dimensional pdf; z0 = ROOT.RooRealVar(""z0"", ""z0"", -0.1, 1); px = ROOT.RooPolynomial(""px"", ""px"", x, [0.0]); py = ROOT.RooPolynomial(""py"", ""py"", y, [0.0]); pz = ROOT.RooPolynomial(""pz"", ""pz"", z, [z0]); pxyz = ROOT.RooProdPdf(""pxyz"", ""pxyz"", [px, py, pz]); ; # Defined non-rectangular region R in (x, y, z); # -------------------------------------------------------------------------------------; ; #; # R = Z[0 - 0.1*Y^2] * Y[0.1*X - 0.9*X] * X[0 - 10]; #; ; # Construct range parameterized in ""R"" in y [ 0.1*x, 0.9*x ]; ylo = ROOT.RooFormulaVar(""ylo"", ""0.1*x"", [x]); yhi = ROOT.RooFormulaVar(""yhi"", ""0.9*x"", [x]); y.setRange(""R"", ylo, yhi); ; # Construct parameterized ranged ""R"" in z [ 0, 0.1*y^2 ]; zlo = ROOT.RooFormulaVar(""zlo"", ""0.0*y"", [y]); zhi = ROOT.RooFormulaVar(""zhi"", ""0.1*y*y"", [y]); z.setRange(""R"", zlo, zhi); ; # Calculate integral of normalized pdf in R; # ----------------------------------------------------------------------------------; ; # Create integral over normalized pdf model over x,y, in ""R"" region; intPdf = pxyz.createIntegral({x, y, z}, {x, y, z}, ""R""); ; # Plot value of integral as function of pdf parameter z0; frame = z0.frame(Title=""Integral of pxyz over x,y, in region R""); intPdf.plotOn(frame); ; c = ROOT.TCanvas(""rf313_paramranges"", ""rf313_paramranges"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf313_paramra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf313__paramranges_8py.html:105,Load,Loading,105,doc/master/rf313__paramranges_8py.html,https://root.cern,https://root.cern/doc/master/rf313__paramranges_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf314_paramfitrange.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf314_paramfitrange.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: working with parametrized ranges in a fit. ; This an example of a fit with an acceptance that changes per-event; pdf = exp(-t/tau) with t[tmin,5]; where t and tmin are both observables in the dataset. ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooConstVar.h""; #include ""RooExponential.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooFitResult.h""; ; using namespace RooFit;; ; void rf314_paramfitrange(); {; ; // D e f i n e o b s e r v a b l e s a n d d e c a y p d f; // ---------------------------------------------------------------; ; // Declare observables; RooRealVar t(""t"", ""t"", 0, 5);; RooRealVar tmin(""tmin"", ""tmin"", 0, 0, 5);; ; // Make parametrized range in t : [tmin,5]; t.setRange(tmin, RooConst(t.getMax()));; ; // Make pdf; RooRealVar tau(""tau"", ""tau"", -1.54, -10, -0.1);; RooExponential model(""model"", ""model"", t, tau);; ; // C r e a t e i n p u t d a t a; // ------------------------------------; ; // Generate complete dataset without acceptance cuts (for reference); std::unique_ptr<RooDataSet> dall{model.generate(t, 10000)};; ; // Generate a (fake) prototype dataset for acceptance limit values; std::unique_ptr<RooDataSet> tmp{RooGaussian(""gmin"", ""gmin"", tmin, 0.0, 0.5).generate(tmin, 5000)};; ; // Generate dataset with t values that observe (t>tmin); std::unique_ptr<RooDataSet> dacc{model.generate(t, ProtoData(*tmp))};; ; // F i t p d f t o d a t a i n a c c e p t a n c e r e g i o n; // -----------------------------------------------------------------------; ; std::unique_ptr<RooFitResult> r{model.fitTo(*dacc, Save(), PrintLevel(-1))};; ; // P l o t f i t t e d p d f o n f u l l a n d a c c e p t e d d a t a; // --------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf314__paramfitrange_8C.html:106,Load,Loading,106,doc/master/rf314__paramfitrange_8C.html,https://root.cern,https://root.cern/doc/master/rf314__paramfitrange_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf314_paramfitrange.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf314_paramfitrange.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: working with parameterized ranges in a fit. ; This an example of a fit with an acceptance that changes per-event; pdf = exp(-t/tau) with t[tmin,5]; where t and tmin are both observables in the dataset. ; import ROOT; ; ; # Define observables and decay pdf; # ---------------------------------------------------------------; ; # Declare observables; t = ROOT.RooRealVar(""t"", ""t"", 0, 5); tmin = ROOT.RooRealVar(""tmin"", ""tmin"", 0, 0, 5); ; # Make parameterized range in t : [tmin,5]; t.setRange(tmin, ROOT.RooFit.RooConst(t.getMax())); ; # Make pdf; tau = ROOT.RooRealVar(""tau"", ""tau"", -1.54, -10, -0.1); model = ROOT.RooExponential(""model"", ""model"", t, tau); ; # Create input data; # ------------------------------------; ; # Generate complete dataset without acceptance cuts (for reference); dall = model.generate({t}, 10000); ; # Generate a (fake) prototype dataset for acceptance limit values; tmp = ROOT.RooGaussian(""gmin"", ""gmin"", tmin, 0.0, 0.5).generate({tmin}, 5000); ; # Generate dataset with t values that observe (t>tmin); dacc = model.generate({t}, ProtoData=tmp); ; # Fit pdf to data in acceptance region; # -----------------------------------------------------------------------; ; r = model.fitTo(dacc, Save=True, PrintLevel=-1); ; # Plot fitted pdf on full and accepted data; # ---------------------------------------------------------------------------------; ; # Make plot frame, datasets and overlay model; frame = t.frame(Title=""Fit to data with per-event acceptance""); dall.plotOn(frame, MarkerColor=""r"", LineColor=""r""); model.plotOn(frame); dacc.plotOn(frame); ; # Print fit results to demonstrate absence of bias; r.Print(""v""); ; c = ROOT.TCanvas(""rf314_paramranges"", ""rf314_paramranges"", 600, 600); ROOT.gPa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf314__paramfitrange_8py.html:107,Load,Loading,107,doc/master/rf314__paramfitrange_8py.html,https://root.cern,https://root.cern/doc/master/rf314__paramfitrange_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf315_projectpdf.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf315_projectpdf.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: marginizalization of multi-dimensional pdfs through integration . ; #include ""RooRealVar.h""; #include ""RooDataHist.h""; #include ""RooGaussian.h""; #include ""RooProdPdf.h""; #include ""RooPolyVar.h""; #include ""TH1.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooNumIntConfig.h""; using namespace RooFit;; ; void rf315_projectpdf(); {; // C r e a t e p d f m ( x , y ) = g x ( x | y ) * g ( y ); // --------------------------------------------------------------; ; // Increase default precision of numeric integration; // as this exercise has high sensitivity to numeric integration precision; RooAbsPdf::defaultIntegratorConfig()->setEpsRel(1e-8);; RooAbsPdf::defaultIntegratorConfig()->setEpsAbs(1e-8);; ; // Create observables; RooRealVar x(""x"", ""x"", -5, 5);; RooRealVar y(""y"", ""y"", -2, 2);; ; // Create function f(y) = a0 + a1*y; RooRealVar a0(""a0"", ""a0"", 0);; RooRealVar a1(""a1"", ""a1"", -1.5, -3, 1);; RooPolyVar fy(""fy"", ""fy"", y, RooArgSet(a0, a1));; ; // Create gaussx(x,f(y),sx); RooRealVar sigmax(""sigmax"", ""width of gaussian"", 0.5);; RooGaussian gaussx(""gaussx"", ""Gaussian in x with shifting mean in y"", x, fy, sigmax);; ; // Create gaussy(y,0,2); RooGaussian gaussy(""gaussy"", ""Gaussian in y"", y, 0.0, 2.0);; ; // Create gaussx(x,sx|y) * gaussy(y); RooProdPdf model(""model"", ""gaussx(x|y)*gaussy(y)"", gaussy, Conditional(gaussx, x));; ; // M a r g i n a l i z e m ( x , y ) t o m ( x ); // ----------------------------------------------------; ; // modelx(x) = Int model(x,y) dy; RooAbsPdf *modelx = model.createProjection(y);; ; // U s e m a r g i n a l i z e d p . d . f . a s r e g u l a r 1 - D p . d . f .; // ------------------------------------------------------------------------------------------; ; // Samp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf315__projectpdf_8C.html:103,Load,Loading,103,doc/master/rf315__projectpdf_8C.html,https://root.cern,https://root.cern/doc/master/rf315__projectpdf_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf315_projectpdf.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf315_projectpdf.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: marginizalization of multi-dimensional pdfs through integration . ; import ROOT; ; ; # Create pdf m(x,y) = gx(x|y) * g(y); # --------------------------------------------------------------; ; # Increase default precision of numeric integration; # as self exercise has high sensitivity to numeric integration precision; ROOT.RooAbsPdf.defaultIntegratorConfig().setEpsRel(1e-8); ROOT.RooAbsPdf.defaultIntegratorConfig().setEpsAbs(1e-8); ; # Create observables; x = ROOT.RooRealVar(""x"", ""x"", -5, 5); y = ROOT.RooRealVar(""y"", ""y"", -2, 2); ; # Create function f(y) = a0 + a1*y; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0); a1 = ROOT.RooRealVar(""a1"", ""a1"", -1.5, -3, 1); fy = ROOT.RooPolyVar(""fy"", ""fy"", y, [a0, a1]); ; # Create gaussx(x,f(y),sx); sigmax = ROOT.RooRealVar(""sigmax"", ""width of gaussian"", 0.5); gaussx = ROOT.RooGaussian(""gaussx"", ""Gaussian in x with shifting mean in y"", x, fy, sigmax); ; # Create gaussy(y,0,2); gaussy = ROOT.RooGaussian(""gaussy"", ""Gaussian in y"", y, 0.0, 2.0); ; # Create gaussx(x,sx|y) * gaussy(y); model = ROOT.RooProdPdf(; ""model"",; ""gaussx(x|y)*gaussy(y)"",; {gaussy},; Conditional=({gaussx}, {x}),; ); ; # Marginalize m(x,y) to m(x); # ----------------------------------------------------; ; # modelx(x) = Int model(x,y) dy; modelx = model.createProjection({y}); ; # Use marginalized pdf as regular 1D pdf; # -----------------------------------------------; ; # Sample 1000 events from modelx; data = modelx.generateBinned({x}, 1000); ; # Fit modelx to toy data; modelx.fitTo(data, Verbose=True, PrintLevel=-1); ; # Plot modelx over data; frame = x.frame(40); data.plotOn(frame); modelx.plotOn(frame); ; # Make 2D histogram of model(x,y); hh = model.createHistogram(""x,y""); hh.SetLineColor(ROOT.kBlue); ; c = RO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf315__projectpdf_8py.html:104,Load,Loading,104,doc/master/rf315__projectpdf_8py.html,https://root.cern,https://root.cern/doc/master/rf315__projectpdf_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf316_llratioplot.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf316_llratioplot.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: using the likelihood ratio technique to construct a signal enhanced one-dimensional projection of a multi-dimensional pdf . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooAddPdf.h""; #include ""RooProdPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf316_llratioplot(); {; ; // C r e a t e 3 D p d f a n d d a t a; // -------------------------------------------; ; // Create observables; RooRealVar x(""x"", ""x"", -5, 5);; RooRealVar y(""y"", ""y"", -5, 5);; RooRealVar z(""z"", ""z"", -5, 5);; ; // Create signal pdf gauss(x)*gauss(y)*gauss(z); RooGaussian gx(""gx"", ""gx"", x, 0.0, 1.0);; RooGaussian gy(""gy"", ""gy"", y, 0.0, 1.0);; RooGaussian gz(""gz"", ""gz"", z, 0.0, 1.0);; RooProdPdf sig(""sig"", ""sig"", RooArgSet(gx, gy, gz));; ; // Create background pdf poly(x)*poly(y)*poly(z); RooPolynomial px(""px"", ""px"", x, RooArgSet(-0.1, 0.004));; RooPolynomial py(""py"", ""py"", y, RooArgSet(0.1, -0.004));; RooPolynomial pz(""pz"", ""pz"", z);; RooProdPdf bkg(""bkg"", ""bkg"", RooArgSet(px, py, pz));; ; // Create composite pdf sig+bkg; RooRealVar fsig(""fsig"", ""signal fraction"", 0.1, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgList(sig, bkg), fsig);; ; std::unique_ptr<RooDataSet> data{model.generate({x, y, z}, 20000)};; ; // P r o j e c t p d f a n d d a t a o n x; // -------------------------------------------------; ; // Make plain projection of data and pdf on x observable; RooPlot *frame = x.frame(Title(""Projection of 3D data and pdf on X""), Bins(40));; data->plotOn(frame);; model.plotOn(frame);; ; // D e f i n e p r o j e c t e d s i g n a l l i k e l i h o o d r a t i o; // --------------------------------------------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf316__llratioplot_8C.html:104,Load,Loading,104,doc/master/rf316__llratioplot_8C.html,https://root.cern,https://root.cern/doc/master/rf316__llratioplot_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf316_llratioplot.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf316_llratioplot.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Multidimensional models: using the likelihood ratio technique to construct a signal enhanced one-dimensional projection of a multi-dimensional pdf . ; import ROOT; ; ; # Create 3D pdf and data; # -------------------------------------------; ; # Create observables; x = ROOT.RooRealVar(""x"", ""x"", -5, 5); y = ROOT.RooRealVar(""y"", ""y"", -5, 5); z = ROOT.RooRealVar(""z"", ""z"", -5, 5); ; # Create signal pdf gauss(x)*gauss(y)*gauss(z); gx = ROOT.RooGaussian(""gx"", ""gx"", x, 0.0, 1.0); gy = ROOT.RooGaussian(""gy"", ""gy"", y, 0.0, 1.0); gz = ROOT.RooGaussian(""gz"", ""gz"", z, 0.0, 1.0); sig = ROOT.RooProdPdf(""sig"", ""sig"", [gx, gy, gz]); ; # Create background pdf poly(x)*poly(y)*poly(z); px = ROOT.RooPolynomial(""px"", ""px"", x, [-0.1, 0.004]); py = ROOT.RooPolynomial(""py"", ""py"", y, [0.1, -0.004]); pz = ROOT.RooPolynomial(""pz"", ""pz"", z); bkg = ROOT.RooProdPdf(""bkg"", ""bkg"", [px, py, pz]); ; # Create composite pdf sig+bkg; fsig = ROOT.RooRealVar(""fsig"", ""signal fraction"", 0.1, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [sig, bkg], [fsig]); ; data = model.generate({x, y, z}, 20000); ; # Project pdf and data on x; # -------------------------------------------------; ; # Make plain projection of data and pdf on x observable; frame = x.frame(Title=""Projection of 3D data and pdf on X"", Bins=40); data.plotOn(frame); model.plotOn(frame); ; # Define projected signal likelihood ratio; # ----------------------------------------------------------------------------------; ; # Calculate projection of signal and total likelihood on (y,z) observables; # i.e. integrate signal and composite model over x; sigyz = sig.createProjection({x}); totyz = model.createProjection({x}); ; # Construct the log of the signal / signal+background probability; llratio_func = ROOT.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf316__llratioplot_8py.html:105,Load,Loading,105,doc/master/rf316__llratioplot_8py.html,https://root.cern,https://root.cern/doc/master/rf316__llratioplot_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf401_importttreethx.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf401_importttreethx.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Data and categories: advanced options for importing data from ROOT TTree and THx histograms ; Basic import options are demonstrated in rf102_dataimport.C; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooDataHist.h""; #include ""RooCategory.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TH1.h""; #include ""TTree.h""; #include ""TRandom.h""; #include <map>; ; using namespace RooFit;; ; TH1 *makeTH1(const char *name, double mean, double sigma);; TTree *makeTTree();; ; void rf401_importttreethx(); {; // I m p o r t m u l t i p l e T H 1 i n t o a R o o D a t a H i s t; // --------------------------------------------------------------------------; ; // Create thee ROOT TH1 histograms; TH1 *hh_1 = makeTH1(""hh1"", 0, 3);; TH1 *hh_2 = makeTH1(""hh2"", -3, 1);; TH1 *hh_3 = makeTH1(""hh3"", +3, 4);; ; // Declare observable x; RooRealVar x(""x"", ""x"", -10, 10);; ; // Create category observable c that serves as index for the ROOT histograms; RooCategory c(""c"", ""c"", {{""SampleA"",0}, {""SampleB"",1}, {""SampleC"",2}});; ; // Create a binned dataset that imports contents of all TH1 mapped by index category c; RooDataHist *dh = new RooDataHist(""dh"", ""dh"", x, Index(c), Import(""SampleA"", *hh_1), Import(""SampleB"", *hh_2),; Import(""SampleC"", *hh_3));; dh->Print();; ; // Alternative constructor form for importing multiple histograms; std::map<std::string, TH1 *> hmap;; hmap[""SampleA""] = hh_1;; hmap[""SampleB""] = hh_2;; hmap[""SampleC""] = hh_3;; RooDataHist *dh2 = new RooDataHist(""dh"", ""dh"", x, c, hmap);; dh2->Print();; ; // I m p o r t i n g a T T r e e i n t o a R o o D a t a S e t w i t h c u t s; // -----------------------------------------------------------------------------------------; ; TTree *tree ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf401__importttreethx_8C.html:107,Load,Loading,107,doc/master/rf401__importttreethx_8C.html,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf401_importttreethx.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf401_importttreethx.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'DATA AND CATEGORIES' RooFit tutorial macro #401 ; Overview of advanced option for importing data from ROOT ROOT.TTree and ROOT.THx histograms Basic import options are demonstrated in rf102_dataimport.py; ; import ROOT; from array import array; ; ; def makeTH1(name, mean, sigma):; """"""Create ROOT TH1 filled with a Gaussian distribution.""""""; ; hh = ROOT.TH1D(name, name, 100, -10, 10); for i in range(1000):; hh.Fill(ROOT.gRandom.Gaus(mean, sigma)); ; return hh; ; ; def makeTTree():; """"""Create ROOT ROOT.TTree filled with a Gaussian distribution in x and a uniform distribution in y.""""""; ; tree = ROOT.TTree(""tree"", ""tree""); px = array(""d"", [0]); py = array(""d"", [0]); pz = array(""d"", [0]); pi = array(""i"", [0]); tree.Branch(""x"", px, ""x/D""); tree.Branch(""y"", py, ""y/D""); tree.Branch(""z"", pz, ""z/D""); tree.Branch(""i"", pi, ""i/I""); for i in range(100):; px[0] = ROOT.gRandom.Gaus(0, 3); py[0] = ROOT.gRandom.Uniform() * 30 - 15; pz[0] = ROOT.gRandom.Gaus(0, 5); pi[0] = i % 3; tree.Fill(); ; return tree; ; ; # Import multiple TH1 into a RooDataHist; # ----------------------------------------------------------; ; # Create thee ROOT ROOT.TH1 histograms; hh_1 = makeTH1(""hh1"", 0, 3); hh_2 = makeTH1(""hh2"", -3, 1); hh_3 = makeTH1(""hh3"", +3, 4); ; # Declare observable x; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); ; # Create category observable c that serves as index for the ROOT histograms; c = ROOT.RooCategory(""c"", ""c""); c.defineType(""SampleA""); c.defineType(""SampleB""); c.defineType(""SampleC""); ; # Create a binned dataset that imports contents of all ROOT.TH1 mapped by; # index category c; dh = ROOT.RooDataHist(""dh"", ""dh"", [x], Index=c, Import={""SampleA"": hh_1, ""SampleB"": hh_2, ""SampleC"": hh_3}); dh.Print(); ; dh2 = ROOT.RooDataHist(""dh"", ""dh"", [x]",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf401__importttreethx_8py.html:108,Load,Loading,108,doc/master/rf401__importttreethx_8py.html,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf402_datahandling.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf402_datahandling.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Data and categories: tools for manipulation of (un)binned datasets . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooDataHist.h""; #include ""RooGaussian.h""; #include ""RooCategory.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TFile.h""; using namespace RooFit;; ; // WVE Add reduction by range; ; void rf402_datahandling(); {; ; // Binned (RooDataHist) and unbinned datasets (RooDataSet) share; // many properties and inherit from a common abstract base class; // (RooAbsData), that provides an interface for all operations; // that can be performed regardless of the data format; ; RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar y(""y"", ""y"", 0, 40);; RooCategory c(""c"", ""c"");; c.defineType(""Plus"", +1);; c.defineType(""Minus"", -1);; ; // B a s i c O p e r a t i o n s o n u n b i n n e d d a t a s e t s; // --------------------------------------------------------------; ; // RooDataSet is an unbinned dataset (a collection of points in N-dimensional space); RooDataSet d(""d"", ""d"", RooArgSet(x, y, c));; ; // Unlike RooAbsArgs (RooAbsPdf,RooFormulaVar,....) datasets are not attached to; // the variables they are constructed from. Instead they are attached to an internal; // clone of the supplied set of arguments; ; // Fill d with dummy values; Int_t i;; for (i = 0; i < 1000; i++) {; x = i / 50 - 10;; y = sqrt(1.0 * i);; c.setLabel((i % 2) ? ""Plus"" : ""Minus"");; ; // We must explicitly refer to x,y,c here to pass the values because; // d is not linked to them (as explained above); d.add(RooArgSet(x, y, c));; }; d.Print(""v"");; cout << endl;; ; // The get() function returns a pointer to the internal copy of the RooArgSet(x,y,c); // supplied in the constructor; const RooArgSet *row = d.get();; row->Print(""v"");; cout <<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf402__datahandling_8C.html:105,Load,Loading,105,doc/master/rf402__datahandling_8C.html,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8C.html,2,"['Load', 'perform']","['Loading', 'performed']"
Performance,". ROOT: tutorials/roofit/rf402_datahandling.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf402_datahandling.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Data and categories: tools for manipulation of (un)binned datasets . ; from __future__ import print_function; import ROOT; import math; ; # WVE Add reduction by range; ; # Binned (RooDataHist) and unbinned datasets (RooDataSet) share; # many properties and inherit from a common abstract base class; # (RooAbsData), provides an interface for all operations; # that can be performed regardless of the data format; ; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); y = ROOT.RooRealVar(""y"", ""y"", 0, 40); c = ROOT.RooCategory(""c"", ""c""); c.defineType(""Plus"", +1); c.defineType(""Minus"", -1); ; # Basic operations on unbinned datasetss; # --------------------------------------------------------------; ; # ROOT.RooDataSet is an unbinned dataset (a collection of points in; # N-dimensional space); d = ROOT.RooDataSet(""d"", ""d"", {x, y, c}); ; # Unlike ROOT.RooAbsArgs (ROOT.RooAbsPdf, ROOT.RooFormulaVar,....) datasets are not attached to; # the variables they are constructed from. Instead they are attached to an internal; # clone of the supplied set of arguments; ; # Fill d with dummy values; for i in range(1000):; x.setVal(i / 50 - 10); y.setVal(math.sqrt(1.0 * i)); if i % 2:; c.setLabel(""Plus""); else:; c.setLabel(""Minus""); ; # We must explicitly refer to x,y, here to pass the values because; # d is not linked to them (as explained above); if i < 3:; print(x, y, c); print(type(x)); d.add({x, y, c}); ; d.Print(""v""); print(""""); ; # The get() function returns a pointer to the internal copy of the RooArgSet(x,y,c); # supplied in the constructor; row = d.get(); row.Print(""v""); print(""""); ; # Get with an argument loads a specific data point in row and returns; # a pointer to row argset. get() always returns the same pointer, unless; # an invalid row number is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf402__datahandling_8py.html:106,Load,Loading,106,doc/master/rf402__datahandling_8py.html,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8py.html,2,"['Load', 'perform']","['Loading', 'performed']"
Performance,". ROOT: tutorials/roofit/rf403_weightedevts.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf403_weightedevts.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Data and categories: using weights in unbinned datasets . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooDataHist.h""; #include ""RooGaussian.h""; #include ""RooFormulaVar.h""; #include ""RooGenericPdf.h""; #include ""RooPolynomial.h""; #include ""RooMinimizer.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooFitResult.h""; using namespace RooFit;; ; void rf403_weightedevts(); {; // C r e a t e o b s e r v a b l e a n d u n w e i g h t e d d a t a s e t; // -------------------------------------------------------------------------------; ; // Declare observable; RooRealVar x(""x"", ""x"", -10, 10);; x.setBins(40);; ; // Construction a uniform pdf; RooPolynomial p0(""px"", ""px"", x);; ; // Sample 1000 events from pdf; std::unique_ptr<RooDataSet> data{p0.generate(x, 1000)};; ; // C a l c u l a t e w e i g h t a n d m a k e d a t a s e t w e i g h t e d; // -----------------------------------------------------------------------------------; ; // Construct formula to calculate (fake) weight for events; RooFormulaVar wFunc(""w"", ""event weight"", ""(x*x+10)"", x);; ; // Add column with variable w to previously generated dataset; RooRealVar *w = (RooRealVar *)data->addColumn(wFunc);; ; // Dataset d is now a dataset with two observable (x,w) with 1000 entries; data->Print();; ; // Instruct dataset wdata in interpret w as event weight rather than as observable; RooDataSet wdata(data->GetName(), data->GetTitle(), data.get(), *data->get(), 0, w->GetName());; ; // Dataset d is now a dataset with one observable (x) with 1000 entries and a sum of weights of ~430K; wdata.Print();; ; // U n b i n n e d M L f i t t o w e i g h t e d d a t a; // ---------------------------------------------------------------; ; // Construction quadra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf403__weightedevts_8C.html:105,Load,Loading,105,doc/master/rf403__weightedevts_8C.html,https://root.cern,https://root.cern/doc/master/rf403__weightedevts_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf403_weightedevts.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf403_weightedevts.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'DATA AND CATEGORIES' RooFit tutorial macro #403 ; Using weights in unbinned datasets. ; from __future__ import print_function; import ROOT; ; ; # Create observable and unweighted dataset; # -------------------------------------------; ; # Declare observable; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); x.setBins(40); ; # Construction a uniform pdf; p0 = ROOT.RooPolynomial(""px"", ""px"", x); ; # Sample 1000 events from pdf; data = p0.generate({x}, 1000); ; # Calculate weight and make dataset weighted; # --------------------------------------------------; ; # Construct formula to calculate (fake) weight for events; wFunc = ROOT.RooFormulaVar(""w"", ""event weight"", ""(x*x+10)"", [x]); ; # Add column with variable w to previously generated dataset; w = data.addColumn(wFunc); ; # Dataset d is now a dataset with two observable (x,w) with 1000 entries; data.Print(); ; # Instruct dataset wdata in interpret w as event weight rather than as; # observable; wdata = ROOT.RooDataSet(data.GetName(), data.GetTitle(), data, data.get(), """", w.GetName()); ; # Dataset d is now a dataset with one observable (x) with 1000 entries and; # a sum of weights of ~430K; wdata.Print(); ; # Unbinned ML fit to weighted data; # ---------------------------------------------------------------; ; # Construction quadratic polynomial pdf for fitting; a0 = ROOT.RooRealVar(""a0"", ""a0"", 1); a1 = ROOT.RooRealVar(""a1"", ""a1"", 0, -1, 1); a2 = ROOT.RooRealVar(""a2"", ""a2"", 1, 0, 10); p2 = ROOT.RooPolynomial(""p2"", ""p2"", x, [a0, a1, a2], 0); ; # Fit quadratic polynomial to weighted data; ; # NOTE: A plain Maximum likelihood fit to weighted data does in general; # NOT result in correct error estimates, individual; # event weights represent Poisson statistics themselves.; #; # Fit with 'wr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf403__weightedevts_8py.html:106,Load,Loading,106,doc/master/rf403__weightedevts_8py.html,https://root.cern,https://root.cern/doc/master/rf403__weightedevts_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf404_categories.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf404_categories.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Data and categories: working with RooCategory objects to describe discrete variables ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooPolynomial.h""; #include ""RooCategory.h""; #include ""Roo1DTable.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include <iostream>; using namespace RooFit;; ; void rf404_categories(); {; ; // C o n s t r u c t a c a t e g o r y w i t h l a b e l s; // ----------------------------------------------------------------; ; // Define a category with labels only; RooCategory tagCat(""tagCat"", ""Tagging category"");; tagCat.defineType(""Lepton"");; tagCat.defineType(""Kaon"");; tagCat.defineType(""NetTagger-1"");; tagCat.defineType(""NetTagger-2"");; tagCat.Print();; ; // C o n s t r u c t a c a t e g o r y w i t h l a b e l s a n d i n d i c e s; // ----------------------------------------------------------------------------------------; ; // Define a category with explicitly numbered states; RooCategory b0flav(""b0flav"", ""B0 flavour eigenstate"");; b0flav[""B0""] = -1;; b0flav[""B0bar""] = 1;; // Print it in ""verbose"" mode to see all states.; b0flav.Print(""V"");; ; ; // Alternatively, define many states at once. The function takes; // a map with std::string --> index mapping.; RooCategory largeCat(""largeCat"", ""A category with many states"");; largeCat.defineTypes({; {""A"", 0}, {""b"", 2}, {""c"", 8}, {""dee"", 4},; {""F"", 133}, {""g"", 15}, {""H"", -20}; });; ; ; // I t e r a t e, q u e r y a n d s e t s t a t e s; // --------------------------------------------------------; ; // One can iterate through the {index,name} pair of category objects; std::cout << ""\nThis is the for loop over states of 'largeCat':"";; for (const auto& idxAndName : largeCat); std::cout << ""\n\t"" << idxAndName.fir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf404__categories_8C.html:103,Load,Loading,103,doc/master/rf404__categories_8C.html,https://root.cern,https://root.cern/doc/master/rf404__categories_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf404_categories.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf404_categories.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Data and categories: working with ROOT.RooCategory objects to describe discrete variables ; ; from __future__ import print_function; import ROOT; ; ; # Construct a category with labels; # --------------------------------------------; ; # Define a category with labels only; tagCat = ROOT.RooCategory(""tagCat"", ""Tagging category""); tagCat.defineType(""Lepton""); tagCat.defineType(""Kaon""); tagCat.defineType(""NetTagger-1""); tagCat.defineType(""NetTagger-2""); tagCat.Print(); ; # Construct a category with labels and indices; # ------------------------------------------------; ; # Define a category with explicitly numbered states; b0flav = ROOT.RooCategory(""b0flav"", ""B0 flavour eigenstate"", {""B0"": -1, ""B0bar"": 1}); b0flav.Print(); ; # Generate dummy data for tabulation demo; # ------------------------------------------------; ; # Generate a dummy dataset; x = ROOT.RooRealVar(""x"", ""x"", 0, 10); data = ROOT.RooPolynomial(""p"", ""p"", x).generate({x, b0flav, tagCat}, 10000); ; # Print tables of category contents of datasets; # --------------------------------------------------; ; # Tables are equivalent of plots for categories; btable = data.table(b0flav); btable.Print(); btable.Print(""v""); ; # Create table for subset of events matching cut expression; ttable = data.table(tagCat, ""x>8.23""); ttable.Print(); ttable.Print(""v""); ; # Create table for all (tagCat x b0flav) state combinations; bttable = data.table({tagCat, b0flav}); bttable.Print(""v""); ; # Retrieve number of events from table; # Number can be non-integer if source dataset has weighed events; nb0 = btable.get(""B0""); print(""Number of events with B0 flavor is "", nb0); ; # Retrieve fraction of events with ""Lepton"" tag; fracLep = ttable.getFrac(""Lepton""); print(""Fraction of events tagged with ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf404__categories_8py.html:104,Load,Loading,104,doc/master/rf404__categories_8py.html,https://root.cern,https://root.cern/doc/master/rf404__categories_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf405_realtocatfuncs.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf405_realtocatfuncs.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Data and categories: demonstration of real-->discrete mapping functions . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooCategory.h""; #include ""RooThresholdCategory.h""; #include ""RooBinningCategory.h""; #include ""Roo1DTable.h""; #include ""RooArgusBG.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf405_realtocatfuncs(); {; ; // D e f i n e p d f i n x , s a m p l e d a t a s e t i n x; // ------------------------------------------------------------------------; ; // Define a dummy PDF in x; RooRealVar x(""x"", ""x"", 0, 10);; RooArgusBG a(""a"", ""argus(x)"", x, 10.0, -1.0);; ; // Generate a dummy dataset; std::unique_ptr<RooDataSet> data{a.generate(x, 10000)};; ; // C r e a t e a t h r e s h o l d r e a l - > c a t f u n c t i o n; // --------------------------------------------------------------------------; ; // A RooThresholdCategory is a category function that maps regions in a real-valued; // input observable observables to state names. At construction time a 'default'; // state name must be specified to which all values of x are mapped that are not; // otherwise assigned; RooThresholdCategory xRegion(""xRegion"", ""region of x"", x, ""Background"");; ; // Specify thresholds and state assignments one-by-one.; // Each statement specifies that all values _below_ the given value; // (and above any lower specified threshold) are mapped to the; // category state with the given name; //; // Background | SideBand | Signal | SideBand | Background; // 4.23 5.23 8.23 9.23; xRegion.addThreshold(4.23, ""Background"");; xRegion.addThreshold(5.23, ""SideBand"");; xRegion.addThreshold(8.23, ""Signal"");; xRegion.addThreshold(9.23, ""SideBand"");; ; // U s e t h r e s h o l d ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf405__realtocatfuncs_8C.html:107,Load,Loading,107,doc/master/rf405__realtocatfuncs_8C.html,https://root.cern,https://root.cern/doc/master/rf405__realtocatfuncs_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf405_realtocatfuncs.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf405_realtocatfuncs.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Data and categories: demonstration of real-discrete mapping functions . ; import ROOT; ; ; # Define pdf in x, sample dataset in x; # ------------------------------------------------------------------------; ; # Define a dummy PDF in x; x = ROOT.RooRealVar(""x"", ""x"", 0, 10); a = ROOT.RooArgusBG(""a"", ""argus(x)"", x, 10.0, -1.0); ; # Generate a dummy dataset; data = a.generate({x}, 10000); ; # Create a threshold real -> cat function; # --------------------------------------------------------------------------; ; # A RooThresholdCategory is a category function that maps regions in a real-valued; # input observable observables to state names. At construction time a 'default'; # state name must be specified to which all values of x are mapped that are not; # otherwise assigned; xRegion = ROOT.RooThresholdCategory(""xRegion"", ""region of x"", x, ""Background""); ; # Specify thresholds and state assignments one-by-one.; # Each statement specifies that all values _below_ the given value; # (and above any lower specified threshold) are mapped to the; # category state with the given name; #; # Background | SideBand | Signal | SideBand | Background; # 4.23 5.23 8.23 9.23; xRegion.addThreshold(4.23, ""Background""); xRegion.addThreshold(5.23, ""SideBand""); xRegion.addThreshold(8.23, ""Signal""); xRegion.addThreshold(9.23, ""SideBand""); ; # Use threshold function to plot data regions; # ----------------------------------------------; ; # Add values of threshold function to dataset so that it can be used as; # observable; data.addColumn(xRegion); ; # Make plot of data in x; xframe = x.frame(Title=""Demo of threshold and binning mapping functions""); data.plotOn(xframe); ; # Use calculated category to select sideband data; data.plotOn(xframe, Cut=""xRegi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf405__realtocatfuncs_8py.html:108,Load,Loading,108,doc/master/rf405__realtocatfuncs_8py.html,https://root.cern,https://root.cern/doc/master/rf405__realtocatfuncs_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf406_cattocatfuncs.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf406_cattocatfuncs.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Data and categories: demonstration of discrete-->discrete (invertible) functions ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooPolynomial.h""; #include ""RooCategory.h""; #include ""RooMappedCategory.h""; #include ""RooMultiCategory.h""; #include ""RooSuperCategory.h""; #include ""Roo1DTable.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf406_cattocatfuncs(); {; // C o n s t r u c t t w o c a t e g o r i e s; // ----------------------------------------------; ; // Define a category with labels only; RooCategory tagCat(""tagCat"", ""Tagging category"");; tagCat.defineType(""Lepton"");; tagCat.defineType(""Kaon"");; tagCat.defineType(""NetTagger-1"");; tagCat.defineType(""NetTagger-2"");; tagCat.Print();; ; // Define a category with explicitly numbered states; RooCategory b0flav(""b0flav"", ""B0 flavour eigenstate"");; b0flav.defineType(""B0"", -1);; b0flav.defineType(""B0bar"", 1);; b0flav.Print();; ; // Construct a dummy dataset with random values of tagCat and b0flav; RooRealVar x(""x"", ""x"", 0, 10);; RooPolynomial p(""p"", ""p"", x);; std::unique_ptr<RooDataSet> data{p.generate({x, b0flav, tagCat}, 10000)};; ; // C r e a t e a c a t - > c a t m a p p i n g c a t e g o r y; // ---------------------------------------------------------------------; ; // A RooMappedCategory is category->category mapping function based on string expression; // The constructor takes an input category an a default state name to which unassigned; // states are mapped; RooMappedCategory tcatType(""tcatType"", ""tagCat type"", tagCat, ""Cut based"");; ; // Enter fully specified state mappings; tcatType.map(""Lepton"", ""Cut based"");; tcatType.map(""Kaon"", ""Cut based"");; ; // Enter a wildcard expression mapping; tcatType.map(""NetTagger*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf406__cattocatfuncs_8C.html:106,Load,Loading,106,doc/master/rf406__cattocatfuncs_8C.html,https://root.cern,https://root.cern/doc/master/rf406__cattocatfuncs_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf406_cattocatfuncs.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf406_cattocatfuncs.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Data and categories: demonstration of discrete-discrete (invertable) functions ; ; import ROOT; ; ; # Construct two categories; # ----------------------------------------------; ; # Define a category with labels only; tagCat = ROOT.RooCategory(""tagCat"", ""Tagging category""); tagCat.defineType(""Lepton""); tagCat.defineType(""Kaon""); tagCat.defineType(""NetTagger-1""); tagCat.defineType(""NetTagger-2""); tagCat.Print(); ; # Define a category with explicitly numbered states; b0flav = ROOT.RooCategory(""b0flav"", ""B0 flavour eigenstate"", {""B0"": -1, ""B0bar"": 1}); b0flav.Print(); ; # Construct a dummy dataset with random values of tagCat and b0flav; x = ROOT.RooRealVar(""x"", ""x"", 0, 10); p = ROOT.RooPolynomial(""p"", ""p"", x); data = p.generate({x, b0flav, tagCat}, 10000); ; # Create a cat -> cat mapping category; # ---------------------------------------------------------------------; ; # A RooMappedCategory is category.category mapping function based on string expression; # The constructor takes an input category an a default state name to which unassigned; # states are mapped; tcatType = ROOT.RooMappedCategory(""tcatType"", ""tagCat type"", tagCat, ""Cut based""); ; # Enter fully specified state mappings; tcatType.map(""Lepton"", ""Cut based""); tcatType.map(""Kaon"", ""Cut based""); ; # Enter a wildcard expression mapping; tcatType.map(""NetTagger*"", ""Neural Network""); ; # Make a table of the mapped category state multiplicit in data; mtable = data.table(tcatType); mtable.Print(""v""); ; # Create a cat X cat product category; # ----------------------------------------------------------------------; ; # A SUPER-category is 'product' of _lvalue_ categories. The state names of a super; # category is a composite of the state labels of the input categories; b0X",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf406__cattocatfuncs_8py.html:107,Load,Loading,107,doc/master/rf406__cattocatfuncs_8py.html,https://root.cern,https://root.cern/doc/master/rf406__cattocatfuncs_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf407_latextables.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf407_latextables.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Data and categories: latex printing of lists and sets of RooArgSets ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooAddPdf.h""; #include ""RooExponential.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf407_latextables(); {; // S e t u p c o m p o s i t e p d f; // --------------------------------------; ; // Declare observable x; RooRealVar x(""x"", ""x"", 0, 10);; ; // Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and their parameters; RooRealVar mean(""mean"", ""mean of gaussians"", 5);; RooRealVar sigma1(""sigma1"", ""width of gaussians"", 0.5);; RooRealVar sigma2(""sigma2"", ""width of gaussians"", 1);; RooGaussian sig1(""sig1"", ""Signal component 1"", x, mean, sigma1);; RooGaussian sig2(""sig2"", ""Signal component 2"", x, mean, sigma2);; ; // Sum the signal components into a composite signal pdf; RooRealVar sig1frac(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0., 1.);; RooAddPdf sig(""sig"", ""Signal"", RooArgList(sig1, sig2), sig1frac);; ; // Build Chebychev polynomial pdf; RooRealVar a0(""a0"", ""a0"", 0.5, 0., 1.);; RooRealVar a1(""a1"", ""a1"", 0.2, 0., 1.);; RooChebychev bkg1(""bkg1"", ""Background 1"", x, RooArgSet(a0, a1));; ; // Build expontential pdf; RooRealVar alpha(""alpha"", ""alpha"", -1);; RooExponential bkg2(""bkg2"", ""Background 2"", x, alpha);; ; // Sum the background components into a composite background pdf; RooRealVar bkg1frac(""sig1frac"", ""fraction of component 1 in background"", 0.2, 0., 1.);; RooAddPdf bkg(""bkg"", ""Signal"", RooArgList(bkg1, bkg2), sig1frac);; ; // Sum the composite signal and background; RooRealVar bkgfrac(""bkgfrac"", ""fraction of background"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""g1+g2+a"", R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf407__latextables_8C.html:104,Load,Loading,104,doc/master/rf407__latextables_8C.html,https://root.cern,https://root.cern/doc/master/rf407__latextables_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf407_latextables.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf407_latextables.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Data and categories: latex printing of lists and sets of RooArgSets ; ; import ROOT; ; ; # Setup composite pdf; # --------------------------------------; ; # Declare observable x; x = ROOT.RooRealVar(""x"", ""x"", 0, 10); ; # Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and; # their parameters; mean = ROOT.RooRealVar(""mean"", ""mean of gaussians"", 5); sigma1 = ROOT.RooRealVar(""sigma1"", ""width of gaussians"", 0.5); sigma2 = ROOT.RooRealVar(""sigma2"", ""width of gaussians"", 1); sig1 = ROOT.RooGaussian(""sig1"", ""Signal component 1"", x, mean, sigma1); sig2 = ROOT.RooGaussian(""sig2"", ""Signal component 2"", x, mean, sigma2); ; # Sum the signal components into a composite signal pdf; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Build Chebychev polynomial pdf; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.2, 0.0, 1.0); bkg1 = ROOT.RooChebychev(""bkg1"", ""Background 1"", x, [a0, a1]); ; # Build expontential pdf; alpha = ROOT.RooRealVar(""alpha"", ""alpha"", -1); bkg2 = ROOT.RooExponential(""bkg2"", ""Background 2"", x, alpha); ; # Sum the background components into a composite background pdf; bkg1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in background"", 0.2, 0.0, 1.0); bkg = ROOT.RooAddPdf(""bkg"", ""Signal"", [bkg1, bkg2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Make list of parameters before and after fit; # ----------------------------------------------------------------------------------------; ; # Make l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf407__latextables_8py.html:105,Load,Loading,105,doc/master/rf407__latextables_8py.html,https://root.cern,https://root.cern/doc/master/rf407__latextables_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf408_RDataFrameToRooFit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf408_RDataFrameToRooFit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Fill RooDataSet/RooDataHist in RDataFrame. ; This tutorial shows how to fill RooFit data classes directly from RDataFrame. Using two small helpers, we tell RDataFrame where the data has to go.; ; #include <RooAbsDataHelper.h>; ; #include <TRandom.h>; ; /// Print the first few entries and summary statistics.; void printData(const RooAbsData& data) {; std::cout << ""\n"";; data.Print();; ; for (int i=0; i < data.numEntries() && i < 20; ++i) {; std::cout << ""("";; for (const auto var : *data.get(i)) {; std::cout << std::setprecision(3) << std::right << std::fixed << std::setw(8) << static_cast<const RooAbsReal*>(var)->getVal() << "", "";; }; std::cout << "")\tweight="" << std::setw(10) << data.weight() << std::endl;; }; ; // Get the x and y variables from the dataset:; const auto & x = static_cast<const RooRealVar&>(*(*data.get())[0]);; const auto & y = static_cast<const RooRealVar&>(*(*data.get())[1]);; ; std::cout << ""mean(x) = "" << data.mean(x) << ""\tsigma(x) = "" << std::sqrt(data.moment(x, 2.)); << ""\n"" << ""mean(y) = "" << data.mean(y) << ""\tsigma(y) = "" << std::sqrt(data.moment(y, 2.)) << std::endl;; }; ; void rf408_RDataFrameToRooFit(); {; // Set up; // ------------------------; ; // We create an RDataFrame with two columns filled with 2 million random numbers.; auto df = ROOT::RDataFrame{2000000}.Define(""x"", []() { return gRandom->Uniform(-5., 5.); }).Define(""y"", []() {; return gRandom->Gaus(1., 3.);; });; ; ; // We create RooFit variables that will represent the dataset.; RooRealVar x(""x"", ""x"", -5., 5.);; RooRealVar y(""y"", ""y"", -50., 50.);; x.setBins(10);; y.setBins(20);; ; ; ; // Booking the creation of RooDataSet / RooDataHist in RDataFrame; // ----------------------------------------------------------------; ; // Method 1:; // --",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf408__RDataFrameToRooFit_8C.html:111,Load,Loading,111,doc/master/rf408__RDataFrameToRooFit_8C.html,https://root.cern,https://root.cern/doc/master/rf408__RDataFrameToRooFit_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf408_RDataFrameToRooFit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf408_RDataFrameToRooFit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Fill RooDataSet/RooDataHist in RDataFrame. ; This tutorial shows how to fill RooFit data classes directly from RDataFrame. Using two small helpers, we tell RDataFrame where the data has to go.; ; import ROOT; import math; ; ; # Set up; # ------------------------; ; # We create an RDataFrame with two columns filled with 2 million random numbers.; df = ROOT.RDataFrame(2000000).Define(""x"", ""gRandom->Uniform(-5., 5.)"").Define(""y"", ""gRandom->Gaus(1., 3.)""); ; ; # We create RooFit variables that will represent the dataset.; x = ROOT.RooRealVar(""x"", ""x"", -5.0, 5.0); y = ROOT.RooRealVar(""y"", ""y"", -50.0, 50.0); x.setBins(10); y.setBins(20); ; ; # Booking the creation of RooDataSet / RooDataHist in RDataFrame; # ----------------------------------------------------------------; ; # Method 1:; # ---------; # We directly book the RooDataSetHelper action.; # We need to pass; # - the RDataFrame column types as template parameters; # - the constructor arguments for RooDataSet (they follow the same syntax as the usual RooDataSet constructors); # - the column names that RDataFrame should fill into the dataset; ; # NOTE: RDataFrame columns are matched to RooFit variables by position, *not by name*!; #; # The returned object is not yet a RooDataSet, but an RResultPtr that will be; # lazy-evaluated once you call GetValue() on it. We will only evaluate the; # RResultPtr once all other RDataFrame related actions are declared. This way; # we trigger the event loop computation only once, which will improve the; # runtime significantly.; #; # To learn more about lazy actions, see:; # https://root.cern/doc/master/classROOT_1_1RDataFrame.html#actions; roo_data_set_result = df.Book(; ROOT.std.move(ROOT.RooDataSetHelper(""dataset"", ""Title of dat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf408__RDataFrameToRooFit_8py.html:112,Load,Loading,112,doc/master/rf408__RDataFrameToRooFit_8py.html,https://root.cern,https://root.cern/doc/master/rf408__RDataFrameToRooFit_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf409_NumPyPandasToRooFit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf409_NumPyPandasToRooFit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Convert between NumPy arrays or Pandas DataFrames and RooDataSets. ; This tutorials first how to export a RooDataSet to NumPy arrays or a Pandas DataFrame, and then it shows you how to create a RooDataSet from a Pandas DataFrame.; ; import ROOT; ; import numpy as np; ; ; # The number of events that we use for the datasets created in this tutorial.; n_events = 10000; ; ; # Creating a RooDataSet and exporting it to the Python ecosystem; # --------------------------------------------------------------; ; # Define the observable.; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); ; # Define a Gaussian model with its parameters.; mean = ROOT.RooRealVar(""mean"", ""mean of gaussian"", 1, -10, 10); sigma = ROOT.RooRealVar(""sigma"", ""width of gaussian"", 1, 0.1, 10); gauss = ROOT.RooGaussian(""gauss"", ""gaussian PDF"", x, mean, sigma); ; # Create a RooDataSet.; data = gauss.generate(ROOT.RooArgSet(x), 10000); ; # Use RooDataSet.to_numpy() to export dataset to a dictionary of NumPy arrays.; # Real values will be of type `double`, categorical values of type `int`.; arrays = data.to_numpy(); ; # We can verify that the mean and standard deviation matches our model specification.; print(""Mean of numpy array:"", np.mean(arrays[""x""])); print(""Standard deviation of numpy array:"", np.std(arrays[""x""])); ; # It is also possible to create a Pandas DataFrame directly from the numpy arrays:; df = data.to_pandas(); ; # Now you can use the DataFrame e.g. for plotting. You can even combine this; # with the RooAbsReal.bins PyROOT function, which returns the binning from; # RooFit as a numpy array!; try:; import matplotlib.pyplot as plt; ; df.hist(column=""x"", bins=x.bins()); except Exception:; print(; 'Skipping `df.hist(column=""x"", bins=x.bins())` because mat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf409__NumPyPandasToRooFit_8py.html:113,Load,Loading,113,doc/master/rf409__NumPyPandasToRooFit_8py.html,https://root.cern,https://root.cern/doc/master/rf409__NumPyPandasToRooFit_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf501_simultaneouspdf.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf501_simultaneouspdf.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organisation and simultaneous fits: using simultaneous pdfs to describe simultaneous fits to multiple datasets . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooAddPdf.h""; #include ""RooSimultaneous.h""; #include ""RooCategory.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf501_simultaneouspdf(); {; // C r e a t e m o d e l f o r p h y s i c s s a m p l e; // -------------------------------------------------------------; ; // Create observables; RooRealVar x(""x"", ""x"", -8, 8);; ; // Construct signal pdf; RooRealVar mean(""mean"", ""mean"", 0, -8, 8);; RooRealVar sigma(""sigma"", ""sigma"", 0.3, 0.1, 10);; RooGaussian gx(""gx"", ""gx"", x, mean, sigma);; ; // Construct background pdf; RooRealVar a0(""a0"", ""a0"", -0.1, -1, 1);; RooRealVar a1(""a1"", ""a1"", 0.004, -1, 1);; RooChebychev px(""px"", ""px"", x, RooArgSet(a0, a1));; ; // Construct composite pdf; RooRealVar f(""f"", ""f"", 0.2, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgList(gx, px), f);; ; // C r e a t e m o d e l f o r c o n t r o l s a m p l e; // --------------------------------------------------------------; ; // Construct signal pdf.; // NOTE that sigma is shared with the signal sample model; RooRealVar mean_ctl(""mean_ctl"", ""mean_ctl"", -3, -8, 8);; RooGaussian gx_ctl(""gx_ctl"", ""gx_ctl"", x, mean_ctl, sigma);; ; // Construct the background pdf; RooRealVar a0_ctl(""a0_ctl"", ""a0_ctl"", -0.1, -1, 1);; RooRealVar a1_ctl(""a1_ctl"", ""a1_ctl"", 0.5, -0.1, 1);; RooChebychev px_ctl(""px_ctl"", ""px_ctl"", x, RooArgSet(a0_ctl, a1_ctl));; ; // Construct the composite model; RooRealVar f_ctl(""f_ctl"", ""f_ctl"", 0.5, 0., 1.);; RooAddPdf model_ctl(""model_ctl"", ""model_ctl"", RooArgList(gx_ctl, px_ct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf501__simultaneouspdf_8C.html:108,Load,Loading,108,doc/master/rf501__simultaneouspdf_8C.html,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf501_simultaneouspdf.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf501_simultaneouspdf.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: using simultaneous pdfs to describe simultaneous fits to multiple datasets . ; import ROOT; ; ; # Create model for physics sample; # -------------------------------------------------------------; ; # Create observables; x = ROOT.RooRealVar(""x"", ""x"", -8, 8); ; # Construct signal pdf; mean = ROOT.RooRealVar(""mean"", ""mean"", 0, -8, 8); sigma = ROOT.RooRealVar(""sigma"", ""sigma"", 0.3, 0.1, 10); gx = ROOT.RooGaussian(""gx"", ""gx"", x, mean, sigma); ; # Construct background pdf; a0 = ROOT.RooRealVar(""a0"", ""a0"", -0.1, -1, 1); a1 = ROOT.RooRealVar(""a1"", ""a1"", 0.004, -1, 1); px = ROOT.RooChebychev(""px"", ""px"", x, [a0, a1]); ; # Construct composite pdf; f = ROOT.RooRealVar(""f"", ""f"", 0.2, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gx, px], [f]); ; # Create model for control sample; # --------------------------------------------------------------; ; # Construct signal pdf.; # NOTE that sigma is shared with the signal sample model; mean_ctl = ROOT.RooRealVar(""mean_ctl"", ""mean_ctl"", -3, -8, 8); gx_ctl = ROOT.RooGaussian(""gx_ctl"", ""gx_ctl"", x, mean_ctl, sigma); ; # Construct the background pdf; a0_ctl = ROOT.RooRealVar(""a0_ctl"", ""a0_ctl"", -0.1, -1, 1); a1_ctl = ROOT.RooRealVar(""a1_ctl"", ""a1_ctl"", 0.5, -0.1, 1); px_ctl = ROOT.RooChebychev(""px_ctl"", ""px_ctl"", x, [a0_ctl, a1_ctl]); ; # Construct the composite model; f_ctl = ROOT.RooRealVar(""f_ctl"", ""f_ctl"", 0.5, 0.0, 1.0); model_ctl = ROOT.RooAddPdf(""model_ctl"", ""model_ctl"", [gx_ctl, px_ctl], [f_ctl]); ; # Generate events for both samples; # ---------------------------------------------------------------; ; # Generate 1000 events in x and y from model; data = model.generate({x}, 1000); data_ctl = model_ctl.generate({x}, 2000); ; # Create index catego",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf501__simultaneouspdf_8py.html:109,Load,Loading,109,doc/master/rf501__simultaneouspdf_8py.html,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf502_wspacewrite.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf502_wspacewrite.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organisation and simultaneous fits: creating and writing a workspace ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooAddPdf.h""; #include ""RooWorkspace.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TFile.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf502_wspacewrite(); {; // C r e a t e m o d e l a n d d a t a s e t; // -----------------------------------------------; ; // Declare observable x; RooRealVar x(""x"", ""x"", 0, 10);; ; // Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and their parameters; RooRealVar mean(""mean"", ""mean of gaussians"", 5, 0, 10);; RooRealVar sigma1(""sigma1"", ""width of gaussians"", 0.5);; RooRealVar sigma2(""sigma2"", ""width of gaussians"", 1);; ; RooGaussian sig1(""sig1"", ""Signal component 1"", x, mean, sigma1);; RooGaussian sig2(""sig2"", ""Signal component 2"", x, mean, sigma2);; ; // Build Chebychev polynomial pdf; RooRealVar a0(""a0"", ""a0"", 0.5, 0., 1.);; RooRealVar a1(""a1"", ""a1"", 0.2, 0, 1.);; RooChebychev bkg(""bkg"", ""Background"", x, RooArgSet(a0, a1));; ; // Sum the signal components into a composite signal pdf; RooRealVar sig1frac(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0., 1.);; RooAddPdf sig(""sig"", ""Signal"", RooArgList(sig1, sig2), sig1frac);; ; // Sum the composite signal and background; RooRealVar bkgfrac(""bkgfrac"", ""fraction of background"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), bkgfrac);; ; // Generate a data sample of 1000 events in x from model; std::unique_ptr<RooDataSet> data{model.generate(x, 1000)};; ; // C r e a t e w o r k s p a c e , i m p o r t d a t a a n d m o d e l; // --------------------------------------------------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf502__wspacewrite_8C.html:104,Load,Loading,104,doc/master/rf502__wspacewrite_8C.html,https://root.cern,https://root.cern/doc/master/rf502__wspacewrite_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf502_wspacewrite.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf502_wspacewrite.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: creating and writing a workspace ; ; import ROOT; ; ; # Create model and dataset; # -----------------------------------------------; ; # Declare observable x; x = ROOT.RooRealVar(""x"", ""x"", 0, 10); ; # Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and; # their parameters; mean = ROOT.RooRealVar(""mean"", ""mean of gaussians"", 5, 0, 10); sigma1 = ROOT.RooRealVar(""sigma1"", ""width of gaussians"", 0.5); sigma2 = ROOT.RooRealVar(""sigma2"", ""width of gaussians"", 1); ; sig1 = ROOT.RooGaussian(""sig1"", ""Signal component 1"", x, mean, sigma1); sig2 = ROOT.RooGaussian(""sig2"", ""Signal component 2"", x, mean, sigma2); ; # Build Chebychev polynomial pdf; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.2, 0.0, 1.0); bkg = ROOT.RooChebychev(""bkg"", ""Background"", x, [a0, a1]); ; # Sum the signal components into a composite signal pdf; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Generate a data sample of 1000 events in x from model; data = model.generate({x}, 1000); ; # Create workspace, import data and model; # -----------------------------------------------------------------------------; ; # Create a empty workspace; w = ROOT.RooWorkspace(""w"", ""workspace""); ; # Import model and all its components into the workspace; w.Import(model); ; # Import data into the workspace; w.Import(data); ; # Print workspace contents; w.Print(); ; # Save workspace in file; # -------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf502__wspacewrite_8py.html:105,Load,Loading,105,doc/master/rf502__wspacewrite_8py.html,https://root.cern,https://root.cern/doc/master/rf502__wspacewrite_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf503_wspaceread.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf503_wspaceread.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organisation and simultaneous fits: reading and using a workspace ; The input file for this macro is generated by rf502_wspacewrite.C. ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooAddPdf.h""; #include ""RooWorkspace.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TFile.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf503_wspaceread(); {; // R e a d w o r k s p a c e f r o m f i l e; // -----------------------------------------------; ; // Open input file with workspace (generated by rf503_wspacewrite); TFile *f = new TFile(""rf502_workspace.root"");; ; // Retrieve workspace from file; RooWorkspace *w = (RooWorkspace *)f->Get(""w"");; ; // R e t r i e v e p d f , d a t a f r o m w o r k s p a c e; // -----------------------------------------------------------------; ; // Retrieve x,model and data from workspace; RooRealVar *x = w->var(""x"");; RooAbsPdf *model = w->pdf(""model"");; RooAbsData *data = w->data(""modelData"");; ; // Print structure of composite pdf; model->Print(""t"");; ; // F i t m o d e l t o d a t a , p l o t m o d e l; // ---------------------------------------------------------; ; // Fit model to data; model->fitTo(*data, PrintLevel(-1));; ; // Plot data and PDF overlaid; RooPlot *xframe = x->frame(Title(""Model and data read from workspace""));; data->plotOn(xframe);; model->plotOn(xframe);; ; // Overlay the background component of model with a dashed line; model->plotOn(xframe, Components(""bkg""), LineStyle(kDashed));; ; // Overlay the background+sig2 components of model with a dotted line; model->plotOn(xframe, Components(""bkg,sig2""), LineStyle(kDotted));; ; // Draw the frame on the canvas; new TCanvas(""rf503_wspaceread"", ""rf503_wsp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf503__wspaceread_8C.html:103,Load,Loading,103,doc/master/rf503__wspaceread_8C.html,https://root.cern,https://root.cern/doc/master/rf503__wspaceread_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf503_wspaceread.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf503_wspaceread.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'ORGANIZATION AND SIMULTANEOUS FITS' RooFit tutorial macro #503 ; Reading and using a workspace; The input file for self macro is generated by rf502_wspaceread.py. ; import ROOT; ; ; # Read workspace from file; # -----------------------------------------------; ; # Open input file with workspace (generated by rf503_wspacewrite); f = ROOT.TFile(""rf502_workspace_py.root""); ; # Retrieve workspace from file; w = f.Get(""w""); ; # Retrieve pdf, data from workspace; # -----------------------------------------------------------------; ; # Retrieve x, and data from workspace; x = w[""x""]; model = w[""model""]; data = w[""modelData""]; ; # Print structure of composite p.d.f.; model.Print(""t""); ; # Fit model to data, plot model; # ---------------------------------------------------------; ; # Fit model to data; model.fitTo(data, PrintLevel=-1); ; # Plot data and PDF overlaid; xframe = x.frame(Title=""Model and data read from workspace""); data.plotOn(xframe); model.plotOn(xframe); ; # Overlay the background component of model with a dashed line; model.plotOn(xframe, Components=""bkg"", LineStyle=""--""); ; # Overlay the background+sig2 components of model with a dotted line; model.plotOn(xframe, Components=""bkg,sig2"", LineStyle="":""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf503_wspaceread"", ""rf503_wspaceread"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); ; c.SaveAs(""rf503_wspaceread.png""); 0x8fdb600 RooAddPdf::model = 1/1 [Auto,Clean] ; 0x91994b0/V- RooChebychev::bkg = 1 [Auto,Dirty] ; 0x880af10/V- RooRealVar::x = 5; 0x27be9c0/V- RooRealVar::a0 = 0.5; 0x2765460/V- RooRealVar::a1 = 0; 0x9279200/V- RooRealVar::bkgfrac = 0.5; 0x926e430/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x91f8100/V- RooGau",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf503__wspaceread_8py.html:104,Load,Loading,104,doc/master/rf503__wspaceread_8py.html,https://root.cern,https://root.cern/doc/master/rf503__wspaceread_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf504_simwstool.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf504_simwstool.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organisation and simultaneous fits: using RooSimWSTool to construct a simultaneous pdf that is built of variations of an input pdf ; ; #include ""RooRealVar.h""; #include ""RooCategory.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooSimultaneous.h""; #include ""RooAddPdf.h""; #include ""RooWorkspace.h""; #include ""RooSimWSTool.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TFile.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf504_simwstool(); {; // C r e a t e m a s t e r p d f; // ---------------------------------; ; // Construct gauss(x,m,s); RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar m(""m"", ""m"", 0, -10, 10);; RooRealVar s(""s"", ""s"", 1, -10, 10);; RooGaussian gauss(""g"", ""g"", x, m, s);; ; // Construct poly(x,p0); RooRealVar p0(""p0"", ""p0"", 0.01, 0., 1.);; RooPolynomial poly(""p"", ""p"", x, p0);; ; // Construct model = f*gauss(x) + (1-f)*poly(x); RooRealVar f(""f"", ""f"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgSet(gauss, poly), f);; ; // C r e a t e c a t e g o r y o b s e r v a b l e s f o r s p l i t t i n g; // ----------------------------------------------------------------------------------; ; // Define two categories that can be used for splitting; RooCategory c(""c"", ""c"");; c.defineType(""run1"");; c.defineType(""run2"");; ; RooCategory d(""d"", ""d"");; d.defineType(""foo"");; d.defineType(""bar"");; ; // S e t u p S i m W S T o o l; // -----------------------------; ; // Import ingredients in a workspace; RooWorkspace w(""w"", ""w"");; w.import(RooArgSet(model, c, d));; ; // Make Sim builder tool; RooSimWSTool sct(w);; ; // B u i l d a s i m u l t a n e o u s m o d e l w i t h o n e s p l i t; // ------------------------------------------------------------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf504__simwstool_8C.html:102,Load,Loading,102,doc/master/rf504__simwstool_8C.html,https://root.cern,https://root.cern/doc/master/rf504__simwstool_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf504_simwstool.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf504_simwstool.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: using RooSimWSTool to construct a simultaneous pdf that is built of variations of an input pdf ; ; import ROOT; ; ; # Create master pdf; # ---------------------------------; ; # Construct gauss(x,m,s); x = ROOT.RooRealVar(""x"", ""x"", -10, 10); m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 1, -10, 10); gauss = ROOT.RooGaussian(""g"", ""g"", x, m, s); ; # Construct poly(x,p0); p0 = ROOT.RooRealVar(""p0"", ""p0"", 0.01, 0.0, 1.0); poly = ROOT.RooPolynomial(""p"", ""p"", x, [p0]); ; # model = f*gauss(x) + (1-f)*poly(x); f = ROOT.RooRealVar(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; # Create category observables for splitting; # ----------------------------------------------------------------------------------; ; # Define two categories that can be used for splitting; c = ROOT.RooCategory(""c"", ""c""); c.defineType(""run1""); c.defineType(""run2""); ; d = ROOT.RooCategory(""d"", ""d""); d.defineType(""foo""); d.defineType(""bar""); ; # Set up SimWSTool; # -----------------------------; ; # Import ingredients in a workspace; w = ROOT.RooWorkspace(""w"", ""w""); w.Import({model, c, d}); ; # Make Sim builder tool; sct = ROOT.RooSimWSTool(w); ; # Build a simultaneous model with one split; # ---------------------------------------------------------------------------------; ; # Construct a simultaneous pdf with the following form; #; # model_run1(x) = f*gauss_run1(x,m_run1,s) + (1-f)*poly; # model_run2(x) = f*gauss_run2(x,m_run2,s) + (1-f)*poly; # simpdf(x,c) = model_run1(x) if c==""run1""; # = model_run2(x) if c==""run2""; #; # Returned pdf is owned by the workspace; model_sim = sct.build(""model_sim"", ""model"", SplitParam=(""m"", ""c"")); ; # Print tree structure of model; mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf504__simwstool_8py.html:103,Load,Loading,103,doc/master/rf504__simwstool_8py.html,https://root.cern,https://root.cern/doc/master/rf504__simwstool_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf505_asciicfg.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf505_asciicfg.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organisation and simultaneous fits: reading and writing ASCII configuration files ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooAddPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf505_asciicfg(); {; // C r e a t e p d f; // ------------------; ; // Construct gauss(x,m,s); RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar m(""m"", ""m"", 0, -10, 10);; RooRealVar s(""s"", ""s"", 1, -10, 10);; RooGaussian gauss(""g"", ""g"", x, m, s);; ; // Construct poly(x,p0); RooRealVar p0(""p0"", ""p0"", 0.01, 0., 1.);; RooPolynomial poly(""p"", ""p"", x, p0);; ; // Construct model = f*gauss(x) + (1-f)*poly(x); RooRealVar f(""f"", ""f"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgSet(gauss, poly), f);; ; // F i t m o d e l t o t o y d a t a; // -----------------------------------------; ; std::unique_ptr<RooDataSet> d{model.generate(x, 1000)};; model.fitTo(*d, PrintLevel(-1));; ; // W r i t e p a r a m e t e r s t o a s c i i f i l e; // -----------------------------------------------------------; ; // Obtain set of parameters; std::unique_ptr<RooArgSet> params{model.getParameters(x)};; ; // Write parameters to file; params->writeToFile(""rf505_asciicfg_example.txt"");; ; TString dir1 = gROOT->GetTutorialDir() ;; dir1.Append(""/roofit/rf505_asciicfg.txt"") ;; TString dir2 = ""rf505_asciicfg_example.txt"";; ; // R e a d p a r a m e t e r s f r o m a s c i i f i l e; // ----------------------------------------------------------------; ; // Read parameters from file; params->readFromFile(dir2);; params->Print(""v"");; ; // Read parameters from section 'Section2' of file; params->readFromFile(dir1, 0, ""Section2"");; params->Print(""v"");; ; // Read parameters from se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf505__asciicfg_8C.html:101,Load,Loading,101,doc/master/rf505__asciicfg_8C.html,https://root.cern,https://root.cern/doc/master/rf505__asciicfg_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf505_asciicfg.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf505_asciicfg.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: reading and writing ASCII configuration files ; ; from __future__ import print_function; import ROOT; ; ; # Create pdf; # ------------------; ; # Construct gauss(x,m,s); x = ROOT.RooRealVar(""x"", ""x"", -10, 10); m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 1, -10, 10); gauss = ROOT.RooGaussian(""g"", ""g"", x, m, s); ; # Construct poly(x,p0); p0 = ROOT.RooRealVar(""p0"", ""p0"", 0.01, 0.0, 1.0); poly = ROOT.RooPolynomial(""p"", ""p"", x, [p0]); ; # model = f*gauss(x) + (1-f)*poly(x); f = ROOT.RooRealVar(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; # Fit model to toy data; # -----------------------------------------; ; d = model.generate({x}, 1000); model.fitTo(d, PrintLevel=-1); ; # Write parameters to ASCII file; # -----------------------------------------------------------; ; # Obtain set of parameters; params = model.getParameters({x}); ; # Write parameters to file; params.writeToFile(""rf505_asciicfg_example.txt""); ; # Read parameters from ASCII file; # ----------------------------------------------------------------; ; # Read parameters from file; params.readFromFile(""rf505_asciicfg_example.txt""); params.Print(""v""); ; configFile = ROOT.gROOT.GetTutorialDir().Data() + ""/roofit/rf505_asciicfg.txt""; ; # Read parameters from section 'Section2' of file; params.readFromFile(configFile, """", ""Section2""); params.Print(""v""); ; # Read parameters from section 'Section3' of file. Mark all; # variables that were processed with the ""READ"" attribute; params.readFromFile(configFile, ""READ"", ""Section3""); ; # Print the list of parameters that were not read from Section3; print(""The following parameters of the were _not_ read from Section3: "", params.select",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf505__asciicfg_8py.html:102,Load,Loading,102,doc/master/rf505__asciicfg_8py.html,https://root.cern,https://root.cern/doc/master/rf505__asciicfg_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf506_msgservice.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf506_msgservice.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organisation and simultaneous fits: tuning and customizing the RooFit message logging facility ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooAddPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooMsgService.h""; ; using namespace RooFit;; ; void rf506_msgservice(); {; // C r e a t e p d f; // --------------------; ; // Construct gauss(x,m,s); RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar m(""m"", ""m"", 0, -10, 10);; RooRealVar s(""s"", ""s"", 1, -10, 10);; RooGaussian gauss(""g"", ""g"", x, m, s);; ; // Construct poly(x,p0); RooRealVar p0(""p0"", ""p0"", 0.01, 0., 1.);; RooPolynomial poly(""p"", ""p"", x, p0);; ; // Construct model = f*gauss(x) + (1-f)*poly(x); RooRealVar f(""f"", ""f"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgSet(gauss, poly), f);; ; std::unique_ptr<RooDataSet> data{model.generate(x, 10)};; ; // P r i n t c o n f i g u r a t i o n o f m e s s a g e s e r v i c e; // ---------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // A d d i n g I n t e g r a t i o n t o p i c t o e x i s t i n g I N F O s t r e a m; // -----------------------------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // Add Integration topic to existing INFO stream; RooMsgService::instance().getStream(1).addTopic(Integration);; ; // Construct integral over gauss to demonstrate new message stream; std::unique_ptr<RooAbsReal> igauss{gauss.createIntegral(x)};; igauss->Print();; ; // Print streams configuration in verbose, which also shows inactive streams",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf506__msgservice_8C.html:103,Load,Loading,103,doc/master/rf506__msgservice_8C.html,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf506_msgservice.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf506_msgservice.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: tuning and customizing the ROOT.RooFit message logging facility ; ; import ROOT; ; # Create pdf; # --------------------; ; # Construct gauss(x,m,s); x = ROOT.RooRealVar(""x"", ""x"", -10, 10); m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 1, -10, 10); gauss = ROOT.RooGaussian(""g"", ""g"", x, m, s); ; # Construct poly(x,p0); p0 = ROOT.RooRealVar(""p0"", ""p0"", 0.01, 0.0, 1.0); poly = ROOT.RooPolynomial(""p"", ""p"", x, [p0]); ; # model = f*gauss(x) + (1-f)*poly(x); f = ROOT.RooRealVar(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; data = model.generate({x}, 10); ; # Print configuration of message service; # ------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Adding integration topic to existing INFO stream; # ---------------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf506__msgservice_8py.html:104,Load,Loading,104,doc/master/rf506__msgservice_8py.html,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf508_listsetmanip.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf508_listsetmanip.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: RooArgSet and RooArgList tools and tricks ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooArgSet.h""; #include ""RooArgList.h""; #include ""RooCategory.h""; using namespace RooFit;; ; void rf508_listsetmanip(); {; ; // C r e a t e d u m m y o b j e c t s; // ---------------------------------------; ; // Create some variables; RooRealVar a(""a"", ""a"", 1, -10, 10);; RooRealVar b(""b"", ""b"", 2, -10, 10);; RooRealVar c(""c"", ""c"", 3, -10, 10);; RooRealVar d(""d"", ""d"", 4, -10, 10);; RooRealVar x(""x"", ""x"", 0, -10, 10);; c.setError(0.5);; a.setConstant();; b.setConstant();; ; // Create a category; RooCategory e(""e"", ""e"");; e.defineType(""sig"");; e.defineType(""bkg"");; ; // Create a pdf; RooGaussian g(""g"", ""g"", x, a, b);; ; // C r e a t i n g , f i l l i n g R o o A r g S e t s; // -------------------------------------------------------; ; // A RooArgSet is a set of RooAbsArg objects. Each object in the set must have; // a unique name; ; // Set constructors exists with up to 9 initial arguments; RooArgSet s(a, b);; ; // At any time objects can be added with add(); s.add(e);; ; // Add up to 9 additional arguments in one call; s.add(RooArgSet(c, d));; ; // Sets can contain any type of RooAbsArg, also pdf and functions; s.add(g);; ; // Remove element d; s.remove(d);; ; // A c c e s s i n g R o o A r g S e t c o n t e n t s; // -------------------------------------------------------; ; // You can look up objects by name; RooAbsArg *aptr = s.find(""a"");; ; // Construct a subset by name; RooArgSet *subset1 = (RooArgSet *)s.selectByName(""a,b,c"");; ; // Construct asubset by attribute; RooArgSet *subset2 = (RooArgSet *)s.selectByA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf508__listsetmanip_8C.html:105,Load,Loading,105,doc/master/rf508__listsetmanip_8C.html,https://root.cern,https://root.cern/doc/master/rf508__listsetmanip_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf508_listsetmanip.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf508_listsetmanip.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'ORGANIZATION AND SIMULTANEOUS FITS' RooFit tutorial macro #508 ; RooArgSet and RooArgList tools and tricks; ; from __future__ import print_function; import ROOT; ; ; # Create dummy objects; # ---------------------------------------; ; # Create some variables; a = ROOT.RooRealVar(""a"", ""a"", 1, -10, 10); b = ROOT.RooRealVar(""b"", ""b"", 2, -10, 10); c = ROOT.RooRealVar(""c"", ""c"", 3, -10, 10); d = ROOT.RooRealVar(""d"", ""d"", 4, -10, 10); x = ROOT.RooRealVar(""x"", ""x"", 0, -10, 10); c.setError(0.5); a.setConstant(); b.setConstant(); ; # Create a category; e = ROOT.RooCategory(""e"", ""e""); e.defineType(""sig""); e.defineType(""bkg""); ; # Create a pdf; g = ROOT.RooGaussian(""g"", ""g"", x, a, b); ; # Creating, killing RooArgSets; # -------------------------------------------------------; ; # A ROOT.RooArgSet is a set of RooAbsArg objects. Each object in the set must have; # a unique name; ; # Set constructors exists with up to 9 initial arguments; s = ROOT.RooArgSet(a, b); ; # At any time objects can be added with add(); s.add(e); ; # Add up to 9 additional arguments in one call; # s.add(ROOT.RooArgSet(c, d)); s.add(c); s.add(d); ; # Sets can contain any type of RooAbsArg, pdf and functions; s.add(g); ; # Remove element d; s.remove(d); ; # Accessing RooArgSet contents; # -------------------------------------------------------; ; # You can look up objects by name; aptr = s.find(""a""); ; # Construct a subset by name; subset1 = s.selectByName(""a,b,c""); ; # Construct asubset by attribute; subset2 = s.selectByAttrib(""Constant"", ROOT.kTRUE); ; # Construct the subset of overlapping contents with another set; s1 = ROOT.RooArgSet(a, b, c); s2 = ROOT.RooArgSet(c, d, e); subset3 = s1.selectCommon(s2); ; # Owning RooArgSets; # ---------------------------------; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf508__listsetmanip_8py.html:106,Load,Loading,106,doc/master/rf508__listsetmanip_8py.html,https://root.cern,https://root.cern/doc/master/rf508__listsetmanip_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf509_wsinteractive.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf509_wsinteractive.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: easy interactive access to workspace contents - CINT to CLING code migration . ; using namespace RooFit;; ; void fillWorkspace(RooWorkspace &w);; ; void rf509_wsinteractive(); {; // C r e a t e a n d f i l l w o r k s p a c e; // ------------------------------------------------; ; // Create a workspace named 'w'; // With CINT w could exports its contents to; // a same-name C++ namespace in CINT 'namespace w'.; // but this does not work anymore in CLING.; // so this tutorial is an example on how to; // change the code; RooWorkspace *w1 = new RooWorkspace(""w"", true);; ; // Fill workspace with pdf and data in a separate function; fillWorkspace(*w1);; ; // Print workspace contents; w1->Print();; ; // this does not work anymore with CLING; // use normal workspace functionality; ; // U s e w o r k s p a c e c o n t e n t s; // ----------------------------------------------; ; // use normal workspace methods; RooAbsPdf *model = w1->pdf(""model"");; RooRealVar *x = w1->var(""x"");; ; std::unique_ptr<RooDataSet> d{ model->generate(*x, 1000)};; std::unique_ptr<RooFitResult> r{model->fitTo(*d, PrintLevel(-1))};; ; // old syntax to access the variable x; // RooPlot* frame = w::x.frame() ;; ; RooPlot *frame = x->frame();; d->plotOn(frame);; ; // OLD syntax to omit x::; // NB: The 'w::' prefix can be omitted if namespace w is imported in local namespace; // in the usual C++ way; //; // using namespace w;; // model.plotOn(frame) ;; // model.plotOn(frame,Components(bkg),LineStyle(kDashed)) ;; ; // new correct syntax; RooAbsPdf *bkg = w1->pdf(""bkg"");; model->plotOn(frame);; model->plotOn(frame, Components(*bkg), LineStyle(kDashed));; ; // Draw the frame on the canvas; new TCanvas(""rf509_wsinteractive"", ""rf509_wsinteractive"",",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf509__wsinteractive_8C.html:106,Load,Loading,106,doc/master/rf509__wsinteractive_8C.html,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf509_wsinteractive.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf509_wsinteractive.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: easy interactive access to workspace contents - CINT to CLING code migration . ; import ROOT; ; ; def fillWorkspace(w):; # Create pdf and fill workspace; # --------------------------------------------------------; ; # Declare observable x; x = ROOT.RooRealVar(""x"", ""x"", 0, 10); ; # Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and; # their parameters; mean = ROOT.RooRealVar(""mean"", ""mean of gaussians"", 5, 0, 10); sigma1 = ROOT.RooRealVar(""sigma1"", ""width of gaussians"", 0.5); sigma2 = ROOT.RooRealVar(""sigma2"", ""width of gaussians"", 1); ; sig1 = ROOT.RooGaussian(""sig1"", ""Signal component 1"", x, mean, sigma1); sig2 = ROOT.RooGaussian(""sig2"", ""Signal component 2"", x, mean, sigma2); ; # Build Chebychev polynomial pdf; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.2, 0.0, 1.0); bkg = ROOT.RooChebychev(""bkg"", ""Background"", x, [a0, a1]); ; # Sum the signal components into a composite signal pdf; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; w.Import(model); ; ; # Create and fill workspace; # ------------------------------------------------; ; ; # Create a workspace named 'w'; # With CINT w could exports its contents to; # a same-name C++ namespace in CINT 'namespace w'.; # but self does not work anymore in CLING.; # so self tutorial is an example on how to; # change the code; w = ROOT.RooWorkspace(""w"", True); ; # Fill workspace with pdf and da",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf509__wsinteractive_8py.html:107,Load,Loading,107,doc/master/rf509__wsinteractive_8py.html,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf510_wsnamedsets.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf510_wsnamedsets.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: working with named parameter sets and parameter snapshots in workspaces . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooAddPdf.h""; #include ""RooWorkspace.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TFile.h""; #include ""TH1.h""; ; using namespace RooFit;; ; void fillWorkspace(RooWorkspace &w);; ; void rf510_wsnamedsets(); {; // C r e a t e m o d e l a n d d a t a s e t; // -----------------------------------------------; ; RooWorkspace *w = new RooWorkspace(""w"");; fillWorkspace(*w);; ; // Exploit convention encoded in named set ""parameters"" and ""observables""; // to use workspace contents w/o need for introspected; RooAbsPdf *model = w->pdf(""model"");; ; // Generate data from pdf in given observables; std::unique_ptr<RooDataSet> data{model->generate(*w->set(""observables""), 1000)};; ; // Fit model to data; model->fitTo(*data, PrintLevel(-1));; ; // Plot fitted model and data on frame of first (only) observable; RooPlot *frame = ((RooRealVar *)w->set(""observables"")->first())->frame();; data->plotOn(frame);; model->plotOn(frame);; ; // Overlay plot with model with reference parameters as stored in snapshots; w->loadSnapshot(""reference_fit"");; model->plotOn(frame, LineColor(kRed));; w->loadSnapshot(""reference_fit_bkgonly"");; model->plotOn(frame, LineColor(kRed), LineStyle(kDashed));; ; // Draw the frame on the canvas; new TCanvas(""rf510_wsnamedsets"", ""rf503_wsnamedsets"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; ; // Print workspace contents; w->Print();; ; // Workspace will remain in memory after macro finishes; gDirectory->Add(w);; }; ; void fillWorkspace(R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf510__wsnamedsets_8C.html:104,Load,Loading,104,doc/master/rf510__wsnamedsets_8C.html,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf510_wsnamedsets.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf510_wsnamedsets.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'ORGANIZATION AND SIMULTANEOUS FITS' RooFit tutorial macro #510 ; Working with named parameter sets and parameter snapshots in workspaces. ; ; import ROOT; ; ; def fillWorkspace(w):; # Create model; # -----------------------; ; # Declare observable x; x = ROOT.RooRealVar(""x"", ""x"", 0, 10); ; # Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and; # their parameters; mean = ROOT.RooRealVar(""mean"", ""mean of gaussians"", 5, 0, 10); sigma1 = ROOT.RooRealVar(""sigma1"", ""width of gaussians"", 0.5); sigma2 = ROOT.RooRealVar(""sigma2"", ""width of gaussians"", 1); ; sig1 = ROOT.RooGaussian(""sig1"", ""Signal component 1"", x, mean, sigma1); sig2 = ROOT.RooGaussian(""sig2"", ""Signal component 2"", x, mean, sigma2); ; # Build Chebychev polynomial p.d.f.; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.2, 0.0, 1.0); bkg = ROOT.RooChebychev(""bkg"", ""Background"", x, [a0, a1]); ; # Sum the signal components into a composite signal p.d.f.; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Import model into p.d.f.; w.Import(model); ; # Encode definition of parameters in workspace; # ---------------------------------------------------------------------------------------; ; # Define named sets ""parameters"" and ""observables"", list which variables should be considered; # parameters and observables by the users convention; #; # Variables appearing in sets _must_ live in the workspace already, the autoImport flag; # o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf510__wsnamedsets_8py.html:105,Load,Loading,105,doc/master/rf510__wsnamedsets_8py.html,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf511_wsfactory_basic.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf511_wsfactory_basic.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: basic use of the 'object factory' associated with a workspace to rapidly build pdfs functions and their parameter components ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooAddPdf.h""; #include ""RooWorkspace.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; using namespace RooFit;; ; void rf511_wsfactory_basic(bool compact = false); {; RooWorkspace *w = new RooWorkspace(""w"");; ; // C r e a t i n g a n d a d d i n g b a s i c p . d . f . s; // ----------------------------------------------------------------; ; // Remake example pdf of tutorial rs502_wspacewrite.C:; //; // Basic pdf construction: ClassName::ObjectName(constructor arguments); // Variable construction : VarName[x,xlo,xhi], VarName[xlo,xhi], VarName[x]; // P.d.f. addition : SUM::ObjectName(coef1*pdf1,...coefM*pdfM,pdfN); //; ; if (!compact) {; ; // Use object factory to build pdf of tutorial rs502_wspacewrite; w->factory(""Gaussian::sig1(x[-10,10],mean[5,0,10],0.5)"");; w->factory(""Gaussian::sig2(x,mean,1)"");; w->factory(""Chebychev::bkg(x,{a0[0.5,0.,1],a1[0.2,0.,1.]})"");; w->factory(""SUM::sig(sig1frac[0.8,0.,1.]*sig1,sig2)"");; w->factory(""SUM::model(bkgfrac[0.5,0.,1.]*bkg,sig)"");; ; } else {; ; // Use object factory to build pdf of tutorial rs502_wspacewrite but; // - Contracted to a single line recursive expression,; // - Omitting explicit names for components that are not referred to explicitly later; ; w->factory(""SUM::model(bkgfrac[0.5,0.,1.]*Chebychev::bkg(x[-10,10],{a0[0.5,0.,1],a1[0.2,0.,1.]}),""; ""SUM(sig1frac[0.8,0.,1.]*Gaussian(x,mean[5,0,10],0.5), Gaussian(x,mean,1)))"");; }; ; // A d v a n c e d p . d . f . c o n s t r u c t o r a r g u m e n ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf511__wsfactory__basic_8C.html:108,Load,Loading,108,doc/master/rf511__wsfactory__basic_8C.html,https://root.cern,https://root.cern/doc/master/rf511__wsfactory__basic_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf511_wsfactory_basic.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf511_wsfactory_basic.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: basic use of the 'object factory' associated with a workspace to rapidly build pdfs functions and their parameter components ; ; import ROOT; ; ; compact = False; w = ROOT.RooWorkspace(""w""); ; # Creating and adding basic pdfs; # ----------------------------------------------------------------; ; # Remake example pdf of tutorial rs502_wspacewrite.C:; #; # Basic pdf construction: ClassName.ObjectName(constructor arguments); # Variable construction : VarName[x,xlo,xhi], VarName[xlo,xhi], VarName[x]; # P.d.f. addition : SUM.ObjectName(coef1*pdf1,...coefM*pdfM,pdfN); #; ; if not compact:; # Use object factory to build pdf of tutorial rs502_wspacewrite; w.factory(""Gaussian::sig1(x[-10,10],mean[5,0,10],0.5)""); w.factory(""Gaussian::sig2(x,mean,1)""); w.factory(""Chebychev::bkg(x,{a0[0.5,0.,1],a1[-0.2,0.,1.]})""); w.factory(""SUM::sig(sig1frac[0.8,0.,1.]*sig1,sig2)""); w.factory(""SUM::model(bkgfrac[0.5,0.,1.]*bkg,sig)""); ; else:; ; # Use object factory to build pdf of tutorial rs502_wspacewrite but; # - Contracted to a single line recursive expression,; # - Omitting explicit names for components that are not referred to explicitly later; ; w.factory(; ""SUM::model(bkgfrac[0.5,0.,1.]*Chebychev::bkg(x[-10,10],{a0[0.5,0.,1],a1[-0.2,0.,1.]}), ""; ""SUM(sig1frac[0.8,0.,1.]*Gaussian(x,mean[5,0,10],0.5), Gaussian(x,mean,1)))""; ); ; # Advanced pdf constructor arguments; # ----------------------------------------------------------------; #; # P.d.f. constructor arguments may by any type of ROOT.RooAbsArg, also; #; # Double_t -. converted to ROOT.RooConst(...); # {a,b,c} -. converted to ROOT.RooArgSet() or ROOT.RooArgList() depending on required ctor arg; # dataset name -. converted to ROOT.RooAbsData reference ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf511__wsfactory__basic_8py.html:109,Load,Loading,109,doc/master/rf511__wsfactory__basic_8py.html,https://root.cern,https://root.cern/doc/master/rf511__wsfactory__basic_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf512_wsfactory_oper.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf512_wsfactory_oper.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: operator expressions and expression-based basic pdfs in the workspace factory syntax ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooAddPdf.h""; #include ""RooWorkspace.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; using namespace RooFit;; ; void rf512_wsfactory_oper(); {; RooWorkspace *w = new RooWorkspace(""w"");; ; // You can define typedefs for even shorter construction semantics; w->factory(""$Typedef(Gaussian,Gaus)"");; w->factory(""$Typedef(Chebychev,Cheby)"");; ; // O p e r a t o r p . d . f . e x a m p l e s; // ------------------------------------------------; ; // PDF addition is done with SUM (coef1*pdf1,pdf2); w->factory(""SUM::summodel( f[0,1]*Gaussian::gx(x[-10,10],m[0],1.0), Chebychev::ch(x,{0.1,0.2,-0.3}) )"");; ; // Extended PDF addition is done with SUM (yield1*pdf1,yield2*pdf2); w->factory(""SUM::extsummodel( Nsig[0,1000]*gx, Nbkg[0,1000]*ch )"");; ; // PDF multiplication is done with PROD ( pdf1, pdf2 ); w->factory(""PROD::gxz( gx, Gaussian::gz(z[-10,10],0,1) )"");; ; // Conditional pdf multiplication is done with PROD ( pdf1|obs, pdf2 ); w->factory(""Gaussian::gy( y[-10,10], x, 1.0 )"");; w->factory(""PROD::gxycond( gy|x, gx )"");; ; // Convolution (numeric/ fft) is done with NCONV/FCONV (obs,pdf1,pdf2); w->factory(""FCONV::lxg( x, Gaussian::g(x,mg[0],1), Landau::lc(x,0,1) )"");; ; // Simultaneous pdfs are constructed with SIMUL( index, state1=pdf1, state2=pdf2,...); w->factory(""SIMUL::smodel( c[A=0,B=1], A=Gaussian::gs(x,m,s[1.0, 0.01, 10.0]), B=Landau::ls(x,0,1) )"");; ; // O p e r a t o r f u n c t i o n e x a m p l e s; // ---------------------------------------------------; ; // Function multiplication i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf512__wsfactory__oper_8C.html:107,Load,Loading,107,doc/master/rf512__wsfactory__oper_8C.html,https://root.cern,https://root.cern/doc/master/rf512__wsfactory__oper_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf512_wsfactory_oper.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf512_wsfactory_oper.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'ORGANIZATION AND SIMULTANEOUS FITS' RooFit tutorial macro #512 ; Illustration of operator expressions and expression-based basic p.d.f.s in the workspace factory syntax; ; ; import ROOT; ; ; w = ROOT.RooWorkspace(""w""); ; # You can define typedefs for even shorter construction semantics; w.factory(""$Typedef(Gaussian,Gaus)""); w.factory(""$Typedef(Chebychev,Cheby)""); ; # Operator pdf examples; # ------------------------------------------------; ; # PDF addition is done with SUM (coef1*pdf1,pdf2); w.factory(""SUM::summodel( f[0,1]*Gaussian::gx(x[-10,10],m[0],1.0), Chebychev::ch(x,{0.1,0.2,-0.3}) )""); ; # Extended PDF addition is done with SUM (yield1*pdf1,yield2*pdf2); w.factory(""SUM::extsummodel( Nsig[0,1000]*gx, Nbkg[0,1000]*ch )""); ; # PDF multiplication is done with PROD ( pdf1, pdf2 ); w.factory(""PROD::gxz( gx, Gaussian::gz(z[-10,10],0,1) )""); ; # Conditional p.d.f multiplication is done with PROD ( pdf1|obs, pdf2 ); w.factory(""Gaussian::gy( y[-10,10], x, 1.0 )""); w.factory(""PROD::gxycond( gy|x, gx )""); ; # Convolution (numeric/ fft) is done with NCONV/FCONV (obs,pdf1,pdf2); w.factory(""FCONV::lxg( x, Gaussian::g(x,mg[0],1), Landau::lc(x,0,1) )""); ; # Simultaneous p.d.f.s are constructed with SIMUL( index, state1=pdf1,; # state2=pdf2,...); w.factory(""SIMUL::smodel( c[A=0,B=1], A=Gaussian::gs(x,m,s[1.0, 0.01, 10.0]), B=Landau::ls(x,0,1) )""); ; # Operator function examples; # ---------------------------------------------------; ; # Function multiplication is done with prod (func1, func2,...); w.factory(""prod::uv(u[10],v[10])""); ; # Function addition is done with sum(func1,func2); w.factory(""sum::uv2(u,v)""); ; # Lagrangian morphing function for the example shown in rf711_lagrangianmorph; infilename = ROOT.gROOT.GetTutorialDir(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf512__wsfactory__oper_8py.html:108,Load,Loading,108,doc/master/rf512__wsfactory__oper_8py.html,https://root.cern,https://root.cern/doc/master/rf512__wsfactory__oper_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf513_wsfactory_tools.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf513_wsfactory_tools.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: RooCustomizer and RooSimWSTool interface in factory workspace tool in a complex standalone B physics example ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooAddPdf.h""; #include ""RooWorkspace.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; using namespace RooFit;; ; void rf513_wsfactory_tools(); {; RooWorkspace *w = new RooWorkspace(""w"");; ; // B u i l d a c o m p l e x e x a m p l e p . d . f .; // -----------------------------------------------------------; ; // Make signal model for CPV: A bmixing decay function in t (convoluted with a triple Gaussian resolution model); // times a Gaussian function the reconstructed mass; w->factory(""PROD::sig( BMixDecay::sig_t( dt[-20,20], mixState[mixed=1,unmix=-1], tagFlav[B0=1,B0bar=-1], ""; ""tau[1.54], dm[0.472], w[0.05], dw[0],""; ""AddModel::gm({GaussModel(dt,biasC[-10,10],sigmaC[0.1,3],dterr[0.01,0.2]),""; ""GaussModel(dt,0,sigmaT[3,10]),""; ""GaussModel(dt,0,20)},{fracC[0,1],fracT[0,1]}),""; ""DoubleSided ),""; ""Gaussian::sig_m( mes[5.20,5.30], mB0[5.20,5.30], sigmB0[0.01,0.05] ))"");; ; // Make background component: A plain decay function in t times an Argus function in the reconstructed mass; w->factory(""PROD::bkg( Decay::bkg_t( dt, tau, gm, DoubleSided),""; ""ArgusBG::bkg_m( mes, 5.291, k[-100,-10]))"");; ; // Make composite model from the signal and background component; w->factory(""SUM::model( Nsig[5000,0,10000]*sig, NBkg[500,0,10000]*bkg )"");; ; // E x a m p l e o f R o o S i m W S T o o l i n t e r f a c e; // ------------------------------------------------------------------; ; // Introduce a flavour tagging category tagCat as observable with 4 states corresponding; // to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf513__wsfactory__tools_8C.html:108,Load,Loading,108,doc/master/rf513__wsfactory__tools_8C.html,https://root.cern,https://root.cern/doc/master/rf513__wsfactory__tools_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf513_wsfactory_tools.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf513_wsfactory_tools.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: illustration use of ROOT.RooCustomizer and ROOT.RooSimWSTool interface in factory workspace tool in a complex standalone B physics example ; ; import ROOT; ; ; w = ROOT.RooWorkspace(""w""); ; # Build a complex example pdf; # -----------------------------------------------------------; ; # Make signal model for CPV: A bmixing decay function in t (convoluted with a triple Gaussian resolution model); # times a Gaussian function the reconstructed mass; w.factory(; ""PROD::sig( BMixDecay::sig_t( dt[-20,20], mixState[mixed=1,unmix=-1], tagFlav[B0=1,B0bar=-1], ""; ""tau[1.54], dm[0.472], w[0.05], dw[0], ""; ""AddModel::gm({GaussModel(dt,biasC[-10,10],sigmaC[0.1,3],dterr[0.01,0.2]), ""; ""GaussModel(dt,0,sigmaT[3,10]), ""; ""GaussModel(dt,0,20)},{fracC[0,1],fracT[0,1]}), ""; ""DoubleSided ), ""; ""Gaussian::sig_m( mes[5.20,5.30], mB0[5.20,5.30], sigmB0[0.01,0.05] ))""; ); ; # Make background component: A plain decay function in t times an Argus; # function in the reconstructed mass; w.factory(""PROD::bkg( Decay::bkg_t( dt, tau, gm, DoubleSided), "" ""ArgusBG::bkg_m( mes, 5.291, k[-100,-10]))""); ; # Make composite model from the signal and background component; w.factory(""SUM::model( Nsig[5000,0,10000]*sig, NBkg[500,0,10000]*bkg )""); ; # Example of RooSimWSTool interface; # ------------------------------------------------------------------; ; # Introduce a flavour tagging category tagCat as observable with 4 states corresponding; # to 4 flavour tagging techniques with different performance that require different; # parameterizations of the fit model; #; # ROOT.RooSimWSTool operation:; # - Make 4 clones of model (for each tagCat) state, will gain an individual; # copy of parameters w, and biasC. The other paramete",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf513__wsfactory__tools_8py.html:109,Load,Loading,109,doc/master/rf513__wsfactory__tools_8py.html,https://root.cern,https://root.cern/doc/master/rf513__wsfactory__tools_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf514_RooCustomizer.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf514_RooCustomizer.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Using the RooCustomizer to create multiple PDFs that share a lot of properties, but have unique parameters for each category. ; As an extra complication, some of the new parameters need to be functions of a mass parameter.; ; ; #include ""RooRealVar.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooAddPdf.h""; #include ""RooCustomizer.h""; #include ""RooCategory.h""; #include ""RooFormulaVar.h""; #include <iostream>; ; void rf514_RooCustomizer() {; ; // Define a proto model that will be used as the template for each category; // ---------------------------------------------------------------------------; ; RooRealVar E(""Energy"",""Energy"",0,3000);; ; RooRealVar meanG(""meanG"",""meanG"", 100., 0., 3000.);; RooRealVar sigmaG(""sigmaG"",""sigmaG"", 3.);; RooGaussian gauss(""gauss"", ""gauss"", E, meanG, sigmaG);; ; RooRealVar pol1(""pol1"", ""Constant of the polynomial"", 1, -10, 10);; RooPolynomial linear(""linear"", ""linear"", E, pol1);; ; RooRealVar yieldSig(""yieldSig"", ""yieldSig"", 1, 0, 1.E4);; RooRealVar yieldBkg(""yieldBkg"", ""yieldBkg"", 1, 0, 1.E4);; ; RooAddPdf model(""model"", ""S + B model"",; RooArgList(gauss,linear),; RooArgList(yieldSig, yieldBkg));; ; std::cout << ""The proto model before customisation:"" << std::endl;; model.Print(""T""); // ""T"" prints the model as a tree; ; ; // Build the categories; RooCategory sample(""sample"",""sample"");; sample[""Sample1""] = 1;; sample[""Sample2""] = 2;; sample[""Sample3""] = 3;; ; ; // Start to customise the proto model that was defined above.; // ---------------------------------------------------------------------------; ; // We need two sets for bookkeeping of PDF nodes:; RooArgSet newLeaves; // This set collects leaves that are created in the process.; RooArgSet allCustomiserNodes; // This set lists leaves t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf514__RooCustomizer_8C.html:106,Load,Loading,106,doc/master/rf514__RooCustomizer_8C.html,https://root.cern,https://root.cern/doc/master/rf514__RooCustomizer_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf514_RooCustomizer.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf514_RooCustomizer.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Using the RooCustomizer to create multiple PDFs that share a lot of properties, but have unique parameters for each category. ; As an extra complication, some of the new parameters need to be functions of a mass parameter.; ; import ROOT; ; E = ROOT.RooRealVar(""Energy"", ""Energy"", 0, 3000); ; meanG = ROOT.RooRealVar(""meanG"", ""meanG"", 100.0, 0.0, 3000.0); sigmaG = ROOT.RooRealVar(""sigmaG"", ""sigmaG"", 3.0); gauss = ROOT.RooGaussian(""gauss"", ""gauss"", E, meanG, sigmaG); ; pol1 = ROOT.RooRealVar(""pol1"", ""Constant of the polynomial"", 1, -10, 10); linear = ROOT.RooPolynomial(""linear"", ""linear"", E, pol1); ; yieldSig = ROOT.RooRealVar(""yieldSig"", ""yieldSig"", 1, 0, 1.0e4); yieldBkg = ROOT.RooRealVar(""yieldBkg"", ""yieldBkg"", 1, 0, 1.0e4); ; model = ROOT.RooAddPdf(""model"", ""S + B model"", [gauss, linear], [yieldSig, yieldBkg]); ; print(""The proto model before customisation:\n""); model.Print(""T"") # ""T"" prints the model as a tree; ; ; # Build the categories; sample = ROOT.RooCategory(""sample"", ""sample"", {""Sample1"": 1, ""Sample2"": 2, ""Sample3"": 3}); ; ; # Start to customise the proto model that was defined above.; # ---------------------------------------------------------------------------; ; # We need two sets for bookkeeping of PDF nodes:; newLeaves = ROOT.RooArgSet(); allCustomiserNodes = ROOT.RooArgSet(); ; ; # 1. Each sample should have its own mean for the gaussian; # The customiser will make copies of `meanG` for each category.; # These will all appear in the set `newLeaves`, which will own the new nodes.; cust = ROOT.RooCustomizer(model, sample, newLeaves, allCustomiserNodes); cust.splitArg(meanG, sample); ; ; # 2. Each sample should have its own signal yield, but there is an extra complication:; # We need the yields 1 and 2 to be a fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf514__RooCustomizer_8py.html:107,Load,Loading,107,doc/master/rf514__RooCustomizer_8py.html,https://root.cern,https://root.cern/doc/master/rf514__RooCustomizer_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf515_hfJSON.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf515_hfJSON.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Code HistFactory Models in JSON. ; With the HS3 standard, it is possible to code RooFit-Models of any kind as JSON files. In this tutorial, you can see how to code up a (simple) HistFactory-based model in JSON and import it into a RooWorkspace.; ; import ROOT; ; # start by creating an empty workspace; ws = ROOT.RooWorkspace(""workspace""); ; # the RooJSONFactoryWSTool is responsible for importing and exporting things to and from your workspace; tool = ROOT.RooJSONFactoryWSTool(ws); ; # use it to import the information from your JSON file; tool.importJSON(ROOT.gROOT.GetTutorialDir().Data() + ""/roofit/rf515_hfJSON.json""); ws.Print(); ; # now, you can easily use your workspace to run your fit (as you usually would); # the model config is named after your pdf, i.e. <the pdf name>_modelConfig; model = ws[""ModelConfig""]; ; # for resetting the parameters after the fit; params = model.GetPdf().getParameters(ws[""observed""]); ROOT.SetOwnership(params, True); params_initial = params.snapshot(); ROOT.SetOwnership(params_initial, True); ; # we are fitting a clone of the model now,; result = model.fitTo(ws[""observed""], ROOT.RooFit.Save(), ROOT.RooFit.PrintLevel(-1)); ROOT.SetOwnership(result, True); result.Print(); # reset parameters, such that we are not double-fitting the model in the; # closure check.; params.assign(params_initial); ; # in the end, you can again write to json; # the result will be not completely identical to the JSON file you used as an input, but it will work just the same; tool.exportJSON(""myWorkspace.json""); ; # You can again import it if you want and check for closure; ws_2 = ROOT.RooWorkspace(""workspace""); tool_2 = ROOT.RooJSONFactoryWSTool(ws_2); tool_2.importJSON(""myWorkspace.json""); ws_2.Print(); model_2 = ws_2[""ModelConfig""];",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf515__hfJSON_8py.html:100,Load,Loading,100,doc/master/rf515__hfJSON_8py.html,https://root.cern,https://root.cern/doc/master/rf515__hfJSON_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf601_intminuit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf601_intminuit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: interactive minimization with MINUIT . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooProdPdf.h""; #include ""RooAddPdf.h""; #include ""RooMinimizer.h""; #include ""RooFitResult.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf601_intminuit(); {; // S e t u p p d f a n d l i k e l i h o o d; // -----------------------------------------------; ; // Observable; RooRealVar x(""x"", ""x"", -20, 20);; ; // Model (intentional strong correlations); RooRealVar mean(""mean"", ""mean of g1 and g2"", 0);; RooRealVar sigma_g1(""sigma_g1"", ""width of g1"", 3);; RooGaussian g1(""g1"", ""g1"", x, mean, sigma_g1);; ; RooRealVar sigma_g2(""sigma_g2"", ""width of g2"", 4, 3.0, 6.0);; RooGaussian g2(""g2"", ""g2"", x, mean, sigma_g2);; ; RooRealVar frac(""frac"", ""frac"", 0.5, 0.0, 1.0);; RooAddPdf model(""model"", ""model"", RooArgList(g1, g2), frac);; ; // Generate 1000 events; std::unique_ptr<RooDataSet> data{model.generate(x, 1000)};; ; // Construct unbinned likelihood of model w.r.t. data; std::unique_ptr<RooAbsReal> nll{model.createNLL(*data)};; ; // I n t e r a c t i v e m i n i m i z a t i o n , e r r o r a n a l y s i s; // -------------------------------------------------------------------------------; ; // Create MINUIT interface object; RooMinimizer m(*nll);; ; // Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(true);; ; // Call MIGRAD to minimize the likelihood; m.migrad();; ; // Print values of all parameters, that reflect values (and error estimates); // that are back propagated from MINUIT; std::unique_ptr<RooArgSet>{model.getParameters(x)}->Print(""s"");; ; // Disable verbose logging; m.setVerbose(false);; ; // Run HESS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf601__intminuit_8C.html:102,Load,Loading,102,doc/master/rf601__intminuit_8C.html,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf601_intminuit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf601_intminuit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'LIKELIHOOD AND MINIMIZATION' RooFit tutorial macro #601 ; Interactive minimization with MINUIT. ; ; import ROOT; ; ; # Setup pdf and likelihood; # -----------------------------------------------; ; # Observable; x = ROOT.RooRealVar(""x"", ""x"", -20, 20); ; # Model (intentional strong correlations); mean = ROOT.RooRealVar(""mean"", ""mean of g1 and g2"", 0); sigma_g1 = ROOT.RooRealVar(""sigma_g1"", ""width of g1"", 3); g1 = ROOT.RooGaussian(""g1"", ""g1"", x, mean, sigma_g1); ; sigma_g2 = ROOT.RooRealVar(""sigma_g2"", ""width of g2"", 4, 3.0, 6.0); g2 = ROOT.RooGaussian(""g2"", ""g2"", x, mean, sigma_g2); ; frac = ROOT.RooRealVar(""frac"", ""frac"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Construct unbinned likelihood of model w.r.t. data; nll = model.createNLL(data); ; # Interactive minimization, error analysis; # -------------------------------------------------------------------------------; ; # Create MINUIT interface object; m = ROOT.RooMinimizer(nll); ; # Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(True); ; # Call MIGRAD to minimize the likelihood; m.migrad(); ; # Print values of all parameters, reflect values (and error estimates); # that are back propagated from MINUIT; model.getParameters({x}).Print(""s""); ; # Disable verbose logging; m.setVerbose(False); ; # Run HESSE to calculate errors from d2L/dp2; m.hesse(); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Run MINOS on sigma_g2 parameter only; m.minos({sigma_g2}); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf601__intminuit_8py.html:103,Load,Loading,103,doc/master/rf601__intminuit_8py.html,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf602_chi2fit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf602_chi2fit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: setting up a chi^2 fit to a binned dataset ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooAddPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf602_chi2fit(); {; ; // S e t u p m o d e l; // ---------------------; ; // Declare observable x; RooRealVar x(""x"", ""x"", 0, 10);; ; // Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and their parameters; RooRealVar mean(""mean"", ""mean of gaussians"", 5);; RooRealVar sigma1(""sigma1"", ""width of gaussians"", 0.5);; RooRealVar sigma2(""sigma2"", ""width of gaussians"", 1);; ; RooGaussian sig1(""sig1"", ""Signal component 1"", x, mean, sigma1);; RooGaussian sig2(""sig2"", ""Signal component 2"", x, mean, sigma2);; ; // Build Chebychev polynomial pdf; RooRealVar a0(""a0"", ""a0"", 0.5, 0., 1.);; RooRealVar a1(""a1"", ""a1"", 0.2, 0., 1.);; RooChebychev bkg(""bkg"", ""Background"", x, RooArgSet(a0, a1));; ; // Sum the signal components into a composite signal pdf; RooRealVar sig1frac(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0., 1.);; RooAddPdf sig(""sig"", ""Signal"", RooArgList(sig1, sig2), sig1frac);; ; // Sum the composite signal and background; RooRealVar bkgfrac(""bkgfrac"", ""fraction of background"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), bkgfrac);; ; // C r e a t e b i n n e d d a t a s e t; // -----------------------------------------; ; std::unique_ptr<RooDataSet> d{model.generate(x, 10000)};; std::unique_ptr<RooDataHist> dh{d->binnedClone()};; ; // Construct a chi^2 of the data and the model.; // When a pdf is used in a chi^2 fit, the probability density scaled; // by the number of events in the dataset to obtain the fit fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf602__chi2fit_8C.html:100,Load,Loading,100,doc/master/rf602__chi2fit_8C.html,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf602_chi2fit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf602_chi2fit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'LIKELIHOOD AND MINIMIZATION' RooFit tutorial macro #602 ; Setting up a chi^2 fit to a binned dataset; ; from __future__ import print_function; import ROOT; ; ; # Set up model; # ---------------------; ; # Declare observable x; x = ROOT.RooRealVar(""x"", ""x"", 0, 10); ; # Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and; # their parameters; mean = ROOT.RooRealVar(""mean"", ""mean of gaussians"", 5); sigma1 = ROOT.RooRealVar(""sigma1"", ""width of gaussians"", 0.5); sigma2 = ROOT.RooRealVar(""sigma2"", ""width of gaussians"", 1); ; sig1 = ROOT.RooGaussian(""sig1"", ""Signal component 1"", x, mean, sigma1); sig2 = ROOT.RooGaussian(""sig2"", ""Signal component 2"", x, mean, sigma2); ; # Build Chebychev polynomial p.d.f.; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", 0.2, 0.0, 1.0); bkg = ROOT.RooChebychev(""bkg"", ""Background"", x, [a0, a1]); ; # Sum the signal components into a composite signal p.d.f.; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Create biuned dataset; # -----------------------------------------; ; d = model.generate({x}, 10000); dh = d.binnedClone(); ; # Construct a chi^2 of the data and the model.; # When a p.d.f. is used in a chi^2 fit, probability density scaled; # by the number of events in the dataset to obtain the fit function; # If model is an extended p.d.f, expected number events is used; # instead of the observed number of events.; ll = ROOT.RooLinkedList(); model.chi2FitTo(dh, ll",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf602__chi2fit_8py.html:101,Load,Loading,101,doc/master/rf602__chi2fit_8py.html,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf603_multicpu.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf603_multicpu.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: setting up a multi-core parallelized unbinned maximum likelihood fit . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooAddPdf.h""; #include ""RooProdPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf603_multicpu(); {; ; // C r e a t e 3 D p d f a n d d a t a; // -------------------------------------------; ; // Create observables; RooRealVar x(""x"", ""x"", -5, 5);; RooRealVar y(""y"", ""y"", -5, 5);; RooRealVar z(""z"", ""z"", -5, 5);; ; // Create signal pdf gauss(x)*gauss(y)*gauss(z); RooGaussian gx(""gx"", ""gx"", x, 0.0, 1.0);; RooGaussian gy(""gy"", ""gy"", y, 0.0, 1.0);; RooGaussian gz(""gz"", ""gz"", z, 0.0, 1.0);; RooProdPdf sig(""sig"", ""sig"", RooArgSet(gx, gy, gz));; ; // Create background pdf poly(x)*poly(y)*poly(z); RooPolynomial px(""px"", ""px"", x, RooArgSet(-0.1, 0.004));; RooPolynomial py(""py"", ""py"", y, RooArgSet(0.1, -0.004));; RooPolynomial pz(""pz"", ""pz"", z);; RooProdPdf bkg(""bkg"", ""bkg"", RooArgSet(px, py, pz));; ; // Create composite pdf sig+bkg; RooRealVar fsig(""fsig"", ""signal fraction"", 0.1, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgList(sig, bkg), fsig);; ; // Generate large dataset; std::unique_ptr<RooDataSet> data{model.generate({x, y, z}, 200000)};; ; // P a r a l l e l f i t t i n g; // -------------------------------; ; // In parallel mode the likelihood calculation is split in N pieces,; // that are calculated in parallel and added a posteriori before passing; // it back to MINUIT.; ; // Use four processes and time results both in wall time and CPU time; model.fitTo(*data, NumCPU(4), Timer(true), PrintLevel(-1));; ; // P a r a l l e l M C p r o j e c t i o n s; // ---------------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf603__multicpu_8C.html:101,Load,Loading,101,doc/master/rf603__multicpu_8C.html,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf603_multicpu.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf603_multicpu.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: setting up a multi-core parallelized unbinned maximum likelihood fit . ; import ROOT; ; ; # Create 3D pdf and data; # -------------------------------------------; ; # Create observables; x = ROOT.RooRealVar(""x"", ""x"", -5, 5); y = ROOT.RooRealVar(""y"", ""y"", -5, 5); z = ROOT.RooRealVar(""z"", ""z"", -5, 5); ; # Create signal pdf gauss(x)*gauss(y)*gauss(z); gx = ROOT.RooGaussian(""gx"", ""gx"", x, 0.0, 1.0); gy = ROOT.RooGaussian(""gy"", ""gy"", y, 0.0, 1.0); gz = ROOT.RooGaussian(""gz"", ""gz"", z, 0.0, 1.0); sig = ROOT.RooProdPdf(""sig"", ""sig"", [gx, gy, gz]); ; # Create background pdf poly(x)*poly(y)*poly(z); px = ROOT.RooPolynomial(""px"", ""px"", x, [-0.1, 0.004]); py = ROOT.RooPolynomial(""py"", ""py"", y, [0.1, -0.004]); pz = ROOT.RooPolynomial(""pz"", ""pz"", z); bkg = ROOT.RooProdPdf(""bkg"", ""bkg"", [px, py, pz]); ; # Create composite pdf sig+bkg; fsig = ROOT.RooRealVar(""fsig"", ""signal fraction"", 0.1, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [sig, bkg], [fsig]); ; # Generate large dataset; data = model.generate({x, y, z}, 200000); ; # Parallel fitting; # -------------------------------; ; # In parallel mode the likelihood calculation is split in N pieces,; # that are calculated in parallel and added a posteriori before passing; # it back to MINUIT.; ; # Use four processes and time results both in wall time and CPU time; model.fitTo(data, NumCPU=4, Timer=True, PrintLevel=-1); ; # Parallel MC projections; # ----------------------------------------------; ; # Construct signal, likelihood projection on (y,z) observables and; # likelihood ratio; sigyz = sig.createProjection({x}); totyz = model.createProjection({x}); llratio_func = ROOT.RooFormulaVar(""llratio"", ""log10(@0)-log10(@1)"", [sigyz, totyz]); ; # Calculate likelihood rat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf603__multicpu_8py.html:102,Load,Loading,102,doc/master/rf603__multicpu_8py.html,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf604_constraints.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf604_constraints.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: fitting with constraints ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooAddPdf.h""; #include ""RooProdPdf.h""; #include ""RooFitResult.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf604_constraints(); {; ; // C r e a t e m o d e l a n d d a t a s e t; // ----------------------------------------------; ; // Construct a Gaussian pdf; RooRealVar x(""x"", ""x"", -10, 10);; ; RooRealVar m(""m"", ""m"", 0, -10, 10);; RooRealVar s(""s"", ""s"", 2, 0.1, 10);; RooGaussian gauss(""gauss"", ""gauss(x,m,s)"", x, m, s);; ; // Construct a flat pdf (polynomial of 0th order); RooPolynomial poly(""poly"", ""poly(x)"", x);; ; // Construct model = f*gauss + (1-f)*poly; RooRealVar f(""f"", ""f"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgSet(gauss, poly), f);; ; // Generate small dataset for use in fitting below; std::unique_ptr<RooDataSet> d{model.generate(x, 50)};; ; // C r e a t e c o n s t r a i n t p d f; // -----------------------------------------; ; // Construct Gaussian constraint pdf on parameter f at 0.8 with resolution of 0.1; RooGaussian fconstraint(""fconstraint"", ""fconstraint"", f, 0.8, 0.2);; ; // M E T H O D 1 - A d d i n t e r n a l c o n s t r a i n t t o m o d e l; // -------------------------------------------------------------------------------------; ; // Multiply constraint term with regular pdf using RooProdPdf; // Specify in fitTo() that internal constraints on parameter f should be used; ; // Multiply constraint with pdf; RooProdPdf modelc(""modelc"", ""model with constraint"", RooArgSet(model, fconstraint));; ; // Fit model (without use of constraint term); std::unique_ptr<RooFitResu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf604__constraints_8C.html:104,Load,Loading,104,doc/master/rf604__constraints_8C.html,https://root.cern,https://root.cern/doc/master/rf604__constraints_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf604_constraints.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf604_constraints.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: fitting with constraints ; ; from __future__ import print_function; import ROOT; ; ; # Create model and dataset; # ----------------------------------------------; ; # Construct a Gaussian pdf; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); ; m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 2, 0.1, 10); gauss = ROOT.RooGaussian(""gauss"", ""gauss(x,m,s)"", x, m, s); ; # Construct a flat pdf (polynomial of 0th order); poly = ROOT.RooPolynomial(""poly"", ""poly(x)"", x); ; # model = f*gauss + (1-f)*poly; f = ROOT.RooRealVar(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; # Generate small dataset for use in fitting below; d = model.generate({x}, 50); ; # Create constraint pdf; # -----------------------------------------; ; # Construct Gaussian constraint pdf on parameter f at 0.8 with; # resolution of 0.1; fconstraint = ROOT.RooGaussian(""fconstraint"", ""fconstraint"", f, 0.8, 0.1); ; # Method 1 - add internal constraint to model; # -------------------------------------------------------------------------------------; ; # Multiply constraint term with regular pdf using ROOT.RooProdPdf Specify in; # fitTo() that internal constraints on parameter f should be used; ; # Multiply constraint with pdf; modelc = ROOT.RooProdPdf(""modelc"", ""model with constraint"", [model, fconstraint]); ; # Fit model (without use of constraint term); r1 = model.fitTo(d, Save=True, PrintLevel=-1); ; # Fit modelc with constraint term on parameter f; r2 = modelc.fitTo(d, Constrain={f}, Save=True, PrintLevel=-1); ; # Method 2 - specify external constraint when fitting; # ------------------------------------------------------------------------------------------; ; # Construct another Gaus",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf604__constraints_8py.html:105,Load,Loading,105,doc/master/rf604__constraints_8py.html,https://root.cern,https://root.cern/doc/master/rf604__constraints_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf605_profilell.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf605_profilell.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: working with the profile likelihood estimator . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooAddPdf.h""; #include ""RooMinimizer.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf605_profilell(); {; // C r e a t e m o d e l a n d d a t a s e t; // -----------------------------------------------; ; // Observable; RooRealVar x(""x"", ""x"", -20, 20);; ; // Model (intentional strong correlations); RooRealVar mean(""mean"", ""mean of g1 and g2"", 0, -10, 10);; RooRealVar sigma_g1(""sigma_g1"", ""width of g1"", 3);; RooGaussian g1(""g1"", ""g1"", x, mean, sigma_g1);; ; RooRealVar sigma_g2(""sigma_g2"", ""width of g2"", 4, 3.0, 6.0);; RooGaussian g2(""g2"", ""g2"", x, mean, sigma_g2);; ; RooRealVar frac(""frac"", ""frac"", 0.5, 0.0, 1.0);; RooAddPdf model(""model"", ""model"", RooArgList(g1, g2), frac);; ; // Generate 1000 events; std::unique_ptr<RooDataSet> data{model.generate(x, 1000)};; ; // C o n s t r u c t p l a i n l i k e l i h o o d; // ---------------------------------------------------; ; // Construct unbinned likelihood; std::unique_ptr<RooAbsReal> nll{model.createNLL(*data, NumCPU(2))};; ; // Minimize likelihood w.r.t all parameters before making plots; RooMinimizer(*nll).migrad();; ; // Plot likelihood scan frac; RooPlot *frame1 = frac.frame(Bins(10), Range(0.01, 0.95), Title(""LL and profileLL in frac""));; nll->plotOn(frame1, ShiftToZero());; ; // Plot likelihood scan in sigma_g2; RooPlot *frame2 = sigma_g2.frame(Bins(10), Range(3.3, 5.0), Title(""LL and profileLL in sigma_g2""));; nll->plotOn(frame2, ShiftToZero());; ; // C o n s t r u c t p r o f i l e l i k e l i h o o d i n f r a c; // -------------------------------------------------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf605__profilell_8C.html:102,Load,Loading,102,doc/master/rf605__profilell_8C.html,https://root.cern,https://root.cern/doc/master/rf605__profilell_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf605_profilell.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf605_profilell.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'LIKELIHOOD AND MINIMIZATION' RooFit tutorial macro #605 ; Working with the profile likelihood estimator. ; ; import ROOT; ; ; # Create model and dataset; # -----------------------------------------------; ; # Observable; x = ROOT.RooRealVar(""x"", ""x"", -20, 20); ; # Model (intentional strong correlations); mean = ROOT.RooRealVar(""mean"", ""mean of g1 and g2"", 0, -10, 10); sigma_g1 = ROOT.RooRealVar(""sigma_g1"", ""width of g1"", 3); g1 = ROOT.RooGaussian(""g1"", ""g1"", x, mean, sigma_g1); ; sigma_g2 = ROOT.RooRealVar(""sigma_g2"", ""width of g2"", 4, 3.0, 6.0); g2 = ROOT.RooGaussian(""g2"", ""g2"", x, mean, sigma_g2); ; frac = ROOT.RooRealVar(""frac"", ""frac"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Construct plain likelihood; # ---------------------------------------------------; ; # Construct unbinned likelihood; nll = model.createNLL(data, NumCPU=2); ; # Minimize likelihood w.r.t all parameters before making plots; ROOT.RooMinimizer(nll).migrad(); ; # Plot likelihood scan frac; frame1 = frac.frame(Bins=10, Range=(0.01, 0.95), Title=""LL and profileLL in frac""); nll.plotOn(frame1, ShiftToZero=True); ; # Plot likelihood scan in sigma_g2; frame2 = sigma_g2.frame(Bins=10, Range=(3.3, 5.0), Title=""LL and profileLL in sigma_g2""); nll.plotOn(frame2, ShiftToZero=True); ; # Construct profile likelihood in frac; # -----------------------------------------------------------------------; ; # The profile likelihood estimator on nll for frac will minimize nll w.r.t; # all floating parameters except frac for each evaluation; ; pll_frac = nll.createProfile({frac}); ; # Plot the profile likelihood in frac; pll_frac.plotOn(frame1, LineColor=""r""); ; # Adjust frame maximu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf605__profilell_8py.html:103,Load,Loading,103,doc/master/rf605__profilell_8py.html,https://root.cern,https://root.cern/doc/master/rf605__profilell_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf606_nllerrorhandling.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf606_nllerrorhandling.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: understanding and customizing error handling in likelihood evaluations . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooArgusBG.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf606_nllerrorhandling(); {; // C r e a t e m o d e l a n d d a t a s e t; // ----------------------------------------------; ; // Observable; RooRealVar m(""m"", ""m"", 5.20, 5.30);; ; // Parameters; RooRealVar m0(""m0"", ""m0"", 5.291, 5.20, 5.30);; RooRealVar k(""k"", ""k"", -30, -50, -10);; ; // Pdf; RooArgusBG argus(""argus"", ""argus"", m, m0, k);; ; // Sample 1000 events in m from argus; std::unique_ptr<RooDataSet> data{argus.generate(m, 1000)};; ; // P l o t m o d e l a n d d a t a; // --------------------------------------; ; RooPlot *frame1 = m.frame(Bins(40), Title(""Argus model and data""));; data->plotOn(frame1);; argus.plotOn(frame1);; ; // F i t m o d e l t o d a t a; // ---------------------------------; ; // The ARGUS background shape has a sharp kinematic cutoff at m=m0; // and is prone to evaluation errors if the cutoff parameter m0; // is floated: when the pdf cutoff value is lower than that in data; // events with m>m0 will have zero probability; ; // Perform unbinned ML fit. Print detailed error messages for up to; // 10 events per likelihood evaluation. The default error handling strategy; // is to return a very high value of the likelihood to MINUIT if errors occur,; // which will force MINUIT to retreat from the problematic area; ; argus.fitTo(*data, PrintEvalErrors(10));; ; // Perform another fit. In this configuration only the number of errors per; // likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disabl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:109,Load,Loading,109,doc/master/rf606__nllerrorhandling_8C.html,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf606_nllerrorhandling.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf606_nllerrorhandling.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'LIKELIHOOD AND MINIMIZATION' RooFit tutorial macro #606 ; Understanding and customizing error handling in likelihood evaluations. ; ; import ROOT; ; ; # Create model and dataset; # ----------------------------------------------; ; # Observable; m = ROOT.RooRealVar(""m"", ""m"", 5.20, 5.30); ; # Parameters; m0 = ROOT.RooRealVar(""m0"", ""m0"", 5.291, 5.20, 5.30); k = ROOT.RooRealVar(""k"", ""k"", -30, -50, -10); ; # Pdf; argus = ROOT.RooArgusBG(""argus"", ""argus"", m, m0, k); ; # Sample 1000 events in m from argus; data = argus.generate({m}, 1000); ; # Plot model and data; # --------------------------------------; ; frame1 = m.frame(Bins=40, Title=""Argus model and data""); data.plotOn(frame1); argus.plotOn(frame1); ; # Fit model to data; # ---------------------------------; ; # The ARGUS background shape has a sharp kinematic cutoff at m=m0; # and is prone to evaluation errors if the cutoff parameter m0; # is floated: when the pdf cutoff value is lower than that in data; # events with m>m0 will have zero probability; ; # Perform unbinned ML fit. Print detailed error messages for up to; # 10 events per likelihood evaluation. The default error handling strategy; # is to return a very high value of the likelihood to MINUIT if errors occur,; # which will force MINUIT to retreat from the problematic area; ; argus.fitTo(data, PrintEvalErrors=10); ; # Perform another fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:110,Load,Loading,110,doc/master/rf606__nllerrorhandling_8py.html,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf607_fitresult.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf607_fitresult.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: demonstration of options of the RooFitResult class . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooAddPdf.h""; #include ""RooChebychev.h""; #include ""RooFitResult.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TFile.h""; #include ""TStyle.h""; #include ""TH2.h""; #include ""TMatrixDSym.h""; ; using namespace RooFit;; ; void rf607_fitresult(); {; // C r e a t e p d f , d a t a; // --------------------------------; ; // Declare observable x; RooRealVar x(""x"", ""x"", 0, 10);; ; // Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and their parameters; RooRealVar mean(""mean"", ""mean of gaussians"", 5, -10, 10);; RooRealVar sigma1(""sigma1"", ""width of gaussians"", 0.5, 0.1, 10);; RooRealVar sigma2(""sigma2"", ""width of gaussians"", 1, 0.1, 10);; ; RooGaussian sig1(""sig1"", ""Signal component 1"", x, mean, sigma1);; RooGaussian sig2(""sig2"", ""Signal component 2"", x, mean, sigma2);; ; // Build Chebychev polynomial pdf; RooRealVar a0(""a0"", ""a0"", 0.5, 0., 1.);; RooRealVar a1(""a1"", ""a1"", -0.2);; RooChebychev bkg(""bkg"", ""Background"", x, RooArgSet(a0, a1));; ; // Sum the signal components into a composite signal pdf; RooRealVar sig1frac(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0., 1.);; RooAddPdf sig(""sig"", ""Signal"", RooArgList(sig1, sig2), sig1frac);; ; // Sum the composite signal and background; RooRealVar bkgfrac(""bkgfrac"", ""fraction of background"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), bkgfrac);; ; // Generate 1000 events; std::unique_ptr<RooDataSet> data{model.generate(x, 1000)};; ; // F i t p d f t o d a t a , s a v e f i t r e s u l t; // -------------------------------------------------------------; ; // Perf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf607__fitresult_8C.html:102,Load,Loading,102,doc/master/rf607__fitresult_8C.html,https://root.cern,https://root.cern/doc/master/rf607__fitresult_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf607_fitresult.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf607_fitresult.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: demonstration of options of the RooFitResult class . ; from __future__ import print_function; import ROOT; ; ; # Create pdf, data; # --------------------------------; ; # Declare observable x; x = ROOT.RooRealVar(""x"", ""x"", 0, 10); ; # Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and; # their parameters; mean = ROOT.RooRealVar(""mean"", ""mean of gaussians"", 5, -10, 10); sigma1 = ROOT.RooRealVar(""sigma1"", ""width of gaussians"", 0.5, 0.1, 10); sigma2 = ROOT.RooRealVar(""sigma2"", ""width of gaussians"", 1, 0.1, 10); ; sig1 = ROOT.RooGaussian(""sig1"", ""Signal component 1"", x, mean, sigma1); sig2 = ROOT.RooGaussian(""sig2"", ""Signal component 2"", x, mean, sigma2); ; # Build Chebychev polynomial pdf; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.2); bkg = ROOT.RooChebychev(""bkg"", ""Background"", x, [a0, a1]); ; # Sum the signal components into a composite signal pdf; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Fit pdf to data, save fit result; # -------------------------------------------------------------; ; # Perform fit and save result; r = model.fitTo(data, Save=True, PrintLevel=-1); ; # Print fit results; # ---------------------------------; ; # Summary printing: Basic info plus final values of floating fit parameters; r.Print(); ; # Verbose printing: Basic info, of constant parameters, and; # fina",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf607__fitresult_8py.html:103,Load,Loading,103,doc/master/rf607__fitresult_8py.html,https://root.cern,https://root.cern/doc/master/rf607__fitresult_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf608_fitresultaspdf.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf608_fitresultaspdf.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: representing the parabolic approximation of the fit as a multi-variate Gaussian on the parameters of the fitted pdf . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooAddPdf.h""; #include ""RooChebychev.h""; #include ""RooFitResult.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TFile.h""; #include ""TStyle.h""; #include ""TH2.h""; #include ""TH3.h""; ; using namespace RooFit;; ; void rf608_fitresultaspdf(); {; // C r e a t e m o d e l a n d d a t a s e t; // -----------------------------------------------; ; // Observable; RooRealVar x(""x"", ""x"", -20, 20);; ; // Model (intentional strong correlations); RooRealVar mean(""mean"", ""mean of g1 and g2"", 0, -1, 1);; RooRealVar sigma_g1(""sigma_g1"", ""width of g1"", 2);; RooGaussian g1(""g1"", ""g1"", x, mean, sigma_g1);; ; RooRealVar sigma_g2(""sigma_g2"", ""width of g2"", 4, 3.0, 5.0);; RooGaussian g2(""g2"", ""g2"", x, mean, sigma_g2);; ; RooRealVar frac(""frac"", ""frac"", 0.5, 0.0, 1.0);; RooAddPdf model(""model"", ""model"", RooArgList(g1, g2), frac);; ; // Generate 1000 events; std::unique_ptr<RooDataSet> data{model.generate(x, 1000)};; ; // F i t m o d e l t o d a t a; // ----------------------------------; ; std::unique_ptr<RooFitResult> r{model.fitTo(*data, Save(), PrintLevel(-1))};; ; // C r e a t e M V G a u s s i a n p d f o f f i t t e d p a r a m e t e r s; // ------------------------------------------------------------------------------------; ; RooAbsPdf *parabPdf = r->createHessePdf(RooArgSet(frac, mean, sigma_g2));; ; // S o m e e x e c e r c i s e s w i t h t h e p a r a m e t e r p d f; // -----------------------------------------------------------------------------; ; // Generate 100K points in the parameter ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html:107,Load,Loading,107,doc/master/rf608__fitresultaspdf_8C.html,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf608_fitresultaspdf.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf608_fitresultaspdf.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: representing the parabolic approximation of the fit as a multi-variate Gaussian on the parameters of the fitted pdf . ; import ROOT; ; ; # Create model and dataset; # -----------------------------------------------; ; # Observable; x = ROOT.RooRealVar(""x"", ""x"", -20, 20); ; # Model (intentional strong correlations); mean = ROOT.RooRealVar(""mean"", ""mean of g1 and g2"", 0, -1, 1); sigma_g1 = ROOT.RooRealVar(""sigma_g1"", ""width of g1"", 2); g1 = ROOT.RooGaussian(""g1"", ""g1"", x, mean, sigma_g1); ; sigma_g2 = ROOT.RooRealVar(""sigma_g2"", ""width of g2"", 4, 3.0, 5.0); g2 = ROOT.RooGaussian(""g2"", ""g2"", x, mean, sigma_g2); ; frac = ROOT.RooRealVar(""frac"", ""frac"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Fit model to data; # ----------------------------------; ; r = model.fitTo(data, Save=True, PrintLevel=-1); ; # Create MV Gaussian pdf of fitted parameters; # ------------------------------------------------------------------------------------; ; parabPdf = r.createHessePdf({frac, mean, sigma_g2}); ; # Some exercises with the parameter pdf; # -----------------------------------------------------------------------------; ; # Generate 100K points in the parameter space, from the MVGaussian pdf; d = parabPdf.generate({mean, sigma_g2, frac}, 100000); ; # Sample a 3-D histogram of the pdf to be visualized as an error; # ellipsoid using the GLISO draw option; hh_3d = parabPdf.createHistogram(""mean,sigma_g2,frac"", 25, 25, 25); hh_3d.SetFillColor(ROOT.kBlue); ; # Project 3D parameter pdf down to 3 permutations of two-dimensional pdfs; # The integrations corresponding to these projections are performed analytically; # by ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf608__fitresultaspdf_8py.html:108,Load,Loading,108,doc/master/rf608__fitresultaspdf_8py.html,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf609_xychi2fit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf609_xychi2fit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: setting up a chi^2 fit to an unbinned dataset with X,Y,err(Y) values (and optionally err(X) values) . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooPolyVar.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TRandom.h""; ; using namespace RooFit;; ; void rf609_xychi2fit(); {; // C r e a t e d a t a s e t w i t h X a n d Y v a l u e s; // -------------------------------------------------------------------; ; // Make weighted XY dataset with asymmetric errors stored; // The StoreError() argument is essential as it makes; // the dataset store the error in addition to the values; // of the observables. If errors on one or more observables; // are asymmetric, one can store the asymmetric error; // using the StoreAsymError() argument; ; RooRealVar x(""x"", ""x"", -11, 11);; RooRealVar y(""y"", ""y"", -10, 200);; RooDataSet dxy(""dxy"", ""dxy"", {x, y}, StoreError({x, y}));; ; // Fill an example dataset with X,err(X),Y,err(Y) values; for (int i = 0; i <= 10; i++) {; ; // Set X value and error; x = -10 + 2 * i;; x.setError(i < 5 ? 0.5 / 1. : 1.0 / 1.);; ; // Set Y value and error; y = x.getVal() * x.getVal() + 4 * fabs(gRandom->Gaus());; y.setError(sqrt(y.getVal()));; ; dxy.add({x, y});; }; ; // P e r f o r m c h i 2 f i t t o X + / - d x a n d Y + / - d Y v a l u e s; // ---------------------------------------------------------------------------------------; ; // Make fit function; RooRealVar a(""a"", ""a"", 0.0, -10, 10);; RooRealVar b(""b"", ""b"", 0.0, -100, 100);; RooRealVar c(""c"", ""c"", 0.0, -100, 100);; RooPolyVar f(""f"", ""f"", x, RooArgList(b, a, c));; ; // Plot dataset in X-Y interpretation; RooPlot *frame = x.frame(Title(""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""));; dxy.plotOnXY(frame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf609__xychi2fit_8C.html:102,Load,Loading,102,doc/master/rf609__xychi2fit_8C.html,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf609_xychi2fit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf609_xychi2fit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: setting up a chi^2 fit to an unbinned dataset with X,Y,err(Y) values (and optionally err(X) values) . ; import ROOT; import math; ; ; # Create dataset with X and Y values; # -------------------------------------------------------------------; ; # Make weighted XY dataset with asymmetric errors stored; # The StoreError() argument is essential as it makes; # the dataset store the error in addition to the values; # of the observables. If errors on one or more observables; # are asymmetric, can store the asymmetric error; # using the StoreAsymError() argument; ; x = ROOT.RooRealVar(""x"", ""x"", -11, 11); y = ROOT.RooRealVar(""y"", ""y"", -10, 200); dxy = ROOT.RooDataSet(""dxy"", ""dxy"", {x, y}, StoreError={x, y}); ; # Fill an example dataset with X,err(X),Y,err(Y) values; for i in range(10):; x.setVal(-10 + 2 * i); x.setError((0.5 / 1.0) if (i < 5) else (1.0 / 1.0)); ; # Set Y value and error; y.setVal(x.getVal() * x.getVal() + 4 * abs(ROOT.gRandom.Gaus())); y.setError(math.sqrt(y.getVal())); ; dxy.add({x, y}); ; # Perform chi2 fit to X +/- dX and Y +/- dY values; # ---------------------------------------------------------------------------------------; ; # Make fit function; a = ROOT.RooRealVar(""a"", ""a"", 0.0, -10, 10); b = ROOT.RooRealVar(""b"", ""b"", 0.0, -100, 100); c = ROOT.RooRealVar(""c"", ""c"", 0.0, -100, 100); f = ROOT.RooPolyVar(""f"", ""f"", x, [b, a, c]); ; # Plot dataset in X-Y interpretation; frame = x.frame(Title=""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""); dxy.plotOnXY(frame, YVar=y); ; # Fit chi^2 using X and Y errors; fit1 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1); fit1.Print(); ; # Overlay fitted function; f.plotOn(frame); ; # Alternative: fit chi^2 integrating f(x) over ranges defined by",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf609__xychi2fit_8py.html:103,Load,Loading,103,doc/master/rf609__xychi2fit_8py.html,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf610_visualerror.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf610_visualerror.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: visualization of errors from a covariance matrix . ; #include ""RooRealVar.h""; #include ""RooDataHist.h""; #include ""RooGaussian.h""; #include ""RooAddPdf.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TAxis.h""; using namespace RooFit;; ; void rf610_visualerror(); {; // S e t u p e x a m p l e f i t; // ---------------------------------------; ; // Create sum of two Gaussians pdf with factory; RooRealVar x(""x"", ""x"", -10, 10);; ; RooRealVar m(""m"", ""m"", 0, -10, 10);; RooRealVar s(""s"", ""s"", 2, 1, 50);; RooGaussian sig(""sig"", ""sig"", x, m, s);; ; RooRealVar m2(""m2"", ""m2"", -1, -10, 10);; RooRealVar s2(""s2"", ""s2"", 6, 1, 50);; RooGaussian bkg(""bkg"", ""bkg"", x, m2, s2);; ; RooRealVar fsig(""fsig"", ""fsig"", 0.33, 0, 1);; RooAddPdf model(""model"", ""model"", RooArgList(sig, bkg), fsig);; ; // Create binned dataset; x.setBins(25);; std::unique_ptr<RooAbsData> d{model.generateBinned(x, 1000)};; ; // Perform fit and save fit result; std::unique_ptr<RooFitResult> r{model.fitTo(*d, Save(), PrintLevel(-1))};; ; // V i s u a l i z e f i t e r r o r; // -------------------------------------; ; // Make plot frame; RooPlot *frame = x.frame(Bins(40), Title(""P.d.f with visualized 1-sigma error band""));; d->plotOn(frame);; ; // Visualize 1-sigma error encoded in fit result 'r' as orange band using linear error propagation; // This results in an error band that is by construction symmetric; //; // The linear error is calculated as; // error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); //; // where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; //; // with f(x) = the plotted curve; // 'da' = error taken from the fit result; // Corr(a,a') = the correlation matrix from the fit result; // Z = requested significance 'Z sigma band'; //; //",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf610__visualerror_8C.html:104,Load,Loading,104,doc/master/rf610__visualerror_8C.html,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf610_visualerror.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf610_visualerror.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: visualization of errors from a covariance matrix . ; import ROOT; ; ; # Setup example fit; # ---------------------------------------; ; # Create sum of two Gaussians pdf with factory; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); ; m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 2, 1, 50); sig = ROOT.RooGaussian(""sig"", ""sig"", x, m, s); ; m2 = ROOT.RooRealVar(""m2"", ""m2"", -1, -10, 10); s2 = ROOT.RooRealVar(""s2"", ""s2"", 6, 1, 50); bkg = ROOT.RooGaussian(""bkg"", ""bkg"", x, m2, s2); ; fsig = ROOT.RooRealVar(""fsig"", ""fsig"", 0.33, 0, 1); model = ROOT.RooAddPdf(""model"", ""model"", [sig, bkg], [fsig]); ; # Create binned dataset; x.setBins(25); d = model.generateBinned({x}, 1000); ; # Perform fit and save fit result; r = model.fitTo(d, Save=True, PrintLevel=-1); ; # Visualize fit error; # -------------------------------------; ; # Make plot frame; frame = x.frame(Bins=40, Title=""P.d.f with visualized 1-sigma error band""); d.plotOn(frame); ; # Visualize 1-sigma error encoded in fit result 'r' as orange band using linear error propagation; # ROOT.This results in an error band that is by construction symmetric; #; # The linear error is calculated as; # error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); #; # where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; #; # with f(x) = the plotted curve; # 'da' = error taken from the fit result; # Corr(a,a') = the correlation matrix from the fit result; # Z = requested significance 'Z sigma band'; #; # The linear method is fast (required 2*N evaluations of the curve, N is the number of parameters),; # but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; # Gaussian approximations made; #; model.plotOn(frame, VisualizeError=(r,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf610__visualerror_8py.html:105,Load,Loading,105,doc/master/rf610__visualerror_8py.html,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html,2,"['Load', 'Perform']","['Loading', 'Perform']"
Performance,". ROOT: tutorials/roofit/rf611_weightedfits.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf611_weightedfits.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Parameter uncertainties for weighted unbinned ML fits . Parameter uncertainties for weighted unbinned ML fits; Based on example from https://arxiv.org/abs/1911.01303; This example compares different approaches to determining parameter uncertainties in weighted unbinned maximum likelihood fits. Performing a weighted unbinned maximum likelihood fits can be useful to account for acceptance effects and to statistically subtract background events using the sPlot formalism. It is however well known that the inverse Hessian matrix does not yield parameter uncertainties with correct coverage in the presence of event weights. Three approaches to the determination of parameter uncertainties are compared in this example:. Using the inverse weighted Hessian matrix [SumW2Error(false)]; Using the expression [SumW2Error(true)] ; \[; V_{ij} = H_{ik}^{-1} C_{kl} H_{lj}^{-1}; \]. where H is the weighted Hessian matrix and C is the Hessian matrix with squared weights; The asymptotically correct approach (for details please see https://arxiv.org/abs/1911.01303) [Asymptotic(true)] ; \[; V_{ij} = H_{ik}^{-1} D_{kl} H_{lj}^{-1}; \]. where H is the weighted Hessian matrix and D is given by ; \[; D_{kl} = \sum_{e=1}^{N} w_e^2 \frac{\partial \log(P)}{\partial \lambda_k}\frac{\partial \log(P)}{\partial; \lambda_l}; \]. with the event weight \(w_e\). The example performs the fit of a second order polynomial in the angle cos(theta) [-1,1] to a weighted data set. The polynomial is given by ; \[; P = \frac{ 1 + c_0 \cdot \cos(\theta) + c_1 \cdot \cos(\theta) \cdot \cos(\theta) }{\mathrm{Norm}}; \]. The two coefficients \( c_0 \) and \( c_1 \) and their uncertainties are to be determined in the fit.; The per-event weight is used to correct for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf611__weightedfits_8C.html:105,Load,Loading,105,doc/master/rf611__weightedfits_8C.html,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html,2,"['Load', 'Perform']","['Loading', 'Performing']"
Performance,". ROOT: tutorials/roofit/rf612_recoverFromInvalidParameters.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf612_recoverFromInvalidParameters.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Recover from regions where the function is not defined. ; We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form ; \[; \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; Before ROOT 6.24, RooFit always passed the highest function value that was encountered during the minimisation to the minimiser. If a parameter is far in a disallowed region, the minimiser has to blindly test various values of the parameters. It might find the correct values by chance, but often be unable to recover from bad starting values. Here, we use a model with such bad values.; Starting with ROOT 6.24, the minimiser receives more information. For example, when a PDF is negative, the magnitude of the ""undershoot"" is passed to the minimiser. The minimiser can use this to compute a gradient, which will eventually lead it out of the disallowed region. The steepness of this gradient can be chosen using RooFit::RecoverFromUndefinedRegions(double). A value of zero is equivalent to RooFit before ROOT 6.24. Positive values activate the recovery. Values between 1. and 10. were found to be a good default. If no argument is passed, RooFit uses 10.; ; #include <RooRealVar.h>; #include <RooPolynomial.h>; #include <RooPlot.h>; #include <RooDataSet.h>; #include <RooGlobalFunc.h>; #include <RooFitResult.h>; #include <RooMsgService.h>; ; #include <TCanvas.h>; #include <TLegend.h>; ; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:121,Load,Loading,121,doc/master/rf612__recoverFromInvalidParameters_8C.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf612_recoverFromInvalidParameters.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf612_recoverFromInvalidParameters.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Recover from regions where the function is not defined. ; We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form ; \[; \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; ; import ROOT; ; ; # Create a fit model:; # The polynomial is notoriously unstable, because it can quickly go negative.; # Since PDFs need to be positive, one often ends up with an unstable fit model.; x = ROOT.RooRealVar(""x"", ""x"", -15, 15); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -10.0, 20.0); a2 = ROOT.RooRealVar(""a2"", ""a2"", 0.2, -10.0, 20.0); a3 = ROOT.RooRealVar(""a3"", ""a3"", 0.01); pdf = ROOT.RooPolynomial(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, [a1, a2, a3]); ; # Create toy data with all-positive coefficients:; data = pdf.generate(x, 10000); ; # For plotting.; # We create pointers to the plotted objects. We want these objects to leak out of the function,; # so we can still see them after it returns.; c = ROOT.TCanvas(); frame = x.frame(); data.plotOn(frame, Name=""data""); ; # Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; # Therefore, we disable plotting messages in RooFit's message streams:; ROOT.RooMsgService.instance().getStream(0).removeTopic(ROOT.RooFit.Plotting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Plotting); ; ; # RooFit before ROOT 6.24; # ---------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:122,Load,Loading,122,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf613_global_observables.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf613_global_observables.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; This tutorial explains the concept of global observables in RooFit, and showcases how their values can be stored either in the model or in the dataset. . Introduction; Note: in this tutorial, we are multiplying the likelihood with an additional likelihood to constrain the parameters with auxiliary measurements. This is different from the rf604_constraints tutorial, where the likelihood is multiplied with a Bayesian prior to constrain the parameters.; With RooFit, you usually optimize some model parameters p to maximize the likelihood L given the per-event or per-bin observations x:. \[ L( x | p ) \]. Often, the parameters are constrained with some prior likelihood C, which doesn't depend on the observables x:. \[ L'( x | p ) = L( x | p ) * C( p ) \]. Usually, these constraint terms depend on some auxiliary measurements of other observables g. The constraint term is then the likelihood of the so-called global observables:. \[ L'( x | p ) = L( x | p ) * C( g | p ) \]. For example, think of a model where the true luminosity lumi is a nuisance parameter that is constrained by an auxiliary measurement lumi_obs with uncertainty lumi_obs_sigma:. \[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi_obs | lumi, lumi_obs_sigma) \]. As a Gaussian is symmetric under exchange of the observable and the mean parameter, you can also sometimes find this equivalent but less conventional formulation for Gaussian constraints:. \[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi | lumi_obs, lumi_obs_sigma) \]. If you wanted to constrain a parameter that represents event counts, you would use a Poissonian constraint, e.g.:. \[ L'(data | mu, count) = L(data | mu, count) * \text{Poisson}(count_obs | count) \]. Unlike a Gaussian, a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf613__global__observables_8C.html:111,Load,Loading,111,doc/master/rf613__global__observables_8C.html,https://root.cern,https://root.cern/doc/master/rf613__global__observables_8C.html,2,"['Load', 'optimiz']","['Loading', 'optimize']"
Performance,". ROOT: tutorials/roofit/rf613_global_observables.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf613_global_observables.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; This tutorial explains the concept of global observables in RooFit, and showcases how their values can be stored either in the model or in the dataset. . Introduction; Note: in this tutorial, we are multiplying the likelihood with an additional likelihood to constrain the parameters with auxiliary measurements. This is different from the rf604_constraints tutorial, where the likelihood is multiplied with a Bayesian prior to constrain the parameters.; With RooFit, you usually optimize some model parameters p to maximize the likelihood L given the per-event or per-bin observations x:. \[ L( x | p ) \]. Often, the parameters are constrained with some prior likelihood C, which doesn't depend on the observables x:. \[ L'( x | p ) = L( x | p ) * C( p ) \]. Usually, these constraint terms depend on some auxiliary measurements of other observables g. The constraint term is then the likelihood of the so-called global observables:. \[ L'( x | p ) = L( x | p ) * C( g | p ) \]. For example, think of a model where the true luminosity lumi is a nuisance parameter that is constrained by an auxiliary measurement lumi_obs with uncertainty lumi_obs_sigma:. \[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi_obs | lumi, lumi_obs_sigma) \]. As a Gaussian is symmetric under exchange of the observable and the mean parameter, you can also sometimes find this equivalent but less conventional formulation for Gaussian constraints:. \[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi | lumi_obs, lumi_obs_sigma) \]. If you wanted to constrain a parameter that represents event counts, you would use a Poissonian constraint, e.g.:. \[ L'(data | mu, count) = L(data | mu, count) * \text{Poisson}(count_obs | count) \]. Unlik",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf613__global__observables_8py.html:112,Load,Loading,112,doc/master/rf613__global__observables_8py.html,https://root.cern,https://root.cern/doc/master/rf613__global__observables_8py.html,2,"['Load', 'optimiz']","['Loading', 'optimize']"
Performance,". ROOT: tutorials/roofit/rf614_binned_fit_problems.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf614_binned_fit_problems.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; A tutorial that explains you how to solve problems with binning effects and numerical stability in binned fits. . Introduction; In this tutorial, you will learn three new things:. How to reduce the bias in binned fits by changing the definition of the normalization integral; How to completely get rid of binning effects by integrating the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; // Generate binned Asimov dataset for a continuous pdf.; // One should in principle be able to use; // pdf.generateBinned(x, nEvents, RooFit::ExpectedData()).; // Unfortunately it has a problem: it also has the bin bias that this tutorial; // demonstrates, to if we would use it, the biases would cancel out.; std::unique_ptr<RooDataHist> generateBinnedAsimov(RooAbsPdf const &pdf, RooRealVar &x, int nEvents); {; auto dataH = std::make_unique<RooDataHist>(""dataH"", ""dataH"", RooArgSet{x});; RooAbsBinning &xBinning = x.getBinning();; for (int iBin = 0; iBin < x.numBins(); ++iBin) {; x.setRange(""bin"", xBinning.binLow(iBin), xBinning.binHigh(iBin));; std::unique_ptr<RooAbsReal> integ{pdf.createIntegral(x, RooFit::NormSet(x), RooFit::Range(""bin""))};; integ->getVal();; dataH->set(iBin, nEvents * integ->getVal(), -1);; }; return dataH;; }; ; // Force numeric integration and do this numeric integration with the; // RooBinIntegrator, which sums the function values at the bin centers.; void enableBinIntegrator(RooAbsReal &func, int numBins); {; RooNumIntConfig customConfig(*func.getIntegratorConfig());; customConfig.method1D().setLabel(""RooBinIntegrator"");; customConfig.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", numBins);; func.setIntegra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:112,Load,Loading,112,doc/master/rf614__binned__fit__problems_8C.html,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf614_binned_fit_problems.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf614_binned_fit_problems.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; A tutorial that explains you how to solve problems with binning effects and numerical stability in binned fits. . Introduction; In this tutorial, you will learn three new things:. How to reduce the bias in binned fits by changing the definition of the normalization integral; How to completely get rid of binning effects by integrating the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; import ROOT; ; ; def generateBinnedAsimov(pdf, x, n_events):; """"""; Generate binned Asimov dataset for a continuous pdf.; One should in principle be able to use; pdf.generateBinned(x, n_events, RooFit::ExpectedData()).; Unfortunately it has a problem: it also has the bin bias that this tutorial; demonstrates, to if we would use it, the biases would cancel out.; """"""; data_h = ROOT.RooDataHist(""dataH"", ""dataH"", {x}); x_binning = x.getBinning(); ; for i_bin in range(x.numBins()):; x.setRange(""bin"", x_binning.binLow(i_bin), x_binning.binHigh(i_bin)); integ = pdf.createIntegral(x, NormSet=x, Range=""bin""); ROOT.SetOwnership(integ, True); integ.getVal(); data_h.set(i_bin, n_events * integ.getVal(), -1); ; return data_h; ; ; def enableBinIntegrator(func, num_bins):; """"""; Force numeric integration and do this numeric integration with the; RooBinIntegrator, which sums the function values at the bin centers.; """"""; custom_config = ROOT.RooNumIntConfig(func.getIntegratorConfig()); custom_config.method1D().setLabel(""RooBinIntegrator""); custom_config.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", num_bins); func.setIntegratorConfig(custom_config); func.forceNumInt(True); ; ; def disableBinIntegrator(func):; """"""; Reset the integra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:113,Load,Loading,113,doc/master/rf614__binned__fit__problems_8py.html,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf615_simulation_based_inference.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf615_simulation_based_inference.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Use Simulation Based Inference (SBI) in RooFit. ; This tutorial shows how to use SBI in ROOT. As reference distribution we choose a simple uniform distribution. The target distribution is chosen to be gaussian with different mean values. The classifier is trained to discriminate between the reference and target distribution. We see how the neural networks generalize to unknown mean values.; We compare the approach of using the likelihood ratio trick to morphing.; An introduction of SBI can be found in https://arxiv.org/pdf/2010.06439.; A short recap: The idea of SBI is to fit a surrogate model to the data, in order to really learn the likelihood function instead of calculating it. Therefore, a classifier is trained to discriminate between samples from a target distribution (here the Gaussian) $$x\sim p(x|\theta)$$ and a reference distribution (here the Uniform) $$x\sim p_{ref}(x|\theta)$$.; The output of the classifier $$\hat{s}(\theta)$$ is a monotonic function of the likelihood ration and can be turned into an estimate of the likelihood ratio via $$\hat{r}(\theta)=\frac{1-\hat{s}(\theta)}{\hat{s}(\theta)}.$$ This is called the likelihood ratio trick.; In the end we compare the negative logarithmic likelihoods of the learned, morphed and analytical likelihood with minuit and as a plot. ; import ROOT; import numpy as np; from sklearn.neural_network import MLPClassifier; ; # The samples used for training the classifier in this tutorial / rescale for more accuracy; n_samples = 10000; ; # Kills warning messages; ROOT.RooMsgService.instance().setGlobalKillBelow(ROOT.RooFit.WARNING); ; ; # Morphing as a baseline; def morphing(setting):; ; # Define binning for morphing; grid = ROOT.RooMomentMorphFuncND.Gr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html:120,Load,Loading,120,doc/master/rf615__simulation__based__inference_8py.html,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf616_morphing.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf616_morphing.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Use Morphing in RooFit. ; This tutorial shows how to use template morphing inside RooFit. As input we have several Gaussian distributions. The output is one gaussian, with a specific mean value. Since likelihoods are often used within the framework of morphing, we provide a way to estimate the negative log likelihood (nll).; Based on example of Kyle Cranmer https://gist.github.com/cranmer/b67830e46d53d5f7cf2d. ; #include ""RooRealVar.h""; #include ""RooRealVar.h""; #include ""RooWorkspace.h""; #include ""RooGaussian.h""; #include ""RooUniform.h""; #include ""RooDataSet.h""; #include ""RooPlot.h""; #include ""RooMomentMorphFuncND.h""; #include ""RooAbsPdf.h""; ; using namespace RooFit;; ; // Number of samples to fill the histograms; const int n_samples = 1000;; ; // Kills warning massages; RooMsgService::instance().setGlobalKillBelow(RooFit::WARNING);; ; // Define the morphing routine; RooPlot *perform_morphing(RooWorkspace &ws, RooMomentMorphFuncND::Setting setting, double sigma); {; // Get Variables from the workspace; RooRealVar *x_var = ws.var(""x"");; RooRealVar *mu_var = ws.var(""mu"");; RooAbsPdf *gauss = ws.pdf(""gauss"");; ; // Initialize a plot; RooPlot *frame1 = x_var->frame();; ; // Define binning for morphing; RooMomentMorphFuncND::Grid grid(RooBinning(4, 0.0, 4.0));; ; // Set binning of histograms, has to be customized for optimal results; x_var->setBins(50);; ; std::vector<int> parampoints = {0, 1, 2, 3, 4};; ; for (auto i : parampoints) {; // Define the sampled gaussians; RooRealVar mu_help(Form(""mu%d"", i), Form(""mu%d"", i), i);; // Use * because RooGaussian expects objects no pointers; RooGaussian help(Form(""g%d"", i), Form(""g%d"", i), *x_var, mu_help, sigma);; ws.import(help, Silence(true));; ; // Fill the histograms use a unique pointer to prevent memory lea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf616__morphing_8C.html:101,Load,Loading,101,doc/master/rf616__morphing_8C.html,https://root.cern,https://root.cern/doc/master/rf616__morphing_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf616_morphing.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf616_morphing.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Use Morphing in RooFit. ; This tutorial shows how to use template morphing inside RooFit. As input we have several Gaussian distributions. The output is one gaussian, with a specific mean value. Since likelihoods are often used within the framework of morphing, we provide a way to estimate the negative log likelihood (nll).; Based on example of Kyle Cranmer https://gist.github.com/cranmer/46fff8d22015e5a26619. ; ; import ROOT; ; # Number of samples to fill the histograms; n_samples = 1000; ; ; # Kills warning messages; ROOT.RooMsgService.instance().setGlobalKillBelow(ROOT.RooFit.WARNING); ; ; # morphing as a baseline; def morphing(setting):; # set up a frame for plotting; frame1 = x_var.frame(); ; # define binning for morphing; bin_mu_x = ROOT.RooBinning(4, 0.0, 4.0); grid = ROOT.RooMomentMorphFuncND.Grid(bin_mu_x); x_var.setBins(50); ; # number of 'sampled' Gaussians, if you change it, adjust the binning properly; for i in range(5):; # Create the sampled Gaussian; workspace.factory(f""Gaussian::g{i}(x, mu{i}[{i}], {sigma})"".format(i=i)); ; # Fill the histograms; hist = workspace[f""g{i}""].generateBinned([x_var], n_samples * 100); # Make sure that every bin is filled and we don't get zero probability; for i_bin in range(hist.numEntries()):; hist.add(hist.get(i_bin), 1.0); ; # Add the pdf to the workspace, the inOrder of 1 is necessary for calculation of the nll; # Adjust it to 0 to see binning; workspace.Import(ROOT.RooHistPdf(f""histpdf{i}"", f""histpdf{i}"", [x_var], hist, intOrder=1)); ; # Add the pdf to the grid and to the plot; grid.addPdf(workspace[f""histpdf{i}""], int(i)); workspace[f""histpdf{i}""].plotOn(frame1); ; # Create the morphing and add it to the workspace; morph_func = ROOT.RooMomentMorphFuncND(""morph_func"", ""morph_func"", [mu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf616__morphing_8py.html:102,Load,Loading,102,doc/master/rf616__morphing_8py.html,https://root.cern,https://root.cern/doc/master/rf616__morphing_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf617_simulation_based_inference_multidimensional.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf617_simulation_based_inference_multidimensional.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Use Simulation Based Inference (SBI) in multiple dimensions in RooFit. ; This tutorial shows how to use SBI in higher dimension in ROOT. This tutorial transfers the simple concepts of the 1D case introduced in rf615_simulation_based_inference.py onto the higher dimensional case.; Again as reference distribution we choose a simple uniform distribution. The target distribution is chosen to be Gaussian with different mean values. The classifier is trained to discriminate between the reference and target distribution. We see how the neural networks generalize to unknown mean values.; Furthermore, we compare SBI to the approach of moment morphing. In this case, we can conclude, that SBI is way more sample eficcient when it comes to estimating the negative log likelihood ratio.; For an introductory background see rf615_simulation_based_inference.py. ; import ROOT; import numpy as np; from sklearn.neural_network import MLPClassifier; import itertools; ; # Kills warning messages; ROOT.RooMsgService.instance().setGlobalKillBelow(ROOT.RooFit.WARNING); ; n_samples_morph = 10000 # Number of samples for morphing; n_bins = 4 # Number of 'sampled' Gaussians; n_samples_train = n_samples_morph * n_bins # To have a fair comparison; ; ; # Morphing as baseline; def morphing(setting, n_dimensions):; # Define binning for morphing; ; binning = [ROOT.RooBinning(n_bins, 0.0, n_bins - 1.0) for dim in range(n_dimensions)]; grid = ROOT.RooMomentMorphFuncND.Grid(*binning); ; # Set bins for each x variable; for x_var in x_vars:; x_var.setBins(50); ; # Define mu values as input for morphing for each dimension; mu_helps = [ROOT.RooRealVar(f""mu{i}"", f""mu{i}"", 0.0) for i in range(n_dimensions)]; ; #",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html:137,Load,Loading,137,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf618_mixture_models.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf618_mixture_models.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Use of mixture models in RooFit. ; This tutorial shows, how to use mixture models for Likelihood Calculation in ROOT. Instead of directly calculating the likelihood we use simulation based inference (SBI) as shown in tutorial 'rf615_simulation_based_inference.py'. We train the classifier to discriminate between samples from an background hypothesis here the zz samples and a target hypothesis, here the higgs samples. The data preparation is based on the tutorial 'df106_HiggsToFourLeptons.py'.; An introduction to mixture models can be found here https://arxiv.org/pdf/1506.02169.; A short summary: We assume the whole probability distribution can be written as a mixture of several components, i.e. $$p(x|\theta)= \sum_{c}w_{c}(\theta)p_{c}(x|\theta)$$ We can write the likelihood ratio in terms of pairwise classification problems \begin{align*} \frac{p(x|\mu)}{p(x|0)}&= \frac{\sum_{c}w_{c}(\mu)p_{c}(x|\mu)}{\sum_{c'}w_{c'}(0)p_{c'}(x|0)}\ &=\sum_{c}\Bigg[\sum_{c'}\frac{w_{c'}(0)}{w_{c}(\mu)}\frac{p_{c'}(x|0)}{p_{c}(x|\mu)}\Bigg]^{-1}, \end{align*} where mu is the signal strength, and a value of 0 corresponds to the background hypothesis. Using this decomposition, one is able to use the pairwise likelihood ratios.; Since the only free parameter in our case is mu, the distributions are independent of this parameter and the dependence on the signal strength can be encoded into the weights. Thus, the subratios simplify dramatically since they are independent of theta and these ratios can be pre-computed and the classifier does not need to be parametrized.; If you wish to see an analysis done with template histograms see 'hf001_example.py'.; ; import ROOT; import os; import numpy as np; import xgboost as xgb; ; # Get Dataframe from t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf618__mixture__models_8py.html:108,Load,Loading,108,doc/master/rf618__mixture__models_8py.html,https://root.cern,https://root.cern/doc/master/rf618__mixture__models_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf701_efficiencyfit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf701_efficiencyfit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: unbinned maximum likelihood fit of an efficiency eff(x) function ; to a dataset D(x,cut), where cut is a category encoding a selection, of which the efficiency as function of x should be described by eff(x). ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooConstVar.h""; #include ""RooFormulaVar.h""; #include ""RooProdPdf.h""; #include ""RooEfficiency.h""; #include ""RooPolynomial.h""; #include ""RooCategory.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf701_efficiencyfit(); {; // C o n s t r u c t e f f i c i e n c y f u n c t i o n e ( x ); // -------------------------------------------------------------------; ; // Declare variables x,mean,sigma with associated name, title, initial value and allowed range; RooRealVar x(""x"", ""x"", -10, 10);; ; // Efficiency function eff(x;a,b); RooRealVar a(""a"", ""a"", 0.4, 0, 1);; RooRealVar b(""b"", ""b"", 5);; RooRealVar c(""c"", ""c"", -1, -10, 10);; RooFormulaVar effFunc(""effFunc"", ""(1-a)+a*cos((x-c)/b)"", RooArgList(a, b, c, x));; ; // C o n s t r u c t c o n d i t i o n a l e f f i c i e n c y p d f E ( c u t | x ); // ------------------------------------------------------------------------------------------; ; // Acceptance state cut (1 or 0); RooCategory cut(""cut"", ""cutr"", { {""accept"", 1}, {""reject"", 0} });; ; // Construct efficiency pdf eff(cut|x); RooEfficiency effPdf(""effPdf"", ""effPdf"", effFunc, cut, ""accept"");; ; // G e n e r a t e d a t a ( x , c u t ) f r o m a t o y m o d e l; // -----------------------------------------------------------------------------; ; // Construct global shape pdf shape(x) and product model(x,cut) = eff(cut|x)*shape(x); // (These are _only_ needed to generate some toy MC here ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf701__efficiencyfit_8C.html:106,Load,Loading,106,doc/master/rf701__efficiencyfit_8C.html,https://root.cern,https://root.cern/doc/master/rf701__efficiencyfit_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf701_efficiencyfit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf701_efficiencyfit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: unbinned maximum likelihood fit of an efficiency eff(x) function to a dataset D(x,cut), cut is a category encoding a selection, which the efficiency as function of x should be described by eff(x) . ; import ROOT; ; ; # Construct efficiency function e(x); # -------------------------------------------------------------------; ; # Declare variables x,mean, with associated name, title, value and allowed; # range; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); ; # Efficiency function eff(x;a,b); a = ROOT.RooRealVar(""a"", ""a"", 0.4, 0, 1); b = ROOT.RooRealVar(""b"", ""b"", 5); c = ROOT.RooRealVar(""c"", ""c"", -1, -10, 10); effFunc = ROOT.RooFormulaVar(""effFunc"", ""(1-a)+a*cos((x-c)/b)"", [a, b, c, x]); ; # Construct conditional efficiency pdf E(cut|x); # ------------------------------------------------------------------------------------------; ; # Acceptance state cut (1 or 0); cut = ROOT.RooCategory(""cut"", ""cutr"", {""accept"": 1, ""reject"": 0}); ; # Construct efficiency pdf eff(cut|x); effPdf = ROOT.RooEfficiency(""effPdf"", ""effPdf"", effFunc, cut, ""accept""); ; # Generate data (x, cut) from a toy model; # -----------------------------------------------------------------------------; ; # Construct global shape pdf shape(x) and product model(x,cut) = eff(cut|x)*shape(x); # (These are _only_ needed to generate some toy MC here to be used later); shapePdf = ROOT.RooPolynomial(""shapePdf"", ""shapePdf"", x, [-0.095]); model = ROOT.RooProdPdf(""model"", ""model"", {shapePdf}, Conditional=({effPdf}, {cut})); ; # Generate some toy data from model; data = model.generate({x, cut}, 10000); ; # Fit conditional efficiency pdf to data; # --------------------------------------------------------------------------; ; # Fit conditional efficiency pdf to data; ef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf701__efficiencyfit_8py.html:107,Load,Loading,107,doc/master/rf701__efficiencyfit_8py.html,https://root.cern,https://root.cern/doc/master/rf701__efficiencyfit_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf702_efficiencyfit_2D.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf702_efficiencyfit_2D.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: unbinned maximum likelihood fit of an efficiency eff(x) function to a dataset D(x,cut), cut is a category encoding a selection whose efficiency as function of x should be described by eff(x) . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooConstVar.h""; #include ""RooCategory.h""; #include ""RooEfficiency.h""; #include ""RooPolynomial.h""; #include ""RooProdPdf.h""; #include ""RooFormulaVar.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf702_efficiencyfit_2D(bool flat = false); {; // C o n s t r u c t e f f i c i e n c y f u n c t i o n e ( x , y ); // -----------------------------------------------------------------------; ; // Declare variables x,mean,sigma with associated name, title, initial value and allowed range; RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar y(""y"", ""y"", -10, 10);; ; // Efficiency function eff(x;a,b); RooRealVar ax(""ax"", ""ay"", 0.6, 0, 1);; RooRealVar bx(""bx"", ""by"", 5);; RooRealVar cx(""cx"", ""cy"", -1, -10, 10);; ; RooRealVar ay(""ay"", ""ay"", 0.2, 0, 1);; RooRealVar by(""by"", ""by"", 5);; RooRealVar cy(""cy"", ""cy"", -1, -10, 10);; ; RooFormulaVar effFunc(""effFunc"", ""((1-ax)+ax*cos((x-cx)/bx))*((1-ay)+ay*cos((y-cy)/by))"",; RooArgList(ax, bx, cx, x, ay, by, cy, y));; ; // Acceptance state cut (1 or 0); RooCategory cut(""cut"", ""cutr"", { {""accept"", 1}, {""reject"", 0} });; ; // C o n s t r u c t c o n d i t i o n a l e f f i c i e n c y p d f E ( c u t | x , y ); // ---------------------------------------------------------------------------------------------; ; // Construct efficiency pdf eff(cut|x); RooEfficiency effPdf(""effPdf"", ""effPdf"", effFunc, cut, ""accept"");; ; // G e n e r a t e d a t a ( x , y , c u t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf702__efficiencyfit__2D_8C.html:109,Load,Loading,109,doc/master/rf702__efficiencyfit__2D_8C.html,https://root.cern,https://root.cern/doc/master/rf702__efficiencyfit__2D_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf702_efficiencyfit_2D.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf702_efficiencyfit_2D.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: unbinned maximum likelihood fit of an efficiency eff(x) function to a dataset D(x,cut), cut is a category encoding a selection whose efficiency as function of x should be described by eff(x) . ; import ROOT; ; ; flat = False; # Construct efficiency function e(x,y); # -----------------------------------------------------------------------; ; # Declare variables x,mean, with associated name, title, value and allowed; # range; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); y = ROOT.RooRealVar(""y"", ""y"", -10, 10); ; # Efficiency function eff(x;a,b); ax = ROOT.RooRealVar(""ax"", ""ay"", 0.6, 0, 1); bx = ROOT.RooRealVar(""bx"", ""by"", 5); cx = ROOT.RooRealVar(""cx"", ""cy"", -1, -10, 10); ; ay = ROOT.RooRealVar(""ay"", ""ay"", 0.2, 0, 1); by = ROOT.RooRealVar(""by"", ""by"", 5); cy = ROOT.RooRealVar(""cy"", ""cy"", -1, -10, 10); ; effFunc = ROOT.RooFormulaVar(; ""effFunc"", ""((1-ax)+ax*cos((x-cx)/bx))*((1-ay)+ay*cos((y-cy)/by))"", [ax, bx, cx, x, ay, by, cy, y]; ); ; # Acceptance state cut (1 or 0); cut = ROOT.RooCategory(""cut"", ""cutr"", {""accept"": 1, ""reject"": 0}); ; # Construct conditional efficiency pdf E(cut|x,y); # ---------------------------------------------------------------------------------------------; ; # Construct efficiency pdf eff(cut|x); effPdf = ROOT.RooEfficiency(""effPdf"", ""effPdf"", effFunc, cut, ""accept""); ; # Generate data(x,y,cut) from a toy model; # -------------------------------------------------------------------------------; ; # Construct global shape pdf shape(x) and product model(x,cut) = eff(cut|x)*shape(x); # (These are _only_ needed to generate some toy MC here to be used later); shapePdfX = ROOT.RooPolynomial(""shapePdfX"", ""shapePdfX"", x, [0 if flat else -0.095]); shapePdfY = ROOT.RooPolynomial(""shapePdfY"", ""shape",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf702__efficiencyfit__2D_8py.html:110,Load,Loading,110,doc/master/rf702__efficiencyfit__2D_8py.html,https://root.cern,https://root.cern/doc/master/rf702__efficiencyfit__2D_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf703_effpdfprod.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf703_effpdfprod.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: using a product of an (acceptance) efficiency and a pdf as pdf . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooConstVar.h""; #include ""RooExponential.h""; #include ""RooEffProd.h""; #include ""RooFormulaVar.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf703_effpdfprod(); {; // D e f i n e o b s e r v a b l e s a n d d e c a y p d f; // ---------------------------------------------------------------; ; // Declare observables; RooRealVar t(""t"", ""t"", 0, 5);; ; // Make pdf; RooRealVar tau(""tau"", ""tau"", -1.54, -4, -0.1);; RooExponential model(""model"", ""model"", t, tau);; ; // D e f i n e e f f i c i e n c y f u n c t i o n; // ---------------------------------------------------; ; // Use error function to simulate turn-on slope; RooFormulaVar eff(""eff"", ""0.5*(TMath::Erf((t-1)/0.5)+1)"", t);; ; // D e f i n e d e c a y p d f w i t h e f f i c i e n c y; // ---------------------------------------------------------------; ; // Multiply pdf(t) with efficiency in t; RooEffProd modelEff(""modelEff"", ""model with efficiency"", model, eff);; ; // P l o t e f f i c i e n c y , p d f; // ----------------------------------------; ; RooPlot *frame1 = t.frame(Title(""Efficiency""));; eff.plotOn(frame1, LineColor(kRed));; ; RooPlot *frame2 = t.frame(Title(""Pdf with and without efficiency""));; ; model.plotOn(frame2, LineStyle(kDashed));; modelEff.plotOn(frame2);; ; // G e n e r a t e t o y d a t a , f i t m o d e l E f f t o d a t a; // ------------------------------------------------------------------------------; ; // Generate events. If the input pdf has an internal generator, the internal generator; // is used and an accept/reject sampling on the efficiency is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf703__effpdfprod_8C.html:103,Load,Loading,103,doc/master/rf703__effpdfprod_8C.html,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf703_effpdfprod.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf703_effpdfprod.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: using a product of an (acceptance) efficiency and a pdf as pdf . ; import ROOT; ; ; # Define observables and decay pdf; # ---------------------------------------------------------------; ; # Declare observables; t = ROOT.RooRealVar(""t"", ""t"", 0, 5); ; # Make pdf; tau = ROOT.RooRealVar(""tau"", ""tau"", -1.54, -4, -0.1); model = ROOT.RooExponential(""model"", ""model"", t, tau); ; # Define efficiency function; # ---------------------------------------------------; ; # Use error function to simulate turn-on slope; eff = ROOT.RooFormulaVar(""eff"", ""0.5*(TMath::Erf((t-1)/0.5)+1)"", [t]); ; # Define decay pdf with efficiency; # ---------------------------------------------------------------; ; # Multiply pdf(t) with efficiency in t; modelEff = ROOT.RooEffProd(""modelEff"", ""model with efficiency"", model, eff); ; # Plot efficiency, pdf; # ----------------------------------------; ; frame1 = t.frame(Title=""Efficiency""); eff.plotOn(frame1, LineColor=""r""); ; frame2 = t.frame(Title=""Pdf with and without efficiency""); ; model.plotOn(frame2, LineStyle=""--""); modelEff.plotOn(frame2); ; # Generate toy data, fit model eff to data; # ------------------------------------------------------------------------------; ; # Generate events. If the input pdf has an internal generator, internal generator; # is used and an accept/reject sampling on the efficiency is applied.; data = modelEff.generate({t}, 10000); ; # Fit pdf. The normalization integral is calculated numerically.; modelEff.fitTo(data, PrintLevel=-1); ; # Plot generated data and overlay fitted pdf; frame3 = t.frame(Title=""Fitted pdf with efficiency""); data.plotOn(frame3); modelEff.plotOn(frame3); ; c = ROOT.TCanvas(""rf703_effpdfprod"", ""rf703_effpdfprod"", 1200, 400); c.Divide(3); c.cd(1); RO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf703__effpdfprod_8py.html:104,Load,Loading,104,doc/master/rf703__effpdfprod_8py.html,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf704_amplitudefit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf704_amplitudefit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: using a pdf defined by a sum of real-valued amplitude components . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooFormulaVar.h""; #include ""RooRealSumPdf.h""; #include ""RooPolyVar.h""; #include ""RooProduct.h""; #include ""TH1.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf704_amplitudefit(); {; // S e t u p 2 D a m p l i t u d e f u n c t i o n s; // -------------------------------------------------------; ; // Observables; RooRealVar t(""t"", ""time"", -1., 15.);; RooRealVar cosa(""cosa"", ""cos(alpha)"", -1., 1.);; ; RooRealVar tau(""tau"", ""#tau"", 1.5);; RooRealVar deltaGamma(""deltaGamma"", ""deltaGamma"", 0.3);; RooFormulaVar coshG(""coshGBasis"", ""exp(-@0/ @1)*cosh(@0*@2/2)"", {t, tau, deltaGamma});; RooFormulaVar sinhG(""sinhGBasis"", ""exp(-@0/ @1)*sinh(@0*@2/2)"", {t, tau, deltaGamma});; ; // Construct polynomial amplitudes in cos(a); RooPolyVar poly1(""poly1"", ""poly1"", cosa, RooArgList{0.5, 0.2, 0.2}, 0);; RooPolyVar poly2(""poly2"", ""poly2"", cosa, RooArgList{1.0, -0.2, 3.0}, 0);; ; // Construct 2D amplitude as uncorrelated product of amp(t)*amp(cosa); RooProduct ampl1(""ampl1"", ""amplitude 1"", {poly1, coshG});; RooProduct ampl2(""ampl2"", ""amplitude 2"", {poly2, sinhG});; ; // C o n s t r u c t a m p l i t u d e s u m p d f; // -----------------------------------------------------; ; // Amplitude strengths; RooRealVar f1(""f1"", ""f1"", 1, 0, 2);; RooRealVar f2(""f2"", ""f2"", 0.5, 0, 2);; ; // Construct pdf; RooRealSumPdf pdf(""pdf"", ""pdf"", RooArgList(ampl1, ampl2), RooArgList(f1, f2));; ; // Generate some toy data from pdf; std::unique_ptr<RooDataSet> data{pdf.generate({t, cosa}, 10000)};; ; // Fit pdf to toy data with only amplitude strength floating; pdf.fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf704__amplitudefit_8C.html:105,Load,Loading,105,doc/master/rf704__amplitudefit_8C.html,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf704_amplitudefit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf704_amplitudefit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: using a pdf defined by a sum of real-valued amplitude components . ; import ROOT; ; ; # Setup 2D amplitude functions; # -------------------------------------------------------; ; # Observables; t = ROOT.RooRealVar(""t"", ""time"", -1.0, 15.0); cosa = ROOT.RooRealVar(""cosa"", ""cos(alpha)"", -1.0, 1.0); ; tau = ROOT.RooRealVar(""tau"", ""#tau"", 1.5); deltaGamma = ROOT.RooRealVar(""deltaGamma"", ""deltaGamma"", 0.3); coshG = ROOT.RooFormulaVar(""coshGBasis"", ""exp(-@0/ @1)*cosh(@0*@2/2)"", [t, tau, deltaGamma]); sinhG = ROOT.RooFormulaVar(""sinhGBasis"", ""exp(-@0/ @1)*sinh(@0*@2/2)"", [t, tau, deltaGamma]); ; # Construct polynomial amplitudes in cos(a); poly1 = ROOT.RooPolyVar(""poly1"", ""poly1"", cosa, [0.5, 0.2, 0.2], 0); poly2 = ROOT.RooPolyVar(""poly2"", ""poly2"", cosa, [1.0, -0.2, 3.0], 0); ; # Construct 2D amplitude as uncorrelated product of amp(t)*amp(cosa); ampl1 = ROOT.RooProduct(""ampl1"", ""amplitude 1"", [poly1, coshG]); ampl2 = ROOT.RooProduct(""ampl2"", ""amplitude 2"", [poly2, sinhG]); ; # Construct amplitude sum pdf; # -----------------------------------------------------; ; # Amplitude strengths; f1 = ROOT.RooRealVar(""f1"", ""f1"", 1, 0, 2); f2 = ROOT.RooRealVar(""f2"", ""f2"", 0.5, 0, 2); ; # Construct pdf; pdf = ROOT.RooRealSumPdf(""pdf"", ""pdf"", [ampl1, ampl2], [f1, f2]); ; # Generate some toy data from pdf; data = pdf.generate({t, cosa}, 10000); ; # Fit pdf to toy data with only amplitude strength floating; pdf.fitTo(data, PrintLevel=-1); ; # Plot amplitude sum pdf; # -------------------------------------------; ; # Make 2D plots of amplitudes; hh_cos = ampl1.createHistogram(""hh_cos"", t, Binning=50, YVar=dict(var=cosa, Binning=50)); hh_sin = ampl2.createHistogram(""hh_sin"", t, Binning=50, YVar=dict(var=cosa, Binning=50)); hh_cos.SetLin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf704__amplitudefit_8py.html:106,Load,Loading,106,doc/master/rf704__amplitudefit_8py.html,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf705_linearmorph.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf705_linearmorph.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: linear interpolation between pdf shapes using the 'Alex Read' algorithm . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooIntegralMorph.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf705_linearmorph(); {; // C r e a t e e n d p o i n t p d f s h a p e s; // ------------------------------------------------------; ; // Observable; RooRealVar x(""x"", ""x"", -20, 20);; ; // Lower end point shape: a Gaussian; RooRealVar g1mean(""g1mean"", ""g1mean"", -10);; RooGaussian g1(""g1"", ""g1"", x, g1mean, 2.0);; ; // Upper end point shape: a Polynomial; RooPolynomial g2(""g2"", ""g2"", x, RooArgSet(-0.03, -0.001));; ; // C r e a t e i n t e r p o l a t i n g p d f; // -----------------------------------------------; ; // Create interpolation variable; RooRealVar alpha(""alpha"", ""alpha"", 0, 1.0);; ; // Specify sampling density on observable and interpolation variable; x.setBins(1000, ""cache"");; alpha.setBins(50, ""cache"");; ; // Construct interpolating pdf in (x,a) represent g1(x) at a=a_min; // and g2(x) at a=a_max; RooIntegralMorph lmorph(""lmorph"", ""lmorph"", g1, g2, x, alpha);; ; // P l o t i n t e r p o l a t i n g p d f a t v a r i o u s a l p h a; // -----------------------------------------------------------------------------; ; // Show end points as blue curves; RooPlot *frame1 = x.frame();; g1.plotOn(frame1);; g2.plotOn(frame1);; ; // Show interpolated shapes in red; alpha.setVal(0.125);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.25);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.375);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.50);; lmorph.plotOn(frame1, LineColor(kRed)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf705__linearmorph_8C.html:104,Load,Loading,104,doc/master/rf705__linearmorph_8C.html,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf705_linearmorph.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf705_linearmorph.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'SPECIAL PDFS' RooFit tutorial macro #705 ; Linear interpolation between p.d.f shapes using the 'Alex Read' algorithm. ; ; import ROOT; ; ; # Create end point pdf shapes; # ------------------------------------------------------; ; # Observable; x = ROOT.RooRealVar(""x"", ""x"", -20, 20); ; # Lower end point shape: a Gaussian; g1mean = ROOT.RooRealVar(""g1mean"", ""g1mean"", -10); g1 = ROOT.RooGaussian(""g1"", ""g1"", x, g1mean, 2.0); ; # Upper end point shape: a Polynomial; g2 = ROOT.RooPolynomial(""g2"", ""g2"", x, [-0.03, -0.001]); ; # Create interpolating pdf; # -----------------------------------------------; ; # Create interpolation variable; alpha = ROOT.RooRealVar(""alpha"", ""alpha"", 0, 1.0); ; # Specify sampling density on observable and interpolation variable; x.setBins(1000, ""cache""); alpha.setBins(50, ""cache""); ; # Construct interpolating pdf in (x,a) represent g1(x) at a=a_min; # and g2(x) at a=a_max; lmorph = ROOT.RooIntegralMorph(""lmorph"", ""lmorph"", g1, g2, x, alpha); ; # Plot interpolating pdf aat various alphas a l p h a; # -----------------------------------------------------------------------------; ; # Show end points as blue curves; frame1 = x.frame(); g1.plotOn(frame1); g2.plotOn(frame1); ; # Show interpolated shapes in red; alpha.setVal(0.125); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.25); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.375); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.50); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.625); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.75); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.875); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.95); lmorph.plotOn(frame1, LineColor=""r""); ; # Show 2D distribution of pdf(x,alpha); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf705__linearmorph_8py.html:105,Load,Loading,105,doc/master/rf705__linearmorph_8py.html,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf706_histpdf.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf706_histpdf.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: histogram-based pdfs and functions . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooHistPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf706_histpdf(); {; // C r e a t e p d f f o r s a m p l i n g; // ---------------------------------------------; ; RooRealVar x(""x"", ""x"", 0, 20);; RooPolynomial p(""p"", ""p"", x, RooArgList(0.01, -0.01, 0.0004));; ; // C r e a t e l o w s t a t s h i s t o g r a m; // ---------------------------------------------------; ; // Sample 500 events from p; x.setBins(20);; std::unique_ptr<RooDataSet> data1{p.generate(x, 500)};; ; // Create a binned dataset with 20 bins and 500 events; std::unique_ptr<RooDataHist> hist1{data1->binnedClone()};; ; // Represent data in dh as pdf in x; RooHistPdf histpdf1(""histpdf1"", ""histpdf1"", x, *hist1, 0);; ; // Plot unbinned data and histogram pdf overlaid; RooPlot *frame1 = x.frame(Title(""Low statistics histogram pdf""), Bins(100));; data1->plotOn(frame1);; histpdf1.plotOn(frame1);; ; // C r e a t e h i g h s t a t s h i s t o g r a m; // -----------------------------------------------------; ; // Sample 100000 events from p; x.setBins(10);; std::unique_ptr<RooDataSet> data2{p.generate(x, 100000)};; ; // Create a binned dataset with 10 bins and 100K events; std::unique_ptr<RooDataHist> hist2{data2->binnedClone()};; ; // Represent data in dh as pdf in x, apply 2nd order interpolation; RooHistPdf histpdf2(""histpdf2"", ""histpdf2"", x, *hist2, 2);; ; // Plot unbinned data and histogram pdf overlaid; RooPlot *frame2 = x.frame(Title(""High stats histogram pdf with interpolation""), Bins(100));; data2->plotOn(frame2);; histpdf2.plotOn(frame2);; ; TCanvas *c = new ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf706__histpdf_8C.html:100,Load,Loading,100,doc/master/rf706__histpdf_8C.html,https://root.cern,https://root.cern/doc/master/rf706__histpdf_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf706_histpdf.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf706_histpdf.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: histogram based pdfs and functions . ; import ROOT; ; ; # Create pdf for sampling; # ---------------------------------------------; ; x = ROOT.RooRealVar(""x"", ""x"", 0, 20); p = ROOT.RooPolynomial(""p"", ""p"", x, [0.01, -0.01, 0.0004]); ; # Create low stats histogram; # ---------------------------------------------------; ; # Sample 500 events from p; x.setBins(20); data1 = p.generate({x}, 500); ; # Create a binned dataset with 20 bins and 500 events; hist1 = data1.binnedClone(); ; # Represent data in dh as pdf in x; histpdf1 = ROOT.RooHistPdf(""histpdf1"", ""histpdf1"", {x}, hist1, 0); ; # Plot unbinned data and histogram pdf overlaid; frame1 = x.frame(Title=""Low statistics histogram pdf"", Bins=100); data1.plotOn(frame1); histpdf1.plotOn(frame1); ; # Create high stats histogram; # -----------------------------------------------------; ; # Sample 100000 events from p; x.setBins(10); data2 = p.generate({x}, 100000); ; # Create a binned dataset with 10 bins and 100K events; hist2 = data2.binnedClone(); ; # Represent data in dh as pdf in x, 2nd order interpolation; histpdf2 = ROOT.RooHistPdf(""histpdf2"", ""histpdf2"", {x}, hist2, 2); ; # Plot unbinned data and histogram pdf overlaid; frame2 = x.frame(Title=""High stats histogram pdf with interpolation"", Bins=100); data2.plotOn(frame2); histpdf2.plotOn(frame2); ; c = ROOT.TCanvas(""rf706_histpdf"", ""rf706_histpdf"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.8); frame2.Draw(); ; c.SaveAs(""rf706_histpdf.png""); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf706_histpdf.py. tutorialsroofitrf706_histp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf706__histpdf_8py.html:101,Load,Loading,101,doc/master/rf706__histpdf_8py.html,https://root.cern,https://root.cern/doc/master/rf706__histpdf_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf707_kernelestimation.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf707_kernelestimation.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: using non-parametric (multi-dimensional) kernel estimation pdfs . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooKeysPdf.h""; #include ""RooNDKeysPdf.h""; #include ""RooProdPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf707_kernelestimation(); {; // C r e a t e l o w s t a t s 1 - D d a t a s e t; // -------------------------------------------------------; ; // Create a toy pdf for sampling; RooRealVar x(""x"", ""x"", 0, 20);; RooPolynomial p(""p"", ""p"", x, RooArgList(0.01, -0.01, 0.0004));; ; // Sample 500 events from p; std::unique_ptr<RooDataSet> data1{p.generate(x, 200)};; ; // C r e a t e 1 - D k e r n e l e s t i m a t i o n p d f; // ---------------------------------------------------------------; ; // Create adaptive kernel estimation pdf. In this configuration the input data; // is mirrored over the boundaries to minimize edge effects in distribution; // that do not fall to zero towards the edges; RooKeysPdf kest1(""kest1"", ""kest1"", x, *data1, RooKeysPdf::MirrorBoth);; ; // An adaptive kernel estimation pdf on the same data without mirroring option; // for comparison; RooKeysPdf kest2(""kest2"", ""kest2"", x, *data1, RooKeysPdf::NoMirror);; ; // Adaptive kernel estimation pdf with increased bandwidth scale factor; // (promotes smoothness over detail preservation); RooKeysPdf kest3(""kest1"", ""kest1"", x, *data1, RooKeysPdf::MirrorBoth, 2);; ; // Plot kernel estimation pdfs with and without mirroring over data; RooPlot *frame = x.frame(Title(""Adaptive kernel estimation pdf with and w/o mirroring""), Bins(20));; data1->plotOn(frame);; kest1.plotOn(frame);; kest2.plotOn(frame, LineStyl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf707__kernelestimation_8C.html:109,Load,Loading,109,doc/master/rf707__kernelestimation_8C.html,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf707_kernelestimation.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf707_kernelestimation.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: using non-parametric (multi-dimensional) kernel estimation pdfs . ; import ROOT; ; ; # Create low stats 1D dataset; # -------------------------------------------------------; ; # Create a toy pdf for sampling; x = ROOT.RooRealVar(""x"", ""x"", 0, 20); p = ROOT.RooPolynomial(""p"", ""p"", x, [0.01, -0.01, 0.0004]); ; # Sample 500 events from p; data1 = p.generate({x}, 200); ; # Create 1D kernel estimation pdf; # ---------------------------------------------------------------; ; # Create adaptive kernel estimation pdf. In self configuration the input data; # is mirrored over the boundaries to minimize edge effects in distribution; # that do not fall to zero towards the edges; kest1 = ROOT.RooKeysPdf(""kest1"", ""kest1"", x, data1, ROOT.RooKeysPdf.MirrorBoth); ; # An adaptive kernel estimation pdf on the same data without mirroring option; # for comparison; kest2 = ROOT.RooKeysPdf(""kest2"", ""kest2"", x, data1, ROOT.RooKeysPdf.NoMirror); ; # Adaptive kernel estimation pdf with increased bandwidth scale factor; # (promotes smoothness over detail preservation); kest3 = ROOT.RooKeysPdf(""kest1"", ""kest1"", x, data1, ROOT.RooKeysPdf.MirrorBoth, 2); ; # Plot kernel estimation pdfs with and without mirroring over data; frame = x.frame(Title=""Adaptive kernel estimation pdf with and w/o mirroring"", Bins=20); data1.plotOn(frame); kest1.plotOn(frame); kest2.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Plot kernel estimation pdfs with regular and increased bandwidth; frame2 = x.frame(Title=""Adaptive kernel estimation pdf with regular, bandwidth""); kest1.plotOn(frame2); kest3.plotOn(frame2, LineColor=""m""); ; # Create low status 2D dataset; # -------------------------------------------------------; ; # Construct a 2D toy pdf for sam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf707__kernelestimation_8py.html:110,Load,Loading,110,doc/master/rf707__kernelestimation_8py.html,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf708_bphysics.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf708_bphysics.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: special decay pdf for B physics with mixing and/or CP violation . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooConstVar.h""; #include ""RooCategory.h""; #include ""RooBMixDecay.h""; #include ""RooBCPEffDecay.h""; #include ""RooBDecay.h""; #include ""RooFormulaVar.h""; #include ""RooTruthModel.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf708_bphysics(); {; // -------------------------------------; // B - D e c a y w i t h m i x i n g; // =====================================; ; // C o n s t r u c t p d f; // -------------------------; ; // Observable; RooRealVar dt(""dt"", ""dt"", -10, 10);; dt.setBins(40);; ; // Parameters; RooRealVar dm(""dm"", ""delta m(B0)"", 0.472);; RooRealVar tau(""tau"", ""tau (B0)"", 1.547);; RooRealVar w(""w"", ""flavour mistag rate"", 0.1);; RooRealVar dw(""dw"", ""delta mistag rate for B0/B0bar"", 0.1);; ; RooCategory mixState(""mixState"", ""B0/B0bar mixing state"");; mixState.defineType(""mixed"", -1);; mixState.defineType(""unmixed"", 1);; ; RooCategory tagFlav(""tagFlav"", ""Flavour of the tagged B0"");; tagFlav.defineType(""B0"", 1);; tagFlav.defineType(""B0bar"", -1);; ; // Use delta function resolution model; RooTruthModel truthModel(""tm"", ""truth model"", dt);; ; // Construct Bdecay with mixing; RooBMixDecay bmix(""bmix"", ""decay"", dt, mixState, tagFlav, tau, dm, w, dw, truthModel, RooBMixDecay::DoubleSided);; ; // P l o t p d f i n v a r i o u s s l i c e s; // ---------------------------------------------------; ; // Generate some data; std::unique_ptr<RooDataSet> data{bmix.generate({dt, mixState, tagFlav}, 10000)};; ; // Plot B0 and B0bar tagged data separately; // For all plots below B0 and B0 tagged data will look somewhat differently; // if th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf708__bphysics_8C.html:101,Load,Loading,101,doc/master/rf708__bphysics_8C.html,https://root.cern,https://root.cern/doc/master/rf708__bphysics_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf708_bphysics.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf708_bphysics.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: special decay pdf for B physics with mixing and/or CP violation . ; import ROOT; ; ; # B-decay with mixing; # -------------------------; ; # Construct pdf; # -------------------------; ; # Observable; dt = ROOT.RooRealVar(""dt"", ""dt"", -10, 10); dt.setBins(40); ; # Parameters; dm = ROOT.RooRealVar(""dm"", ""delta m(B0)"", 0.472); tau = ROOT.RooRealVar(""tau"", ""tau (B0)"", 1.547); w = ROOT.RooRealVar(""w"", ""flavour mistag rate"", 0.1); dw = ROOT.RooRealVar(""dw"", ""delta mistag rate for B0/B0bar"", 0.1); ; mixState = ROOT.RooCategory(""mixState"", ""B0/B0bar mixing state"", {""mixed"": -1, ""unmixed"": 1}); ; tagFlav = ROOT.RooCategory(""tagFlav"", ""Flavour of the tagged B0"", {""B0"": 1, ""B0bar"": -1}); ; # Use delta function resolution model; tm = ROOT.RooTruthModel(""tm"", ""truth model"", dt); ; # Construct Bdecay with mixing; bmix = ROOT.RooBMixDecay(""bmix"", ""decay"", dt, mixState, tagFlav, tau, dm, w, dw, tm, type=""DoubleSided""); ; # Plot pdf in various slices; # ---------------------------------------------------; ; # Generate some data; data = bmix.generate({dt, mixState, tagFlav}, 10000); ; # Plot B0 and B0bar tagged data separately; # For all plots below B0 and B0 tagged data will look somewhat differently; # if the flavor tagging mistag rate for B0 and B0 is different (i.e. dw!=0); frame1 = dt.frame(Title=""B decay distribution with mixing (B0/B0bar)""); ; data.plotOn(frame1, Cut=""tagFlav==tagFlav::B0""); bmix.plotOn(frame1, Slice=(tagFlav, ""B0"")); ; data.plotOn(frame1, Cut=""tagFlav==tagFlav::B0bar"", MarkerColor=""c""); bmix.plotOn(frame1, Slice=(tagFlav, ""B0bar""), LineColor=""c""); ; # Plot mixed slice for B0 and B0bar tagged data separately; frame2 = dt.frame(Title=""B decay distribution of mixed events (B0/B0bar)""); ; data.plotOn(frame2, Cut=""mix",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf708__bphysics_8py.html:102,Load,Loading,102,doc/master/rf708__bphysics_8py.html,https://root.cern,https://root.cern/doc/master/rf708__bphysics_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf709_BarlowBeeston.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf709_BarlowBeeston.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Implementing the Barlow-Beeston method for taking into account the statistical uncertainty of a Monte-Carlo fit template. . ; #include ""RooRealVar.h""; #include ""RooGaussian.h""; #include ""RooUniform.h""; #include ""RooDataSet.h""; #include ""RooDataHist.h""; #include ""RooHistFunc.h""; #include ""RooRealSumPdf.h""; #include ""RooParamHistFunc.h""; #include ""RooHistConstraint.h""; #include ""RooProdPdf.h""; #include ""RooPlot.h""; ; #include ""TCanvas.h""; #include ""TPaveText.h""; ; #include <iostream>; #include <memory>; ; using namespace RooFit;; ; void rf709_BarlowBeeston(); {; // First, construct a likelihood model with a Gaussian signal on top of a uniform background; RooRealVar x(""x"", ""x"", -20, 20);; x.setBins(25);; ; RooRealVar meanG(""meanG"", ""meanG"", 1, -10, 10);; RooRealVar sigG(""sigG"", ""sigG"", 1.5, -10, 10);; RooGaussian g(""g"", ""Gauss"", x, meanG, sigG);; RooUniform u(""u"", ""Uniform"", x);; ; ; // Generate the data to be fitted; std::unique_ptr<RooDataSet> sigData(g.generate(x, 50));; std::unique_ptr<RooDataSet> bkgData(u.generate(x, 1000));; ; RooDataSet sumData(""sumData"", ""Gauss + Uniform"", x);; sumData.append(*sigData);; sumData.append(*bkgData);; ; ; // Make histogram templates for signal and background.; // Let's take a signal distribution with low statistics and a more accurate; // background distribution.; // Normally, these come from Monte Carlo simulations, but we will just generate them.; std::unique_ptr<RooDataHist> dh_sig( g.generateBinned(x, 50) );; std::unique_ptr<RooDataHist> dh_bkg( u.generateBinned(x, 10000) );; ; ; // ***** Case 0 - 'Rigid templates' *****; ; // Construct histogram shapes for signal and background; RooHistFunc p_h_sig(""p_h_sig"",""p_h_sig"",x,*dh_sig);; RooHistFunc p_h_bkg(""p_h_bkg"",""p_h_bkg"",x,*dh_bkg);; ; // Construct s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:106,Load,Loading,106,doc/master/rf709__BarlowBeeston_8C.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf709_BarlowBeeston.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf709_BarlowBeeston.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Implementing the Barlow-Beeston method for taking into account the statistical uncertainty of a Monte-Carlo fit template. . ; ; import ROOT; ; # First, construct a likelihood model with a Gaussian signal on top of a uniform background; x = ROOT.RooRealVar(""x"", ""x"", -20, 20); x.setBins(25); ; meanG = ROOT.RooRealVar(""meanG"", ""meanG"", 1, -10, 10); sigG = ROOT.RooRealVar(""sigG"", ""sigG"", 1.5, -10, 10); g = ROOT.RooGaussian(""g"", ""Gauss"", x, meanG, sigG); u = ROOT.RooUniform(""u"", ""Uniform"", x); ; ; # Generate the data to be fitted; sigData = g.generate(x, 50); bkgData = u.generate(x, 1000); ; sumData = ROOT.RooDataSet(""sumData"", ""Gauss + Uniform"", x); sumData.append(sigData); sumData.append(bkgData); ; ; # Make histogram templates for signal and background.; # Let's take a signal distribution with low statistics and a more accurate; # background distribution.; # Normally, these come from Monte Carlo simulations, but we will just generate them.; dh_sig = g.generateBinned(x, 50); dh_bkg = u.generateBinned(x, 10000); ; ; # Case 0 - 'Rigid templates'; ; # Construct histogram shapes for signal and background; p_h_sig = ROOT.RooHistFunc(""p_h_sig"", ""p_h_sig"", x, dh_sig); p_h_bkg = ROOT.RooHistFunc(""p_h_bkg"", ""p_h_bkg"", x, dh_bkg); ; # Construct scale factors for adding the two distributions; Asig0 = ROOT.RooRealVar(""Asig"", ""Asig"", 1, 0.01, 5000); Abkg0 = ROOT.RooRealVar(""Abkg"", ""Abkg"", 1, 0.01, 5000); ; # Construct the sum model; model0 = ROOT.RooRealSumPdf(""model0"", ""model0"", [p_h_sig, p_h_bkg], [Asig0, Abkg0], True); ; ; # Case 1 - 'Barlow Beeston'; ; # Construct parameterized histogram shapes for signal and background; p_ph_sig1 = ROOT.RooParamHistFunc(""p_ph_sig"", ""p_ph_sig"", dh_sig, x); p_ph_bkg1 = ROOT.RooParamHistFunc(""p_ph_bkg"", """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8py.html:107,Load,Loading,107,doc/master/rf709__BarlowBeeston_8py.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf710_roopoly.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf710_roopoly.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Taylor expansion of RooFit functions using the taylorExpand function with RooPolyFunc . ; #include ""RooRealVar.h""; #include ""RooPolyFunc.h""; #include ""RooAbsCollection.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; ; using namespace RooFit;; ; void rf710_roopoly(); {; // C r e a t e p o l y n o m i a l; // f u n c t i o n o f f o u r t h o r d e r; // ---------------------------------------------; // x^4 - 5x^3 + 5x^2 + 5x -6; // ---------------------------------------------; ; RooRealVar x(""x"", ""x"", 0, -3, 10);; RooPolyFunc f(""f"", ""f"", RooArgSet(x));; f.addTerm(+1, x, 4);; f.addTerm(-5, x, 3);; f.addTerm(+5, x, 2);; f.addTerm(+5, x, 1);; f.addTerm(-6, x, 0);; ; // C r e a t e t a y l o r e x p a n s i o n; // ---------------------------------------------; double x0 = 2.0;; auto taylor_o1 = RooPolyFunc::taylorExpand(""taylor_o1"", ""taylor expansion order 1"", f, {x}, 1, {x0});; auto taylor_o2 = RooPolyFunc::taylorExpand(""taylor_o2"", ""taylor expansion order 2"", f, {x}, 2, {x0});; ; // Plot polynomial with first and second order taylor expansion overlaid; auto frame = x.frame(Title(""x^{4} - 5x^{3} + 5x^{2} + 5x - 6""));; auto c = new TCanvas(""rf710_roopoly"", ""rf710_roopoly"", 400, 400);; c->cd();; ; f.plotOn(frame, Name(""f""));; taylor_o1->plotOn(frame, LineColor(kRed), LineStyle(kDashed), Name(""taylor_o1""));; taylor_o2->plotOn(frame, LineColor(kRed - 9), LineStyle(kDotted), Name(""taylor_o2""));; ; frame->SetMinimum(-8.0);; frame->SetMaximum(+8.0);; frame->SetYTitle(""function value"");; frame->Draw();; ; auto legend = new TLegend(0.53, 0.7, 0.86, 0.87);; legend->SetFillColor(kWhite);; legend->SetLineColor(kWhite);; legend->SetTextSize(0.02);; legend->AddEntry(""taylor_o1"", ""Taylor expansion upto first order"", ""L"");; legend->AddEntry(""taylor_o2"", ""Taylor expansi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf710__roopoly_8C.html:100,Load,Loading,100,doc/master/rf710__roopoly_8C.html,https://root.cern,https://root.cern/doc/master/rf710__roopoly_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf710_roopoly.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf710_roopoly.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Taylor expansion of RooFit functions using the taylorExpand function . ; import ROOT; ; # Create functions; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; x = ROOT.RooRealVar(""x"", ""x"", 0.0, -3, 10); ; # RooPolyFunc polynomial; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; # x ^ 4 - 5x ^ 3 + 5x ^ 2 + 5x - 6; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; f = ROOT.RooPolyFunc(""f"", ""f"", ROOT.RooArgList(x)); f.addTerm(+1, x, 4); f.addTerm(-5, x, 3); f.addTerm(+5, x, 2); f.addTerm(+5, x, 1); f.addTerm(-6, x, 0); ; f = ROOT.RooFormulaVar(""f"", ""f"", ""pow(@0,4) -5 * pow(@0,3) +5 * pow(@0,2) + 5 * pow(@0,1) - 6"", [x]); # taylor expand around x0 = 0; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; x0 = 2.0; taylor_o1 = ROOT.RooPolyFunc.taylorExpand(""taylorfunc_o1"", ""taylor expansion order 1"", f, [x], 1, [x0]); ROOT.SetOwnership(taylor_o1, True); taylor_o2 = ROOT.RooPolyFunc.taylorExpand(""taylorfunc_o2"", ""taylor expansion order 2"", f, [x], 2, [x0]); ROOT.SetOwnership(taylor_o2, True); frame = x.frame(Title=""x^{4} - 5x^{3} + 5x^{2} + 5x - 6""); c = ROOT.TCanvas(""c"", ""c"", 400, 400); ; f.plotOn(frame, Name=""f""); taylor_o1.plotOn(frame, Name=""taylor_o1"", LineColor=""kRed"", LineStyle=""kDashed""); taylor_o2.plotOn(frame, Name=""taylor_o2"", LineColor=""kRed - 9"", LineStyle=""kDotted""); ; c.cd(); frame.SetMinimum(-8.0); frame.SetMaximum(+8.0); frame.SetYTitle(""function value""); frame.Draw(); ; legend = ROOT.TLegend(0.53, 0.73, 0.86, 0.87); legend.SetFillColor(ROOT.kWhite); legend.SetLineColor(ROOT.kWhite); legend.SetTextSize(0.02); legend.AddEntry(""taylor_o1"", ""Taylor exp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf710__roopoly_8py.html:101,Load,Loading,101,doc/master/rf710__roopoly_8py.html,https://root.cern,https://root.cern/doc/master/rf710__roopoly_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf711_lagrangianmorph.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf711_lagrangianmorph.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Morphing effective field theory distributions with RooLagrangianMorphFunc A morphing function as a function of one coefficient is setup and can be used to obtain the distribution for any value of the coefficient. . ; #include <RooAbsCollection.h>; #include <RooDataHist.h>; #include <RooDataSet.h>; #include <RooLagrangianMorphFunc.h>; #include <RooPlot.h>; #include <RooRealVar.h>; ; #include <TCanvas.h>; #include <TColor.h>; #include <TFile.h>; #include <TFolder.h>; #include <TH1.h>; #include <TLegend.h>; #include <TStyle.h>; ; using namespace RooFit;; ; void rf711_lagrangianmorph(); {; // C r e a t e v a r i a b l e s f o r; // m o r p h i n g f u n c t i o n; // ---------------------------------------------; ; std::string observablename = ""pTV"";; ; // Setup observable that is morphed; RooRealVar obsvar(observablename.c_str(), ""p_{T}^{V}"", 10, 600);; ; // Setup two couplings that enters the morphing function; // kSM -> SM coupling set to constant (1); // cHq3 -> EFT parameter with NewPhysics attribute set to true; RooRealVar kSM(""kSM"", ""sm modifier"", 1.0);; RooRealVar cHq3(""cHq3"", ""EFT modifier"", 0.0, 1.0);; cHq3.setAttribute(""NewPhysics"", true);; ; // I n p u t s n e e d e d f o r c o n f i g; // ---------------------------------------------; std::string infilename = std::string(gROOT->GetTutorialDir()) + ""/roofit/input_histos_rf_lagrangianmorph.root"";; std::vector<std::string> samplelist = {""SM_NPsq0"", ""cHq3_NPsq1"", ""cHq3_NPsq2""};; ; // S e t u p C o n f i g; // ---------------------------------------------; RooLagrangianMorphFunc::Config config;; config.fileName = infilename;; config.observableName = observablename;; config.folderNames = samplelist;; config.couplings.add(cHq3);; config.couplings.add(kSM);; ; // C r e a t e m o r p h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf711__lagrangianmorph_8C.html:108,Load,Loading,108,doc/master/rf711__lagrangianmorph_8C.html,https://root.cern,https://root.cern/doc/master/rf711__lagrangianmorph_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf711_lagrangianmorph.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf711_lagrangianmorph.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Morphing effective field theory distributions with RooLagrangianMorphFunc. ; A morphing function as a function of one coefficient is setup and can be used to obtain the distribution for any value of the coefficient. ; import ROOT; ; ROOT.gStyle.SetOptStat(0); ROOT.PyConfig.IgnoreCommandLineOptions = True; ROOT.gROOT.SetBatch(True); ; # Create functions; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; observablename = ""pTV""; ; # Setup observable that is to be morphed; obsvar = ROOT.RooRealVar(observablename, ""p_{T}^{V}"", 10, 600); ; # Setup two couplings that enters the morphing function; # kSM -> SM coupling set to constant (1); # cHq3 -> EFT parameter with NewPhysics attribute set to true; kSM = ROOT.RooRealVar(""kSM"", ""sm modifier"", 1.0); cHq3 = ROOT.RooRealVar(""cHq3"", ""EFT modifier"", 0.0, 1.0); cHq3.setAttribute(""NewPhysics"", True); ; # Inputs to setup config; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; infilename = ROOT.gROOT.GetTutorialDir().Data() + ""/roofit/input_histos_rf_lagrangianmorph.root""; par = ""cHq3""; samplelist = [""SM_NPsq0"", ""cHq3_NPsq1"", ""cHq3_NPsq2""]; ; # Set Config; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; config = ROOT.RooLagrangianMorphFunc.Config(); config.fileName = infilename; config.observableName = observablename; config.folderNames = samplelist; config.couplings.add(cHq3); config.couplings.add(kSM); ; ; # Create morphing function; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; morphfunc = ROOT.RooLagrangianMorphFunc(""morphfunc"", ""morphed dist. of pTV"", config); ; # Get morphed distribution at c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf711__lagrangianmorph_8py.html:109,Load,Loading,109,doc/master/rf711__lagrangianmorph_8py.html,https://root.cern,https://root.cern/doc/master/rf711__lagrangianmorph_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf712_lagrangianmorphfit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf712_lagrangianmorphfit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Performing a simple fit with RooLagrangianMorphFunc. ; a morphing function is setup as a function of three variables and a fit is performed on a pseudo-dataset. ; #include <RooDataHist.h>; #include <RooFitResult.h>; #include <RooLagrangianMorphFunc.h>; #include <RooPlot.h>; #include <RooRealVar.h>; ; #include <TAxis.h>; #include <TCanvas.h>; #include <TH2.h>; #include <TStyle.h>; ; using namespace RooFit;; ; void rf712_lagrangianmorphfit(); {; // C r e a t e v a r i a b l e s f o r; // m o r p h i n g f u n c t i o n; // ---------------------------------------------; ; std::string observablename = ""pTV"";; RooRealVar obsvar(observablename.c_str(), ""observable of pTV"", 10, 600);; RooRealVar kSM(""kSM"", ""sm modifier"", 1.0);; RooRealVar cHq3(""cHq3"", ""EFT modifier"", -10.0, 10.0);; cHq3.setAttribute(""NewPhysics"", true);; RooRealVar cHl3(""cHl3"", ""EFT modifier"", -10.0, 10.0);; cHl3.setAttribute(""NewPhysics"", true);; RooRealVar cHDD(""cHDD"", ""EFT modifier"", -10.0, 10.0);; cHDD.setAttribute(""NewPhysics"", true);; ; // I n p u t s n e e d e d f o r c o n f i g; // ---------------------------------------------; std::string infilename = std::string(gROOT->GetTutorialDir()) + ""/roofit/input_histos_rf_lagrangianmorph.root"";; std::vector<std::string> samplelist = {""SM_NPsq0"", ""cHq3_NPsq1"", ""cHq3_NPsq2"", ""cHl3_NPsq1"",; ""cHl3_NPsq2"", ""cHDD_NPsq1"", ""cHDD_NPsq2"", ""cHl3_cHDD_NPsq2"",; ""cHq3_cHDD_NPsq2"", ""cHl3_cHq3_NPsq2""};; ; // S e t u p C o n f i g; // ---------------------------------------------; RooLagrangianMorphFunc::Config config;; config.fileName = infilename;; config.observableName = observablename;; config.folderNames = samplelist;; config.couplings.add(cHq3);; config.couplings.add(cHl3);; config.couplings.add(cHDD);; config.couplings.add(kSM)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:111,Load,Loading,111,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,3,"['Load', 'Perform', 'perform']","['Loading', 'Performing', 'performed']"
Performance,". ROOT: tutorials/roofit/rf712_lagrangianmorphfit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf712_lagrangianmorphfit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Performing a simple fit with RooLagrangianMorphFunc . ; import ROOT; ; ROOT.gStyle.SetOptStat(0); ROOT.PyConfig.IgnoreCommandLineOptions = True; ROOT.gROOT.SetBatch(True); ; # Create functions; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; observablename = ""pTV""; obsvar = ROOT.RooRealVar(observablename, ""observable of pTV"", 10, 600); ; # Setup three EFT coefficient and constant SM modifier; kSM = ROOT.RooRealVar(""kSM"", ""sm modifier"", 1.0); cHq3 = ROOT.RooRealVar(""cHq3"", ""EFT modifier"", -10.0, 10.0); cHq3.setAttribute(""NewPhysics"", True); cHl3 = ROOT.RooRealVar(""cHl3"", ""EFT modifier"", -10.0, 10.0); cHl3.setAttribute(""NewPhysics"", True); cHDD = ROOT.RooRealVar(""cHDD"", ""EFT modifier"", -10.0, 10.0); cHDD.setAttribute(""NewPhysics"", True); ; # Inputs to setup config; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; infilename = ROOT.gROOT.GetTutorialDir().Data() + ""/roofit/input_histos_rf_lagrangianmorph.root""; par = ""cHq3""; samplelist = [; ""SM_NPsq0"",; ""cHq3_NPsq1"",; ""cHq3_NPsq2"",; ""cHl3_NPsq1"",; ""cHl3_NPsq2"",; ""cHDD_NPsq1"",; ""cHDD_NPsq2"",; ""cHl3_cHDD_NPsq2"",; ""cHq3_cHDD_NPsq2"",; ""cHl3_cHq3_NPsq2"",; ]; ; # Set Config; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; config = ROOT.RooLagrangianMorphFunc.Config(); config.fileName = infilename; config.observableName = observablename; config.folderNames = samplelist; config.couplings.add(cHq3); config.couplings.add(cHDD); config.couplings.add(cHl3); config.couplings.add(kSM); ; ; # Create morphing function; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; morphfunc = ROOT.RooLagrangianM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8py.html:112,Load,Loading,112,doc/master/rf712__lagrangianmorphfit_8py.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8py.html,2,"['Load', 'Perform']","['Loading', 'Performing']"
Performance,". ROOT: tutorials/roofit/rf801_mcstudy.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf801_mcstudy.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Validation and MC studies: toy Monte Carlo study that perform cycles of event generation and fitting . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooAddPdf.h""; #include ""RooMCStudy.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH2.h""; #include ""RooFitResult.h""; #include ""TStyle.h""; #include ""TDirectory.h""; ; using namespace RooFit;; ; void rf801_mcstudy(); {; // C r e a t e m o d e l; // -----------------------; ; // Declare observable x; RooRealVar x(""x"", ""x"", 0, 10);; x.setBins(40);; ; // Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and their parameters; RooRealVar mean(""mean"", ""mean of gaussians"", 5, 0, 10);; RooRealVar sigma1(""sigma1"", ""width of gaussians"", 0.5);; RooRealVar sigma2(""sigma2"", ""width of gaussians"", 1);; ; RooGaussian sig1(""sig1"", ""Signal component 1"", x, mean, sigma1);; RooGaussian sig2(""sig2"", ""Signal component 2"", x, mean, sigma2);; ; // Build Chebychev polynomial pdf; RooRealVar a0(""a0"", ""a0"", 0.5, 0., 1.);; RooRealVar a1(""a1"", ""a1"", -0.2, -1, 1.);; RooChebychev bkg(""bkg"", ""Background"", x, RooArgSet(a0, a1));; ; // Sum the signal components into a composite signal pdf; RooRealVar sig1frac(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0., 1.);; RooAddPdf sig(""sig"", ""Signal"", RooArgList(sig1, sig2), sig1frac);; ; // Sum the composite signal and background; RooRealVar nbkg(""nbkg"", ""number of background events,"", 150, 0, 1000);; RooRealVar nsig(""nsig"", ""number of signal events"", 150, 0, 1000);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), RooArgList(nbkg, nsig));; ; // C r e a t e m a n a g e r; // ---------------------------; ; // Instantiate RooMCStudy manager on model with x as observable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf801__mcstudy_8C.html:100,Load,Loading,100,doc/master/rf801__mcstudy_8C.html,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html,2,"['Load', 'perform']","['Loading', 'perform']"
Performance,". ROOT: tutorials/roofit/rf801_mcstudy.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf801_mcstudy.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Validation and MC studies: toy Monte Carlo study that perform cycles of event generation and fitting . ; import ROOT; ; ; # Create model; # -----------------------; ; # Declare observable x; x = ROOT.RooRealVar(""x"", ""x"", 0, 10); x.setBins(40); ; # Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and; # their parameters; mean = ROOT.RooRealVar(""mean"", ""mean of gaussians"", 5, 0, 10); sigma1 = ROOT.RooRealVar(""sigma1"", ""width of gaussians"", 0.5); sigma2 = ROOT.RooRealVar(""sigma2"", ""width of gaussians"", 1); ; sig1 = ROOT.RooGaussian(""sig1"", ""Signal component 1"", x, mean, sigma1); sig2 = ROOT.RooGaussian(""sig2"", ""Signal component 2"", x, mean, sigma2); ; # Build Chebychev polynomial pdf; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.2, -1, 1.0); bkg = ROOT.RooChebychev(""bkg"", ""Background"", x, [a0, a1]); ; # Sum the signal components into a composite signal pdf; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; nbkg = ROOT.RooRealVar(""nbkg"", ""number of background events, "", 150, 0, 1000); nsig = ROOT.RooRealVar(""nsig"", ""number of signal events"", 150, 0, 1000); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [nbkg, nsig]); ; # Create manager; # ---------------------------; ; # Instantiate ROOT.RooMCStudy manager on model with x as observable and given choice of fit options; #; # The Silence() option kills all messages below the PROGRESS level, only a single message; # per sample executed, any error message that occur during fitting; #; # The Extended() option has two effects:; # 1) The extended ML term is included in the likelihood an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf801__mcstudy_8py.html:101,Load,Loading,101,doc/master/rf801__mcstudy_8py.html,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8py.html,2,"['Load', 'perform']","['Loading', 'perform']"
Performance,". ROOT: tutorials/roofit/rf802_mcstudy_addons.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf802_mcstudy_addons.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Validation and MC studies: RooMCStudy - using separate fit and generator models, using the chi^2 calculator model Running a biased fit model against an optimal fit. . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooAddPdf.h""; #include ""RooMCStudy.h""; #include ""RooChi2MCSModule.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; #include ""TDirectory.h""; #include ""TLegend.h""; ; using namespace RooFit;; ; void rf802_mcstudy_addons(); {; ; // C r e a t e m o d e l; // -----------------------; ; // Observables, parameters; RooRealVar x(""x"", ""x"", -10, 10);; x.setBins(10);; RooRealVar mean(""mean"", ""mean of gaussian"", 0, -2., 1.8);; RooRealVar sigma(""sigma"", ""width of gaussian"", 5, 1, 10);; ; // Create Gaussian pdf; RooGaussian gauss(""gauss"", ""gaussian PDF"", x, mean, sigma);; ; // C r e a t e m a n a g e r w i t h c h i ^ 2 a d d - o n m o d u l e; // ----------------------------------------------------------------------------; ; // Create study manager for binned likelihood fits of a Gaussian pdf in 10 bins; RooMCStudy *mcs = new RooMCStudy(gauss, x, Silence(), Binned());; ; // Add chi^2 calculator module to mcs; RooChi2MCSModule chi2mod;; mcs->addModule(chi2mod);; ; // Generate 1000 samples of 1000 events; mcs->generateAndFit(2000, 1000);; ; // Number of bins for chi2 plots; int nBins = 100;; ; // Fill histograms with distributions chi2 and prob(chi2,ndf) that; // are calculated by RooChiMCSModule; TH1 *hist_chi2 = mcs->fitParDataSet().createHistogram(""chi2"", AutoBinning(nBins));; hist_chi2->SetTitle(""#chi^{2} values of all toy runs;#chi^{2}"");; TH1 *hist_prob = mcs->fitParDataSet().createHistogram(""prob"", AutoBinning(nBins));; hist_prob->Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf802__mcstudy__addons_8C.html:107,Load,Loading,107,doc/master/rf802__mcstudy__addons_8C.html,https://root.cern,https://root.cern/doc/master/rf802__mcstudy__addons_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf803_mcstudy_addons2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf803_mcstudy_addons2.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Validation and MC studies: RooMCStudy - Using the randomizer and profile likelihood add-on models . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooAddPdf.h""; #include ""RooMCStudy.h""; #include ""RooRandomizeParamMCSModule.h""; #include ""RooDLLSignificanceMCSModule.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; #include ""TDirectory.h""; ; using namespace RooFit;; ; void rf803_mcstudy_addons2(); {; // C r e a t e m o d e l; // -----------------------; ; // Simulation of signal and background of top quark decaying into; // 3 jets with background; ; // Observable; RooRealVar mjjj(""mjjj"", ""m(3jet) (GeV)"", 100, 85., 350.);; ; // Signal component (Gaussian); RooRealVar mtop(""mtop"", ""m(top)"", 162);; RooRealVar wtop(""wtop"", ""m(top) resolution"", 15.2);; RooGaussian sig(""sig"", ""top signal"", mjjj, mtop, wtop);; ; // Background component (Chebychev); RooRealVar c0(""c0"", ""Chebychev coefficient 0"", -0.846, -1., 1.);; RooRealVar c1(""c1"", ""Chebychev coefficient 1"", 0.112, -1., 1.);; RooRealVar c2(""c2"", ""Chebychev coefficient 2"", 0.076, -1., 1.);; RooChebychev bkg(""bkg"", ""combinatorial background"", mjjj, RooArgList(c0, c1, c2));; ; // Composite model; RooRealVar nsig(""nsig"", ""number of signal events"", 53, 0, 1e3);; RooRealVar nbkg(""nbkg"", ""number of background events"", 103, 0, 5e3);; RooAddPdf model(""model"", ""model"", RooArgList(sig, bkg), RooArgList(nsig, nbkg));; ; // C r e a t e m a n a g e r; // ---------------------------; ; // Configure manager to perform binned extended likelihood fits (Binned(),Extended()) on data generated; // with a Poisson fluctuation on Nobs (Extended()); RooMCStudy *mcs = new RooMCStudy(model, mjjj, Binned(), Silence(), ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf803__mcstudy__addons2_8C.html:108,Load,Loading,108,doc/master/rf803__mcstudy__addons2_8C.html,https://root.cern,https://root.cern/doc/master/rf803__mcstudy__addons2_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf804_mcstudy_constr.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf804_mcstudy_constr.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Validation and MC studies: using RooMCStudy on models with constrains . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooAddPdf.h""; #include ""RooProdPdf.h""; #include ""RooMCStudy.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf804_mcstudy_constr(); {; // C r e a t e m o d e l w i t h p a r a m e t e r c o n s t r a i n t; // ---------------------------------------------------------------------------; ; // Observable; RooRealVar x(""x"", ""x"", -10, 10);; ; // Signal component; RooRealVar m(""m"", ""m"", 0, -10, 10);; RooRealVar s(""s"", ""s"", 2, 0.1, 10);; RooGaussian g(""g"", ""g"", x, m, s);; ; // Background component; RooPolynomial p(""p"", ""p"", x);; ; // Composite model; RooRealVar f(""f"", ""f"", 0.4, 0., 1.);; RooAddPdf sum(""sum"", ""sum"", RooArgSet(g, p), f);; ; // Construct constraint on parameter f; RooGaussian fconstraint(""fconstraint"", ""fconstraint"", f, 0.7, 0.1);; ; // Multiply constraint with pdf; RooProdPdf sumc(""sumc"", ""sum with constraint"", RooArgSet(sum, fconstraint));; ; // S e t u p t o y s t u d y w i t h m o d e l; // ---------------------------------------------------; ; // Perform toy study with internal constraint on f; RooMCStudy mcs(sumc, x, Constrain(f), Silence(), Binned(), FitOptions(PrintLevel(-1)));; ; // Run 500 toys of 2000 events.; // Before each toy is generated, a value for the f is sampled from the constraint pdf and; // that value is used for the generation of that toy.; mcs.generateAndFit(500, 2000);; ; // Make plot of distribution of generated value of f parameter; TH1 *h_f_gen = mcs.fitParDataSet().createHistogram(""f_gen"", AutoBinning(40));; ; // Make plot of distribution of fitted",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf804__mcstudy__constr_8C.html:107,Load,Loading,107,doc/master/rf804__mcstudy__constr_8C.html,https://root.cern,https://root.cern/doc/master/rf804__mcstudy__constr_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf901_numintconfig.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf901_numintconfig.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: configuration and customization of how numeric (partial) integrals are executed ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooNumIntConfig.h""; #include ""RooLandau.h""; #include ""RooArgSet.h""; #include <iomanip>; using namespace RooFit;; ; void rf901_numintconfig(); {; ; // A d j u s t g l o b a l 1 D i n t e g r a t i o n p r e c i s i o n; // ----------------------------------------------------------------------------; ; // Print current global default configuration for numeric integration strategies; RooAbsReal::defaultIntegratorConfig()->Print(""v"");; ; // Example: Change global precision for 1D integrals from 1e-7 to 1e-6; //; // The relative epsilon (change as fraction of current best integral estimate) and; // absolute epsilon (absolute change w.r.t last best integral estimate) can be specified; // separately. For most pdf integrals the relative change criterium is the most important,; // however for certain non-pdf functions that integrate out to zero a separate absolute; // change criterium is necessary to declare convergence of the integral; //; // NB: This change is for illustration only. In general the precision should be at least 1e-7; // for normalization integrals for MINUIT to succeed.; //; RooAbsReal::defaultIntegratorConfig()->setEpsAbs(1e-6);; RooAbsReal::defaultIntegratorConfig()->setEpsRel(1e-6);; ; // N u m e r i c i n t e g r a t i o n o f l a n d a u p d f; // ------------------------------------------------------------------; ; RooRealVar x(""x"", ""x"", -10, 10);; RooLandau landau(""landau"", ""landau"", x, 0.0, 0.1);; ; // Disable analytic integration from demonstration purposes; landau.forc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf901__numintconfig_8C.html:105,Load,Loading,105,doc/master/rf901__numintconfig_8C.html,https://root.cern,https://root.cern/doc/master/rf901__numintconfig_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf901_numintconfig.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf901_numintconfig.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: configuration and customization of how numeric (partial) integrals are executed ; ; from __future__ import print_function; import ROOT; ; ; # Adjust global 1D integration precision; # ----------------------------------------------------------------------------; ; # Print current global default configuration for numeric integration; # strategies; ROOT.RooAbsReal.defaultIntegratorConfig().Print(""v""); ; # Example: Change global precision for 1D integrals from 1e-7 to 1e-6; #; # The relative epsilon (change as fraction of current best integral estimate) and; # absolute epsilon (absolute change w.r.t last best integral estimate) can be specified; # separately. For most pdf integrals the relative change criterium is the most important,; # however for certain non-pdf functions that integrate out to zero a separate absolute; # change criterium is necessary to declare convergence of the integral; #; # NB: ROOT.This change is for illustration only. In general the precision should be at least 1e-7; # for normalization integrals for MINUIT to succeed.; #; ROOT.RooAbsReal.defaultIntegratorConfig().setEpsAbs(1e-6); ROOT.RooAbsReal.defaultIntegratorConfig().setEpsRel(1e-6); ; # N u m e r i c i n t e g r a t i o n o f l a n d a u p d f; # ------------------------------------------------------------------; ; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); landau = ROOT.RooLandau(""landau"", ""landau"", x, 0.0, 0.1); ; # Disable analytic integration from demonstration purposes; landau.forceNumInt(True); ; # Activate debug-level messages for topic integration to be able to follow; # actions below; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Integration); ; # Calculate integral over landau with defau",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf901__numintconfig_8py.html:106,Load,Loading,106,doc/master/rf901__numintconfig_8py.html,https://root.cern,https://root.cern/doc/master/rf901__numintconfig_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf902_numgenconfig.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf902_numgenconfig.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: configuration and customization of how MC sampling algorithms on specific pdfs are executed ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooChebychev.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooNumGenConfig.h""; #include ""RooArgSet.h""; #include <iomanip>; using namespace RooFit;; ; void rf902_numgenconfig(); {; ; // A d j u s t g l o b a l MC s a m p l i n g s t r a t e g y; // ------------------------------------------------------------------; ; // Example pdf for use below; RooRealVar x(""x"", ""x"", 0, 10);; RooChebychev model(""model"", ""model"", x, RooArgList(0, 0.5, -0.1));; ; // Change global strategy for 1D sampling problems without conditional observable; // (1st false) and without discrete observable (2nd false) from RooFoamGenerator,; // ( an interface to the TFoam MC generator with adaptive subdivisioning strategy ) to RooAcceptReject,; // a plain accept/reject sampling algorithm [ RooFit default before ROOT 5.23/04 ]; RooAbsPdf::defaultGeneratorConfig()->method1D(false, false).setLabel(""RooAcceptReject"");; ; // Generate 10Kevt using RooAcceptReject; std::unique_ptr<RooDataSet> data_ar{model.generate(x, 10000, Verbose(true))};; data_ar->Print();; ; // A d j u s t i n g d e f a u l t c o n f i g f o r a s p e c i f i c p d f; // -------------------------------------------------------------------------------------; ; // Another possibility: associate custom MC sampling configuration as default for object 'model'; // The true argument will install a clone of the default configuration as specialized configuration; // for this model if none existed so far; model.specialGeneratorConfig(true)->method1D(false, false).setLabel(""RooFoamGenerator"");; ; // A d j u s t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf902__numgenconfig_8C.html:105,Load,Loading,105,doc/master/rf902__numgenconfig_8C.html,https://root.cern,https://root.cern/doc/master/rf902__numgenconfig_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf902_numgenconfig.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf902_numgenconfig.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: configuration and customization of how MC sampling algorithms on specific pdfs are executed ; ; import ROOT; ; ; # Adjust global MC sampling strategy; # ------------------------------------------------------------------; ; # Example pdf for use below; x = ROOT.RooRealVar(""x"", ""x"", 0, 10); model = ROOT.RooChebychev(""model"", ""model"", x, [0.0, 0.5, -0.1]); ; # Change global strategy for 1D sampling problems without conditional observable; # (1st kFALSE) and without discrete observable (2nd kFALSE) from ROOT.RooFoamGenerator,; # ( an interface to the ROOT.TFoam MC generator with adaptive subdivisioning strategy ) to ROOT.RooAcceptReject,; # a plain accept/reject sampling algorithm [ ROOT.RooFit default before; # ROOT 5.23/04 ]; ROOT.RooAbsPdf.defaultGeneratorConfig().method1D(False, False).setLabel(""RooAcceptReject""); ; # Generate 10Kevt using ROOT.RooAcceptReject; data_ar = model.generate({x}, 10000, Verbose=True); data_ar.Print(); ; # Adjusting default config for a specific pdf; # -------------------------------------------------------------------------------------; ; # Another possibility: associate custom MC sampling configuration as default for object 'model'; # The kTRUE argument will install a clone of the default configuration as specialized configuration; # for self model if none existed so far; model.specialGeneratorConfig(True).method1D(False, False).setLabel(""RooFoamGenerator""); ; # Adjusting parameters of a specific technique; # ---------------------------------------------------------------------------------------; ; # Adjust maximum number of steps of ROOT.RooIntegrator1D in the global; # default configuration; ROOT.RooAbsPdf.defaultGeneratorConfig().getConfigSection(""RooAcceptReject"").setR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf902__numgenconfig_8py.html:106,Load,Loading,106,doc/master/rf902__numgenconfig_8py.html,https://root.cern,https://root.cern/doc/master/rf902__numgenconfig_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/roofit/rf903_numintcache.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf903_numintcache.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: caching of slow numeric integrals and parameterization of slow numeric integrals . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooDataHist.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooWorkspace.h""; #include ""RooExpensiveObjectCache.h""; #include ""TFile.h""; #include ""TH1.h""; ; using namespace RooFit;; ; RooWorkspace *getWorkspace(Int_t mode);; ; void rf903_numintcache(Int_t mode = 0); {; // Mode = 0 : Run plain fit (slow); // Mode = 1 : Generate workspace with pre-calculated integral and store it on file (prepare for accelerated running); // Mode = 2 : Run fit from previously stored workspace including cached integrals (fast, requires run in mode=1; // first); ; // C r e a t e , s a v e o r l o a d w o r k s p a c e w i t h p . d . f .; // -----------------------------------------------------------------------------------; ; // Make/load workspace, exit here in mode 1; RooWorkspace *w1 = getWorkspace(mode);; if (mode == 1) {; ; // Show workspace that was created; w1->Print();; ; // Show plot of cached integral values; RooDataHist *hhcache = (RooDataHist *)w1->expensiveObjectCache().getObj(1);; if (hhcache) {; ; new TCanvas(""rf903_numintcache"", ""rf903_numintcache"", 600, 600);; hhcache->createHistogram(""a"")->Draw();; ; } else {; Error(""rf903_numintcache"", ""Cached histogram is not existing in workspace"");; }; return;; }; ; // U s e p . d . f . f r o m w o r k s p a c e f o r g e n e r a t i o n a n d f i t t i n g; // -----------------------------------------------------------------------------------; ; // This is always slow (need to find maximum function value empirically in 3D space); std::unique_ptr<RooDataSet> d{w1->pdf(""model"")->generate(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf903__numintcache_8C.html:104,Load,Loading,104,doc/master/rf903__numintcache_8C.html,https://root.cern,https://root.cern/doc/master/rf903__numintcache_8C.html,2,"['Load', 'cache']","['Loading', 'cached']"
Performance,". ROOT: tutorials/roofit/rf903_numintcache.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf903_numintcache.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: caching of slow numeric integrals and parameterizations of slow numeric integrals . ; import sys; import ROOT; ; ; def getWorkspace(mode):; # Create, save or load workspace with pdf; # -----------------------------------------------------------------------------------; #; # Mode = 0 : Create workspace for plain running (no integral caching); # Mode = 1 : Generate workspace with precalculated integral and store it on file; # Mode = 2 : Load previously stored workspace from file; ; w = ROOT.RooWorkspace(); ; if mode != 2:; # Create empty workspace workspace; w = ROOT.RooWorkspace(""w"", 1); ; # Make a difficult to normalize pdf in 3 dimensions that is; # integrated numerically.; w.factory(; ""EXPR::model('1/((x-a)*(x-a)+0.01)+1/((y-a)*(y-a)+0.01)+1/((z-a)*(z-a)+0.01)',x[-1,1],y[-1,1],z[-1,1],a[-5,5])""; ); ; if mode == 1:; # Instruct model to precalculate normalization integral that integrate at least; # two dimensions numerically. In self specific case the integral value for; # all values of parameter 'a' are stored in a histogram and available for use; # in subsequent fitting and plotting operations (interpolation is; # applied); ; # w.pdf(""model"").setNormValueCaching(3); model = w[""model""]; model.setStringAttribute(""CACHEPARMINT"", ""x:y:z""); ; # Evaluate pdf once to trigger filling of cache; normSet = {w[""x""], w[""y""], w[""z""]}; model.getVal(normSet); w.writeToFile(""rf903_numintcache.root""); ; if mode == 2:; # Load preexisting workspace from file in mode==2; f = ROOT.TFile(""rf903_numintcache.root""); w = f.Get(""w""); ; # Return created or loaded workspace; return w; ; ; mode = 0; # Mode = 0 : Run plain fit (slow); # Mode = 1 : Generate workspace with precalculated integral and store it on file (prepare for acce",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf903__numintcache_8py.html:105,Load,Loading,105,doc/master/rf903__numintcache_8py.html,https://root.cern,https://root.cern/doc/master/rf903__numintcache_8py.html,3,"['Load', 'load']","['Load', 'Loading', 'load']"
Performance,". ROOT: tutorials/rootlogoff.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rootlogoff.C File ReferenceTutorials. Detailed Description; Example of rootlogoff.C. ; The macro rootlogoff.C in the current working directory, is executed when root finishes.; ; {; printf(""\nTaking a break from ROOT? Hope to see you back!\n\n"");; }; AuthorRene Brun ; Definition in file rootlogoff.C. tutorialsrootlogoff.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootlogoff_8C.html:90,Load,Loading,90,doc/master/rootlogoff_8C.html,https://root.cern,https://root.cern/doc/master/rootlogoff_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/rootlogon.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rootlogon.C File ReferenceTutorials. Detailed Description; Example of rootlogon.C. ; The macro rootlogon.C in the current working directory, is executed when root starts unless the option -n is used.; ; {; printf(""\nWelcome to the ROOT tutorials\n\n"");; printf(""\nType \"".x demos.C\"" to get a toolbar from which to execute the demos\n"");; printf(""\nType \"".x demoshelp.C\"" to see the help window\n\n"");; printf(""==> Many tutorials use the file hsimple.root produced by hsimple.C\n"");; printf(""==> It is recommended to execute hsimple.C before any other script\n\n"");; }; ; AuthorRene Brun ; Definition in file rootlogon.C. tutorialsrootlogon.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootlogon_8C.html:89,Load,Loading,89,doc/master/rootlogon_8C.html,https://root.cern,https://root.cern/doc/master/rootlogon_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/rootlogon.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rootlogon.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup Tutorials; 3/// Example of `rootlogon.C`.; 4/// The macro `rootlogon.C` in the current working directory, is executed when; 5/// `root` starts unless the option `-n` is used.; 6///; 7/// \macro_code; 8///; 9/// \author Rene Brun; 10 ; 11{; 12 printf(""\nWelcome to the ROOT tutorials\n\n"");; 13 printf(""\nType \"".x demos.C\"" to get a toolbar from which to execute the demos\n"");; 14 printf(""\nType \"".x demoshelp.C\"" to see the help window\n\n"");; 15 printf(""==> Many tutorials use the file hsimple.root produced by hsimple.C\n"");; 16 printf(""==> It is recommended to execute hsimple.C before any other script\n\n"");; 17}; 18 . tutorialsrootlogon.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootlogon_8C_source.html:86,Load,Loading,86,doc/master/rootlogon_8C_source.html,https://root.cern,https://root.cern/doc/master/rootlogon_8C_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/spectrum/peaks.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. peaks.C File ReferenceTutorials » Spectrum tutorials. Detailed Description; Illustrates how to find peaks in histograms. ; This script generates a random number of gaussian peaks on top of a linear background. The position of the peaks is found via TSpectrum and injected as initial values of parameters to make a global fit. The background is computed and drawn on top of the original histogram.; This script can fit ""peaks' heights"" or ""peaks' areas"" (comment out or uncomment the line which defines __PEAKS_C_FIT_AREAS__).; To execute this example, do (in ROOT 5 or ROOT 6):; root > .x peaks.C (generate 10 peaks by default); root > .x peaks.C++ (use the compiler); root > .x peaks.C++(30) (generates 30 peaks); xDouble_t x[n]Definition legend1.C:17; To execute only the first part of the script (without fitting) specify a negative value for the number of peaks, eg; root > .x peaks.C(-20); ; Found 9 candidate peaks to fit; Found 9 useful peaks to fit; Now fitting: Be patient; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 596.686; NDf = 471; Edm = 1.7299e-05; NCalls = 1747; p0 = 527.684 +/- 2.02282 ; p1 = -0.395029 +/- 0.00304651 ; p2 = 634.668 +/- 20.672 ; p3 = 519.331 +/- 0.111412 ; p4 = 3.49861 +/- 0.109353 ; p5 = 664.735 +/- 18.7022 ; p6 = 319.147 +/- 0.131874 ; p7 = 4.69145 +/- 0.126752 ; p8 = 670.916 +/- 17.6455 ; p9 = 754.806 +/- 0.108202 ; p10 = 4.29739 +/- 0.101204 ; p11 = 669.613 +/- 20.0806 ; p12 = 475.964 +/- 0.113649 ; p13 = 3.89314 +/- 0.110985 ; p14 = 648.09 +/- 18.199 ; p15 = 989.666 +/- 0.0884478 ; p16 = 3.34535 +/- 0.0786714 ; p17 = 662.552 +/- 17.8619 ; p18 = 539.268 +/- 0.122694 ; p19 = 4.56069 +/- 0.113882 ; p20 = 659.417 +/- 16.1804 ; p21 = 948.476 +/- 0.101982 ; p22 = 4.41156 +/- 0.091998 ; p23 = 753.529 +/- 15.2593 ; p24 = 232.585 +/- 0.151403 ; p25 = 6.95019 +/- 0.122555 ; p26 = 645.477 +",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/peaks_8C.html:94,Load,Loading,94,doc/master/peaks_8C.html,https://root.cern,https://root.cern/doc/master/peaks_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva Directory Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva Directory Reference. Directory dependency graph for tmva:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Directories;  envelope;  ;  keras;  ;  pytorch;  . Files;  createData.C;  Plot the variables. ;  ;  PyTorch_Generate_CNN_Model.py;  ;  RBatchGenerator_filters_vectors.py;  ;  RBatchGenerator_NumPy.py;   Example of getting batches of events from a ROOT dataset as Python generators of numpy arrays. ;  ;  RBatchGenerator_PyTorch.py;   Example of getting batches of events from a ROOT dataset into a basic PyTorch workflow. ;  ;  RBatchGenerator_TensorFlow.py;   Example of getting batches of events from a ROOT dataset into a basic TensorFlow workflow. ;  ;  tmva001_RTensor.C;   This tutorial illustrates the basic features of the RTensor class, RTensor is a std::vector-like container with additional shape information. ;  ;  tmva002_RDataFrameAsTensor.C;   This tutorial shows how the content of an RDataFrame can be converted to an RTensor object. ;  ;  tmva003_RReader.C;   This tutorial shows how to apply with the modern interfaces models saved in TMVA XML files. ;  ;  tmva004_RStandardScaler.C;   This tutorial illustrates the usage of the standard scaler as preprocessing method. ;  ;  tmva100_DataPreparation.py;   This tutorial illustrates how to prepare ROOT datasets to be nicely readable by most machine learning methods. ;  ;  tmva101_Training.py;   This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ;  ;  tmva102_Testing.py;   This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ;  ;  tmva103_Application.C;   This tutorial illustrates how you can conveniently apply BDTs in C++ using the fast tree inference engine offered b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:87,Load,Loading,87,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/RBatchGenerator_NumPy.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; RBatchGenerator_NumPy.py File ReferenceTutorials » TMVA tutorials. Detailed Description; Example of getting batches of events from a ROOT dataset as Python generators of numpy arrays. ; ; import ROOT; ; tree_name = ""sig_tree""; file_name = ""http://root.cern/files/Higgs_data.root""; ; batch_size = 128; chunk_size = 5_000; ; ds_train, ds_validation = ROOT.TMVA.Experimental.CreateNumPyGenerators(; tree_name,; file_name,; batch_size,; chunk_size,; validation_split=0.3,; shuffle=True,; ); ; # Loop through training set; for i, b in enumerate(ds_train):; print(f""Training batch {i} => {b.shape}""); ; ; # Loop through Validation set; for i, b in enumerate(ds_validation):; print(f""Validation batch {i} => {b.shape}""); Training batch 0 => (128, 29); Training batch 1 => (128, 29); Training batch 2 => (128, 29); Training batch 3 => (128, 29); Training batch 4 => (128, 29); Training batch 5 => (128, 29); Training batch 6 => (128, 29); Training batch 7 => (128, 29); Training batch 8 => (128, 29); Training batch 9 => (128, 29); Training batch 10 => (128, 29); Training batch 11 => (128, 29); Training batch 12 => (128, 29); Training batch 13 => (128, 29); Training batch 14 => (128, 29); Training batch 15 => (128, 29); Training batch 16 => (128, 29); Training batch 17 => (128, 29); Training batch 18 => (128, 29); Training batch 19 => (128, 29); Training batch 20 => (128, 29); Training batch 21 => (128, 29); Training batch 22 => (128, 29); Training batch 23 => (128, 29); Training batch 24 => (128, 29); Training batch 25 => (128, 29); Training batch 26 => (128, 29); Training batch 27 => (128, 29); Training batch 28 => (128, 29); Training batch 29 => (128, 29); Training batch 30 => (128, 29); Training batch 31 => (128, 29); Training batch 32 => (128, 29); Training batch 33 => (128, 29); Training batch 34 => (128, 29); Training batch 35 =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RBatchGenerator__NumPy_8py.html:107,Load,Loading,107,doc/master/RBatchGenerator__NumPy_8py.html,https://root.cern,https://root.cern/doc/master/RBatchGenerator__NumPy_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/RBatchGenerator_PyTorch.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; RBatchGenerator_PyTorch.py File ReferenceTutorials » TMVA tutorials. Detailed Description; Example of getting batches of events from a ROOT dataset into a basic PyTorch workflow. ; ; import torch; import ROOT; ; tree_name = ""sig_tree""; file_name = ""http://root.cern/files/Higgs_data.root""; ; batch_size = 128; chunk_size = 5_000; ; target = ""Type""; ; # Returns two generators that return training and validation batches; # as PyTorch tensors.; gen_train, gen_validation = ROOT.TMVA.Experimental.CreatePyTorchGenerators(; tree_name,; file_name,; batch_size,; chunk_size,; target=target,; validation_split=0.3,; ); ; # Get a list of the columns used for training; input_columns = gen_train.train_columns; num_features = len(input_columns); ; ; def calc_accuracy(targets, pred):; return torch.sum(targets == pred.round()) / pred.size(0); ; ; # Initialize PyTorch model; model = torch.nn.Sequential(; torch.nn.Linear(num_features, 300),; torch.nn.Tanh(),; torch.nn.Linear(300, 300),; torch.nn.Tanh(),; torch.nn.Linear(300, 300),; torch.nn.Tanh(),; torch.nn.Linear(300, 1),; torch.nn.Sigmoid(),; ); loss_fn = torch.nn.MSELoss(reduction=""mean""); optimizer = torch.optim.SGD(model.parameters(), lr=0.01, momentum=0.9); ; ; # Loop through the training set and train model; for i, (x_train, y_train) in enumerate(gen_train):; # Make prediction and calculate loss; pred = model(x_train).view(-1); loss = loss_fn(pred, y_train); ; # improve model; model.zero_grad(); loss.backward(); optimizer.step(); ; # Calculate accuracy; accuracy = calc_accuracy(y_train, pred); ; print(f""Training => accuracy: {accuracy}""); ; #################################################################; # Validation; #################################################################; ; # Evaluate the model on the validation set; for i, (x_train, y_train) in enumerate(gen_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RBatchGenerator__PyTorch_8py.html:109,Load,Loading,109,doc/master/RBatchGenerator__PyTorch_8py.html,https://root.cern,https://root.cern/doc/master/RBatchGenerator__PyTorch_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/RBatchGenerator_TensorFlow.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; RBatchGenerator_TensorFlow.py File ReferenceTutorials » TMVA tutorials. Detailed Description; Example of getting batches of events from a ROOT dataset into a basic TensorFlow workflow. ; ; import tensorflow as tf; import ROOT; ; tree_name = ""sig_tree""; file_name = ""http://root.cern/files/Higgs_data.root""; ; batch_size = 128; chunk_size = 5_000; ; target = ""Type""; ; # Returns two TF.Dataset for training and validation batches.; ds_train, ds_valid = ROOT.TMVA.Experimental.CreateTFDatasets(; tree_name,; file_name,; batch_size,; chunk_size,; validation_split=0.3,; target=target,; ); ; # Get a list of the columns used for training; input_columns = ds_train.train_columns; num_features = len(input_columns); ; ##############################################################################; # AI example; ##############################################################################; ; # Define TensorFlow model; model = tf.keras.Sequential(; [; tf.keras.layers.Dense(; 300, activation=tf.nn.tanh, input_shape=(num_features,); ), # input shape required; tf.keras.layers.Dense(300, activation=tf.nn.tanh),; tf.keras.layers.Dense(300, activation=tf.nn.tanh),; tf.keras.layers.Dense(1, activation=tf.nn.sigmoid),; ]; ); loss_fn = tf.keras.losses.BinaryCrossentropy(); model.compile(optimizer=""adam"", loss=loss_fn, metrics=[""accuracy""]); ; # Train model; model.fit(ds_train, validation_data=ds_valid, epochs=2); lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RBatchGenerator__TensorFlow_8py.html:112,Load,Loading,112,doc/master/RBatchGenerator__TensorFlow_8py.html,https://root.cern,https://root.cern/doc/master/RBatchGenerator__TensorFlow_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVAClassification.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassification.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides examples for the training and testing of the TMVA classifiers. ; As input data is used a toy-MC sample consisting of four Gaussian-distributed and linearly correlated input variables. The methods to be used can be switched on and off by means of booleans, or via the prompt command, for example: root -l ./TMVAClassification.C\‍(\""Fisher,Likelihood\""\‍); (note that the backslashes are mandatory) If no method given, a default set of classifiers is used. The output file ""TMVAC.root"" can be analysed with the use of dedicated macros (simply say: root -l <macro.C>), which can be conveniently invoked through a GUI that will appear at the end of the run of this macro. Launch the GUI via the command: root -l ./TMVAGui.C; You can also compile and run the example with the following commands make; ./TMVAClassification <Methods>; where: <Methods> = ""method1 method2"" are the TMVA classifier names example: ./TMVAClassification Fisher LikelihoodPCA BDT; If no method given, a default set is of classifiers is used. Project : TMVA - a ROOT-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVAClassification. ; ; ==> Start TMVAClassification; --- TMVAClassification : Using input file: ./files/tmva_class_example.root; DataSetInfo : [dataset] : Added class ""Signal""; : Add Tree TreeS of type Signal with 6000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 6000 events; Factory : Booking method: ␛[1mCuts␛[0m; : ; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:103,Load,Loading,103,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVAClassification.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassification.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_tmva; 3/// \notebook -nodraw; 4/// This macro provides examples for the training and testing of the; 5/// TMVA classifiers.; 6///; 7/// As input data is used a toy-MC sample consisting of four Gaussian-distributed; 8/// and linearly correlated input variables.; 9/// The methods to be used can be switched on and off by means of booleans, or; 10/// via the prompt command, for example:; 11///; 12/// root -l ./TMVAClassification.C\‍(\""Fisher,Likelihood\""\‍); 13///; 14/// (note that the backslashes are mandatory); 15/// If no method given, a default set of classifiers is used.; 16/// The output file ""TMVAC.root"" can be analysed with the use of dedicated; 17/// macros (simply say: root -l <macro.C>), which can be conveniently; 18/// invoked through a GUI that will appear at the end of the run of this macro.; 19/// Launch the GUI via the command:; 20///; 21/// root -l ./TMVAGui.C; 22///; 23/// You can also compile and run the example with the following commands; 24///; 25/// make; 26/// ./TMVAClassification <Methods>; 27///; 28/// where: `<Methods> = ""method1 method2""` are the TMVA classifier names; 29/// example:; 30///; 31/// ./TMVAClassification Fisher LikelihoodPCA BDT; 32///; 33/// If no method given, a default set is of classifiers is used; 34///; 35/// - Project : TMVA - a ROOT-integrated toolkit for multivariate data analysis; 36/// - Package : TMVA; 37/// - Root Macro: TMVAClassification; 38///; 39/// \macro_output; 40/// \macro_code; 41/// \author Andreas Hoecker; 42 ; 43 ; 44#include <cstdlib>; 45#include <iostream>; 46#include <map>; 47#include <string>; 48 ; 49#include ""TChain.h""; 50#include ""TFile.h""; 51#include ""TTree.h""; 52#include ""TString.h""; 53#include ""TObjString.h""; 54#include ""TSystem.h""; 55#include ""TROOT.h""; 56 ; 57#inclu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C_source.html:100,Load,Loading,100,doc/master/TMVAClassification_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVAClassificationApplication.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationApplication.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example on how to use the trained classifiers within an analysis module . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Executable: TMVAClassificationApplication. ; ; ==> Start TMVAClassificationApplication; : Booking ""BDT method"" of type ""BDT"" from dataset/weights/TMVAClassification_BDT.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_BDT.weights.xml; <HEADER> DataSetInfo : [Default] : Added class ""Signal""; <HEADER> DataSetInfo : [Default] : Added class ""Background""; : Booked classifier ""BDT"" of type: ""BDT""; : Booking ""Cuts method"" of type ""Cuts"" from dataset/weights/TMVAClassification_Cuts.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_Cuts.weights.xml; : Read cuts optimised using sample of MC events; : Reading 100 signal efficiency bins for 4 variables; : Booked classifier ""Cuts"" of type: ""Cuts""; : Booking ""CutsD method"" of type ""Cuts"" from dataset/weights/TMVAClassification_CutsD.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_CutsD.weights.xml; : Read cuts optimised using sample of MC events; : Reading 100 signal efficiency bins for 4 variables; : Booked classifier ""CutsD"" of type: ""Cuts""; : Booking ""FDA_GA method"" of type ""FDA"" from dataset/weights/TMVAClassification_FDA_GA.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_FDA_GA.weights.xml; : User-defined formula string : ""(0)+(1)*x0+(2)*x1+(3)*x2+(4)*x3""; : TFormula-compatible formula string: ""[0]+[1]*[5]+[2]*[6]+[3]*[7]+[4]*[8]""; : Booked classifier ""FDA_GA"" of type: ""FDA""; : Booking ""KNN method"" of type ""KNN"" from dataset/weights/TMVAClassification_KNN.weights.xml.; : Reading weight file: dataset/w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationApplication_8C.html:114,Load,Loading,114,doc/master/TMVAClassificationApplication_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVAClassificationApplication.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationApplication.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_tmva; 3/// \notebook -nodraw; 4/// This macro provides a simple example on how to use the trained classifiers; 5/// within an analysis module; 6/// - Project : TMVA - a Root-integrated toolkit for multivariate data analysis; 7/// - Package : TMVA; 8/// - Executable: TMVAClassificationApplication; 9///; 10/// \macro_output; 11/// \macro_code; 12/// \author Andreas Hoecker; 13 ; 14#include <cstdlib>; 15#include <vector>; 16#include <iostream>; 17#include <map>; 18#include <string>; 19 ; 20#include ""TFile.h""; 21#include ""TTree.h""; 22#include ""TString.h""; 23#include ""TSystem.h""; 24#include ""TROOT.h""; 25#include ""TStopwatch.h""; 26 ; 27#include ""TMVA/Tools.h""; 28#include ""TMVA/Reader.h""; 29#include ""TMVA/MethodCuts.h""; 30 ; 31using namespace TMVA;; 32 ; 33void TMVAClassificationApplication( TString myMethodList = """" ); 34{; 35 ; 36 //---------------------------------------------------------------; 37 // This loads the library; 38 TMVA::Tools::Instance();; 39 ; 40 // Default MVA methods to be trained + tested; 41 std::map<std::string,int> Use;; 42 ; 43 // Cut optimisation; 44 Use[""Cuts""] = 1;; 45 Use[""CutsD""] = 1;; 46 Use[""CutsPCA""] = 0;; 47 Use[""CutsGA""] = 0;; 48 Use[""CutsSA""] = 0;; 49 //; 50 // 1-dimensional likelihood (""naive Bayes estimator""); 51 Use[""Likelihood""] = 1;; 52 Use[""LikelihoodD""] = 0; // the ""D"" extension indicates decorrelated input variables (see option strings); 53 Use[""LikelihoodPCA""] = 1; // the ""PCA"" extension indicates PCA-transformed input variables (see option strings); 54 Use[""LikelihoodKDE""] = 0;; 55 Use[""LikelihoodMIX""] = 0;; 56 //; 57 // Mutidimensional likelihood and Nearest-Neighbour methods; 58 Use[""PDERS""] = 1;; 59 Use[""PDERSD""] = 0;; 60 Use[""PDERSPCA""] = 0;; 61 Use[""PDEFoam""] = 1;; 62 Use[""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:111,Load,Loading,111,doc/master/TMVAClassificationApplication_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVAClassificationCategory.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationCategory.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode. . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVAClassificationCategory. As input data is used a toy-MC sample consisting of four Gaussian-distributed and linearly correlated input variables with category (eta) dependent properties.; For this example, only Fisher and Likelihood are used. Run via: root -l TMVAClassificationCategory.C; The output file ""TMVACC.root"" can be analysed with the use of dedicated macros (simply say: root -l <macro.C>), which can be conveniently invoked through a GUI that will appear at the end of the run of this macro.; ; ; ==> Start TMVAClassificationCategory; --- TMVAClassificationCategory: Accessing /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tmva/data/toy_sigbkg_categ_offset.root; <HEADER> DataSetInfo : [dataset] : Added class ""Signal""; : Add Tree TreeS of type Signal with 10000 events; <HEADER> DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 10000 events; <HEADER> Factory : Booking method: Fisher; : ; <HEADER> Factory : Booking method: Likelihood; : ; <HEADER> Factory : Booking method: FisherCat; : ; : Adding sub-classifier: Fisher::Category_Fisher_1; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Background""; : Adding sub-classifier: Fisher::Category_Fisher_2; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; <HEADER> Factory : Booking method: LikelihoodCat; : ; : Adding su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationCategory_8C.html:111,Load,Loading,111,doc/master/TMVAClassificationCategory_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVAClassificationCategoryApplication.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationCategoryApplication.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Executable: TMVAClassificationCategoryApplication. ; ; ==> Start TMVAClassificationCategoryApplication; : Booking ""FisherCat method"" of type ""Category"" from dataset/weights/TMVAClassificationCategory_FisherCat.weights.xml.; : Reading weight file: dataset/weights/TMVAClassificationCategory_FisherCat.weights.xml; <HEADER> DataSetInfo : [Default] : Added class ""Signal""; <HEADER> DataSetInfo : [Default] : Added class ""Background""; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; : Booked classifier ""FisherCat"" of type: ""Category""; : Booking ""LikelihoodCat method"" of type ""Category"" from dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml.; : Reading weight file: dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Background""; : Booked classifier ""LikelihoodCat"" of type: ""Category""; --- TMVAClassificationApp : Accessing /home/sftnight/build/workspace/root",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html:122,Load,Loading,122,doc/master/TMVAClassificationCategoryApplication_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVACrossValidation.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVACrossValidation.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides an example of how to use TMVA for k-folds cross evaluation. ; As input data is used a toy-MC sample consisting of two gaussian distributions.; The output file ""TMVACV.root"" can be analysed with the use of dedicated macros (simply say: root -l <macro.C>), which can be conveniently invoked through a GUI that will appear at the end of the run of this macro. Launch the GUI via the command:; root -l -e 'TMVA::TMVAGui(""TMVACV.root"")'; e#define e(i)Definition RSha256.hxx:103; lTLine lDefinition textangle.C:4. Cross Evaluation; Cross evaluation is a special case of k-folds cross validation where the splitting into k folds is computed deterministically. This ensures that the a given event will always end up in the same fold.; In addition all resulting classifiers are saved and can be applied to new data using MethodCrossValidation. One requirement for this to work is a splitting function that is evaluated for each event to determine into what fold it goes (for training/evaluation) or to what classifier (for application). Split Expression; Cross evaluation uses a deterministic split to partition the data into folds called the split expression. The expression can be any valid TFormula as long as all parts used are defined.; For each event the split expression is evaluated to a number and the event is put in the fold corresponding to that number.; It is recommended to always use int([NumFolds]) at the end of the expression.; The split expression has access to all spectators and variables defined in the dataloader. Additionally, the number of folds in the split can be accessed with NumFolds (or numFolds). Example; ""int(fabs([eventID]))%int([NumFolds])"". Project : TMVA - a ROOT-integrated toolkit for multivariate data analysis; Package :",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidation_8C.html:104,Load,Loading,104,doc/master/TMVACrossValidation_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidation_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVACrossValidationApplication.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVACrossValidationApplication.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides an example of how to use TMVA for k-folds cross evaluation in application. ; This requires that CrossValidation was run with a deterministic split, such as ""...:splitExpr=int([eventID])%int([numFolds]):..."". Project : TMVA - a ROOT-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVACrossValidationApplication. ; : Booking ""BDTG"" of type ""CrossValidation"" from datasetcv/weights/TMVACrossValidation_BDTG.weights.xml.; : Reading weight file: datasetcv/weights/TMVACrossValidation_BDTG.weights.xml; <HEADER> DataSetInfo : [Default] : Added class ""Signal""; <HEADER> DataSetInfo : [Default] : Added class ""Background""; : Reading weightfile: datasetcv/weights/TMVACrossValidation_BDTG_fold1.weights.xml; : Reading weight file: datasetcv/weights/TMVACrossValidation_BDTG_fold1.weights.xml; : Reading weightfile: datasetcv/weights/TMVACrossValidation_BDTG_fold2.weights.xml; : Reading weight file: datasetcv/weights/TMVACrossValidation_BDTG_fold2.weights.xml; : Booked classifier ""BDTG"" of type: ""CrossValidation""; : Booking ""Fisher"" of type ""CrossValidation"" from datasetcv/weights/TMVACrossValidation_Fisher.weights.xml.; : Reading weight file: datasetcv/weights/TMVACrossValidation_Fisher.weights.xml; : Reading weightfile: datasetcv/weights/TMVACrossValidation_Fisher_fold1.weights.xml; : Reading weight file: datasetcv/weights/TMVACrossValidation_Fisher_fold1.weights.xml; : Reading weightfile: datasetcv/weights/TMVACrossValidation_Fisher_fold2.weights.xml; : Reading weight file: datasetcv/weights/TMVACrossValidation_Fisher_fold2.weights.xml; : Booked classifier ""Fisher"" of type: ""CrossValidation""; : Rebuilding Dataset Default; (int) 0; ; #include <cstdlib>; #include <iostream>; #include <map>; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidationApplication_8C.html:115,Load,Loading,115,doc/master/TMVACrossValidationApplication_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidationApplication_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVACrossValidationRegression.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVACrossValidationRegression.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides an example of how to use TMVA for k-folds cross evaluation. ; As input data is used a toy-MC sample consisting of two gaussian distributions.; The output file ""TMVARegCv.root"" can be analysed with the use of dedicated macros (simply say: root -l <macro.C>), which can be conveniently invoked through a GUI that will appear at the end of the run of this macro. Launch the GUI via the command:; root -l -e 'TMVA::TMVAGui(""TMVARegCv.root"")'; e#define e(i)Definition RSha256.hxx:103; lTLine lDefinition textangle.C:4. Cross Evaluation; Cross evaluation is a special case of k-folds cross validation where the splitting into k folds is computed deterministically. This ensures that the a given event will always end up in the same fold.; In addition all resulting classifiers are saved and can be applied to new data using MethodCrossValidation. One requirement for this to work is a splitting function that is evaluated for each event to determine into what fold it goes (for training/evaluation) or to what classifier (for application). Split Expression; Cross evaluation uses a deterministic split to partition the data into folds called the split expression. The expression can be any valid TFormula as long as all parts used are defined.; For each event the split expression is evaluated to a number and the event is put in the fold corresponding to that number.; It is recommended to always use int([NumFolds]) at the end of the expression.; The split expression has access to all spectators and variables defined in the dataloader. Additionally, the number of folds in the split can be accessed with NumFolds (or numFolds). Example; ""int(fabs([eventID]))%int([NumFolds])"". Project : TMVA - a ROOT-integrated toolkit for multivariat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html:114,Load,Loading,114,doc/master/TMVACrossValidationRegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html,1,['Load'],['Loading']
Performance,. ROOT: tutorials/tmva/TMVAGAexample.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAGAexample.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This executable gives an example of a very simple use of the genetic algorithm of TMVA . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Executable: TMVAGAexample. ; Start Test TMVAGAexample; ========================; ; EXAMPLE; range: 0 15; range: 0 13; range: 0 5; : fitness: -160.873 f_0: 13.4483 f_1: 12.8918 f_2: 2.5 ; ---; : fitness: -166.504 f_0: 14.4828 f_1: 12.3598 f_2: 2.5 ; ---; : fitness: -178.422 f_0: 15 f_1: 12.8948 f_2: 5 ; ---; : fitness: -178.422 f_0: 15 f_1: 12.8948 f_2: 5 ; ---; : fitness: -180.587 f_0: 15 f_1: 12.8725 f_2: 2.5 ; ---; : fitness: -180.587 f_0: 15 f_1: 12.8725 f_2: 2.5 ; ---; : fitness: -181.686 f_0: 15 f_1: 12.779 f_2: 0 ; ---; : fitness: -181.686 f_0: 15 f_1: 12.779 f_2: 0 ; ---; : fitness: -183.087 f_0: 15 f_1: 12.8725 f_2: 0 ; ---; : fitness: -183.422 f_0: 15 f_1: 12.8948 f_2: 0 ; ---; : fitness: -183.422 f_0: 15 f_1: 12.8948 f_2: 0 ; ---; : fitness: -183.422 f_0: 15 f_1: 12.8948 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f_1: 12.9972 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f_1: 12.9972 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f_1: 12.9972 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f_1: 12.9972 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f_1: 12.9972 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f_1: 12.9972 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f_1: 12.9972 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f_1: 12.9972 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f_1: 12.9972 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f_1: 12.9972 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f_1: 12.9972 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f_1: 12.9972 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f_1: 12.9972 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f_1: 12.9972 f_2: 0 ; ---; : fitness: -184.957 f_0: 15 f,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAGAexample_8C.html:98,Load,Loading,98,doc/master/TMVAGAexample_8C.html,https://root.cern,https://root.cern/doc/master/TMVAGAexample_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVAGAexample2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAGAexample2.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This executable gives an example of a very simple use of the genetic algorithm of TMVA. . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Executable: TMVAGAexample. ; Start Test TMVAGAexample; ========================; ; ; EXAMPLE; range: 0 15; range: 0 13; range: 0 5; FitterBase : <GeneticFitter> Optimisation, please be patient ... (inaccurate progress timing for GA); : Elapsed time: 0.0113 sec ; FACTOR 0 : 15; FACTOR 1 : 13; FACTOR 2 : 0; ; ; #include <iostream> // Stream declarations; #include <vector>; ; #include ""TMVA/GeneticAlgorithm.h""; #include ""TMVA/GeneticFitter.h""; #include ""TMVA/IFitterTarget.h""; ; using std::vector, std::cout, std::endl;; ; namespace TMVA {; ; ; class MyFitness : public IFitterTarget {; public:; MyFitness() : IFitterTarget() {; }; ; // the fitness-function goes here; // the factors are optimized such that the return-value of this function is minimized; // take care!! the fitness-function must never fail, .. means: you have to prevent; // the function from reaching undefined values (such as x=0 for 1/x or so); //; // HINT: to use INTEGER variables, it is sufficient to cast the ""factor"" in the fitness-function; // to (int). In this case the variable-range has to be chosen +1 ( to get 0..5, take Interval(0,6) ); // since the introduction of ""Interval"" ranges can be defined with a third parameter; // which gives the number of bins within the interval. With that technique discrete values; // can be achieved easier. The random selection out of this discrete numbers is completely uniform.; //; Double_t EstimatorFunction( std::vector<Double_t> & factors ){; //return (10.- (int)factors.at(0) *factors.at(1) + (int)factors.at(2));; return (10.- factors.at(0) *factors.at(1) + factors.at(2));; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAGAexample2_8C.html:99,Load,Loading,99,doc/master/TMVAGAexample2_8C.html,https://root.cern,https://root.cern/doc/master/TMVAGAexample2_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVAMinimalClassification.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAMinimalClassification.C File ReferenceTutorials » TMVA tutorials. Detailed Description; Minimal self-contained example for setting up TMVA with binary classification. ; This is intended as a simple foundation to build on. It assumes you are familiar with TMVA already. As such concepts like the Factory, the DataLoader and others are not explained. For descriptions and tutorials use the TMVA User's Guide (https://root.cern/root-user-guides-and-manuals under TMVA) or the more detailed examples provided with TMVA e.g. TMVAClassification.C.; Sets up a minimal binary classification example with two slightly overlapping 2-D gaussian distributions and trains a BDT classifier to discriminate the data. Project : TMVA - a ROOT-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVAMinimalClassification.C. ; <HEADER> DataSetInfo : [dataset] : Added class ""Signal""; : Add Tree of type Signal with 1000 events; <HEADER> DataSetInfo : [dataset] : Added class ""Background""; : Add Tree of type Background with 1000 events; <HEADER> Factory : Booking method: BDT; : ; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree ; : Building event vectors for type 2 Background; : Dataset[dataset] : create input formulas for tree ; <HEADER> DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Dataset[dataset] : Weight renormalisation mode: ""EqualNumEvents"": renormalises all event classes ...; : Dataset[dataset] : such that the effective (weighted) number of events in each class is the same ; : Dataset[dataset] : (and equals the number of events (entries) given for class=0 ); : Dataset[dataset] : ... i.e. such that Sum[i=1..N_j]{w_i} = N_classA, j=classA, classB, ...; : Dataset[dataset] : ... (note that N_j is the sum of TRAINING eve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMinimalClassification_8C.html:110,Load,Loading,110,doc/master/TMVAMinimalClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMinimalClassification_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVAMulticlass.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAMulticlass.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example for the training and testing of the TMVA multiclass classification . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVAMulticlass. ; ; ==> Start TMVAMulticlass; --- TMVAMulticlass: Using input file: ./files/tmva_multiclass_example.root; DataSetInfo : [dataset] : Added class ""Signal""; : Add Tree TreeS of type Signal with 2000 events; DataSetInfo : [dataset] : Added class ""bg0""; : Add Tree TreeB0 of type bg0 with 2000 events; DataSetInfo : [dataset] : Added class ""bg1""; : Add Tree TreeB1 of type bg1 with 2000 events; DataSetInfo : [dataset] : Added class ""bg2""; : Add Tree TreeB2 of type bg2 with 2000 events; : Dataset[dataset] : Class index : 0 name : Signal; : Dataset[dataset] : Class index : 1 name : bg0; : Dataset[dataset] : Class index : 2 name : bg1; : Dataset[dataset] : Class index : 3 name : bg2; Factory : Booking method: ␛[1mBDTG␛[0m; : ; : the option NegWeightTreatment=InverseBoostNegWeights does not exist for BoostType=Grad; : --> change to new default NegWeightTreatment=Pray; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for type 2 bg0; : Dataset[dataset] : create input formulas for tree TreeB0; : Building event vectors for type 2 bg1; : Dataset[dataset] : create input formulas for tree TreeB1; : Building event vectors for type 2 bg2; : Dataset[dataset] : create input formulas for tree TreeB2; DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 1000; : Signal -- testing",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:99,Load,Loading,99,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVAMulticlass.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAMulticlass.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_tmva; 3/// \notebook -nodraw; 4/// This macro provides a simple example for the training and testing of the TMVA; 5/// multiclass classification; 6/// - Project : TMVA - a Root-integrated toolkit for multivariate data analysis; 7/// - Package : TMVA; 8/// - Root Macro: TMVAMulticlass; 9///; 10/// \macro_output; 11/// \macro_code; 12/// \author Andreas Hoecker; 13 ; 14#include <cstdlib>; 15#include <iostream>; 16#include <map>; 17#include <string>; 18 ; 19#include ""TFile.h""; 20#include ""TTree.h""; 21#include ""TString.h""; 22#include ""TSystem.h""; 23#include ""TROOT.h""; 24 ; 25 ; 26#include ""TMVA/Tools.h""; 27#include ""TMVA/Factory.h""; 28#include ""TMVA/DataLoader.h""; 29#include ""TMVA/TMVAMultiClassGui.h""; 30 ; 31 ; 32using namespace TMVA;; 33 ; 34void TMVAMulticlass( TString myMethodList = """" ); 35{; 36 ; 37 // This loads the library; 38 TMVA::Tools::Instance();; 39 ; 40 // to get access to the GUI and all tmva macros; 41 //; 42 // TString tmva_dir(TString(gRootDir) + ""/tmva"");; 43 // if(gSystem->Getenv(""TMVASYS"")); 44 // tmva_dir = TString(gSystem->Getenv(""TMVASYS""));; 45 // gROOT->SetMacroPath(tmva_dir + ""/test/:"" + gROOT->GetMacroPath() );; 46 // gROOT->ProcessLine("".L TMVAMultiClassGui.C"");; 47 ; 48 ; 49 //---------------------------------------------------------------; 50 // Default MVA methods to be trained + tested; 51 std::map<std::string,int> Use;; 52 Use[""MLP""] = 1;; 53 Use[""BDTG""] = 1;; 54#ifdef R__HAS_TMVAGPU; 55 Use[""DL_CPU""] = 1;; 56 Use[""DL_GPU""] = 1;; 57#else; 58 Use[""DL_CPU""] = 1;; 59 Use[""DL_GPU""] = 0;; 60#endif; 61 Use[""FDA_GA""] = 0;; 62 Use[""PDEFoam""] = 1;; 63 ; 64 //---------------------------------------------------------------; 65 ; 66 std::cout << std::endl;; 67 std::cout << ""==> Start TMVAMulticlass"" << std::endl;; 68 ; 69 if (m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C_source.html:96,Load,Loading,96,doc/master/TMVAMulticlass_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVAMulticlassApplication.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAMulticlassApplication.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVAMulticlassApplication. ; ; ==> Start TMVAMulticlassApp; : Booking ""BDTG method"" of type ""BDT"" from dataset/weights/TMVAMulticlass_BDTG.weights.xml.; : Reading weight file: dataset/weights/TMVAMulticlass_BDTG.weights.xml; <HEADER> DataSetInfo : [Default] : Added class ""Signal""; <HEADER> DataSetInfo : [Default] : Added class ""bg0""; <HEADER> DataSetInfo : [Default] : Added class ""bg1""; <HEADER> DataSetInfo : [Default] : Added class ""bg2""; : Booked classifier ""BDTG"" of type: ""BDT""; : Booking ""DL_CPU method"" of type ""DL"" from dataset/weights/TMVAMulticlass_DL_CPU.weights.xml.; : Reading weight file: dataset/weights/TMVAMulticlass_DL_CPU.weights.xml; : Booked classifier ""DL_CPU"" of type: ""DL""; TMVAMultiClassApplication: Skip DL_GPU method since it has not been trained !; TMVAMultiClassApplication: Skip FDA_GA method since it has not been trained !; : Booking ""MLP method"" of type ""MLP"" from dataset/weights/TMVAMulticlass_MLP.weights.xml.; : Reading weight file: dataset/weights/TMVAMulticlass_MLP.weights.xml; <HEADER> MLP : Building Network. ; : Initializing weights; : Booked classifier ""MLP"" of type: ""MLP""; : Booking ""PDEFoam method"" of type ""PDEFoam"" from dataset/weights/TMVAMulticlass_PDEFoam.weights.xml.; : Reading weight file: dataset/weights/TMVAMulticlass_PDEFoam.weights.xml; : Read foams from file: dataset/weights/TMVAMulticlass_PDEFoam.weights_foams.root; : Booked classifier ""PDEFoam"" of type: ""PDEFoam""; --- TMVAMulticlassApp : Using input file: ./files/tmva_multiclass_example.root; --- Select signal sample; : Reb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlassApplication_8C.html:110,Load,Loading,110,doc/master/TMVAMulticlassApplication_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlassApplication_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVAMulticlassApplication.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAMulticlassApplication.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_tmva; 3/// \notebook -nodraw; 4/// This macro provides a simple example on how to use the trained multiclass; 5/// classifiers within an analysis module; 6/// - Project : TMVA - a Root-integrated toolkit for multivariate data analysis; 7/// - Package : TMVA; 8/// - Root Macro: TMVAMulticlassApplication; 9///; 10/// \macro_output; 11/// \macro_code; 12/// \author Andreas Hoecker; 13 ; 14 ; 15#include <cstdlib>; 16#include <iostream>; 17#include <map>; 18#include <string>; 19#include <vector>; 20 ; 21#include ""TFile.h""; 22#include ""TTree.h""; 23#include ""TString.h""; 24#include ""TSystem.h""; 25#include ""TROOT.h""; 26#include ""TStopwatch.h""; 27#include ""TH1F.h""; 28 ; 29#include ""TMVA/Tools.h""; 30#include ""TMVA/Reader.h""; 31 ; 32using namespace TMVA;; 33 ; 34void TMVAMulticlassApplication( TString myMethodList = """" ); 35{; 36 ; 37 TMVA::Tools::Instance();; 38 ; 39 //---------------------------------------------------------------; 40 // Default MVA methods to be trained + tested; 41 std::map<std::string,int> Use;; 42 Use[""MLP""] = 1;; 43 Use[""BDTG""] = 1;; 44 Use[""DL_CPU""] = 1;; 45 Use[""DL_GPU""] = 1;; 46 Use[""FDA_GA""] = 1;; 47 Use[""PDEFoam""] = 1;; 48 //---------------------------------------------------------------; 49 ; 50 std::cout << std::endl;; 51 std::cout << ""==> Start TMVAMulticlassApp"" << std::endl;; 52 if (myMethodList != """") {; 53 for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) it->second = 0;; 54 ; 55 std::vector<TString> mlist = gTools().SplitString( myMethodList, ',' );; 56 for (UInt_t i=0; i<mlist.size(); i++) {; 57 std::string regMethod(mlist[i]);; 58 ; 59 if (Use.find(regMethod) == Use.end()) {; 60 std::cout << ""Method \"""" << regMethod << ""\"" not known in TMVA under this name. Choose am",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlassApplication_8C_source.html:107,Load,Loading,107,doc/master/TMVAMulticlassApplication_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlassApplication_8C_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVAMultipleBackgroundExample.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAMultipleBackgroundExample.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algorithm. . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Executable: TMVAGAexample. ; Start Test TMVAGAexample; ========================; ; ... event: 0 (200); ======> EVENT:0; var1 = -1.14361; var2 = -0.822373; var3 = -0.395426; var4 = -0.529427; created tree: TreeS; ... event: 0 (200); ======> EVENT:0; var1 = -1.54361; var2 = -1.42237; var3 = -1.39543; var4 = -2.02943; created tree: TreeB0; ... event: 0 (200); ======> EVENT:0; var1 = -1.54361; var2 = -0.822373; var3 = -0.395426; var4 = -2.02943; created tree: TreeB1; ======> EVENT:0; var1 = 0.463304; var2 = 1.37192; var3 = -1.16769; var4 = -1.77551; created tree: TreeB2; created data file: tmva_example_multiple_background.root; ; ========================; --- Training; <HEADER> DataSetInfo : [datasetBkg0] : Added class ""Signal""; : Add Tree TreeS of type Signal with 200 events; <HEADER> DataSetInfo : [datasetBkg0] : Added class ""Background""; : Add Tree TreeB0 of type Background with 200 events; <HEADER> Factory : Booking method: BDTG; : ; : the option NegWeightTreatment=InverseBoostNegWeights does not exist for BoostType=Grad; : --> change to new default NegWeightTreatment=Pray; : Rebuilding Dataset datasetBkg0; : Building event vectors for type 2 Signal; : Dataset[datasetBkg0] : create input formulas for tree TreeS; : Building event vectors for type 2 Background; : Dataset[datasetBkg0] : create input formulas f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMultipleBackgroundExample_8C.html:114,Load,Loading,114,doc/master/TMVAMultipleBackgroundExample_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMultipleBackgroundExample_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVARegression.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVARegression.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides examples for the training and testing of the TMVA classifiers. ; As input data is used a toy-MC sample consisting of four Gaussian-distributed and linearly correlated input variables.; The methods to be used can be switched on and off by means of booleans, or via the prompt command, for example: root -l TMVARegression.C\‍(\""LD,MLP\""\‍); (note that the backslashes are mandatory) If no method given, a default set is used.; The output file ""TMVAReg.root"" can be analysed with the use of dedicated macros (simply say: root -l <macro.C>), which can be conveniently invoked through a GUI that will appear at the end of the run of this macro.; Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVARegression. ; ; ==> Start TMVARegression; --- TMVARegression : Using input file: ./files/tmva_reg_example.root; DataSetInfo : [datasetreg] : Added class ""Regression""; : Add Tree TreeR of type Regression with 10000 events; : Dataset[datasetreg] : Class index : 0 name : Regression; Factory : Booking method: ␛[1mPDEFoam␛[0m; : ; : Rebuilding Dataset datasetreg; : Building event vectors for type 2 Regression; : Dataset[datasetreg] : create input formulas for tree TreeR; DataSetFactory : [datasetreg] : Number of events in input trees; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Regression -- training events : 1000; : Regression -- testing events : 9000; : Regression -- training and testing events: 10000; : ; DataSetInfo : Correlation matrix (Regression):; : ------------------------; : var1 var2; : var1: +1.000 +0.006; : var2: +0.006 +1.000; : ------------------------; DataSetFactory : [datasetreg] : ; : ; Factory : Booking m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:99,Load,Loading,99,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVARegression.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVARegression.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_tmva; 3/// \notebook -nodraw; 4/// This macro provides examples for the training and testing of the; 5/// TMVA classifiers.; 6///; 7/// As input data is used a toy-MC sample consisting of four Gaussian-distributed; 8/// and linearly correlated input variables.; 9///; 10/// The methods to be used can be switched on and off by means of booleans, or; 11/// via the prompt command, for example:; 12///; 13/// root -l TMVARegression.C\‍(\""LD,MLP\""\‍); 14///; 15/// (note that the backslashes are mandatory); 16/// If no method given, a default set is used.; 17///; 18/// The output file ""TMVAReg.root"" can be analysed with the use of dedicated; 19/// macros (simply say: root -l <macro.C>), which can be conveniently; 20/// invoked through a GUI that will appear at the end of the run of this macro.; 21/// - Project : TMVA - a Root-integrated toolkit for multivariate data analysis; 22/// - Package : TMVA; 23/// - Root Macro: TMVARegression; 24///; 25/// \macro_output; 26/// \macro_code; 27/// \author Andreas Hoecker; 28 ; 29#include <cstdlib>; 30#include <iostream>; 31#include <map>; 32#include <string>; 33 ; 34#include ""TChain.h""; 35#include ""TFile.h""; 36#include ""TTree.h""; 37#include ""TString.h""; 38#include ""TObjString.h""; 39#include ""TSystem.h""; 40#include ""TROOT.h""; 41 ; 42#include ""TMVA/Tools.h""; 43#include ""TMVA/Factory.h""; 44#include ""TMVA/DataLoader.h""; 45#include ""TMVA/TMVARegGui.h""; 46 ; 47 ; 48using namespace TMVA;; 49 ; 50void TMVARegression( TString myMethodList = """" ); 51{; 52 // The explicit loading of the shared libTMVA is done in TMVAlogon.C, defined in .rootrc; 53 // if you use your private .rootrc, or run from a different directory, please copy the; 54 // corresponding lines from .rootrc; 55 ; 56 // methods to be processed can be given as an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C_source.html:96,Load,Loading,96,doc/master/TMVARegression_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVARegressionApplication.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVARegressionApplication.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example on how to use the trained regression MVAs within an analysis module . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Executable: TMVARegressionApplication. ; ; ==> Start TMVARegressionApplication; : Booking ""BDTG method"" of type ""BDT"" from datasetreg/weights/TMVARegression_BDTG.weights.xml.; : Reading weight file: datasetreg/weights/TMVARegression_BDTG.weights.xml; <HEADER> DataSetInfo : [Default] : Added class ""Regression""; : Booked classifier ""BDTG"" of type: ""BDT""; : Booking ""DNN_CPU method"" of type ""DL"" from datasetreg/weights/TMVARegression_DNN_CPU.weights.xml.; : Reading weight file: datasetreg/weights/TMVARegression_DNN_CPU.weights.xml; : Booked classifier ""DNN_CPU"" of type: ""DL""; : Booking ""KNN method"" of type ""KNN"" from datasetreg/weights/TMVARegression_KNN.weights.xml.; : Reading weight file: datasetreg/weights/TMVARegression_KNN.weights.xml; : Creating kd-tree with 1000 events; : Computing scale factor for 1d distributions: (ifrac, bottom, top) = (80%, 10%, 90%); <HEADER> ModulekNN : Optimizing tree for 2 variables with 1000 values; : <Fill> Class 1 has 1000 events; : Booked classifier ""KNN"" of type: ""KNN""; : Booking ""LD method"" of type ""LD"" from datasetreg/weights/TMVARegression_LD.weights.xml.; : Reading weight file: datasetreg/weights/TMVARegression_LD.weights.xml; : Booked classifier ""LD"" of type: ""LD""; : Booking ""PDEFoam method"" of type ""PDEFoam"" from datasetreg/weights/TMVARegression_PDEFoam.weights.xml.; : Reading weight file: datasetreg/weights/TMVARegression_PDEFoam.weights.xml; : Read foams from file: datasetreg/weights/TMVARegression_PDEFoam.weights_foams.root; : Booked classifier ""PDEFoam"" of type: ""PDEFoam""; --- TMVARegressionApp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegressionApplication_8C.html:110,Load,Loading,110,doc/master/TMVARegressionApplication_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegressionApplication_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVARegressionApplication.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVARegressionApplication.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_tmva; 3/// \notebook -nodraw; 4/// This macro provides a simple example on how to use the trained regression MVAs; 5/// within an analysis module; 6///; 7/// - Project : TMVA - a Root-integrated toolkit for multivariate data analysis; 8/// - Package : TMVA; 9/// - Executable: TMVARegressionApplication; 10///; 11/// \macro_output; 12/// \macro_code; 13/// \author Andreas Hoecker; 14 ; 15#include <cstdlib>; 16#include <vector>; 17#include <iostream>; 18#include <map>; 19#include <string>; 20 ; 21#include ""TFile.h""; 22#include ""TTree.h""; 23#include ""TString.h""; 24#include ""TSystem.h""; 25#include ""TROOT.h""; 26#include ""TStopwatch.h""; 27 ; 28#include ""TMVA/Tools.h""; 29#include ""TMVA/Reader.h""; 30 ; 31using namespace TMVA;; 32 ; 33void TMVARegressionApplication( TString myMethodList = """" ); 34{; 35 //---------------------------------------------------------------; 36 // This loads the library; 37 TMVA::Tools::Instance();; 38 ; 39 // Default MVA methods to be trained + tested; 40 std::map<std::string,int> Use;; 41 ; 42 // --- Mutidimensional likelihood and Nearest-Neighbour methods; 43 Use[""PDERS""] = 0;; 44 Use[""PDEFoam""] = 1;; 45 Use[""KNN""] = 1;; 46 //; 47 // --- Linear Discriminant Analysis; 48 Use[""LD""] = 1;; 49 //; 50 // --- Function Discriminant analysis; 51 Use[""FDA_GA""] = 0;; 52 Use[""FDA_MC""] = 0;; 53 Use[""FDA_MT""] = 0;; 54 Use[""FDA_GAMT""] = 0;; 55 //; 56 // --- Neural Network; 57 Use[""MLP""] = 0;; 58 // Deep neural network; 59#ifdef R__HAS_TMVAGPU; 60 Use[""DNN_GPU""] = 1;; 61 Use[""DNN_CPU""] = 0;; 62#else; 63 Use[""DNN_GPU""] = 0;; 64#ifdef R__HAS_TMVACPU; 65 Use[""DNN_CPU""] = 1;; 66#else; 67 Use[""DNN_CPU""] = 0;; 68#endif; 69#endif; 70 //; 71 // --- Support Vector Machine; 72 Use[""SVM""] = 0;; 73 //; 74 // --- Boosted Decision Tre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegressionApplication_8C_source.html:107,Load,Loading,107,doc/master/TMVARegressionApplication_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVARegressionApplication_8C_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVA_CNN_Classification.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVA_CNN_Classification.C File ReferenceTutorials » TMVA tutorials. Detailed Description; TMVA Classification Example Using a Convolutional Neural Network ; This is an example of using a CNN in TMVA. We do classification using a toy image data set that is generated when running the example macro. ; Running with nthreads = 4; DataSetInfo : [dataset] : Added class ""Signal""; : Add Tree sig_tree of type Signal with 1000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree bkg_tree of type Background with 1000 events; Factory : Booking method: ␛[1mBDT␛[0m; : ; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree sig_tree; : Using variable vars[0] from array expression vars of size 256; : Building event vectors for type 2 Background; : Dataset[dataset] : create input formulas for tree bkg_tree; : Using variable vars[0] from array expression vars of size 256; DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 800; : Signal -- testing events : 200; : Signal -- training and testing events: 1000; : Background -- training events : 800; : Background -- testing events : 200; : Background -- training and testing events: 1000; : ; Factory : Booking method: ␛[1mTMVA_DNN_CPU␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIER:Layout=DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,DENSE|1|LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.9,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,MaxEpochs=10,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,DropConfig=0.0+0.0+",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:108,Load,Loading,108,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVA_CNN_Classification.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; TMVA_CNN_Classification.py File ReferenceTutorials » TMVA tutorials. Detailed Description; TMVA Classification Example Using a Convolutional Neural Network ; This is an example of using a CNN in TMVA. We do classification using a toy image data set that is generated when running the example macro; ; ; # TMVA Classification Example Using a Convolutional Neural Network; ; ; ## Helper function to create input images data; ## we create a signal and background 2D histograms from 2d gaussians; ## with a location (means in X and Y) different for each event; ## The difference between signal and background is in the gaussian width.; ## The width for the background gaussian is slightly larger than the signal width by few % values; ; import os; import importlib.util; ; opt = [1, 1, 1, 1, 1]; useTMVACNN = opt[0] if len(opt) > 0 else False; useKerasCNN = opt[1] if len(opt) > 1 else False; useTMVADNN = opt[2] if len(opt) > 2 else False; useTMVABDT = opt[3] if len(opt) > 3 else False; usePyTorchCNN = opt[4] if len(opt) > 4 else False; ; tf_spec = importlib.util.find_spec(""tensorflow""); if tf_spec is None:; useKerasCNN = False; print(""TMVA_CNN_Classificaton"",""Skip using Keras since tensorflow is not installed""); else:; import tensorflow; ; # PyTorch has to be imported before ROOT to avoid crashes because of clashing; # std::regexp symbols that are exported by cppyy.; # See also: https://github.com/wlav/cppyy/issues/227; torch_spec = importlib.util.find_spec(""torch""); if torch_spec is None:; usePyTorchCNN = False; print(""TMVA_CNN_Classificaton"",""Skip using PyTorch since torch is not installed""); else:; import torch; ; ; import ROOT; ; ; TMVA = ROOT.TMVA; TFile = ROOT.TFile; ; TMVA.Tools.Instance(); ; def MakeImagesTree(n, nh, nw):; # image size (nh x nw); ntot = nh * nw; fileOutName = ""images_data_16x16.root""; nRndmEvts = 1000",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html:109,Load,Loading,109,doc/master/TMVA__CNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVA_Higgs_Classification.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVA_Higgs_Classification.C File ReferenceTutorials » TMVA tutorials. Detailed Description; Classification example of TMVA based on public Higgs UCI dataset ; The UCI data set is a public HIGGS data set , see http://archive.ics.uci.edu/ml/datasets/HIGGS used in this paper: Baldi, P., P. Sadowski, and D. Whiteson. “Searching for Exotic Particles in High-energy Physics with Deep Learning.” Nature Communications 5 (July 2, 2014). ; ******************************************************************************; *Tree :sig_tree : tree *; *Entries : 10000 : Total = 1177229 bytes File Size = 785298 *; * : : Tree compression factor = 1.48 *; ******************************************************************************; *Br 0 :Type : Type/F *; *Entries : 10000 : Total Size= 40556 bytes File Size = 307 *; *Baskets : 1 : Basket Size= 1500672 bytes Compression= 130.54 *; *............................................................................*; *Br 1 :lepton_pT : lepton_pT/F *; *Entries : 10000 : Total Size= 40581 bytes File Size = 30464 *; *Baskets : 1 : Basket Size= 1500672 bytes Compression= 1.32 *; *............................................................................*; *Br 2 :lepton_eta : lepton_eta/F *; *Entries : 10000 : Total Size= 40586 bytes File Size = 28650 *; *Baskets : 1 : Basket Size= 1500672 bytes Compression= 1.40 *; *............................................................................*; *Br 3 :lepton_phi : lepton_phi/F *; *Entries : 10000 : Total Size= 40586 bytes File Size = 30508 *; *Baskets : 1 : Basket Size= 1500672 bytes Compression= 1.31 *; *............................................................................*; *Br 4 :missing_energy_magnitude : missing_energy_magnitude/F *; *Entries : 10000 : Total Size= 40656 bytes File Size = 35749 *; *Baskets : 1 : Basket Size= 1500672 bytes Com",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:110,Load,Loading,110,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVA_Higgs_Classification.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; TMVA_Higgs_Classification.py File ReferenceTutorials » TMVA tutorials. Detailed Description; Classification example of TMVA based on public Higgs UCI dataset ; The UCI data set is a public HIGGS data set , see http://archive.ics.uci.edu/ml/datasets/HIGGS used in this paper: Baldi, P., P. Sadowski, and D. Whiteson. “Searching for Exotic Particles in High-energy Physics with Deep Learning.” Nature Communications 5 (July 2, 2014). ******************************************************************************; *Tree :sig_tree : tree *; *Entries : 10000 : Total = 1177229 bytes File Size = 785298 *; * : : Tree compression factor = 1.48 *; ******************************************************************************; *Br 0 :Type : Type/F *; *Entries : 10000 : Total Size= 40556 bytes File Size = 307 *; *Baskets : 1 : Basket Size= 1500672 bytes Compression= 130.54 *; *............................................................................*; *Br 1 :lepton_pT : lepton_pT/F *; *Entries : 10000 : Total Size= 40581 bytes File Size = 30464 *; *Baskets : 1 : Basket Size= 1500672 bytes Compression= 1.32 *; *............................................................................*; *Br 2 :lepton_eta : lepton_eta/F *; *Entries : 10000 : Total Size= 40586 bytes File Size = 28650 *; *Baskets : 1 : Basket Size= 1500672 bytes Compression= 1.40 *; *............................................................................*; *Br 3 :lepton_phi : lepton_phi/F *; *Entries : 10000 : Total Size= 40586 bytes File Size = 30508 *; *Baskets : 1 : Basket Size= 1500672 bytes Compression= 1.31 *; *............................................................................*; *Br 4 :missing_energy_magnitude : missing_energy_magnitude/F *; *Entries : 10000 : Total Size= 40656 bytes File Size = 35749 *; *Baskets : 1 : Basket Size= 1500",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:111,Load,Loading,111,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVA_RNN_Classification.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVA_RNN_Classification.C File ReferenceTutorials » TMVA tutorials. Detailed Description; TMVA Classification Example Using a Recurrent Neural Network ; This is an example of using a RNN in TMVA. We do classification using a toy time dependent data set that is generated when running this example macro. ; Running with nthreads = 4; --- RNNClassification : Using input file: time_data_t10_d30.root; DataSetInfo : [dataset] : Added class ""Signal""; : Add Tree sgn of type Signal with 2000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree bkg of type Background with 2000 events; number of variables is 300; vars_time0[0],vars_time0[1],vars_time0[2],vars_time0[3],vars_time0[4],vars_time0[5],vars_time0[6],vars_time0[7],vars_time0[8],vars_time0[9],vars_time0[10],vars_time0[11],vars_time0[12],vars_time0[13],vars_time0[14],vars_time0[15],vars_time0[16],vars_time0[17],vars_time0[18],vars_time0[19],vars_time0[20],vars_time0[21],vars_time0[22],vars_time0[23],vars_time0[24],vars_time0[25],vars_time0[26],vars_time0[27],vars_time0[28],vars_time0[29],vars_time1[0],vars_time1[1],vars_time1[2],vars_time1[3],vars_time1[4],vars_time1[5],vars_time1[6],vars_time1[7],vars_time1[8],vars_time1[9],vars_time1[10],vars_time1[11],vars_time1[12],vars_time1[13],vars_time1[14],vars_time1[15],vars_time1[16],vars_time1[17],vars_time1[18],vars_time1[19],vars_time1[20],vars_time1[21],vars_time1[22],vars_time1[23],vars_time1[24],vars_time1[25],vars_time1[26],vars_time1[27],vars_time1[28],vars_time1[29],vars_time2[0],vars_time2[1],vars_time2[2],vars_time2[3],vars_time2[4],vars_time2[5],vars_time2[6],vars_time2[7],vars_time2[8],vars_time2[9],vars_time2[10],vars_time2[11],vars_time2[12],vars_time2[13],vars_time2[14],vars_time2[15],vars_time2[16],vars_time2[17],vars_time2[18],vars_time2[19],vars_time2[20],vars_time2[21],vars_time2[22],vars_time2[23",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:108,Load,Loading,108,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVA_RNN_Classification.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; TMVA_RNN_Classification.py File ReferenceTutorials » TMVA tutorials. Detailed Description; TMVA Classification Example Using a Recurrent Neural Network ; This is an example of using a RNN in TMVA. We do classification using a toy time dependent data set that is generated when running this example macro. DataSetInfo : [dataset] : Added class ""Signal""; : Add Tree sgn of type Signal with 2000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree bkg of type Background with 2000 events; Factory : Booking method: ␛[1mTMVA_LSTM␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIERUNIFORM:ValidationSize=0.2:RandomSeed=1234:InputLayout=10|30:Layout=LSTM|10|30|10|0|1,RESHAPE|FLAT,DENSE|64|TANH,LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,WeightDecay=1e-2,Regularization=None,MaxEpochs=10Optimizer=ADAM,DropConfig=0.0+0.+0.+0.:Architecture=CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIERUNIFORM:ValidationSize=0.2:RandomSeed=1234:InputLayout=10|30:Layout=LSTM|10|30|10|0|1,RESHAPE|FLAT,DENSE|64|TANH,LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,WeightDecay=1e-2,Regularization=None,MaxEpochs=10Optimizer=ADAM,DropConfig=0.0+0.+0.+0.:Architecture=CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""None"" [List of variable transformations performed before training, e.g., ""D_Backgroun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:109,Load,Loading,109,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVA_SOFIE_GNN_Application.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Functions |; Variables ; TMVA_SOFIE_GNN_Application.C File Reference. #include ""encoder.hxx""; #include ""core.hxx""; #include ""decoder.hxx""; #include ""output_transform.hxx""; #include ""TMVA/SOFIE_common.hxx""; #include ""TRandom3.h""; #include ""TH1.h""; #include ""TCanvas.h""; #include ""TFile.h""; #include ""TTree.h""; #include ""TSystem.h""; #include ""ROOT/RDataFrame.hxx"". Include dependency graph for TMVA_SOFIE_GNN_Application.C:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  SOFIE_GNN;  . Functions; double check_mem (std::string s="""");  ; std::vector< GNN_Data > GenerateData (int nevts, int seed);  ; int main ();  ; void Print (GNN_Data &d, std::string txt="""");  ; template<class T > ; void PrintTensor (RTensor< T > &t);  ; std::vector< GNN_Data > ReadData (std::string treename, std::string filename);  ; void TMVA_SOFIE_GNN_Application (bool verbose=false);  . Variables; const int EDGE_FEATURE_SIZE = 4;  ; const int GLOBAL_FEATURE_SIZE = 1;  ; const int NODE_FEATURE_SIZE = 4;  ; const int num_max_edges = 30;  ; const int num_max_nodes = 10;  . Function Documentation. ◆ check_mem(). double check_mem ; (; std::string ; s = """"). Definition at line 27 of file TMVA_SOFIE_GNN_Application.C. ◆ GenerateData(). std::vector< GNN_Data > GenerateData ; (; int ; nevts, . int ; seed . ). Definition at line 109 of file TMVA_SOFIE_GNN_Application.C. ◆ main(). int main ; (; ). Definition at line 234 of file TMVA_SOFIE_GNN_Application.C. ◆ Print(). void Print ; (; GNN_Data & ; d, . std::string ; txt = """" . ). Definition at line 59 of file TMVA_SOFIE_GNN_Application.C. ◆ PrintTensor(). template<class T > . void PrintTensor ; (; RTensor< T > & ; t). Definition at line 40 of file TMVA_SOFIE_GNN_Application.C. ◆ ReadData(). std::vector< GNN_Data > ReadData ; (; std::string ; treename, . s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__GNN__Application_8C.html:111,Load,Loading,111,doc/master/TMVA__SOFIE__GNN__Application_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__GNN__Application_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVA_SOFIE_GNN_Application.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVA_SOFIE_GNN_Application.C. Go to the documentation of this file. 1// Macor evaluating a GNN model which was generated with the Parser macro; 2//; 3 ; 4// need to add include path to find generated model file; 5#ifdef __CLING__; 6R__ADD_INCLUDE_PATH($PWD); 7R__ADD_INCLUDE_PATH($ROOTSYS/runtutorials); 8#endif; 9 ; 10#include ""encoder.hxx""; 11#include ""core.hxx""; 12#include ""decoder.hxx""; 13#include ""output_transform.hxx""; 14 ; 15#include ""TMVA/SOFIE_common.hxx""; 16#include ""TRandom3.h""; 17#include ""TH1.h""; 18#include ""TCanvas.h""; 19#include ""TFile.h""; 20#include ""TTree.h""; 21#include ""TSystem.h""; 22#include ""ROOT/RDataFrame.hxx""; 23 ; 24using namespace TMVA::Experimental;; 25using namespace TMVA::Experimental::SOFIE;; 26 ; 27double check_mem(std::string s = """"){; 28 ProcInfo_t p;; 29 printf(""%s - "",s.c_str());; 30 gSystem->GetProcInfo(&p);; 31 printf("" Rmem = %8.3f MB, Vmem = %8.f3 MB \n"",; 32 p.fMemResident /1024., /// convert memory from kB to MB; 33 p.fMemVirtual /1024.; 34 );; 35 return p.fMemResident / 1024.;; 36}; 37 ; 38 ; 39template<class T>; 40void PrintTensor(RTensor<T> & t) {; 41 std::cout << "" shape : "" << ConvertShapeToString(t.GetShape()) << "" size : "" << t.GetSize() << ""\n"";; 42 auto & shape = t.GetShape();; 43 auto p = t.GetData();; 44 size_t nrows = (shape.size() > 1) ? shape[0] : 1;; 45 size_t ncols = (shape.size() > 1) ? t.GetStrides()[0] : shape[0];; 46 for (size_t i = 0; i < nrows; i++) {; 47 for (size_t j = 0; j < ncols; j++) {; 48 if (j==ncols-1) {; 49 if (j>10) std::cout << ""... "";; 50 std::cout << *p << std::endl;; 51 }; 52 else if (j<10); 53 std::cout << *p << "", "";; 54 p++;; 55 }; 56 }; 57 std::cout << std::endl;; 58}; 59void Print(GNN_Data & d, std::string txt = """") {; 60 if (!txt.empty()) std::cout << std::endl << txt << std::endl;; 61 std::cout << ""node data:""; PrintTensor(d.node_data);; 62 st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__GNN__Application_8C_source.html:108,Load,Loading,108,doc/master/TMVA__SOFIE__GNN__Application_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__GNN__Application_8C_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVA_SOFIE_GNN_Parser.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVA_SOFIE_GNN_Parser.py. Go to the documentation of this file. 1## Tutorial showing how to parse a GNN from GraphNet and make a SOFIE model; 2## The tutorial also generate some data which can serve as input for the tutorial TMVA_SOFIE_GNN_Application.C; 3import ROOT; 4 ; 5import numpy as np; 6import graph_nets as gn; 7from graph_nets import utils_tf; 8import sonnet as snt; 9#for getting time and memory; 10import time; 11import os; 12import psutil; 13 ; 14# defining graph properties. Number of edges/modes are the maximum; 15num_max_nodes=100; 16num_max_edges=300; 17node_size=4; 18edge_size=4; 19global_size=1; 20LATENT_SIZE = 100; 21NUM_LAYERS = 4; 22processing_steps = 5; 23numevts = 100; 24 ; 25verbose = False; 26 ; 27#print the used memory in MB; 28def printMemory(s = """") :; 29 #get memory of current process; 30 pid = os.getpid(); 31 python_process = psutil.Process(pid); 32 memoryUse = python_process.memory_info()[0]/(1024.*1024.) #divide by 1024 * 1024 to get memory in MB; 33 print(s,""memory:"",memoryUse,""(MB)""); 34 ; 35 ; 36# method for returning dictionary of graph data; 37def get_dynamic_graph_data_dict(NODE_FEATURE_SIZE=2, EDGE_FEATURE_SIZE=2, GLOBAL_FEATURE_SIZE=1):; 38 num_nodes = np.random.randint(num_max_nodes-2, size=1)[0] + 2; 39 num_edges = np.random.randint(num_max_edges-1, size=1)[0] + 1; 40 return {; 41 ""globals"": 10*np.random.rand(GLOBAL_FEATURE_SIZE).astype(np.float32)-5.,; 42 ""nodes"": 10*np.random.rand(num_nodes, NODE_FEATURE_SIZE).astype(np.float32)-5.,; 43 ""edges"": 10*np.random.rand(num_edges, EDGE_FEATURE_SIZE).astype(np.float32)-5.,; 44 ""senders"": np.random.randint(num_nodes, size=num_edges, dtype=np.int32),; 45 ""receivers"": np.random.randint(num_nodes, size=num_edges, dtype=np.int32); 46 }; 47 ; 48# generate graph data with a fixed number of nodes/edges; 49def get_fix_graph_data_dict(num_nodes, num_edges,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__GNN__Parser_8py_source.html:104,Load,Loading,104,doc/master/TMVA__SOFIE__GNN__Parser_8py_source.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__GNN__Parser_8py_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVA_SOFIE_Inference.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; TMVA_SOFIE_Inference.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides an example of using a trained model with Keras and make inference using SOFIE directly from Numpy This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before this one. ; In this case we are parsing the input file and then run the inference in the same macro making use of the ROOT JITing capability; ; import ROOT; import numpy as np; ; ; ROOT.TMVA.PyMethodBase.PyInitialize(); ; ; # check if the input file exists; modelFile = ""Higgs_trained_model.h5""; if (ROOT.gSystem.AccessPathName(modelFile)) :; ROOT.Info(""TMVA_SOFIE_RDataFrame"",""You need to run TMVA_Higgs_Classification.C to generate the Keras trained model""); exit(); ; ; # parse the input Keras model into RModel object; model = ROOT.TMVA.Experimental.SOFIE.PyKeras.Parse(modelFile); ; generatedHeaderFile = modelFile.replace("".h5"","".hxx""); print(""Generating inference code for the Keras model from "",modelFile,""in the header "", generatedHeaderFile); #Generating inference code; model.Generate(); model.OutputGenerated(generatedHeaderFile); model.PrintGenerated(); ; # now compile using ROOT JIT trained model; modelName = modelFile.replace("".h5"",""""); print(""compiling SOFIE model "", modelName); ROOT.gInterpreter.Declare('#include ""' + generatedHeaderFile + '""'); ; ; generatedHeaderFile = modelFile.replace("".h5"","".hxx""); print(""Generating inference code for the Keras model from "",modelFile,""in the header "", generatedHeaderFile); #Generating inference; ; inputFileName = ""Higgs_data.root""; inputFile = ""http://root.cern.ch/files/"" + inputFileName; ; ; ; ; ; # make SOFIE inference on signal data; ; df1 = ROOT.RDataFrame(""sig_tree"", inputFile); sigData = df1.AsNumpy(columns=['m_jj', 'm_jjj', 'm_lv', 'm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__Inference_8py.html:106,Load,Loading,106,doc/master/TMVA__SOFIE__Inference_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__Inference_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVA_SOFIE_Keras.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVA_SOFIE_Keras.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example for the parsing of Keras .h5 file into RModel object and further generating the .hxx header files for inference. ; ; using namespace TMVA::Experimental;; ; TString pythonSrc = ""\; import os\n\; os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\n\; \n\; import numpy as np\n\; from tensorflow.keras.models import Model\n\; from tensorflow.keras.layers import Input,Dense,Activation,ReLU\n\; from tensorflow.keras.optimizers import SGD\n\; \n\; input=Input(shape=(64,),batch_size=4)\n\; x=Dense(32)(input)\n\; x=Activation('relu')(x)\n\; x=Dense(16,activation='relu')(x)\n\; x=Dense(8,activation='relu')(x)\n\; x=Dense(4)(x)\n\; output=ReLU()(x)\n\; model=Model(inputs=input,outputs=output)\n\; \n\; randomGenerator=np.random.RandomState(0)\n\; x_train=randomGenerator.rand(4,64)\n\; y_train=randomGenerator.rand(4,4)\n\; \n\; model.compile(loss='mean_squared_error', optimizer=SGD(learning_rate=0.01))\n\; model.fit(x_train, y_train, epochs=5, batch_size=4)\n\; model.save('KerasModel.h5')\n"";; ; ; void TMVA_SOFIE_Keras(const char * modelFile = nullptr, bool printModelInfo = true){; ; //Running the Python script to generate Keras .h5 file; TMVA::PyMethodBase::PyInitialize();; ; if (modelFile == nullptr) {; TMacro m;; m.AddLine(pythonSrc);; m.SaveSource(""make_keras_model.py"");; gSystem->Exec(TMVA::Python_Executable() + "" make_keras_model.py"");; modelFile = ""KerasModel.h5"";; }; ; //Parsing the saved Keras .h5 file into RModel object; SOFIE::RModel model = SOFIE::PyKeras::Parse(modelFile);; ; ; //Generating inference code; model.Generate();; // generate output header. By default it will be modelName.hxx; model.OutputGenerated();; ; if (!printModelInfo) return;; ; //Printing required input tensors; std::cout<<""\n\n"";; model.PrintRequiredInpu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__Keras_8C.html:101,Load,Loading,101,doc/master/TMVA__SOFIE__Keras_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__Keras_8C.html,2,"['Load', 'optimiz']","['Loading', 'optimizers']"
Performance,. ROOT: tutorials/tmva/TMVA_SOFIE_Keras_HiggsModel.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVA_SOFIE_Keras_HiggsModel.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro run the SOFIE parser on the Keras model obtaining running TMVA_Higgs_Classification.C You need to run that macro before this one ; AuthorLorenzo Moneta ; Definition in file TMVA_SOFIE_Keras_HiggsModel.C. tutorialstmvaTMVA_SOFIE_Keras_HiggsModel.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__Keras__HiggsModel_8C.html:112,Load,Loading,112,doc/master/TMVA__SOFIE__Keras__HiggsModel_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__Keras__HiggsModel_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVA_SOFIE_Models.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; TMVA_SOFIE_Models.py File ReferenceTutorials » TMVA tutorials. Detailed Description; Example of inference with SOFIE using a set of models trained with Keras. ; This tutorial shows how to store several models in a single header file and the weights in a ROOT binary file. The models are then evaluated using the RDataFrame First, generate the input model by running TMVA_Higgs_Classification.C.; This tutorial parses the input model and runs the inference using ROOT's JITing capability.; ; import ROOT; from os.path import exists; ; ROOT.TMVA.PyMethodBase.PyInitialize(); ; ; ## generate and train Keras models with different architectures; ; import numpy as np; from tensorflow.keras.models import Sequential; from tensorflow.keras.layers import Dense; from tensorflow.keras.optimizers import Adam; ; from sklearn.model_selection import train_test_split; ; def CreateModel(nlayers = 4, nunits = 64):; model = Sequential(); model.add(Dense(nunits, activation='relu',input_dim=7)); for i in range(1,nlayers) :; model.add(Dense(nunits, activation='relu')); ; model.add(Dense(1, activation='sigmoid')); model.compile(loss = 'binary_crossentropy', optimizer = Adam(learning_rate = 0.001), weighted_metrics = ['accuracy']); model.summary(); return model; ; def PrepareData() :; #get the input data; inputFileName = ""Higgs_data.root""; inputFile = ""http://root.cern.ch/files/"" + inputFileName; ; df1 = ROOT.RDataFrame(""sig_tree"", inputFile); sigData = df1.AsNumpy(columns=['m_jj', 'm_jjj', 'm_lv', 'm_jlv', 'm_bb', 'm_wbb', 'm_wwbb']); #print(sigData); ; # stack all the 7 numpy array in a single array (nevents x nvars); xsig = np.column_stack(list(sigData.values())); data_sig_size = xsig.shape[0]; print(""size of data"", data_sig_size); ; # make SOFIE inference on background data; df2 = ROOT.RDataFrame(""bkg_tree"", inputFile); bkgData = df2.AsNumpy(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__Models_8py.html:103,Load,Loading,103,doc/master/TMVA__SOFIE__Models_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__Models_8py.html,2,"['Load', 'optimiz']","['Loading', 'optimizers']"
Performance,". ROOT: tutorials/tmva/TMVA_SOFIE_ONNX.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVA_SOFIE_ONNX.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example for the parsing of ONNX files into RModel object and further generating the .hxx header files for inference. ; ; using namespace TMVA::Experimental;; ; void TMVA_SOFIE_ONNX(std::string inputFile = """"){; if (inputFile.empty() ); inputFile = std::string(gROOT->GetTutorialsDir()) + ""/tmva/Linear_16.onnx"";; ; //Creating parser object to parse ONNX files; SOFIE::RModelParser_ONNX parser;; SOFIE::RModel model = parser.Parse(inputFile, true);; ; //Generating inference code; model.Generate();; // write the code in a file (by default Linear_16.hxx and Linear_16.dat; model.OutputGenerated();; ; //Printing required input tensors; model.PrintRequiredInputTensors();; ; //Printing initialized tensors (weights); std::cout<<""\n\n"";; model.PrintInitializedTensors();; ; //Printing intermediate tensors; std::cout<<""\n\n"";; model.PrintIntermediateTensors();; ; //Checking if tensor already exist in model; std::cout<<""\n\nTensor \""16weight\"" already exist: ""<<std::boolalpha<<model.CheckIfTensorAlreadyExist(""16weight"")<<""\n\n"";; std::vector<size_t> tensorShape = model.GetTensorShape(""16weight"");; std::cout<<""Shape of tensor \""16weight\"": "";; for(auto& it:tensorShape){; std::cout<<it<<"","";; }; std::cout<<""\n\nData type of tensor \""16weight\"": "";; SOFIE::ETensorType tensorType = model.GetTensorType(""16weight"");; std::cout<<SOFIE::ConvertTypeToString(tensorType);; ; //Printing generated inference code; std::cout<<""\n\n"";; model.PrintGenerated();; }; gROOT#define gROOTDefinition TROOT.h:406; TMVA::Experimental::SOFIE::RModelParser_ONNXDefinition RModelParser_ONNX.hxx:27; TMVA::Experimental::SOFIE::RModelParser_ONNX::ParseRModel Parse(std::string filename, bool verbose=false)Definition RModelParser_ONNX.cxx:312; TMVA::Experimental::SOFIE::RMo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__ONNX_8C.html:100,Load,Loading,100,doc/master/TMVA__SOFIE__ONNX_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__ONNX_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVA_SOFIE_PyTorch.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVA_SOFIE_PyTorch.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example for the parsing of PyTorch .pt file into RModel object and further generating the .hxx header files for inference. ; ; using namespace TMVA::Experimental;; ; TString pythonSrc = ""\; import torch\n\; import torch.nn as nn\n\; \n\; model = nn.Sequential(\n\; nn.Linear(32,16),\n\; nn.ReLU(),\n\; nn.Linear(16,8),\n\; nn.ReLU()\n\; )\n\; \n\; criterion = nn.MSELoss()\n\; optimizer = torch.optim.SGD(model.parameters(),lr=0.01)\n\; \n\; x=torch.randn(2,32)\n\; y=torch.randn(2,8)\n\; \n\; for i in range(500):\n\; y_pred = model(x)\n\; loss = criterion(y_pred,y)\n\; optimizer.zero_grad()\n\; loss.backward()\n\; optimizer.step()\n\; \n\; model.eval()\n\; m = torch.jit.script(model)\n\; torch.jit.save(m,'PyTorchModel.pt')\n"";; ; ; void TMVA_SOFIE_PyTorch(){; ; //Running the Python script to generate PyTorch .pt file; TMVA::PyMethodBase::PyInitialize();; ; TMacro m;; m.AddLine(pythonSrc);; m.SaveSource(""make_pytorch_model.py"");; gSystem->Exec(TMVA::Python_Executable() + "" make_pytorch_model.py"");; ; //Parsing a PyTorch model requires the shape and data-type of input tensor; //Data-type of input tensor defaults to Float if not specified; std::vector<size_t> inputTensorShapeSequential{2,32};; std::vector<std::vector<size_t>> inputShapesSequential{inputTensorShapeSequential};; ; //Parsing the saved PyTorch .pt file into RModel object; SOFIE::RModel model = SOFIE::PyTorch::Parse(""PyTorchModel.pt"",inputShapesSequential);; ; //Generating inference code; model.Generate();; model.OutputGenerated(""PyTorchModel.hxx"");; ; //Printing required input tensors; std::cout<<""\n\n"";; model.PrintRequiredInputTensors();; ; //Printing initialized tensors (weights); std::cout<<""\n\n"";; model.PrintInitializedTensors();; ; //Printing intermediat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__PyTorch_8C.html:103,Load,Loading,103,doc/master/TMVA__SOFIE__PyTorch_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__PyTorch_8C.html,4,"['Load', 'optimiz']","['Loading', 'optimizer']"
Performance,". ROOT: tutorials/tmva/TMVA_SOFIE_RDataFrame.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVA_SOFIE_RDataFrame.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides an example of using a trained model with Keras and make inference using SOFIE and RDataFrame This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before to generate the trained Keras model Then you need to run the macro TMVA_SOFIE_Keras_HiggsModel.C to generate the corresponding header file using SOFIE. ; Execute in this order: root TMVA_Higgs_Classification.C; root TMVA_SOFIE_Keras_HiggsModel.C; root TMVA_SOFIE_RDataFrame.C; TMVA_Higgs_ClassificationDefinition TMVA_Higgs_Classification.py:1; TMVA_SOFIE_RDataFrameDefinition TMVA_SOFIE_RDataFrame.py:1; ; using namespace TMVA::Experimental;; ; // need to add the current directory (from where we are running this macro); // to the include path for Cling; R__ADD_INCLUDE_PATH($PWD); R__ADD_INCLUDE_PATH($ROOTSYS/runtutorials); #include ""Higgs_trained_model.hxx""; #include ""TMVA/SOFIEHelpers.hxx""; ; using namespace TMVA::Experimental;; ; void TMVA_SOFIE_RDataFrame(int nthreads = 2){; ; std::string inputFileName = ""Higgs_data.root"";; std::string inputFile = ""http://root.cern.ch/files/"" + inputFileName;; ; ROOT::EnableImplicitMT(nthreads);; ; ROOT::RDataFrame df1(""sig_tree"", inputFile);; int nslots = df1.GetNSlots();; std::cout << ""Running using "" << nslots << "" threads"" << std::endl;; auto h1 = df1.DefineSlot(""DNN_Value"", SofieFunctor<7, TMVA_SOFIE_Higgs_trained_model::Session>(nslots),; {""m_jj"", ""m_jjj"", ""m_lv"", ""m_jlv"", ""m_bb"", ""m_wbb"", ""m_wwbb""}); .Histo1D({""h_sig"", """", 100, 0, 1}, ""DNN_Value"");; ; ROOT::RDataFrame df2(""bkg_tree"", inputFile);; nslots = df2.GetNSlots();; auto h2 = df2.DefineSlot(""DNN_Value"", SofieFunctor<7, TMVA_SOFIE_Higgs_trained_model::Session>(nslots),; {""m_jj"", ""m_jjj"", ""m_lv"", ""m_jlv"", """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame_8C.html:106,Load,Loading,106,doc/master/TMVA__SOFIE__RDataFrame_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVA_SOFIE_RDataFrame.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; TMVA_SOFIE_RDataFrame.py File ReferenceTutorials » TMVA tutorials. Detailed Description; Example of inference with SOFIE and RDataFrame, of a model trained with Keras. ; First, generate the input model by running TMVA_Higgs_Classification.C.; This tutorial parses the input model and runs the inference using ROOT's JITing capability.; ; import ROOT; from os.path import exists; ; ROOT.TMVA.PyMethodBase.PyInitialize(); ; ; # check if the input file exists; modelFile = ""Higgs_trained_model.h5""; modelName = ""Higgs_trained_model""; ; ; if not exists(modelFile):; raise FileNotFoundError(""You need to run TMVA_Higgs_Classification.C to generate the Keras trained model""); ; # parse the input Keras model into RModel object; model = ROOT.TMVA.Experimental.SOFIE.PyKeras.Parse(modelFile); ; # generating inference code; model.Generate(); model.OutputGenerated(""Higgs_trained_model_generated.hxx""); model.PrintGenerated(); ; # compile using ROOT JIT trained model; print(""compiling SOFIE model and functor....""); ROOT.gInterpreter.Declare('#include ""Higgs_trained_model_generated.hxx""'); ROOT.gInterpreter.Declare('auto sofie_functor = TMVA::Experimental::SofieFunctor<7,TMVA_SOFIE_'+modelName+'::Session>(0,""Higgs_trained_model_generated.dat"");'); ; # run inference over input data; inputFile = ""http://root.cern/files/Higgs_data.root""; df1 = ROOT.RDataFrame(""sig_tree"", inputFile); h1 = df1.Define(""DNN_Value"", ""sofie_functor(rdfslot_,m_jj, m_jjj, m_lv, m_jlv, m_bb, m_wbb, m_wwbb)"").Histo1D((""h_sig"", """", 100, 0, 1),""DNN_Value""); ; df2 = ROOT.RDataFrame(""bkg_tree"", inputFile); h2 = df2.Define(""DNN_Value"", ""sofie_functor(rdfslot_,m_jj, m_jjj, m_lv, m_jlv, m_bb, m_wbb, m_wwbb)"").Histo1D((""h_bkg"", """", 100, 0, 1),""DNN_Value""); ; # run over the input data once, combining both RDataFrame graphs.; ROOT.RDF.RunGraphs([h1, h2]);; ; print(""Number of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame_8py.html:107,Load,Loading,107,doc/master/TMVA__SOFIE__RDataFrame_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVA_SOFIE_RDataFrame_JIT.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVA_SOFIE_RDataFrame_JIT.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides an example of using a trained model with Keras and make inference using SOFIE and RDataFrame This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before this one. ; In this case we are parsing the input file and then run the inference in the same macro making use of the ROOT JITing capability; ; using namespace TMVA::Experimental;; ; /// function to compile the generated model and the declaration of the SofieFunctor; /// used by RDF.; /// Assume that the model name as in the header file; void CompileModelForRDF(const std::string & headerModelFile, unsigned int ninputs, unsigned int nslots=0) {; ; std::string modelName = headerModelFile.substr(0,headerModelFile.find("".hxx""));; std::string cmd = std::string(""#include \"""") + headerModelFile + std::string(""\"""");; auto ret = gInterpreter->Declare(cmd.c_str());; if (!ret); throw std::runtime_error(""Error compiling : "" + cmd);; std::cout << ""compiled : "" << cmd << std::endl;; ; cmd = ""auto sofie_functor = TMVA::Experimental::SofieFunctor<"" + std::to_string(ninputs) + "",TMVA_SOFIE_"" +; modelName + ""::Session>("" + std::to_string(nslots) + "");"";; ret = gInterpreter->Declare(cmd.c_str());; if (!ret); throw std::runtime_error(""Error compiling : "" + cmd);; std::cout << ""compiled : "" << cmd << std::endl;; std::cout << ""Model is ready to be evaluated"" << std::endl;; return;; }; ; void TMVA_SOFIE_RDataFrame_JIT(std::string modelFile = ""Higgs_trained_model.h5""){; ; TMVA::PyMethodBase::PyInitialize();; ; // check if the input file exists; if (gSystem->AccessPathName(modelFile.c_str())) {; Info(""TMVA_SOFIE_RDataFrame"",""You need to run TMVA_Higgs_Classification.C to generate the Keras trained model"");; return;; };",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html:110,Load,Loading,110,doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/TMVA_SOFIE_RSofieReader.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVA_SOFIE_RSofieReader.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides an example of using a trained model with Keras and make inference using SOFIE with the RSofieReader class This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before to generate the trained Keras model ; Execute in this order: root TMVA_Higgs_Classification.C; root TMVA_SOFIE_RSofieReader.C; TMVA_Higgs_ClassificationDefinition TMVA_Higgs_Classification.py:1; ; using namespace TMVA::Experimental;; ; void TMVA_SOFIE_RSofieReader(){; ; RSofieReader model(""Higgs_trained_model.h5"");; // for debugging; //RSofieReader model(""Higgs_trained_model.h5"", {}, true);; ; // the input shape for this model is a tensor with shape (1,7); ; std::vector<float> input = {0.1,0.2,0.3,0.4,0.5,0.6,0.7};; ; // predict model on a single event (takes a std::vector<float>); ; auto output = model.Compute(input);; ; std::cout << ""Event prediction = "" << output[0] << std::endl;; ; // predict model now on a input file using RDataFrame; ; std::string inputFileName = ""Higgs_data.root"";; std::string inputFile = ""http://root.cern.ch/files/"" + inputFileName;; ; ; ROOT::RDataFrame df1(""sig_tree"", inputFile);; ; auto h1 = df1.Define(""DNN_Values"", Compute<7, float>(model),; {""m_jj"", ""m_jjj"", ""m_lv"", ""m_jlv"", ""m_bb"", ""m_wbb"", ""m_wwbb""}); .Define(""y"",""DNN_Values[0]""); .Histo1D({""h_sig"", """", 100, 0, 1}, ""y"");; ; ROOT::RDataFrame df2(""bkg_tree"", inputFile);; auto h2 = df2.Define(""DNN_Values"", Compute<7, float>(model),; {""m_jj"", ""m_jjj"", ""m_lv"", ""m_jlv"", ""m_bb"", ""m_wbb"", ""m_wwbb""}); .Define(""y"",""DNN_Values[0]""); .Histo1D({""h_bkg"", """", 100, 0, 1}, ""y"");; ; h1->SetLineColor(kRed);; h2->SetLineColor(kBlue);; ; auto c1 = new TCanvas();; gStyle->SetOptStat(0);; ; h2->DrawClone();; h1->DrawClone(""SAM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__RSofieReader_8C.html:108,Load,Loading,108,doc/master/TMVA__SOFIE__RSofieReader_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RSofieReader_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/createData.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. createData.C File ReferenceTutorials » TMVA tutorials. Detailed Description; Plot the variables. ; ; ; #include ""TROOT.h""; #include ""TMath.h""; #include ""TTree.h""; #include ""TArrayD.h""; #include ""TStyle.h""; #include ""TFile.h""; #include ""TRandom.h""; #include ""Riostream.h""; #include ""TCanvas.h""; #include ""TMatrixD.h""; #include ""TH2F.h""; #include ""TLegend.h""; #include ""TBranch.h""; #include <vector>; ; void plot( TString fname = ""data.root"", TString var0=""var0"", TString var1=""var1"" ); {; TFile* dataFile = TFile::Open( fname );; ; if (!dataFile) {; cout << ""ERROR: cannot open file: "" << fname << endl;; return;; }; ; TTree *treeS = (TTree*)dataFile->Get(""TreeS"");; TTree *treeB = (TTree*)dataFile->Get(""TreeB"");; ; TCanvas* c = new TCanvas( ""c"", """", 0, 0, 550, 550 );; ; TStyle *TMVAStyle = gROOT->GetStyle(""Plain""); // our style is based on Plain; TMVAStyle->SetOptStat(0);; TMVAStyle->SetPadTopMargin(0.02);; TMVAStyle->SetPadBottomMargin(0.16);; TMVAStyle->SetPadRightMargin(0.03);; TMVAStyle->SetPadLeftMargin(0.15);; TMVAStyle->SetPadGridX(0);; TMVAStyle->SetPadGridY(0);; ; TMVAStyle->SetOptTitle(0);; TMVAStyle->SetTitleW(.4);; TMVAStyle->SetTitleH(.10);; TMVAStyle->SetTitleX(.5);; TMVAStyle->SetTitleY(.9);; TMVAStyle->SetMarkerStyle(20);; TMVAStyle->SetMarkerSize(1.6);; TMVAStyle->cd();; ; ; Float_t xmin = TMath::Min( treeS->GetMinimum( var0 ), treeB->GetMinimum( var0 ) );; Float_t xmax = TMath::Max( treeS->GetMaximum( var0 ), treeB->GetMaximum( var0 ) );; Float_t ymin = TMath::Min( treeS->GetMinimum( var1 ), treeB->GetMinimum( var1 ) );; Float_t ymax = TMath::Max( treeS->GetMaximum( var1 ), treeB->GetMaximum( var1 ) );; ; Int_t nbin = 500;; TH2F* frameS = new TH2F( ""DataS"", ""DataS"", nbin, xmin, xmax, nbin, ymin, ymax );; TH2F* frameB = new TH2F( ""DataB"", ""DataB"", nbin, xmin, xmax, nbin, ymin, ymax );; ; // project trees; treeS->Draw( Form(""%s:%",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/createData_8C.html:95,Load,Loading,95,doc/master/createData_8C.html,https://root.cern,https://root.cern/doc/master/createData_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/keras Directory Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. keras Directory Reference. Directory dependency graph for keras:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files;  ApplicationClassificationKeras.py;   This tutorial shows how to apply a trained model to new data. ;  ;  ApplicationRegressionKeras.py;   This tutorial shows how to apply a trained model to new data (regression). ;  ;  ClassificationKeras.py;   This tutorial shows how to do classification in TMVA with neural networks trained with keras. ;  ;  GenerateModel.py;   This tutorial shows how to define and generate a keras model for use with TMVA. ;  ;  MulticlassKeras.py;   This tutorial shows how to do multiclass classification in TMVA with neural networks trained with keras. ;  ;  RegressionKeras.py;   This tutorial shows how to do regression in TMVA with neural networks trained with keras. ;  . tutorialstmvakeras. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_983ef7a33b0c59dc2d471f36240bf58a.html:93,Load,Loading,93,doc/master/dir_983ef7a33b0c59dc2d471f36240bf58a.html,https://root.cern,https://root.cern/doc/master/dir_983ef7a33b0c59dc2d471f36240bf58a.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/keras/ClassificationKeras.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; ClassificationKeras.py File ReferenceTutorials » TMVA tutorials » TMVA Keras tutorials. Detailed Description; This tutorial shows how to do classification in TMVA with neural networks trained with keras. ; ; from ROOT import TMVA, TFile, TTree, TCut; from subprocess import call; from os.path import isfile; ; from tensorflow.keras.models import Sequential; from tensorflow.keras.layers import Dense, Activation; from tensorflow.keras.optimizers import SGD; ; # Setup TMVA; TMVA.Tools.Instance(); TMVA.PyMethodBase.PyInitialize(); ; output = TFile.Open('TMVA_Classification_Keras.root', 'RECREATE'); factory = TMVA.Factory('TMVAClassification', output,; '!V:!Silent:Color:DrawProgressBar:Transformations=D,G:AnalysisType=Classification'); ; # Load data; if not isfile('tmva_class_example.root'):; call(['curl', '-L', '-O', 'http://root.cern/files/tmva_class_example.root']); ; data = TFile.Open('tmva_class_example.root'); signal = data.Get('TreeS'); background = data.Get('TreeB'); ; dataloader = TMVA.DataLoader('dataset'); for branch in signal.GetListOfBranches():; dataloader.AddVariable(branch.GetName()); ; dataloader.AddSignalTree(signal, 1.0); dataloader.AddBackgroundTree(background, 1.0); dataloader.PrepareTrainingAndTestTree(TCut(''),; 'nTrain_Signal=4000:nTrain_Background=4000:SplitMode=Random:NormMode=NumEvents:!V'); ; # Generate model; ; # Define model; model = Sequential(); model.add(Dense(64, activation='relu', input_dim=4)); model.add(Dense(2, activation='softmax')); ; # Set loss and optimizer; model.compile(loss='categorical_crossentropy',; optimizer=SGD(learning_rate=0.01), weighted_metrics=['accuracy', ]); ; # Store model to file; model.save('modelClassification.h5'); model.summary(); ; # Book methods; factory.BookMethod(dataloader, TMVA.Types.kFisher, 'Fisher',; '!H:!V:Fisher:VarTransform=D,G'); factory.Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ClassificationKeras_8py.html:111,Load,Loading,111,doc/master/ClassificationKeras_8py.html,https://root.cern,https://root.cern/doc/master/ClassificationKeras_8py.html,3,"['Load', 'optimiz']","['Load', 'Loading', 'optimizers']"
Performance,". ROOT: tutorials/tmva/keras/ClassificationKeras.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ClassificationKeras.py. Go to the documentation of this file. 1#!/usr/bin/env python; 2## \file; 3## \ingroup tutorial_tmva_keras; 4## \notebook -nodraw; 5## This tutorial shows how to do classification in TMVA with neural networks; 6## trained with keras.; 7##; 8## \macro_code; 9##; 10## \date 2017; 11## \author TMVA Team; 12 ; 13from ROOT import TMVA, TFile, TTree, TCut; 14from subprocess import call; 15from os.path import isfile; 16 ; 17from tensorflow.keras.models import Sequential; 18from tensorflow.keras.layers import Dense, Activation; 19from tensorflow.keras.optimizers import SGD; 20 ; 21# Setup TMVA; 22TMVA.Tools.Instance(); 23TMVA.PyMethodBase.PyInitialize(); 24 ; 25output = TFile.Open('TMVA_Classification_Keras.root', 'RECREATE'); 26factory = TMVA.Factory('TMVAClassification', output,; 27 '!V:!Silent:Color:DrawProgressBar:Transformations=D,G:AnalysisType=Classification'); 28 ; 29# Load data; 30if not isfile('tmva_class_example.root'):; 31 call(['curl', '-L', '-O', 'http://root.cern/files/tmva_class_example.root']); 32 ; 33data = TFile.Open('tmva_class_example.root'); 34signal = data.Get('TreeS'); 35background = data.Get('TreeB'); 36 ; 37dataloader = TMVA.DataLoader('dataset'); 38for branch in signal.GetListOfBranches():; 39 dataloader.AddVariable(branch.GetName()); 40 ; 41dataloader.AddSignalTree(signal, 1.0); 42dataloader.AddBackgroundTree(background, 1.0); 43dataloader.PrepareTrainingAndTestTree(TCut(''),; 44 'nTrain_Signal=4000:nTrain_Background=4000:SplitMode=Random:NormMode=NumEvents:!V'); 45 ; 46# Generate model; 47 ; 48# Define model; 49model = Sequential(); 50model.add(Dense(64, activation='relu', input_dim=4)); 51model.add(Dense(2, activation='softmax')); 52 ; 53# Set loss and optimizer; 54model.compile(loss='categorical_crossentropy',; 55 optimizer=SGD(learning_rate=0.01), weighted_metrics=['accuracy', ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ClassificationKeras_8py_source.html:108,Load,Loading,108,doc/master/ClassificationKeras_8py_source.html,https://root.cern,https://root.cern/doc/master/ClassificationKeras_8py_source.html,2,"['Load', 'optimiz']","['Loading', 'optimizers']"
Performance,". ROOT: tutorials/tmva/tmva001_RTensor.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva001_RTensor.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates the basic features of the RTensor class, RTensor is a std::vector-like container with additional shape information. ; The class serves as an interface in C++ between multi-dimensional data and the algorithm such as in machine learning workflows. The interface is similar to Numpy arrays and provides a subset of the functionality.; ; using namespace TMVA::Experimental;; ; void tmva001_RTensor(); {; // Create RTensor from scratch; RTensor<float> x({2, 2});; cout << x << endl;; ; // Assign some data; x(0, 0) = 1;; x(0, 1) = 2;; x(1, 0) = 3;; x(1, 1) = 4;; ; // Apply transformations; auto x2 = x.Reshape({1, 4}).Squeeze();; cout << x2 << endl;; ; // Slice; auto x3 = x.Reshape({2, 2}).Slice({{0, 2}, {0, 1}});; cout << x3 << endl;; ; // Create tensor as view on data without ownership; float data[] = {5, 6, 7, 8};; RTensor<float> y(data, {2, 2});; cout << y << endl;; ; // Create tensor as view on data with ownership; auto data2 = std::make_shared<std::vector<float>>(4);; float c = 9;; for (auto &v : *data2) {; v = c;; c++;; }; ; RTensor<float> z(data2, {2, 2});; cout << z << endl;; }; c#define c(i)Definition RSha256.hxx:101; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; TMVA::Experimental::RTensorRTensor is a container with contiguous memory and shape information.Definition RTensor.hxx:162; TMVA::Experimental::RTensor::ReshapeRTensor< Value_t, Container_t > Reshape(const Shape_t &shape) constReshape tensor.Definition RTensor.hxx:480; RooFit::SliceRooCmdArg Slice(const RooArgSet &sliceSet)Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva001__RTensor_8C.html:100,Load,Loading,100,doc/master/tmva001__RTensor_8C.html,https://root.cern,https://root.cern/doc/master/tmva001__RTensor_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/tmva002_RDataFrameAsTensor.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva002_RDataFrameAsTensor.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial shows how the content of an RDataFrame can be converted to an RTensor object. ; ; using namespace TMVA::Experimental;; ; void tmva002_RDataFrameAsTensor(); {; // Creation of an RDataFrame with five entries filled with ascending numbers; ROOT::RDataFrame df(5);; auto df2 = df.Define(""x"", ""1.f*rdfentry_"").Define(""y"", ""-1.f*rdfentry_"");; ; // Convert content of columns to an RTensor object; auto x = AsTensor<float>(df2);; ; std::cout << ""RTensor from an RDataFrame:\n"" << x << ""\n\n"";; ; // The utility also supports reading only a part of the RDataFrame and different; // memory layouts.; auto x2 = AsTensor<float>(df2, {""x""}, MemoryLayout::ColumnMajor);; ; std::cout << ""RTensor from a single column of the RDataFrame:\n"" << x2 << ""\n\n"";; }; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; xDouble_t x[n]Definition legend1.C:17; TMVA::ExperimentalDefinition RModelParser_Keras.h:40; ; RTensor from an RDataFrame:; { { 0, -0 } { 1, -1 } { 2, -2 } { 3, -3 } { 4, -4 } }; ; RTensor from a single column of the RDataFrame:; { { 0 } { 1 } { 2 } { 3 } { 4 } }; ; DateDecember 2018 ; AuthorStefan Wunsch ; Definition in file tmva002_RDataFrameAsTensor.C. tutorialstmvatmva002_RDataFrameAsTensor.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva002__RDataFrameAsTensor_8C.html:111,Load,Loading,111,doc/master/tmva002__RDataFrameAsTensor_8C.html,https://root.cern,https://root.cern/doc/master/tmva002__RDataFrameAsTensor_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/tmva003_RReader.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva003_RReader.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial shows how to apply with the modern interfaces models saved in TMVA XML files. ; ; using namespace TMVA::Experimental;; ; void train(const std::string &filename); {; // Create factory; auto output = TFile::Open(""TMVARR.root"", ""RECREATE"");; auto factory = new TMVA::Factory(""tmva003"",; output, ""!V:!DrawProgressBar:AnalysisType=Classification"");; ; // Open trees with signal and background events; auto data = TFile::Open(filename.c_str());; auto signal = (TTree *)data->Get(""TreeS"");; auto background = (TTree *)data->Get(""TreeB"");; ; // Add variables and register the trees with the dataloader; auto dataloader = new TMVA::DataLoader(""tmva003_BDT"");; const std::vector<std::string> variables = {""var1"", ""var2"", ""var3"", ""var4""};; for (const auto &var : variables) {; dataloader->AddVariable(var);; }; dataloader->AddSignalTree(signal, 1.0);; dataloader->AddBackgroundTree(background, 1.0);; dataloader->PrepareTrainingAndTestTree("""", """");; ; // Train a TMVA method; factory->BookMethod(dataloader, TMVA::Types::kBDT, ""BDT"", ""!V:!H:NTrees=300:MaxDepth=2"");; factory->TrainAllMethods();; }; ; void tmva003_RReader(); {; // First, let's train a model with TMVA.; const std::string filename = ""http://root.cern/files/tmva_class_example.root"";; train(filename);; ; // Next, we load the model from the TMVA XML file.; RReader model(""tmva003_BDT/weights/tmva003_BDT.weights.xml"");; ; // In case you need a reminder of the names and order of the variables during; // training, you can ask the model for it.; auto variables = model.GetVariableNames();; ; // The model can now be applied in different scenarios:; // 1) Event-by-event inference; // 2) Batch inference on data of multiple events; // 3) Inference as part of an RDataFrame graph; ; // 1) Event-by-event inference; /",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva003__RReader_8C.html:100,Load,Loading,100,doc/master/tmva003__RReader_8C.html,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/tmva004_RStandardScaler.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva004_RStandardScaler.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates the usage of the standard scaler as preprocessing method. ; ; using namespace TMVA::Experimental;; ; void tmva004_RStandardScaler(); {; // Load data used to fit the parameters; ROOT::RDataFrame df(""TreeS"", ""http://root.cern/files/tmva_class_example.root"");; auto x = AsTensor<float>(df);; ; // Create standard scaler and fit to data; RStandardScaler<float> scaler;; scaler.Fit(x);; ; // Compute transformation; auto y = scaler.Compute(x);; ; // Plot first variable scaled and unscaled; TH1F h1(""h1"", "";x_{4};N_{Events}"", 20, -4, 4);; TH1F h2(""h2"", "";x_{4};N_{Events}"", 20, -4, 4);; for (std::size_t i = 0; i < x.GetShape()[0]; i++) {; h1.Fill(x(i, 3));; h2.Fill(y(i, 3));; }; h1.SetLineWidth(2);; h1.SetLineColor(kRed);; h2.SetLineWidth(2);; h2.SetLineColor(kBlue);; ; gStyle->SetOptStat(0);; auto c = new TCanvas("""", """", 800, 800);; h2.Draw(""HIST"");; h1.Draw(""HIST SAME"");; ; TLegend legend(0.7, 0.7, 0.89, 0.89);; legend.SetBorderSize(0);; legend.AddEntry(""h1"", ""Unscaled"", ""l"");; legend.AddEntry(""h2"", ""Scaled"", ""l"");; legend.Draw();; ; c->DrawClone();; }; c#define c(i)Definition RSha256.hxx:101; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::Fillvirtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva004__RStandardScaler_8C.html:108,Load,Loading,108,doc/master/tmva004__RStandardScaler_8C.html,https://root.cern,https://root.cern/doc/master/tmva004__RStandardScaler_8C.html,2,['Load'],"['Load', 'Loading']"
Performance,". ROOT: tutorials/tmva/tmva100_DataPreparation.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva100_DataPreparation.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates how to prepare ROOT datasets to be nicely readable by most machine learning methods. ; This requires filtering the initial complex datasets and writing the data in a flat format.; ; import ROOT; ; ; def filter_events(df):; """"""; Reduce initial dataset to only events which shall be used for training; """"""; return df.Filter(""nElectron>=2 && nMuon>=2"", ""At least two electrons and two muons""); ; ; def define_variables(df):; """"""; Define the variables which shall be used for training; """"""; return df.Define(""Muon_pt_1"", ""Muon_pt[0]"")\; .Define(""Muon_pt_2"", ""Muon_pt[1]"")\; .Define(""Electron_pt_1"", ""Electron_pt[0]"")\; .Define(""Electron_pt_2"", ""Electron_pt[1]""); ; ; variables = [""Muon_pt_1"", ""Muon_pt_2"", ""Electron_pt_1"", ""Electron_pt_2""]; ; ; if __name__ == ""__main__"":; for filename, label in [[""SMHiggsToZZTo4L.root"", ""signal""], [""ZZTo2e2mu.root"", ""background""]]:; print("">>> Extract the training and testing events for {} from the {} dataset."".format(; label, filename)); ; # Load dataset, filter the required events and define the training variables; filepath = ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/"" + filename; df = ROOT.RDataFrame(""Events"", filepath); df = filter_events(df); df = define_variables(df); ; # Book cutflow report; report = df.Report(); ; # Split dataset by event number for training and testing; columns = ROOT.std.vector[""string""](variables); df.Filter(""event % 2 == 0"", ""Select events with even event number for training"")\; .Snapshot(""Events"", ""train_"" + label + "".root"", columns); df.Filter(""event % 2 == 1"", ""Select events with odd event number for training"")\; .Snapshot(""Events"", ""test_"" + label + "".root"", columns); ; # Print cutflow report; report.Print(); formatOpti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva100__DataPreparation_8py.html:109,Load,Loading,109,doc/master/tmva100__DataPreparation_8py.html,https://root.cern,https://root.cern/doc/master/tmva100__DataPreparation_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/tmva101_Training.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva101_Training.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ; Using XGBoost, we illustrate how you can convert an externally trained model in a format serializable and readable with the fast tree inference engine offered by TMVA.; ; # XGBoost has to be imported before ROOT to avoid crashes because of clashing; # std::regexp symbols that are exported by cppyy.; # See also: https://github.com/wlav/cppyy/issues/227; from xgboost import XGBClassifier; ; import ROOT; import numpy as np; ; from tmva100_DataPreparation import variables; ; ; def load_data(signal_filename, background_filename):; # Read data from ROOT files; data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); ; # Convert inputs to format readable by machine learning tools; x_sig = np.vstack([data_sig[var] for var in variables]).T; x_bkg = np.vstack([data_bkg[var] for var in variables]).T; x = np.vstack([x_sig, x_bkg]); ; # Create labels; num_sig = x_sig.shape[0]; num_bkg = x_bkg.shape[0]; y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); ; # Compute weights balancing both classes; num_all = num_sig + num_bkg; w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); ; return x, y, w; ; if __name__ == ""__main__"":; # Load data; x, y, w = load_data(""train_signal.root"", ""train_background.root""); ; # Fit xgboost model; bdt = XGBClassifier(max_depth=3, n_estimators=500); bdt.fit(x, y, sample_weight=w); ; # Save model in TMVA format; print(""Training done on "",x.shape[0],""events. Saving model in tmva101.root""); ROOT.TMVA.Experimental.SaveXGBoost(bdt, ""myBDT"", ""tmva101.root"", num_inputs=x.shape[1])",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva101__Training_8py.html:102,Load,Loading,102,doc/master/tmva101__Training_8py.html,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/tmva101_Training.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva101_Training.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_tmva; 3## \notebook -nodraw; 4## This tutorial show how you can train a machine learning model with any package; 5## reading the training data directly from ROOT files. Using XGBoost, we illustrate; 6## how you can convert an externally trained model in a format serializable and readable; 7## with the fast tree inference engine offered by TMVA.; 8##; 9## \macro_code; 10## \macro_output; 11##; 12## \date August 2019; 13## \author Stefan Wunsch; 14 ; 15# XGBoost has to be imported before ROOT to avoid crashes because of clashing; 16# std::regexp symbols that are exported by cppyy.; 17# See also: https://github.com/wlav/cppyy/issues/227; 18from xgboost import XGBClassifier; 19 ; 20import ROOT; 21import numpy as np; 22 ; 23from tmva100_DataPreparation import variables; 24 ; 25 ; 26def load_data(signal_filename, background_filename):; 27 # Read data from ROOT files; 28 data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); 29 data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); 30 ; 31 # Convert inputs to format readable by machine learning tools; 32 x_sig = np.vstack([data_sig[var] for var in variables]).T; 33 x_bkg = np.vstack([data_bkg[var] for var in variables]).T; 34 x = np.vstack([x_sig, x_bkg]); 35 ; 36 # Create labels; 37 num_sig = x_sig.shape[0]; 38 num_bkg = x_bkg.shape[0]; 39 y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); 40 ; 41 # Compute weights balancing both classes; 42 num_all = num_sig + num_bkg; 43 w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); 44 ; 45 return x, y, w; 46 ; 47if __name__ == ""__main__"":; 48 # Load data; 49 x, y, w = load_data(""train_signal.root"", ""train_background.root""); 50 ; 51 # Fit xgboost model; 52 bdt = XGBClassifier(max_depth=3, n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva101__Training_8py_source.html:99,Load,Loading,99,doc/master/tmva101__Training_8py_source.html,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tmva/tmva102_Testing.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva102_Testing.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ; ; import ROOT; import pickle; ; from tmva100_DataPreparation import variables; from tmva101_Training import load_data; ; ; # Load data; x, y_true, w = load_data(""test_signal.root"", ""test_background.root""); ; # Load trained model; File = ""tmva101.root""; if (ROOT.gSystem.AccessPathName(File)) :; ROOT.Info(""tmva102_Testing.py"", File+""does not exist""); exit(); ; bdt = ROOT.TMVA.Experimental.RBDT(""myBDT"", File); ; # Make prediction; y_pred = bdt.Compute(x); ; # Compute ROC using sklearn; from sklearn.metrics import roc_curve, auc; false_positive_rate, true_positive_rate, _ = roc_curve(y_true, y_pred, sample_weight=w); score = auc(false_positive_rate, true_positive_rate); ; # Plot ROC; c = ROOT.TCanvas(""roc"", """", 600, 600); g = ROOT.TGraph(len(false_positive_rate), false_positive_rate, true_positive_rate); g.SetTitle(""AUC = {:.2f}"".format(score)); g.SetLineWidth(3); g.SetLineColor(ROOT.kRed); g.Draw(""AC""); g.GetXaxis().SetRangeUser(0, 1); g.GetYaxis().SetRangeUser(0, 1); g.GetXaxis().SetTitle(""False-positive rate""); g.GetYaxis().SetTitle(""True-positive rate""); c.Draw(); lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva102__Testing_8py.html:101,Load,Loading,101,doc/master/tmva102__Testing_8py.html,https://root.cern,https://root.cern/doc/master/tmva102__Testing_8py.html,3,['Load'],"['Load', 'Loading']"
Performance,". ROOT: tutorials/tmva/tmva103_Application.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva103_Application.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates how you can conveniently apply BDTs in C++ using the fast tree inference engine offered by TMVA. ; Supported workflows are event-by-event inference, batch inference and pipelines with RDataFrame.; ; using namespace TMVA::Experimental;; ; void tmva103_Application(); {; const char* model_filename = ""tmva101.root"";; ; if (gSystem->AccessPathName(model_filename)) {; Info(""tmva103_Application.C"", ""%s does not exist"", model_filename);; return;; }; ; // Load BDT model; RBDT bdt(""myBDT"", model_filename);; ; // Apply model on a single input; auto y1 = bdt.Compute({1.0, 2.0, 3.0, 4.0});; ; std::cout << ""Apply model on a single input vector: "" << y1[0] << std::endl;; ; // Apply model on a batch of inputs; float data[8] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0};; RTensor<float> x(data, {2, 4});; auto y2 = bdt.Compute(x);; ; std::cout << ""Apply model on an input tensor: "" << y2 << std::endl;; ; // Apply model as part of an RDataFrame workflow; ROOT::RDataFrame df(""Events"", ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/SMHiggsToZZTo4L.root"");; auto df2 = df.Filter(""nMuon >= 2""); .Filter(""nElectron >= 2""); .Define(""Muon_pt_1"", ""Muon_pt[0]""); .Define(""Muon_pt_2"", ""Muon_pt[1]""); .Define(""Electron_pt_1"", ""Electron_pt[0]""); .Define(""Electron_pt_2"", ""Electron_pt[1]""); .Define(""y"",; Compute<4, float>(bdt),; {""Muon_pt_1"", ""Muon_pt_2"", ""Electron_pt_1"", ""Electron_pt_2""});; ; std::cout << ""Mean response on the signal sample: "" << *df2.Mean(""y"") << std::endl;; }; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva103__Application_8C.html:104,Load,Loading,104,doc/master/tmva103__Application_8C.html,https://root.cern,https://root.cern/doc/master/tmva103__Application_8C.html,2,['Load'],"['Load', 'Loading']"
Performance,". ROOT: tutorials/tree Directory Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tree Directory Reference. Directory dependency graph for tree:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Directories;  dictionary;  . Files;  basic.C;   Read data from an ascii file and create a root file with an histogram and an ntuple. ;  ;  basic2.C;   Create can ntuple reading data from an ascii file. ;  ;  bill.C;   Benchmark comparing row-wise and column-wise storage performance ;  ;  cernbuild.C;   Read data (CERN staff) from an ascii file and create a root file with a Tree. ;  ;  cernstaff.C;   Playing with a Tree containing variables of type character ;  ;  circular.C;   Example of a circular Tree ;  ;  clonesA_Event.C;  Example to write & read a Tree built with a complex class inheritance tree. ;  ;  clonesA_Event.cxx;  ;  clonesA_Event.h;  ;  copytree.C;   Copy a subset of a Tree to a new Tree ;  ;  copytree2.C;   Copy a subset of a Tree to a new Tree, one branch in a separate file. ;  ;  copytree3.C;   Example of Root macro to copy a subset of a Tree to a new Tree, selecting entries. ;  ;  drawsparse.C;   Convert a THnSparse to a TTree using efficient iteration through the THnSparse and draw a THnSparse using TParallelCoord. ;  ;  h1analysis.C;   Example of analysis class for the H1 data. ;  ;  h1analysis.h;  ;  h1analysisProxy.C;  Example of analysis class for the H1 data using code generated by MakeProxy. ;  ;  h1analysisProxy.h;  ;  h1analysisProxyCut.C;  ;  h1analysisTreeReader.C;  H1 analysis example expressed in terms of TTreeReader (see h1analysis.C). ;  ;  h1analysisTreeReader.h;  ;  h1chain.C;   Creates a TChain to be used by the h1analysis.C class the symbol H1 must point to a directory where the H1 data sets have been installed. ;  ;  hsimpleProxy.C;   Used by hsimpleProxyDriver.C. ;  ;  hsimpleProxyDriver.C;   This is the driver of the hsimpleProxy example. ;  ;  hsimpleReader.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html:87,Load,Loading,87,doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html,https://root.cern,https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html,2,"['Load', 'perform']","['Loading', 'performance']"
Performance,". ROOT: tutorials/tree/basic.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. basic.C File ReferenceTutorials » Tree tutorials. Detailed Description; Read data from an ascii file and create a root file with an histogram and an ntuple. ; See a variant of this macro in basic2.C.; ; #include ""Riostream.h""; void basic() {; // read file $ROOTSYS/tutorials/tree/basic.dat; // this file has 3 columns of float data; TString dir = gROOT->GetTutorialDir();; dir.Append(""/tree/"");; dir.ReplaceAll(""/./"",""/"");; ifstream in;; in.open(Form(""%sbasic.dat"",dir.Data()));; ; Float_t x,y,z;; Int_t nlines = 0;; auto f = TFile::Open(""basic.root"",""RECREATE"");; TH1F h1(""h1"",""x distribution"",100,-4,4);; TNtuple ntuple(""ntuple"",""data from ascii file"",""x:y:z"");; ; while (1) {; in >> x >> y >> z;; if (!in.good()) break;; if (nlines < 5) printf(""x=%8f, y=%8f, z=%8f\n"",x,y,z);; h1.Fill(x);; ntuple.Fill(x,y,z);; nlines++;; }; printf("" found %d points\n"",nlines);; ; in.close();; ; f->Write();; }; f#define f(i)Definition RSha256.hxx:104; Riostream.h; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; gROOT#define gROOTDefinition TROOT.h:406; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/basic_8C.html:90,Load,Loading,90,doc/master/basic_8C.html,https://root.cern,https://root.cern/doc/master/basic_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/basic2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. basic2.C File ReferenceTutorials » Tree tutorials. Detailed Description; Create can ntuple reading data from an ascii file. ; This macro is a variant of basic.C. ; void basic2() {; TString dir = gROOT->GetTutorialDir();; dir.Append(""/tree/"");; dir.ReplaceAll(""/./"",""/"");; ; TFile *f = new TFile(""basic2.root"",""RECREATE"");; TH1F *h1 = new TH1F(""h1"",""x distribution"",100,-4,4);; TTree *T = new TTree(""ntuple"",""data from ascii file"");; Long64_t nlines = T->ReadFile(Form(""%sbasic.dat"",dir.Data()),""x:y:z"");; printf("" found %lld points\n"",nlines);; T->Draw(""x"",""z>2"");; T->Write();; }; f#define f(i)Definition RSha256.hxx:104; Long64_tlong long Long64_tDefinition RtypesCore.h:69; gROOT#define gROOTDefinition TROOT.h:406; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; h1TH1F * h1Definition legend1.C:5; AuthorRene Brun ; Definition in file basic2.C. tutorialstreebasic2.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/basic2_8C.html:91,Load,Loading,91,doc/master/basic2_8C.html,https://root.cern,https://root.cern/doc/master/basic2_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/bill.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. bill.C File ReferenceTutorials » Tree tutorials. Detailed Description; Benchmark comparing row-wise and column-wise storage performance ; The test consists in writing/reading to/from keys or trees To execute the benchmark: root -b -q bill.C or root -b -q bill.C++; b#define b(i)Definition RSha256.hxx:100; qfloat * qDefinition THbookFile.cxx:89; for example for N=10000, the following output is produced on an 2.7 GHz Intel Core i7 (year 2011). The names featuring a ""t"" are relative to trees, the faster, the better. billw0 : RT= 0.803 s, Cpu= 0.800 s, File size= 45608143 bytes, CX= 1; billr0 : RT= 0.388 s, Cpu= 0.390 s; billtw0 : RT= 0.336 s, Cpu= 0.310 s, File size= 45266881 bytes, CX= 1.00034; billtr0 : RT= 0.229 s, Cpu= 0.230 s; billw1 : RT= 1.671 s, Cpu= 1.670 s, File size= 16760526 bytes, CX= 2.72078; billr1 : RT= 0.667 s, Cpu= 0.680 s; billtw1 : RT= 0.775 s, Cpu= 0.770 s, File size= 9540884 bytes, CX= 4.74501; billtr1 : RT= 0.352 s, Cpu= 0.350 s; billtot : RT= 5.384 s, Cpu= 5.290 s; ******************************************************************; * ROOTMARKS =1763.9 * Root6.05/03 20150914/948; ******************************************************************; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/bill_8C.html:89,Load,Loading,89,doc/master/bill_8C.html,https://root.cern,https://root.cern/doc/master/bill_8C.html,2,"['Load', 'perform']","['Loading', 'performance']"
Performance,". ROOT: tutorials/tree/cernbuild.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. cernbuild.C File ReferenceTutorials » Tree tutorials. Detailed Description; Read data (CERN staff) from an ascii file and create a root file with a Tree. ; ; TFile *cernbuild(Int_t getFile=0, Int_t print=1) {; ; Int_t Category;; UInt_t Flag;; Int_t Age;; Int_t Service;; Int_t Children;; Int_t Grade;; Int_t Step;; Int_t Hrweek;; Int_t Cost;; Char_t Division[4];; Char_t Nation[3];; ; //The input file cern.dat is a copy of the CERN staff data base; //from 1988; TString filename = ""cernstaff.root"";; TString dir = gROOT->GetTutorialDir();; dir.Append(""/tree/"");; dir.ReplaceAll(""/./"",""/"");; FILE *fp = fopen(Form(""%scernstaff.dat"",dir.Data()),""r"");; ; TFile *hfile = 0;; if (getFile) {; // if the argument getFile =1 return the file ""cernstaff.root""; // if the file does not exist, it is created; if (!gSystem->AccessPathName(dir+""cernstaff.root"",kFileExists)) {; hfile = TFile::Open(dir+""cernstaff.root""); //in $ROOTSYS/tutorials/tree; if (hfile) return hfile;; }; //otherwise try $PWD/cernstaff.root; if (!gSystem->AccessPathName(""cernstaff.root"",kFileExists)) {; hfile = TFile::Open(""cernstaff.root""); //in current dir; if (hfile) return hfile;; }; }; //no cernstaff.root file found. Must generate it !; //generate cernstaff.root in $ROOTSYS/tutorials/tree if we have write access; if (gSystem->AccessPathName(""."",kWritePermission)) {; printf(""you must run the script in a directory with write access\n"");; return 0;; }; hfile = TFile::Open(filename,""RECREATE"");; TTree *tree = new TTree(""T"",""CERN 1988 staff data"");; tree->Branch(""Category"",&Category,""Category/I"");; tree->Branch(""Flag"",&Flag,""Flag/i"");; tree->Branch(""Age"",&Age,""Age/I"");; tree->Branch(""Service"",&Service,""Service/I"");; tree->Branch(""Children"",&Children,""Children/I"");; tree->Branch(""Grade"",&Grade,""Grade/I"");; tree->Branch(""Step"",&Step,""Step/I"");; tree->Branch(""Hrweek"",&Hrweek,""Hrweek/I"");; tree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/cernbuild_8C.html:94,Load,Loading,94,doc/master/cernbuild_8C.html,https://root.cern,https://root.cern/doc/master/cernbuild_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/cernstaff.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. cernstaff.C File ReferenceTutorials » Tree tutorials. Detailed Description; Playing with a Tree containing variables of type character . ; void cernstaff () {; TString dir = gROOT->GetTutorialDir();; dir.Append(""/tree/cernstaff.C"");; if (gSystem->AccessPathName(""cernstaff.root"")) {; gROOT->SetMacroPath(dir);; gROOT->ProcessLine("".x cernbuild.C"");; }; TFile *f = new TFile(""cernstaff.root"");; TTree *T = (TTree*)f->Get(""T"");; TCanvas *c1 = new TCanvas(""c1"",""CERN staff"",10,10,1000,750);; c1->Divide(2,2);; // make table of number of people per Nation & Division; c1->cd(1); gPad->SetGrid();; T->Draw(""Nation:Division>>hN"","""",""text"");; TH2F *hN = (TH2F*)gDirectory->Get(""hN"");; hN->SetMarkerSize(1.6);; hN->SetStats(0);; ; //make profile of Average cost per Nation; c1->cd(2); gPad->SetGrid();; gPad->SetLeftMargin(0.12);; T->Draw(""Cost:Nation>>hNation"","""",""prof,goff"");; TH1F *hNation = (TH1F*)gDirectory->Get(""hNation"");; hNation->SetTitle(""Average Cost per Nation"");; hNation->LabelsOption("">""); //sort by decreasing bin contents; hNation->SetMaximum(13000);; hNation->SetMinimum(7000);; hNation->SetStats(0);; hNation->SetMarkerStyle(21);; hNation->Draw();; ; //make stacked plot of Nations versus Grade; c1->cd(3); gPad->SetGrid();; THStack *hGrades = new THStack(""hGrades"",""Nations versus Grade"");; TH1F *hFR = new TH1F(""hFR"",""FR"",12,3,15);; hFR->SetFillColor(kCyan);; hGrades->Add(hFR);; T->Draw(""Grade>>hFR"",""Nation==\""FR\"""");; TH1F *hCH = new TH1F(""hCH"",""CH"",12,3,15);; hCH->SetFillColor(kRed);; hGrades->Add(hCH);; T->Draw(""Grade>>hCH"",""Nation==\""CH\"""");; TH1F *hIT = new TH1F(""hIT"",""IT"",12,3,15);; hIT->SetFillColor(kGreen);; hGrades->Add(hIT);; T->Draw(""Grade>>hIT"",""Nation==\""IT\"""");; TH1F *hDE = new TH1F(""hDE"",""DE"",12,3,15);; hDE->SetFillColor(kYellow);; hGrades->Add(hDE);; T->Draw(""Grade>>hDE"",""Nation==\""DE\"""");; TH1F *hGB = new TH1F(""hGB"",""GB"",12,3,1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/cernstaff_8C.html:94,Load,Loading,94,doc/master/cernstaff_8C.html,https://root.cern,https://root.cern/doc/master/cernstaff_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/cernstaff.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. cernstaff.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_tree; 3/// \notebook; 4/// Playing with a Tree containing variables of type character; 5///; 6/// \macro_image; 7/// \macro_code; 8///; 9/// \author Rene Brun; 10 ; 11void cernstaff () {; 12 TString dir = gROOT->GetTutorialDir();; 13 dir.Append(""/tree/cernstaff.C"");; 14 if (gSystem->AccessPathName(""cernstaff.root"")) {; 15 gROOT->SetMacroPath(dir);; 16 gROOT->ProcessLine("".x cernbuild.C"");; 17 }; 18 TFile *f = new TFile(""cernstaff.root"");; 19 TTree *T = (TTree*)f->Get(""T"");; 20 TCanvas *c1 = new TCanvas(""c1"",""CERN staff"",10,10,1000,750);; 21 c1->Divide(2,2);; 22 // make table of number of people per Nation & Division; 23 c1->cd(1); gPad->SetGrid();; 24 T->Draw(""Nation:Division>>hN"","""",""text"");; 25 TH2F *hN = (TH2F*)gDirectory->Get(""hN"");; 26 hN->SetMarkerSize(1.6);; 27 hN->SetStats(0);; 28 ; 29 //make profile of Average cost per Nation; 30 c1->cd(2); gPad->SetGrid();; 31 gPad->SetLeftMargin(0.12);; 32 T->Draw(""Cost:Nation>>hNation"","""",""prof,goff"");; 33 TH1F *hNation = (TH1F*)gDirectory->Get(""hNation"");; 34 hNation->SetTitle(""Average Cost per Nation"");; 35 hNation->LabelsOption("">""); //sort by decreasing bin contents; 36 hNation->SetMaximum(13000);; 37 hNation->SetMinimum(7000);; 38 hNation->SetStats(0);; 39 hNation->SetMarkerStyle(21);; 40 hNation->Draw();; 41 ; 42 //make stacked plot of Nations versus Grade; 43 c1->cd(3); gPad->SetGrid();; 44 THStack *hGrades = new THStack(""hGrades"",""Nations versus Grade"");; 45 TH1F *hFR = new TH1F(""hFR"",""FR"",12,3,15);; 46 hFR->SetFillColor(kCyan);; 47 hGrades->Add(hFR);; 48 T->Draw(""Grade>>hFR"",""Nation==\""FR\"""");; 49 TH1F *hCH = new TH1F(""hCH"",""CH"",12,3,15);; 50 hCH->SetFillColor(kRed);; 51 hGrades->Add(hCH);; 52 T->Draw(""Grade>>hCH"",""Nation==\""CH\"""");; 53 TH1F *hIT = new TH1F(""hIT"",""IT"",12,3,15);; 54 hIT->SetFillColor(kG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/cernstaff_8C_source.html:91,Load,Loading,91,doc/master/cernstaff_8C_source.html,https://root.cern,https://root.cern/doc/master/cernstaff_8C_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/circular.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. circular.C File ReferenceTutorials » Tree tutorials. Detailed Description; Example of a circular Tree ; Circular Trees are interesting in online real time environments to store the results of the last maxEntries events. for more info, see TTree::SetCircular. Circular trees must be memory resident.; ; void circular() {; auto T = new TTree(""T"",""test circular buffers"");; TRandom r;; Float_t px,py,pz;; Double_t randomNum;; UShort_t i;; T->Branch(""px"",&px,""px/F"");; T->Branch(""py"",&py,""px/F"");; T->Branch(""pz"",&pz,""px/F"");; T->Branch(""random"",&randomNum,""random/D"");; T->Branch(""i"",&i,""i/s"");; T->SetCircular(20000); //keep a maximum of 20000 entries in memory; for (i = 0; i < 65000; i++) {; r.Rannor(px,py);; pz = px*px + py*py;; randomNum = r.Rndm();; T->Fill();; }; T->Print();; }; ; UShort_tunsigned short UShort_tDefinition RtypesCore.h:40; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; AuthorRene Brun ; Definition in file circular.C. tutorialstreecircular.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/circular_8C.html:93,Load,Loading,93,doc/master/circular_8C.html,https://root.cern,https://root.cern/doc/master/circular_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/clonesA_Event.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. clonesA_Event.C File ReferenceTutorials » Tree tutorials. Detailed Description; Example to write & read a Tree built with a complex class inheritance tree. ; It demonstrates usage of inheritance and TClonesArrays This is simplified / stripped extract of an event structure which was used within the Marabou project.; To run this example, do: root > .x clonesA_Event.C; ; #ifndef CLONESA_EVENT_SECOND_RUN; ; void clonesA_Event() {; std::string s1(__FILE__);; TString dir = gSystem->UnixPathName(s1.substr(0, s1.find_last_of(""\\/"")).c_str());; gROOT->ProcessLine(TString("".L "")+dir+""/clonesA_Event.cxx+"");; #define CLONESA_EVENT_SECOND_RUN yes; gROOT->ProcessLine(""#include \"""" __FILE__ ""\"""");; gROOT->ProcessLine(""clonesA_Event(true)"");; }; ; #else; ; void clonesA_Event_w(); {; // protect against old ROOT versions; if ( gROOT->GetVersionInt() < 30503 ) {; cout << ""Works only with ROOT version >= 3.05/03"" << endl;; return;; }; if ( gROOT->GetVersionDate() < 20030406 ) {; cout << ""Works only with ROOT CVS version after 5. 4. 2003"" << endl;; return;; }; ; //write a Tree; TFile *hfile = new TFile(""clonesA_Event.root"",""RECREATE"",""Test TClonesArray"");; TTree *tree = new TTree(""clonesA_Event"",""An example of a ROOT tree"");; TUsrSevtData1 *event1 = new TUsrSevtData1();; TUsrSevtData2 *event2 = new TUsrSevtData2();; tree->Branch(""top1"",""TUsrSevtData1"",&event1,8000,99);; tree->Branch(""top2"",""TUsrSevtData2"",&event2,8000,99);; for (Int_t ev = 0; ev < 10; ev++) {; cout << ""event "" << ev << endl;; event1->SetEvent(ev);; event2->SetEvent(ev);; tree->Fill();; if (ev <3) tree->Show(ev);; }; tree->Write();; tree->Print();; delete hfile;; }; ; void clonesA_Event_r(); {; //read the Tree; TFile * hfile = new TFile(""clonesA_Event.root"");; TTree *tree = (TTree*)hfile->Get(""clonesA_Event"");; ; TUsrSevtData1 * event1 = 0;; TUsrSevtData2 * event2 = 0;; tree->SetBranchAdd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/clonesA__Event_8C.html:98,Load,Loading,98,doc/master/clonesA__Event_8C.html,https://root.cern,https://root.cern/doc/master/clonesA__Event_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/copytree.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. copytree.C File ReferenceTutorials » Tree tutorials. Detailed Description; Copy a subset of a Tree to a new Tree ; The input file has been generated by the program in $ROOTSYS/test/Event with Event 1000 1 1 1.; ; // Load the library at macro parsing time: we need this to use its content in the code; R__LOAD_LIBRARY($ROOTSYS/test/libEvent.so); ; void copytree(); {; ; TString dir = ""$ROOTSYS/test/Event.root"";; gSystem->ExpandPathName(dir);; const auto filename = gSystem->AccessPathName(dir) ? ""./Event.root"" : ""$ROOTSYS/test/Event.root"";; ; TFile oldfile(filename);; TTree *oldtree;; oldfile.GetObject(""T"", oldtree);; ; // Deactivate all branches; oldtree->SetBranchStatus(""*"", 0);; ; // Activate only four of them; for (auto activeBranchName : {""event"", ""fNtrack"", ""fNseg"", ""fH""}); oldtree->SetBranchStatus(activeBranchName, 1);; ; // Create a new file + a clone of old tree in new file; TFile newfile(""small.root"", ""recreate"");; auto newtree = oldtree->CloneTree();; ; newtree->Print();; newfile.Write();; }; R__LOAD_LIBRARY#define R__LOAD_LIBRARY(LIBRARY)Definition Rtypes.h:496; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TFileA ROOT file is an on-disk file, usually with extension ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/copytree_8C.html:93,Load,Loading,93,doc/master/copytree_8C.html,https://root.cern,https://root.cern/doc/master/copytree_8C.html,2,['Load'],"['Load', 'Loading']"
Performance,". ROOT: tutorials/tree/copytree2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. copytree2.C File ReferenceTutorials » Tree tutorials. Detailed Description; Copy a subset of a Tree to a new Tree, one branch in a separate file. ; One branch of the new Tree is written to a separate file The input file has been generated by the program in $ROOTSYS/test/Event with the command Event 1000 1 1 1; ; // Load the library at macro parsing time: we need this to use its content in the code; R__LOAD_LIBRARY($ROOTSYS/test/libEvent.so); ; void copytree2(); {; ; TString dir = ""$ROOTSYS/test/Event.root"";; gSystem->ExpandPathName(dir);; const auto filename = gSystem->AccessPathName(dir) ? ""./Event.root"" : ""$ROOTSYS/test/Event.root"";; ; TFile oldfile(filename);; TTree *oldtree;; oldfile.GetObject(""T"", oldtree);; ; // Activate only four of them; for (auto activeBranchName : {""event"", ""fNtrack"", ""fNseg"", ""fH""}) {; oldtree->SetBranchStatus(activeBranchName, 1);; }; ; // Create a new file + a clone of old tree header. Do not copy events; TFile newfile(""small.root"", ""recreate"");; auto newtree = oldtree->CloneTree(0);; ; // Divert branch fH to a separate file and copy all events; newtree->GetBranch(""fH"")->SetFile(""small_fH.root"");; newtree->CopyEntries(oldtree);; ; newtree->Print();; newfile.Write();; }; R__LOAD_LIBRARY#define R__LOAD_LIBRARY(LIBRARY)Definition Rtypes.h:496; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/copytree2_8C.html:94,Load,Loading,94,doc/master/copytree2_8C.html,https://root.cern,https://root.cern/doc/master/copytree2_8C.html,2,['Load'],"['Load', 'Loading']"
Performance,". ROOT: tutorials/tree/copytree3.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. copytree3.C File ReferenceTutorials » Tree tutorials. Detailed Description; Example of Root macro to copy a subset of a Tree to a new Tree, selecting entries. ; Only selected entries are copied to the new Tree. The input file has been generated by the program in $ROOTSYS/test/Event with Event 1000 1 99 1; ; R__LOAD_LIBRARY($ROOTSYS/test/libEvent.so); ; void copytree3(); {; // Get old file, old tree and set top branch address; TString dir = ""$ROOTSYS/test/Event.root"";; gSystem->ExpandPathName(dir);; const auto filename = gSystem->AccessPathName(dir) ? ""./Event.root"" : ""$ROOTSYS/test/Event.root"";; ; TFile oldfile(filename);; TTree *oldtree;; oldfile.GetObject(""T"", oldtree);; ; const auto nentries = oldtree->GetEntries();; ; Event *event = nullptr;; oldtree->SetBranchAddress(""event"", &event);; ; // Create a new file + a clone of old tree in new file; TFile newfile(""small.root"", ""recreate"");; auto newtree = oldtree->CloneTree(0);; ; for (auto i : ROOT::TSeqI(nentries)) {; oldtree->GetEntry(i);; if (event->GetNtrack() > 605); newtree->Fill();; event->Clear();; }; ; newtree->Print();; newfile.Write();; }; R__LOAD_LIBRARY#define R__LOAD_LIBRARY(LIBRARY)Definition Rtypes.h:496; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; nentriesint nent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/copytree3_8C.html:94,Load,Loading,94,doc/master/copytree3_8C.html,https://root.cern,https://root.cern/doc/master/copytree3_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/drawsparse.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. drawsparse.C File ReferenceTutorials » Tree tutorials. Detailed Description; Convert a THnSparse to a TTree using efficient iteration through the THnSparse and draw a THnSparse using TParallelCoord. ; The plot will contain one line for each filled bin, with the bin's coordinates on each axis, and the bin's content on the rightmost axis.; Run as .L $ROOTSYS/tutorials/tree/drawsparse.C+. ; ; ; #include ""TParallelCoord.h""; #include ""TParallelCoordVar.h""; #include ""TROOT.h""; #include ""TTree.h""; #include ""TLeaf.h""; #include ""THnSparse.h""; #include ""TAxis.h""; #include ""TCanvas.h""; #include ""TRandom.h""; #include ""TFile.h""; #include ""TH3.h""; ; TTree* toTree(THnSparse* h); {; // Creates a TTree and fills it with the coordinates of all; // filled bins. The tree will have one branch for each dimension,; // and one for the bin content.; ; Int_t dim = h->GetNdimensions();; TString name(h->GetName()); name += ""_tree"";; TString title(h->GetTitle()); title += "" tree"";; ; TTree* tree = new TTree(name, title);; Double_t* x = new Double_t[dim + 1];; memset(x, 0, sizeof(Double_t) * (dim + 1));; ; TString branchname;; for (Int_t d = 0; d < dim; ++d) {; if (branchname.Length()); branchname += "":"";; TAxis* axis = h->GetAxis(d);; branchname += axis->GetName();; branchname += ""/D"";; }; tree->Branch(""coord"", x, branchname);; tree->Branch(""bincontent"", &x[dim], ""bincontent/D"");; ; Int_t *bins = new Int_t[dim];; for (Long64_t i = 0; i < h->GetNbins(); ++i) {; x[dim] = h->GetBinContent(i, bins);; for (Int_t d = 0; d < dim; ++d) {; x[d] = h->GetAxis(d)->GetBinCenter(bins[d]);; }; ; tree->Fill();; }; ; delete [] bins;; //delete [] x;; return tree;; }; ; ; void drawsparse_draw(THnSparse* h); {; // Draw a THnSparse using TParallelCoord, creating a temporary TTree.; ; TTree* tree = toTree(h);; ; TString whatToDraw;; TIter iLeaf(tree->GetListOfLeaves());; const TLeaf* le",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/drawsparse_8C.html:95,Load,Loading,95,doc/master/drawsparse_8C.html,https://root.cern,https://root.cern/doc/master/drawsparse_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/h1analysis.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. h1analysis.C File ReferenceTutorials » Tree tutorials. Detailed Description; Example of analysis class for the H1 data. ; This file uses 4 large data sets from the H1 collaboration at DESY Hamburg. One can access these data sets (277 MBytes) from the standard Root web site at: https://root.cern/files/h1/ The Physics plots below generated by this example cannot be produced when using smaller data sets.; There are several ways to analyze data stored in a Root Tree; Using TTree::Draw: This is very convenient and efficient for small tasks. A TTree::Draw call produces one histogram at the time. The histogram is automatically generated. The selection expression may be specified in the command line.; Using the TTreeViewer: This is a graphical interface to TTree::Draw with the same functionality.; Using the code generated by TTree::MakeClass: In this case, the user creates an instance of the analysis class. They have the control over the event loop and he can generate an unlimited number of histograms.; Using the code generated by TTree::MakeSelector. Like for the code generated by TTree::MakeClass, the user can do complex analysis. However, they cannot control the event loop. The event loop is controlled by TTree::Process called by the user. This solution is illustrated by the current code. The advantage of this method is that it can be run in a parallel environment using PROOF (the Parallel Root Facility). A chain of 4 files (originally converted from PAW ntuples) is used to illustrate the various ways to loop on Root data sets. Each data set contains a Root Tree named ""h42"" The class definition in h1analysis.h has been generated automatically by the Root utility TTree::MakeSelector using one of the files with the following statement:; h42->MakeSelector(""h1analysis"");; This produces two files: h1analysis.h and h1analysis.C (skeleton of this f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysis_8C.html:95,Load,Loading,95,doc/master/h1analysis_8C.html,https://root.cern,https://root.cern/doc/master/h1analysis_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/h1analysisProxy.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. h1analysisProxy.C File ReferenceTutorials » Tree tutorials. Detailed Description; Example of analysis class for the H1 data using code generated by MakeProxy. ; This file uses 4 large data sets from the H1 collaboration at DESY Hamburg. One can access these data sets (277 MBytes) from the standard Root web site at: https://root.cern/files/h1/ The Physics plots below generated by this example cannot be produced when using smaller data sets.; There are several ways to analyze data stored in a Root Tree; Using TTree::Draw: This is very convenient and efficient for small tasks. A TTree::Draw call produces one histogram at the time. The histogram is automatically generated. The selection expression may be specified in the command line.; Using the TTreeViewer: This is a graphical interface to TTree::Draw with the same functionality.; Using the code generated by TTree::MakeClass: In this case, the user creates an instance of the analysis class. They have the control over the event loop and he can generate an unlimited number of histograms.; Using the code generated by TTree::MakeSelector. Like for the code generated by TTree::MakeClass, the user can do complex analysis. However, they cannot control the event loop. The event loop is controlled by TTree::Process called by the user. This solution is illustrated by the current code. The advantage of this method is that it can be run in a parallel environment using PROOF (the Parallel Root Facility). A chain of 4 files (originally converted from PAW ntuples) is used to illustrate the various ways to loop on Root data sets. Each data set contains a Root Tree named ""h42""; h1analysProxy.C can be used either via TTree::Draw: h42->Draw(""h1analysisProxy.C"");; or it can be used directly with TTree::MakeProxy, for example to generate a shared library. TTree::MakeProxy will generate a TSelector skeleto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysisProxy_8C.html:100,Load,Loading,100,doc/master/h1analysisProxy_8C.html,https://root.cern,https://root.cern/doc/master/h1analysisProxy_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/h1analysisProxy.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions |; Variables ; h1analysisProxy.h File Reference. #include ""TH2.h""; #include ""TF1.h""; #include ""TStyle.h""; #include ""TCanvas.h""; #include ""TLine.h""; #include ""TEntryList.h""; #include ""TPaveStats.h""; #include ""TMath.h"". Include dependency graph for h1analysisProxy.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Functions; Double_t fdm2 (Double_t *xx, Double_t *par);  ; Double_t fdm5 (Double_t *xx, Double_t *par);  . Variables; const Double_t dxbin = (0.17-0.13)/40;  ; const Double_t sigma = 0.0012;  . Function Documentation. ◆ fdm2(). Double_t fdm2 ; (; Double_t * ; xx, . Double_t * ; par . ). Definition at line 25 of file h1analysisProxy.h. ◆ fdm5(). Double_t fdm5 ; (; Double_t * ; xx, . Double_t * ; par . ). Definition at line 14 of file h1analysisProxy.h. Variable Documentation. ◆ dxbin. const Double_t dxbin = (0.17-0.13)/40. Definition at line 10 of file h1analysisProxy.h. ◆ sigma. const Double_t sigma = 0.0012. Definition at line 11 of file h1analysisProxy.h. tutorialstreeh1analysisProxy.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysisProxy_8h.html:100,Load,Loading,100,doc/master/h1analysisProxy_8h.html,https://root.cern,https://root.cern/doc/master/h1analysisProxy_8h.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/h1analysisProxy.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. h1analysisProxy.h. Go to the documentation of this file. 1#include ""TH2.h""; 2#include ""TF1.h""; 3#include ""TStyle.h""; 4#include ""TCanvas.h""; 5#include ""TLine.h""; 6#include ""TEntryList.h""; 7#include ""TPaveStats.h""; 8#include ""TMath.h""; 9 ; 10const Double_t dxbin = (0.17-0.13)/40; // Bin-width; 11const Double_t sigma = 0.0012;; 12 ; 13//_____________________________________________________________________; 14Double_t fdm5(Double_t *xx, Double_t *par); 15{; 16 Double_t x = xx[0];; 17 if (x <= 0.13957) return 0;; 18 Double_t xp3 = (x-par[3])*(x-par[3]);; 19 Double_t res = dxbin*(par[0]*TMath::Power(x-0.13957, par[1]); 20 + par[2] / 2.5066/par[4]*TMath::Exp(-xp3/2/par[4]/par[4]));; 21 return res;; 22}; 23 ; 24//_____________________________________________________________________; 25Double_t fdm2(Double_t *xx, Double_t *par); 26{; 27 Double_t x = xx[0];; 28 if (x <= 0.13957) return 0;; 29 Double_t xp3 = (x-0.1454)*(x-0.1454);; 30 Double_t res = dxbin*(par[0]*TMath::Power(x-0.13957, 0.25); 31 + par[1] / 2.5066/sigma*TMath::Exp(-xp3/2/sigma/sigma));; 32 return res;; 33}; 34 ; Double_tdouble Double_tDefinition RtypesCore.h:59; TCanvas.h; TEntryList.h; TF1.h; TH2.h; TLine.h; TMath.h; TPaveStats.h; TStyle.h; fdm5Double_t fdm5(Double_t *xx, Double_t *par)Definition h1analysisProxy.h:14; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; dxbinconst Double_t dxbinDefinition h1analysisProxy.h:10; fdm2Double_t fdm2(Double_t *xx, Double_t *par)Definition h1analysisProxy.h:25; xDouble_t x[n]Definition legend1.C:17; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721. tutorialstreeh1analysisProxy.h. ROOT master - Reference Guide Generated on Tue No",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysisProxy_8h_source.html:97,Load,Loading,97,doc/master/h1analysisProxy_8h_source.html,https://root.cern,https://root.cern/doc/master/h1analysisProxy_8h_source.html,1,['Load'],['Loading']
Performance,. ROOT: tutorials/tree/h1analysisProxyCut.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions ; h1analysisProxyCut.C File Reference. Functions; Bool_t h1analysisProxyCut ();  . Function Documentation. ◆ h1analysisProxyCut(). Bool_t h1analysisProxyCut ; (; ). Definition at line 1 of file h1analysisProxyCut.C. tutorialstreeh1analysisProxyCut.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysisProxyCut_8C.html:103,Load,Loading,103,doc/master/h1analysisProxyCut_8C.html,https://root.cern,https://root.cern/doc/master/h1analysisProxyCut_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/h1analysisTreeReader.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. h1analysisTreeReader.C File ReferenceTutorials » Tree tutorials. Detailed Description; H1 analysis example expressed in terms of TTreeReader (see h1analysis.C). ; ; #include ""h1analysisTreeReader.h""; #include ""TStyle.h""; #include ""TCanvas.h""; #include ""TPaveStats.h""; #include ""TLine.h""; #include ""TMath.h""; #include ""TFile.h""; #include ""TROOT.h""; ; ; const Double_t dxbin = (0.17-0.13)/40; // Bin-width; const Double_t sigma = 0.0012;; ; //_____________________________________________________________________; Double_t fdm5(Double_t *xx, Double_t *par); {; Double_t x = xx[0];; if (x <= 0.13957) return 0;; Double_t xp3 = (x-par[3])*(x-par[3]);; Double_t res = dxbin*(par[0]*TMath::Power(x-0.13957, par[1]); + par[2] / 2.5066/par[4]*TMath::Exp(-xp3/2/par[4]/par[4]));; return res;; }; ; //_____________________________________________________________________; Double_t fdm2(Double_t *xx, Double_t *par); {; Double_t x = xx[0];; if (x <= 0.13957) return 0;; Double_t xp3 = (x-0.1454)*(x-0.1454);; Double_t res = dxbin*(par[0]*TMath::Power(x-0.13957, 0.25); + par[1] / 2.5066/sigma*TMath::Exp(-xp3/2/sigma/sigma));; return res;; }; //_____________________________________________________________________; Bool_t h1analysisTreeReader::Process(Long64_t entry){; // entry is the entry number in the current Tree; // Selection function to select D* and D0.; myTreeReader.SetLocalEntry(entry);; fProcessed++;; //in case one entry list is given in input, the selection has already been done.; if (!useList) {; // Return as soon as a bad entry is detected; if (TMath::Abs(*fMd0_d-1.8646) >= 0.04) return kFALSE;; if (*fPtds_d <= 2.5) return kFALSE;; if (TMath::Abs(*fEtads_d) >= 1.5) return kFALSE;; (*fIk)--; //original fIk used f77 convention starting at 1; (*fIpi)--;; ; ; if (fNhitrp.At(*fIk)* fNhitrp.At(*fIpi) <= 1) return kFALSE;; ; ; if (fRend.At(*fIk) -fRs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysisTreeReader_8C.html:105,Load,Loading,105,doc/master/h1analysisTreeReader_8C.html,https://root.cern,https://root.cern/doc/master/h1analysisTreeReader_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/h1chain.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. h1chain.C File ReferenceTutorials » Tree tutorials. Detailed Description; Creates a TChain to be used by the h1analysis.C class the symbol H1 must point to a directory where the H1 data sets have been installed. ; ; TChain chain(""h42"");; ; void h1chain(const char *h1dir = 0); {; if (h1dir) {; gSystem->Setenv(""H1"",h1dir);; }; chain.SetCacheSize(20*1024*1024);; chain.Add(""$H1/dstarmb.root"");; chain.Add(""$H1/dstarp1a.root"");; chain.Add(""$H1/dstarp1b.root"");; chain.Add(""$H1/dstarp2.root"");; }; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TChainA chain is a collection of files containing TTree objects.Definition TChain.h:33; TSystem::Setenvvirtual void Setenv(const char *name, const char *value)Set environment variable.Definition TSystem.cxx:1649; AuthorRene Brun ; Definition in file h1chain.C. tutorialstreeh1chain.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1chain_8C.html:92,Load,Loading,92,doc/master/h1chain_8C.html,https://root.cern,https://root.cern/doc/master/h1chain_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/hsimpleProxy.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. hsimpleProxy.C File ReferenceTutorials » Tree tutorials. Detailed Description; Used by hsimpleProxyDriver.C. ; To use this file, generate hsimple.root: root.exe -b -l -q hsimple.C; b#define b(i)Definition RSha256.hxx:100; qfloat * qDefinition THbookFile.cxx:89; hsimpleDefinition hsimple.py:1; lTLine lDefinition textangle.C:4; and do TFile *file = TFile::Open(""hsimple.root"");; TTree *ntuple ; file->GetObject(""ntuple"",ntuple);; ntuple->Draw(""hsimpleProxy.C+"");; TDirectory::GetObjectvoid GetObject(const char *namecycle, T *&ptr)Get an object with proper type checking.Definition TDirectory.h:212; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::Drawvoid Draw(Option_t *opt) overrideDefault Draw method for all objects.Definition TTree.h:431; ; double hsimpleProxy() {; return px;; }; AuthorRene Brun ; Definition in file hsimpleProxy.C. tutorialstreehsimpleProxy.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsimpleProxy_8C.html:97,Load,Loading,97,doc/master/hsimpleProxy_8C.html,https://root.cern,https://root.cern/doc/master/hsimpleProxy_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/hsimpleProxyDriver.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. hsimpleProxyDriver.C File ReferenceTutorials » Tree tutorials. Detailed Description; This is the driver of the hsimpleProxy example. ; It provides the infrastructure to run that code on an ntuple To be run from the tutorials directory; ; void hsimpleProxyDriver(); {; std::cout << gSystem->WorkingDirectory() << std::endl;; TFile *file = TFile::Open(""hsimple.root"");; if (!file){; std::cerr << ""Input file not found.\n"";; return ;; }; TTree *ntuple = nullptr;; file->GetObject(""ntuple"",ntuple);; std::string s1(__FILE__);; TString dir = gSystem->UnixPathName(s1.substr(0, s1.find_last_of(""\\/"")).c_str());; ntuple->Draw(dir+""/hsimpleProxy.C+"");; }; s1#define s1(x)Definition RSha256.hxx:91; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TDirectory::GetObjectvoid GetObject(const char *namecycle, T *&ptr)Get an object with proper type checking.Definition TDirectory.h:212; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TStringBasic string class.Definition TString.h:139; TSystem::UnixPathNamevirtual const char * UnixPathName(const char *unixpathname)Convert from a local pathname to a Unix pathname.Definition TSystem.cxx:1063; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::Drawvoid Draw(Option_t *opt) overrideDefault Draw method for all objects.Definition TTree.h:431; AuthorRene Brun ; Definition in file hsimpleProxyDriver.C. tutorialstreehsimpleProxyDriver.C. ROOT master - Refere",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsimpleProxyDriver_8C.html:103,Load,Loading,103,doc/master/hsimpleProxyDriver_8C.html,https://root.cern,https://root.cern/doc/master/hsimpleProxyDriver_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/hsimpleReader.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. hsimpleReader.C File ReferenceTutorials » Tree tutorials. Detailed Description; TTreeReader simplest example. ; Read data from hsimple.root (written by hsimple.C); ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h""; ; void hsimpleReader() {; // Create a histogram for the values we read.; auto myHist = new TH1F(""h1"",""ntuple"",100,-4,4);; ; // Open the file containing the tree.; auto myFile = TFile::Open(""hsimple.root"");; if (!myFile || myFile->IsZombie()) {; return;; }; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);; ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");; ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }; ; myHist->Draw();; }; TFile.h; TH1F.h; TTreeReaderValue.h; TTreeReader.h; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TTreeReaderValueAn interface for reading values stored in ROOT columnar datasets.Definition TTreeReaderValue.h:174; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; AuthorAnders Eie, 2013 ; Definition in file hsimpleReader.C. tutorialstreehsimpleReader.C. ROOT master - Refe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsimpleReader_8C.html:98,Load,Loading,98,doc/master/hsimpleReader_8C.html,https://root.cern,https://root.cern/doc/master/hsimpleReader_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/htest.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. htest.C File ReferenceTutorials » Tree tutorials. Detailed Description; Save histograms in Tree branches ; To run this example, do root > .L htest.C; root > htw(); root > htr1(); root > htr2(); root > htr3(). ; void htw() {; // Create a Tree with a few branches of type histogram; // 25000 entries are filled in the Tree; // For each entry, the copy of 3 histograms is written; // The data base will contain 75000 histograms.; gBenchmark->Start(""hsimple"");; TFile f(""ht.root"",""recreate"");; auto T = new TTree(""T"",""test"");; auto hpx = new TH1F(""hpx"",""This is the px distribution"",100,-4,4);; auto hpxpy = new TH2F(""hpxpy"",""py vs px"",40,-4,4,40,-4,4);; auto hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; T->Branch(""hpx"",""TH1F"",&hpx,32000,0);; T->Branch(""hpxpy"",""TH2F"",&hpxpy,32000,0);; T->Branch(""hprof"",""TProfile"",&hprof,32000,0);; Float_t px, py, pz;; for (Int_t i = 0; i < 25000; i++) {; if (i%1000 == 0) printf(""at entry: %d\n"",i);; gRandom->Rannor(px,py);; pz = px*px + py*py;; hpx->Fill(px);; hpxpy->Fill(px,py);; hprof->Fill(px,pz);; T->Fill();; }; T->Print();; f.Write();; gBenchmark->Show(""hsimple"");; }; ; void htr1() {; // Connect Tree generated by htw and show histograms for entry 12345; auto f = new TFile(""ht.root"");; auto T = (TTree*)f->Get(""T"");; TH1F *hpx = nullptr;; TH2F *hpxpy = nullptr;; TProfile *hprof = nullptr;; T->SetBranchAddress(""hpx"",&hpx);; T->SetBranchAddress(""hpxpy"",&hpxpy);; T->SetBranchAddress(""hprof"",&hprof);; T->GetEntry(12345);; auto c1 = new TCanvas(""c1"",""test"",10,10,600,1000);; c1->Divide(1,3);; c1->cd(1);; hpx->Draw();; c1->cd(2);; hpxpy->Draw();; c1->cd(3);; hprof->Draw();; c1->Print(""htr1.png"");; }; ; void htr2() {; // Connect Tree generated by htw and show histograms for entry 12345; // a variant of htr1; auto f = new TFile(""ht.root"");; auto T = (TTree*)f->Get(""T"");; auto c1 = new TCanvas(""c1"",""t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/htest_8C.html:90,Load,Loading,90,doc/master/htest_8C.html,https://root.cern,https://root.cern/doc/master/htest_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/hvector.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. hvector.C File ReferenceTutorials » Tree tutorials. Detailed Description; Write and read STL vectors in a tree. . ; #include <vector>; ; #include ""TFile.h""; #include ""TTree.h""; #include ""TCanvas.h""; #include ""TFrame.h""; #include ""TH1F.h""; #include ""TBenchmark.h""; #include ""TRandom.h""; #include ""TSystem.h""; ; void write(); {; ; TFile *f = TFile::Open(""hvector.root"",""RECREATE"");; ; if (!f) { return; }; ; // Create one histograms; TH1F *hpx = new TH1F(""hpx"",""This is the px distribution"",100,-4,4);; hpx->SetFillColor(48);; ; std::vector<float> vpx;; std::vector<float> vpy;; std::vector<float> vpz;; std::vector<float> vrand;; ; // Create a TTree; TTree *t = new TTree(""tvec"",""Tree with vectors"");; t->Branch(""vpx"",&vpx);; t->Branch(""vpy"",&vpy);; t->Branch(""vpz"",&vpz);; t->Branch(""vrand"",&vrand);; ; // Create a new canvas.; TCanvas *c1 = new TCanvas(""c1"",""Dynamic Filling Example"",200,10,700,500);; ; gRandom->SetSeed();; const Int_t kUPDATE = 1000;; for (Int_t i = 0; i < 25000; i++) {; Int_t npx = (Int_t)(gRandom->Rndm(1)*15);; ; vpx.clear();; vpy.clear();; vpz.clear();; vrand.clear();; ; for (Int_t j = 0; j < npx; ++j) {; ; Float_t px,py,pz;; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ; hpx->Fill(px);; ; vpx.emplace_back(px);; vpy.emplace_back(py);; vpz.emplace_back(pz);; vrand.emplace_back(random);; ; }; if (i && (i%kUPDATE) == 0) {; if (i == kUPDATE) hpx->Draw();; c1->Modified();; c1->Update();; if (gSystem->ProcessEvents()); break;; }; t->Fill();; }; f->Write();; ; delete f;; }; ; ; void read(); {; ; TFile *f = TFile::Open(""hvector.root"",""READ"");; ; if (!f) { return; }; ; TTree *t; f->GetObject(""tvec"",t);; ; std::vector<float> *vpx = nullptr;; ; // Create a new canvas.; TCanvas *c1 = new TCanvas(""c1"",""Dynamic Filling Example"",200,10,700,500);; ; const Int_t kUPDATE = 1000;; ; TBranch *bvpx = nullptr;; t->S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hvector_8C.html:92,Load,Loading,92,doc/master/hvector_8C.html,https://root.cern,https://root.cern/doc/master/hvector_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/jets.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. jets.C File ReferenceTutorials » Tree tutorials. Detailed Description; Usage of a Tree using the JetEvent class. ; The JetEvent class has several collections (TClonesArray) and other collections (TRefArray) referencing objects in the TClonesArrays. The JetEvent class is in $ROOTSYS/tutorials/tree/JetEvent.h,cxx to execute the script, do .x jets.C; jetsvoid jets()Definition jets.C:38; ; #ifdef JETS_SECOND_RUN; ; #include ""TFile.h""; #include ""TTree.h""; #include ""TRandom.h""; #include ""TROOT.h""; #include ""TSystem.h""; #include ""JetEvent.h""; #include ""Riostream.h""; ; ; void write(Int_t nev=100) {; //write nev Jet events; TFile f(""JetEvent.root"",""recreate"");; TTree *T = new TTree(""T"",""Event example with Jets"");; JetEvent *event = new JetEvent;; T->Branch(""event"",""JetEvent"",&event,8000,2);; ; for (Int_t ev=0;ev<nev;ev++) {; event->Build();; T->Fill();; }; ; T->Print();; T->Write();; }; ; void read() {; //read the JetEvent file; TFile f(""JetEvent.root"");; TTree *T = (TTree*)f.Get(""T"");; JetEvent *event = 0;; T->SetBranchAddress(""event"", &event);; Long64_t nentries = T->GetEntries();; ; for (Long64_t ev=0;ev<nentries;ev++) {; T->GetEntry(ev);; if (ev) continue; //dump first event only; cout << "" Event: ""<< ev; << "" Jets: "" << event->GetNjet(); << "" Tracks: "" << event->GetNtrack(); << "" Hits A: "" << event->GetNhitA(); << "" Hits B: "" << event->GetNhitB() << endl;; }; }; ; void pileup(Int_t nev=200) {; //make nev pileup events, each build with LOOPMAX events selected; //randomly among the nentries; TFile f(""JetEvent.root"");; TTree *T = (TTree*)f.Get(""T"");; // Long64_t nentries = T->GetEntries();; ; const Int_t LOOPMAX=10;; JetEvent *events[LOOPMAX];; Int_t loop;; for (loop=0;loop<LOOPMAX;loop++) events[loop] = 0;; for (Long64_t ev=0;ev<nev;ev++) {; if (ev%10 == 0) printf(""building pileup: %lld\n"",ev);; for (loop=0;loop<LOOPMAX;loop++) {; Int_t rev = gRand",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree_2jets_8C.html:89,Load,Loading,89,doc/master/tree_2jets_8C.html,https://root.cern,https://root.cern/doc/master/tree_2jets_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/ntuple1.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ntuple1.C File ReferenceTutorials » Tree tutorials. Detailed Description; Simple tree analysis. . ; #include ""TCanvas.h""; #include ""TFile.h""; #include ""TNtuple.h""; #include ""TProfile.h""; #include ""TBenchmark.h""; #include ""TStyle.h""; #include ""TPaveText.h""; #include ""TFrame.h""; #include ""TF1.h""; #include ""TROOT.h""; #include ""TSystem.h""; #include ""TInterpreter.h""; ; void ntuple1() {; ; //just in case this script is executed multiple times; delete gROOT->GetListOfFiles()->FindObject(""hsimple.root"");; delete gROOT->GetListOfCanvases()->FindObject(""c1"");; ; gBenchmark->Start(""ntuple1"");; //; // Connect ROOT histogram/ntuple demonstration file; // generated by example $ROOTSYS/tutorials/hsimple.C.; TString dir = gROOT->GetTutorialDir();; dir.Append(""/hsimple.C"");; dir.ReplaceAll(""/./"",""/"");; if (gBenchmark->GetBench(""hsimple"") < 0) gInterpreter->LoadMacro(dir.Data());; TFile *f1 = (TFile*)gROOT->ProcessLineFast(""hsimple(1)"");; if (!f1) return;; //; // Create a canvas, with 4 pads; //; TCanvas *c1 = new TCanvas(""c1"",""The Ntuple canvas"",200,10,700,780);; TPad *pad1 = new TPad(""pad1"",""This is pad1"",0.02,0.52,0.48,0.98,21);; TPad *pad2 = new TPad(""pad2"",""This is pad2"",0.52,0.52,0.98,0.98,21);; TPad *pad3 = new TPad(""pad3"",""This is pad3"",0.02,0.02,0.48,0.48,21);; TPad *pad4 = new TPad(""pad4"",""This is pad4"",0.52,0.02,0.98,0.48,1);; pad1->Draw();; pad2->Draw();; pad3->Draw();; pad4->Draw();; //; // Change default style for the statistics box; gStyle->SetStatW(0.30);; gStyle->SetStatH(0.20);; //; // Display a function of one ntuple column imposing a condition; // on another column.; pad1->cd();; pad1->SetGrid();; pad1->SetLogy();; TNtuple *ntuple = (TNtuple*)f1->Get(""ntuple"");; ntuple->SetLineColor(1);; ntuple->SetFillStyle(1001);; ntuple->SetFillColor(45);; ntuple->Draw(""3*px+2"",""px**2+py**2>1"");; ntuple->SetFillColor(38);; ntuple->Draw(""2*px+2"",""pz>2""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ntuple1_8C.html:92,Load,Loading,92,doc/master/ntuple1_8C.html,https://root.cern,https://root.cern/doc/master/ntuple1_8C.html,2,['Load'],"['LoadMacro', 'Loading']"
Performance,". ROOT: tutorials/tree/parallelcoord.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. parallelcoord.C File ReferenceTutorials » Tree tutorials. Detailed Description; Script illustrating the use of the TParallelCoord class . ; #include ""TFile.h""; #include ""TCanvas.h""; #include ""TStyle.h""; #include ""TRandom.h""; #include ""TNtuple.h""; #include ""TParallelCoord.h""; #include ""TParallelCoordVar.h""; #include ""TParallelCoordRange.h""; ; Double_t r1,r2,r3,r4,r5,r6,r7,r8,r9;; Double_t dr = 3.5;; TRandom *r;; ; void generate_random(Int_t i) {; r1 = (2*dr*r->Rndm(i))-dr;; r2 = (2*dr*r->Rndm(i))-dr;; r7 = (2*dr*r->Rndm(i))-dr;; r9 = (2*dr*r->Rndm(i))-dr;; r4 = (2*dr*r->Rndm(i))-dr;; r3 = (2*dr*r->Rndm(i))-dr;; r5 = (2*dr*r->Rndm(i))-dr;; r6 = (2*dr*r->Rndm(i))-dr;; r8 = (2*dr*r->Rndm(i))-dr;; }; ; void parallelcoord() {; ; TNtuple *nt = nullptr;; ; Double_t s1x, s1y, s1z;; Double_t s2x, s2y, s2z;; Double_t s3x, s3y, s3z;; r = new TRandom();;; ; new TCanvas(""c1"", ""c1"",0,0,800,700);; ; nt = new TNtuple(""nt"",""Demo ntuple"",""x:y:z:u:v:w"");; ; for (Int_t i=0; i<20000; i++) {; r->Sphere(s1x, s1y, s1z, 0.1);; r->Sphere(s2x, s2y, s2z, 0.2);; r->Sphere(s3x, s3y, s3z, 0.05);; ; generate_random(i);; nt->Fill(r1, r2, r3, r4, r5, r6);; ; generate_random(i);; nt->Fill(s1x, s1y, s1z, s2x, s2y, s2z);; ; generate_random(i);; nt->Fill(r1, r2, r3, r4, r5, r6);; ; generate_random(i);; nt->Fill(s2x-1, s2y-1, s2z, s1x+.5, s1y+.5, s1z+.5);; ; generate_random(i);; nt->Fill(r1, r2, r3, r4, r5, r6);; ; generate_random(i);; nt->Fill(s1x+1, s1y+1, s1z+1, s3x-2, s3y-2, s3z-2);; ; generate_random(i);; nt->Fill(r1, r2, r3, r4, r5, r6);; }; nt->Draw(""x:y:z:u:v:w"","""",""para"",5000);; TParallelCoord* para = (TParallelCoord*)gPad->GetListOfPrimitives()->FindObject(""ParaCoord"");; para->SetDotsSpacing(5);; TParallelCoordVar* firstaxis = (TParallelCoordVar*)para->GetVarList()->FindObject(""x"");; firstaxis->AddRange(new TParallelCoordRange(firstaxis,0.846018,1.158469));; para",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/parallelcoord_8C.html:98,Load,Loading,98,doc/master/parallelcoord_8C.html,https://root.cern,https://root.cern/doc/master/parallelcoord_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/parallelcoordtrans.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. parallelcoordtrans.C File ReferenceTutorials » Tree tutorials. Detailed Description; Use of transparency with ||-Coord. ; It displays the same data set twice. The first time without transparency and the second time with transparency. On the second plot, several clusters appear. Images without and with transparency. Transparency works in PDF files. ; #include ""TFile.h""; #include ""TCanvas.h""; #include ""TStyle.h""; #include ""TRandom.h""; #include ""TNtuple.h""; #include ""TParallelCoord.h""; #include ""TParallelCoordVar.h""; #include ""TParallelCoordRange.h""; ; Double_t r1,r2,r3,r4,r5,r6,r7,r8,r9;; Double_t dr = 3.5;; TRandom *r;; ; void generate_random(Int_t i) {; r->Rannor(r1,r4);; r->Rannor(r7,r9);; r2 = (2*dr*r->Rndm(i))-dr;; r3 = (2*dr*r->Rndm(i))-dr;; r5 = (2*dr*r->Rndm(i))-dr;; r6 = (2*dr*r->Rndm(i))-dr;; r8 = (2*dr*r->Rndm(i))-dr;; }; ; void parallelcoordtrans() {; Double_t x,y,z,u,v,w,a,b,c;; Double_t s1x, s1y, s1z;; Double_t s2x, s2y, s2z;; Double_t s3x, s3y, s3z;; r = new TRandom();;; ; auto c1 = new TCanvas(""c1"", ""c1"",0,0,900,1000);; c1->Divide(1,2);; ; auto nt = new TNtuple(""nt"",""Demo ntuple"",""x:y:z:u:v:w:a:b:c"");; ; int n=0;; for (Int_t i=0; i<1500; i++) {; r->Sphere(s1x, s1y, s1z, 0.1);; r->Sphere(s2x, s2y, s2z, 0.2);; r->Sphere(s3x, s3y, s3z, 0.05);; ; generate_random(i);; nt->Fill(r1, r2, r3, r4, r5, r6, r7, r8, r9);; n++;; ; generate_random(i);; nt->Fill(s1x, s1y, s1z, s2x, s2y, s2z, r7, r8, r9);; n++;; ; generate_random(i);; nt->Fill(r1, r2, r3, r4, r5, r6, r7, s3y, r9);; n++;; ; generate_random(i);; nt->Fill(s2x-1, s2y-1, s2z, s1x+.5, s1y+.5, s1z+.5, r7, r8, r9);; n++;; ; generate_random(i);; nt->Fill(r1, r2, r3, r4, r5, r6, r7, r8, r9);; n++;; ; generate_random(i);; nt->Fill(s1x+1, s1y+1, s1z+1, s3x-2, s3y-2, s3z-2, r7, r8, r9);; n++;; ; generate_random(i);; nt->Fill(r1, r2, r3, r4, r5, r6, s3x, r8, s3z );; n++;; }; ; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree_2parallelcoordtrans_8C.html:103,Load,Loading,103,doc/master/tree_2parallelcoordtrans_8C.html,https://root.cern,https://root.cern/doc/master/tree_2parallelcoordtrans_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/printSizes.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. printSizes.C File ReferenceTutorials » Tree tutorials. Detailed Description; This macro can be used to get aggregate information on the size take on disk or in memory by the various branches in a TTree. ; For example: root [] printTreeSummary(tree);; The TTree ""T"" takes 3764343 bytes on disk; Its branch ""event"" takes 3760313 bytes on disk; onOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void onDefinition TGWin32VirtualXProxy.cxx:106; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; root [] printBranchSummary(tree->GetBranch(""event""));; The branch ""event"" takes 3760313 bytes on disk; Its sub-branch ""TObject"" takes 581 bytes on disk; Its sub-branch ""fType[20]"" takes 640 bytes on disk; Its sub-branch ""fEventName"" takes 855 bytes on disk; Its sub-branch ""fNtrack"" takes 506 bytes on disk; Its sub-branch ""fNseg"" takes 554 bytes on disk; Its sub-branch ""fNvertex"" takes 507 bytes on disk; Its sub-branch ""fFlag"" takes 420 bytes on disk; Its sub-branch ""fTemper",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/printSizes_8C.html:95,Load,Loading,95,doc/master/printSizes_8C.html,https://root.cern,https://root.cern/doc/master/printSizes_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/run_h1analysis.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. run_h1analysis.C File ReferenceTutorials » Tree tutorials. Detailed Description; Macro driving the analysis can specify file name and type ; .- type == 0 : normal; type = 1 : use AClic to compile selector; type = 2 : use a fill list and then process the fill list///. ; //----------------------------------------; ; void run_h1analysis(int type = 0, const char * h1dir = 0) {; ; std::cout << ""Run h1 analysis "" << std::endl;; ; // create first the chain with all the files; ; TChain chain(""h42"");; ; if (h1dir) {; gSystem->Setenv(""H1"",h1dir);; }; else; gSystem->Setenv(""H1"",""http://root.cern/files/h1/"");; ; ; std::cout << ""Creating the chain"" << std::endl;; ; chain.SetCacheSize(20*1024*1024);; chain.Add(""$H1/dstarmb.root"");; chain.Add(""$H1/dstarp1a.root"");; chain.Add(""$H1/dstarp1b.root"");; chain.Add(""$H1/dstarp2.root"");; ; TString selectionMacro = gSystem->GetDirName(__FILE__) + ""/h1analysis.C"";; ; if (type == 0); chain.Process(selectionMacro);; else if (type == 1) {; // use AClic ( add a + at the end; selectionMacro += ""+"";; chain.Process(selectionMacro);; }; else if (type == 2) {; chain.Process(selectionMacro,""fillList"");; chain.Process(selectionMacro,""useList"");; }; }; ; ; ; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/run__h1analysis_8C.html:99,Load,Loading,99,doc/master/run__h1analysis_8C.html,https://root.cern,https://root.cern/doc/master/run__h1analysis_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/spider.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. spider.C File ReferenceTutorials » Tree tutorials. Detailed Description; TSpider example. ; ; #include ""TFile.h""; #include ""TCanvas.h""; #include ""TNtuple.h""; #include ""TSpider.h""; ; void spider() {; TCanvas *c1 = new TCanvas(""c1"",""TSpider example"",200,10,700,700);; TFile *f = new TFile(""hsimple.root"");; if (!f || f->IsZombie()) {; printf(""Please run <ROOT location>/tutorials/hsimple.C before."");; return;; }; TNtuple* ntuple = (TNtuple*)f->Get(""ntuple"");; TString varexp = ""px:py:pz:random:sin(px):log(px/py):log(pz)"";; TString selection = ""px>0 && py>0 && pz>0"";; TString options = ""average"";; TSpider *spider = new TSpider(ntuple,varexp.Data(),selection.Data(),options.Data());; spider->Draw();; c1->ToggleEditor();; c1->Selected(c1,spider,1);; }; f#define f(i)Definition RSha256.hxx:104; TCanvas.h; TFile.h; TNtuple.h; TSpider.h; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TSpiderSpider class.Definition TSpider.h:40; TSpider::Drawvoid Draw(Option_t *options="""") overrideDraw the spider.Definition TSpider.cxx:454; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; c1return c1Definition legend1.C:41; AuthorBastien Dallapiazza ; Definition in file spider.C. tutorialstreespider.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/spider_8C.html:91,Load,Loading,91,doc/master/spider_8C.html,https://root.cern,https://root.cern/doc/master/spider_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/staff.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. staff.C File ReferenceTutorials » Tree tutorials. Detailed Description; Create a plot of the data in cernstaff.root To create cernstaff.root, execute tutorial $ROOTSYS/tutorials/tree/cernbuild.C . ; void staff() {; auto f = TFile::Open(""cernstaff.root"");; TTree *T = nullptr;; f->GetObject(""T"",T);; T->Draw(""Grade:Age:Cost:Division:Nation"","""",""gl5d"");; if (gPad) gPad->Print(""staff.C.png"");; }; f#define f(i)Definition RSha256.hxx:104; gPad#define gPadDefinition TVirtualPad.h:308; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; staffDefinition staff.py:1; AuthorRene Brun ; Definition in file staff.C. tutorialstreestaff.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/staff_8C.html:90,Load,Loading,90,doc/master/staff_8C.html,https://root.cern,https://root.cern/doc/master/staff_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/tcl.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tcl.C File ReferenceTutorials » Tree tutorials. Detailed Description; How to write a TClonesArray to a TTree ; The following tests can be run Interactive tests Root > .x tcl.C //no-split interpreted; Root > .x tcl.C(1) //split interpreted; Root > .x tcl.C++ //no-split compiled; Root > .x tcl.C++(1) //split compiled; Batch tests: same as above but with no graphics root -b -q tcl.C; root -b -q tcl.C++; root -b -q ""tcl.C(1)""; root -b -q ""tcl.C++(1)""; ; #include ""TFile.h""; #include ""TClonesArray.h""; #include ""TH2.h""; #include ""TLine.h""; #include ""TTree.h""; #include ""TBenchmark.h""; #include ""TRandom.h""; ; void tclwrite(Int_t split); {; // Generate a Tree with a TClonesArray; // The array can be split or not; TFile f(""tcl.root"",""recreate"");; f.SetCompressionLevel(1); //try level 2 also; TTree T(""T"",""test tcl"");; TClonesArray *arr = new TClonesArray(""TLine"");; TClonesArray &ar = *arr;; T.Branch(""tcl"",&arr,256000,split);; //By default a TClonesArray is created with its BypassStreamer bit set.; //However, because TLine has a custom Streamer, this bit was reset; //by TTree::Branch above. We set again this bit because the current; //version of TLine uses the automatic Streamer.; //BypassingStreamer saves space and time.; arr->BypassStreamer();; for (Int_t ev=0;ev<10000;ev++) {; ar.Clear();; Int_t nlines = Int_t(gRandom->Gaus(50,10));; if(nlines < 0) nlines = 1;; for (Int_t i=0;i<nlines;i++) {; Float_t x1 = gRandom->Rndm();; Float_t y1 = gRandom->Rndm();; Float_t x2 = gRandom->Rndm();; Float_t y2 = gRandom->Rndm();; new(ar[i]) TLine(x1,y1,x2,y2);; }; T.Fill();; }; T.Print();; T.Write();; }; ; void tclread(); {; // read file generated by tclwrite; // loop on all entries.; // histogram center of lines; TFile *f = new TFile(""tcl.root"");; TTree *T = (TTree*)f->Get(""T"");; TH2F *h2 = new TH2F(""h2"",""center of lines"",40,0,1,40,0,1);; ; TClonesArray *arr = new TCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tcl_8C.html:88,Load,Loading,88,doc/master/tcl_8C.html,https://root.cern,https://root.cern/doc/master/tcl_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/temperature.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. temperature.C File ReferenceTutorials » Tree tutorials. Detailed Description; This tutorial illustrates how to use the highlight mode with trees. ; It first creates a TTree from a temperature data set in Prague between 1775 and 2004. Then it defines three pads representing the temperature per year, month and day. Thanks to the highlight mechanism it is possible to explore the data set only by moving the mouse on the plots. Movements on the years' plot will update the months' and days' plot. Movements on the months plot will update the days plot. Movements on the days' plot will display the exact temperature for a given day.; ; Int_t year, month, day;; TTree *tree = nullptr;; TProfile *hYear = nullptr, *hMonth = nullptr, *hDay = nullptr;; TCanvas *Canvas = nullptr;; Int_t customhb = -2;; TLatex *info = nullptr;; ; // Ranges for year, month, day and temperature; Int_t rYear[3]; // from tree/data; Int_t rMonth[3] = { 12, 1, 13 };; Int_t rDay[3] = { 31, 1, 32 };; Double_t rTemp[3] = { 55.0, -20.0, 35.0 };; ; void HighlightDay(Int_t xhb); {; if (!info) {; info = new TLatex();; info->SetTextSizePixels(25);; Canvas->cd(3);; info->Draw();; gPad->Update();; }; ; if (xhb != customhb) day = xhb;; TString temp = TString::Format("" %5.1f #circC"", hDay->GetBinContent(day));; if (hDay->GetBinEntries(day) == 0) temp = "" "";; TString m = "" "";; if (month>0) m = TString::Format(""-%02d"",month);; TString d = "" "";; if (day>0) d = TString::Format(""-%02d"",day);; info->SetText(2.0, hDay->GetMinimum()*0.8, TString::Format(""%4d%s%s%s"", year, m.Data(), d.Data(), temp.Data()));; Canvas->GetPad(3)->Modified();; }; ; void HighlightMonth(Int_t xhb); {; if (!hDay) {; hDay = new TProfile(""hDay"", ""; day; temp, #circC"", rDay[0], rDay[1], rDay[2]);; hDay->SetMinimum(rTemp[1]);; hDay->SetMaximum(rTemp[2]);; hDay->GetYaxis()->SetNdivisions(410);; hDay->SetFillColor(kGray);; h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/temperature_8C.html:96,Load,Loading,96,doc/master/temperature_8C.html,https://root.cern,https://root.cern/doc/master/temperature_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/tree.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tree.C File ReferenceTutorials » Tree tutorials. Detailed Description; Display the Tree data structures . ; void tree() {; TCanvas* c1 = new TCanvas(""c1"",""Tree Data Structure"",200,10,750,940);; c1->Range(0,-0.1,1,1.15);; ; gBenchmark->Start(""tree"");; ; Int_t branchcolor = 26;; Int_t leafcolor = 30;; Int_t basketcolor = 42;; Int_t offsetcolor = 43;; TPaveLabel* title = new TPaveLabel(.3,1.05,.8,1.13,c1->GetTitle());; title->SetFillColor(16);; title->Draw();; TPaveText* treePave = new TPaveText(.01,.75,.15,1.00);; treePave->SetFillColor(18);; treePave->SetTextAlign(12);; TText *tnt = treePave->AddText(""Tree"");; tnt->SetTextAlign(22);; tnt->SetTextSize(0.030);; treePave->AddText(""fScanField"");; treePave->AddText(""fMaxEventLoop"");; treePave->AddText(""fMaxVirtualSize"");; treePave->AddText(""fEntries"");; treePave->AddText(""fDimension"");; treePave->AddText(""fSelectedRows"");; treePave->Draw();; TPavesText* farm = new TPavesText(.01,1.02,.15,1.1,9,""tr"");; TText *tfarm = farm->AddText(""CHAIN"");; tfarm->SetTextSize(0.024);; farm->AddText(""Collection"");; farm->AddText(""of Trees"");; farm->Draw();; TLine* llink = new TLine(.15,.92,.80,.92);; llink->SetLineWidth(2);; llink->SetLineColor(1);; llink->Draw();; llink->DrawLine(.21,.87,.21,.275);; llink->DrawLine(.23,.87,.23,.375);; llink->DrawLine(.25,.87,.25,.805);; llink->DrawLine(.41,.25,.41,-.025);; llink->DrawLine(.43,.25,.43,.075);; llink->DrawLine(.45,.25,.45,.175);; TPaveLabel* branch0 = new TPaveLabel(.20,.87,.35,.97,""Branch 0"");; branch0->SetTextSize(0.35);; branch0->SetFillColor(branchcolor);; branch0->Draw();; TPaveLabel* branch1 = new TPaveLabel(.40,.87,.55,.97,""Branch 1"");; branch1->SetTextSize(0.35);; branch1->SetFillColor(branchcolor);; branch1->Draw();; TPaveLabel* branch2 = new TPaveLabel(.60,.87,.75,.97,""Branch 2"");; branch2->SetTextSize(0.35);; branch2->SetFillColor(branchcolor);; branch2->Dr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree_8C.html:89,Load,Loading,89,doc/master/tree_8C.html,https://root.cern,https://root.cern/doc/master/tree_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/tree0.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tree0.C File ReferenceTutorials » Tree tutorials. Detailed Description; Simple Event class example ; execute as: .x tree0.C++; You have to copy it first to a directory where you have write access! Note that .x tree0.C cannot work with this example. Effect of ClassDef() and ClassImp() macros; After running this macro create an instance of Det and Event; Det d;; Event e;; d#define d(i)Definition RSha256.hxx:102; e#define e(i)Definition RSha256.hxx:103; EventDefinition collection_proxies.C:172; now you can see the effect of the ClassDef() and ClassImp() macros. (for the Det class these commands are commented!) For instance 'e' now knows who it is:; cout<<e.Class_Name()<<endl;; whereas d does not.; The methods that are added by the ClassDef()/Imp() macro can be listed with; .class; .class Event; .class Det; ; #include <TRandom.h>; #include <TTree.h>; #include <TCanvas.h>; #include <TStyle.h>; ; #include <Riostream.h>; ; //class Det : public TObject {; class Det { // each detector gives an energy and time signal; public:; Double_t e; //energy; Double_t t; //time; ; // ClassDef(Det,1); };; ; //ClassImp(Det); ; //class Event { //TObject is not required by this example; class Event : public TObject {; public:; ; Det a; // say there are two detectors (a and b) in the experiment; Det b;; ClassDefOverride(Event,1); };; ; ClassImp(Event); ; void tree0() {; // create a TTree; TTree *tree = new TTree(""tree"",""treelibrated tree"");; Event *e = new Event;; ; // create a branch with energy; tree->Branch(""event"",&e);; ; // fill some events with random numbers; Int_t nevent=10000;; for (Int_t iev=0;iev<nevent;iev++) {; if (iev%1000==0) cout<<""Processing event ""<<iev<<""...""<<endl;; ; Float_t ea,eb;; gRandom->Rannor(ea,eb); // the two energies follow a gaus distribution; e->a.e=ea;; e->b.e=eb;; e->a.t=gRandom->Rndm(); // random; e->b.t=e->a.t + gRandom->Gaus(0.,.1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree0_8C.html:90,Load,Loading,90,doc/master/tree0_8C.html,https://root.cern,https://root.cern/doc/master/tree0_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/tree1.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tree1.C File ReferenceTutorials » Tree tutorials. Detailed Description; This example is a variant of hsimple.C but using a TTree instead of a TNtuple. ; It shows:; how to fill a Tree with a few simple variables.; how to read this Tree; how to browse and analyze the Tree via the TBrowser and TTreeViewer This example can be run in many different ways:. Using the Cling interpreter .x tree1.C. Using the automatic compiler interface .x tree1.C++. .L tree1.C or .L tree1.C++; tree1(); One can also run the write and read parts in two separate sessions. For example following one of the sessions above, one can start the session: .L tree1.C; tree1r();; ; #include ""TROOT.h""; #include ""TFile.h""; #include ""TTree.h""; #include ""TBrowser.h""; #include ""TH2.h""; #include ""TRandom.h""; ; void tree1w(); {; //create a Tree file tree1.root; ; //create the file, the Tree and a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""random"",&random,""random/D"");; t1.Branch(""ev"",&ev,""ev/I"");; ; //fill the tree; for (Int_t i=0;i<10000;i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; ; //save the Tree header. The file will be automatically closed; //when going out of the function scope; t1.Write();; }; ; void tree1r(); {; //read the Tree generated by tree1w and fill two histograms; ; //note that we use ""new"" to create the TFile and TTree objects !; //because we want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree1.root"");; TTree *t1 = (TTree*)f->Get(""t1"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1->SetBranchAddress(""px"",&px);; t1->SetBranchAddress(""py"",&py);; t1->SetBranchAddr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree1_8C.html:90,Load,Loading,90,doc/master/tree1_8C.html,https://root.cern,https://root.cern/doc/master/tree1_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/tree2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tree2.C File ReferenceTutorials » Tree tutorials. Detailed Description; This example illustrates how to make a Tree from variables or arrays in a C struct - without a dictionary, by creating the branches for builtin types (int, float, double) and arrays explicitly. ; See tree2a.C for the same example using a class with dictionary instead of a C-struct.; In this example, we are mapping a C struct to one of the Geant3 common blocks /gctrak/. In the real life, this common will be filled by Geant3 at each step and only the Tree Fill function should be called. The example emulates the Geant3 step routines.; to run the example, do: .x tree2.C to execute with the Cling interpreter; .x tree2.C++ to execute with native compiler; ; #include ""TFile.h""; #include ""TTree.h""; #include ""TH2.h""; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""TMath.h""; ; const Int_t MAXMEC = 30;; ; typedef struct {; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7];; Int_t nmec;; Int_t lmec[MAXMEC];; Int_t namec[MAXMEC];; Int_t nstep;; Int_t pid;; Float_t destep;; Float_t destel;; Float_t safety;; Float_t sleng;; Float_t step;; Float_t snext;; Float_t sfield;; Float_t tofg;; Float_t gekrat;; Float_t upwght;; } Gctrak_t;; ; ; void helixStep(Float_t step, Float_t *vect, Float_t *vout); {; // extrapolate track in constant field; Float_t field = 20; //magnetic field in kilogauss; enum Evect {kX,kY,kZ,kPX,kPY,kPZ,kPP};; vout[kPP] = vect[kPP];; Float_t h4 = field*2.99792e-4;; Float_t rho = -h4/vect[kPP];; Float_t tet = rho*step;; Float_t tsint = tet*tet/6;; Float_t sintt = 1 - tsint;; Float_t sint = tet*sintt;; Float_t cos1t = tet/2;; Float_t f1 = step*sintt;; Float_t f2 = step*cos1t;; Float_t f3 = step*tsint*vect[kPZ];; Float_t f4 = -tet*cos1t;; Float_t f5 = sint;; Float_t f6 = tet*cos1t*vect[kPZ];; vout[kX] = vect[kX] + (f1*vect[kPX] - f2*vect[kPY]);; vout[",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree2_8C.html:90,Load,Loading,90,doc/master/tree2_8C.html,https://root.cern,https://root.cern/doc/master/tree2_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/tree2a.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tree2a.C File ReferenceTutorials » Tree tutorials. Detailed Description; This example is the same as tree2.C, but uses a class instead of a C-struct. ; In this example, we are mapping a class to one of the Geant3 common blocks /gctrak/. In the real life, this common will be filled by Geant3 at each step and only the Tree Fill function should be called. The example emulates the Geant3 step routines.; to run the example, do to execute with native compiler: .x tree2a.C+ ; Note that since IO is involved, ACLiC has to be invoked to create the dictionary of class Gctrak. ; #include ""TROOT.h""; #include ""TFile.h""; #include ""TTree.h""; #include ""TBrowser.h""; #include ""TH2.h""; #include ""TMath.h""; #include ""TRandom.h""; #include ""TCanvas.h""; ; const Int_t MAXMEC = 30;; ; class Gctrak : public TObject {; public:; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7]; //! not persistent; Int_t nmec;; Int_t *lmec; //[nmec]; Int_t *namec; //[nmec]; Int_t nstep; //! not persistent; Int_t pid;; Float_t destep;; Float_t destel; //! not persistent; Float_t safety; //! not persistent; Float_t sleng; //! not persistent; Float_t step; //! not persistent; Float_t snext; //! not persistent; Float_t sfield; //! not persistent; Float_t tofg; //! not persistent; Float_t gekrat; //! not persistent; Float_t upwght; //! not persistent; ; Gctrak() {lmec=nullptr; namec=nullptr;}; ; ClassDefOverride(Gctrak,1); };; ; ; void helixStep(Float_t step, Float_t *vect, Float_t *vout); {; // extrapolate track in constant field; Float_t field = 20; //magnetic field in kilogauss; enum Evect {kX,kY,kZ,kPX,kPY,kPZ,kPP};; vout[kPP] = vect[kPP];; Float_t h4 = field*2.99792e-4;; Float_t rho = -h4/vect[kPP];; Float_t tet = rho*step;; Float_t tsint = tet*tet/6;; Float_t sintt = 1 - tsint;; Float_t sint = tet*sintt;; Float_t cos1t = tet/2;; Float_t f1 = step*sintt;; Float_t f2 = st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree2a_8C.html:91,Load,Loading,91,doc/master/tree2a_8C.html,https://root.cern,https://root.cern/doc/master/tree2a_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/tree3.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tree3.C File ReferenceTutorials » Tree tutorials. Detailed Description; Example of a Tree where branches are variable length arrays A second Tree is created and filled in parallel. ; Run this script with .x tree3.C; In the function treer, the first Tree is open. The second Tree is declared friend of the first tree. TTree::Draw is called with variables from both Trees. ; #include ""TFile.h""; #include ""TTree.h""; #include ""TRandom.h""; #include ""TCanvas.h""; ; void tree3w() {; ; const Int_t kMaxTrack = 500;; Int_t ntrack;; Int_t stat[kMaxTrack];; Int_t sign[kMaxTrack];; Float_t px[kMaxTrack];; Float_t py[kMaxTrack];; Float_t pz[kMaxTrack];; Float_t pt[kMaxTrack];; Float_t zv[kMaxTrack];; Float_t chi2[kMaxTrack];; Double_t sumstat;; ; TFile f(""tree3.root"",""recreate"");; TTree *t3 = new TTree(""t3"",""Reconst ntuple"");; t3->Branch(""ntrack"",&ntrack,""ntrack/I"");; t3->Branch(""stat"",stat,""stat[ntrack]/I"");; t3->Branch(""sign"",sign,""sign[ntrack]/I"");; t3->Branch(""px"",px,""px[ntrack]/F"");; t3->Branch(""py"",py,""py[ntrack]/F"");; t3->Branch(""pz"",pz,""pz[ntrack]/F"");; t3->Branch(""zv"",zv,""zv[ntrack]/F"");; t3->Branch(""chi2"",chi2,""chi2[ntrack]/F"");; ; TFile fr(""tree3f.root"",""recreate"");; TTree *t3f = new TTree(""t3f"",""a friend Tree"");; t3f->Branch(""ntrack"",&ntrack,""ntrack/I"");; t3f->Branch(""sumstat"",&sumstat,""sumstat/D"");; t3f->Branch(""pt"",pt,""pt[ntrack]/F"");; ; for (Int_t i=0;i<1000;i++) {; Int_t nt = gRandom->Rndm()*(kMaxTrack-1);; ntrack = nt;; sumstat = 0;; for (Int_t n=0;n<nt;n++) {; stat[n] = n%3;; sign[n] = i%2;; px[n] = gRandom->Gaus(0,1);; py[n] = gRandom->Gaus(0,2);; pz[n] = gRandom->Gaus(10,5);; zv[n] = gRandom->Gaus(100,2);; chi2[n] = gRandom->Gaus(0,.01);; sumstat += chi2[n];; pt[n] = TMath::Sqrt(px[n]*px[n] + py[n]*py[n]);; }; t3->Fill();; t3f->Fill();; }; t3->Print();; f.cd();; t3->Write();; fr.cd();; t3f->Write();; }; ; void tree3r(); {; TFile *f = new TF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree3_8C.html:90,Load,Loading,90,doc/master/tree3_8C.html,https://root.cern,https://root.cern/doc/master/tree3_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/tree4.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tree4.C File ReferenceTutorials » Tree tutorials. Detailed Description; This example writes a tree with objects of the class Event. ; It is a simplified version of $ROOTSYS/test/MainEvent.cxx to write the tree, and $ROOTSYS/test/eventb.C It shows:; how to fill a Tree with an event class containing these data members: char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr;; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; Int_tint Int_tDefinition RtypesCore.h:45; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622. the difference in splitting or not splitting a branch; how to read selected branches of the tree, and print the first entry with less than 587 tracks.; how to browse and analyze the Tree via the TBrowser and TTreeViewer. This example can be run in many different ways:; way1 using the Cling interpreter: .x tree4.C. way2 using the Cling interpreter: .L tree4.C; tree4(). way3 using ACLIC: .L ../test/libEvent.so; .x tree4.C++; One can also run the write and read parts in two separate sessions. For example following one of the sessions above, one can start the session: .L tree4.C; tree4r();; ; R__LOAD_LIBRARY($ROOTSYS/test/libEvent.so); ; #include ""TFile.h""; #include ""TTree.h""; #include ""TBrowser.h""; #include ""TH2.h""; #include ""TRandom.h""; #include ""TClassTable.h""; #include ""TSystem.h""; #include ""TROOT.h""; #include ""../test/Event.h""; ; void tree4w(); {; ; //create a Tree file tree4.root; TFile f(""tree4.root"",""RECREATE"");; ; // Create a ROOT Tree; TTree t4(""t4"",""A Tree with Even",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree4_8C.html:90,Load,Loading,90,doc/master/tree4_8C.html,https://root.cern,https://root.cern/doc/master/tree4_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/treefriend.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. treefriend.C File ReferenceTutorials » Tree tutorials. Detailed Description; Illustrates how to use Tree friends: . create a simple TTree; Copy a subset of this TTree to a new TTree; Create a Tree Index; Make a friend TTree; compare two TTrees; Draw a variable from the first tree versus a variable in the friend Tree. You can run this tutorial with: root > .x treefriend.C (interpreted via Cling); root > .x treefriend.C+ (executed via ACLIC & the native compiler); or, variants like: root > .L treefriend.C+; root > CreateParentTree();; root > CreateFriendTree();; root > CompareTrees();; root > DrawFriend();; ; ******************************************************************************; *Tree :T : test friend trees *; *Entries : 10000 : Total = 203762 bytes File Size = 94821 *; * : : Tree compression factor = 1.69 *; ******************************************************************************; *Br 0 :Run : Run/I *; *Entries : 10000 : Total Size= 40698 bytes File Size = 265 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 120.75 *; *............................................................................*; *Br 1 :Event : Event/I *; *Entries : 10000 : Total Size= 40712 bytes File Size = 11231 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 2.85 *; *............................................................................*; *Br 2 :x : x/F *; *Entries : 10000 : Total Size= 40684 bytes File Size = 27116 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 1.18 *; *............................................................................*; *Br 3 :y : y/F *; *Entries : 10000 : Total Size= 40684 bytes File Size = 27035 *; *Baskets : 1 : Basket Size= 32000 bytes Compression= 1.18 *; *............................................................................*; *Br 4 :z : z/F *; *Entries : 10000 : Total Size= 40684 b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/treefriend_8C.html:95,Load,Loading,95,doc/master/treefriend_8C.html,https://root.cern,https://root.cern/doc/master/treefriend_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/tree/treegetval.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. treegetval.C File ReferenceTutorials » Tree tutorials. Detailed Description; Illustrates how to retrieve TTree variables in arrays. ; This example:; creates a simple TTree,; generates TTree variables thanks to the Draw method with goff option,; retrieves some of them in arrays thanks to GetVal,; generates and draw graphs with these arrays. The option goff in TTree::Draw behaves like any other drawing option except that, at the end, no graphics is produced ( goff= graphics off). This allows to generate as many TTree variables as needed. All the graphics options (except para and candle) are limited to four variables only. And para and candle need at least two variables.; Note that by default TTree::Draw creates the arrays obtained with GetVal with a length corresponding to the parameter fEstimate. By default fEstimate=1000000 and can be modified via TTree::SetEstimate. To keep in memory all the results use: tree->SetEstimate(-1);; SetEstimate should be called if the expected number of selected rows is greater than 1000000. ; The arrays' dimension is 5000; ; void treegetval() {; // create a simple TTree with 5 branches; Int_t run, evt;; Float_t x,y,z;; TTree *T = new TTree(""T"",""test friend trees"");; T->Branch(""Run"",&run,""Run/I"");; T->Branch(""Event"",&evt,""Event/I"");; T->Branch(""x"",&x,""x/F"");; T->Branch(""y"",&y,""y/F"");; T->Branch(""z"",&z,""z/F"");; TRandom r;; for (Int_t i=0;i<10000;i++) {; if (i < 5000) run = 1;; else run = 2;; evt = i;; x = r.Gaus(10,1);; y = r.Gaus(20,2);; z = r.Landau(2,1);; T->Fill();; }; ; // Draw with option goff and generate seven variables; Int_t n = T->Draw(""x:y:z:Run:Event:sin(x):cos(x)"",""Run==1"",""goff"");; printf(""The arrays' dimension is %d\n"",n);; ; // Retrieve variables 0, 5 et 6; Double_t *vx = T->GetVal(0);; Double_t *vxs = T->GetVal(5);; Double_t *vxc = T->GetVal(6);; ; // Create and draw graphs; TGraph *gs = ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/treegetval_8C.html:95,Load,Loading,95,doc/master/treegetval_8C.html,https://root.cern,https://root.cern/doc/master/treegetval_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/v7 Directory Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. v7 Directory Reference. Directory dependency graph for v7:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Directories;  ntuple;  . Files;  browser.cxx;  ;  concurrentfill.cxx;  ;  filedialog.cxx;  ;  fitpanel.cxx;  ;  fitpanel6.cxx;  ;  histops.cxx;  ;  perf.cxx;  ;  perfcomp.cxx;  ;  simple.cxx;  . tutorialsv7. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:51 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_87a15b6630bbbec9854bba9437a28716.html:85,Load,Loading,85,doc/master/dir_87a15b6630bbbec9854bba9437a28716.html,https://root.cern,https://root.cern/doc/master/dir_87a15b6630bbbec9854bba9437a28716.html,2,"['Load', 'concurren']","['Loading', 'concurrentfill']"
Performance,". ROOT: tutorials/v7/ntuple Directory Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ntuple Directory Reference. Directory dependency graph for ntuple:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files;  ntpl001_staff.C;   Write and read tabular data with RNTuple. ;  ;  ntpl002_vector.C;   Write and read STL vectors with RNTuple. ;  ;  ntpl004_dimuon.C;   Mini-Analysis on CMS OpenData with RDataFrame. ;  ;  ntpl005_introspection.C;   Write and read an RNTuple from a user-defined class. ;  ;  ntpl006_friends.C;   Work with befriended RNTuples. ;  ;  ntpl007_mtFill.C;   Example of multi-threaded writes using multiple REntry objects ;  ;  ntpl008_import.C;   Example of converting data stored in a TTree into an RNTuple ;  ;  ntpl009_parallelWriter.C;   Example of multi-threaded writes using RNTupleParallelWriter. ;  ;  ntpl010_skim.C;   Example creating a derived RNTuple ;  ;  ntpl011_global_temperatures.C;   This ROOT 7 example demonstrates how to use RNTuple in combination with ROOT 6 features like RDataframe and visualizations. ;  ;  ntpl012_processor.C;   Demonstrate the RNTupleProcessor using multiple RNTuples ;  ;  ntpl013_staged.C;   Example of staged cluster committing in multi-threaded writing using RNTupleParallelWriter. ;  ;  ntpl014_framework.C;   ;  . tutorialsv7ntuple. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_74d0bdb54707d3eaa1a5a0931b591e7a.html:92,Load,Loading,92,doc/master/dir_74d0bdb54707d3eaa1a5a0931b591e7a.html,https://root.cern,https://root.cern/doc/master/dir_74d0bdb54707d3eaa1a5a0931b591e7a.html,4,"['Load', 'multi-thread']","['Loading', 'multi-threaded']"
Performance,". ROOT: tutorials/v7/ntuple/ntpl001_staff.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ntpl001_staff.C File ReferenceTutorials » ROOT 7 tutorials » ROOT 7 ntuple tutorials. Detailed Description; Write and read tabular data with RNTuple. ; Adapted from the cernbuild and cernstaff tree tutorials. Illustrates the type-safe ntuple model interface, which is used to define a data model that is in a second step taken by an ntuple reader or writer. ; // NOTE: The RNTuple classes are experimental at this point.; // Functionality, interface, and data format is still subject to changes.; // Do not use for real data!; ; #include <ROOT/RNTupleModel.hxx>; #include <ROOT/RNTupleReader.hxx>; #include <ROOT/RNTupleWriter.hxx>; ; #include <TCanvas.h>; #include <TH1I.h>; #include <TROOT.h>; #include <TString.h>; ; #include <cassert>; #include <cstdio>; #include <fstream>; #include <iostream>; #include <memory>; #include <string>; #include <sstream>; #include <utility>; ; // Import classes from experimental namespace for the time being; using RNTupleModel = ROOT::Experimental::RNTupleModel;; using RNTupleReader = ROOT::Experimental::RNTupleReader;; using RNTupleWriter = ROOT::Experimental::RNTupleWriter;; ; constexpr char const* kNTupleFileName = ""ntpl001_staff.root"";; ; void Ingest() {; // The input file cernstaff.dat is a copy of the CERN staff data base from 1988; ifstream fin(gROOT->GetTutorialDir() + ""/tree/cernstaff.dat"");; assert(fin.is_open());; ; // We create a unique pointer to an empty data model; auto model = RNTupleModel::Create();; ; // To define the data model, we create fields with a given C++ type and name. Fields are roughly TTree branches.; // MakeField returns a shared pointer to a memory location that we can populate to fill the ntuple with data; auto fldCategory = model->MakeField<int>(""Category"");; auto fldFlag = model->MakeField<unsigned int>(""Flag"");; auto fldAge = model->MakeField<int>(""Age"");; auto fldServi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ntpl001__staff_8C.html:103,Load,Loading,103,doc/master/ntpl001__staff_8C.html,https://root.cern,https://root.cern/doc/master/ntpl001__staff_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/v7/ntuple/ntpl001_staff.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ntpl001_staff.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_ntuple; 3/// \notebook; 4/// Write and read tabular data with RNTuple. Adapted from the cernbuild and cernstaff tree tutorials.; 5/// Illustrates the type-safe ntuple model interface, which is used to define a data model that is in a second step; 6/// taken by an ntuple reader or writer.; 7///; 8/// \macro_image; 9/// \macro_code; 10///; 11/// \date April 2019; 12/// \author The ROOT Team; 13 ; 14// NOTE: The RNTuple classes are experimental at this point.; 15// Functionality, interface, and data format is still subject to changes.; 16// Do not use for real data!; 17 ; 18#include <ROOT/RNTupleModel.hxx>; 19#include <ROOT/RNTupleReader.hxx>; 20#include <ROOT/RNTupleWriter.hxx>; 21 ; 22#include <TCanvas.h>; 23#include <TH1I.h>; 24#include <TROOT.h>; 25#include <TString.h>; 26 ; 27#include <cassert>; 28#include <cstdio>; 29#include <fstream>; 30#include <iostream>; 31#include <memory>; 32#include <string>; 33#include <sstream>; 34#include <utility>; 35 ; 36// Import classes from experimental namespace for the time being; 37using RNTupleModel = ROOT::Experimental::RNTupleModel;; 38using RNTupleReader = ROOT::Experimental::RNTupleReader;; 39using RNTupleWriter = ROOT::Experimental::RNTupleWriter;; 40 ; 41constexpr char const* kNTupleFileName = ""ntpl001_staff.root"";; 42 ; 43void Ingest() {; 44 // The input file cernstaff.dat is a copy of the CERN staff data base from 1988; 45 ifstream fin(gROOT->GetTutorialDir() + ""/tree/cernstaff.dat"");; 46 assert(fin.is_open());; 47 ; 48 // We create a unique pointer to an empty data model; 49 auto model = RNTupleModel::Create();; 50 ; 51 // To define the data model, we create fields with a given C++ type and name. Fields are roughly TTree branches.; 52 // MakeField returns a shared pointer to a memory location th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ntpl001__staff_8C_source.html:100,Load,Loading,100,doc/master/ntpl001__staff_8C_source.html,https://root.cern,https://root.cern/doc/master/ntpl001__staff_8C_source.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/v7/ntuple/ntpl008_import.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ntpl008_import.C File ReferenceTutorials » ROOT 7 tutorials » ROOT 7 ntuple tutorials. Detailed Description; Example of converting data stored in a TTree into an RNTuple . ; // NOTE: The RNTuple classes are experimental at this point.; // Functionality, interface, and data format is still subject to changes.; // Do not use for real data!; ; #include <ROOT/RNTupleDS.hxx>; #include <ROOT/RNTupleImporter.hxx>; #include <ROOT/RNTupleReader.hxx>; #include <ROOT/RPageStorageFile.hxx>; ; #include <TFile.h>; #include <TROOT.h>; #include <TSystem.h>; ; // Import classes from experimental namespace for the time being.; using RNTupleImporter = ROOT::Experimental::RNTupleImporter;; using RNTupleReader = ROOT::Experimental::RNTupleReader;; ; // Input and output.; constexpr char const *kTreeFileName = ""http://root.cern.ch/files/HiggsTauTauReduced/GluGluToHToTauTau.root"";; constexpr char const *kTreeName = ""Events"";; constexpr char const *kNTupleFileName = ""ntpl008_import.root"";; ; void ntpl008_import(); {; // RNTupleImporter appends keys to the output file; make sure a second run of the tutorial does not fail; // with `Key 'Events' already exists in file ntpl008_import.root` by removing the output file.; gSystem->Unlink(kNTupleFileName);; ; // Use multiple threads to compress RNTuple data.; ROOT::EnableImplicitMT();; ; // Create a new RNTupleImporter object.; auto importer = RNTupleImporter::Create(kTreeFileName, kTreeName, kNTupleFileName);; ; // Begin importing.; importer->Import();; ; // Inspect the schema of the written RNTuple.; auto file = std::unique_ptr<TFile>(TFile::Open(kNTupleFileName));; if (!file || file->IsZombie()) {; std::cerr << ""cannot open "" << kNTupleFileName << std::endl;; return;; }; auto ntpl = std::unique_ptr<ROOT::RNTuple>(file->Get<ROOT::RNTuple>(""Events""));; auto reader = RNTupleReader::Open(*ntpl);; reader->PrintI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ntpl008__import_8C.html:104,Load,Loading,104,doc/master/ntpl008__import_8C.html,https://root.cern,https://root.cern/doc/master/ntpl008__import_8C.html,1,['Load'],['Loading']
Performance,". ROOT: tutorials/v7/ntuple/ntpl008_import.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ntpl008_import.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_ntuple; 3/// \notebook; 4/// Example of converting data stored in a TTree into an RNTuple; 5///; 6/// \macro_image; 7/// \macro_code; 8///; 9/// \date December 2022; 10/// \author The ROOT Team; 11 ; 12// NOTE: The RNTuple classes are experimental at this point.; 13// Functionality, interface, and data format is still subject to changes.; 14// Do not use for real data!; 15 ; 16#include <ROOT/RNTupleDS.hxx>; 17#include <ROOT/RNTupleImporter.hxx>; 18#include <ROOT/RNTupleReader.hxx>; 19#include <ROOT/RPageStorageFile.hxx>; 20 ; 21#include <TFile.h>; 22#include <TROOT.h>; 23#include <TSystem.h>; 24 ; 25// Import classes from experimental namespace for the time being.; 26using RNTupleImporter = ROOT::Experimental::RNTupleImporter;; 27using RNTupleReader = ROOT::Experimental::RNTupleReader;; 28 ; 29// Input and output.; 30constexpr char const *kTreeFileName = ""http://root.cern.ch/files/HiggsTauTauReduced/GluGluToHToTauTau.root"";; 31constexpr char const *kTreeName = ""Events"";; 32constexpr char const *kNTupleFileName = ""ntpl008_import.root"";; 33 ; 34void ntpl008_import(); 35{; 36 // RNTupleImporter appends keys to the output file; make sure a second run of the tutorial does not fail; 37 // with `Key 'Events' already exists in file ntpl008_import.root` by removing the output file.; 38 gSystem->Unlink(kNTupleFileName);; 39 ; 40 // Use multiple threads to compress RNTuple data.; 41 ROOT::EnableImplicitMT();; 42 ; 43 // Create a new RNTupleImporter object.; 44 auto importer = RNTupleImporter::Create(kTreeFileName, kTreeName, kNTupleFileName);; 45 ; 46 // Begin importing.; 47 importer->Import();; 48 ; 49 // Inspect the schema of the written RNTuple.; 50 auto file = std::unique_ptr<TFile>(TFile::Open(kNTupleFileName));; 51 if (!file || file->IsZombie()) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ntpl008__import_8C_source.html:101,Load,Loading,101,doc/master/ntpl008__import_8C_source.html,https://root.cern,https://root.cern/doc/master/ntpl008__import_8C_source.html,1,['Load'],['Loading']
Performance,. ROOT: unsigned int Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. unsigned int Class Reference. The documentation for this class was generated from the following files:. unsigned int. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:49 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classunsigned_01int.html:81,Load,Loading,81,doc/master/classunsigned_01int.html,https://root.cern,https://root.cern/doc/master/classunsigned_01int.html,1,['Load'],['Loading']
Performance,". ROOT: vec Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; vec Struct Reference. . Definition at line 1855 of file civetweb.c. Public Attributes; size_t len;  ; const char * ptr;  . Member Data Documentation. ◆ len. size_t vec::len. Definition at line 1857 of file civetweb.c. ◆ ptr. const char* vec::ptr. Definition at line 1856 of file civetweb.c. Collaboration diagram for vec:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; net/http/civetweb/civetweb.c. vec. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:49 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structvec.html:73,Load,Loading,73,doc/master/structvec.html,https://root.cern,https://root.cern/doc/master/structvec.html,1,['Load'],['Loading']
Performance,". ROOT: vec Struct Reference. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; vec Struct Reference. . Definition at line 1856 of file civetweb.c. Public Attributes; size_t len;  ; const char * ptr;  . Member Data Documentation. ◆ len. size_t vec::len. Definition at line 1858 of file civetweb.c. ◆ ptr. const char* vec::ptr. Definition at line 1857 of file civetweb.c. Collaboration diagram for vec:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; net/http/civetweb/civetweb.c. vec. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:13:25 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/structvec.html:72,Load,Loading,72,doc/v632/structvec.html,https://root.cern,https://root.cern/doc/v632/structvec.html,1,['Load'],['Loading']
Performance,. ROOT: writer Namespace Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; writer Namespace Reference. Classes; class  writer;  . writer. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespacewriter.html:79,Load,Loading,79,doc/master/namespacewriter.html,https://root.cern,https://root.cern/doc/master/namespacewriter.html,1,['Load'],['Loading']
Performance,". ROOT: xRooProjectedPdf Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Protected Member Functions |; List of all members ; xRooProjectedPdf Class Reference. . Definition at line 7144 of file xRooNode.cxx. Public Member Functions; TObject * clone (const char *newname) const override;  ; double expectedEvents (const RooArgSet *nset) const override;  Return expected number of events to be used in calculation of extended likelihood. ;  ; ExtendMode extendMode () const override;  Returns ability of PDF to provide extended likelihood terms. ;  ;  RooProjectedPdf ();  Default constructor. ;  ;  RooProjectedPdf (const char *name, const char *title, RooAbsReal &_intpdf, const RooArgSet &intObs);  Construct projection of input pdf '_intpdf' over observables 'intObs'. ;  ;  RooProjectedPdf (const RooProjectedPdf &other, const char *name=nullptr);  Copy constructor. ;  ;  Public Member Functions inherited from RooProjectedPdf;  RooProjectedPdf ();  Default constructor. ;  ;  RooProjectedPdf (const char *name, const char *title, RooAbsReal &_intpdf, const RooArgSet &intObs);  Construct projection of input pdf '_intpdf' over observables 'intObs'. ;  ;  RooProjectedPdf (const RooProjectedPdf &other, const char *name=nullptr);  Copy constructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Return analytical integral represent by appropriate element of projection cache. ;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; RooAbsPdf * createProjection (const RooArgSet &iset) override;  Special version of RooAbsReal::createProjection that deals with projections of projections. ;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  Force RooRealIntegral to relegate integration of all observables to internal logic. ;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classxRooProjectedPdf.html:85,Load,Loading,85,doc/master/classxRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classxRooProjectedPdf.html,1,['Load'],['Loading']
Performance,". ROOT::Fit::Fitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::Fitter. class ROOT::Fit::Fitter. Fitter class, entry point for performing all type of fits.; Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; The configuration of the fit (parameters, options, etc...) are specified in the; ROOT::Math::FitConfig class. @ingroup FitMain. Function Members (Methods); public:. ~Fitter(); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolFit(const ROOT::Fit::BinData& data); boolFit(const ROOT::Fit::UnBinData& data); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0); boolFitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0); ROOT::Fit::FitterFitter(); ROOT::Math::IMultiGenFunction*GetFCN(); ROOT::Math::Minimizer*GetMinimizer(); boolIsBinFit() const; boolLikelihoodFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::UnBinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolLinearFit(const ROOT::Fit::BinData& data); const ROOT::Fit::FitResult&Result() const; voidSetFunction(const ROOT::Fit::Fitter::IMod",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Fit__Fitter.html:304,perform,performing,304,root/html526/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html526/ROOT__Fit__Fitter.html,2,['perform'],"['performed', 'performing']"
Performance,". ROOT::Fit::Fitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::Fitter. class ROOT::Fit::Fitter. Fitter class, entry point for performing all type of fits.; Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; The configuration of the fit (parameters, options, etc...) are specified in the; ROOT::Math::FitConfig class. @ingroup FitMain. Function Members (Methods); public:. ~Fitter(); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolFit(const ROOT::Fit::BinData& data); boolFit(const ROOT::Fit::UnBinData& data); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); ROOT::Fit::FitterFitter(); ROOT::Math::IMultiGenFunction*GetFCN() const; ROOT::Math::Minimizer*GetMinimizer() const; boolIsBinFit() const; boolLikelihoodFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::UnBinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__Fitter.html:304,perform,performing,304,root/html528/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__Fitter.html,2,['perform'],"['performed', 'performing']"
Performance,". ROOT::Fit::Fitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::Fitter. class ROOT::Fit::Fitter. Fitter class, entry point for performing all type of fits.; Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; The configuration of the fit (parameters, options, etc...) are specified in the; ROOT::Math::FitConfig class.; After fitting the config of the fit will be modified to have the new values the resulting; parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; initial parameters by calling FitConfig.SetUpdateAfterFit(false);. @ingroup FitMain. Function Members (Methods); public:. ~Fitter(); boolApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolEvalFCN(); boolFit(const ROOT::Fit::BinData& data); boolFit(const ROOT::Fit::UnBinData& data, bool useWeight = false); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(ROOT::Fit::Fitter::MinuitFCN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Fit__Fitter.html:306,perform,performing,306,root/html530/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html530/ROOT__Fit__Fitter.html,2,['perform'],"['performed', 'performing']"
Performance,". ROOT::Fit::Fitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::Fitter. class ROOT::Fit::Fitter. Fitter class, entry point for performing all type of fits.; Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; The configuration of the fit (parameters, options, etc...) are specified in the; ROOT::Math::FitConfig class.; After fitting the config of the fit will be modified to have the new values the resulting; parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; initial parameters by calling FitConfig.SetUpdateAfterFit(false);. @ingroup FitMain. Function Members (Methods); public:. ~Fitter(); boolApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolEvalFCN(); boolFit(const ROOT::Fit::BinData& data); boolFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Fit__Fitter.html:306,perform,performing,306,root/html532/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html,4,['perform'],"['performed', 'performing']"
Performance,". ROOT::Fit::Fitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::Fitter. class ROOT::Fit::Fitter. Fitter class, entry point for performing all type of fits.; Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; The configuration of the fit (parameters, options, etc...) are specified in the; ROOT::Math::FitConfig class.; After fitting the config of the fit will be modified to have the new values the resulting; parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; initial parameters by calling FitConfig.SetUpdateAfterFit(false);. @ingroup FitMain. Function Members (Methods); public:. ~Fitter(); boolApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolEvalFCN(); boolFit(const ROOT::Fit::BinData& data); boolFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); ROOT::Fit::FitterFitter(); ROOT::Math::IMultiGenFunction*GetFCN() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Fit__Fitter.html:306,perform,performing,306,root/html602/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html602/ROOT__Fit__Fitter.html,2,['perform'],"['performed', 'performing']"
Performance,". ROOT::Fit::Fitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::Fitter. class ROOT::Fit::Fitter. Fitter class, entry point for performing all type of fits.; Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; The configuration of the fit (parameters, options, etc...) are specified in the; ROOT::Math::FitConfig class.; After fitting the config of the fit will be modified to have the new values the resulting; parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; initial parameters by calling FitConfig.SetUpdateAfterFit(false);. @ingroup FitMain. Function Members (Methods); public:. ~Fitter(); boolApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolEvalFCN(); boolFit(const ROOT::Fit::BinData& data); boolFit(const shared_ptr<ROOT::Fit::BinData>& data); boolFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); ROOT::Fit::Fit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Fit__Fitter.html:306,perform,performing,306,root/html604/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html604/ROOT__Fit__Fitter.html,2,['perform'],"['performed', 'performing']"
Performance,". ROOT::Math::BrentMinimizer1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::BrentMinimizer1D. class ROOT::Math::BrentMinimizer1D: private ROOT::Math::IMinimizer1D. User class for performing function minimization. It will use the Brent Method for function minimization in a given interval.; First, a grid search is used to bracket the minimum value; with the a step size = (xmax-xmin)/npx. The step size; can be controlled via the SetNpx() function. A default value of npx = 100 is used.; The default value con be changed using the static method SetDefaultNpx.; If the function is unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval.; If the Brent method fails to converge the bracketing is repeted on the latest best estimate of the; interval. The procedure is repeted with a maximum value (default =10) which can be set for all; BrentRootFinder classes with the method SetDefaultNSearch. This class is implemented from TF1::GetMinimum. To use the class, three steps have to be taken:; 1. Create the class.; 2. Set a function within an interval to look for the minimum.; 3. Call the Minimize function with the error parameters. If another minimization is to be performed, repeat the last two steps. @ingroup Min1D. Function Members (Methods); public:. virtual~BrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(const ROOT::Math::BrentMinimizer1D&); virtual doubleFValLower() const; virtual doubleFValMinimum() const; virtual doubleFValUpper() const; virtual intIterations() const; virtual boolMinimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); virtual const char*Name() const; static voidSetDefaultNpx(int npx); static void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__BrentMinimizer1D.html:356,perform,performing,356,root/html528/ROOT__Math__BrentMinimizer1D.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__BrentMinimizer1D.html,1,['perform'],['performing']
Performance,". ROOT::Math::BrentMinimizer1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::BrentMinimizer1D. class ROOT::Math::BrentMinimizer1D: private ROOT::Math::IMinimizer1D. User class for performing function minimization. It will use the Brent Method for function minimization in a given interval.; This class is implemented from TF1::GetMinimum. To use the class, three steps have to be taken:; 1. Create the class.; 2. Set a function within an interval to look for the minimum.; 3. Call the Minimize function with the error parameters. If another minimization is to be performed, repeat the last two steps. @ingroup Min1D. Function Members (Methods); public:. virtual~BrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(const ROOT::Math::BrentMinimizer1D&); virtual doubleFValLower() const; virtual doubleFValMinimum() const; virtual doubleFValUpper() const; virtual intIterations() const; virtual intMinimize(int maxIter, double absTol, double relTol); virtual const char*Name() const; intSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); virtual doubleXLower() const; virtual doubleXMinimum() const; virtual doubleXUpper() const. Data Members; protected:. const ROOT::Math::IGenFunction*fFunctionPointer to the function.; intfNIterNumber of iterations needed for the last stimation.; doublefXMaxUpper bound of the search interval; doublefXMinLower bound of the search interval.; doublefXMinimumPosition of the stimated minimum. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BrentMinimizer1D(); Default Constructor. . virtual ~BrentMinimizer1D(); Default Destructor. . double XMinimum() const; Return current estimate of the position of the minimum. . double XLower() const; Return current lower bound",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__BrentMinimizer1D.html:356,perform,performing,356,root/html526/ROOT__Math__BrentMinimizer1D.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__BrentMinimizer1D.html,2,['perform'],"['performed', 'performing']"
Performance,". ROOT::Math::BrentMinimizer1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::BrentMinimizer1D. class ROOT::Math::BrentMinimizer1D: private ROOT::Math::IMinimizer1D. User class for performing function minimization. It will use the Brent Method for function minimization in a given interval.; First, a grid search is used to bracket the minimum value; with the a step size = (xmax-xmin)/npx. The step size; can be controlled via the SetNpx() function. A default value of npx = 100 is used.; The default value con be changed using the static method SetDefaultNpx.; If the function is unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval.; If the Brent method fails to converge the bracketing is repeted on the latest best estimate of the; interval. The procedure is repeted with a maximum value (default =10) which can be set for all; BrentRootFinder classes with the method SetDefaultNSearch. This class is implemented from TF1::GetMinimum. To use the class, three steps have to be taken:; 1. Create the class.; 2. Set a function within an interval to look for the minimum.; 3. Call the Minimize function with the error parameters. If another minimization is to be performed, repeat the last two steps. @ingroup Min1D. Function Members (Methods); public:. virtual~BrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(const ROOT::Math::BrentMinimizer1D&); virtual doubleFValLower() const; virtual doubleFValMinimum() const; virtual doubleFValUpper() const; virtual intIterations() const; virtual boolMinimize(int maxIter, double absTol = 1.0E-8, double relTol = 1.0E-10); virtual const char*Name() const; ROOT::Math::BrentMinimizer1D&operator=(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__BrentMinimizer1D.html:358,perform,performing,358,root/html602/ROOT__Math__BrentMinimizer1D.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__BrentMinimizer1D.html,2,['perform'],['performing']
Performance,". ROOT::Math::BrentMinimizer1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::BrentMinimizer1D. class ROOT::Math::BrentMinimizer1D: private ROOT::Math::IMinimizer1D. User class for performing function minimization. It will use the Brent Method for function minimization in a given interval.; First, a grid search is used to bracket the minimum value; with the a step size = (xmax-xmin)/npx. The step size; can be controlled via the SetNpx() function. A default value of npx = 100 is used.; The default value con be changed using the static method SetDefaultNpx.; If the function is unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval.; If the Brent method fails to converge the bracketing is repeted on the latest best estimate of the; interval. The procedure is repeted with a maximum value (default =10) which can be set for all; BrentRootFinder classes with the method SetDefaultNSearch. This class is implemented from TF1::GetMinimum. To use the class, three steps have to be taken:; 1. Create the class.; 2. Set a function within an interval to look for the minimum.; 3. Call the Minimize function with the error parameters. If another minimization is to be performed, repeat the last two steps. @ingroup Min1D. Function Members (Methods); public:. virtual~BrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(const ROOT::Math::BrentMinimizer1D&); virtual doubleFValLower() const; virtual doubleFValMinimum() const; virtual doubleFValUpper() const; virtual intIterations() const; virtual boolMinimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); virtual const char*Name() const; static voidSetDefaultNpx(int npx); static vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__BrentMinimizer1D.html:358,perform,performing,358,root/html530/ROOT__Math__BrentMinimizer1D.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__BrentMinimizer1D.html,3,['perform'],['performing']
Performance,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__GSLIntegrator.html:352,perform,performing,352,root/html526/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__GSLIntegrator.html,1,['perform'],['performing']
Performance,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); RO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__GSLIntegrator.html:352,perform,performing,352,root/html528/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__GSLIntegrator.html,1,['perform'],['performing']
Performance,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.0000000000000001E-9, double relTol = 9.999999999",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__GSLIntegrator.html:354,perform,performing,354,root/html602/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__GSLIntegrator.html,2,['perform'],['performing']
Performance,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__GSLIntegrator.html:354,perform,performing,354,root/html530/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLIntegrator.html,3,['perform'],['performing']
Performance,". ROOT::Math::GSLMCIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLMCIntegrator. class ROOT::Math::GSLMCIntegrator: public ROOT::Math::VirtualIntegratorMultiDim. Class for performing numerical integration of a multidimensional function.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be; instantiate using the plugin manager (plugin name is ""GSLMCIntegrator""). @ingroup MCIntegration. Function Members (Methods); public:. virtual~GSLMCIntegrator(); doubleChiSqr(); virtual doubleError() const; ROOT::Math::GSLMCIntegratorGSLMCIntegrator(ROOT::Math::IntegrationMultiDim::Type type = MCIntegration::kVEGAS, double absTol = 1.E-6, double relTol = 1E-4, unsigned int calls = 500000); ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); virtual doubleIntegral(const double* a, const double* b); doubleIntegral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, void* p = 0); voidSetGenerator(ROOT::Math::GSLRngWrapper* r); voidSetMode(ROOT::Math::MCIntegration::Mode mode); voidSetParameters(const ROOT::Math::VegasParameters& p); voidSetParameters(const ROOT::Math::M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__GSLMCIntegrator.html:360,perform,performing,360,root/html526/ROOT__Math__GSLMCIntegrator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__GSLMCIntegrator.html,1,['perform'],['performing']
Performance,". ROOT::Math::GSLMCIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLMCIntegrator. class ROOT::Math::GSLMCIntegrator: public ROOT::Math::VirtualIntegratorMultiDim. Class for performing numerical integration of a multidimensional function.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be; instantiate using the plugin manager (plugin name is ""GSLMCIntegrator""). @ingroup MCIntegration. Function Members (Methods); public:. virtual~GSLMCIntegrator(); doubleChiSqr(); virtual doubleError() const; ROOT::Math::IOptions*ExtraOptions() const; ROOT::Math::IntegrationMultiDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLMCIntegratorGSLMCIntegrator(ROOT::Math::IntegrationMultiDim::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0); ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); virtual doubleIntegral(const double* a, const double* b); doubleIntegral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); virtual intNEval() const; virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__GSLMCIntegrator.html:360,perform,performing,360,root/html528/ROOT__Math__GSLMCIntegrator.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__GSLMCIntegrator.html,1,['perform'],['performing']
Performance,". ROOT::Math::GSLMCIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLMCIntegrator. class ROOT::Math::GSLMCIntegrator: public ROOT::Math::VirtualIntegratorMultiDim. Class for performing numerical integration of a multidimensional function.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be; instantiate using the plugin manager (plugin name is ""GSLMCIntegrator""). @ingroup MCIntegration. Function Members (Methods); public:. virtual~GSLMCIntegrator(); doubleChiSqr(); virtual doubleError() const; ROOT::Math::IOptions*ExtraOptions() const; ROOT::Math::IntegrationMultiDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLMCIntegratorGSLMCIntegrator(ROOT::Math::IntegrationMultiDim::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0); ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); virtual doubleIntegral(const double* a, const double* b); doubleIntegral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); virtual intNEval() const; virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__GSLMCIntegrator.html:362,perform,performing,362,root/html530/ROOT__Math__GSLMCIntegrator.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLMCIntegrator.html,3,['perform'],['performing']
Performance,". ROOT::Math::GSLMCIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLMCIntegrator. class ROOT::Math::GSLMCIntegrator: public ROOT::Math::VirtualIntegratorMultiDim. Class for performing numerical integration of a multidimensional function.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be; instantiate using the plugin manager (plugin name is ""GSLMCIntegrator""). @ingroup MCIntegration. Function Members (Methods); public:. virtual~GSLMCIntegrator(); doubleChiSqr(); virtual doubleError() const; ROOT::Math::IOptions*ExtraOptions() const; ROOT::Math::MCIntegration::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLMCIntegratorGSLMCIntegrator(ROOT::Math::MCIntegration::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0); ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); virtual doubleIntegral(const double* a, const double* b); doubleIntegral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); virtual intNEval() const; virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, void* p = 0)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__GSLMCIntegrator.html:362,perform,performing,362,root/html602/ROOT__Math__GSLMCIntegrator.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__GSLMCIntegrator.html,2,['perform'],['performing']
Performance,". ROOT::Math::GaussIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(); ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&, bool copy = false); virtual voidSetRelTolerance(double); virtual intStatus() const. Data Members; protected:. doublefEpsilonRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; boolfFunctionCopiedBool value to check if the function was copied when set.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool value to check if the function was at least called once.; static boolfgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~GaussIntegrator(); Destructor. Deletes the function if it was previously copied. . Gau",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__GaussIntegrator.html:363,perform,performing,363,root/html526/ROOT__Math__GaussIntegrator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__GaussIntegrator.html,1,['perform'],['performing']
Performance,". ROOT::Math::GaussIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsilonRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool value",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__GaussIntegrator.html:363,perform,performing,363,root/html528/ROOT__Math__GaussIntegrator.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__GaussIntegrator.html,1,['perform'],['performing']
Performance,". ROOT::Math::GaussIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussIntegratorGaussIntegrator(double absTol = 0, double relTol = 0); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::GaussIntegrator&operator=(const ROOT::Math::GaussIntegrator&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double eps); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double eps); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const; ROOT::Math::VirtualIntegratorROOT::Math::VirtualIntegrator::VirtualIntegrator(); ROOT::Math::VirtualIntegratorROOT::Math::VirtualIntegrator::VirtualIntegrator(const ROOT::Math::VirtualIntegrator&); ROOT::Math::VirtualIntegratorOneDimROOT::Math::VirtualIntegratorOneDim::VirtualIntegratorOneDim(); ROOT::Math::VirtualIntegratorOneDimROOT::Math::VirtualIntegratorOneDim:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__GaussIntegrator.html:365,perform,performing,365,root/html602/ROOT__Math__GaussIntegrator.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__GaussIntegrator.html,2,['perform'],['performing']
Performance,". ROOT::Math::GaussIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussIntegratorGaussIntegrator(double absTol = 0, double relTol = 0); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double eps); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double eps); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsAbsAbsolute error.; doublefEpsRelRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultRes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:365,perform,performing,365,root/html534/ROOT__Math__GaussIntegrator.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html,1,['perform'],['performing']
Performance,". ROOT::Math::GaussIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsilonRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool val",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__GaussIntegrator.html:365,perform,performing,365,root/html530/ROOT__Math__GaussIntegrator.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__GaussIntegrator.html,2,['perform'],['performing']
Performance,". ROOT::Math::GaussLegendreIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::GaussLegendreIntegrator. class ROOT::Math::GaussLegendreIntegrator: public ROOT::Math::GaussIntegrator. User class for performing function integration. It will use the Gauss-Legendre Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidROOT::Math::GaussI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__GaussLegendreIntegrator.html:379,perform,performing,379,root/html528/ROOT__Math__GaussLegendreIntegrator.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__GaussLegendreIntegrator.html,1,['perform'],['performing']
Performance,". ROOT::Math::GaussLegendreIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::GaussLegendreIntegrator. class ROOT::Math::GaussLegendreIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss-Legendre Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussLegendreIntegrator(); virtual doubleError() const; ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); voidGetWeightVectors(double* x, double* w); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&, bool copy = false); voidSetNumberPoints(int num); virtual voidSetRelTolerance(double); virtual intStatus() const. private:. voidCalcGaussLegendreSamplingPoints(). Data Members; protected:. doublefEpsilonDesired relative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; boolfFunctionCopiedBool value to check if the function was copied when set.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; intfNumNumber of points used in the stimation of the integral.; boolfUsedOnceBool value to check if the fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__GaussLegendreIntegrator.html:387,perform,performing,387,root/html526/ROOT__Math__GaussLegendreIntegrator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__GaussLegendreIntegrator.html,1,['perform'],['performing']
Performance,". ROOT::Math::GaussLegendreIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::GaussLegendreIntegrator. class ROOT::Math::GaussLegendreIntegrator: public ROOT::Math::GaussIntegrator. User class for performing function integration. It will use the Gauss-Legendre Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double absTol = 0, double relTol = 0); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidRO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html:381,perform,performing,381,root/html534/ROOT__Math__GaussLegendreIntegrator.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html,1,['perform'],['performing']
Performance,". ROOT::Math::GaussLegendreIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::GaussLegendreIntegrator. class ROOT::Math::GaussLegendreIntegrator: public ROOT::Math::GaussIntegrator. User class for performing function integration. It will use the Gauss-Legendre Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double absTol = 0, double relTol = 0); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 9.9999999999999998E-13); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::GaussLegendreIntegrator&operator=(const ROOT::Math::GaussLegendreIntegrator&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidROOT::Math::GaussInteg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__GaussLegendreIntegrator.html:381,perform,performing,381,root/html602/ROOT__Math__GaussLegendreIntegrator.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__GaussLegendreIntegrator.html,2,['perform'],['performing']
Performance,". ROOT::Math::GaussLegendreIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::GaussLegendreIntegrator. class ROOT::Math::GaussLegendreIntegrator: public ROOT::Math::GaussIntegrator. User class for performing function integration. It will use the Gauss-Legendre Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidROOT::Math::Gaus",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__GaussLegendreIntegrator.html:381,perform,performing,381,root/html530/ROOT__Math__GaussLegendreIntegrator.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__GaussLegendreIntegrator.html,2,['perform'],['performing']
Performance,". ROOT::Math::IntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IntegratorMultiDim. class ROOT::Math::IntegratorMultiDim. User class for performing multidimensional integration. By default uses adaptive multi-dimensional integration using the algorithm from Genz Mallik; implemented in the class ROOT::Math::AdaptiveIntegratorMultiDim otherwise it can uses via the; plug-in manager the MC integration class (ROOT::Math::GSLMCIntegration) from MathMore. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorMultiDim(); doubleError() const; ROOT::Math::VirtualIntegratorMultiDim*GetIntegrator(); doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000); doubleResult() const; voidSetAbsTolerance(double absTol); voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IntegratorMultiDim&); ROOT::Math::IntegratorMultiDim&operator=(const ROOT::Math::IntegratorMultiDim&). Data Members; private:. ROOT::Math::VirtualIntegratorMultiDim*fIntegratorpointer to mu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IntegratorMultiDim.html:328,perform,performing,328,root/html526/ROOT__Math__IntegratorMultiDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IntegratorMultiDim.html,1,['perform'],['performing']
Performance,". ROOT::Math::IntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IntegratorMultiDim. class ROOT::Math::IntegratorMultiDim. User class for performing multidimensional integration. By default uses adaptive multi-dimensional integration using the algorithm from Genz Mallik; implemented in the class ROOT::Math::AdaptiveIntegratorMultiDim otherwise it can uses via the; plug-in manager the MC integration class (ROOT::Math::GSLMCIntegration) from MathMore. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorMultiDim(); doubleError() const; ROOT::Math::VirtualIntegratorMultiDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationMultiDim::Type); static ROOT::Math::IntegrationMultiDim::TypeGetType(const char* name); doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); stringName() const; ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleResult() const; voidSetAbsTolerance(double absTol); voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Math",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorMultiDim.html:328,perform,performing,328,root/html528/ROOT__Math__IntegratorMultiDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorMultiDim.html,1,['perform'],['performing']
Performance,". ROOT::Math::IntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IntegratorMultiDim. class ROOT::Math::IntegratorMultiDim. User class for performing multidimensional integration. By default uses adaptive multi-dimensional integration using the algorithm from Genz Mallik; implemented in the class ROOT::Math::AdaptiveIntegratorMultiDim otherwise it can uses via the; plug-in manager the MC integration class (ROOT::Math::GSLMCIntegration) from MathMore. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorMultiDim(); doubleError() const; ROOT::Math::VirtualIntegratorMultiDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationMultiDim::Type); static ROOT::Math::IntegrationMultiDim::TypeGetType(const char* name); doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); stringName() const; ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleResult() const; voidSetAbsTolerance(double absTol); voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__IntegratorMultiDim.html:330,perform,performing,330,root/html530/ROOT__Math__IntegratorMultiDim.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__IntegratorMultiDim.html,5,['perform'],['performing']
Performance,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); doubleI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IntegratorOneDim.html:322,perform,performing,322,root/html526/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IntegratorOneDim.html,2,"['load', 'perform']","['load', 'performing']"
Performance,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Math",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html:322,perform,performing,322,root/html528/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html,2,"['load', 'perform']","['load', 'performing']"
Performance,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Math::IntegrationOneDim::TypeGetType(const char* name); doubleIntegral(); doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IntegratorOneDim.html:324,perform,performing,324,root/html602/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IntegratorOneDim.html,4,"['load', 'perform']","['load', 'performing']"
Performance,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__IntegratorOneDim.html:324,perform,performing,324,root/html530/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__IntegratorOneDim.html,6,"['load', 'perform']","['load', 'performing']"
Performance,". ROOT::Math::Interpolator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Interpolator. class ROOT::Math::Interpolator. Class for performing function interpolation of points.; The class is instantiated with an interpolation methods, passed as an enumeration in the constructor.; See Interpolation::Type for the available interpolation algorithms, which are implemented using GSL.; See also the <A HREF=http://www.gnu.org/software/gsl/manual/html_node/Interpolation.html"">GSL manual</A> for more information.; The class provides additional methods for computing derivatives and integrals of interpolating functions. This class does not support copying.; @ingroup Interpolation. Function Members (Methods); public:. virtual~Interpolator(); doubleDeriv(double x) const; doubleDeriv2(double x) const; doubleEval(double x) const; doubleInteg(double a, double b) const; ROOT::Math::InterpolatorInterpolator(unsigned int ndata = 0, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE); ROOT::Math::InterpolatorInterpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE); boolSetData(const vector<double>& x, const vector<double>& y); boolSetData(unsigned int ndata, const double* x, const double* y); stringType() const; stringTypeGet() const. private:. ROOT::Math::InterpolatorInterpolator(const ROOT::Math::Interpolator&); ROOT::Math::Interpolator&operator=(const ROOT::Math::Interpolator&). Data Members; private:. ROOT::Math::GSLInterpolator*fInterppointer to GSL interpolator class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Interpolator(unsigned int ndata = 0, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from number of data points and with Inter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__Interpolator.html:305,perform,performing,305,root/html526/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__Interpolator.html,2,['perform'],['performing']
Performance,". ROOT::Math::Interpolator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Interpolator. class ROOT::Math::Interpolator. Class for performing function interpolation of points.; The class is instantiated with an interpolation methods, passed as an enumeration in the constructor.; See Interpolation::Type for the available interpolation algorithms, which are implemented using GSL.; See also the <A HREF=http://www.gnu.org/software/gsl/manual/html_node/Interpolation.html"">GSL manual</A> for more information.; The class provides additional methods for computing derivatives and integrals of interpolating functions. This class does not support copying.; @ingroup Interpolation. Function Members (Methods); public:. virtual~Interpolator(); doubleDeriv(double x) const; doubleDeriv2(double x) const; doubleEval(double x) const; doubleInteg(double a, double b) const; ROOT::Math::InterpolatorInterpolator(unsigned int ndata = 0, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE); ROOT::Math::InterpolatorInterpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE); boolSetData(const vector<double>& x, const vector<double>& y); boolSetData(unsigned int ndata, const double* x, const double* y); stringType() const; stringTypeGet() const. private:. ROOT::Math::InterpolatorInterpolator(const ROOT::Math::Interpolator&); ROOT::Math::Interpolator&operator=(const ROOT::Math::Interpolator&). Data Members; private:. ROOT::Math::GSLInterpolator*fInterppointer to GSL interpolator class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Interpolator(unsigned int ndata = 0, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from number of data points and with Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__Interpolator.html:307,perform,performing,307,root/html530/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__Interpolator.html,5,['perform'],['performing']
Performance,. ROOT::Math::MathMoreLibrary. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::MathMoreLibrary. class ROOT::Math::MathMoreLibrary. Function Members (Methods); public:. ~MathMoreLibrary(); static voidLoad(); ROOT::Math::MathMoreLibraryMathMoreLibrary(); ROOT::Math::MathMoreLibraryMathMoreLibrary(const ROOT::Math::MathMoreLibrary&); ROOT::Math::MathMoreLibraryMathMoreLibrary(ROOT::Math::MathMoreLibrary&&); ROOT::Math::MathMoreLibrary&operator=(const ROOT::Math::MathMoreLibrary&); ROOT::Math::MathMoreLibrary&operator=(ROOT::Math::MathMoreLibrary&&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Load(); adding this method with force the auto-loading of the library. » Last changed: root/mathmore:$Id$ » Last generated: 2015-06-30 14:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__MathMoreLibrary.html:824,Load,Load,824,root/html602/ROOT__Math__MathMoreLibrary.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__MathMoreLibrary.html,2,"['Load', 'load']","['Load', 'loading']"
Performance,. ROOT::Math::MathMoreLibrary. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::MathMoreLibrary. class ROOT::Math::MathMoreLibrary. Function Members (Methods); public:. ~MathMoreLibrary(); static voidLoad(); ROOT::Math::MathMoreLibraryMathMoreLibrary(); ROOT::Math::MathMoreLibraryMathMoreLibrary(const ROOT::Math::MathMoreLibrary&); ROOT::Math::MathMoreLibraryMathMoreLibrary(ROOT::Math::MathMoreLibrary&&); ROOT::Math::MathMoreLibrary&operator=(const ROOT::Math::MathMoreLibrary&); ROOT::Math::MathMoreLibrary&operator=(ROOT::Math::MathMoreLibrary&&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Load(); adding this method with force the auto-loading of the library. » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__MathMoreLibrary.html:824,Load,Load,824,root/html604/ROOT__Math__MathMoreLibrary.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__MathMoreLibrary.html,2,"['Load', 'load']","['Load', 'loading']"
Performance,". ROOT::Math::RootFinder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::RootFinder. class ROOT::Math::RootFinder. User Class to find the Root of one dimensional functions.; The GSL Methods are implemented in MathMore and they are loaded automatically; via the plug-in manager. The possible types of Root-finding algorithms are:; <ul>; <li>Root Bracketing Algorithms which do not require function derivatives; <ol>; <li>RootFinder::kBRENT (default method implemented in MathCore); <li>RootFinder::kGSL_BISECTION; <li>RootFinder::kGSL_FALSE_POS; <li>RootFinder::kGSL_BRENT; </ol>; <li>Root Finding Algorithms using Derivatives; <ol>; <li>RootFinder::kGSL_NEWTON; <li>RootFinder::kGSL_SECANT; <li>RootFinder::kGSL_STEFFENSON; </ol>; </ul>. This class does not cupport copying. @ingroup RootFinders. Function Members (Methods); public:. virtual~RootFinder(); intIterate(); intIterations() const; const char*Name() const; doubleRoot() const; ROOT::Math::RootFinderRootFinder(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT); boolSetFunction(const ROOT::Math::IGradFunction& f, double xstart); boolSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); boolSetMethod(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT); boolSolve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); intStatus() const. private:. ROOT::Math::RootFinder&operator=(const ROOT::Math::RootFinder& rhs); ROOT::Math::RootFinderRootFinder(const ROOT::Math::RootFinder&). Data Members; public:. enum EType { kBRENT; kGSL_BISECTION; kGSL_FALSE_POS; kGSL_BRENT; kGSL_NEWTON; kGSL_SECANT; kGSL_STEFFENSON; };. private:. ROOT::Math::IRootFinderMethod*fSolvertype of algorithm to be used . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool Solve(Function &f, Derivative &d, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__RootFinder.html:405,load,loaded,405,root/html528/ROOT__Math__RootFinder.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__RootFinder.html,1,['load'],['loaded']
Performance,". ROOT::Math::RootFinder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::RootFinder. class ROOT::Math::RootFinder. User Class to find the Root of one dimensional functions.; The GSL Methods are implemented in MathMore and they are loaded automatically; via the plug-in manager. The possible types of Root-finding algorithms are:; <ul>; <li>Root Bracketing Algorithms which do not require function derivatives; <ol>; <li>RootFinder::kBRENT (default method implemented in MathCore); <li>RootFinder::kGSL_BISECTION; <li>RootFinder::kGSL_FALSE_POS; <li>RootFinder::kGSL_BRENT; </ol>; <li>Root Finding Algorithms using Derivatives; <ol>; <li>RootFinder::kGSL_NEWTON; <li>RootFinder::kGSL_SECANT; <li>RootFinder::kGSL_STEFFENSON; </ol>; </ul>. This class does not cupport copying. @ingroup RootFinders. Function Members (Methods); public:. virtual~RootFinder(); intIterate(); intIterations() const; const char*Name() const; doubleRoot() const; ROOT::Math::RootFinderRootFinder(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT); boolSetFunction(const ROOT::Math::IGradFunction& f, double xstart); boolSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); boolSetMethod(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT); boolSolve(int maxIter = 100, double absTol = 1.0E-8, double relTol = 1.0E-10); boolSolve<int, double>(int& f, double& d, double start, int maxIter = 100, double absTol = 1.0E-8, double relTol = 1.0E-10); boolSolve<int>(int& f, double min, double max, int maxIter = 100, double absTol = 1.0E-8, double relTol = 1.0E-10); intStatus() const. private:. ROOT::Math::RootFinder&operator=(const ROOT::Math::RootFinder& rhs); ROOT::Math::RootFinderRootFinder(const ROOT::Math::RootFinder&). Data Members; public:. static ROOT::Math::RootFinder::ETypekBRENT; static ROOT::Math::RootFinder",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__RootFinder.html:407,load,loaded,407,root/html602/ROOT__Math__RootFinder.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__RootFinder.html,2,['load'],['loaded']
Performance,". ROOT::Math::RootFinder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::RootFinder. class ROOT::Math::RootFinder. User Class to find the Root of one dimensional functions.; The GSL Methods are implemented in MathMore and they are loaded automatically; via the plug-in manager. The possible types of Root-finding algorithms are:; <ul>; <li>Root Bracketing Algorithms which do not require function derivatives; <ol>; <li>RootFinder::kBRENT (default method implemented in MathCore); <li>RootFinder::kGSL_BISECTION; <li>RootFinder::kGSL_FALSE_POS; <li>RootFinder::kGSL_BRENT; </ol>; <li>Root Finding Algorithms using Derivatives; <ol>; <li>RootFinder::kGSL_NEWTON; <li>RootFinder::kGSL_SECANT; <li>RootFinder::kGSL_STEFFENSON; </ol>; </ul>. This class does not cupport copying. @ingroup RootFinders. Function Members (Methods); public:. virtual~RootFinder(); intIterate(); intIterations() const; const char*Name() const; doubleRoot() const; ROOT::Math::RootFinderRootFinder(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT); boolSetFunction(const ROOT::Math::IGradFunction& f, double xstart); boolSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); boolSetMethod(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT); boolSolve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); intStatus() const. private:. ROOT::Math::RootFinder&operator=(const ROOT::Math::RootFinder& rhs); ROOT::Math::RootFinderRootFinder(const ROOT::Math::RootFinder&). Data Members; public:. enum EType { kBRENT; kGSL_BISECTION; kGSL_FALSE_POS; kGSL_BRENT; kGSL_NEWTON; kGSL_SECANT; kGSL_STEFFENSON; };. private:. ROOT::Math::IRootFinderMethod*fSolvertype of algorithm to be used . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool Solve(Function &f, Derivative &d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__RootFinder.html:407,load,loaded,407,root/html530/ROOT__Math__RootFinder.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__RootFinder.html,3,['load'],['loaded']
Performance,". ROOT::Math::Translation3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::Translation3D. class ROOT::Math::Translation3D. Class describing a 3 dimensional translation. It can be combined (using the operator *); with the ROOT::Math::Rotation3D classes and ROOT::Math::Transform3D to obtained combined; transformations and to operate on points and vectors.; Note that a the translation applied to a Vector object (DisplacementVector3D and LorentzVector classes); performes a noop, i.e. it returns the same vector. A translation can be applied only to the Point objects; (PositionVector3D classes). @ingroup GenVector. Function Members (Methods); public:. ~Translation3D(); voidGetComponents(double& dx, double& dy, double& dz) const; ROOT::Math::Translation3DInverse() const; voidInvert(); booloperator!=(const ROOT::Math::Translation3D& rhs) const; ROOT::Math::Plane3Doperator()(const ROOT::Math::Plane3D& plane) const; ROOT::Math::Translation3Doperator*(const ROOT::Math::Translation3D& t) const; ROOT::Math::Translation3D&operator*=(const ROOT::Math::Translation3D& t); ROOT::Math::Translation3D&operator=(const ROOT::Math::Translation3D&); booloperator==(const ROOT::Math::Translation3D& rhs) const; voidSetComponents(double dx, double dy, double dz); voidSetXYZ(double dx, double dy, double dz); ROOT::Math::Translation3DTranslation3D(); ROOT::Math::Translation3DTranslation3D(const ROOT::Math::Translation3D&); ROOT::Math::Translation3DTranslation3D(double dx, double dy, double dz); const ROOT::Math::Translation3D::Vector&Vect() const. Data Members; private:. ROOT::Math::Translation3D::VectorfVectinternal 3D vector representing the translation . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Translation3D(). Default constructor ( zero translation ). {}. Translation3D(IT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__Translation3D.html:638,perform,performes,638,root/html526/ROOT__Math__Translation3D.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__Translation3D.html,2,['perform'],['performes']
Performance,". ROOT::Math::Translation3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::Translation3D. class ROOT::Math::Translation3D. Class describing a 3 dimensional translation. It can be combined (using the operator *); with the ROOT::Math::Rotation3D classes and ROOT::Math::Transform3D to obtained combined; transformations and to operate on points and vectors.; Note that a the translation applied to a Vector object (DisplacementVector3D and LorentzVector classes); performes a noop, i.e. it returns the same vector. A translation can be applied only to the Point objects; (PositionVector3D classes). @ingroup GenVector. Function Members (Methods); public:. ~Translation3D(); voidGetComponents(double& dx, double& dy, double& dz) const; ROOT::Math::Translation3DInverse() const; voidInvert(); booloperator!=(const ROOT::Math::Translation3D& rhs) const; ROOT::Math::Plane3Doperator()(const ROOT::Math::Plane3D& plane) const; ROOT::Math::Translation3Doperator*(const ROOT::Math::Translation3D& t) const; ROOT::Math::Translation3D&operator*=(const ROOT::Math::Translation3D& t); ROOT::Math::Translation3D&operator=(const ROOT::Math::Translation3D&); ROOT::Math::Translation3D&operator=(ROOT::Math::Translation3D&&); booloperator==(const ROOT::Math::Translation3D& rhs) const; voidSetComponents(double dx, double dy, double dz); voidSetXYZ(double dx, double dy, double dz); ROOT::Math::Translation3DTranslation3D(); ROOT::Math::Translation3DTranslation3D(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v); ROOT::Math::Translation3DTranslation3D(const ROOT::Math::Translation3D&); ROOT::Math::Translation3DTranslation3D(ROOT::Math::Translation3D&&); ROOT::Math::Translation3DTranslation3D(double dx, double dy, double dz); const ROOT::Math::Translation3D::Vector&Vect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__Translation3D.html:640,perform,performes,640,root/html602/ROOT__Math__Translation3D.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__Translation3D.html,2,['perform'],['performes']
Performance,". ROOT::Math::Translation3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::Translation3D. class ROOT::Math::Translation3D. Class describing a 3 dimensional translation. It can be combined (using the operator *); with the ROOT::Math::Rotation3D classes and ROOT::Math::Transform3D to obtained combined; transformations and to operate on points and vectors.; Note that a the translation applied to a Vector object (DisplacementVector3D and LorentzVector classes); performes a noop, i.e. it returns the same vector. A translation can be applied only to the Point objects; (PositionVector3D classes). @ingroup GenVector. Function Members (Methods); public:. ~Translation3D(); voidGetComponents(double& dx, double& dy, double& dz) const; ROOT::Math::Translation3DInverse() const; voidInvert(); booloperator!=(const ROOT::Math::Translation3D& rhs) const; ROOT::Math::Plane3Doperator()(const ROOT::Math::Plane3D& plane) const; ROOT::Math::Translation3Doperator*(const ROOT::Math::Translation3D& t) const; ROOT::Math::Translation3D&operator*=(const ROOT::Math::Translation3D& t); ROOT::Math::Translation3D&operator=(const ROOT::Math::Translation3D&); booloperator==(const ROOT::Math::Translation3D& rhs) const; voidSetComponents(double dx, double dy, double dz); voidSetXYZ(double dx, double dy, double dz); ROOT::Math::Translation3DTranslation3D(); ROOT::Math::Translation3DTranslation3D(const ROOT::Math::Translation3D&); ROOT::Math::Translation3DTranslation3D(double dx, double dy, double dz); const ROOT::Math::Translation3D::Vector&Vect() const. Data Members; private:. ROOT::Math::Translation3D::VectorfVectinternal 3D vector representing the translation . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Translation3D(). Default constructor ( zero translation ). {}. Translation3D(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__Translation3D.html:640,perform,performes,640,root/html530/ROOT__Math__Translation3D.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__Translation3D.html,3,['perform'],['performes']
Performance,". ROOT::Minuit2::CombinedMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::CombinedMinimizer. class ROOT::Minuit2::CombinedMinimizer: public ROOT::Minuit2::ModularFunctionMinimizer. Combined minimizer: combination of Migrad and Simplex. I; If the Migrad method fails at first attempt, a simplex; minimization is performed and then migrad is tried again. Function Members (Methods); public:. virtual~CombinedMinimizer(); virtual const ROOT::Minuit2::MinimumBuilder&Builder() const; ROOT::Minuit2::CombinedMinimizerCombinedMinimizer(); ROOT::Minuit2::CombinedMinimizerCombinedMinimizer(const ROOT::Minuit2::CombinedMinimizer&); virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const vector<double>&, const vector<double>&, unsigned int stra = 1,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Minuit2__CombinedMinimizer.html:496,perform,performed,496,root/html526/ROOT__Minuit2__CombinedMinimizer.html,https://root.cern,https://root.cern/root/html526/ROOT__Minuit2__CombinedMinimizer.html,2,['perform'],['performed']
Performance,". ROOT::Minuit2::CombinedMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::CombinedMinimizer. class ROOT::Minuit2::CombinedMinimizer: public ROOT::Minuit2::ModularFunctionMinimizer. Combined minimizer: combination of Migrad and Simplex. I; If the Migrad method fails at first attempt, a simplex; minimization is performed and then migrad is tried again. Function Members (Methods); public:. virtual~CombinedMinimizer(); virtual const ROOT::Minuit2::MinimumBuilder&Builder() const; ROOT::Minuit2::CombinedMinimizerCombinedMinimizer(); ROOT::Minuit2::CombinedMinimizerCombinedMinimizer(const ROOT::Minuit2::CombinedMinimizer&); virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const vector<double>&, const vector<double>&, unsigned int stra = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Minuit2__CombinedMinimizer.html:498,perform,performed,498,root/html530/ROOT__Minuit2__CombinedMinimizer.html,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__CombinedMinimizer.html,2,['perform'],['performed']
Performance,". ROOT::Minuit2::CombinedMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::CombinedMinimizer. class ROOT::Minuit2::CombinedMinimizer: public ROOT::Minuit2::ModularFunctionMinimizer. Combined minimizer: combination of Migrad and Simplex. I; If the Migrad method fails at first attempt, a simplex; minimization is performed and then migrad is tried again. Function Members (Methods); public:. virtual~CombinedMinimizer(); virtual const ROOT::Minuit2::MinimumBuilder&Builder() const; virtual ROOT::Minuit2::MinimumBuilder&Builder(); ROOT::Minuit2::CombinedMinimizerCombinedMinimizer(); ROOT::Minuit2::CombinedMinimizerCombinedMinimizer(const ROOT::Minuit2::CombinedMinimizer&); ROOT::Minuit2::FunctionMinimizerROOT::Minuit2::FunctionMinimizer::FunctionMinimizer(); ROOT::Minuit2::FunctionMinimizerROOT::Minuit2::FunctionMinimizer::FunctionMinimizer(const ROOT::Minuit2::FunctionMinimizer&); virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Minuit2__CombinedMinimizer.html:498,perform,performed,498,root/html602/ROOT__Minuit2__CombinedMinimizer.html,https://root.cern,https://root.cern/root/html602/ROOT__Minuit2__CombinedMinimizer.html,2,['perform'],['performed']
Performance,". ROOT::Minuit2::CombinedMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::CombinedMinimizer. class ROOT::Minuit2::CombinedMinimizer: public ROOT::Minuit2::ModularFunctionMinimizer. Combined minimizer: combination of Migrad and Simplex. I; If the Migrad method fails at first attempt, a simplex; minimization is performed and then migrad is tried again. Function Members (Methods); public:. virtual~CombinedMinimizer(); virtual const ROOT::Minuit2::MinimumBuilder&Builder() const; virtual ROOT::Minuit2::MinimumBuilder&Builder(); ROOT::Minuit2::CombinedMinimizerCombinedMinimizer(); ROOT::Minuit2::CombinedMinimizerCombinedMinimizer(const ROOT::Minuit2::CombinedMinimizer&); virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const vector<doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Minuit2__CombinedMinimizer.html:498,perform,performed,498,root/html534/ROOT__Minuit2__CombinedMinimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Minuit2__CombinedMinimizer.html,1,['perform'],['performed']
Performance,". ROOT::TFriendProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » ROOT::TFriendProxy. class ROOT::TFriendProxy. TFriendProxy. Concrete implementation of the proxy around a Friend Tree. Function Members (Methods); public:. ~TFriendProxy(); Long64_tGetReadEntry() const; ROOT::TFriendProxy&operator=(ROOT::TFriendProxy&&); ROOT::TFriendProxy&operator=(const ROOT::TFriendProxy&); voidResetReadEntry(); ROOT::TFriendProxyTFriendProxy(); ROOT::TFriendProxyTFriendProxy(ROOT::TFriendProxy&&); ROOT::TFriendProxyTFriendProxy(const ROOT::TFriendProxy&); ROOT::TFriendProxyTFriendProxy(ROOT::TBranchProxyDirector* director, TTree* main, Int_t index); voidUpdate(TTree* newmain). Data Members; protected:. ROOT::TBranchProxyDirectorfDirectorcontain pointer to TTree and entry to be read; Int_tfIndexIndex of this tree in the list of friends. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFriendProxy(). TFriendProxy(ROOT::TBranchProxyDirector* director, TTree* main, Int_t index); Constructor. Long64_t GetReadEntry() const; Return the entry number currently being looked at. void ResetReadEntry(); Refresh the cached read entry number from the original tree. void Update(TTree* newmain); Update the address of the underlying tree. TFriendProxy(). TFriendProxy(ROOT::TBranchProxyDirector* director, TTree* main, Int_t index). » Author: Philippe Canal 01/06/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__TFriendProxy.html:1341,cache,cached,1341,root/html604/ROOT__TFriendProxy.html,https://root.cern,https://root.cern/root/html604/ROOT__TFriendProxy.html,1,['cache'],['cached']
Performance,". ROOT::TFriendProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » ROOT::TFriendProxy. class ROOT::TFriendProxy. TFriendProxy. Concrete implementation of the proxy around a Friend Tree. Function Members (Methods); public:. ~TFriendProxy(); Long64_tGetReadEntry() const; ROOT::TFriendProxy&operator=(ROOT::TFriendProxy&&); ROOT::TFriendProxy&operator=(const ROOT::TFriendProxy&); voidResetReadEntry(); ROOT::TFriendProxyTFriendProxy(); ROOT::TFriendProxyTFriendProxy(ROOT::TFriendProxy&&); ROOT::TFriendProxyTFriendProxy(const ROOT::TFriendProxy&); ROOT::TFriendProxyTFriendProxy(ROOT::TBranchProxyDirector* director, TTree* main, Int_t index); voidUpdate(TTree* newmain). Data Members; protected:. ROOT::TBranchProxyDirectorfDirectorcontain pointer to TTree and entry to be read; Int_tfIndexIndex of this tree in the list of friends. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFriendProxy(). TFriendProxy(ROOT::TBranchProxyDirector* director, TTree* main, Int_t index); Constructor. Long64_t GetReadEntry() const; Return the entry number currently being looked at. void ResetReadEntry(); Refresh the cached read entry number from the original tree. void Update(TTree* newmain); Update the address of the underlying tree. TFriendProxy(). TFriendProxy(ROOT::TBranchProxyDirector* director, TTree* main, Int_t index). » Author: Philippe Canal 01/06/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-30 14:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__TFriendProxy.html:1341,cache,cached,1341,root/html602/ROOT__TFriendProxy.html,https://root.cern,https://root.cern/root/html602/ROOT__TFriendProxy.html,1,['cache'],['cached']
Performance,". ROOT::TFriendProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » ROOT::TFriendProxy. class ROOT::TFriendProxy. TFriendProxy. Concrete implementation of the proxy around a Friend Tree. Function Members (Methods); public:. ~TFriendProxy(); Long64_tGetReadEntry() const; ROOT::TFriendProxy&operator=(const ROOT::TFriendProxy&); voidResetReadEntry(); ROOT::TFriendProxyTFriendProxy(); ROOT::TFriendProxyTFriendProxy(const ROOT::TFriendProxy&); ROOT::TFriendProxyTFriendProxy(ROOT::TBranchProxyDirector* director, TTree* main, Int_t index); voidUpdate(TTree* newmain). Data Members; protected:. ROOT::TBranchProxyDirectorfDirectorcontain pointer to TTree and entry to be read; Int_tfIndexIndex of this tree in the list of friends. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFriendProxy(). TFriendProxy(ROOT::TBranchProxyDirector* director, TTree* main, Int_t index); Constructor. Long64_t GetReadEntry() const; Return the entry number currently being looked at. void ResetReadEntry(); Refresh the cached read entry number from the original tree. void Update(TTree* newmain); Update the address of the underlying tree. TFriendProxy(). » Author: Philippe Canal 01/06/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id: TFriendProxy.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2009-12-07 13:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__TFriendProxy.html:1235,cache,cached,1235,root/html526/ROOT__TFriendProxy.html,https://root.cern,https://root.cern/root/html526/ROOT__TFriendProxy.html,1,['cache'],['cached']
Performance,". ROOT::TFriendProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » ROOT::TFriendProxy. class ROOT::TFriendProxy. TFriendProxy. Concrete implementation of the proxy around a Friend Tree. Function Members (Methods); public:. ~TFriendProxy(); Long64_tGetReadEntry() const; voidResetReadEntry(); ROOT::TFriendProxyTFriendProxy(); ROOT::TFriendProxyTFriendProxy(ROOT::TBranchProxyDirector* director, TTree* main, Int_t index); voidUpdate(TTree* newmain). Data Members; protected:. ROOT::TBranchProxyDirectorfDirectorcontain pointer to TTree and entry to be read; Int_tfIndexIndex of this tree in the list of friends. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFriendProxy(). TFriendProxy(ROOT::TBranchProxyDirector* director, TTree* main, Int_t index); Constructor. Long64_t GetReadEntry() const; Return the entry number currently being looked at. void ResetReadEntry(); Refresh the cached read entry number from the original tree. void Update(TTree* newmain); Update the address of the underlying tree. » Author: Philippe Canal 01/06/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__TFriendProxy.html:1119,cache,cached,1119,root/html534/ROOT__TFriendProxy.html,https://root.cern,https://root.cern/root/html534/ROOT__TFriendProxy.html,1,['cache'],['cached']
Performance,". ROOT::TFriendProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » ROOT::TFriendProxy. class ROOT::TFriendProxy. TFriendProxy. Concrete implementation of the proxy around a Friend Tree. Function Members (Methods); public:. ~TFriendProxy(); Long64_tGetReadEntry() const; voidResetReadEntry(); ROOT::TFriendProxyTFriendProxy(); ROOT::TFriendProxyTFriendProxy(ROOT::TBranchProxyDirector* director, TTree* main, Int_t index); voidUpdate(TTree* newmain). Data Members; protected:. ROOT::TBranchProxyDirectorfDirectorcontain pointer to TTree and entry to be read; Int_tfIndexIndex of this tree in the list of friends. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFriendProxy(). TFriendProxy(ROOT::TBranchProxyDirector* director, TTree* main, Int_t index); Constructor. Long64_t GetReadEntry() const; Return the entry number currently being looked at. void ResetReadEntry(); Refresh the cached read entry number from the original tree. void Update(TTree* newmain); Update the address of the underlying tree. » Author: Philippe Canal 01/06/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id: TFriendProxy.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 19:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__TFriendProxy.html:1119,cache,cached,1119,root/html528/ROOT__TFriendProxy.html,https://root.cern,https://root.cern/root/html528/ROOT__TFriendProxy.html,1,['cache'],['cached']
Performance,". ROOT::TFriendProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » ROOT::TFriendProxy. class ROOT::TFriendProxy. TFriendProxy. Concrete implementation of the proxy around a Friend Tree. Function Members (Methods); public:. ~TFriendProxy(); Long64_tGetReadEntry() const; voidResetReadEntry(); ROOT::TFriendProxyTFriendProxy(); ROOT::TFriendProxyTFriendProxy(ROOT::TBranchProxyDirector* director, TTree* main, Int_t index); voidUpdate(TTree* newmain). Data Members; protected:. ROOT::TBranchProxyDirectorfDirectorcontain pointer to TTree and entry to be read; Int_tfIndexIndex of this tree in the list of friends. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFriendProxy(). TFriendProxy(ROOT::TBranchProxyDirector* director, TTree* main, Int_t index); Constructor. Long64_t GetReadEntry() const; Return the entry number currently being looked at. void ResetReadEntry(); Refresh the cached read entry number from the original tree. void Update(TTree* newmain); Update the address of the underlying tree. » Author: Philippe Canal 01/06/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id: TFriendProxy.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__TFriendProxy.html:1119,cache,cached,1119,root/html530/ROOT__TFriendProxy.html,https://root.cern,https://root.cern/root/html530/ROOT__TFriendProxy.html,1,['cache'],['cached']
Performance,". ROOT::TFriendProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » ROOT::TFriendProxy. class ROOT::TFriendProxy. TFriendProxy. Concrete implementation of the proxy around a Friend Tree. Function Members (Methods); public:. ~TFriendProxy(); Long64_tGetReadEntry() const; voidResetReadEntry(); ROOT::TFriendProxyTFriendProxy(); ROOT::TFriendProxyTFriendProxy(ROOT::TBranchProxyDirector* director, TTree* main, Int_t index); voidUpdate(TTree* newmain). Data Members; protected:. ROOT::TBranchProxyDirectorfDirectorcontain pointer to TTree and entry to be read; Int_tfIndexIndex of this tree in the list of friends. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFriendProxy(). TFriendProxy(ROOT::TBranchProxyDirector* director, TTree* main, Int_t index); Constructor. Long64_t GetReadEntry() const; Return the entry number currently being looked at. void ResetReadEntry(); Refresh the cached read entry number from the original tree. void Update(TTree* newmain); Update the address of the underlying tree. » Author: Philippe Canal 01/06/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id: TFriendProxy.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__TFriendProxy.html:1119,cache,cached,1119,root/html532/ROOT__TFriendProxy.html,https://root.cern,https://root.cern/root/html532/ROOT__TFriendProxy.html,1,['cache'],['cached']
Performance,". Reimplemented from TMVA::MethodBase.; Definition at line 266 of file MethodBase.h. ◆ ReadWeightsFromXML(). void TMVA::MethodCrossValidation::ReadWeightsFromXML ; (; void * ; parent). virtual . Reads from the xml file. ; Implements TMVA::MethodBase.; Definition at line 208 of file MethodCrossValidation.cxx. ◆ Reset(). void TMVA::MethodCrossValidation::Reset ; (; void ; ). virtual . Reset the method, as if it had just been instantiated (forget all training etc.). ; Reimplemented from TMVA::MethodBase.; Definition at line 108 of file MethodCrossValidation.cxx. ◆ Streamer(). virtual void TMVA::MethodCrossValidation::Streamer ; (; TBuffer & ; ). virtual . Reimplemented from TMVA::MethodBase. ◆ StreamerNVirtual(). void TMVA::MethodCrossValidation::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 120 of file MethodCrossValidation.h. ◆ Train(). void TMVA::MethodCrossValidation::Train ; (; void ; ). virtual . Call the Optimizer with the set of parameters and ranges that are meant to be tuned. ; Set the tuning parameters according to the argument. training. ; Implements TMVA::MethodBase.; Definition at line 146 of file MethodCrossValidation.cxx. ◆ WriteMonitoringHistosToFile(). void TMVA::MethodCrossValidation::WriteMonitoringHistosToFile ; (; void ; ); const. virtual . write special monitoring histograms to file dummy implementation here --------------— ; Reimplemented from TMVA::MethodBase.; Definition at line 359 of file MethodCrossValidation.cxx. Member Data Documentation. ◆ CrossValidation. friend TMVA::MethodCrossValidation::CrossValidation. private . Definition at line 40 of file MethodCrossValidation.h. ◆ fEncapsulatedMethodName. TString TMVA::MethodCrossValidation::fEncapsulatedMethodName. private . Definition at line 101 of file MethodCrossValidation.h. ◆ fEncapsulatedMethods. std::vector<MethodBase *> TMVA::MethodCrossValidation::fEncapsulatedMethods. private . Definition at line 112 of file MethodCrossValidation.h. ◆ fEn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodCrossValidation.html:35563,Optimiz,Optimizer,35563,doc/master/classTMVA_1_1MethodCrossValidation.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodCrossValidation.html,2,"['Optimiz', 'tune']","['Optimizer', 'tuned']"
Performance,". Reimplemented in TGLEmbeddedViewer, and TGLSAViewer.; Definition at line 226 of file TGLViewer.h. ◆ DistancetoPrimitive(). Int_t TGLViewer::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Calculate and return pixel distance to nearest viewer object from window location px, py This is provided for use when embedding GL viewer into pad. ; Reimplemented from TObject.; Definition at line 2225 of file TGLViewer.cxx. ◆ DoDraw(). void TGLViewer::DoDraw ; (; Bool_t ; swap_buffers = kTRUE). Draw out the viewer. ; Definition at line 548 of file TGLViewer.cxx. ◆ DoDrawMono(). void TGLViewer::DoDrawMono ; (; Bool_t ; swap_buffers). Draw out in monoscopic mode. ; Definition at line 626 of file TGLViewer.cxx. ◆ DoDrawStereo(). void TGLViewer::DoDrawStereo ; (; Bool_t ; swap_buffers). Draw out in stereoscopic mode. ; Definition at line 658 of file TGLViewer.cxx. ◆ DoOverlaySelect(). Bool_t TGLViewer::DoOverlaySelect ; (; Int_t ; x, . Int_t ; y . ). Perform GL selection, picking overlay objects only. ; Return TRUE if the selected overlay-element has changed. ; Definition at line 1508 of file TGLViewer.cxx. ◆ DoSecondarySelect(). Bool_t TGLViewer::DoSecondarySelect ; (; Int_t ; x, . Int_t ; y . ). Secondary selection. ; Definition at line 1397 of file TGLViewer.cxx. ◆ DoSelect(). Bool_t TGLViewer::DoSelect ; (; Int_t ; x, . Int_t ; y . ). Perform GL selection, picking objects overlapping WINDOW area described by 'rect'. ; Return kTRUE if selection should be changed, kFALSE otherwise. Select lock should already been taken in other thread in TGLViewer::ReqSelect(). ; Definition at line 1328 of file TGLViewer.cxx. ◆ DoubleClicked(). virtual void TGLViewer::DoubleClicked ; (; ). inlinevirtual . Definition at line 376 of file TGLViewer.h. ◆ DrawDebugInfo(). void TGLViewer::DrawDebugInfo ; (; ). If in debug mode draw camera aids and overall bounding box. ; Definition at line 1191 of file TGLViewer.cxx. ◆ DrawGuides(). void TGLViewer::DrawGuides ; (; ). Draw refe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLViewer.html:43934,Perform,Perform,43934,doc/master/classTGLViewer.html,https://root.cern,https://root.cern/doc/master/classTGLViewer.html,1,['Perform'],['Perform']
Performance,". RooAbsCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCache. class RooAbsCache. RooAbsCache is the abstract base class for data members of RooAbsArgs; that cache other (composite) RooAbsArg expressions. The RooAbsCache; interface defines the interaction between the owning RooAbsArg object; and the cache data member to communicate server redirects, operation; mode changes and constant term optimization management calls.; . Function Members (Methods); public:. RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCache.html:362,cache,cache,362,root/html528/RooAbsCache.html,https://root.cern,https://root.cern/root/html528/RooAbsCache.html,9,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,". RooAbsCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCache. class RooAbsCache. RooAbsCache is the abstract base class for data members of RooAbsArgs; that cache other (composite) RooAbsArg expressions. The RooAbsCache; interface defines the interaction between the owning RooAbsArg object; and the cache data member to communicate server redirects, operation; mode changes and constant term optimization management calls.; . Function Members (Methods); public:. RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCache.html:362,cache,cache,362,root/html526/RooAbsCache.html,https://root.cern,https://root.cern/root/html526/RooAbsCache.html,3,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,". RooAbsCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCache. class RooAbsCache. RooAbsCache is the abstract base class for data members of RooAbsArgs; that cache other (composite) RooAbsArg expressions. The RooAbsCache; interface defines the interaction between the owning RooAbsArg object; and the cache data member to communicate server redirects, operation; mode changes and constant term optimization management calls.; . Function Members (Methods); public:. RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCache.html:362,cache,cache,362,root/html534/RooAbsCache.html,https://root.cern,https://root.cern/root/html534/RooAbsCache.html,3,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,". RooAbsCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCache. class RooAbsCache. RooAbsCache is the abstract base class for data members of RooAbsArgs; that cache other (composite) RooAbsArg expressions. The RooAbsCache; interface defines the interaction between the owning RooAbsArg object; and the cache data member to communicate server redirects, operation; mode changes and constant term optimization management calls.; . Function Members (Methods); public:. virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCache.html:362,cache,cache,362,root/html602/RooAbsCache.html,https://root.cern,https://root.cern/root/html602/RooAbsCache.html,6,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,". RooAbsCacheElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCacheElement. class RooAbsCacheElement. RooAbsCacheElement is the abstract base class for objects to be stored; in RooAbsCache cache manager objects. Each storage element has an ; interface to pass on calls for server redirection, operation mode; change calls and constant term optimization management calls; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCacheElement(); static TClass*Class(); virtual RooArgListcontainedArgs(RooAbsCacheElement::Action); virtual voidfindConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); virtual TClass*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCacheElement(); RooAbsCacheElement(const RooAbsCacheElement&); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. static RooAbsCacheElement::ActionFindConstantNodes; static RooAbsCacheElement::ActionOperModeChange; static RooAbsCacheElement::ActionOptimizeCaching. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCacheElement.html:394,cache,cache,394,root/html602/RooAbsCacheElement.html,https://root.cern,https://root.cern/root/html602/RooAbsCacheElement.html,4,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,". RooAbsCacheElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCacheElement. class RooAbsCacheElement. RooAbsCacheElement is the abstract base class for objects to be stored; in RooAbsCache cache manager objects. Each storage element has an ; interface to pass on calls for server redirection, operation mode; change calls and constant term optimization management calls; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCacheElement(); static TClass*Class(); virtual RooArgListcontainedArgs(RooAbsCacheElement::Action); virtual voidfindConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); virtual TClass*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCacheElement.html:394,cache,cache,394,root/html528/RooAbsCacheElement.html,https://root.cern,https://root.cern/root/html528/RooAbsCacheElement.html,6,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,". RooAbsCacheElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCacheElement. class RooAbsCacheElement. RooAbsCacheElement is the abstract base class for objects to be stored; in RooAbsCache cache manager objects. Each storage element has an ; interface to pass on calls for server redirection, operation mode; change calls and constant term optimization management calls; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCacheElement(); static TClass*Class(); virtual RooArgListcontainedArgs(RooAbsCacheElement::Action); virtual voidfindConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); virtual TClass*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to prin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCacheElement.html:394,cache,cache,394,root/html526/RooAbsCacheElement.html,https://root.cern,https://root.cern/root/html526/RooAbsCacheElement.html,2,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,". RooAbsCacheElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCacheElement. class RooAbsCacheElement. RooAbsCacheElement is the abstract base class for objects to be stored; in RooAbsCache cache manager objects. Each storage element has an ; interface to pass on calls for server redirection, operation mode; change calls and constant term optimization management calls; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCacheElement(); static TClass*Class(); virtual RooArgListcontainedArgs(RooAbsCacheElement::Action); virtual voidfindConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); virtual TClass*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCacheElement.html:394,cache,cache,394,root/html534/RooAbsCacheElement.html,https://root.cern,https://root.cern/root/html534/RooAbsCacheElement.html,2,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,". RooAbsCachedPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedPdf. class RooAbsCachedPdf: public RooAbsPdf. RooAbsCachedPdf is the abstract base class for p.d.f.s that need or; want to cache their evaluate() output in a RooHistPdf defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistPdf cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedPdf must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the p.d.fs function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedPdf.html:393,cache,cache,393,root/html528/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedPdf.html,24,['cache'],"['cache', 'cached']"
Performance,". RooAbsCachedPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedPdf. class RooAbsCachedPdf: public RooAbsPdf. RooAbsCachedPdf is the abstract base class for p.d.f.s that need or; want to cache their evaluate() output in a RooHistPdf defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistPdf cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedPdf must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the p.d.fs function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedPdf.html:393,cache,cache,393,root/html526/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedPdf.html,4,['cache'],"['cache', 'cached']"
Performance,". RooAbsCachedReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedReal. class RooAbsCachedReal: public RooAbsReal. RooAbsCachedReal is the abstract base class for functions that need or; want to cache their evaluate() output in a RooHistFunc defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistFunc cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedReal must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the functions function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedReal.html:400,cache,cache,400,root/html528/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedReal.html,24,['cache'],"['cache', 'cached']"
Performance,". RooAbsCachedReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedReal. class RooAbsCachedReal: public RooAbsReal. RooAbsCachedReal is the abstract base class for functions that need or; want to cache their evaluate() output in a RooHistFunc defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistFunc cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedReal must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the functions function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedReal.html:400,cache,cache,400,root/html526/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedReal.html,4,['cache'],"['cache', 'cached']"
Performance,". RooAbsFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsFunc. class RooAbsFunc. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsFunc(); static TClass*Class(); UInt_tgetDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tisValid() const; Int_tnumCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&operator=(const RooAbsFunc&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidresetNumCall() const; virtual voidrestoreXVec() const; virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. UInt_t_dimensionNumber of observables; Int_t_ncallFunction call counter; Bool_t_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~RooAbsFunc(); { }. UInt_t getDimension() const; Dimension of function. Bool_t isValid() const; Is function in valid state. Double_t operator()(const Double_t* xvector) const. Double_t getMinLi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsFunc.html:366,perform,performing,366,root/html528/RooAbsFunc.html,https://root.cern,https://root.cern/root/html528/RooAbsFunc.html,3,['perform'],['performing']
Performance,". RooAbsFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsFunc. class RooAbsFunc. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsFunc(); static TClass*Class(); UInt_tgetDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tisValid() const; Int_tnumCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&operator=(const RooAbsFunc&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidresetNumCall() const; virtual voidrestoreXVec() const; virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. UInt_t_dimensionNumber of observables; Int_t_ncallFunction call counter; Bool_t_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~RooAbsFunc(); { }. UInt_t getDimension() const; Dimension of function. Bool_t isValid() const; Is function in valid state. Double_t operator()(const Double_t* xvector) const. Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsFunc.html:366,perform,performing,366,root/html526/RooAbsFunc.html,https://root.cern,https://root.cern/root/html526/RooAbsFunc.html,1,['perform'],['performing']
Performance,". RooAbsFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsFunc. class RooAbsFunc. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsFunc(); virtual list<Double_t>*binBoundaries(Int_t) const; static TClass*Class(); UInt_tgetDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tisValid() const; Int_tnumCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&operator=(const RooAbsFunc&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidresetNumCall() const; virtual voidrestoreXVec() const; virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. UInt_t_dimensionNumber of observables; Int_t_ncallFunction call counter; Bool_t_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~RooAbsFunc(); { }. UInt_t getDimension() const; Dimension of function. Bool_t isValid() const; Is function in valid state.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsFunc.html:366,perform,performing,366,root/html534/RooAbsFunc.html,https://root.cern,https://root.cern/root/html534/RooAbsFunc.html,1,['perform'],['performing']
Performance,". RooAbsFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsFunc. class RooAbsFunc. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsFunc(); virtual list<Double_t>*binBoundaries(Int_t) const; static TClass*Class(); UInt_tgetDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tisValid() const; Int_tnumCall() const; virtual Double_toperator()(const Double_t[] xvector) const; RooAbsFunc&operator=(const RooAbsFunc&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidresetNumCall() const; virtual voidrestoreXVec() const; RooAbsFunc(UInt_t dimension); RooAbsFunc(const RooAbsFunc& other); virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. UInt_t_dimensionNumber of observables; Int_t_ncallFunction call counter; Bool_t_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; inline RooAbsFunc(UInt_t dimension); { }. inline Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsFunc.html:366,perform,performing,366,root/html602/RooAbsFunc.html,https://root.cern,https://root.cern/root/html602/RooAbsFunc.html,2,['perform'],['performing']
Performance,". RooAbsMCStudyModule. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsMCStudyModule. class RooAbsMCStudyModule: public TNamed. RooAbsMCStudyModule is a base class for add-on modules to RooMCStudy that; can perform additional calculations on each generate+fit cycle managed; by RooMCStudy; This class can insert code to be executed before each generation step,; between the generation and fitting step and after the fitting step.; Any summary output variables declared in the RooDataSet exported through; summaryData() is merged with the 'master' summary dataset in RooMCStudy; Look at RooDLLSignificanceMCStudyModule for an example of an implementation; . Function Members (Methods); public:. RooAbsMCStudyModule(const RooAbsMCStudyModule& other); RooAbsMCStudyModule(const char* name, const char* title); virtual~RooAbsMCStudyModule(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tdoInitializeInstance(RooMCStudy&); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsMCStudyModule.html:404,perform,perform,404,root/html526/RooAbsMCStudyModule.html,https://root.cern,https://root.cern/root/html526/RooAbsMCStudyModule.html,5,['perform'],['perform']
Performance,". RooAbsMCStudyModule. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsMCStudyModule. class RooAbsMCStudyModule: public TNamed. RooAbsMCStudyModule is a base class for add-on modules to RooMCStudy that; can perform additional calculations on each generate+fit cycle managed; by RooMCStudy; This class can insert code to be executed before each generation step,; between the generation and fitting step and after the fitting step.; Any summary output variables declared in the RooDataSet exported through; summaryData() is merged with the 'master' summary dataset in RooMCStudy; Look at RooDLLSignificanceMCStudyModule for an example of an implementation; . Function Members (Methods); public:. virtual~RooAbsMCStudyModule(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tdoInitializeInstance(RooMCStudy&); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::Execute",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsMCStudyModule.html:404,perform,perform,404,root/html602/RooAbsMCStudyModule.html,https://root.cern,https://root.cern/root/html602/RooAbsMCStudyModule.html,2,['perform'],['perform']
Performance,". RooAbsOptTestStatistic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsOptTestStatistic. class RooAbsOptTestStatistic: public RooAbsTestStatistic. RooAbsOptTestStatistic is the abstract base class for test; statistics objects that evaluate a function or PDF at each point of a given; dataset. This class provides generic optimizations, such as; caching and precalculation of constant terms that can be made for; all such quantities; Implementations should define evaluatePartition(), which calculates the; value of a (sub)range of the dataset and optionally combinedValue(),; which combines the values calculated for each partition. If combinedValue(); is not overloaded, the default implementation will add the partition results; to obtain the combined result; Support for calculation in partitions is needed to allow multi-core; parallelized calculation of test statistics; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsOptTestStatistic(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsOptTestStatistic.html:521,optimiz,optimizations,521,root/html528/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html528/RooAbsOptTestStatistic.html,6,['optimiz'],['optimizations']
Performance,". RooAbsOptTestStatistic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsOptTestStatistic. class RooAbsOptTestStatistic: public RooAbsTestStatistic. RooAbsOptTestStatistic is the abstract base class for test; statistics objects that evaluate a function or PDF at each point of a given; dataset. This class provides generic optimizations, such as; caching and precalculation of constant terms that can be made for; all such quantities; Implementations should define evaluatePartition(), which calculates the; value of a (sub)range of the dataset and optionally combinedValue(),; which combines the values calculated for each partition. If combinedValue(); is not overloaded, the default implementation will add the partition results; to obtain the combined result; Support for calculation in partitions is needed to allow multi-core; parallelized calculation of test statistics; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsOptTestStatistic(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsOptTestStatistic.html:521,optimiz,optimizations,521,root/html526/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsOptTestStatistic.html,1,['optimiz'],['optimizations']
Performance,". RooAbsSelfCachedPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsSelfCachedPdf. class RooAbsSelfCachedPdf: public RooAbsCachedPdf. RooAbsSelfCachedPdf is an abstract base class for probability; density functions whose output is cached in terms of a histogram in; all observables between getVal() and evaluate(). For certain; p.d.f.s that are very expensive to calculate it may be beneficial; to implement them as a RooAbsSelfCachedPdf rather than a; RooAbsPdf. Class RooAbsSelfCachedPdf is designed to have its; interface identical to that of RooAbsPdf, so any p.d.f can make use; of its caching functionality by merely switching its base class.; Existing RooAbsPdf objects can also be cached a posteriori with the; RooCachedPdf wrapper p.d.f. that takes any RooAbsPdf object as; input.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsSelfCachedPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsSelfCachedPdf.html:431,cache,cached,431,root/html528/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsSelfCachedPdf.html,12,['cache'],['cached']
Performance,". RooAbsSelfCachedPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsSelfCachedPdf. class RooAbsSelfCachedPdf: public RooAbsCachedPdf. RooAbsSelfCachedPdf is an abstract base class for probability; density functions whose output is cached in terms of a histogram in; all observables between getVal() and evaluate(). For certain; p.d.f.s that are very expensive to calculate it may be beneficial; to implement them as a RooAbsSelfCachedPdf rather than a; RooAbsPdf. Class RooAbsSelfCachedPdf is designed to have its; interface identical to that of RooAbsPdf, so any p.d.f can make use; of its caching functionality by merely switching its base class.; Existing RooAbsPdf objects can also be cached a posteriori with the; RooCachedPdf wrapper p.d.f. that takes any RooAbsPdf object as; input.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsSelfCachedPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsSelfCachedPdf.html:431,cache,cached,431,root/html526/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsSelfCachedPdf.html,2,['cache'],['cached']
Performance,". RooAbsSelfCachedReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsSelfCachedReal. class RooAbsSelfCachedReal: public RooAbsCachedReal. RooAbsSelfCachedReal is an abstract base class for functions whose; output is cached in terms of a histogram in all observables between; getVal() and evaluate(). For certain p.d.f.s that are very; expensive to calculate it may be beneficial to implement them as a; RooAbsSelfCachedReal rather than a RooAbsReal. Class; RooAbsSelfCachedReal is designed to have its interface identical to; that of RooAbsReal, so any p.d.f can make use of its caching; functionality by merely switching its base class. Existing; RooAbsReal objects can also be cached a posteriori with the; RooCachedReal wrapper function that takes any RooAbsReal object as; input.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsSelfCachedReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsSelfCachedReal.html:416,cache,cached,416,root/html528/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html528/RooAbsSelfCachedReal.html,12,['cache'],['cached']
Performance,". RooAbsSelfCachedReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsSelfCachedReal. class RooAbsSelfCachedReal: public RooAbsCachedReal. RooAbsSelfCachedReal is an abstract base class for functions whose; output is cached in terms of a histogram in all observables between; getVal() and evaluate(). For certain p.d.f.s that are very; expensive to calculate it may be beneficial to implement them as a; RooAbsSelfCachedReal rather than a RooAbsReal. Class; RooAbsSelfCachedReal is designed to have its interface identical to; that of RooAbsReal, so any p.d.f can make use of its caching; functionality by merely switching its base class. Existing; RooAbsReal objects can also be cached a posteriori with the; RooCachedReal wrapper function that takes any RooAbsReal object as; input.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsSelfCachedReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsSelfCachedReal.html:416,cache,cached,416,root/html526/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsSelfCachedReal.html,2,['cache'],['cached']
Performance,". RooAbsTestStatistic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsTestStatistic. class RooAbsTestStatistic: public RooAbsReal. RooAbsTestStatistic is the abstract base class for all test; statistics. Test statistics that evaluate the PDF at each data; point should inherit from the RooAbsOptTestStatistic class which; implements several generic optimizations that can be done for such; quantities.; This test statistic base class organizes calculation of test; statistic values for RooSimultaneous PDF as a combination of test; statistic values for the PDF components of the simultaneous PDF and; organizes multi-processor parallel calculation of test statistic; values. For the latter, the test statistic value is calculated in; partitions in parallel executing processes and a posteriori; combined in the main thread.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsTestStatistic(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsTestStatistic.html:547,optimiz,optimizations,547,root/html528/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html528/RooAbsTestStatistic.html,6,['optimiz'],['optimizations']
Performance,". RooAbsTestStatistic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsTestStatistic. class RooAbsTestStatistic: public RooAbsReal. RooAbsTestStatistic is the abstract base class for all test; statistics. Test statistics that evaluate the PDF at each data; point should inherit from the RooAbsOptTestStatistic class which; implements several generic optimizations that can be done for such; quantities.; This test statistic base class organizes calculation of test; statistic values for RooSimultaneous PDF as a combination of test; statistic values for the PDF components of the simultaneous PDF and; organizes multi-processor parallel calculation of test statistic; values. For the latter, the test statistic value is calculated in; partitions in parallel executing processes and a posteriori; combined in the main thread.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsTestStatistic(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& par",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsTestStatistic.html:547,optimiz,optimizations,547,root/html526/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsTestStatistic.html,1,['optimiz'],['optimizations']
Performance,". RooCachedPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooCachedPdf. class RooCachedPdf: public RooAbsCachedPdf. RooCachedPdf is an implementation of RooAbsCachedPdf that can cache; any external RooAbsPdf input function provided in the constructor. ; . Function Members (Methods); public:. RooCachedPdf(); RooCachedPdf(const RooCachedPdf& other, const char* name = 0); RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf); RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf, const RooArgSet& cacheObs); virtual~RooCachedPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCachedPdf.html:375,cache,cache,375,root/html528/RooCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooCachedPdf.html,3,['cache'],['cache']
Performance,". RooCachedPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooCachedPdf. class RooCachedPdf: public RooAbsCachedPdf. RooCachedPdf is an implementation of RooAbsCachedPdf that can cache; any external RooAbsPdf input function provided in the constructor. ; . Function Members (Methods); public:. RooCachedPdf(); RooCachedPdf(const RooCachedPdf& other, const char* name = 0); RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf); RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf, const RooArgSet& cacheObs); virtual~RooCachedPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedPdf.html:375,cache,cache,375,root/html534/RooCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooCachedPdf.html,1,['cache'],['cache']
Performance,". RooCachedPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooCachedPdf. class RooCachedPdf: public RooAbsCachedPdf. RooCachedPdf is an implementation of RooAbsCachedPdf that can cache; any external RooAbsPdf input function provided in the constructor. ; . Function Members (Methods); public:. RooCachedPdf(); RooCachedPdf(const RooCachedPdf& other, const char* name = 0); RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf); RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf, const RooArgSet& cacheObs); virtual~RooCachedPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedPdf.html:375,cache,cache,375,root/html526/RooCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooCachedPdf.html,1,['cache'],['cache']
Performance,". RooCachedPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooCachedPdf. class RooCachedPdf: public RooAbsCachedPdf. RooCachedPdf is an implementation of RooAbsCachedPdf that can cache; any external RooAbsPdf input function provided in the constructor. ; . Function Members (Methods); public:. virtual~RooCachedPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedPdf.html:375,cache,cache,375,root/html602/RooCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooCachedPdf.html,2,['cache'],['cache']
Performance,". RooCachedReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooCachedReal. class RooCachedReal: public RooAbsCachedReal. RooCachedReal is an implementation of RooAbsCachedReal that can cache; any external RooAbsReal input function provided in the constructor. ; . Function Members (Methods); public:. RooCachedReal(); RooCachedReal(const RooCachedReal& other, const char* name = 0); RooCachedReal(const char* name, const char* title, RooAbsReal& _func); RooCachedReal(const char* name, const char* title, RooAbsReal& _func, const RooArgSet& cacheObs); virtual~RooCachedReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCachedReal.html:381,cache,cache,381,root/html528/RooCachedReal.html,https://root.cern,https://root.cern/root/html528/RooCachedReal.html,3,['cache'],['cache']
Performance,". RooCachedReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooCachedReal. class RooCachedReal: public RooAbsCachedReal. RooCachedReal is an implementation of RooAbsCachedReal that can cache; any external RooAbsReal input function provided in the constructor. ; . Function Members (Methods); public:. RooCachedReal(); RooCachedReal(const RooCachedReal& other, const char* name = 0); RooCachedReal(const char* name, const char* title, RooAbsReal& _func); RooCachedReal(const char* name, const char* title, RooAbsReal& _func, const RooArgSet& cacheObs); virtual~RooCachedReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedReal.html:381,cache,cache,381,root/html526/RooCachedReal.html,https://root.cern,https://root.cern/root/html526/RooCachedReal.html,1,['cache'],['cache']
Performance,". RooCachedReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooCachedReal. class RooCachedReal: public RooAbsCachedReal. RooCachedReal is an implementation of RooAbsCachedReal that can cache; any external RooAbsReal input function provided in the constructor. ; . Function Members (Methods); public:. virtual~RooCachedReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheSource() const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedReal.html:381,cache,cache,381,root/html602/RooCachedReal.html,https://root.cern,https://root.cern/root/html602/RooCachedReal.html,1,['cache'],['cache']
Performance,". RooCachedReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooCachedReal. class RooCachedReal: public RooAbsCachedReal. RooCachedReal is an implementation of RooAbsCachedReal that can cache; any external RooAbsReal input function provided in the constructor.; . Function Members (Methods); public:. RooCachedReal(); RooCachedReal(const RooCachedReal& other, const char* name = 0); RooCachedReal(const char* name, const char* title, RooAbsReal& _func); RooCachedReal(const char* name, const char* title, RooAbsReal& _func, const RooArgSet& cacheObs); virtual~RooCachedReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedReal.html:381,cache,cache,381,root/html534/RooCachedReal.html,https://root.cern,https://root.cern/root/html534/RooCachedReal.html,1,['cache'],['cache']
Performance,". RooCachedReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooCachedReal. class RooCachedReal: public RooAbsCachedReal. RooCachedReal is an implementation of RooAbsCachedReal that can cache; any external RooAbsReal input function provided in the constructor.; . Function Members (Methods); public:. virtual~RooCachedReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheSource() const; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooCachedReal.html:381,cache,cache,381,root/html604/RooCachedReal.html,https://root.cern,https://root.cern/root/html604/RooCachedReal.html,1,['cache'],['cache']
Performance,". RooChangeTracker. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooChangeTracker. class RooChangeTracker: public RooAbsReal. ; RooChangeTracker is a meta object that tracks value; changes in a given set of RooAbsArgs by registering itself as value; client of these objects. The change tracker can perform an; additional validation step where it also compares the numeric; values of the tracked arguments with reference values to ensure; that values have actually changed. This may be useful in case some; of the tracked observables are in binned datasets where each; observable propates a valueDirty flag when an event is loaded even; though usually only one observable actually changes.; . Function Members (Methods); public:. RooChangeTracker(); RooChangeTracker(const RooChangeTracker& other, const char* name = 0); RooChangeTracker(const char* name, const char* title, const RooArgSet& trackSet, Bool_t checkValues = kFALSE); virtual~RooChangeTracker(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooChangeTracker.html:492,perform,perform,492,root/html528/RooChangeTracker.html,https://root.cern,https://root.cern/root/html528/RooChangeTracker.html,8,"['load', 'perform']","['loaded', 'perform']"
Performance,". RooChangeTracker. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooChangeTracker. class RooChangeTracker: public RooAbsReal. ; RooChangeTracker is a meta object that tracks value; changes in a given set of RooAbsArgs by registering itself as value; client of these objects. The change tracker can perform an; additional validation step where it also compares the numeric; values of the tracked arguments with reference values to ensure; that values have actually changed. This may be useful in case some; of the tracked observables are in binned datasets where each; observable propates a valueDirty flag when an event is loaded even; though usually only one observable actually changes.; . Function Members (Methods); public:. RooChangeTracker(); RooChangeTracker(const RooChangeTracker& other, const char* name = 0); RooChangeTracker(const char* name, const char* title, const RooArgSet& trackSet, Bool_t checkValues = kFALSE); virtual~RooChangeTracker(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChangeTracker.html:492,perform,perform,492,root/html526/RooChangeTracker.html,https://root.cern,https://root.cern/root/html526/RooChangeTracker.html,2,"['load', 'perform']","['loaded', 'perform']"
Performance,". RooChangeTracker. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooChangeTracker. class RooChangeTracker: public RooAbsReal. ; RooChangeTracker is a meta object that tracks value; changes in a given set of RooAbsArgs by registering itself as value; client of these objects. The change tracker can perform an; additional validation step where it also compares the numeric; values of the tracked arguments with reference values to ensure; that values have actually changed. This may be useful in case some; of the tracked observables are in binned datasets where each; observable propates a valueDirty flag when an event is loaded even; though usually only one observable actually changes.; . Function Members (Methods); public:. virtual~RooChangeTracker(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChangeTracker.html:492,perform,perform,492,root/html602/RooChangeTracker.html,https://root.cern,https://root.cern/root/html602/RooChangeTracker.html,4,"['load', 'perform']","['loaded', 'perform']"
Performance,". RooDataProjBinding. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooDataProjBinding. class RooDataProjBinding: public RooRealBinding. Class RooDataProjBinding is a lightweight interface; adaptor that projects a real function via summation of states; provided in a dataset. The real function must be attached to the; dataset before creating this binding object.; If the dataset only contains category variables, the summation is optimized; performing a weighted sum over the states of a RooSuperCategory that is; constructed from all the categories in the dataset; . Function Members (Methods); public:. RooDataProjBinding(const RooDataProjBinding&); RooDataProjBinding(const RooAbsReal& real, const RooAbsData& data, const RooArgSet& vars, const RooArgSet* normSet = 0); virtual~RooDataProjBinding(); static TClass*Class(); UInt_tRooAbsFunc::getDimension() const; virtual Double_tRooRealBinding::getMaxLimit(UInt_t dimension) const; virtual Double_tRooRealBinding::getMinLimit(UInt_t dimension) const; virtual const char*RooRealBinding::getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&RooAbsFunc::operator=(const RooAbsFunc&); virtual list<Double_t>*RooRealBinding::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidRooRealBinding::restoreXVec() const; virtual voidRooRealBinding::saveXVec() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidRooRealBinding::loadValues(const Double_t* xvector) const. Data Members; protected:. Roo1DTable*_catTableSupercategory table generated from _data; Bool_tRooRealBinding::_clip",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDataProjBinding.html:624,optimiz,optimized,624,root/html528/RooDataProjBinding.html,https://root.cern,https://root.cern/root/html528/RooDataProjBinding.html,6,"['optimiz', 'perform']","['optimized', 'performing']"
Performance,". RooDataProjBinding. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooDataProjBinding. class RooDataProjBinding: public RooRealBinding. Class RooDataProjBinding is a lightweight interface; adaptor that projects a real function via summation of states; provided in a dataset. The real function must be attached to the; dataset before creating this binding object.; If the dataset only contains category variables, the summation is optimized; performing a weighted sum over the states of a RooSuperCategory that is; constructed from all the categories in the dataset; . Function Members (Methods); public:. RooDataProjBinding(const RooDataProjBinding&); RooDataProjBinding(const RooAbsReal& real, const RooAbsData& data, const RooArgSet& vars, const RooArgSet* normSet = 0); virtual~RooDataProjBinding(); static TClass*Class(); UInt_tRooAbsFunc::getDimension() const; virtual Double_tRooRealBinding::getMaxLimit(UInt_t dimension) const; virtual Double_tRooRealBinding::getMinLimit(UInt_t dimension) const; virtual const char*RooRealBinding::getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&RooAbsFunc::operator=(const RooAbsFunc&); virtual list<Double_t>*RooRealBinding::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidRooRealBinding::restoreXVec() const; virtual voidRooRealBinding::saveXVec() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidRooRealBinding::loadValues(const Double_t* xvector) const. Data Members; protected:. Roo1DTable*_catTableSupercategory table generated from _data; Bool_tRooReal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataProjBinding.html:624,optimiz,optimized,624,root/html526/RooDataProjBinding.html,https://root.cern,https://root.cern/root/html526/RooDataProjBinding.html,2,"['optimiz', 'perform']","['optimized', 'performing']"
Performance,". RooDataProjBinding. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooDataProjBinding. class RooDataProjBinding: public RooRealBinding. Class RooDataProjBinding is a lightweight interface; adaptor that projects a real function via summation of states; provided in a dataset. The real function must be attached to the; dataset before creating this binding object.; If the dataset only contains category variables, the summation is optimized; performing a weighted sum over the states of a RooSuperCategory that is; constructed from all the categories in the dataset; . Function Members (Methods); public:. RooDataProjBinding(const RooDataProjBinding&); RooDataProjBinding(const RooAbsReal& real, const RooAbsData& data, const RooArgSet& vars, const RooArgSet* normSet = 0); virtual~RooDataProjBinding(); virtual list<Double_t>*RooRealBinding::binBoundaries(Int_t) const; static TClass*Class(); UInt_tRooAbsFunc::getDimension() const; virtual Double_tRooRealBinding::getMaxLimit(UInt_t dimension) const; virtual Double_tRooRealBinding::getMinLimit(UInt_t dimension) const; virtual const char*RooRealBinding::getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&RooAbsFunc::operator=(const RooAbsFunc&); virtual list<Double_t>*RooRealBinding::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidRooRealBinding::restoreXVec() const; virtual voidRooRealBinding::saveXVec() const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidRooRealBinding::loadValues(const Double_t* xvector) const. Data Members; protected:. Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataProjBinding.html:624,optimiz,optimized,624,root/html534/RooDataProjBinding.html,https://root.cern,https://root.cern/root/html534/RooDataProjBinding.html,2,"['optimiz', 'perform']","['optimized', 'performing']"
Performance,". RooDataProjBinding. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooDataProjBinding. class RooDataProjBinding: public RooRealBinding. Class RooDataProjBinding is a lightweight interface; adaptor that projects a real function via summation of states; provided in a dataset. The real function must be attached to the; dataset before creating this binding object.; If the dataset only contains category variables, the summation is optimized; performing a weighted sum over the states of a RooSuperCategory that is; constructed from all the categories in the dataset; . Function Members (Methods); public:. virtual~RooDataProjBinding(); virtual list<Double_t>*RooRealBinding::binBoundaries(Int_t) const; static TClass*Class(); UInt_tRooAbsFunc::getDimension() const; virtual Double_tRooRealBinding::getMaxLimit(UInt_t dimension) const; virtual Double_tRooRealBinding::getMinLimit(UInt_t dimension) const; virtual const char*RooRealBinding::getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t[] xvector) const; RooDataProjBinding&operator=(const RooDataProjBinding&); virtual list<Double_t>*RooRealBinding::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidRooRealBinding::restoreXVec() const; RooDataProjBinding(const RooDataProjBinding&); RooDataProjBinding(const RooAbsReal& real, const RooAbsData& data, const RooArgSet& vars, const RooArgSet* normSet = 0); virtual voidRooRealBinding::saveXVec() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidRooRealBinding::loadValues(const Double_t[] xvector) const. Data Members",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataProjBinding.html:624,optimiz,optimized,624,root/html602/RooDataProjBinding.html,https://root.cern,https://root.cern/root/html602/RooDataProjBinding.html,4,"['optimiz', 'perform']","['optimized', 'performing']"
Performance,". RooDataWeightedAverage. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooDataWeightedAverage. class RooDataWeightedAverage: public RooAbsOptTestStatistic. ; Class RooDataWeightedAverage calculate a weighted; average of a function or p.d.f given a dataset with observable; values, i.e. DWA(f(x),D(x)) = sum_i f(x_i) where x_i is draw from; D(i). This class is an implementation of RooAbsOptTestStatistics ; can make use of the optimization and parallization infrastructure; of that base class. The main use of RooDataWeightedAverage is; to calculate curves in RooPlots that are added with ProjWData(); plot option.; . Function Members (Methods); public:. RooDataWeightedAverage(); RooDataWeightedAverage(const RooDataWeightedAverage& other, const char* name = 0); RooDataWeightedAverage(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t showProgress = kFALSE, Bool_t verbose = kTRUE); virtual~RooDataWeightedAverage(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDataWeightedAverage.html:621,optimiz,optimization,621,root/html528/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html528/RooDataWeightedAverage.html,3,['optimiz'],['optimization']
Performance,". RooDataWeightedAverage. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooDataWeightedAverage. class RooDataWeightedAverage: public RooAbsOptTestStatistic. ; Class RooDataWeightedAverage calculate a weighted; average of a function or p.d.f given a dataset with observable; values, i.e. DWA(f(x),D(x)) = sum_i f(x_i) where x_i is draw from; D(i). This class is an implementation of RooAbsOptTestStatistics ; can make use of the optimization and parallization infrastructure; of that base class. The main use of RooDataWeightedAverage is; to calculate curves in RooPlots that are added with ProjWData(); plot option.; . Function Members (Methods); public:. RooDataWeightedAverage(); RooDataWeightedAverage(const RooDataWeightedAverage& other, const char* name = 0); RooDataWeightedAverage(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t showProgress = kFALSE, Bool_t verbose = kTRUE); virtual~RooDataWeightedAverage(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataWeightedAverage.html:621,optimiz,optimization,621,root/html526/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html526/RooDataWeightedAverage.html,1,['optimiz'],['optimization']
Performance,". RooDataWeightedAverage. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooDataWeightedAverage. class RooDataWeightedAverage: public RooAbsOptTestStatistic. ; Class RooDataWeightedAverage calculate a weighted; average of a function or p.d.f given a dataset with observable; values, i.e. DWA(f(x),D(x)) = sum_i f(x_i) where x_i is draw from; D(i). This class is an implementation of RooAbsOptTestStatistics ; can make use of the optimization and parallization infrastructure; of that base class. The main use of RooDataWeightedAverage is; to calculate curves in RooPlots that are added with ProjWData(); plot option.; . Function Members (Methods); public:. RooDataWeightedAverage(); RooDataWeightedAverage(const RooDataWeightedAverage& other, const char* name = 0); RooDataWeightedAverage(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t showProgress = kFALSE, Bool_t verbose = kTRUE); virtual~RooDataWeightedAverage(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataWeightedAverage.html:621,optimiz,optimization,621,root/html534/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html534/RooDataWeightedAverage.html,1,['optimiz'],['optimization']
Performance,". RooDataWeightedAverage. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooDataWeightedAverage. class RooDataWeightedAverage: public RooAbsOptTestStatistic. ; Class RooDataWeightedAverage calculate a weighted; average of a function or p.d.f given a dataset with observable; values, i.e. DWA(f(x),D(x)) = sum_i f(x_i) where x_i is draw from; D(i). This class is an implementation of RooAbsOptTestStatistics ; can make use of the optimization and parallization infrastructure; of that base class. The main use of RooDataWeightedAverage is; to calculate curves in RooPlots that are added with ProjWData(); plot option.; . Function Members (Methods); public:. virtual~RooDataWeightedAverage(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsReal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataWeightedAverage.html:621,optimiz,optimization,621,root/html602/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html602/RooDataWeightedAverage.html,2,['optimiz'],['optimization']
Performance,". RooErrorVar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooErrorVar. class RooErrorVar: public RooAbsRealLValue. RooErrorVar is an auxilary class that represents the error; of a RooRealVar as a seperate object. The main reason of; existence of this class is to facilitate the reuse of existing; techniques to perform calculations that involve a RooRealVars; error, such as calculating the pull value.; . Function Members (Methods); public:. RooErrorVar(); RooErrorVar(const RooErrorVar& other, const char* name = 0); RooErrorVar(const char* name, const char* title, const RooRealVar& input); virtual~RooErrorVar(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooErrorVar.html:507,perform,perform,507,root/html528/RooErrorVar.html,https://root.cern,https://root.cern/root/html528/RooErrorVar.html,2,['perform'],['perform']
Performance,". RooErrorVar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooErrorVar. class RooErrorVar: public RooAbsRealLValue. RooErrorVar is an auxilary class that represents the error; of a RooRealVar as a seperate object. The main reason of; existence of this class is to facilitate the reuse of existing; techniques to perform calculations that involve a RooRealVars; error, such as calculating the pull value.; . Function Members (Methods); public:. RooErrorVar(); RooErrorVar(const RooErrorVar& other, const char* name = 0); RooErrorVar(const char* name, const char* title, const RooRealVar& input); virtual~RooErrorVar(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooErrorVar.html:507,perform,perform,507,root/html532/RooErrorVar.html,https://root.cern,https://root.cern/root/html532/RooErrorVar.html,2,['perform'],['perform']
Performance,". RooErrorVar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooErrorVar. class RooErrorVar: public RooAbsRealLValue. RooErrorVar is an auxilary class that represents the error; of a RooRealVar as a seperate object. The main reason of; existence of this class is to facilitate the reuse of existing; techniques to perform calculations that involve a RooRealVars; error, such as calculating the pull value.; . Function Members (Methods); public:. RooErrorVar(); RooErrorVar(const RooErrorVar& other, const char* name = 0); RooErrorVar(const char* name, const char* title, const RooRealVar& input); virtual~RooErrorVar(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooErrorVar.html:507,perform,perform,507,root/html526/RooErrorVar.html,https://root.cern,https://root.cern/root/html526/RooErrorVar.html,1,['perform'],['perform']
Performance,". RooErrorVar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooErrorVar. class RooErrorVar: public RooAbsRealLValue. RooErrorVar is an auxilary class that represents the error; of a RooRealVar as a seperate object. The main reason of; existence of this class is to facilitate the reuse of existing; techniques to perform calculations that involve a RooRealVars; error, such as calculating the pull value.; . Function Members (Methods); public:. virtual~RooErrorVar(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooErrorVar.html:507,perform,perform,507,root/html602/RooErrorVar.html,https://root.cern,https://root.cern/root/html602/RooErrorVar.html,2,['perform'],['perform']
Performance,". RooFFTConvPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooFFTConvPdf. class RooFFTConvPdf: public RooAbsCachedPdf. This class implement a generic one-dimensional numeric convolution of two p.d.f.; and can convolve any two RooAbsPdfs. The class exploits the convolution theorem. f(x) (*) g(x) --F--> f(k_i) * g(k_i). and calculate the convolution by calculate a Real->Complex FFT of both input p.d.fs; multiplying the complex coefficients and performing the reverse Complex->Real FFT; to get the result in the input space. This class using the ROOT FFT Interface to; the (free) FFTW3 package (www.fftw.org) and requires that your ROOT installation is; compiled with the --enable-fftw3 option (instructions for Linux follow). Note that the performance in terms of speed and stability of RooFFTConvPdf is; vastly superior to that of RooNumConvPdf. An important feature of FFT convolutions is that the observable is treated in a; cyclical way. This is correct & desirable behavior for cyclical observables such as angles,; but it may not be for other observables. The effect that is observed is that if; p.d.f is zero at xMin and non-zero at xMax some spillover occurs and; a rising tail may appear at xMin. This effect can be reduced or eliminated by; introducing a buffer zone in the FFT calculation. If this feature is activated; input the sampling array for the FFT calculation is extended in both directions; and filled with repetitions of the lowest bin value and highest bin value; respectively. The buffer bins are stripped again when the FFT output values; are transferred to the p.d.f cache. The default buffer size is 10% of the; observable domain size and can be changed with setBufferFraction() member function. This class is a caching p.d.f inheriting from RooAbsCachedPdf. If this p.d.f; i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:643,perform,performing,643,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,14,['perform'],"['performance', 'performing']"
Performance,". RooFormulaVar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooFormulaVar. class RooFormulaVar: public RooAbsReal. RooFormulaVar is a generic implementation of a real valued object; which takes a RooArgList of servers and a C++ expression string defining how; its value should be calculated from the given list of servers.; RooFormulaVar uses a RooFormula object to perform the expression evaluation. If RooAbsPdf objects are supplied to RooFormulaVar as servers, their; raw (unnormalized) values will be evaluated. Use RooGenericPdf, which; constructs generic PDF functions, to access their properly normalized; values. The string expression can be any valid TFormula expression referring to the; listed servers either by name or by their ordinal list position:. RooFormulaVar(""gen"",""x*y"",RooArgList(x,y)) or; RooFormulaVar(""gen"",""@0*@1"",RooArgList(x,y)). The latter form, while slightly less readable, is more versatile because it; doesn't hardcode any of the variable names it expects. Function Members (Methods); public:. RooFormulaVar(); RooFormulaVar(const RooFormulaVar& other, const char* name = 0); RooFormulaVar(const char* name, const char* title, const RooArgList& dependents); RooFormulaVar(const char* name, const char* title, const char* formula, const RooArgList& dependents); virtual~RooFormulaVar(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFormulaVar.html:562,perform,perform,562,root/html534/RooFormulaVar.html,https://root.cern,https://root.cern/root/html534/RooFormulaVar.html,1,['perform'],['perform']
Performance,". RooFormulaVar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooFormulaVar. class RooFormulaVar: public RooAbsReal. RooFormulaVar is a generic implementation of a real valued object; which takes a RooArgList of servers and a C++ expression string defining how; its value should be calculated from the given list of servers.; RooFormulaVar uses a RooFormula object to perform the expression evaluation. If RooAbsPdf objects are supplied to RooFormulaVar as servers, their; raw (unnormalized) values will be evaluated. Use RooGenericPdf, which; constructs generic PDF functions, to access their properly normalized; values. The string expression can be any valid TFormula expression referring to the; listed servers either by name or by their ordinal list position:. RooFormulaVar(""gen"",""x*y"",RooArgList(x,y)) or; RooFormulaVar(""gen"",""@0*@1"",RooArgList(x,y)). The latter form, while slightly less readable, is more versatile because it; doesn't hardcode any of the variable names it expects. Function Members (Methods); public:. virtual~RooFormulaVar(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFormulaVar.html:562,perform,perform,562,root/html602/RooFormulaVar.html,https://root.cern,https://root.cern/root/html602/RooFormulaVar.html,2,['perform'],['perform']
Performance,". RooFormulaVar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooFormulaVar. class RooFormulaVar: public RooAbsReal. RooRealVar is a generic implementation of a real valued object; which takes a RooArgList of servers and a C++ expression string defining how; its value should be calculated from the given list of servers.; RooRealVar uses a RooFormula object to perform the expression evaluation. If RooAbsPdf objects are supplied to RooRealVar as servers, their; raw (unnormalized) values will be evaluated. Use RooGenericPdf, which; constructs generic PDF functions, to access their properly normalized; values. The string expression can be any valid TFormula expression referring to the; listed servers either by name or by their ordinal list position:. RooRealVar(""gen"",""x*y"",RooArgList(x,y)) or; RooRealVar(""gen"",""@0*@1"",RooArgList(x,y)). The latter form, while slightly less readable, is more versatile because it; doesn't hardcode any of the variable names it expects. Function Members (Methods); public:. RooFormulaVar(); RooFormulaVar(const RooFormulaVar& other, const char* name = 0); RooFormulaVar(const char* name, const char* title, const RooArgList& dependents); RooFormulaVar(const char* name, const char* title, const char* formula, const RooArgList& dependents); virtual~RooFormulaVar(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooFormulaVar.html:556,perform,perform,556,root/html528/RooFormulaVar.html,https://root.cern,https://root.cern/root/html528/RooFormulaVar.html,3,['perform'],['perform']
Performance,". RooFormulaVar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooFormulaVar. class RooFormulaVar: public RooAbsReal. RooRealVar is a generic implementation of a real valued object; which takes a RooArgList of servers and a C++ expression string defining how; its value should be calculated from the given list of servers.; RooRealVar uses a RooFormula object to perform the expression evaluation. If RooAbsPdf objects are supplied to RooRealVar as servers, their; raw (unnormalized) values will be evaluated. Use RooGenericPdf, which; constructs generic PDF functions, to access their properly normalized; values. The string expression can be any valid TFormula expression referring to the; listed servers either by name or by their ordinal list position:. RooRealVar(""gen"",""x*y"",RooArgList(x,y)) or; RooRealVar(""gen"",""@0*@1"",RooArgList(x,y)). The latter form, while slightly less readable, is more versatile because it; doesn't hardcode any of the variable names it expects. Function Members (Methods); public:. RooFormulaVar(); RooFormulaVar(const RooFormulaVar& other, const char* name = 0); RooFormulaVar(const char* name, const char* title, const RooArgList& dependents); RooFormulaVar(const char* name, const char* title, const char* formula, const RooArgList& dependents); virtual~RooFormulaVar(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFormulaVar.html:556,perform,perform,556,root/html526/RooFormulaVar.html,https://root.cern,https://root.cern/root/html526/RooFormulaVar.html,1,['perform'],['perform']
Performance,". RooGenCategory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooGenCategory. class RooGenCategory: public RooAbsCategory. RooGenCategory provides the most flexibe mapping of a series of input categories; on a output category via a global function provided in the constructor; ; The mapping function must have the form 'const char* mapFunc(const RooArgSet* catList)'; and return the name of the output state for the list of categories supplied in the argument.; The global function can be a ROOT interpreted function.; ; RooGenCategory builds a numerical index-to-index map from the user function; to achieve a high performance mapping.; . Function Members (Methods); public:. RooGenCategory(); RooGenCategory(const RooGenCategory& other, const char* name = 0); RooGenCategory(const char* name, const char* title, void* userFunc, RooArgSet& catList); virtual~RooGenCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGenCategory.html:811,perform,performance,811,root/html528/RooGenCategory.html,https://root.cern,https://root.cern/root/html528/RooGenCategory.html,4,['perform'],['performance']
Performance,". RooGenCategory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooGenCategory. class RooGenCategory: public RooAbsCategory. RooGenCategory provides the most flexibe mapping of a series of input categories; on a output category via a global function provided in the constructor; ; The mapping function must have the form 'const char* mapFunc(const RooArgSet* catList)'; and return the name of the output state for the list of categories supplied in the argument.; The global function can be a ROOT interpreted function.; ; RooGenCategory builds a numerical index-to-index map from the user function; to achieve a high performance mapping.; . Function Members (Methods); public:. RooGenCategory(); RooGenCategory(const RooGenCategory& other, const char* name = 0); RooGenCategory(const char* name, const char* title, void* userFunc, RooArgSet& catList); virtual~RooGenCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGenCategory.html:811,perform,performance,811,root/html526/RooGenCategory.html,https://root.cern,https://root.cern/root/html526/RooGenCategory.html,1,['perform'],['performance']
Performance,". RooGenericPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooGenericPdf. class RooGenericPdf: public RooAbsPdf. RooGenericPdf is a concrete implementation of a probability density function,; which takes a RooArgList of servers and a C++ expression string defining how; its value should be calculated from the given list of servers.; A fully numerical integration is automatically performed to normalize the given; expression. RooGenericPdf uses a RooFormula object to perform the expression evaluation; The string expression can be any valid TFormula expression referring to the; listed servers either by name or by their ordinal list position:; RooGenericPdf(""gen"",""x*y"",RooArgList(x,y)) or; RooGenericPdf(""gen"",""@0*@1"",RooArgList(x,y)) ; The latter form, while slightly less readable, is more versatile because it; doesn't hardcode any of the variable names it expects; . Function Members (Methods); public:. RooGenericPdf(); RooGenericPdf(const RooGenericPdf& other, const char* name = 0); RooGenericPdf(const char* name, const char* title, const RooArgList& dependents); RooGenericPdf(const char* name, const char* title, const char* formula, const RooArgList& dependents); virtual~RooGenericPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGenericPdf.html:578,perform,performed,578,root/html528/RooGenericPdf.html,https://root.cern,https://root.cern/root/html528/RooGenericPdf.html,8,['perform'],"['perform', 'performed']"
Performance,". RooGenericPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooGenericPdf. class RooGenericPdf: public RooAbsPdf. RooGenericPdf is a concrete implementation of a probability density function,; which takes a RooArgList of servers and a C++ expression string defining how; its value should be calculated from the given list of servers.; A fully numerical integration is automatically performed to normalize the given; expression. RooGenericPdf uses a RooFormula object to perform the expression evaluation; The string expression can be any valid TFormula expression referring to the; listed servers either by name or by their ordinal list position:; RooGenericPdf(""gen"",""x*y"",RooArgList(x,y)) or; RooGenericPdf(""gen"",""@0*@1"",RooArgList(x,y)) ; The latter form, while slightly less readable, is more versatile because it; doesn't hardcode any of the variable names it expects; . Function Members (Methods); public:. RooGenericPdf(); RooGenericPdf(const RooGenericPdf& other, const char* name = 0); RooGenericPdf(const char* name, const char* title, const RooArgList& dependents); RooGenericPdf(const char* name, const char* title, const char* formula, const RooArgList& dependents); virtual~RooGenericPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGenericPdf.html:578,perform,performed,578,root/html526/RooGenericPdf.html,https://root.cern,https://root.cern/root/html526/RooGenericPdf.html,2,['perform'],"['perform', 'performed']"
Performance,". RooGenericPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooGenericPdf. class RooGenericPdf: public RooAbsPdf. RooGenericPdf is a concrete implementation of a probability density function,; which takes a RooArgList of servers and a C++ expression string defining how; its value should be calculated from the given list of servers.; A fully numerical integration is automatically performed to normalize the given; expression. RooGenericPdf uses a RooFormula object to perform the expression evaluation; The string expression can be any valid TFormula expression referring to the; listed servers either by name or by their ordinal list position:; RooGenericPdf(""gen"",""x*y"",RooArgList(x,y)) or; RooGenericPdf(""gen"",""@0*@1"",RooArgList(x,y)) ; The latter form, while slightly less readable, is more versatile because it; doesn't hardcode any of the variable names it expects; . Function Members (Methods); public:. virtual~RooGenericPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGenericPdf.html:578,perform,performed,578,root/html602/RooGenericPdf.html,https://root.cern,https://root.cern/root/html602/RooGenericPdf.html,4,['perform'],"['perform', 'performed']"
Performance,". RooLinkedList_altNonSharedBinningNon-shareable alternative binnings; Double_t_asymErrHiHigh side of asymmetric error associated with current value; Double_t_asymErrLoLow side of asymmetric error associated with current value; RooAbsBinning*_binning; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_errorSymmetric error associated with current value; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealVar.html:36715,cache,cache,36715,root/html532/RooRealVar.html,https://root.cern,https://root.cern/root/html532/RooRealVar.html,5,['cache'],"['cache', 'caches']"
Performance,". RooMCStudy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooMCStudy. class RooMCStudy: public TNamed. RooMCStudy is a help class to facilitate Monte Carlo studies; such as 'goodness-of-fit' studies, that involve fitting a PDF ; to multiple toy Monte Carlo sets generated from the same PDF ; or another PDF.; ; Given a fit PDF and a generator PDF, RooMCStudy can produce; large numbers of toyMC samples and/or fit these samples; and acculumate the final parameters of each fit in a dataset.; ; Additional plotting routines simplify the task of plotting; the distribution of the minimized likelihood, each parameters fitted value, ; fitted error and pull distribution.; ; Class RooMCStudy provides the option to insert add-in modules; that modify the generate and fit cycle and allow to perform; extra steps in the cycle. Output of these modules can be stored; alongside the fit results in the aggregate results dataset.; These study modules should derive from classs RooAbsMCStudyModel; . Function Members (Methods); public:. RooMCStudy(const RooAbsPdf& genModel, const RooAbsPdf& fitModel, const RooArgSet& dependents, const char* genOptions = """", const char* fitOptions = """", const RooDataSet* genProtoData = 0, const RooArgSet& projDeps = RooArgSet()); RooMCStudy(const RooAbsPdf& model, const RooArgSet& observables, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual~RooMCStudy(); voidTObject::AbstractMethod(const char* method) const; Bool_taddFitResult(const RooFitResult& fr); voidaddModule(RooAbsMCStudyModule& module); virtual voidTObject::AppendPad(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMCStudy.html:981,perform,perform,981,root/html526/RooMCStudy.html,https://root.cern,https://root.cern/root/html526/RooMCStudy.html,1,['perform'],['perform']
Performance,". RooMCStudy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooMCStudy. class RooMCStudy: public TNamed. RooMCStudy is a help class to facilitate Monte Carlo studies; such as 'goodness-of-fit' studies, that involve fitting a PDF ; to multiple toy Monte Carlo sets generated from the same PDF ; or another PDF.; ; Given a fit PDF and a generator PDF, RooMCStudy can produce; large numbers of toyMC samples and/or fit these samples; and acculumate the final parameters of each fit in a dataset.; ; Additional plotting routines simplify the task of plotting; the distribution of the minimized likelihood, each parameters fitted value, ; fitted error and pull distribution.; ; Class RooMCStudy provides the option to insert add-in modules; that modify the generate and fit cycle and allow to perform; extra steps in the cycle. Output of these modules can be stored; alongside the fit results in the aggregate results dataset.; These study modules should derive from classs RooAbsMCStudyModel; . Function Members (Methods); public:. RooMCStudy(const RooAbsPdf& genModel, const RooAbsPdf& fitModel, const RooArgSet& dependents, const char* genOptions = """", const char* fitOptions = """", const RooDataSet* genProtoData = 0, const RooArgSet& projDeps = RooArgSet()); RooMCStudy(const RooAbsPdf& model, const RooArgSet& observables, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual~RooMCStudy(); voidTObject::AbstractMethod(const char* method) const; Bool_taddFitResult(const RooFitResult& fr); voidaddModule(RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMCStudy.html:981,perform,perform,981,root/html528/RooMCStudy.html,https://root.cern,https://root.cern/root/html528/RooMCStudy.html,4,['perform'],['perform']
Performance,". RooMCStudy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooMCStudy. class RooMCStudy: public TNamed. RooMCStudy is a help class to facilitate Monte Carlo studies; such as 'goodness-of-fit' studies, that involve fitting a PDF ; to multiple toy Monte Carlo sets generated from the same PDF ; or another PDF.; ; Given a fit PDF and a generator PDF, RooMCStudy can produce; large numbers of toyMC samples and/or fit these samples; and acculumate the final parameters of each fit in a dataset.; ; Additional plotting routines simplify the task of plotting; the distribution of the minimized likelihood, each parameters fitted value, ; fitted error and pull distribution.; ; Class RooMCStudy provides the option to insert add-in modules; that modify the generate and fit cycle and allow to perform; extra steps in the cycle. Output of these modules can be stored; alongside the fit results in the aggregate results dataset.; These study modules should derive from classs RooAbsMCStudyModel; . Function Members (Methods); public:. virtual~RooMCStudy(); voidTObject::AbstractMethod(const char* method) const; Bool_taddFitResult(const RooFitResult& fr); voidaddModule(RooAbsMCStudyModule& module); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMCStudy.html:981,perform,perform,981,root/html602/RooMCStudy.html,https://root.cern,https://root.cern/root/html602/RooMCStudy.html,2,['perform'],['perform']
Performance,". RooNormSetCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooNormSetCache. class RooNormSetCache. Class RooNormSet cache manage the bookkeeping of multiple instances; of sets of integration and normalization observables that effectively; have the same definition. In complex function expression many; RooArgSets with the same contents may be passed to an object that; caches intermediate results dependent on the normalization/integration set; To avoid unnecessary cache faulting, This class tracks all instances; with the same contents and reports to the owner if the present nset/iset; is truely different from the current reference. Class RooNormSet only; evaluates each RooArgSet pointer once, it therefore assumes that; RooArgSets with normalization and/or integration sets are not changes; during their lifetime. ; . Function Members (Methods); public:. RooNormSetCache(Int_t regSize = 10); RooNormSetCache(const RooNormSetCache& other); virtual~RooNormSetCache(); voidadd(const RooArgSet* set1, const RooArgSet* set2 = 0); Bool_tautoCache(const RooAbsArg* self, const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0, Bool_t autoRefill = kTRUE); static TClass*Class(); voidclear(); Bool_tcontains(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); Bool_tcontainsSet1(const RooArgSet* set1); Int_tentries() const; Int_tindex(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); voidinitialize(const RooNormSetCache& other); virtual TClass*IsA() const; const RooArgSet*lastSet1() const; const RooArgSet*lastSet2() const; const RooNameSet&nameSet1() const; const RooNameSet&nameSet2() const; RooNormSetCache&operator=(const RooNormSetCache&); virtual voidShowMembers(TMemberInspector& insp); virtual voidSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNormSetCache.html:315,cache,cache,315,root/html528/RooNormSetCache.html,https://root.cern,https://root.cern/root/html528/RooNormSetCache.html,3,['cache'],"['cache', 'caches']"
Performance,". RooNormSetCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooNormSetCache. class RooNormSetCache. Class RooNormSet cache manage the bookkeeping of multiple instances; of sets of integration and normalization observables that effectively; have the same definition. In complex function expression many; RooArgSets with the same contents may be passed to an object that; caches intermediate results dependent on the normalization/integration set; To avoid unnecessary cache faulting, This class tracks all instances; with the same contents and reports to the owner if the present nset/iset; is truely different from the current reference. Class RooNormSet only; evaluates each RooArgSet pointer once, it therefore assumes that; RooArgSets with normalization and/or integration sets are not changes; during their lifetime. ; . Function Members (Methods); public:. RooNormSetCache(Int_t regSize = 10); RooNormSetCache(const RooNormSetCache& other); virtual~RooNormSetCache(); voidadd(const RooArgSet* set1, const RooArgSet* set2 = 0); Bool_tautoCache(const RooAbsArg* self, const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0, Bool_t autoRefill = kTRUE); static TClass*Class(); voidclear(); Bool_tcontains(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); Bool_tcontainsSet1(const RooArgSet* set1); Int_tentries() const; Int_tindex(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); voidinitialize(const RooNormSetCache& other); virtual TClass*IsA() const; const RooArgSet*lastSet1() const; const RooArgSet*lastSet2() const; const RooNameSet&nameSet1() const; const RooNameSet&nameSet2() const; RooNormSetCache&operator=(const RooNormSetCache&); virtual voidShowMembers(TMemberInspector& insp, char* parent); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNormSetCache.html:315,cache,cache,315,root/html526/RooNormSetCache.html,https://root.cern,https://root.cern/root/html526/RooNormSetCache.html,3,['cache'],"['cache', 'caches']"
Performance,". RooNormSetCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooNormSetCache. class RooNormSetCache. Class RooNormSet cache manage the bookkeeping of multiple instances; of sets of integration and normalization observables that effectively; have the same definition. In complex function expression many; RooArgSets with the same contents may be passed to an object that; caches intermediate results dependent on the normalization/integration set; To avoid unnecessary cache faulting, This class tracks all instances; with the same contents and reports to the owner if the present nset/iset; is truely different from the current reference. Class RooNormSet only; evaluates each RooArgSet pointer once, it therefore assumes that; RooArgSets with normalization and/or integration sets are not changes; during their lifetime. ; . Function Members (Methods); public:. RooNormSetCache(Int_t regSize = 64); RooNormSetCache(const RooNormSetCache& other); virtual~RooNormSetCache(); voidadd(const RooArgSet* set1, const RooArgSet* set2 = 0); Bool_tautoCache(const RooAbsArg* self, const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0, Bool_t autoRefill = kTRUE); static TClass*Class(); voidclear(); Bool_tcontains(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); Bool_tcontainsSet1(const RooArgSet* set1); Int_tentries() const; Int_tindex(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); voidinitialize(const RooNormSetCache& other); virtual TClass*IsA() const; const RooArgSet*lastSet1() const; const RooArgSet*lastSet2() const; const RooNameSet&nameSet1() const; const RooNameSet&nameSet2() const; RooNormSetCache&operator=(const RooNormSetCache&); virtual voidShowMembers(TMemberInspector& insp); virtual voidSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNormSetCache.html:315,cache,cache,315,root/html530/RooNormSetCache.html,https://root.cern,https://root.cern/root/html530/RooNormSetCache.html,6,['cache'],"['cache', 'caches']"
Performance,". RooNormSetCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooNormSetCache. class RooNormSetCache. Class RooNormSet cache manage the bookkeeping of multiple instances; of sets of integration and normalization observables that effectively; have the same definition. In complex function expression many; RooArgSets with the same contents may be passed to an object that; caches intermediate results dependent on the normalization/integration set; To avoid unnecessary cache faulting, This class tracks all instances; with the same contents and reports to the owner if the present nset/iset; is truely different from the current reference. Class RooNormSet only; evaluates each RooArgSet pointer once, it therefore assumes that; RooArgSets with normalization and/or integration sets are not changes; during their lifetime. ; . Function Members (Methods); public:. RooNormSetCache(ULong_t max = 32); RooNormSetCache(const RooNormSetCache&); virtual~RooNormSetCache(); voidadd(const RooArgSet* set1, const RooArgSet* set2 = 0); Bool_tautoCache(const RooAbsArg* self, const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0, Bool_t autoRefill = kTRUE); static TClass*Class(); voidclear(); Bool_tcontains(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); Bool_tcontainsSet1(const RooArgSet* set1); Int_tentries() const; Int_tindex(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); voidinitialize(const RooNormSetCache& other); virtual TClass*IsA() const; const RooArgSet*lastSet1() const; const RooArgSet*lastSet2() const; const RooNameSet&nameSet1() const; const RooNameSet&nameSet2() const; RooNormSetCache&operator=(const RooNormSetCache&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNormSetCache.html:315,cache,cache,315,root/html534/RooNormSetCache.html,https://root.cern,https://root.cern/root/html534/RooNormSetCache.html,3,['cache'],"['cache', 'caches']"
Performance,". RooNormSetCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooNormSetCache. class RooNormSetCache. Class RooNormSet cache manage the bookkeeping of multiple instances; of sets of integration and normalization observables that effectively; have the same definition. In complex function expression many; RooArgSets with the same contents may be passed to an object that; caches intermediate results dependent on the normalization/integration set; To avoid unnecessary cache faulting, This class tracks all instances; with the same contents and reports to the owner if the present nset/iset; is truely different from the current reference. Class RooNormSet only; evaluates each RooArgSet pointer once, it therefore assumes that; RooArgSets with normalization and/or integration sets are not changes; during their lifetime. ; . Function Members (Methods); public:. virtual~RooNormSetCache(); voidadd(const RooArgSet* set1, const RooArgSet* set2 = 0); Bool_tautoCache(const RooAbsArg* self, const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0, Bool_t autoRefill = kTRUE); static TClass*Class(); voidclear(); Bool_tcontains(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); Bool_tcontainsSet1(const RooArgSet* set1); Int_tentries() const; Int_tindex(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); voidinitialize(const RooNormSetCache& other); virtual TClass*IsA() const; const RooArgSet*lastSet1() const; const RooArgSet*lastSet2() const; const RooNameSet&nameSet1() const; const RooNameSet&nameSet2() const; RooNormSetCache&operator=(const RooNormSetCache&); RooNormSetCache(ULong_t max = 32); RooNormSetCache(const RooNormSetCache&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNormSetCache.html:315,cache,cache,315,root/html602/RooNormSetCache.html,https://root.cern,https://root.cern/root/html602/RooNormSetCache.html,6,['cache'],"['cache', 'caches']"
Performance,". RooNumGenFactory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooNumGenFactory. class RooNumGenFactory: public TObject. RooNumGenFactory is a factory to instantiate numeric integrators; from a given function binding and a given configuration. The factory; searches for a numeric integrator registered with the factory that; has the ability to perform the numeric integration. The choice of; method may depend on the number of dimensions integrated,; the nature of the integration limits (closed or open ended) and; the preference of the caller as encoded in the configuration object.; . Function Members (Methods); public:. virtual~RooNumGenFactory(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; RooAbsNumGenerator*createSampler(RooAbsReal& func, const RooArgSet& genVars, const RooArgSet& condVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, RooAbsReal* maxFuncVal = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumGenFactory.html:540,perform,perform,540,root/html526/RooNumGenFactory.html,https://root.cern,https://root.cern/root/html526/RooNumGenFactory.html,7,['perform'],['perform']
Performance,". RooNumIntFactory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooNumIntFactory. class RooNumIntFactory: public TObject. RooNumIntFactory is a factory to instantiate numeric integrators; from a given function binding and a given configuration. The factory; searches for a numeric integrator registered with the factory that; has the ability to perform the numeric integration. The choice of; method may depend on the number of dimensions integrated,; the nature of the integration limits (closed or open ended) and; the preference of the caller as encoded in the configuration object.; . Function Members (Methods); public:. virtual~RooNumIntFactory(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; RooAbsIntegrator*createIntegrator(RooAbsFunc& func, const RooNumIntConfig& config, Int_t ndim = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumIntFactory.html:540,perform,perform,540,root/html526/RooNumIntFactory.html,https://root.cern,https://root.cern/root/html526/RooNumIntFactory.html,4,['perform'],['perform']
Performance,". RooNumIntFactory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooNumIntFactory. class RooNumIntFactory: public TObject. RooNumIntFactory is a factory to instantiate numeric integrators; from a given function binding and a given configuration. The factory; searches for a numeric integrator registered with the factory that; has the ability to perform the numeric integration. The choice of; method may depend on the number of dimensions integrated,; the nature of the integration limits (closed or open ended) and; the preference of the caller as encoded in the configuration object.; . Function Members (Methods); public:. virtual~RooNumIntFactory(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; RooAbsIntegrator*createIntegrator(RooAbsFunc& func, const RooNumIntConfig& config, Int_t ndim = 0, Bool_t isBinned = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumIntFactory.html:540,perform,perform,540,root/html534/RooNumIntFactory.html,https://root.cern,https://root.cern/root/html534/RooNumIntFactory.html,3,['perform'],['perform']
Performance,". RooNumRunningInt. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooNumRunningInt. class RooNumRunningInt: public RooAbsCachedReal. Class RooNumRunningInt is an implementation of RooAbsCachedReal that represents a running integral; ; RI(f(x)) = Int[x_lo,x] f(x') dx'; ; that is calculated internally with a numeric technique: The input function; is first sampled into a histogram, which is then numerically integrated.; The output function is an interpolated version of the integrated histogram.; The sampling density is controlled by the binning named ""cache"" in the observable x.; The shape of the p.d.f is always calculated for the entire domain in x and; cached in a histogram. The cache histogram is automatically recalculated; when any of the parameters of the input p.d.f. has changed.; . Function Members (Methods); public:. RooNumRunningInt(const RooNumRunningInt& other, const char* name = 0); RooNumRunningInt(const char* name, const char* title, RooAbsReal& _func, RooRealVar& _x, const char* binningName = ""cache""); virtual~RooNumRunningInt(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNumRunningInt.html:748,cache,cache,748,root/html528/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html528/RooNumRunningInt.html,12,['cache'],"['cache', 'cached']"
Performance,". RooNumRunningInt. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooNumRunningInt. class RooNumRunningInt: public RooAbsCachedReal. Class RooNumRunningInt is an implementation of RooAbsCachedReal that represents a running integral; ; RI(f(x)) = Int[x_lo,x] f(x') dx'; ; that is calculated internally with a numeric technique: The input function; is first sampled into a histogram, which is then numerically integrated.; The output function is an interpolated version of the integrated histogram.; The sampling density is controlled by the binning named ""cache"" in the observable x.; The shape of the p.d.f is always calculated for the entire domain in x and; cached in a histogram. The cache histogram is automatically recalculated; when any of the parameters of the input p.d.f. has changed.; . Function Members (Methods); public:. RooNumRunningInt(const RooNumRunningInt& other, const char* name = 0); RooNumRunningInt(const char* name, const char* title, RooAbsReal& _func, RooRealVar& _x, const char* binningName = ""cache""); virtual~RooNumRunningInt(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumRunningInt.html:748,cache,cache,748,root/html526/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html526/RooNumRunningInt.html,3,['cache'],"['cache', 'cached']"
Performance,". RooNumRunningInt. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooNumRunningInt. class RooNumRunningInt: public RooAbsCachedReal. Class RooNumRunningInt is an implementation of RooAbsCachedReal that represents a running integral; ; RI(f(x)) = Int[x_lo,x] f(x') dx'; ; that is calculated internally with a numeric technique: The input function; is first sampled into a histogram, which is then numerically integrated.; The output function is an interpolated version of the integrated histogram.; The sampling density is controlled by the binning named ""cache"" in the observable x.; The shape of the p.d.f is always calculated for the entire domain in x and; cached in a histogram. The cache histogram is automatically recalculated; when any of the parameters of the input p.d.f. has changed.; . Function Members (Methods); public:. virtual~RooNumRunningInt(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsDa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumRunningInt.html:748,cache,cache,748,root/html602/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html602/RooNumRunningInt.html,6,['cache'],"['cache', 'cached']"
Performance,". RooObjCacheManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooObjCacheManager. class RooObjCacheManager: public RooCacheManager<RooAbsCacheElement>. Class RooObjCacheManager is an implementation of class RooCacheManager; and specializes in the storage of cache elements that contain RooAbsArg objects.; Caches with RooAbsArg derived payload require special care as server redirects; cache operation mode changes and constant term optimization calls may need to be; forwarded to such cache payload. This cache manager takes are of all these operations; by forwarding these calls to the RooAbsCacheElement interface functions, which; have a sensible default implementation. ; . Function Members (Methods); public:. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); virtual~RooObjCacheManager(); Int_tRooCacheManager<RooAbsCacheElement>::cacheSize() const; static TClass*Class(); static Bool_tclearObsList(); static voiddoClearObsList(Bool_t flag); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObjByIndex(Int_t index) const; virtual voidinsertObjectHook(RooAbsCacheElement&); virtual TClass*IsA() const; Int_tRooCacheManager<RooAbsCacheElement>::lastIndex() const; const RooNameSet*RooCacheManager<RooAbsCacheElement>::nameSet1ByIndex(Int_t index) const; const RooNameSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooObjCacheManager.html:457,cache,cache,457,root/html530/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html530/RooObjCacheManager.html,6,"['Cache', 'cache', 'optimiz']","['Caches', 'cache', 'optimization']"
Performance,". RooObjCacheManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooObjCacheManager. class RooObjCacheManager: public RooCacheManager<RooAbsCacheElement>. Class RooObjCacheManager is an implementation of class RooCacheManager; and specializes in the storage of cache elements that contain RooAbsArg objects.; Caches with RooAbsArg derived payload require special care as server redirects; cache operation mode changes and constant term optimization calls may need to be; forwarded to such cache payload. This cache manager takes are of all these operations; by forwarding these calls to the RooAbsCacheElement interface functions, which; have a sensible default implementation. ; . Function Members (Methods); public:. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); virtual~RooObjCacheManager(); Int_tRooCacheManager<RooAbsCacheElement>::cacheSize() const; static TClass*Class(); static Bool_tclearObsList(); static voiddoClearObsList(Bool_t flag); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx, const char* isetRangeName); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObjByIndex(Int_t index) const; virtual voidinsertObjectHook(RooAbsCacheElement&); virtual TClass*IsA() const; Int_tRooCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooObjCacheManager.html:457,cache,cache,457,root/html532/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html532/RooObjCacheManager.html,6,"['Cache', 'cache', 'optimiz']","['Caches', 'cache', 'optimization']"
Performance,". RooObjCacheManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooObjCacheManager. class RooObjCacheManager: public RooCacheManager<RooAbsCacheElement>. Class RooObjCacheManager is an implementation of class RooCacheManager; and specializes in the storage of cache elements that contain RooAbsArg objects.; Caches with RooAbsArg derived payload require special care as server redirects; cache operation mode changes and constant term optimization calls may need to be; forwarded to such cache payload. This cache manager takes are of all these operations; by forwarding these calls to the RooAbsCacheElement interface functions, which; have a sensible default implementation. ; . Function Members (Methods); public:. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); virtual~RooObjCacheManager(); Int_tRooCacheManager<RooAbsCacheElement>::cacheSize() const; static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObjByIndex(Int_t index) const; virtual voidinsertObjectHook(RooAbsCacheElement&); virtual TClass*IsA() const; Int_tRooCacheManager<RooAbsCacheElement>::lastIndex() const; const RooNameSet*RooCacheManager<RooAbsCacheElement>::nameSet1ByIndex(Int_t index) const; const RooNameSet*RooCacheManager<RooAbsCacheElement>::nameSet2ByIndex(Int_t index) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooObjCacheManager.html:457,cache,cache,457,root/html526/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html526/RooObjCacheManager.html,12,"['Cache', 'cache', 'optimiz']","['Caches', 'cache', 'optimization']"
Performance,". RooObjCacheManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooObjCacheManager. class RooObjCacheManager: public RooCacheManager<RooAbsCacheElement>. Class RooObjCacheManager is an implementation of class RooCacheManager; and specializes in the storage of cache elements that contain RooAbsArg objects.; Caches with RooAbsArg derived payload require special care as server redirects; cache operation mode changes and constant term optimization calls may need to be; forwarded to such cache payload. This cache manager takes are of all these operations; by forwarding these calls to the RooAbsCacheElement interface functions, which; have a sensible default implementation. ; . Function Members (Methods); public:. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 2, Bool_t clearCacheOnServerRedirect = kTRUE, Bool_t allowOptimize = kFALSE); virtual~RooObjCacheManager(); Int_tRooCacheManager<RooAbsCacheElement>::cacheSize() const; static TClass*Class(); static Bool_tclearObsList(); static voiddoClearObsList(Bool_t flag); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx, const char* isetRangeName); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObjByIndex(Int_t index) const; virtual voidinsertObjectHook(RooAbsCacheElement&); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooObjCacheManager.html:457,cache,cache,457,root/html534/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html534/RooObjCacheManager.html,6,"['Cache', 'cache', 'optimiz']","['Caches', 'cache', 'optimization']"
Performance,". RooObjCacheManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooObjCacheManager. class RooObjCacheManager: public RooCacheManager<RooAbsCacheElement>. Class RooObjCacheManager is an implementation of class RooCacheManager; and specializes in the storage of cache elements that contain RooAbsArg objects.; Caches with RooAbsArg derived payload require special care as server redirects; cache operation mode changes and constant term optimization calls may need to be; forwarded to such cache payload. This cache manager takes are of all these operations; by forwarding these calls to the RooAbsCacheElement interface functions, which; have a sensible default implementation. ; . Function Members (Methods); public:. virtual~RooObjCacheManager(); Int_tRooCacheManager<RooAbsCacheElement>::cacheSize() const; static TClass*Class(); static Bool_tclearObsList(); static voiddoClearObsList(Bool_t flag); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx, const char* isetRangeName); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObjByIndex(Int_t index) const; virtual voidinsertObjectHook(RooAbsCacheElement&); virtual TClass*IsA() const; Int_tRooCacheManager<RooAbsCacheElement>::lastIndex() const; const RooNameSet*RooCacheManager<RooAbsCacheElement>::nameSet1ByIndex(Int_t index) const; const RooNameSet*RooCacheManager<RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooObjCacheManager.html:457,cache,cache,457,root/html602/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html602/RooObjCacheManager.html,12,"['Cache', 'cache', 'optimiz']","['Caches', 'cache', 'optimization']"
Performance,". RooProjectedPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooProjectedPdf. class RooProjectedPdf: public RooAbsPdf. Class RooProjectedPdf is a RooAbsPdf implementation that represent a projection ; of a given input p.d.f and the object returned by RooAbsPdf::createProjection.; ; The actual projection integral for it value and normalization are; calculated on the fly in getVal() once the normalization observables are known.; Class RooProjectedPdf can cache projected p.d.f.s for multiple normalization; observables simultaneously.; ; The createProjection() method of RooProjectedPdf is overloaded and will; return a new RooProjectedPdf that performs the projection of itself; and the requested additional projections in one integration step; The performance of f->createProjection(x)->createProjection(y); is therefore identical to that of f->createProjection(RooArgSet(x,y)). Function Members (Methods); public:. RooProjectedPdf(); RooProjectedPdf(const RooProjectedPdf& other, const char* name = 0); RooProjectedPdf(const char* name, const char* title, RooAbsReal& _intpdf, const RooArgSet& intObs); virtual~RooProjectedPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProjectedPdf.html:654,cache,cache,654,root/html528/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html528/RooProjectedPdf.html,12,"['cache', 'perform']","['cache', 'performance', 'performs']"
Performance,". RooProjectedPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooProjectedPdf. class RooProjectedPdf: public RooAbsPdf. Class RooProjectedPdf is a RooAbsPdf implementation that represent a projection ; of a given input p.d.f and the object returned by RooAbsPdf::createProjection.; ; The actual projection integral for it value and normalization are; calculated on the fly in getVal() once the normalization observables are known.; Class RooProjectedPdf can cache projected p.d.f.s for multiple normalization; observables simultaneously.; ; The createProjection() method of RooProjectedPdf is overloaded and will; return a new RooProjectedPdf that performs the projection of itself; and the requested additional projections in one integration step; The performance of f->createProjection(x)->createProjection(y); is therefore identical to that of f->createProjection(RooArgSet(x,y)). Function Members (Methods); public:. RooProjectedPdf(); RooProjectedPdf(const RooProjectedPdf& other, const char* name = 0); RooProjectedPdf(const char* name, const char* title, RooAbsReal& _intpdf, const RooArgSet& intObs); virtual~RooProjectedPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::App",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProjectedPdf.html:654,cache,cache,654,root/html526/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html526/RooProjectedPdf.html,3,"['cache', 'perform']","['cache', 'performance', 'performs']"
Performance,". RooProjectedPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooProjectedPdf. class RooProjectedPdf: public RooAbsPdf. Class RooProjectedPdf is a RooAbsPdf implementation that represent a projection ; of a given input p.d.f and the object returned by RooAbsPdf::createProjection.; ; The actual projection integral for it value and normalization are; calculated on the fly in getVal() once the normalization observables are known.; Class RooProjectedPdf can cache projected p.d.f.s for multiple normalization; observables simultaneously.; ; The createProjection() method of RooProjectedPdf is overloaded and will; return a new RooProjectedPdf that performs the projection of itself; and the requested additional projections in one integration step; The performance of f->createProjection(x)->createProjection(y); is therefore identical to that of f->createProjection(RooArgSet(x,y)). Function Members (Methods); public:. virtual~RooProjectedPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProjectedPdf.html:654,cache,cache,654,root/html602/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html602/RooProjectedPdf.html,6,"['cache', 'perform']","['cache', 'performance', 'performs']"
Performance,". RooRealIntegral. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealIntegral. class RooRealIntegral: public RooAbsReal. RooRealIntegral performs hybrid numerical/analytical integrals of RooAbsReal objects; The class performs none of the actual integration, but only manages the logic; of what variables can be integrated analytically, accounts for eventual jacobian; terms and defines what numerical integrations needs to be done to complement the; analytical integral.; ; The actual analytical integrations (if any) are done in the PDF themselves, the numerical; integration is performed in the various implemenations of the RooAbsIntegrator base class.; . Function Members (Methods); public:. RooRealIntegral(); RooRealIntegral(const RooRealIntegral& other, const char* name = 0); RooRealIntegral(const char* name, const char* title, const RooAbsReal& function, const RooArgSet& depList, const RooArgSet* funcNormSet = 0, const RooNumIntConfig* config = 0, const char* rangeName = 0); virtual~RooRealIntegral(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const RooArgSet&anaIntVars() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealIntegral.html:333,perform,performs,333,root/html526/RooRealIntegral.html,https://root.cern,https://root.cern/root/html526/RooRealIntegral.html,3,['perform'],"['performed', 'performs']"
Performance,". RooRealIntegral. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealIntegral. class RooRealIntegral: public RooAbsReal. RooRealIntegral performs hybrid numerical/analytical integrals of RooAbsReal objects; The class performs none of the actual integration, but only manages the logic; of what variables can be integrated analytically, accounts for eventual jacobian; terms and defines what numerical integrations needs to be done to complement the; analytical integral.; ; The actual analytical integrations (if any) are done in the PDF themselves, the numerical; integration is performed in the various implemenations of the RooAbsIntegrator base class.; . Function Members (Methods); public:. RooRealIntegral(); RooRealIntegral(const RooRealIntegral& other, const char* name = 0); RooRealIntegral(const char* name, const char* title, const RooAbsReal& function, const RooArgSet& depList, const RooArgSet* funcNormSet = 0, const RooNumIntConfig* config = 0, const char* rangeName = 0); virtual~RooRealIntegral(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; const RooArgSet&anaIntVars() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooRealIntegral.html:333,perform,performs,333,root/html528/RooRealIntegral.html,https://root.cern,https://root.cern/root/html528/RooRealIntegral.html,12,['perform'],"['performed', 'performs']"
Performance,". RooRealIntegral. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooRealIntegral. class RooRealIntegral: public RooAbsReal. RooRealIntegral performs hybrid numerical/analytical integrals of RooAbsReal objects; The class performs none of the actual integration, but only manages the logic; of what variables can be integrated analytically, accounts for eventual jacobian; terms and defines what numerical integrations needs to be done to complement the; analytical integral.; ; The actual analytical integrations (if any) are done in the PDF themselves, the numerical; integration is performed in the various implemenations of the RooAbsIntegrator base class.; . Function Members (Methods); public:. virtual~RooRealIntegral(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; const RooArgSet&anaIntVars() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attribu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealIntegral.html:333,perform,performs,333,root/html602/RooRealIntegral.html,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html,6,['perform'],"['performed', 'performs']"
Performance,". RooStats::HybridCalculator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::HybridCalculator. class RooStats::HybridCalculator: public RooStats::HypoTestCalculator, public TNamed. HybridCalculator class: this class is a fresh rewrite in RooStats of; 	RooStatsCms/LimitCalculator developped by D. Piparo and G. Schott; Authors: D. Piparo, G. Schott - Universitaet Karlsruhe. The class is born from the need to have an implementation of the CLs; method that could take advantage from the RooFit Package.; The basic idea is the following:; - Instantiate an object specifying a signal+background model, a background model and a dataset.; - Perform toy MC experiments to know the distributions of -2lnQ; - Calculate the CLsb and CLs values as ""integrals"" of these distributions. The class allows the user to input models as RooAbsPdf ( TH1 object could be used; by using the RooHistPdf class); The pdfs must be ""extended"": for more information please refer to; http://roofit.sourceforge.net). The dataset can be entered as a; RooAbsData objects. Unlike the TLimit Class a complete MC generation is performed at each step; and not a simple Poisson fluctuation of the contents of the bins.; Another innovation is the treatment of the nuisance parameters. The user; can input in the constructor nuisance parameters.; To include the information that we have about the nuisance parameters a prior; PDF (RooAbsPdf) should be specified. Different test statistic can be used (likelihood ratio, number of events or; profile likelihood ratio. The default is the likelihood ratio.; See the method SetTestStatistic. The number of toys to be generated is controlled by SetNumberOfToys(n). The result of the calculations is returned as a HybridResult object pointer. see also the following interesting references:; - Al",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__HybridCalculator.html:837,Perform,Perform,837,root/html526/RooStats__HybridCalculator.html,https://root.cern,https://root.cern/root/html526/RooStats__HybridCalculator.html,1,['Perform'],['Perform']
Performance,". RooStats::HybridCalculatorOriginal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::HybridCalculatorOriginal. class RooStats::HybridCalculatorOriginal: public RooStats::HypoTestCalculator, public TNamed. HybridCalculatorOriginal class: this class is a fresh rewrite in RooStats of; 	RooStatsCms/LimitCalculator developped by D. Piparo and G. Schott; Authors: D. Piparo, G. Schott - Universitaet Karlsruhe. The class is born from the need to have an implementation of the CLs; method that could take advantage from the RooFit Package.; The basic idea is the following:; - Instantiate an object specifying a signal+background model, a background model and a dataset.; - Perform toy MC experiments to know the distributions of -2lnQ; - Calculate the CLsb and CLs values as ""integrals"" of these distributions. The class allows the user to input models as RooAbsPdf ( TH1 object could be used; by using the RooHistPdf class); The pdfs must be ""extended"": for more information please refer to; http://roofit.sourceforge.net). The dataset can be entered as a; RooAbsData objects. Unlike the TLimit Class a complete MC generation is performed at each step; and not a simple Poisson fluctuation of the contents of the bins.; Another innovation is the treatment of the nuisance parameters. The user; can input in the constructor nuisance parameters.; To include the information that we have about the nuisance parameters a prior; PDF (RooAbsPdf) should be specified. Different test statistic can be used (likelihood ratio, number of events or; profile likelihood ratio. The default is the likelihood ratio.; See the method SetTestStatistic. The number of toys to be generated is controlled by SetNumberOfToys(n). The result of the calculations is returned as a HybridResult object pointer. see also the followi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HybridCalculatorOriginal.html:869,Perform,Perform,869,root/html530/RooStats__HybridCalculatorOriginal.html,https://root.cern,https://root.cern/root/html530/RooStats__HybridCalculatorOriginal.html,5,['Perform'],['Perform']
Performance,". RooStats::HybridCalculatorOriginal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOSTATS; » RooStats::HybridCalculatorOriginal. class RooStats::HybridCalculatorOriginal: public RooStats::HypoTestCalculator, public TNamed. HybridCalculatorOriginal class: this class is a fresh rewrite in RooStats of; 	RooStatsCms/LimitCalculator developped by D. Piparo and G. Schott; Authors: D. Piparo, G. Schott - Universitaet Karlsruhe. The class is born from the need to have an implementation of the CLs; method that could take advantage from the RooFit Package.; The basic idea is the following:; - Instantiate an object specifying a signal+background model, a background model and a dataset.; - Perform toy MC experiments to know the distributions of -2lnQ; - Calculate the CLsb and CLs values as ""integrals"" of these distributions. The class allows the user to input models as RooAbsPdf ( TH1 object could be used; by using the RooHistPdf class); The pdfs must be ""extended"": for more information please refer to; http://roofit.sourceforge.net). The dataset can be entered as a; RooAbsData objects. Unlike the TLimit Class a complete MC generation is performed at each step; and not a simple Poisson fluctuation of the contents of the bins.; Another innovation is the treatment of the nuisance parameters. The user; can input in the constructor nuisance parameters.; To include the information that we have about the nuisance parameters a prior; PDF (RooAbsPdf) should be specified. Different test statistic can be used (likelihood ratio, number of events or; profile likelihood ratio. The default is the likelihood ratio.; See the method SetTestStatistic. The number of toys to be generated is controlled by SetNumberOfToys(n). The result of the calculations is returned as a HybridResult object pointer. see also the following interes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__HybridCalculatorOriginal.html:859,Perform,Perform,859,root/html528/RooStats__HybridCalculatorOriginal.html,https://root.cern,https://root.cern/root/html528/RooStats__HybridCalculatorOriginal.html,1,['Perform'],['Perform']
Performance,". RooStats::HybridPlot. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::HybridPlot. class RooStats::HybridPlot: public TNamed. Class HybridPlot; Authors: D. Piparo, G. Schott - Universitaet Karlsruhe. This class provides the plots for the result of a study performed with the; HybridCalculator class. An example plot is available here:; http://www-ekp.physik.uni-karlsruhe.de/~schott/roostats/hybridplot_example.png. Function Members (Methods); public:. virtual~HybridPlot(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(const char* options = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidDumpToFile(const char* RootFileName, const char* options); voidDumpToImage(const char* filename); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__HybridPlot.html:456,perform,performed,456,root/html526/RooStats__HybridPlot.html,https://root.cern,https://root.cern/root/html526/RooStats__HybridPlot.html,6,['perform'],['performed']
Performance,". RooStats::HybridPlot. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOSTATS; » RooStats::HybridPlot. class RooStats::HybridPlot: public TNamed. Class HybridPlot; Authors: D. Piparo, G. Schott - Universitaet Karlsruhe. This class provides the plots for the result of a study performed with the; HybridCalculator class. An example plot is available here:; http://www-ekp.physik.uni-karlsruhe.de/~schott/roostats/hybridplot_example.png. Function Members (Methods); public:. virtual~HybridPlot(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(const char* options = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidDumpToFile(const char* RootFileName, const char* options); voidDumpToImage(const char* filename); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__HybridPlot.html:446,perform,performed,446,root/html528/RooStats__HybridPlot.html,https://root.cern,https://root.cern/root/html528/RooStats__HybridPlot.html,1,['perform'],['performed']
Performance,". RooStats::HypoTestInverter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::HypoTestInverter. class RooStats::HypoTestInverter: public RooStats::IntervalCalculator, public TNamed. HypoTestInverter class for performing an hypothesis test inversion by scanning the hypothesis test results of the; HybridCalculator for various values of the parameter of interest. By looking at the confidence level curve of; the result an upper limit, where it intersects the desired confidence level, can be derived.; The class implements the RooStats::IntervalCalculator interface and returns an RooStats::HypoTestInverterResult class.; The result is a SimpleInterval, which via the method UpperLimit returns to the user the upper limit value. The HypoTestInverter implements various option for performing the scan. HypoTestInverter::RunFixedScan will scan using a fixed grid the parameter of interest. HypoTestInverter::RunAutoScan will perform an automatic scan to find optimally the curve and it will stop until the desired precision is obtained.; The confidence level value at a given point can be done via HypoTestInverter::RunOnePoint.; The class can scan the CLs+b values or alternativly CLs (if the method HypoTestInverter::UseCLs has been called). New contributions to this class have been written by Matthias Wolf (advanced AutoRun algorithm). Function Members (Methods); public:. virtual~HypoTestInverter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__HypoTestInverter.html:408,perform,performing,408,root/html526/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html526/RooStats__HypoTestInverter.html,2,['perform'],['performing']
Performance,". RooStats::HypoTestInverter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::HypoTestInverter. class RooStats::HypoTestInverter: public RooStats::IntervalCalculator. HypoTestInverter class for performing an hypothesis test inversion by scanning the hypothesis test results of an; HypoTestCalculator for various values of the parameter of interest. By looking at the confidence level curve of; the result an upper limit, where it intersects the desired confidence level, can be derived.; The class implements the RooStats::IntervalCalculator interface and returns an RooStats::HypoTestInverterResult class.; The result is a SimpleInterval, which via the method UpperLimit returns to the user the upper limit value. The HypoTestInverter implements various option for performing the scan. HypoTestInverter::RunFixedScan will scan using a fixed grid the parameter of interest. HypoTestInverter::RunAutoScan will perform an automatic scan to find optimally the curve and it will stop until the desired precision is obtained.; The confidence level value at a given point can be done via HypoTestInverter::RunOnePoint.; The class can scan the CLs+b values or alternativly CLs (if the method HypoTestInverter::UseCLs has been called). Contributions to this class have been written by Giovanni Petrucciani and Annapaola Decosa. Function Members (Methods); public:. virtual~HypoTestInverter(); static TClass*Class(); voidClear(); virtual Double_tConfidenceLevel() const; RooStats::HypoTestCalculatorGeneric*GetHypoTestCalculator() const; virtual RooStats::HypoTestInverterResult*GetInterval() const; RooStats::SamplingDistribution*GetLowerLimitDistribution(bool rebuild = false, int nToys = 100); RooStats::TestStatistic*GetTestStatistic() const; RooStats::SamplingDistribution*GetUpperLimitDistribution(bool re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HypoTestInverter.html:393,perform,performing,393,root/html530/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html530/RooStats__HypoTestInverter.html,10,['perform'],['performing']
Performance,". RooStats::HypoTestInverter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOSTATS; » RooStats::HypoTestInverter. class RooStats::HypoTestInverter: public RooStats::IntervalCalculator, public TNamed. HypoTestInverter class for performing an hypothesis test inversion by scanning the hypothesis test results of the; HybridCalculator for various values of the parameter of interest. By looking at the confidence level curve of; the result an upper limit, where it intersects the desired confidence level, can be derived.; The class implements the RooStats::IntervalCalculator interface and returns an RooStats::HypoTestInverterResult class.; The result is a SimpleInterval, which via the method UpperLimit returns to the user the upper limit value. The HypoTestInverter implements various option for performing the scan. HypoTestInverter::RunFixedScan will scan using a fixed grid the parameter of interest. HypoTestInverter::RunAutoScan will perform an automatic scan to find optimally the curve and it will stop until the desired precision is obtained.; The confidence level value at a given point can be done via HypoTestInverter::RunOnePoint.; The class can scan the CLs+b values or alternativly CLs (if the method HypoTestInverter::UseCLs has been called). New contributions to this class have been written by Matthias Wolf (advanced AutoRun algorithm). Function Members (Methods); public:. virtual~HypoTestInverter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__HypoTestInverter.html:398,perform,performing,398,root/html528/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html528/RooStats__HypoTestInverter.html,2,['perform'],['performing']
Performance,". RooStats::HypoTestInverterOriginal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::HypoTestInverterOriginal. class RooStats::HypoTestInverterOriginal: public RooStats::IntervalCalculator, public TNamed. HypoTestInverterOriginal class for performing an hypothesis test inversion by scanning the hypothesis test results of the; HybridCalculator for various values of the parameter of interest. By looking at the confidence level curve of; the result an upper limit, where it intersects the desired confidence level, can be derived.; The class implements the RooStats::IntervalCalculator interface and returns an RooStats::HypoTestInverterResult class.; The result is a SimpleInterval, which via the method UpperLimit returns to the user the upper limit value. The HypoTestInverterOriginal implements various option for performing the scan. HypoTestInverterOriginal::RunFixedScan will scan using a fixed grid the parameter of interest. HypoTestInverterOriginal::RunAutoScan will perform an automatic scan to find optimally the curve and it will stop until the desired precision is obtained.; The confidence level value at a given point can be done via HypoTestInverterOriginal::RunOnePoint.; The class can scan the CLs+b values or alternativly CLs (if the method HypoTestInverterOriginal::UseCLs has been called). New contributions to this class have been written by Matthias Wolf (advanced AutoRun algorithm). Function Members (Methods); public:. virtual~HypoTestInverterOriginal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HypoTestInverterOriginal.html:440,perform,performing,440,root/html530/RooStats__HypoTestInverterOriginal.html,https://root.cern,https://root.cern/root/html530/RooStats__HypoTestInverterOriginal.html,10,['perform'],['performing']
Performance,". RooStats::NeymanConstruction. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::NeymanConstruction. class RooStats::NeymanConstruction: public RooStats::IntervalCalculator, public TNamed. NeymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests,; performs a NeymanConstruction. ; It produces a RooStats::PointSetInterval, which is a concrete implementation of the ConfInterval interface. . The Neyman Construction is not a uniquely defined statistical technique, it requires that one specify an ordering rule ; or ordering principle, which is usually incoded by choosing a specific test statistic and limits of integration ; (corresponding to upper/lower/central limits). As a result, this class must be configured with the corresponding; information before it can produce an interval. Common configurations, such as the Feldman-Cousins approach, can be ; enforced by other light weight classes. The Neyman Construction considers every point in the parameter space independently, no assumptions are ; made that the interval is connected or of a particular shape. As a result, the PointSetInterval class is used to ; represent the result. The user indicate which points in the parameter space to perform the constrution by providing; a PointSetInterval instance with the desired points. This class is fairly light weight, because the choice of parameter points to be considered is factorized and so is the ; creation of the sampling distribution of the test statistic (which is done by a concrete class implementing the DistributionCreator interface). As a result, this class basically just drives the construction by:. using a DistributionCreator to create the SamplingDistribution of a user-defined test statistic for each parameter point of inter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__NeymanConstruction.html:500,perform,performs,500,root/html526/RooStats__NeymanConstruction.html,https://root.cern,https://root.cern/root/html526/RooStats__NeymanConstruction.html,1,['perform'],['performs']
Performance,". RooStats::NeymanConstruction. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::NeymanConstruction. class RooStats::NeymanConstruction: public RooStats::IntervalCalculator. NeymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests,; performs a NeymanConstruction. ; It produces a RooStats::PointSetInterval, which is a concrete implementation of the ConfInterval interface. . The Neyman Construction is not a uniquely defined statistical technique, it requires that one specify an ordering rule ; or ordering principle, which is usually incoded by choosing a specific test statistic and limits of integration ; (corresponding to upper/lower/central limits). As a result, this class must be configured with the corresponding; information before it can produce an interval. Common configurations, such as the Feldman-Cousins approach, can be ; enforced by other light weight classes. The Neyman Construction considers every point in the parameter space independently, no assumptions are ; made that the interval is connected or of a particular shape. As a result, the PointSetInterval class is used to ; represent the result. The user indicate which points in the parameter space to perform the constrution by providing; a PointSetInterval instance with the desired points. This class is fairly light weight, because the choice of parameter points to be considered is factorized and so is the ; creation of the sampling distribution of the test statistic (which is done by a concrete class implementing the DistributionCreator interface). As a result, this class basically just drives the construction by:. using a DistributionCreator to create the SamplingDistribution of a user-defined test statistic for each parameter point of interest,; defining ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__NeymanConstruction.html:485,perform,performs,485,root/html528/RooStats__NeymanConstruction.html,https://root.cern,https://root.cern/root/html528/RooStats__NeymanConstruction.html,6,['perform'],['performs']
Performance,". RooStats::NumberCountingPdfFactory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::NumberCountingPdfFactory. class RooStats::NumberCountingPdfFactory. A factory for building PDFs and data for a number counting combination. ; The factory produces a PDF for N channels with uncorrelated background ; uncertainty. Correlations can be added by extending this PDF with additional terms.; The factory relates the signal in each channel to a master signal strength times the ; expected signal in each channel. Thus, the final test is performed on the master signal strength.; This yields a more powerful test than letting signal in each channel be independent. The problem has been studied in these references:. http://arxiv.org/abs/physics/0511028; http://arxiv.org/abs/physics/0702156; http://cdsweb.cern.ch/record/1099969?ln=en. One can incorporate uncertainty on the expected signal by adding additional terms.; For the future, perhaps this factory should be extended to include the efficiency terms automatically. Function Members (Methods); public:. virtual~NumberCountingPdfFactory(); voidAddData(Double_t* mainMeas, Double_t* bkgMeas, Double_t* db, Int_t nbins, RooWorkspace* ws, const char* dsName = ""NumberCountingData""); voidAddDataWithSideband(Double_t* mainMeas, Double_t* sideband, Double_t* tau, Int_t nbins, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); voidAddExpData(Double_t* sigExp, Double_t* bkgExp, Double_t* db, Int_t nbins, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); voidAddExpDataWithSideband(Double_t* sigExp, Double_t* bkgExp, Double_t* tau, Int_t nbins, RooWorkspace* ws, const char* dsName = ""NumberCountingData""); voidAddModel(Double_t* sigExp, Int_t nchan, RooWorkspace* ws, const char* pdfName = ""CombinedPdf"", const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__NumberCountingPdfFactory.html:729,perform,performed,729,root/html526/RooStats__NumberCountingPdfFactory.html,https://root.cern,https://root.cern/root/html526/RooStats__NumberCountingPdfFactory.html,6,['perform'],['performed']
Performance,". RooStats::NumberCountingPdfFactory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOSTATS; » RooStats::NumberCountingPdfFactory. class RooStats::NumberCountingPdfFactory. A factory for building PDFs and data for a number counting combination. ; The factory produces a PDF for N channels with uncorrelated background ; uncertainty. Correlations can be added by extending this PDF with additional terms.; The factory relates the signal in each channel to a master signal strength times the ; expected signal in each channel. Thus, the final test is performed on the master signal strength.; This yields a more powerful test than letting signal in each channel be independent. The problem has been studied in these references:. http://arxiv.org/abs/physics/0511028; http://arxiv.org/abs/physics/0702156; http://cdsweb.cern.ch/record/1099969?ln=en. One can incorporate uncertainty on the expected signal by adding additional terms.; For the future, perhaps this factory should be extended to include the efficiency terms automatically. Function Members (Methods); public:. virtual~NumberCountingPdfFactory(); voidAddData(Double_t* mainMeas, Double_t* bkgMeas, Double_t* db, Int_t nbins, RooWorkspace* ws, const char* dsName = ""NumberCountingData""); voidAddDataWithSideband(Double_t* mainMeas, Double_t* sideband, Double_t* tau, Int_t nbins, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); voidAddExpData(Double_t* sigExp, Double_t* bkgExp, Double_t* db, Int_t nbins, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); voidAddExpDataWithSideband(Double_t* sigExp, Double_t* bkgExp, Double_t* tau, Int_t nbins, RooWorkspace* ws, const char* dsName = ""NumberCountingData""); voidAddModel(Double_t* sigExp, Int_t nchan, RooWorkspace* ws, const char* pdfName = ""CombinedPdf"", const char* masterSign",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__NumberCountingPdfFactory.html:719,perform,performed,719,root/html528/RooStats__NumberCountingPdfFactory.html,https://root.cern,https://root.cern/root/html528/RooStats__NumberCountingPdfFactory.html,1,['perform'],['performed']
Performance,". RooUnitTest. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooUnitTest. class RooUnitTest: public TNamed. RooUnit test is an abstract base class for unit regression tests for; RooFit and RooStats tests performed in stressRooFit and stressRooStats; Implementations of this class must implement abstract method testCode(); which defines the regression test to be performed. Inside testCode(); the regression test can define objects on which the regression is performed.; These are; RooPlot - regPlot() ;; RooFitResult - regFitResult() ;; Double_t - regValue() ;; RooTable - regTable() ;; TH1/2/3 - regTH ; RooWorkspace - regWS() ;; ; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooUnitTest(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tareTHidentical(TH1* htest, TH1* href); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearSilentMode(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Double_tctol(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooUnitTest.html:397,perform,performed,397,root/html534/RooUnitTest.html,https://root.cern,https://root.cern/root/html534/RooUnitTest.html,9,['perform'],['performed']
Performance,". RootTalk: Re: [ROOT] error calc. in TProfile. Re: [ROOT] error calc. in TProfile. From: Martin Kestel (mka@mppmu.mpg.de); Date: Fri Jul 19 2002 - 13:18:48 MEST. Next message: Ed Oltman: ""[ROOT] Performance question: Updating a colz histogram""; Previous message: Arkadiusz Bubak: ""[ROOT] TThread and TMapFile together""; In reply to: Rene Brun: ""Re: [ROOT] error calc. in TProfile"". Messages sorted by:; [ date ]; [ thread ]; [ subject ]; [ author ]. Hi Rene,. RB>I agree with your theory. In the practical case of TProfile; RB>with low statistics in one bin and very small weights, do you have a; RB>better algorithm to propose? I mean an algorithm really working,; RB>and for example, not subject to rounding problems?; RB>Let me know. I will be happy to include it. I thought a little bit about this problem and arrived at the following; conclusion / suggestion:. Is it possible to use a user-supplied error calculation function? In addition; of course to the other options (error-of-the-mean and spread option). It is always the user's own responsibility to calculate their errors; correctly, as well as judging the outcome of a fit they make. What should be; the job of ROOT (IMHO), is to provide the tools to fit data points; even if; the fit is bad and the chi^2 is large, this is telling something. A user cannot expect ROOT to take care for any ill-posed fit, it is necessary; to give a bad result in that case. There is more to fitting distributions than; just to run a program: when fits do not work well, the users may be advised to; think about the model they are fitting and not to complain to ROOT developers; about their (physics or) statistics problem. just another $0.02 from me -- I am curious for other opinions. Best Regards,. Martin. Next message: Ed Oltman: ""[ROOT] Performance question: Updating a colz histogram""; Previous message: Arkadiusz Bubak: ""[ROOT] TThread and TMapFile together""; In reply to: Rene Brun: ""Re: [ROOT] error calc. in TProfile"". Messages sorted by:; [ da",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/roottalk/roottalk02/2916.html:196,Perform,Performance,196,root/roottalk/roottalk02/2916.html,https://root.cern,https://root.cern/root/roottalk/roottalk02/2916.html,1,['Perform'],['Performance']
Performance,". Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::HypoTestInverter. class RooStats::HypoTestInverter: public RooStats::IntervalCalculator, public TNamed. HypoTestInverter class for performing an hypothesis test inversion by scanning the hypothesis test results of the; HybridCalculator for various values of the parameter of interest. By looking at the confidence level curve of; the result an upper limit, where it intersects the desired confidence level, can be derived.; The class implements the RooStats::IntervalCalculator interface and returns an RooStats::HypoTestInverterResult class.; The result is a SimpleInterval, which via the method UpperLimit returns to the user the upper limit value. The HypoTestInverter implements various option for performing the scan. HypoTestInverter::RunFixedScan will scan using a fixed grid the parameter of interest. HypoTestInverter::RunAutoScan will perform an automatic scan to find optimally the curve and it will stop until the desired precision is obtained.; The confidence level value at a given point can be done via HypoTestInverter::RunOnePoint.; The class can scan the CLs+b values or alternativly CLs (if the method HypoTestInverter::UseCLs has been called). New contributions to this class have been written by Matthias Wolf (advanced AutoRun algorithm). Function Members (Methods); public:. virtual~HypoTestInverter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tConfidenceLevel() const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__HypoTestInverter.html:1122,perform,perform,1122,root/html526/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html526/RooStats__HypoTestInverter.html,1,['perform'],['perform']
Performance,". See THnBase::Add(). void Add(const THnBase* h, Double_t c = 1.); Add contents of h scaled by c to this histogram:; this = this + c * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set. void RebinnedAdd(const THnBase* h, Double_t c = 1.); Add contents of h scaled by c to this histogram:; this = this + c * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set.; In contrast to Add(), RebinnedAdd() does not require consistent binning of; this and h; instead, each bin's center is used to determine the target bin. Long64_t Merge(TCollection* list); Merge this with a list of THnBase's. All THnBase's provided; in the list must have the same bin layout!. void Multiply(const THnBase* h); Multiply this histogram by histogram h; this = this * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set. void Multiply(TF1* f, Double_t c = 1.); Performs the operation: this = this*c*f1; if errors are defined, errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after; calling Multiply(). void Divide(const THnBase* h); Divide this histogram by h; this = this/(h); Note that if h has Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content. void Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); Replace contents of this histogram by multiplication of h1 by h2; this = (c1*h1)/(c2*h2); Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnBase.html:14633,Perform,Performs,14633,root/html534/THnBase.html,https://root.cern,https://root.cern/root/html534/THnBase.html,3,['Perform'],['Performs']
Performance,". SysInfo_t. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » SysInfo_t. class SysInfo_t. TSystem. Abstract base class defining a generic interface to the underlying; Operating System. Function Members (Methods); public:. SysInfo_t(); SysInfo_t(const SysInfo_t&); virtual~SysInfo_t(); static TClass*Class(); virtual TClass*IsA() const; SysInfo_t&operator=(const SysInfo_t&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. Int_tfBusSpeedbus speed in MHz; Int_tfCpuSpeedcpu speed in MHz; TStringfCpuTypetype of cpu; Int_tfCpusnumber of cpus; Int_tfL2Cachelevel 2 cache size in KB; TStringfModelcomputer model; TStringfOSOS; Int_tfPhysRamphysical RAM in MB. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SysInfo_t(); { }. virtual ~SysInfo_t(); { }. TSystem& operator=(const SysInfo_t& ). » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TSystem.h 37109 2010-11-30 16:30:58Z pcanal $ » Last generated: 2010-12-01 01:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/SysInfo_t.html:810,cache,cache,810,root/html528/SysInfo_t.html,https://root.cern,https://root.cern/root/html528/SysInfo_t.html,1,['cache'],['cache']
Performance,". SysInfo_t. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » SysInfo_t. class SysInfo_t. TSystem. Abstract base class defining a generic interface to the underlying; Operating System. Function Members (Methods); public:. SysInfo_t(); SysInfo_t(const SysInfo_t&); virtual~SysInfo_t(); static TClass*Class(); virtual TClass*IsA() const; SysInfo_t&operator=(const SysInfo_t&); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. Int_tfBusSpeedbus speed in MHz; Int_tfCpuSpeedcpu speed in MHz; TStringfCpuTypetype of cpu; Int_tfCpusnumber of cpus; Int_tfL2Cachelevel 2 cache size in KB; TStringfModelcomputer model; TStringfOSOS; Int_tfPhysRamphysical RAM in MB. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SysInfo_t(); { }. virtual ~SysInfo_t(); { }. TSystem& operator=(const SysInfo_t& ). » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TSystem.h 27497 2009-02-18 16:16:06Z rdm $ » Last generated: 2009-12-07 13:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/SysInfo_t.html:824,cache,cache,824,root/html526/SysInfo_t.html,https://root.cern,https://root.cern/root/html526/SysInfo_t.html,1,['cache'],['cache']
Performance,". SysInfo_t. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » SysInfo_t. class SysInfo_t. TSystem. Abstract base class defining a generic interface to the underlying; Operating System. Function Members (Methods); public:. SysInfo_t(); SysInfo_t(const SysInfo_t&); virtual~SysInfo_t(); static TClass*Class(); virtual TClass*IsA() const; SysInfo_t&operator=(const SysInfo_t&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. Int_tfBusSpeedbus speed in MHz; Int_tfCpuSpeedcpu speed in MHz; TStringfCpuTypetype of cpu; Int_tfCpusnumber of cpus; Int_tfL2Cachelevel 2 cache size in KB; TStringfModelcomputer model; TStringfOSOS; Int_tfPhysRamphysical RAM in MB. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SysInfo_t(); { }. virtual ~SysInfo_t(); { }. TSystem& operator=(const SysInfo_t& ). » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TSystem.h 37109 2010-11-30 16:30:58Z pcanal $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/SysInfo_t.html:812,cache,cache,812,root/html530/SysInfo_t.html,https://root.cern,https://root.cern/root/html530/SysInfo_t.html,1,['cache'],['cache']
Performance,". SysInfo_t. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » SysInfo_t. class SysInfo_t. TSystem. Abstract base class defining a generic interface to the underlying; Operating System. Function Members (Methods); public:. SysInfo_t(); SysInfo_t(const SysInfo_t&); virtual~SysInfo_t(); static TClass*Class(); virtual TClass*IsA() const; SysInfo_t&operator=(const SysInfo_t&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. Int_tfBusSpeedbus speed in MHz; Int_tfCpuSpeedcpu speed in MHz; TStringfCpuTypetype of cpu; Int_tfCpusnumber of cpus; Int_tfL2Cachelevel 2 cache size in KB; TStringfModelcomputer model; TStringfOSOS; Int_tfPhysRamphysical RAM in MB. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SysInfo_t(); { }. virtual ~SysInfo_t(); { }. TSystem& operator=(const SysInfo_t& ). » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TSystem.h 41630 2011-10-28 14:16:25Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/SysInfo_t.html:812,cache,cache,812,root/html532/SysInfo_t.html,https://root.cern,https://root.cern/root/html532/SysInfo_t.html,1,['cache'],['cache']
Performance,". SysInfo_t. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » SysInfo_t. class SysInfo_t. TSystem. Abstract base class defining a generic interface to the underlying; Operating System. Function Members (Methods); public:. SysInfo_t(); SysInfo_t(const SysInfo_t&); virtual~SysInfo_t(); static TClass*Class(); virtual TClass*IsA() const; SysInfo_t&operator=(const SysInfo_t&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. Int_tfBusSpeedbus speed in MHz; Int_tfCpuSpeedcpu speed in MHz; TStringfCpuTypetype of cpu; Int_tfCpusnumber of cpus; Int_tfL2Cachelevel 2 cache size in KB; TStringfModelcomputer model; TStringfOSOS; Int_tfPhysRamphysical RAM in MB. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SysInfo_t(); { }. virtual ~SysInfo_t(); { }. TSystem& operator=(const SysInfo_t& ). » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-09-08 17:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/SysInfo_t.html:831,cache,cache,831,root/html534/SysInfo_t.html,https://root.cern,https://root.cern/root/html534/SysInfo_t.html,1,['cache'],['cache']
Performance,". SysInfo_t. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » SysInfo_t. class SysInfo_t. TSystem. Abstract base class defining a generic interface to the underlying; Operating System.; This is not an ABC in the strict sense of the (C++) word. For; every member function there is an implementation (often not more; than a call to AbstractMethod() which prints a warning saying; that the method should be overridden in a derived class), which; allows a simple partial implementation for new OS'es. Function Members (Methods); public:. virtual~SysInfo_t(); static TClass*Class(); virtual TClass*IsA() const; SysInfo_t&operator=(const SysInfo_t&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); SysInfo_t(); SysInfo_t(const SysInfo_t&). Data Members; public:. Int_tfBusSpeedbus speed in MHz; Int_tfCpuSpeedcpu speed in MHz; TStringfCpuTypetype of cpu; Int_tfCpusnumber of cpus; Int_tfL2Cachelevel 2 cache size in KB; TStringfModelcomputer model; TStringfOSOS; Int_tfPhysRamphysical RAM in MB. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SysInfo_t(); { }. virtual ~SysInfo_t(); { }. TSystem& operator=(const SysInfo_t& ). » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 14:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/SysInfo_t.html:1178,cache,cache,1178,root/html602/SysInfo_t.html,https://root.cern,https://root.cern/root/html602/SysInfo_t.html,1,['cache'],['cache']
Performance,". SysInfo_t. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » SysInfo_t. class SysInfo_t. TSystem. Abstract base class defining a generic interface to the underlying; Operating System.; This is not an ABC in the strict sense of the (C++) word. For; every member function there is an implementation (often not more; than a call to AbstractMethod() which prints a warning saying; that the method should be overridden in a derived class), which; allows a simple partial implementation for new OS'es. Function Members (Methods); public:. virtual~SysInfo_t(); static TClass*Class(); virtual TClass*IsA() const; SysInfo_t&operator=(const SysInfo_t&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); SysInfo_t(); SysInfo_t(const SysInfo_t&). Data Members; public:. Int_tfBusSpeedbus speed in MHz; Int_tfCpuSpeedcpu speed in MHz; TStringfCpuTypetype of cpu; Int_tfCpusnumber of cpus; Int_tfL2Cachelevel 2 cache size in KB; TStringfModelcomputer model; TStringfOSOS; Int_tfPhysRamphysical RAM in MB. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SysInfo_t(); { }. virtual ~SysInfo_t(); { }. TSystem& operator=(const SysInfo_t& ). » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-09-08 17:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/SysInfo_t.html:1178,cache,cache,1178,root/html604/SysInfo_t.html,https://root.cern,https://root.cern/root/html604/SysInfo_t.html,1,['cache'],['cache']
Performance,". TAxisEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TAxisEditor. class TAxisEditor: public TGedFrame. TAxisEditor. Implements GUI for axis attributes.; axis color; ticks parameters: length, setting on both axis sides,; logarithmic or linear scale along the selected axis,; primary, secondary and tertiary axis divisions,; setting more logarithmic labels,; optimizing labels' position if available; axis title - a title can be added via the text entry field; and can be set to be centered or rotated via the corresponding; check buttons, the title color, offset, font can be set easily; axis labels - their color, size, offset can be set similarly,; in addition there is a check box for no exponent choice,; and another one for setting the same decimal part for all labels //. /*. */. Function Members (Methods); public:. TAxisEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TAxisEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAxisEditor.html:548,optimiz,optimizing,548,root/html526/TAxisEditor.html,https://root.cern,https://root.cern/root/html526/TAxisEditor.html,5,['optimiz'],['optimizing']
Performance,". TAxisEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TAxisEditor. class TAxisEditor: public TGedFrame. TAxisEditor. Implements GUI for axis attributes.; axis color; ticks parameters: length, setting on both axis sides,; logarithmic or linear scale along the selected axis,; primary, secondary and tertiary axis divisions,; setting more logarithmic labels,; optimizing labels' position if available; axis title - a title can be added via the text entry field; and can be set to be centered or rotated via the corresponding; check buttons, the title color, offset, font can be set easily; axis labels - their color, size, offset can be set similarly,; in addition there is a check box for no exponent choice,; and another one for setting the same decimal part for all labels //. /*. */. Function Members (Methods); public:. virtual~TAxisEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TAxisEditor.html:548,optimiz,optimizing,548,root/html602/TAxisEditor.html,https://root.cern,https://root.cern/root/html602/TAxisEditor.html,2,['optimiz'],['optimizing']
Performance,". TBranchRef. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TBranchRef. class TBranchRef: public TBranch. A branch containing and managing a TRefTable for TRef autoloading.; It loads the TBranch containing a referenced object when requested; by TRef::GetObject(), so the reference can be resolved. The; information which branch to load is stored by TRefTable. Once a; TBranch has read the TBranchRef's current entry it will not be told; to re-read, in case the use has changed objects read from the; branch. LIMITATION; Note that this does NOT allow for autoloading of references spanning; different entries. The TBranchRef's current entry has to correspond; to the entry of the TBranch containing the referenced object. The TRef cannot be stored in a top-level branch which is a; TBranchObject for the auto-loading to work. E.g. you cannot store; the TRefs in TObjArray, and create a top-level branch storing this; TObjArray. Function Members (Methods); public:. TBranchRef(); TBranchRef(TTree* tree); virtual~TBranchRef(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTBranch::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBranchRef.html:362,load,loads,362,root/html526/TBranchRef.html,https://root.cern,https://root.cern/root/html526/TBranchRef.html,15,['load'],"['load', 'loading', 'loads']"
Performance,". TBranchRef. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TBranchRef. class TBranchRef: public TBranch. A branch containing and managing a TRefTable for TRef autoloading.; It loads the TBranch containing a referenced object when requested; by TRef::GetObject(), so the reference can be resolved. The; information which branch to load is stored by TRefTable. Once a; TBranch has read the TBranchRef's current entry it will not be told; to re-read, in case the use has changed objects read from the; branch. LIMITATION; Note that this does NOT allow for autoloading of references spanning; different entries. The TBranchRef's current entry has to correspond; to the entry of the TBranch containing the referenced object. The TRef cannot be stored in a top-level branch which is a; TBranchObject for the auto-loading to work. E.g. you cannot store; the TRefs in TObjArray, and create a top-level branch storing this; TObjArray. Function Members (Methods); public:. virtual~TBranchRef(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTBranch::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBranchRef.html:362,load,loads,362,root/html602/TBranchRef.html,https://root.cern,https://root.cern/root/html602/TBranchRef.html,6,['load'],"['load', 'loading', 'loads']"
Performance,". TBranchSTL. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TBranchSTL. class TBranchSTL: public TBranch. TBranchSTL. A Branch handling STL collection of pointers (vectors, lists, queues,; sets and multisets) while storing them in split mode. Function Members (Methods); public:. TBranchSTL(); TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); virtual~TBranchSTL(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBranchSTL.html:365,queue,queues,365,root/html526/TBranchSTL.html,https://root.cern,https://root.cern/root/html526/TBranchSTL.html,5,['queue'],['queues']
Performance,". TBranchSTL. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TBranchSTL. class TBranchSTL: public TBranch. TBranchSTL. A Branch handling STL collection of pointers (vectors, lists, queues,; sets and multisets) while storing them in split mode. Function Members (Methods); public:. virtual~TBranchSTL(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBranchSTL.html:365,queue,queues,365,root/html602/TBranchSTL.html,https://root.cern,https://root.cern/root/html602/TBranchSTL.html,2,['queue'],['queues']
Performance,". TBrowser*fBrowserselected browser (if exist); TObject*fCalledObjectobject to call; TContextMenuImp*fContextMenuImp!Context menu system specific implementation; TStringTNamed::fNameobject identifier; TVirtualPad*fSelectedCanvasselected canvas (if exist); TClassMenuItem*fSelectedMenuItemselected class menu item; TFunction*fSelectedMethodselected method; TObject*fSelectedObjectselected object; TVirtualPad*fSelectedPadselected pad (if exist); TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TContextMenu(const char* name, const char* title = ""Context sensitive popup menu""); Create a context menu. ~TContextMenu(); Destroy a context menu. void Action(TObject *object, TMethod *method); Action to be performed when this menu item is selected.; If the selected method requires arguments we popup an; automatically generated dialog, otherwise the method is; directly executed. void Action(TClassMenuItem *menuitem); Action to be performed when this menu item is selected.; If the selected method requires arguments we popup an; automatically generated dialog, otherwise the method is; directly executed. void Action(TObject *object, TToggle *toggle); Action to be performed when this toggle menu item is selected. const char * CreateArgumentTitle(TMethodArg* argument); Create string describing argument (for use in dialog box). const char * CreateDialogTitle(TObject* object, TFunction* method); Create title for dialog box retrieving argument values. const char * CreatePopupTitle(TObject* object); Create title for popup menu. void Execute(TObject *object, TFunction *method, const char *params); Execute method with specified arguments for specified object. void Execute(TObject *object, TFunction *method, TObjArray *params); Execute method with specified arguments for specified object. void Popup(Int_t x, Int_t y, TObject* obj, TVirtualPad* c = 0, TVirtualPad* p = 0); Popup context menu at given location in canvas ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TContextMenu.html:8318,perform,performed,8318,root/html526/TContextMenu.html,https://root.cern,https://root.cern/root/html526/TContextMenu.html,1,['perform'],['performed']
Performance,". TBuffer3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBuffer3D. class TBuffer3D: public TObject. TBuffer3D. Generic 3D primitive description class - see TBuffer3DTypes for; producer classes. ; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBuffer3D.html:821,perform,performance,821,root/html526/TBuffer3D.html,https://root.cern,https://root.cern/root/html526/TBuffer3D.html,7,['perform'],['performance']
Performance,". TBufferJSON. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » HTTP; » TBufferJSON. class TBufferJSON: public TBuffer. Class for serializing object into JavaScript Object Notation (JSON) format.; It creates such object representation, which can be directly; used in JavaScript ROOT (JSROOT) for drawing. TBufferJSON implements TBuffer interface, therefore most of; ROOT and user classes can be converted into JSON.; There are certain limitations for classes with custom streamers,; which should be equipped specially for this purposes (see TCanvas::Streamer() as example). To perform conversion, one should use TBufferJSON::ConvertToJSON method like:. TH1* h1 = new TH1I(""h1"",""title"",100, 0, 10);; h1->FillRandom(""gaus"",10000);; TString json = TBufferJSON::ConvertToJSON(h1);. Function Members (Methods); public:. virtual~TBufferJSON(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tCheckObject(const TObject*); virtual Bool_tCheckObject(const void*, const TClass*); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBufferJSON.html:750,perform,perform,750,root/html602/TBufferJSON.html,https://root.cern,https://root.cern/root/html602/TBufferJSON.html,2,['perform'],['perform']
Performance,". TBufferJSON. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » HTTP; » TBufferJSON. class TBufferJSON: public TBuffer. TBufferJSON. Class for serializing object into JavaScript Object Notation (JSON) format.; It creates such object representation, which can be directly; used in JavaScript ROOT (JSROOT) for drawing. TBufferJSON implements TBuffer interface, therefore most of; ROOT and user classes can be converted into JSON.; There are certain limitations for classes with custom streamers,; which should be equipped specially for this purposes (see TCanvas::Streamer() as example). To perform conversion, one should use TBufferJSON::ConvertToJSON method like:. TH1* h1 = new TH1I(""h1"",""title"",100, 0, 10);; h1->FillRandom(""gaus"",10000);; TString json = TBufferJSON::ConvertToJSON(h1);. Function Members (Methods); public:. TBufferJSON(); virtual~TBufferJSON(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tCheckObject(const TObject*); virtual Bool_tCheckObject(const void*, const TClass*); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferJSON.html:763,perform,perform,763,root/html534/TBufferJSON.html,https://root.cern,https://root.cern/root/html534/TBufferJSON.html,1,['perform'],['perform']
Performance,". TClass. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TClass. class TClass: public TDictionary. The ROOT global object gROOT contains a list of all defined; classes. This list is build when a reference to a class dictionary; is made. When this happens, the static ""class""::Dictionary(); function is called to create a TClass object describing the; class. The Dictionary() function is defined in the ClassDef; macro and stored (at program startup or library load time) together; with the class name in the TClassTable singleton object.; For a description of all dictionary classes see TDictionary. Function Members (Methods); public:. TClass(); TClass(const char* name, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, const char* dfil = 0, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, ShowMembersFunc_t showmember, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); virtual~TClass(); voidTObject::AbstractMethod(const char* method) const; static voidAddClass(TClass* cl); voidAddImplFile(const char* filename, int line); voidAddInstance(Bool_t heap = kFALSE); static Bool_tAddRule(const char* rule); voidAdoptMemberStreamer(const char* name, TMemberStreamer* strm); voidAdoptReferenceProxy(TVirtualRefProxy* proxy); voidAdoptSchemaRules(ROOT::TSchemaRuleSet* rules); voidAdoptStreamer(TClassStreamer* strm); virtual voidTObject::AppendPad(Option_t* option = """"); static Int_tAutoBrowse(TObject* obj, TBrowser* browser); virtual voidBrowse(TBrowser* b); Int_tBrowse(void* obj, TBrowser* b) const; voidBuildEmulatedRealData(const char* name, Long_t offset, TClass* cl); voidBuildRealData(void* pointer = 0, Bool_t isTransient = kFALSE); voidCal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClass.html:644,load,load,644,root/html534/TClass.html,https://root.cern,https://root.cern/root/html534/TClass.html,1,['load'],['load']
Performance,". TClass. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TClass. class TClass: public TDictionary. The ROOT global object gROOT contains a list of all defined; classes. This list is build when a reference to a class dictionary; is made. When this happens, the static ""class""::Dictionary(); function is called to create a TClass object describing the; class. The Dictionary() function is defined in the ClassDef; macro and stored (at program startup or library load time) together; with the class name in the TClassTable singleton object.; For a description of all dictionary classes see TDictionary. Function Members (Methods); public:. TClass(); TClass(const char* name, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, const char* dfil = 0, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, ShowMembersFunc_t showmember, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); virtual~TClass(); voidTObject::AbstractMethod(const char* method) const; static voidAddClass(TClass* cl); voidAddImplFile(const char* filename, int line); voidAddInstance(Bool_t heap = kFALSE); voidAddRef(TClassRef* ref); static Bool_tAddRule(const char* rule); voidAdoptMemberStreamer(const char* name, TMemberStreamer* strm); voidAdoptReferenceProxy(TVirtualRefProxy* proxy); voidAdoptSchemaRules(ROOT::TSchemaRuleSet* rules); voidAdoptStreamer(TClassStreamer* strm); virtual voidTObject::AppendPad(Option_t* option = """"); static Int_tAutoBrowse(TObject* obj, TBrowser* browser); virtual voidBrowse(TBrowser* b); Int_tBrowse(void* obj, TBrowser* b) const; voidBuildEmulatedRealData(const char* name, Long_t offset, TClass* cl); voidBuildRealData(void* pointer = 0, Bool_t is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClass.html:644,load,load,644,root/html528/TClass.html,https://root.cern,https://root.cern/root/html528/TClass.html,3,['load'],['load']
Performance,". TClass. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TClass. class TClass: public TDictionary. The ROOT global object gROOT contains a list of all defined; classes. This list is build when a reference to a class dictionary; is made. When this happens, the static ""class""::Dictionary(); function is called to create a TClass object describing the; class. The Dictionary() function is defined in the ClassDef; macro and stored (at program startup or library load time) together; with the class name in the TClassTable singleton object.; For a description of all dictionary classes see TDictionary. Function Members (Methods); public:. TClass(); TClass(const char* name, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, const char* dfil = 0, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, ShowMembersFunc_t showmember, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); virtual~TClass(); voidTObject::AbstractMethod(const char* method) const; static voidAddClass(TClass* cl); voidAddImplFile(const char* filename, int line); voidAddInstance(Bool_t heap = kFALSE); voidAddRef(TClassRef* ref); voidAdoptMemberStreamer(const char* name, TMemberStreamer* strm); voidAdoptReferenceProxy(TVirtualRefProxy* proxy); voidAdoptSchemaRules(ROOT::TSchemaRuleSet* rules); voidAdoptStreamer(TClassStreamer* strm); virtual voidTObject::AppendPad(Option_t* option = """"); static Int_tAutoBrowse(TObject* obj, TBrowser* browser); virtual voidBrowse(TBrowser* b); Int_tBrowse(void* obj, TBrowser* b) const; voidBuildEmulatedRealData(const char* name, Long_t offset, TClass* cl); voidBuildRealData(void* pointer = 0, Bool_t isTransient = kFALSE); voidCalculateStream",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClass.html:644,load,load,644,root/html526/TClass.html,https://root.cern,https://root.cern/root/html526/TClass.html,1,['load'],['load']
Performance,". TClass. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TClass. class TClass: public TDictionary. The ROOT global object gROOT contains a list of all defined; classes. This list is build when a reference to a class dictionary; is made. When this happens, the static ""class""::Dictionary(); function is called to create a TClass object describing the; class. The Dictionary() function is defined in the ClassDef; macro and stored (at program startup or library load time) together; with the class name in the TClassTable singleton object.; For a description of all dictionary classes see TDictionary. Function Members (Methods); public:. virtual~TClass(); voidTObject::AbstractMethod(const char* method) const; static voidAddClass(TClass* cl); static voidAddClassToDeclIdMap(TDictionary::DeclId_t id, TClass* cl); voidAddImplFile(const char* filename, int line); voidAddInstance(Bool_t heap = kFALSE); static Bool_tAddRule(const char* rule); voidAdoptMemberStreamer(const char* name, TMemberStreamer* strm); voidAdoptReferenceProxy(TVirtualRefProxy* proxy); voidAdoptSchemaRules(ROOT::TSchemaRuleSet* rules); voidAdoptStreamer(TClassStreamer* strm); virtual voidTObject::AppendPad(Option_t* option = """"); static Int_tAutoBrowse(TObject* obj, TBrowser* browser); virtual voidBrowse(TBrowser* b); Int_tBrowse(void* obj, TBrowser* b) const; voidBuildEmulatedRealData(const char* name, Long_t offset, TClass* cl); voidBuildRealData(void* pointer = 0, Bool_t isTransient = kFALSE); voidCalculateStreamerOffset() const; Bool_tCallShowMembers(const void* obj, TMemberInspector& insp, Bool_t isTransient = kFALSE) const; Bool_tCanIgnoreTObjectStreamer(); Bool_tCanSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; Long_tClassProperty() const; virtual voidTNamed::Clear(Option_t* option = """")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:644,load,load,644,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,1,['load'],['load']
Performance,". TClass. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TClass. class TClass: public TDictionary. The ROOT global object gROOT contains a list of all defined; classes. This list is build when a reference to a class dictionary; is made. When this happens, the static ""class""::Dictionary(); function is called to create a TClass object describing the; class. The Dictionary() function is defined in the ClassDef; macro and stored (at program startup or library load time) together; with the class name in the TClassTable singleton object.; For a description of all dictionary classes see TDictionary. The name of the class as registered in the TClass object and in the; list of class is the ""normalized name"" and is defined as:. The name of the type as accessible from the global scope to which; a 'using namespace std;' has been applied to and with:; - all typedefs desugared except for Double32_t, Float16_t,; Long64_t, ULong64_t and std::string.; - default template parameters removed for STL collections and; added for any other class templates instances.; - Fully qualified both for the class name itself and all of its; component, except that, at least for moment, all 'std::' are; stripped. Function Members (Methods); public:. virtual~TClass(); voidTObject::AbstractMethod(const char* method) const; static voidAddClass(TClass* cl); static voidAddClassToDeclIdMap(TDictionary::DeclId_t id, TClass* cl); voidAddImplFile(const char* filename, int line); voidAddInstance(Bool_t heap = kFALSE); static Bool_tAddRule(const char* rule); voidAdoptMemberStreamer(const char* name, TMemberStreamer* strm); voidAdoptReferenceProxy(TVirtualRefProxy* proxy); voidAdoptSchemaRules(ROOT::TSchemaRuleSet* rules); voidAdoptStreamer(TClassStreamer* strm); virtual voidTObject::AppendPad(Option_t* option = """"); static Int_tAuto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TClass.html:644,load,load,644,root/html604/TClass.html,https://root.cern,https://root.cern/root/html604/TClass.html,1,['load'],['load']
Performance,". TClassDocInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HTML; » TClassDocInfo. class TClassDocInfo: public TObject. Caches class documentation information, like which module it belongs to,; and whether THtml should generate documentation for the class. Function Members (Methods); public:. TClassDocInfo(TClass* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); TClassDocInfo(TDictionary* cl, const char* htmlfilename = """", const char* fsdecl = """", const char* fsimpl = """", const char* decl = 0, const char* impl = 0); virtual~TClassDocInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClassDocInfo.html:292,Cache,Caches,292,root/html526/TClassDocInfo.html,https://root.cern,https://root.cern/root/html526/TClassDocInfo.html,5,['Cache'],['Caches']
Performance,". TClassDocInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HTML; » TClassDocInfo. class TClassDocInfo: public TObject. Caches class documentation information, like which module it belongs to,; and whether THtml should generate documentation for the class. Function Members (Methods); public:. virtual~TClassDocInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictionary*GetClass() const; const char*GetDeclFileName() const; const char*GetDeclFileSysName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetHtmlFileName() const; virtual const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClassDocInfo.html:292,Cache,Caches,292,root/html602/TClassDocInfo.html,https://root.cern,https://root.cern/root/html602/TClassDocInfo.html,2,['Cache'],['Caches']
Performance,". TClassRef. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TClassRef. class TClassRef. TClassRef is used to implement a permanent reference to a TClass; object. In particular this reference will change if and when the; TClass object is regenerated. This regeneration usually happens; when a library containing the described class is loaded after a; file containing an instance of this class has been opened. The references kept track of using an intrusive double linked list.; The intrusive list is maintained by TClass::AddRef and; TClass::RemoveRef. The 'start' of the list is held in; TClass::fRefStart. Function Members (Methods); public:. ~TClassRef(); TClass*GetClass() const; const char*GetClassName(); TClass*operator TClass *() const; TClass*operator->() const; TClassRef&operator=(const TClassRef& rhs); TClassRef&operator=(TClass* rhs); voidReset(); voidSetName(const char* new_name); TClassRef(); TClassRef(TClass* cl); TClassRef(const char* classname); TClassRef(const TClassRef&). private:. voidAssign(const TClassRef&); voidAssign(TClass*); TClass*InternalGetClass() const. Data Members; private:. stringfClassNameName of referenced class; TClass*const*fClassPtr! Ptr to the permanent TClass ptr/reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassRef(const TClassRef& ); Copy ctor, increases reference count to original TClass object. TClassRef(const char* classname); Create reference to specified class name, but don't set referenced; class object. TClassRef(TClass* cl); Add reference to specified class object. void Assign(const TClassRef& ); Assignment operator implementation, increases reference count to original class object.; This routines assumes that the copy actually need to be done. void Assign(TClass* ); Assignment operator, in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClassRef.html:518,load,loaded,518,root/html602/TClassRef.html,https://root.cern,https://root.cern/root/html602/TClassRef.html,2,['load'],['loaded']
Performance,". TCollection * GetListOfTypes(Bool_t load = kFALSE); Return a dynamic list giving access to all TDataTypes (typedefs); currently defined. The list is populated on demand. Calling; gROOT->GetListOfTypes()->FindObject(nameoftype);; will return the TDataType corresponding to 'nameoftype'. If the; TDataType is not already in the list itself and the type does exist,; a new TDataType will be created and added to the list. Calling; gROOT->GetListOfTypes()->ls(); // or Print(); list only the typedefs that have been previously accessed throught the; list (plus the builtins types). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the name of the given include file corresponds to a class that; is known to ROOT, e.g. ""TLorentzVector.h"" versus TLorentzVector. void InitSystem(); Initialize operating system interface. void InitThreads(); Load and initialize thread library. void InitInterpreter(); Initialize the interpreter. Should be called only after main(),; to make sure LLVM/Clang is fully initialized. TClass * LoadClass(const char* name, Bool_t silent = kFALSE) const; Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. Int_t LoadClass(const char* classname, const char* libname, Bool_t check = kFALSE); Check if class ""classname"" is known to the interpreter (in fact,; this check is not needed anymore, so classname is ignored). If; not it will load library ""libname"". If the library name does; not start with ""lib"", ""lib"" will be prepended and a search will; be made in the DynamicPath (see .rootrc). If not found a s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:30000,Load,Load,30000,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,2,['Load'],['Load']
Performance,". TEmulatedCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TEmulatedCollectionProxy. class TEmulatedCollectionProxy: public TGenCollectionProxy. TEmulatedCollectionProxy. Streamer around an arbitrary STL like container, which implements basic; container functionality. Note:; Although this class contains all the setup necessary to deal; with maps, the map-like functionality is NOT supported.; For optimization reasons this functionality is put into; the class TEmulatedMapProxy. Function Members (Methods); public:. TEmulatedCollectionProxy(const TEmulatedCollectionProxy& copy); TEmulatedCollectionProxy(const char* cl_name); virtual~TEmulatedCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void* env); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual TVirtualCollectionProxy*Generate() const; virtual TClass*TGenCollectionProxy::GetCollectionClass(); virtual Int_tTGenCollectionProxy::GetCollectionType(); virtual TStreamerInfoActions::TActionSequence*TGenCollectionProxy::GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tTGenCollectionProxy::GetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tTGenCollectionProxy::GetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tTGenCollectionProxy::GetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tTGenCollectionProxy::GetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tTGenCollectionProxy::GetFunctionNext(Bool_t read = kTRUE); virtual ULong_tTGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEmulatedCollectionProxy.html:569,optimiz,optimization,569,root/html528/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html528/TEmulatedCollectionProxy.html,1,['optimiz'],['optimization']
Performance,". TEmulatedCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TEmulatedCollectionProxy. class TEmulatedCollectionProxy: public TGenCollectionProxy. TEmulatedCollectionProxy. Streamer around an arbitrary STL like container, which implements basic; container functionality. Note:; Although this class contains all the setup necessary to deal; with maps, the map-like functionality is NOT supported.; For optimization reasons this functionality is put into; the class TEmulatedMapProxy. Function Members (Methods); public:. TEmulatedCollectionProxy(const TEmulatedCollectionProxy& copy); TEmulatedCollectionProxy(const char* cl_name); virtual~TEmulatedCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void* env); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual TVirtualCollectionProxy*Generate() const; virtual TClass*TGenCollectionProxy::GetCollectionClass(); virtual Int_tTGenCollectionProxy::GetCollectionType(); virtual TStreamerInfoActions::TActionSequence*TGenCollectionProxy::GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tTGenCollectionProxy::GetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tTGenCollectionProxy::GetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tTGenCollectionProxy::GetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tTGenCollectionProxy::GetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tTGenCollectionProxy::GetFunctionNext(Bool_t read = kTRUE); virtual ULong_tT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEmulatedCollectionProxy.html:571,optimiz,optimization,571,root/html530/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html530/TEmulatedCollectionProxy.html,1,['optimiz'],['optimization']
Performance,". TEmulatedCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TEmulatedCollectionProxy. class TEmulatedCollectionProxy: public TGenCollectionProxy. TEmulatedCollectionProxy. Streamer around an arbitrary STL like container, which implements basic; container functionality. Note:; Although this class contains all the setup necessary to deal; with maps, the map-like functionality is NOT supported.; For optimization reasons this functionality is put into; the class TEmulatedMapProxy. Function Members (Methods); public:. TEmulatedCollectionProxy(const TEmulatedCollectionProxy& copy); TEmulatedCollectionProxy(const char* cl_name, Bool_t silent); virtual~TEmulatedCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void* env); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE) const; virtual TVirtualCollectionProxy*Generate() const; virtual TClass*TGenCollectionProxy::GetCollectionClass() const; virtual Int_tTGenCollectionProxy::GetCollectionType() const; virtual TStreamerInfoActions::TActionSequence*TGenCollectionProxy::GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tTGenCollectionProxy::GetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tTGenCollectionProxy::GetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tTGenCollectionProxy::GetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tTGenCollectionProxy::GetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tTGenCollectionProxy::GetFunctionNext",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEmulatedCollectionProxy.html:571,optimiz,optimization,571,root/html534/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TEmulatedCollectionProxy.html,1,['optimiz'],['optimization']
Performance,". TEmulatedCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TEmulatedCollectionProxy. class TEmulatedCollectionProxy: public TGenCollectionProxy. TEmulatedCollectionProxy. Streamer around an arbitrary STL like container, which implements basic; container functionality. Note:; Although this class contains all the setup necessary to deal; with maps, the map-like functionality is NOT supported.; For optimization reasons this functionality is put into; the class TEmulatedMapProxy. Function Members (Methods); public:. TEmulatedCollectionProxy(const TEmulatedCollectionProxy& copy); TEmulatedCollectionProxy(const char* cl_name, Bool_t silent); virtual~TEmulatedCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void* env); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual TVirtualCollectionProxy*Generate() const; virtual TClass*TGenCollectionProxy::GetCollectionClass(); virtual Int_tTGenCollectionProxy::GetCollectionType(); virtual TStreamerInfoActions::TActionSequence*TGenCollectionProxy::GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tTGenCollectionProxy::GetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tTGenCollectionProxy::GetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tTGenCollectionProxy::GetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tTGenCollectionProxy::GetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tTGenCollectionProxy::GetFunctionNext(Bool_t read = kTRUE); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEmulatedCollectionProxy.html:571,optimiz,optimization,571,root/html532/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html532/TEmulatedCollectionProxy.html,1,['optimiz'],['optimization']
Performance,". TEntryListArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TEntryListArray. class TEntryListArray: public TEntryList. TEntryListArray: a list of entries and subentries in a TTree or TChain; TEntryListArray is an extension of TEntryList, used to hold selected entries and subentries (sublists) for when the user has a TTree with containers (vectors, arrays, ...). Usage with TTree::Draw to select entries and subentries . To fill a list elist :; ; tree->Draw("">> elist"", ""x > 0"", ""entrylistarray""); ; ; To use a list to select entries and subentries:. tree->SetEntryList(elist);; tree->Draw(""y"");; tree->Draw(""z"");; . Its main purpose is to improve the performance of a code that needs to apply complex cuts on TTree::Draw multiple times. After the first call above to TTree::Draw, a TEntryListArray is created and filled with the entries and the indices of the arrays that satisfied the selection cut (x > 0). In the subsequent calls to TTree::Draw, only these entries / subentries are used to fill histograms. About the class ; The class derives from TEntryList and can be used basically in the same way. This same class is used to keep entries and subentries, so there are two types of TEntryListArray's:. The ones that only hold subentries ; fEntry is set to the entry# for which the subentries correspond; fSubLists must be 0; The ones that hold entries and eventually lists with subentries in fSubLists.; fEntry = -1 for those; If there are no sublists for a given entry, all the subentries will be used in the selection . Additions with respect to TEntryList ; Data members:; fSubLists: a container to hold the sublists; fEntry: the entry number if the list is used to hold subentries; fLastSubListQueried and fSubListIter: a pointer to the last sublist queried and an iterator to resume the loop from th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEntryListArray.html:843,perform,performance,843,root/html532/TEntryListArray.html,https://root.cern,https://root.cern/root/html532/TEntryListArray.html,2,['perform'],['performance']
Performance,". TEntryListArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TEntryListArray. class TEntryListArray: public TEntryList. TEntryListArray: a list of entries and subentries in a TTree or TChain; TEntryListArray is an extension of TEntryList, used to hold selected entries and subentries (sublists) for when the user has a TTree with containers (vectors, arrays, ...). Usage with TTree::Draw to select entries and subentries . To fill a list elist :; ; tree->Draw("">> elist"", ""x > 0"", ""entrylistarray"");; ; To use a list to select entries and subentries:. tree->SetEntryList(elist);; tree->Draw(""y"");; tree->Draw(""z"");; . Its main purpose is to improve the performance of a code that needs to apply complex cuts on TTree::Draw multiple times. After the first call above to TTree::Draw, a TEntryListArray is created and filled with the entries and the indices of the arrays that satisfied the selection cut (x > 0). In the subsequent calls to TTree::Draw, only these entries / subentries are used to fill histograms. About the class ; The class derives from TEntryList and can be used basically in the same way. This same class is used to keep entries and subentries, so there are two types of TEntryListArray's:. The ones that only hold subentries; fEntry is set to the entry# for which the subentries correspond; fSubLists must be 0; The ones that hold entries and eventually lists with subentries in fSubLists.; fEntry = -1 for those; If there are no sublists for a given entry, all the subentries will be used in the selection . Additions with respect to TEntryList ; Data members:; fSubLists: a container to hold the sublists; fEntry: the entry number if the list is used to hold subentries; fLastSubListQueried and fSubListIter: a pointer to the last sublist queried and an iterator to resume the loop from the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEntryListArray.html:842,perform,performance,842,root/html602/TEntryListArray.html,https://root.cern,https://root.cern/root/html602/TEntryListArray.html,2,['perform'],['performance']
Performance,". TEntryListBlock. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TEntryListBlock. class TEntryListBlock: public TObject. TEntryListBlock: Used by TEntryList to store the entry numbers; There are 2 ways to represent entry numbers in a TEntryListBlock:. as bits, where passing entry numbers are assigned 1, not passing - 0; as a simple array of entry numbers. storing the numbers of entries that pass; storing the numbers of entries that don't pass. In both cases, a UShort_t* is used. The second option is better in case; less than 1/16 or more than 15/16 of entries pass the selection, and the representation can be; changed by calling OptimizeStorage() function. ; When the block is being filled, it's always stored as bits, and the OptimizeStorage(); function is called by TEntryList when it starts filling the next block. If; Enter() or Remove() is called after OptimizeStorage(), representation is ; again changed to 1). . Picture; Source. {; //=========Macro generated from canvas: c/c; //========= (Fri Mar 16 18:59:21 2007) by ROOT version5.15/03; TCanvas *c = new TCanvas(""c"", ""c"",49,123,752,435);; c->Range(0,0,1,1);; c->SetBorderSize(2);; c->SetFrameFillColor(0);; ; TPaveText *pt = new TPaveText(0.00313972,0.650146,0.22135,0.772595,""br"");; pt->SetFillColor(19);; TText *text = pt->AddText(""TEntryListBlock"");; pt->Draw();; ; pt = new TPaveText(0.00313972,0.827988,0.675039,0.994169,""br"");; pt->SetFillColor(19);; pt->SetTextColor(4);; text = pt->AddText(""Indices representation in a TEntryListBlock"");; pt->Draw();; ; pt = new TPaveText(0.00410678,0.412955,0.221766,0.651822,""br"");; pt->SetFillColor(19);; pt->SetTextAlign(12);; pt->SetTextSize(0.048583);; text = pt->AddText(""UShort_t* fIndices"");; text = pt->AddText(""Int_t fType"");; pt->Draw();; ; pt = new TPaveText(0.324961,0.708455,0.959184,0.80466",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEntryListBlock.html:821,Optimiz,OptimizeStorage,821,root/html528/TEntryListBlock.html,https://root.cern,https://root.cern/root/html528/TEntryListBlock.html,8,['Optimiz'],['OptimizeStorage']
Performance,". TEntryListBlock. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TEntryListBlock. class TEntryListBlock: public TObject. TEntryListBlock: Used by TEntryList to store the entry numbers; There are 2 ways to represent entry numbers in a TEntryListBlock:. as bits, where passing entry numbers are assigned 1, not passing - 0; as a simple array of entry numbers. storing the numbers of entries that pass; storing the numbers of entries that don't pass. In both cases, a UShort_t* is used. The second option is better in case; less than 1/16 or more than 15/16 of entries pass the selection, and the representation can be; changed by calling OptimizeStorage() function.; When the block is being filled, it's always stored as bits, and the OptimizeStorage(); function is called by TEntryList when it starts filling the next block. If; Enter() or Remove() is called after OptimizeStorage(), representation is; again changed to 1). Picture; Source. {; //=========Macro generated from canvas: c/c; //========= (Fri Mar 16 18:59:21 2007) by ROOT version5.15/03; TCanvas *c = new TCanvas(""c"", ""c"",49,123,752,435);; c->Range(0,0,1,1);; c->SetBorderSize(2);; c->SetFrameFillColor(0);. TPaveText *pt = new TPaveText(0.00313972,0.650146,0.22135,0.772595,""br"");; pt->SetFillColor(19);; TText *text = pt->AddText(""TEntryListBlock"");; pt->Draw();. pt = new TPaveText(0.00313972,0.827988,0.675039,0.994169,""br"");; pt->SetFillColor(19);; pt->SetTextColor(4);; text = pt->AddText(""Indices representation in a TEntryListBlock"");; pt->Draw();. pt = new TPaveText(0.00410678,0.412955,0.221766,0.651822,""br"");; pt->SetFillColor(19);; pt->SetTextAlign(12);; pt->SetTextSize(0.048583);; text = pt->AddText(""UShort_t* fIndices"");; text = pt->AddText(""Int_t fType"");; pt->Draw();. pt = new TPaveText(0.324961,0.708455,0.959184,0.804665,""br"");; pt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEntryListBlock.html:821,Optimiz,OptimizeStorage,821,root/html602/TEntryListBlock.html,https://root.cern,https://root.cern/root/html602/TEntryListBlock.html,4,['Optimiz'],['OptimizeStorage']
Performance,". TEntryListFromFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TEntryListFromFile. class TEntryListFromFile: public TEntryList. TEntryListFromFile. Manages entry lists from different files, when they are not loaded; in memory at the same time. This entry list should only be used when processing a TChain (see; TChain::SetEntryList() function). File naming convention:; - by default, filename_elist.root is used, where filename is the; name of the chain element.; - xxx$xxx.root - $ sign is replaced by the name of the chain element; If the list name is not specified (by passing filename_elist.root/listname to; the TChain::SetEntryList() function, the first object of class TEntryList; in the file is taken.; It is assumed that there are as many lists, as there are chain elements,; and they are in the same order. If one of the list files can't be opened, or there is an error reading a list; from the file, this list is skipped and the entry loop continues on the next; list. Function Members (Methods); public:. TEntryListFromFile(); TEntryListFromFile(const TEntryListFromFile&); TEntryListFromFile(const char* filename, const char* listname, Int_t nfiles); virtual~TEntryListFromFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(const TEntryList*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tContains(Long64_t, TTree*); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTEntryList::DirectoryAutoAdd(TDi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEntryListFromFile.html:398,load,loaded,398,root/html528/TEntryListFromFile.html,https://root.cern,https://root.cern/root/html528/TEntryListFromFile.html,3,['load'],['loaded']
Performance,". TEntryListFromFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TEntryListFromFile. class TEntryListFromFile: public TEntryList. TEntryListFromFile. Manages entry lists from different files, when they are not loaded; in memory at the same time. This entry list should only be used when processing a TChain (see; TChain::SetEntryList() function). File naming convention:; - by default, filename_elist.root is used, where filename is the; name of the chain element.; - xxx$xxx.root - $ sign is replaced by the name of the chain element; If the list name is not specified (by passing filename_elist.root/listname to; the TChain::SetEntryList() function, the first object of class TEntryList; in the file is taken.; It is assumed that there are as many lists, as there are chain elements,; and they are in the same order. If one of the list files can't be opened, or there is an error reading a list; from the file, this list is skipped and the entry loop continues on the next; list. Function Members (Methods); public:. TEntryListFromFile(); TEntryListFromFile(const char* filename, const char* listname, Int_t nfiles); virtual~TEntryListFromFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(const TEntryList*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tContains(Long64_t, TTree*); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTEntryList::DirectoryAutoAdd(TDirectory*); virtual Int_tTObject::DistancetoPrim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEntryListFromFile.html:398,load,loaded,398,root/html534/TEntryListFromFile.html,https://root.cern,https://root.cern/root/html534/TEntryListFromFile.html,1,['load'],['loaded']
Performance,". TEntryListFromFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TEntryListFromFile. class TEntryListFromFile: public TEntryList. TEntryListFromFile. Manages entry lists from different files, when they are not loaded; in memory at the same time. This entry list should only be used when processing a TChain (see; TChain::SetEntryList() function). File naming convention:; - by default, filename_elist.root is used, where filename is the; name of the chain element.; - xxx$xxx.root - $ sign is replaced by the name of the chain element; If the list name is not specified (by passing filename_elist.root/listname to; the TChain::SetEntryList() function, the first object of class TEntryList; in the file is taken.; It is assumed that there are as many lists, as there are chain elements,; and they are in the same order. If one of the list files can't be opened, or there is an error reading a list; from the file, this list is skipped and the entry loop continues on the next; list. Function Members (Methods); public:. virtual~TEntryListFromFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(const TEntryList*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tContains(Long64_t, TTree*); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTEntryList::DirectoryAutoAdd(TDirectory*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::Dr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEntryListFromFile.html:398,load,loaded,398,root/html602/TEntryListFromFile.html,https://root.cern,https://root.cern/root/html602/TEntryListFromFile.html,2,['load'],['loaded']
Performance,". TF1Convolution. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TF1Convolution. class TF1Convolution. (f*g)(t) = int(f(x)g(x-t)dx) *. class wrapping convolution of two function : evaluation of TF1(t) * TF1(x-t). The convolution is performed by default using FFTW if it is available .; One can pass optionally the range of the convolution (by default the first function range is used).; Note that when using Discrete Fouriere Transform (as FFTW), it is a circular transform, so the functions should be; approximatly zero at the end of the range. If they are significantly different than zero on one side (e.g. the left side); a spill over will occur on the other side (e.g right side).; If no function range is given by default the function1 range + 10% is used; One shoud use also a not too small number of points for the DFT (a minimum of 1000). By default 10000 points are used . Function Members (Methods); public:. ~TF1Convolution(); Int_tGetNpar() const; const char*GetParName(Int_t ipar) const; Double_tGetXmax() const; Double_tGetXmin() const; Double_toperator()(Double_t* t, Double_t* p); TF1Convolution&operator=(TF1Convolution&&); TF1Convolution&operator=(const TF1Convolution&); voidSetExtraRange(Double_t percentage); voidSetNofPointsFFT(Int_t n); voidSetNumConv(Bool_t flag = true); voidSetParameters(Double_t* p); voidSetParameters(Double_t p0, Double_t p1, Double_t p2 = 0., Double_t p3 = 0., Double_t p4 = 0., Double_t p5 = 0., Double_t p6 = 0., Double_t p7 = 0.); voidSetRange(Double_t a, Double_t b); TF1Convolution(TF1Convolution&&); TF1Convolution(const TF1Convolution&); TF1Convolution(TF1* function1, TF1* function2, Bool_t useFFT = true); TF1Convolution(TString formula, Double_t xmin = 1., Double_t xmax = 0., Bool_t useFFT = true); TF1Convolution(TF1* function1, TF1* function2, Double_t xmi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TF1Convolution.html:416,perform,performed,416,root/html604/TF1Convolution.html,https://root.cern,https://root.cern/root/html604/TF1Convolution.html,1,['perform'],['performed']
Performance,". TFTP. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TFTP. class TFTP: public TObject. TFTP. This class provides all infrastructure for a performant file; transfer protocol. It works in conjuction with the rootd daemon; and can use parallel sockets to improve performance over fat pipes. Function Members (Methods); public:. TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); virtual~TFTP(); voidTObject::AbstractMethod(const char* method) const; Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); voidAscii(); voidascii(); voidbin(); voidBinary(); virtual voidTObject::Browse(TBrowser* b); voidbye(); voidcd(const char* dir) const; Int_tChangeDirectory(const char* dir) const; Int_tChangePermission(const char* file, Int_t mode) const; voidchmod(const char* file, Int_t mode) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Int_tClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeleteDirectory(const char* dir) const; Int_tDeleteFile(const char* file) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFTP.html:322,perform,performant,322,root/html528/TFTP.html,https://root.cern,https://root.cern/root/html528/TFTP.html,8,['perform'],"['performance', 'performant']"
Performance,". TFTP. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TFTP. class TFTP: public TObject. TFTP. This class provides all infrastructure for a performant file; transfer protocol. It works in conjuction with the rootd daemon; and can use parallel sockets to improve performance over fat pipes. Function Members (Methods); public:. virtual~TFTP(); voidTObject::AbstractMethod(const char* method) const; Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); voidAscii(); voidascii(); voidbin(); voidBinary(); virtual voidTObject::Browse(TBrowser* b); voidbye(); voidcd(const char* dir) const; Int_tChangeDirectory(const char* dir) const; Int_tChangePermission(const char* file, Int_t mode) const; voidchmod(const char* file, Int_t mode) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Int_tClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeleteDirectory(const char* dir) const; Int_tDeleteFile(const char* file) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFTP.html:322,perform,performant,322,root/html602/TFTP.html,https://root.cern,https://root.cern/root/html602/TFTP.html,4,['perform'],"['performance', 'performant']"
Performance,". TFileCacheRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheRead. class TFileCacheRead: public TObject. TFileCacheRead : a cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created. Function Members (Methods); public:. TFileCacheRead(); TFileCacheRead(TFile* file, Int_t buffersize); virtual~TFileCacheRead(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* err",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileCacheRead.html:318,cache,cache,318,root/html528/TFileCacheRead.html,https://root.cern,https://root.cern/root/html528/TFileCacheRead.html,12,['cache'],['cache']
Performance,". TFileCacheRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheRead. class TFileCacheRead: public TObject. TFileCacheRead : a cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created. Function Members (Methods); public:. TFileCacheRead(); TFileCacheRead(TFile* file, Int_t buffersize, TObject* tree = 0); virtual~TFileCacheRead(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidAddNoCacheBytesRead(Long64_t len); virtual voidAddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFileCacheRead.html:318,cache,cache,318,root/html534/TFileCacheRead.html,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html,4,['cache'],['cache']
Performance,". TFileCacheRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheRead. class TFileCacheRead: public TObject. TFileCacheRead : a cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created. Function Members (Methods); public:. virtual~TFileCacheRead(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddBranch(TBranch*, Bool_t = kFALSE); virtual Int_tAddBranch(const char*, Bool_t = kFALSE); virtual voidAddNoCacheBytesRead(Long64_t len); virtual voidAddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TFileCacheRead.html:318,cache,cache,318,root/html604/TFileCacheRead.html,https://root.cern,https://root.cern/root/html604/TFileCacheRead.html,4,['cache'],['cache']
Performance,". TFileCacheRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheRead. class TFileCacheRead: public TObject. TFileCacheRead : a cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created. Function Members (Methods); public:. virtual~TFileCacheRead(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidAddNoCacheBytesRead(Long64_t len); virtual voidAddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFileCacheRead.html:318,cache,cache,318,root/html602/TFileCacheRead.html,https://root.cern,https://root.cern/root/html602/TFileCacheRead.html,4,['cache'],['cache']
Performance,". TFileCacheWrite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheWrite. class TFileCacheWrite: public TObject. TFileCacheWrite : a cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()). Function Members (Methods); public:. TFileCacheWrite(); TFileCacheWrite(TFile* file, Int_t buffersize); virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileCacheWrite.html:322,cache,cache,322,root/html528/TFileCacheWrite.html,https://root.cern,https://root.cern/root/html528/TFileCacheWrite.html,20,['cache'],['cache']
Performance,". TFileCacheWrite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheWrite. class TFileCacheWrite: public TObject. TFileCacheWrite : a cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()). Function Members (Methods); public:. virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFileCacheWrite.html:322,cache,cache,322,root/html602/TFileCacheWrite.html,https://root.cern,https://root.cern/root/html602/TFileCacheWrite.html,10,['cache'],['cache']
Performance,". TFileIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TFileIter. class TFileIter: public TListIter. Class to iterate (read / write ) the events written to TFile.; The event is supposed to assign an unique ID in form of. TKey <event Id> ::= eventName ""."" run_number ""."" event_number. and stored as the TKey name of the object written. void TesTFileIter(){; // This macros tests the various methods of TFileIter class.; gSystem->Load(""libTable"");. //First create simple ROOT file; TDataSet *ds = new TDataSet(""event"");; TObject *nextObject = 0;; TRandom run;; TRandom event;; {; TFileIter outSet(""test.root"",""RECREATE"");; UInt_t totalEvent = 10;; UInt_t runNumber = 20010301;; Int_t i=0;; Int_t j=0;; for (;j < 10;j++) {; for (i = 1;i<totalEvent;i++) {; outSet.NextEventPut(ds,UInt_t(i),UInt_t(runNumber+j+10*run.Rndm()-5));; }; }; }; printf("" ----------------------> TFile has been created <--------------------\n"");; TFile *f = new TFile(""test.root"");; TFileIter readObj(f);; // the number of the object available directly from ""MyDataSet.root""; Int_t size = readObj.TotalKeys();; printf("" The total number of the objects: %d\n"",size);. //-----------------------------------------------------------------------; // Loop over all objects, read them in to memory one by one. printf("" -- > Loop over all objects, read them in to memory one by one < -- \n"");; for( readObj = 0; int(readObj) < size; ++readObj){; nextObject = *readObj;; printf("" %d bytes of the object \""%s\"" of class \""%s\"" written with TKey \""%s\"" has been read from file\n""; ,readObj.GetObjlen(); ,nextObject->GetName(); ,nextObject->IsA()->GetName(); ,(const char *)readObj; );; delete nextObject;; }; //-----------------------------------------------------------------------; // Now loop over all objects in inverse order; printf("" -- > Now lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileIter.html:618,Load,Load,618,root/html528/TFileIter.html,https://root.cern,https://root.cern/root/html528/TFileIter.html,6,['Load'],['Load']
Performance,". TFileStager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TFileStager. class TFileStager: public TNamed. TFileStager. Abstract base class defining an interface to a stager. To open a connection to a stager use the static method; Open(""<stager>""), where <stager> contains a keyword allowing to load; the relevant plug-in, e.g.; TFileStager::Open(""root://lxb6064.cern.ch""); will load TXNetFileStager and initialize it for the redirector at; lxb6046.cern.ch . Function Members (Methods); public:. TFileStager(const char* stager); TFileStager(const TFileStager&); virtual~TFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileStager.html:453,load,load,453,root/html528/TFileStager.html,https://root.cern,https://root.cern/root/html528/TFileStager.html,2,['load'],['load']
Performance,". TFileStager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TFileStager. class TFileStager: public TNamed. TFileStager. Abstract base class defining an interface to a stager. To open a connection to a stager use the static method; Open(""<stager>""), where <stager> contains a keyword allowing to load; the relevant plug-in, e.g.; TFileStager::Open(""root://lxb6064.cern.ch""); will load TXNetFileStager and initialize it for the redirector at; lxb6046.cern.ch . Function Members (Methods); public:. TFileStager(const char* stager); TFileStager(const TFileStager&); virtual~TFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFileStager.html:455,load,load,455,root/html530/TFileStager.html,https://root.cern,https://root.cern/root/html530/TFileStager.html,6,['load'],['load']
Performance,". TFileStager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TFileStager. class TFileStager: public TNamed. TFileStager. Abstract base class defining an interface to a stager. To open a connection to a stager use the static method; Open(""<stager>""), where <stager> contains a keyword allowing to load; the relevant plug-in, e.g.; TFileStager::Open(""root://lxb6064.cern.ch""); will load TXNetFileStager and initialize it for the redirector at; lxb6046.cern.ch . Function Members (Methods); public:. virtual~TFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFileStager.html:479,load,load,479,root/html602/TFileStager.html,https://root.cern,https://root.cern/root/html602/TFileStager.html,4,['load'],['load']
Performance,". TFitEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » FITPANEL; » TFitEditor. class TFitEditor: public TGMainFrame. TFitEditor. Allows to perform, explore and compare various fits. To display the new Fit panel interface right click on a histogram; or a graph to pop up the context menu and then select the menu; entry 'Fit Panel'. ""General"" Tab. The first set of GUI elements is related to the function choice; and settings. The status bar on the bottom provides information; about the current minimization settings using the following; abbreviations:; LIB - shows the current choice between Minuit/Minuit2/Fumili; MIGRAD or FUMILI points to the current minimization method in use.; Itr: - shows the maximum number of iterations nnnn set for the fit.; Prn: - can be DEF/VER/QT and shows the current print option in use. ""Predefined"" combo box - contains a list of predefined functions; in ROOT. The default one is Gaussian. ""Operation"" radio button group defines selected operational mode; between functions: NOP - no operation (default); ADD - addition; CONV - convolution (will be implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFitEditor.html:320,perform,perform,320,root/html528/TFitEditor.html,https://root.cern,https://root.cern/root/html528/TFitEditor.html,6,['perform'],['perform']
Performance,". TGButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGButton. class TGButton: public TGFrame, public TGWidget. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGButton.html:738,perform,perform,738,root/html528/TGButton.html,https://root.cern,https://root.cern/root/html528/TGButton.html,6,['perform'],['perform']
Performance,". TGCheckButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGCheckButton. class TGCheckButton: public TGTextButton. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- butt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGCheckButton.html:741,perform,perform,741,root/html528/TGCheckButton.html,https://root.cern,https://root.cern/root/html528/TGCheckButton.html,6,['perform'],['perform']
Performance,". TGLClip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLClip. class TGLClip: public TGLPhysicalShape. TGLClip. Abstract clipping shape - derives from TGLPhysicalShape; Adds clip mode (inside/outside) and pure virtual method to; approximate shape as set of planes. This plane set is used to perform; interactive clipping using OpenGL clip planes. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLClip(); voidTGLPhysicalShape::AddReference(TGLPShapeRef* ref); const TGLBoundingBox&TGLPhysicalShape::BoundingBox() const; virtual voidTGLPhysicalShape::CalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*TGLPhysicalShape::Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*TGLPhysicalShape::GetLogical() const; TGLPhysicalShape::EManipTGLPhysicalShape::GetManip() const; TGLClip::EModeGetMode() const; const TGLPhysicalShape*TGLPhysicalShape::GetNextPhysical() const; TGLVector3TGLPhysicalShape::GetScale() const; UChar_tTGLPhysicalShape::GetSelected() const; TGLVertex3TGLPhysicalShape::GetTranslation() const; UInt_tTGLPhysicalShape::ID() const; voidIncTimeStamp(); voidInvalidate(); voidTGLPhysicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; Bool_tTGLPhysicalShape::IsInvisible() const; Bool_tTGLPhysicalShape::IsModified() const; Bool_tTGLPhysicalShape::IsSelected() const; Bool_tTGLPhysicalShape::IsTransparent() const; Bool_tIsValid() const; virtual voidModified(); TGLClip&operator=(const TGLClip&); virtual voidPlaneSet(TGLPlaneSet_t& set) const; virtual voidTGLPhysicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLClip.html:479,perform,perform,479,root/html602/TGLClip.html,https://root.cern,https://root.cern/root/html602/TGLClip.html,2,['perform'],['perform']
Performance,". TGLClip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLClip. class TGLClip: public TGLPhysicalShape. TGLClip. Abstract clipping shape - derives from TGLPhysicalShape; Adds clip mode (inside/outside) and pure virtual method to; approximate shape as set of planes. This plane set is used to perform; interactive clipping using OpenGL clip planes. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLClip(); voidTGLPhysicalShape::AddReference(TGLPShapeRef* ref); const TGLBoundingBox&TGLPhysicalShape::BoundingBox() const; virtual voidTGLPhysicalShape::CalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*TGLPhysicalShape::Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*TGLPhysicalShape::GetLogical() const; TGLPhysicalShape::EManipTGLPhysicalShape::GetManip() const; TGLClip::EModeGetMode() const; const TGLPhysicalShape*TGLPhysicalShape::GetNextPhysical() const; TGLVector3TGLPhysicalShape::GetScale() const; UChar_tTGLPhysicalShape::GetSelected() const; TGLVertex3TGLPhysicalShape::GetTranslation() const; UInt_tTGLPhysicalShape::ID() const; voidIncTimeStamp(); voidInvalidate(); voidTGLPhysicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; Bool_tTGLPhysicalShape::IsInvisible() const; Bool_tTGLPhysicalShape::IsModified() const; Bool_tTGLPhysicalShape::IsSelected() const; Bool_tTGLPhysicalShape::IsTransparent() const; Bool_tIsValid() const; virtual voidModified(); virtual voidPlaneSet(TGLPlaneSet_t& set) const; virtual voidTGLPhysicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD, Short_t& quantLOD) const; voidTG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLClip.html:479,perform,perform,479,root/html528/TGLClip.html,https://root.cern,https://root.cern/root/html528/TGLClip.html,4,['perform'],['perform']
Performance,". TGLColor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLColor. class TGLColor. Class encapsulating color information in preferred GL format - an; array of four unsigned bytes.; Color index is also cached for easier interfacing with the; traditional ROOT graphics. Function Members (Methods); public:. TGLColor(); TGLColor(const TGLColor&); TGLColor(Color_t color_index, Char_t transparency = 0); TGLColor(Int_t r, Int_t g, Int_t b, Int_t a = 255); TGLColor(Float_t r, Float_t g, Float_t b, Float_t a = 1); virtual~TGLColor(); UChar_t*Arr(); TStringAsString() const; const UChar_t*CArr() const; static TClass*Class(); UChar_tGetAlpha() const; UChar_tGetBlue() const; Color_tGetColorIndex() const; UChar_tGetGreen() const; UChar_tGetRed() const; Char_tGetTransparency() const; virtual TClass*IsA() const; TGLColor&operator=(const TGLColor& c); voidSetAlpha(Int_t v); voidSetBlue(Int_t v); voidSetColor(Color_t color_index); voidSetColor(Color_t color_index, Char_t transparency); voidSetColor(Int_t r, Int_t g, Int_t b, Int_t a = 255); voidSetColor(Float_t r, Float_t g, Float_t b, Float_t a = 1); voidSetGreen(Int_t v); voidSetRed(Int_t v); voidSetTransparency(Char_t transparency); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Short_tfIndex; UChar_tfRGBA[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLColor(); Default constructor. Color is initialized to black. TGLColor(Int_t r, Int_t g, Int_t b, Int_t a = 255); Constructor from Int_t values. TGLColor(Float_t r, Float_t g, Float_t b, Float_t a = 1); Constructor from Float_t values. TGLColor(Color_t color_index, Char_t transparency = 0); Constructor from color-index and transparency. ~TGLColor(); Dectructo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLColor.html:387,cache,cached,387,root/html528/TGLColor.html,https://root.cern,https://root.cern/root/html528/TGLColor.html,3,['cache'],['cached']
Performance,". TGLColor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLColor. class TGLColor. Class encapsulating color information in preferred GL format - an; array of four unsigned bytes.; Color index is also cached for easier interfacing with the; traditional ROOT graphics. Function Members (Methods); public:. TGLColor(); TGLColor(const TGLColor&); TGLColor(Color_t color_index, Char_t transparency = 0); TGLColor(Int_t r, Int_t g, Int_t b, Int_t a = 255); TGLColor(Float_t r, Float_t g, Float_t b, Float_t a = 1); virtual~TGLColor(); UChar_t*Arr(); TStringAsString() const; const UChar_t*CArr() const; static TClass*Class(); UChar_tGetAlpha() const; UChar_tGetBlue() const; Color_tGetColorIndex() const; UChar_tGetGreen() const; UChar_tGetRed() const; Char_tGetTransparency() const; virtual TClass*IsA() const; TGLColor&operator=(const TGLColor& c); voidSetAlpha(Int_t v); voidSetBlue(Int_t v); voidSetColor(Color_t color_index); voidSetColor(Color_t color_index, Char_t transparency); voidSetColor(Int_t r, Int_t g, Int_t b, Int_t a = 255); voidSetColor(Float_t r, Float_t g, Float_t b, Float_t a = 1); voidSetGreen(Int_t v); voidSetRed(Int_t v); voidSetTransparency(Char_t transparency); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. Short_tfIndex; UChar_tfRGBA[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLColor(); Default constructor. Color is initialized to black. TGLColor(Int_t r, Int_t g, Int_t b, Int_t a = 255); Constructor from Int_t values. TGLColor(Float_t r, Float_t g, Float_t b, Float_t a = 1); Constructor from Float_t values. TGLColor(Color_t color_index, Char_t transparency = 0); Constructor from color-index and transparency. ~TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLColor.html:387,cache,cached,387,root/html534/TGLColor.html,https://root.cern,https://root.cern/root/html534/TGLColor.html,1,['cache'],['cached']
Performance,". TGLColor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLColor. class TGLColor. Class encapsulating color information in preferred GL format - an; array of four unsigned bytes.; Color index is also cached for easier interfacing with the; traditional ROOT graphics. Function Members (Methods); public:. virtual~TGLColor(); UChar_t*Arr(); TStringAsString() const; const UChar_t*CArr() const; static TClass*Class(); UChar_tGetAlpha() const; UChar_tGetBlue() const; Color_tGetColorIndex() const; UChar_tGetGreen() const; UChar_tGetRed() const; Char_tGetTransparency() const; virtual TClass*IsA() const; TGLColor&operator=(const TGLColor& c); voidSetAlpha(Int_t v); voidSetBlue(Int_t v); voidSetColor(Color_t color_index); voidSetColor(Color_t color_index, Char_t transparency); voidSetColor(Int_t r, Int_t g, Int_t b, Int_t a = 255); voidSetColor(Float_t r, Float_t g, Float_t b, Float_t a = 1); voidSetGreen(Int_t v); voidSetRed(Int_t v); voidSetTransparency(Char_t transparency); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLColor(); TGLColor(const TGLColor&); TGLColor(Color_t color_index, Char_t transparency = 0); TGLColor(Int_t r, Int_t g, Int_t b, Int_t a = 255); TGLColor(Float_t r, Float_t g, Float_t b, Float_t a = 1). Data Members; protected:. Short_tfIndex; UChar_tfRGBA[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLColor(); Default constructor. Color is initialized to black. TGLColor(Int_t r, Int_t g, Int_t b, Int_t a = 255); Constructor from Int_t values. TGLColor(Float_t r, Float_t g, Float_t b, Float_t a = 1); Constructor from Float_t values. TGLColor(Color_t color_index, Char_t transparency = 0); Constructor from color-index and transp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLColor.html:387,cache,cached,387,root/html602/TGLColor.html,https://root.cern,https://root.cern/root/html602/TGLColor.html,2,['cache'],['cached']
Performance,". TGLPhysicalShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPhysicalShape. class TGLPhysicalShape. Concrete physical shape - a GL drawable. Physical shapes are the; objects the user can actually see, select, move in the viewer. It is; a placement of the associated local frame TGLLogicaShape into the; world frame. The draw process is:. Load attributes - material colors etc; Load translation matrix - placement; Load gl name (for selection); Call our associated logical shape Draw() to draw placed shape. The physical shape supports translation, scaling and rotation,; selection, color changes, and permitted modification flags etc.; A physical shape cannot modify or be bound to another (or no); logical shape - hence const & handle. It can perform mutable; reference counting on the logical to enable purging. Physical shape also maintains a list of references to it and; provides notifications of change and destruction.; See class TGLPShapeRef which needs to be sub-classes for real use. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how external viewer clients use it. Function Members (Methods); public:. TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const TGLMatrix& transform, Bool_t invertedWind, const Float_t* rgba); TGLPhysicalShape(UInt_t ID, const TGLLogicalShape& logicalShape, const double* transform, Bool_t invertedWind, const Float_t* rgba); virtual~TGLPhysicalShape(); voidAddReference(TGLPShapeRef* ref); const TGLBoundingBox&BoundingBox() const; virtual voidCalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*GetLogical() const; TGLPhysicalShape::EManipGetManip() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLPhysicalShape.html:531,Load,Load,531,root/html528/TGLPhysicalShape.html,https://root.cern,https://root.cern/root/html528/TGLPhysicalShape.html,16,"['Load', 'perform']","['Load', 'perform']"
Performance,". TGLPhysicalShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPhysicalShape. class TGLPhysicalShape. Concrete physical shape - a GL drawable. Physical shapes are the; objects the user can actually see, select, move in the viewer. It is; a placement of the associated local frame TGLLogicaShape into the; world frame. The draw process is:. Load attributes - material colors etc; Load translation matrix - placement; Load gl name (for selection); Call our associated logical shape Draw() to draw placed shape. The physical shape supports translation, scaling and rotation,; selection, color changes, and permitted modification flags etc.; A physical shape cannot modify or be bound to another (or no); logical shape - hence const & handle. It can perform mutable; reference counting on the logical to enable purging. Physical shape also maintains a list of references to it and; provides notifications of change and destruction.; See class TGLPShapeRef which needs to be sub-classes for real use. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how external viewer clients use it. Function Members (Methods); public:. virtual~TGLPhysicalShape(); voidAddReference(TGLPShapeRef* ref); const TGLBoundingBox&BoundingBox() const; virtual voidCalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*GetLogical() const; TGLPhysicalShape::EManipGetManip() const; const TGLPhysicalShape*GetNextPhysical() const; TGLVector3GetScale() const; UChar_tGetSelected() const; TGLVertex3GetTranslation() const; UInt_tID() const; voidInvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; Bool_tIsInvisibl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLPhysicalShape.html:531,Load,Load,531,root/html602/TGLPhysicalShape.html,https://root.cern,https://root.cern/root/html602/TGLPhysicalShape.html,8,"['Load', 'perform']","['Load', 'perform']"
Performance,". TGLScene. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLScene. class TGLScene: public TGLSceneBase. TGLScene provides managememnt and rendering of ROOT's default 3D; object representation as logical and physical shapes. A GL scene is the container for all the viewable objects (shapes); loaded into the viewer. It consists of two main stl::maps containing; the TGLLogicalShape and TGLPhysicalShape collections, and interface; functions enabling viewers to manage objects in these. The physical; shapes defined the placement of copies of the logical shapes - see; TGLLogicalShape/TGLPhysicalShape for more information on relationship. The scene can be drawn by owning viewer, passing camera, draw style; & quality (LOD), clipping etc - see Draw(). The scene can also be; drawn for selection in similar fashion - see Select(). The scene; keeps track of a single selected physical - which can be modified by; viewers. The scene maintains a lazy calculated bounding box for the total; scene extents, axis aligned round TGLPhysicalShape shapes. Currently a scene is owned exclusively by one viewer - however it is; intended that it could easily be shared by multiple viewers - for; efficiency and syncronisation reasons. Hence viewer variant objects; camera, clips etc being owned by viewer and passed at draw/select. Function Members (Methods); public:. TGLScene(); virtual~TGLScene(); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidAdoptLogical(TGLLogicalShape& shape); virtual voidAdoptPhysical(TGLPhysicalShape& shape); UInt_tBeginSmartRefresh(); virtual Bool_tBeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*TGLSceneBase::Clip() const; virtual TGLScene::TSceneInfo*CreateSceneInfo(TGLViewerBase* view); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLScene.html:477,load,loaded,477,root/html528/TGLScene.html,https://root.cern,https://root.cern/root/html528/TGLScene.html,4,['load'],['loaded']
Performance,". TGLScene. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLScene. class TGLScene: public TGLSceneBase. TGLScene provides managememnt and rendering of ROOT's default 3D; object representation as logical and physical shapes. A GL scene is the container for all the viewable objects (shapes); loaded into the viewer. It consists of two main stl::maps containing; the TGLLogicalShape and TGLPhysicalShape collections, and interface; functions enabling viewers to manage objects in these. The physical; shapes defined the placement of copies of the logical shapes - see; TGLLogicalShape/TGLPhysicalShape for more information on relationship. The scene can be drawn by owning viewer, passing camera, draw style; & quality (LOD), clipping etc - see Draw(). The scene can also be; drawn for selection in similar fashion - see Select(). The scene; keeps track of a single selected physical - which can be modified by; viewers. The scene maintains a lazy calculated bounding box for the total; scene extents, axis aligned round TGLPhysicalShape shapes. Currently a scene is owned exclusively by one viewer - however it is; intended that it could easily be shared by multiple viewers - for; efficiency and syncronisation reasons. Hence viewer variant objects; camera, clips etc being owned by viewer and passed at draw/select. Function Members (Methods); public:. virtual~TGLScene(); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidAdoptLogical(TGLLogicalShape& shape); virtual voidAdoptPhysical(TGLPhysicalShape& shape); UInt_tBeginSmartRefresh(); virtual Bool_tBeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*TGLSceneBase::Clip() const; virtual TGLScene::TSceneInfo*CreateSceneInfo(TGLViewerBase* view); TGLLockable:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLScene.html:477,load,loaded,477,root/html602/TGLScene.html,https://root.cern,https://root.cern/root/html602/TGLScene.html,2,['load'],['loaded']
Performance,". TGLSceneInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLSceneInfo. class TGLSceneInfo. TGLSceneInfo. Base class for extended scene context. Scenes can be shared among several viewers and each scene needs to; cache some viewer/camera/clipping specific state => this is a; storage class for this data. Sub-classes of TGLSceneBase can override the virtual; CreateSceneInfo() method and in it instantiate a sub-class of; TGLSceneInfo containing the needed information. See TGLScene and; inner class SceneInfo; note that some casting is needed in actual; methods as TGLRnrCtx holds the base-class pointer. Function Members (Methods); public:. TGLSceneInfo(TGLViewerBase* view = 0, TGLSceneBase* scene = 0); virtual~TGLSceneInfo(); UInt_tCameraStamp() const; static TClass*Class(); TGLClip*Clip() const; Char_tClipMode() const; voidClipMode(Char_t m); vector<TGLPlane>&ClipPlanes(); UInt_tClipStamp() const; vector<TGLPlane>&FrustumPlanes(); Bool_tGetActive() const; TGLSceneBase*GetScene() const; const TGLBoundingBox&GetTransformedBBox(); TGLViewerBase*GetViewer() const; Bool_tHasUpdateTimeouted() const; voidInClip(Bool_t c); voidInFrustum(Bool_t f); virtual TClass*IsA() const; Bool_tIsInClip() const; Bool_tIsInFrustum() const; Bool_tIsVisible() const; TGLCamera*LastCamera() const; TGLClip*LastClip() const; Short_tLastLOD() const; Float_tLastOLLineW() const; Short_tLastStyle() const; Float_tLastWFLineW() const; Short_tLOD() const; Float_tOLLineW() const; TGLSceneBase&RefScene() const; TGLViewerBase&RefViewer() const; voidResetCameraStamp(); voidResetClipStamp(); voidResetSceneStamp(); voidResetUpdateTimeouted(); UInt_tSceneStamp() const; voidSetActive(Bool_t a); voidSetCameraStamp(UInt_t ts); voidSetClip(TGLClip* p); voidSetClipStamp(UInt_t ts); voidSetLastCamera(TGLCamera* p); voidSetLastClip(TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLSceneInfo.html:402,cache,cache,402,root/html528/TGLSceneInfo.html,https://root.cern,https://root.cern/root/html528/TGLSceneInfo.html,4,['cache'],['cache']
Performance,. TGLSceneInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLSceneInfo. class TGLSceneInfo. TGLSceneInfo. Base class for extended scene context. Scenes can be shared among several viewers and each scene needs to; cache some viewer/camera/clipping specific state => this is a; storage class for this data. Sub-classes of TGLSceneBase can override the virtual; CreateSceneInfo() method and in it instantiate a sub-class of; TGLSceneInfo containing the needed information. See TGLScene and; inner class SceneInfo; note that some casting is needed in actual; methods as TGLRnrCtx holds the base-class pointer. Function Members (Methods); public:. virtual~TGLSceneInfo(); UInt_tCameraStamp() const; static TClass*Class(); TGLClip*Clip() const; Char_tClipMode() const; voidClipMode(Char_t m); vector<TGLPlane>&ClipPlanes(); UInt_tClipStamp() const; vector<TGLPlane>&FrustumPlanes(); Bool_tGetActive() const; TGLSceneBase*GetScene() const; const TGLBoundingBox&GetTransformedBBox(); TGLViewerBase*GetViewer() const; Bool_tHasUpdateTimeouted() const; voidInClip(Bool_t c); voidInFrustum(Bool_t f); virtual TClass*IsA() const; Bool_tIsInClip() const; Bool_tIsInFrustum() const; Bool_tIsVisible() const; TGLCamera*LastCamera() const; TGLClip*LastClip() const; Short_tLastLOD() const; Float_tLastOLLineW() const; Short_tLastStyle() const; Float_tLastWFLineW() const; Short_tLOD() const; Float_tOLLineW() const; TGLSceneBase&RefScene() const; TGLViewerBase&RefViewer() const; voidResetCameraStamp(); voidResetClipStamp(); voidResetSceneStamp(); voidResetUpdateTimeouted(); UInt_tSceneStamp() const; voidSetActive(Bool_t a); voidSetCameraStamp(UInt_t ts); voidSetClip(TGLClip* p); voidSetClipStamp(UInt_t ts); voidSetLastCamera(TGLCamera* p); voidSetLastClip(TGLClip* p); voidSetLastLOD(Short_t ld); voidSetLastOLLineW(Float_,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLSceneInfo.html:402,cache,cache,402,root/html602/TGLSceneInfo.html,https://root.cern,https://root.cern/root/html602/TGLSceneInfo.html,2,['cache'],['cache']
Performance,". TGLStopwatch. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLStopwatch. class TGLStopwatch. TGLStopwatch. Stopwatch object for timing GL work. We do not use the TStopwatch as; we need to perform GL flushing to get accurate times + we record; timing overheads here. Function Members (Methods); public:. TGLStopwatch(); TGLStopwatch(const TGLStopwatch&); virtual~TGLStopwatch(); static TClass*Class(); Double_tEnd(); virtual TClass*IsA() const; Double_tLap() const; Double_tLastRun() const; TGLStopwatch&operator=(const TGLStopwatch&); virtual voidShowMembers(TMemberInspector& insp); voidStart(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. Double_tGetClock() const. Data Members; private:. Double_tfEnd! end time (millisec); Double_tfLastRun! time of last run (milisec); Double_tfStart! start time (millisec). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLStopwatch(); Construct stopwatch object. ~TGLStopwatch(); Destroy stopwatch object. void Start(); Start timing. Double_t Lap() const; Return lap time since Start(), in milliseconds. Double_t End(); End timing, return total time since Start(), in milliseconds. Double_t GetClock(void); Get internal clock time, in milliseconds. TGLStopwatch(). Double_t LastRun() const; { return fLastRun; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLStopwatch.h 23087 2008-04-09 14:10:56Z rdm $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLStopwatch.html:376,perform,perform,376,root/html528/TGLStopwatch.html,https://root.cern,https://root.cern/root/html528/TGLStopwatch.html,1,['perform'],['perform']
Performance,". TGLStopwatch. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLStopwatch. class TGLStopwatch. TGLStopwatch. Stopwatch object for timing GL work. We do not use the TStopwatch as; we need to perform GL flushing to get accurate times + we record; timing overheads here. Function Members (Methods); public:. TGLStopwatch(); TGLStopwatch(const TGLStopwatch&); virtual~TGLStopwatch(); static TClass*Class(); Double_tEnd(); virtual TClass*IsA() const; Double_tLap() const; Double_tLastRun() const; TGLStopwatch&operator=(const TGLStopwatch&); virtual voidShowMembers(TMemberInspector& insp); voidStart(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. Double_tGetClock() const. Data Members; private:. Double_tfEnd! end time (millisec); Double_tfLastRun! time of last run (milisec); Double_tfStart! start time (millisec). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLStopwatch(); Construct stopwatch object. ~TGLStopwatch(); Destroy stopwatch object. void Start(); Start timing. Double_t Lap() const; Return lap time since Start(), in milliseconds. Double_t End(); End timing, return total time since Start(), in milliseconds. Double_t GetClock(void); Get internal clock time, in milliseconds. TGLStopwatch(). Double_t LastRun() const; { return fLastRun; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLStopwatch.h 23087 2008-04-09 14:10:56Z rdm $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGLStopwatch.html:376,perform,perform,376,root/html530/TGLStopwatch.html,https://root.cern,https://root.cern/root/html530/TGLStopwatch.html,1,['perform'],['perform']
Performance,". TGLStopwatch. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLStopwatch. class TGLStopwatch. TGLStopwatch. Stopwatch object for timing GL work. We do not use the TStopwatch as; we need to perform GL flushing to get accurate times + we record; timing overheads here. Function Members (Methods); public:. TGLStopwatch(); TGLStopwatch(const TGLStopwatch&); virtual~TGLStopwatch(); static TClass*Class(); Double_tEnd(); virtual TClass*IsA() const; Double_tLap() const; Double_tLastRun() const; TGLStopwatch&operator=(const TGLStopwatch&); virtual voidShowMembers(TMemberInspector& insp); voidStart(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. Double_tGetClock() const. Data Members; private:. Double_tfEnd! end time (millisec); Double_tfLastRun! time of last run (milisec); Double_tfStart! start time (millisec). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLStopwatch(); Construct stopwatch object. ~TGLStopwatch(); Destroy stopwatch object. void Start(); Start timing. Double_t Lap() const; Return lap time since Start(), in milliseconds. Double_t End(); End timing, return total time since Start(), in milliseconds. Double_t GetClock(void); Get internal clock time, in milliseconds. TGLStopwatch(). Double_t LastRun() const; { return fLastRun; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLStopwatch.h 23087 2008-04-09 14:10:56Z rdm $ » Last generated: 2011-11-03 20:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLStopwatch.html:376,perform,perform,376,root/html532/TGLStopwatch.html,https://root.cern,https://root.cern/root/html532/TGLStopwatch.html,1,['perform'],['perform']
Performance,". TGLStopwatch. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLStopwatch. class TGLStopwatch. TGLStopwatch. Stopwatch object for timing GL work. We do not use the TStopwatch as; we need to perform GL flushing to get accurate times + we record; timing overheads here. Function Members (Methods); public:. TGLStopwatch(); TGLStopwatch(const TGLStopwatch&); virtual~TGLStopwatch(); static TClass*Class(); Double_tEnd(); virtual TClass*IsA() const; Double_tLap() const; Double_tLastRun() const; TGLStopwatch&operator=(const TGLStopwatch&); virtual voidShowMembers(TMemberInspector&); voidStart(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. Double_tGetClock() const. Data Members; private:. Double_tfEnd! end time (millisec); Double_tfLastRun! time of last run (milisec); Double_tfStart! start time (millisec). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLStopwatch(); Construct stopwatch object. ~TGLStopwatch(); Destroy stopwatch object. void Start(); Start timing. Double_t Lap() const; Return lap time since Start(), in milliseconds. Double_t End(); End timing, return total time since Start(), in milliseconds. Double_t GetClock(void); Get internal clock time, in milliseconds. TGLStopwatch(). Double_t LastRun() const; { return fLastRun; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-03-13 19:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLStopwatch.html:376,perform,perform,376,root/html534/TGLStopwatch.html,https://root.cern,https://root.cern/root/html534/TGLStopwatch.html,1,['perform'],['perform']
Performance,". TGLStopwatch. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLStopwatch. class TGLStopwatch. TGLStopwatch. Stopwatch object for timing GL work. We do not use the TStopwatch as; we need to perform GL flushing to get accurate times + we record; timing overheads here. Function Members (Methods); public:. virtual~TGLStopwatch(); static TClass*Class(); Double_tEnd(); virtual TClass*IsA() const; Double_tLap() const; Double_tLastRun() const; TGLStopwatch&operator=(const TGLStopwatch&); virtual voidShowMembers(TMemberInspector& insp) const; voidStart(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLStopwatch(); TGLStopwatch(const TGLStopwatch&). private:. Double_tGetClock() const. Data Members; private:. Double_tfEnd! end time (millisec); Double_tfLastRun! time of last run (milisec); Double_tfStart! start time (millisec). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLStopwatch(); Construct stopwatch object. ~TGLStopwatch(); Destroy stopwatch object. void Start(); Start timing. Double_t Lap() const; Return lap time since Start(), in milliseconds. Double_t End(); End timing, return total time since Start(), in milliseconds. Double_t GetClock(void); Get internal clock time, in milliseconds. TGLStopwatch(). Double_t LastRun() const; { return fLastRun; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-02 15:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLStopwatch.html:376,perform,perform,376,root/html604/TGLStopwatch.html,https://root.cern,https://root.cern/root/html604/TGLStopwatch.html,1,['perform'],['perform']
Performance,". TGLStopwatch. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLStopwatch. class TGLStopwatch. TGLStopwatch. Stopwatch object for timing GL work. We do not use the TStopwatch as; we need to perform GL flushing to get accurate times + we record; timing overheads here. Function Members (Methods); public:. virtual~TGLStopwatch(); static TClass*Class(); Double_tEnd(); virtual TClass*IsA() const; Double_tLap() const; Double_tLastRun() const; TGLStopwatch&operator=(const TGLStopwatch&); virtual voidShowMembers(TMemberInspector& insp) const; voidStart(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLStopwatch(); TGLStopwatch(const TGLStopwatch&). private:. Double_tGetClock() const. Data Members; private:. Double_tfEnd! end time (millisec); Double_tfLastRun! time of last run (milisec); Double_tfStart! start time (millisec). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLStopwatch(); Construct stopwatch object. ~TGLStopwatch(); Destroy stopwatch object. void Start(); Start timing. Double_t Lap() const; Return lap time since Start(), in milliseconds. Double_t End(); End timing, return total time since Start(), in milliseconds. Double_t GetClock(void); Get internal clock time, in milliseconds. TGLStopwatch(). Double_t LastRun() const; { return fLastRun; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:54; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLStopwatch.html:376,perform,perform,376,root/html602/TGLStopwatch.html,https://root.cern,https://root.cern/root/html602/TGLStopwatch.html,1,['perform'],['perform']
Performance,". TGLViewer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLViewer. class TGLViewer: public TVirtualViewer3D, public TGLViewerBase, public TQObject. Base GL viewer object - used by both standalone and embedded (in pad); GL. Contains core viewer objects :. GL scene - collection of main drawn objects - see TGLStdScene; Cameras (fXyzzCamera) - ortho and perspective cameras - see TGLCamera; Clipping (fClipXyzz) - collection of clip objects - see TGLClip; Manipulators (fXyzzManip) - collection of manipulators - see TGLManip. It maintains the current active draw styles, clipping object,; manipulator, camera etc. TGLViewer is 'GUI free' in that it does not derive from any ROOT GUI; TGFrame etc - see TGLSAViewer for this. However it contains GUI; GUI style methods HandleButton() etc to which GUI events can be; directed from standalone frame or embedding pad to perform; interaction. Also, the TGLWidget needs to be created externally. It is not owned; by the viewer. For embedded (pad) GL this viewer is created directly by plugin; manager. For standalone the derived TGLSAViewer is. Function Members (Methods); public:. TGLViewer(TVirtualPad* pad); TGLViewer(TVirtualPad* pad, Int_t x, Int_t y, Int_t width, Int_t height); virtual~TGLViewer(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivated()SIGNAL ; virtual voidAddCompositeOp(UInt_t); virtual Int_tAddObject(const TBuffer3D&, Bool_t* = 0); virtual Int_tAddObject(UInt_t, const TBuffer3D&, Bool_t* = 0); virtual voidTGLViewerBase::AddOverlayElement(TGLOverlayElement* el); TGLSceneInfo*TGLViewerBase::AddScene(TGLSceneBase* scene); virtual voidTObject::AppendPad(Option_t* option = """"); voidApplySelection(); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; voidAutoFade(Float_t fade, Fl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLViewer.html:1052,perform,perform,1052,root/html528/TGLViewer.html,https://root.cern,https://root.cern/root/html528/TGLViewer.html,4,['perform'],['perform']
Performance,". TGLViewer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLViewer. class TGLViewer: public TVirtualViewer3D, public TGLViewerBase, public TQObject. Base GL viewer object - used by both standalone and embedded (in pad); GL. Contains core viewer objects :. GL scene - collection of main drawn objects - see TGLStdScene; Cameras (fXyzzCamera) - ortho and perspective cameras - see TGLCamera; Clipping (fClipXyzz) - collection of clip objects - see TGLClip; Manipulators (fXyzzManip) - collection of manipulators - see TGLManip. It maintains the current active draw styles, clipping object,; manipulator, camera etc. TGLViewer is 'GUI free' in that it does not derive from any ROOT GUI; TGFrame etc - see TGLSAViewer for this. However it contains GUI; GUI style methods HandleButton() etc to which GUI events can be; directed from standalone frame or embedding pad to perform; interaction. Also, the TGLWidget needs to be created externally. It is not owned; by the viewer. For embedded (pad) GL this viewer is created directly by plugin; manager. For standalone the derived TGLSAViewer is. Function Members (Methods); public:. virtual~TGLViewer(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivated()SIGNAL ; virtual voidAddCompositeOp(UInt_t); virtual Int_tAddObject(const TBuffer3D&, Bool_t* = 0); virtual Int_tAddObject(UInt_t, const TBuffer3D&, Bool_t* = 0); virtual voidTGLViewerBase::AddOverlayElement(TGLOverlayElement* el); TGLSceneInfo*TGLViewerBase::AddScene(TGLSceneBase* scene); virtual voidTObject::AppendPad(Option_t* option = """"); voidApplySelection(); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; voidAutoFade(Float_t fade, Float_t time = 1, Int_t steps = 10); virtual voidBeginScene(); static Bool_tTQObject::BlockAllSignals(Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLViewer.html:1052,perform,perform,1052,root/html602/TGLViewer.html,https://root.cern,https://root.cern/root/html602/TGLViewer.html,2,['perform'],['perform']
Performance,". TGPicture. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGPicture. class TGPicture: public TObject, public TRefCnt. TGPicture & TGPicturePool. The TGPicture class implements pictures and icons used in the; different GUI elements and widgets. The TGPicturePool class; implements a TGPicture cache. TGPictures are created, managed and; destroyed by the TGPicturePool. Function Members (Methods); public:. TGPicture(const TGPicture&); virtual~TGPicture(); voidTObject::AbstractMethod(const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Handle_t id, GContext_t gc, Int_t x, Int_t y) const; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGPicture.html:476,cache,cache,476,root/html528/TGPicture.html,https://root.cern,https://root.cern/root/html528/TGPicture.html,4,['cache'],['cache']
Performance,". TGPicture. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGPicture. class TGPicture: public TObject, public TRefCnt. TGPicture & TGPicturePool. The TGPicture class implements pictures and icons used in the; different GUI elements and widgets. The TGPicturePool class; implements a TGPicture cache. TGPictures are created, managed and; destroyed by the TGPicturePool. Function Members (Methods); public:. virtual~TGPicture(); voidTObject::AbstractMethod(const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Handle_t id, GContext_t gc, Int_t x, Int_t y) const; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGPicture.html:476,cache,cache,476,root/html602/TGPicture.html,https://root.cern,https://root.cern/root/html602/TGPicture.html,2,['cache'],['cache']
Performance,". TGPictureButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGPictureButton. class TGPictureButton: public TGButton. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGPictureButton.html:743,perform,perform,743,root/html528/TGPictureButton.html,https://root.cern,https://root.cern/root/html528/TGPictureButton.html,6,['perform'],['perform']
Performance,". TGPicturePool. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGPicturePool. class TGPicturePool: public TObject. TGPicture & TGPicturePool. The TGPicture class implements pictures and icons used in the; different GUI elements and widgets. The TGPicturePool class; implements a TGPicture cache. TGPictures are created, managed and; destroyed by the TGPicturePool. Function Members (Methods); public:. TGPicturePool(const TGClient* client, const char* path); virtual~TGPicturePool(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFreePicture(const TGPicture* pic); virtual Option_t*TObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGPicturePool.html:472,cache,cache,472,root/html528/TGPicturePool.html,https://root.cern,https://root.cern/root/html528/TGPicturePool.html,4,['cache'],['cache']
Performance,". TGPicturePool. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGPicturePool. class TGPicturePool: public TObject. TGPicture & TGPicturePool. The TGPicture class implements pictures and icons used in the; different GUI elements and widgets. The TGPicturePool class; implements a TGPicture cache. TGPictures are created, managed and; destroyed by the TGPicturePool. Function Members (Methods); public:. virtual~TGPicturePool(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFreePicture(const TGPicture* pic); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGPicturePool.html:472,cache,cache,472,root/html602/TGPicturePool.html,https://root.cern,https://root.cern/root/html602/TGPicturePool.html,2,['cache'],['cache']
Performance,". TGRadioButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGRadioButton. class TGRadioButton: public TGTextButton. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- butt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGRadioButton.html:741,perform,perform,741,root/html528/TGRadioButton.html,https://root.cern,https://root.cern/root/html528/TGRadioButton.html,6,['perform'],['perform']
Performance,". TGSelectedPicture. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSelectedPicture. class TGSelectedPicture: public TGPicture. TGPicture & TGPicturePool. The TGPicture class implements pictures and icons used in the; different GUI elements and widgets. The TGPicturePool class; implements a TGPicture cache. TGPictures are created, managed and; destroyed by the TGPicturePool. Function Members (Methods); public:. TGSelectedPicture(const TGClient* client, const TGPicture* p); virtual~TGSelectedPicture(); voidTObject::AbstractMethod(const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTGPicture::Draw(Handle_t id, GContext_t gc, Int_t x, Int_t y) const; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGSelectedPicture.html:486,cache,cache,486,root/html528/TGSelectedPicture.html,https://root.cern,https://root.cern/root/html528/TGSelectedPicture.html,4,['cache'],['cache']
Performance,". TGSelectedPicture. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSelectedPicture. class TGSelectedPicture: public TGPicture. TGPicture & TGPicturePool. The TGPicture class implements pictures and icons used in the; different GUI elements and widgets. The TGPicturePool class; implements a TGPicture cache. TGPictures are created, managed and; destroyed by the TGPicturePool. Function Members (Methods); public:. virtual~TGSelectedPicture(); voidTObject::AbstractMethod(const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTGPicture::Draw(Handle_t id, GContext_t gc, Int_t x, Int_t y) const; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGSelectedPicture.html:486,cache,cache,486,root/html602/TGSelectedPicture.html,https://root.cern,https://root.cern/root/html602/TGSelectedPicture.html,2,['cache'],['cache']
Performance,". TGSplitButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSplitButton. class TGSplitButton: public TGTextButton. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- butt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGSplitButton.html:741,perform,perform,741,root/html528/TGSplitButton.html,https://root.cern,https://root.cern/root/html528/TGSplitButton.html,6,['perform'],['perform']
Performance,". TGTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTable. class TGTable: public TGCompositeFrame, public TGWidget. TGTable. TGTable implements a table widget to display data in rows and; columns. The data is supplied by a TVirtualTableInterface. The table is a TGCanvas to make use of already available viewport; functionality and drawing optimizations. The top left cell in a table has coordinates (0,0). A TObjArray is used internally to ensure little overhead and fast; acces to cells. If the data source has more rows than the default 50 rows of cells in; memory, buttons at the bottom of the table can be used to load the; next or previous chunk of data. At the top of the table, a frame is visible that shows the coordinates; of the top left cell currently in memmory in row,column. The amount of; rows and columns is also shown in rows x columns. These values can be; edited to move to a different area of the data source or to resize the; table. Tab will switch between the enties, return will move to the; currently entered range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate; TVirtualTableInterface from the data that needs visualization and; then creating the TGTable using this interface. A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTable.html:530,optimiz,optimizations,530,root/html602/TGTable.html,https://root.cern,https://root.cern/root/html602/TGTable.html,4,"['load', 'optimiz']","['load', 'optimizations']"
Performance,". TGTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTable. class TGTable: public TGCompositeFrame, public TGWidget. TGTable; ; TGTable implements a table widget to display data in rows and ; columns. The data is supplied by a TVirtualTableInterface. . The table is a TGCanvas to make use of already available viewport ; functionality and drawing optimizations. . The top left cell in a table has coordinates (0,0) . A TObjArray is used internally to ensure little overhead and fast ; acces to cells. . If the data source has more rows than the default 50 rows of cells in; memory, buttons at the bottom of the table can be used to load the; next or previous chunk of data. At the top of the table, a frame is visible that shows the coordinates; of the top left cell currently in memmory in row,column. The amount of; rows and columns is also shown in rows x columns. These values can be; edited to move to a different area of the data source or to resize the; table. Tab will switch between the enties, return will move to the; currently entered range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate ; TVirtualTableInterface from the data that needs visualization and ; then creating the TGTable using this interface. . A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Creat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTable.html:536,optimiz,optimizations,536,root/html528/TGTable.html,https://root.cern,https://root.cern/root/html528/TGTable.html,6,"['load', 'optimiz']","['load', 'optimizations']"
Performance,". TGText. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGText. class TGText. TGText. A TGText is a multi line text buffer. It allows the text to be; loaded from file, saved to file and edited. It is used in the; TGTextEdit widget. Single line text is handled by TGTextBuffer; and the TGTextEntry widget. Function Members (Methods); public:. TGText(); TGText(TGText* text); TGText(const char* string); virtual~TGText(); Bool_tAddText(TGText* text); Bool_tAppend(const char* fn); TStringAsString(); Bool_tBreakLine(TGLongPosition pos); static TClass*Class(); voidClear(); Long_tColCount() const; Bool_tDelChar(TGLongPosition pos); Bool_tDelLine(ULong_t pos); Bool_tDelText(TGLongPosition start, TGLongPosition end); charGetChar(TGLongPosition pos); TGTextLine*GetCurrentLine() const; const char*GetFileName() const; char*GetLine(TGLongPosition pos, ULong_t length); Long_tGetLineLength(Long_t row); Long_tGetLongestLine() const; Bool_tInsChar(TGLongPosition pos, char c); Bool_tInsLine(ULong_t row, const char* string); Bool_tInsText(TGLongPosition pos, const char* buf); Bool_tInsText(TGLongPosition ins_pos, TGText* src, TGLongPosition start_src, TGLongPosition end_src); virtual TClass*IsA() const; Bool_tIsSaved() const; Bool_tLoad(const char* fn, Long_t startpos = 0, Long_t length = -1); Bool_tLoadBuffer(const char* txtbuf); Bool_tReplace(TGLongPosition start, const char* oldText, const char* newText, Bool_t direction, Bool_t caseSensitive); voidReTab(Long_t row); Long_tRowCount() const; Bool_tSave(const char* fn); Bool_tSearch(TGLongPosition* foundPos, TGLongPosition start, const char* searchString, Bool_t direction, Bool_t caseSensitive); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TGText(const TGText&); voidInit(); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGText.html:333,load,loaded,333,root/html528/TGText.html,https://root.cern,https://root.cern/root/html528/TGText.html,3,['load'],['loaded']
Performance,". TGText. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGText. class TGText. TGText. A TGText is a multi line text buffer. It allows the text to be; loaded from file, saved to file and edited. It is used in the; TGTextEdit widget. Single line text is handled by TGTextBuffer; and the TGTextEntry widget. Function Members (Methods); public:. TGText(); TGText(TGText* text); TGText(const char* string); virtual~TGText(); Bool_tAddText(TGText* text); Bool_tAppend(const char* fn); TStringAsString(); Bool_tBreakLine(TGLongPosition pos); static TClass*Class(); voidClear(); Long_tColCount() const; Bool_tDelChar(TGLongPosition pos); Bool_tDelLine(ULong_t pos); Bool_tDelText(TGLongPosition start, TGLongPosition end); charGetChar(TGLongPosition pos); TGTextLine*GetCurrentLine() const; const char*GetFileName() const; char*GetLine(TGLongPosition pos, ULong_t length); Long_tGetLineLength(Long_t row); Long_tGetLongestLine() const; Bool_tInsChar(TGLongPosition pos, char c); Bool_tInsLine(ULong_t row, const char* string); Bool_tInsText(TGLongPosition pos, const char* buf); Bool_tInsText(TGLongPosition ins_pos, TGText* src, TGLongPosition start_src, TGLongPosition end_src); virtual TClass*IsA() const; Bool_tIsSaved() const; Bool_tLoad(const char* fn, Long_t startpos = 0, Long_t length = -1); Bool_tLoadBuffer(const char* txtbuf); Bool_tReplace(TGLongPosition start, const char* oldText, const char* newText, Bool_t direction, Bool_t caseSensitive); voidReTab(Long_t row); Long_tRowCount() const; Bool_tSave(const char* fn); Bool_tSearch(TGLongPosition* foundPos, TGLongPosition start, const char* searchString, Bool_t direction, Bool_t caseSensitive); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. TGText(const TGTe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGText.html:333,load,loaded,333,root/html534/TGText.html,https://root.cern,https://root.cern/root/html534/TGText.html,1,['load'],['loaded']
Performance,". TGText. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGText. class TGText. TGText. A TGText is a multi line text buffer. It allows the text to be; loaded from file, saved to file and edited. It is used in the; TGTextEdit widget. Single line text is handled by TGTextBuffer; and the TGTextEntry widget. Function Members (Methods); public:. virtual~TGText(); Bool_tAddText(TGText* text); Bool_tAppend(const char* fn); TStringAsString(); Bool_tBreakLine(TGLongPosition pos); static TClass*Class(); voidClear(); Long_tColCount() const; Bool_tDelChar(TGLongPosition pos); Bool_tDelLine(ULong_t pos); Bool_tDelText(TGLongPosition start, TGLongPosition end); charGetChar(TGLongPosition pos); TGTextLine*GetCurrentLine() const; const char*GetFileName() const; char*GetLine(TGLongPosition pos, ULong_t length); Long_tGetLineLength(Long_t row); Long_tGetLongestLine() const; Bool_tInsChar(TGLongPosition pos, char c); Bool_tInsLine(ULong_t row, const char* string); Bool_tInsText(TGLongPosition pos, const char* buf); Bool_tInsText(TGLongPosition ins_pos, TGText* src, TGLongPosition start_src, TGLongPosition end_src); virtual TClass*IsA() const; Bool_tIsSaved() const; Bool_tLoad(const char* fn, Long_t startpos = 0, Long_t length = -1); Bool_tLoadBuffer(const char* txtbuf); Bool_tReplace(TGLongPosition start, const char* oldText, const char* newText, Bool_t direction, Bool_t caseSensitive); voidReTab(Long_t row); Long_tRowCount() const; Bool_tSave(const char* fn); Bool_tSearch(TGLongPosition* foundPos, TGLongPosition start, const char* searchString, Bool_t direction, Bool_t caseSensitive); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGText(); TGText(TGText* text); TGText(const char* string). protected:. voidIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGText.html:333,load,loaded,333,root/html602/TGText.html,https://root.cern,https://root.cern/root/html602/TGText.html,2,['load'],['loaded']
Performance,". TGTextButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTextButton. class TGTextButton: public TGButton. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTextButton.html:734,perform,perform,734,root/html528/TGTextButton.html,https://root.cern,https://root.cern/root/html528/TGTextButton.html,6,['perform'],['perform']
Performance,". TGTextLine. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTextLine. class TGTextLine. TGText. A TGText is a multi line text buffer. It allows the text to be; loaded from file, saved to file and edited. It is used in the; TGTextEdit widget. Single line text is handled by TGTextBuffer; and the TGTextEntry widget. Function Members (Methods); public:. TGTextLine(); TGTextLine(TGTextLine* line); TGTextLine(const char* string); virtual~TGTextLine(); static TClass*Class(); voidClear(); voidDelChar(ULong_t pos); voidDelText(ULong_t pos, ULong_t length); charGetChar(ULong_t pos); ULong_tGetLineLength(); char*GetText() const; char*GetText(ULong_t pos, ULong_t length); char*GetWord(ULong_t pos); voidInsChar(ULong_t pos, char character); voidInsText(ULong_t pos, const char* text); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TGTextLine(const TGTextLine&); TGTextLine&operator=(const TGTextLine&). Data Members; protected:. ULong_tfLengthlenght of line; TGTextLine*fNextnext line; TGTextLine*fPrevprevious line; char*fStringline of text. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGTextLine(); Create empty line of text (default ctor). TGTextLine(TGTextLine* line); Initialize line of text with other line of text (not copy ctor). TGTextLine(const char* string); Initialize line of text with a const char*. TGTextLine(const TGTextLine& ); copy constructor. TGTextLine& operator=(const TGTextLine& ); assignment operator. ~TGTextLine(); Delete a line of text. void Clear(); Clear a line of text. void DelText(ULong_t pos, ULong_t length); Delete length chars from line starting at position pos. void InsText(ULong_t pos, const char* text); Insert text in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTextLine.html:345,load,loaded,345,root/html528/TGTextLine.html,https://root.cern,https://root.cern/root/html528/TGTextLine.html,3,['load'],['loaded']
Performance,". TGTextLine. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTextLine. class TGTextLine. TGText. A TGText is a multi line text buffer. It allows the text to be; loaded from file, saved to file and edited. It is used in the; TGTextEdit widget. Single line text is handled by TGTextBuffer; and the TGTextEntry widget. Function Members (Methods); public:. TGTextLine(); TGTextLine(TGTextLine* line); TGTextLine(const char* string); virtual~TGTextLine(); static TClass*Class(); voidClear(); voidDelChar(ULong_t pos); voidDelText(ULong_t pos, ULong_t length); charGetChar(ULong_t pos); ULong_tGetLineLength(); char*GetText() const; char*GetText(ULong_t pos, ULong_t length); char*GetWord(ULong_t pos); voidInsChar(ULong_t pos, char character); voidInsText(ULong_t pos, const char* text); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. TGTextLine(const TGTextLine&); TGTextLine&operator=(const TGTextLine&). Data Members; protected:. ULong_tfLengthlength of line; TGTextLine*fNextnext line; TGTextLine*fPrevprevious line; char*fStringline of text. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGTextLine(); Create empty line of text (default ctor). TGTextLine(TGTextLine* line); Initialize line of text with other line of text (not copy ctor). TGTextLine(const char* string); Initialize line of text with a const char*. TGTextLine(const TGTextLine& ); copy constructor. TGTextLine& operator=(const TGTextLine& ); assignment operator. ~TGTextLine(); Delete a line of text. void Clear(); Clear a line of text. void DelText(ULong_t pos, ULong_t length); Delete length chars from line starting at position pos. void InsText(ULong_t pos, const char* tex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGTextLine.html:345,load,loaded,345,root/html534/TGTextLine.html,https://root.cern,https://root.cern/root/html534/TGTextLine.html,1,['load'],['loaded']
Performance,". TGTextLine. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTextLine. class TGTextLine. TGText. A TGText is a multi line text buffer. It allows the text to be; loaded from file, saved to file and edited. It is used in the; TGTextEdit widget. Single line text is handled by TGTextBuffer; and the TGTextEntry widget. Function Members (Methods); public:. virtual~TGTextLine(); static TClass*Class(); voidClear(); voidDelChar(ULong_t pos); voidDelText(ULong_t pos, ULong_t length); charGetChar(ULong_t pos); ULong_tGetLineLength(); char*GetText() const; char*GetText(ULong_t pos, ULong_t length); char*GetWord(ULong_t pos); voidInsChar(ULong_t pos, char character); voidInsText(ULong_t pos, const char* text); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGTextLine(); TGTextLine(TGTextLine* line); TGTextLine(const char* string). protected:. TGTextLine&operator=(const TGTextLine&); TGTextLine(const TGTextLine&). Data Members; protected:. ULong_tfLengthlength of line; TGTextLine*fNextnext line; TGTextLine*fPrevprevious line; char*fStringline of text. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGTextLine(); Create empty line of text (default ctor). TGTextLine(TGTextLine* line); Initialize line of text with other line of text (not copy ctor). TGTextLine(const char* string); Initialize line of text with a const char*. TGTextLine(const TGTextLine& ); copy constructor. TGTextLine& operator=(const TGTextLine& ); assignment operator. ~TGTextLine(); Delete a line of text. void Clear(); Clear a line of text. void DelText(ULong_t pos, ULong_t length); Delete length chars from line starting at position pos. void InsText(ULong_t pos, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTextLine.html:345,load,loaded,345,root/html602/TGTextLine.html,https://root.cern,https://root.cern/root/html602/TGTextLine.html,2,['load'],['loaded']
Performance,". TGTextView. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTextView. class TGTextView: public TGView. TGTextView. A TGTextView is a text viewer widget. It is a specialization of; TGView. It uses the TGText class (which contains all text; manipulation code, i.e. loading a file in memory, changing,; removing lines, etc.). Use a TGTextView to view non-editable text.; For supported messages see TGView. Function Members (Methods); public:. TGTextView(const TGWindow* parent = 0, UInt_t w = 1, UInt_t h = 1, Int_t id = -1, UInt_t sboptions = 0, Pixel_t back = GetWhitePixel()); TGTextView(const TGWindow* parent, UInt_t w, UInt_t h, TGText* text, Int_t id = -1, UInt_t sboptions = 0, Pixel_t back = GetWhitePixel()); TGTextView(const TGWindow* parent, UInt_t w, UInt_t h, const char* string, Int_t id = -1, UInt_t sboptions = 0, Pixel_t back = GetWhitePixel()); virtual~TGTextView(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidAddLine(const char* string); virtual voidAddLineFast(const char* string); virtual voidAddText(TGText* text); virtual voidAdjustWidth(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGView::ChangeBackground(Pixel_t); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTextView.html:448,load,loading,448,root/html528/TGTextView.html,https://root.cern,https://root.cern/root/html528/TGTextView.html,4,['load'],['loading']
Performance,". TGTextView. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTextView. class TGTextView: public TGView. TGTextView. A TGTextView is a text viewer widget. It is a specialization of; TGView. It uses the TGText class (which contains all text; manipulation code, i.e. loading a file in memory, changing,; removing lines, etc.). Use a TGTextView to view non-editable text.; For supported messages see TGView. Function Members (Methods); public:. virtual~TGTextView(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidAddLine(const char* string); virtual voidAddLineFast(const char* string); virtual voidAddText(TGText* text); virtual voidAdjustWidth(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGView::ChangeBackground(Pixel_t); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidClear(Option_t* = """"); virtual voidClicked(const char* word)SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTextView.html:448,load,loading,448,root/html602/TGTextView.html,https://root.cern,https://root.cern/root/html602/TGTextView.html,2,['load'],['loading']
Performance,". TGX11TTF. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » X11TTF; » TGX11TTF. class TGX11TTF: public TGX11. TGX11TTF. Interface to low level X11 (Xlib). This class gives access to basic; X11 graphics via the parent class TGX11. However, all text and font; handling is done via the Freetype TrueType library. When the; shared library containing this class is loaded the global gVirtualX; is redirected to point to this class. Function Members (Methods); public:. TGX11TTF(const TGX11& org); TGX11TTF(const TGX11TTF&); virtual~TGX11TTF(); voidTObject::AbstractMethod(const char* method) const; static voidActivate(); virtual Int_tTGX11::AddPixmap(ULong_t pixid, UInt_t w, UInt_t h); virtual Int_tTGX11::AddWindow(ULong_t qwid, UInt_t w, UInt_t h); virtual Bool_tTGX11::AllocColor(Colormap_t cmap, ColorStruct_t& color); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGX11::Bell(Int_t percent); virtual voidTObject::Browse(TBrowser* b); virtual voidTGX11::ChangeActivePointerGrab(Window_t, UInt_t, Cursor_t); virtual voidTGX11::ChangeGC(GContext_t gc, GCValues_t* gval); virtual voidTGX11::ChangeProperties(Window_t id, Atom_t property, Atom_t type, Int_t format, UChar_t* data, Int_t len); virtual voidTGX11::ChangeProperty(Window_t id, Atom_t property, Atom_t type, UChar_t* data, Int_t len); virtual voidTGX11::ChangeWindowAttributes(Window_t id, SetWindowAttributes_t* attr); virtual Bool_tTGX11::CheckEvent(Window_t id, EGEventType type, Event_t& ev); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGX11::ClearArea(Window_t id, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGX11::ClearWindow(); virtual voidTGX11::ClearWindow(Window_t id); virtual TObject*TNamed::Clone(const char* newname = """") const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGX11TTF.html:537,load,loaded,537,root/html528/TGX11TTF.html,https://root.cern,https://root.cern/root/html528/TGX11TTF.html,3,['load'],['loaded']
Performance,". TGX11TTF. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » X11TTF; » TGX11TTF. class TGX11TTF: public TGX11. TGX11TTF. Interface to low level X11 (Xlib). This class gives access to basic; X11 graphics via the parent class TGX11. However, all text and font; handling is done via the Freetype TrueType library. When the; shared library containing this class is loaded the global gVirtualX; is redirected to point to this class. Function Members (Methods); public:. TGX11TTF(const TGX11& org); TGX11TTF(const TGX11TTF&); virtual~TGX11TTF(); voidTObject::AbstractMethod(const char* method) const; static voidActivate(); virtual Int_tTGX11::AddPixmap(ULong_t pixid, UInt_t w, UInt_t h); virtual Int_tTGX11::AddWindow(ULong_t qwid, UInt_t w, UInt_t h); virtual Bool_tTGX11::AllocColor(Colormap_t cmap, ColorStruct_t& color); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualX::BeginModalSessionFor(Window_t window); virtual voidTGX11::Bell(Int_t percent); virtual voidTObject::Browse(TBrowser* b); virtual voidTGX11::ChangeActivePointerGrab(Window_t, UInt_t, Cursor_t); virtual voidTGX11::ChangeGC(GContext_t gc, GCValues_t* gval); virtual voidTGX11::ChangeProperties(Window_t id, Atom_t property, Atom_t type, Int_t format, UChar_t* data, Int_t len); virtual voidTGX11::ChangeProperty(Window_t id, Atom_t property, Atom_t type, UChar_t* data, Int_t len); virtual voidTGX11::ChangeWindowAttributes(Window_t id, SetWindowAttributes_t* attr); virtual Bool_tTGX11::CheckEvent(Window_t id, EGEventType type, Event_t& ev); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGX11::ClearArea(Window_t id, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGX11::ClearWindow(); virtual voidTGX11::ClearWindow(Window_t id); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGX11TTF.html:537,load,loaded,537,root/html534/TGX11TTF.html,https://root.cern,https://root.cern/root/html534/TGX11TTF.html,1,['load'],['loaded']
Performance,". TGX11TTF. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » X11TTF; » TGX11TTF. class TGX11TTF: public TGX11. TGX11TTF. Interface to low level X11 (Xlib). This class gives access to basic; X11 graphics via the parent class TGX11. However, all text and font; handling is done via the Freetype TrueType library. When the; shared library containing this class is loaded the global gVirtualX; is redirected to point to this class. Function Members (Methods); public:. virtual~TGX11TTF(); voidTObject::AbstractMethod(const char* method) const; static voidActivate(); virtual Int_tTGX11::AddPixmap(ULong_t pixid, UInt_t w, UInt_t h); virtual Int_tTGX11::AddWindow(ULong_t qwid, UInt_t w, UInt_t h); virtual Bool_tTGX11::AllocColor(Colormap_t cmap, ColorStruct_t& color); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualX::BeginModalSessionFor(Window_t window); virtual voidTGX11::Bell(Int_t percent); virtual voidTObject::Browse(TBrowser* b); virtual voidTGX11::ChangeActivePointerGrab(Window_t, UInt_t, Cursor_t); virtual voidTGX11::ChangeGC(GContext_t gc, GCValues_t* gval); virtual voidTGX11::ChangeProperties(Window_t id, Atom_t property, Atom_t type, Int_t format, UChar_t* data, Int_t len); virtual voidTGX11::ChangeProperty(Window_t id, Atom_t property, Atom_t type, UChar_t* data, Int_t len); virtual voidTGX11::ChangeWindowAttributes(Window_t id, SetWindowAttributes_t* attr); virtual Bool_tTGX11::CheckEvent(Window_t id, EGEventType type, Event_t& ev); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGX11::ClearArea(Window_t id, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGX11::ClearWindow(); virtual voidTGX11::ClearWindow(Window_t id); virtual TObject*TNamed::Clone(const char* newname = """") cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGX11TTF.html:537,load,loaded,537,root/html602/TGX11TTF.html,https://root.cern,https://root.cern/root/html602/TGX11TTF.html,2,['load'],['loaded']
Performance,". TGenCollectionProxy::Value. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy::Value. class TGenCollectionProxy::Value. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Value(); voidDeleteItem(void* ptr); Bool_tIsValid(); TGenCollectionProxy::Value&operator=(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(const TGenCollectionProxy::Value& inside); TGenCollectionProxy::ValueValue(const string& info). Data Members; public:. unsigned intfCasetype of data of Value_type; void*fCtorMethod cache for containee constructor; void*fDeleteMethod cache for containee delete; void*fDtorMethod cache for containee destructor; EDataTypefKindkind of ROOT-fundamental type; size_tfSizefSize of the contained object; TClassReffTypeTClass reference of Value_type in collection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Value(const Value& inside); Copy constructor. Value(const std::string& info); Initializing constructor. void DeleteItem(void* ptr); Delete individual item from STL container. Bool_t IsValid(). » Author: Markus Frank 28/10/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TGenCollectionProxy.h 36061 2010-10-04 16:05:51Z pcanal $ » Last generated: 2010-10-04 18:51; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGenCollectionProxy__Value.html:1046,cache,cache,1046,root/html528/TGenCollectionProxy__Value.html,https://root.cern,https://root.cern/root/html528/TGenCollectionProxy__Value.html,3,['cache'],['cache']
Performance,". TGenCollectionProxy::Value. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy::Value. class TGenCollectionProxy::Value. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Value(); voidDeleteItem(void* ptr); Bool_tIsValid(); TGenCollectionProxy::Value&operator=(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(const TGenCollectionProxy::Value& inside); TGenCollectionProxy::ValueValue(const string& info). Data Members; public:. unsigned intfCasetype of data of Value_type; void*fCtorMethod cache for containee constructor; void*fDeleteMethod cache for containee delete; void*fDtorMethod cache for containee destructor; EDataTypefKindkind of ROOT-fundamental type; size_tfSizefSize of the contained object; TClassReffTypeTClass reference of Value_type in collection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Value(const Value& inside); Copy constructor. Value(const std::string& info); Initializing constructor. void DeleteItem(void* ptr); Delete individual item from STL container. Bool_t IsValid(). » Author: Markus Frank 28/10/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TGenCollectionProxy.h 38934 2011-04-19 20:26:28Z pcanal $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGenCollectionProxy__Value.html:1048,cache,cache,1048,root/html530/TGenCollectionProxy__Value.html,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy__Value.html,3,['cache'],['cache']
Performance,". TGenericTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TGenericTable. class TGenericTable: public TTable. TGenericTable. This is the class to represent the array of C-struct; defined at run-time. Example: see $ROOTSYS/tutorials/tree/staff.C. !{; !// example of macro to read data from an ascii file and; !// create a root file with an histogram and an ntuple.; !// A'la the famous ROOT/PAW staff data example; !// ( see PAW - Long write up, CERN, page33. ); !; ! gROOT->Reset();; ! gSystem->Load(""libRootKernel"");; !; ! struct staff_t {; ! Int_t cat;; ! Int_t division;; ! Int_t flag;; ! Int_t age;; ! Int_t service;; ! Int_t children;; ! Int_t grade;; ! Int_t step;; ! Int_t nation;; ! Int_t hrweek;; ! Int_t cost;; ! };; !; ! staff_t staff;; !; ! // open ASCII data file; ! FILE *fp = fopen(""staff.dat"",""r"");; !; ! char line[81];; !; ! // Create the generic table for 1000 rows (it may grow then); ! TGenericTable *allStaff = new TGenericTable(""staff_t"",""Staff-data"",1000);; !; ! // Fill the memory resident table; ! while (fgets(&line,80,fp)) {; ! sscanf(&line[0] ,""%d%d%d%d"", &staff.cat,&staff.division,&staff.flag,&staff.age);; ! sscanf(&line[13],""%d%d%d%d"", &staff.service,&staff.children,&staff.grade,&staff.step);; ! sscanf(&line[24],""%d%d%d"", &staff.nation,&staff.hrweek,&staff.cost);; ! allStaff->AddAt(&staff);; ! }; ! fclose(fp);; ! // Delete unused space;; ! allStaff->Purge();; !; ! allStaff->Print(0,10);; !; !// Create ROOT file; ! TFile *f = new TFile(""aptuple.root"",""RECREATE"");; ! allStaff->Write();; ! f->Write();; !; ! // We should close TFile otherwise all histograms we create below; ! // may be written to the file too occasionaly; ! f->Close();; !; !// Create ROOT Browser; ! new TBrowser(""staff"",allStaff);; !; !// Create couple of the histograms; ! TCanvas *canva = new TCanvas(""S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGenericTable.html:685,Load,Load,685,root/html528/TGenericTable.html,https://root.cern,https://root.cern/root/html528/TGenericTable.html,6,['Load'],['Load']
Performance,". TGenericTable::iterator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TGenericTable::iterator. class TGenericTable::iterator. TGenericTable. This is the class to represent the array of C-struct; defined at run-time. Example: see $ROOTSYS/tutorials/tree/staff.C. !{; !// example of macro to read data from an ascii file and; !// create a root file with an histogram and an ntuple.; !// A'la the famous ROOT/PAW staff data example; !// ( see PAW - Long write up, CERN, page33. ); !; ! gROOT->Reset();; ! gSystem->Load(""libRootKernel"");; !; ! struct staff_t {; ! Int_t cat;; ! Int_t division;; ! Int_t flag;; ! Int_t age;; ! Int_t service;; ! Int_t children;; ! Int_t grade;; ! Int_t step;; ! Int_t nation;; ! Int_t hrweek;; ! Int_t cost;; ! };; !; ! staff_t staff;; !; ! // open ASCII data file; ! FILE *fp = fopen(""staff.dat"",""r"");; !; ! char line[81];; !; ! // Create the generic table for 1000 rows (it may grow then); ! TGenericTable *allStaff = new TGenericTable(""staff_t"",""Staff-data"",1000);; !; ! // Fill the memory resident table; ! while (fgets(&line,80,fp)) {; ! sscanf(&line[0] ,""%d%d%d%d"", &staff.cat,&staff.division,&staff.flag,&staff.age);; ! sscanf(&line[13],""%d%d%d%d"", &staff.service,&staff.children,&staff.grade,&staff.step);; ! sscanf(&line[24],""%d%d%d"", &staff.nation,&staff.hrweek,&staff.cost);; ! allStaff->AddAt(&staff);; ! }; ! fclose(fp);; ! // Delete unused space;; ! allStaff->Purge();; !; ! allStaff->Print(0,10);; !; !// Create ROOT file; ! TFile *f = new TFile(""aptuple.root"",""RECREATE"");; ! allStaff->Write();; ! f->Write();; !; ! // We should close TFile otherwise all histograms we create below; ! // may be written to the file too occasionaly; ! f->Close();; !; !// Create ROOT Browser; ! new TBrowser(""staff"",allStaff);; !; !// Create couple of the histograms; ! TCanvas *canva =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGenericTable__iterator.html:700,Load,Load,700,root/html602/TGenericTable__iterator.html,https://root.cern,https://root.cern/root/html602/TGenericTable__iterator.html,2,['Load'],['Load']
Performance,". TGeoChecker. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMPAINTER; » TGeoChecker. class TGeoChecker: public TObject. TGeoChecker - Geometry checking package. TGeoChecker class provides several geometry checking methods. There are two; types of tests that can be performed. One is based on random sampling or; ray-tracing and provides a visual check on how navigation methods work for; a given geometry. The second actually checks the validity of the geometry; definition in terms of overlapping/extruding objects. Both types of checks; can be done for a given branch (starting with a given volume) as well as for; the geometry as a whole. 1. TGeoChecker::CheckPoint(Double_t x, Double_t y, Double_t z). This method can be called direcly from the TGeoManager class and print a; report on how a given point is classified by the modeller: which is the; full path to the deepest node containing it, and the (under)estimation; of the distance to the closest boundary (safety). 2. TGeoChecker::RandomPoints(Int_t npoints). Can be called from TGeoVolume class. It first draws the volume and its; content with the current visualization settings. Then randomly samples points; in its bounding box, plotting in the geometry display only the points; classified as belonging to visible volumes. 3. TGeoChecker::RandomRays(Int_t nrays, Double_t startx, starty, startz). Can be called and acts in the same way as the previous, but instead of points,; rays having random isotropic directions are generated from the given point.; A raytracing algorithm propagates all rays untill they exit geometry, plotting; all segments crossing visible nodes in the same color as these. 4. TGeoChecker::Test(Int_t npoints). Implementation of TGeoManager::Test(). Computes the time for the modeller; to find out ""Where am I?"" for a given number of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoChecker.html:446,perform,performed,446,root/html528/TGeoChecker.html,https://root.cern,https://root.cern/root/html528/TGeoChecker.html,6,['perform'],['performed']
Performance,". TGeoCombiTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoCombiTrans. class TGeoCombiTrans: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Sc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCombiTrans.html:490,optimiz,optimize,490,root/html528/TGeoCombiTrans.html,https://root.cern,https://root.cern/root/html528/TGeoCombiTrans.html,18,"['optimiz', 'perform']","['optimize', 'performance', 'performed']"
Performance,". TGeoGenTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoGenTrans. class TGeoGenTrans: public TGeoCombiTrans. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoGenTrans.html:488,optimiz,optimize,488,root/html528/TGeoGenTrans.html,https://root.cern,https://root.cern/root/html528/TGeoGenTrans.html,18,"['optimiz', 'perform']","['optimize', 'performance', 'performed']"
Performance,". TGeoHMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoHMatrix. class TGeoHMatrix: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHMatrix.html:481,optimiz,optimize,481,root/html528/TGeoHMatrix.html,https://root.cern,https://root.cern/root/html528/TGeoHMatrix.html,18,"['optimiz', 'perform']","['optimize', 'performance', 'performed']"
Performance,". TGeoIdentity. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoIdentity. class TGeoIdentity: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoIdentity.html:484,optimiz,optimize,484,root/html528/TGeoIdentity.html,https://root.cern,https://root.cern/root/html528/TGeoIdentity.html,18,"['optimiz', 'perform']","['optimize', 'performance', 'performed']"
Performance,". TGeoIteratorPlugin. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoIteratorPlugin. class TGeoIteratorPlugin: public TObject. TGeoIterator. A geometry iterator that sequentially follows all nodes of the geometrical; hierarchy of a volume. The iterator has to be initiated with a top volume; pointer:. TGeoIterator next(myVolume);. One can use the iterator as any other in ROOT:. TGeoNode *node;; while ((node=next())) {. }. The iterator can perform 2 types of iterations that can be selected via:. next.SetType(Int_t type);. Here TYPE can be:; 0 (default) - 'first daughter next' behavior; 1 - iteration at the current level only. Supposing the tree structure looks like:. TOP ___ A_1 ___ A1_1 ___ A11_1; | | |___ A12_1; | |_____A2_1 ___ A21_1; | |___ A21_2; |___ B_1 ... The order of iteration for TYPE=0 is: A_1, A1_1, A11_1, A12_1, A2_1, A21_1,; A21_2, B_1, ...; The order of iteration for TYPE=1 is: A_1, B_1, ...; At any moment during iteration, TYPE can be changed. If the last iterated node; is for instance A1_1 and the iteration type was 0, one can do:. next.SetType(1);; The next iterated nodes will be the rest of A daughters: A2,A3,... The iterator; will return 0 after finishing all daughters of A. During iteration, the following can be retreived:; - Top volume where iteration started: TGeoIterator::GetTopVolume(); - Node at level I in the current branch: TGeoIterator::GetNode(Int_t i); - Iteration type: TGeoIterator::GetType(); - Global matrix of the current node with respect to the top volume:; TGeoIterator::GetCurrentMatrix(). The iterator can be reset by changing (or not) the top volume:. TGeoIterator::Reset(TGeoVolume *top);. Example:. We want to find out a volume named ""MyVol"" in the hierarchy of TOP volume. TIter next(TOP);; TGeoNode *node;; TString name(""MyVol"");; while ((node=ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoIteratorPlugin.html:630,perform,perform,630,root/html528/TGeoIteratorPlugin.html,https://root.cern,https://root.cern/root/html528/TGeoIteratorPlugin.html,6,['perform'],['perform']
Performance,". TGeoMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoMatrix. class TGeoMatrix: public TNamed. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse sca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoMatrix.html:474,optimiz,optimize,474,root/html528/TGeoMatrix.html,https://root.cern,https://root.cern/root/html528/TGeoMatrix.html,18,"['optimiz', 'perform']","['optimize', 'performance', 'performed']"
Performance,". TGeoRotation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoRotation. class TGeoRotation: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoRotation.html:484,optimiz,optimize,484,root/html528/TGeoRotation.html,https://root.cern,https://root.cern/root/html528/TGeoRotation.html,18,"['optimiz', 'perform']","['optimize', 'performance', 'performed']"
Performance,". TGeoScale. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoScale. class TGeoScale: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse sc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoScale.html:475,optimiz,optimize,475,root/html528/TGeoScale.html,https://root.cern,https://root.cern/root/html528/TGeoScale.html,18,"['optimiz', 'perform']","['optimize', 'performance', 'performed']"
Performance,". TGeoTranslation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoTranslation. class TGeoTranslation: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTranslation.html:493,optimiz,optimize,493,root/html528/TGeoTranslation.html,https://root.cern,https://root.cern/root/html528/TGeoTranslation.html,18,"['optimiz', 'perform']","['optimize', 'performance', 'performed']"
Performance,". TGeoVolumeEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMBUILDER; » TGeoVolumeEditor. class TGeoVolumeEditor: public TGeoGedFrame. TGeoVolumeEditor. Editor for geometry volumes and assemblies of volumes. Besides the volume; name and line attributes, a TGeoVolume has the following editable categories; split vertically by a shutter:; - Properties: one can edit the shape and medium components from here. It is; also possible to change the existing ones.; - Daughters: the main category allowing defining, editing, removing or; positioning daughter volumes inside the current edited volume. To add a; daughter, one needs to select first a volume and a matrix. Currently no check; is performed if the daughter volume creates an extrusion (illegal for tracking).; To remove or change the position of an existing daughter, one should simply; select the desired daughter from the combo box with the existing ones, then; simply click the appropriate button.; - Visualization: One can set the visibility of the volume and of its daughters,; set the visibility depth and the view type. Selecting ""All"" will draw the; volume and all visible daughters down to the selected level starting from the; edited volume. Selecting ""Leaves"" will draw just the deepest daughters within; the selected visibility level, without displaying the containers, while ""Only""; will just draw the edited volume.; - Division: The category becomes active only if there are no daughters of the; edited volume added by normal positioning (e.g. from <Daughters> category). The; minimum allowed starting value for the selected division axis is automatically; selected, while the dslicing step is set to 0 - meaning that only the number; of slices matter. Function Members (Methods); public:. TGeoVolumeEditor(const TGWindow* p = 0, Int_t width = 14",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolumeEditor.html:872,perform,performed,872,root/html534/TGeoVolumeEditor.html,https://root.cern,https://root.cern/root/html534/TGeoVolumeEditor.html,1,['perform'],['performed']
Performance,". TGeoVolumeEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMBUILDER; » TGeoVolumeEditor. class TGeoVolumeEditor: public TGeoGedFrame. TGeoVolumeEditor. Editor for geometry volumes and assemblies of volumes. Besides the volume; name and line attributes, a TGeoVolume has the following editable categories; split vertically by a shutter:; - Properties: one can edit the shape and medium components from here. It is; also possible to change the existing ones.; - Daughters: the main category allowing defining, editing, removing or; positioning daughter volumes inside the current edited volume. To add a; daughter, one needs to select first a volume and a matrix. Currently no check; is performed if the daughter volume creates an extrusion (illegal for tracking).; To remove or change the position of an existing daughter, one should simply; select the desired daughter from the combo box with the existing ones, then; simply click the appropriate button.; - Visualization: One can set the visibility of the volume and of its daughters,; set the visibility depth and the view type. Selecting ""All"" will draw the; volume and all visible daughters down to the selected level starting from the; edited volume. Selecting ""Leaves"" will draw just the deepest daughters within; the selected visibility level, without displaying the containers, while ""Only""; will just draw the edited volume.; - Division: The category becomes active only if there are no daughters of the; edited volume added by normal positioning (e.g. from <Daughters> category). The; minimum allowed starting value for the selected division axis is automatically; selected, while the dslicing step is set to 0 - meaning that only the number; of slices matter. Function Members (Methods); public:. virtual~TGeoVolumeEditor(); voidTObject::AbstractMethod(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoVolumeEditor.html:872,perform,performed,872,root/html602/TGeoVolumeEditor.html,https://root.cern,https://root.cern/root/html602/TGeoVolumeEditor.html,2,['perform'],['performed']
Performance,". TGeoVolumeEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMBUILDER; » TGeoVolumeEditor. class TGeoVolumeEditor: public TGeoGedFrame. TGeoVolumeEditor. Editor for geometry volumes and assemblies of volumes. Besides the volume; name and line attributes, a TGeoVolume has the following editable categories; splitted vertically by a shutter:; - Properties: one can edit the shape and medium components from here. It is; also possible to change the existing ones.; - Daughters: the main category allowing defining, editing, removing or; positioning daughter volumes inside the current edited volume. To add a; daughter, one needs to select first a volume and a matrix. Currently no check; is performed if the daughter volume creates an extrusion (illegal for tracking).; To remove or change the position of an existing daughter, one should simply; select the desired daughter from the combo box with the existing ones, then; simply click the appropriate button.; - Visualization: One can set the visibility of the volume and of its daughters,; set the visibility depth and the view type. Selecting ""All"" will draw the; volume and all visible daughters down to the selected level starting from the; edited volume. Selecting ""Leaves"" will draw just the deepest daughters within; the selected visibility level, without displaying the containers, while ""Only""; will just draw the edited volume.; - Division: The category becomes active only if there are no daughters of the; edited volume added by normal positioning (e.g. from <Daughters> category). The; minimum allowed starting value for the selected division axis is automatically; selected, while the dslicing step is set to 0 - meaning that only the number; of slices matter. Function Members (Methods); public:. TGeoVolumeEditor(const TGWindow* p = 0, Int_t width =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoVolumeEditor.html:875,perform,performed,875,root/html528/TGeoVolumeEditor.html,https://root.cern,https://root.cern/root/html528/TGeoVolumeEditor.html,3,['perform'],['performed']
Performance,". TGraph. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraph. class TGraph: public TNamed, public TAttLine, public TAttFill, public TAttMarker. Graph class; A Graph is a graphics object made of two arrays X and Y with npoints each. The TGraph painting is performed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class. Note:Unlike histogram or tree (or even TGraph2D), TGraph objects; are not automatically attached to the current TFile, in order to keep the; management and size of the TGraph has small as possible. The picture below gives an example:. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""A Simple Graph Example"",200,10,700,500);; Double_t x[100], y[100];; Int_t n = 20;; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }; gr = new TGraph(n,x,y);; gr->Draw(""AC*"");; return c1;; } . Function Members (Methods); public:. TGraph(); TGraph(Int_t n); TGraph(const TGraph& gr); TGraph(const TH1* h); TGraph(const TVectorF& vx, const TVectorF& vy); TGraph(const TVectorD& vx, const TVectorD& vy); TGraph(const TF1* f, Option_t* option = """"); TGraph(Int_t n, const Int_t* x, const Int_t* y); TGraph(Int_t n, const Float_t* x, const Float_t* y); TGraph(Int_t n, const Double_t* x, const Double_t* y); TGraph(const char* filename, const char* format = ""%lg %lg"", Option_t* option = """"); virtual~TGraph(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(TF1* f); virtual voidBrowse(TBrowser* b); virtual Double_tChisquare(const TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraph.html:442,perform,performed,442,root/html534/TGraph.html,https://root.cern,https://root.cern/root/html534/TGraph.html,1,['perform'],['performed']
Performance,". TGraph. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraph. class TGraph: public TNamed, public TAttLine, public TAttFill, public TAttMarker. Graph class; A Graph is a graphics object made of two arrays X and Y with npoints each. The TGraph painting is performed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class. Note:Unlike histogram or tree (or even TGraph2D), TGraph objects; are not automatically attached to the current TFile, in order to keep the; management and size of the TGraph has small as possible. The picture below gives an example:. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""A Simple Graph Example"",200,10,700,500);; Double_t x[100], y[100];; Int_t n = 20;; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }; gr = new TGraph(n,x,y);; gr->Draw(""AC*"");; return c1;; } . Function Members (Methods); public:. virtual~TGraph(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(TF1* f); virtual voidBrowse(TBrowser* b); virtual Double_tChisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; static Bool_tCompareArg(const TGraph* gr, Int_t left, Int_t right); static Bool_tCompareRadius(const TGraph* gr, Int_t left, Int_t right); static Bool_tCompareX(const TGraph* gr, Int_t left, Int_t right); static Bool_tCompareY(const TGraph* gr, Int_t left, Int_t right); virtual voidComputeRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; virtual voidTNamed::Copy(TObject& named) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraph.html:442,perform,performed,442,root/html602/TGraph.html,https://root.cern,https://root.cern/root/html602/TGraph.html,2,['perform'],['performed']
Performance,". TGraph. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraph. class TGraph: public TNamed, public TAttLine, public TAttFill, public TAttMarker. Graph class; A Graph is a graphics object made of two arrays X and Y with npoints each. The TGraph painting is performed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class. The picture below gives an example:. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""A Simple Graph Example"",200,10,700,500);; Double_t x[100], y[100];; Int_t n = 20;; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }; gr = new TGraph(n,x,y);; gr->Draw(""AC*"");; return c1;; } . Function Members (Methods); public:. TGraph(); TGraph(Int_t n); TGraph(const TGraph& gr); TGraph(const TH1* h); TGraph(const TVectorF& vx, const TVectorF& vy); TGraph(const TVectorD& vx, const TVectorD& vy); TGraph(const TF1* f, Option_t* option = """"); TGraph(Int_t n, const Int_t* x, const Int_t* y); TGraph(Int_t n, const Float_t* x, const Float_t* y); TGraph(Int_t n, const Double_t* x, const Double_t* y); TGraph(const char* filename, const char* format = ""%lg %lg"", Option_t* option = """"); virtual~TGraph(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(TF1* f); virtual voidBrowse(TBrowser* b); virtual Double_tChisquare(const TF1* f1) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; static Bool_tCompareArg(const TGraph* gr, Int_t left, Int_t right); static Bool_tCompareRadius(const TGraph* gr, Int_t left, Int_t right); static Bool_tCompareX(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGraph.html:442,perform,performed,442,root/html530/TGraph.html,https://root.cern,https://root.cern/root/html530/TGraph.html,2,['perform'],['performed']
Performance,". TGraphAsymmErrors. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraphAsymmErrors. class TGraphAsymmErrors: public TGraph. TGraphAsymmErrors class; A TGraphAsymmErrors is a TGraph with assymetric error bars. The TGraphAsymmErrors painting is performed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class. The picture below gives an example:. Picture; Source. {; c1 = new TCanvas(""c1"",""A Simple Graph with assymetric error bars"",200,10,700,500);; c1->SetFillColor(42);; c1->SetGrid();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; return c1;; } . Function Members (Methods); public:. TGraphAsymmErrors(); TGraphAsymmErrors(Int_t n); TGraphAsymmErrors(const TGraphAsymmErrors& gr); TGraphAsymmErrors(const TH1* h); TGraphAsymmErrors(const TH1* pass, const TH1* total, Option_t* option = """"); TGraphAsymmErrors(const TVectorF& vx, const TVectorF& vy, const TVectorF& vexl, const TVectorF& vexh, const TVectorF& veyl, const TVectorF& veyh); TGraphAsymmErrors(const TVectorD& vx, const TVectorD& vy, const TVectorD& vexl, const TVectorD& vexh, const TVectorD& veyl, const TVectorD& veyh); TGraphAsymmErrors(Int_t n, const Float_t* x, const Float_t* y, const Float_t* exl = 0, const Float_t* exh = 0, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraphAsymmErrors.html:430,perform,performed,430,root/html534/TGraphAsymmErrors.html,https://root.cern,https://root.cern/root/html534/TGraphAsymmErrors.html,1,['perform'],['performed']
Performance,". TGraphAsymmErrors. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraphAsymmErrors. class TGraphAsymmErrors: public TGraph. TGraphAsymmErrors class; A TGraphAsymmErrors is a TGraph with assymetric error bars. The TGraphAsymmErrors painting is performed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class. The picture below gives an example:. Picture; Source. {; c1 = new TCanvas(""c1"",""A Simple Graph with assymetric error bars"",200,10,700,500);; c1->SetFillColor(42);; c1->SetGrid();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; return c1;; } . Function Members (Methods); public:. virtual~TGraphAsymmErrors(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(TF1* f); virtual voidBayesDivide(const TH1* pass, const TH1* total, Option_t* opt = """"); virtual voidTGraph::Browse(TBrowser* b); virtual Double_tTGraph::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; static Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraphAsymmErrors.html:430,perform,performed,430,root/html602/TGraphAsymmErrors.html,https://root.cern,https://root.cern/root/html602/TGraphAsymmErrors.html,2,['perform'],['performed']
Performance,". TGraphBentErrors. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraphBentErrors. class TGraphBentErrors: public TGraph. TGraphBentErrors class; A TGraphBentErrors is a TGraph with bent, assymetric error bars. The TGraphBentErrors painting is performed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class. The picture below gives an example:. Picture; Source. {; c1 = new TCanvas(""c1"",""A Simple Graph with bent error bars"",200,10,700,500);; Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; return c1;; } . Function Members (Methods); public:. TGraphBentErrors(); TGraphBentErrors(Int_t n); TGraphBentErrors(const TGraphBentErrors& gr); TGraphBentErrors(Int_t n, const Float_t* x, const Float_t* y, const Float_t* exl = 0, const Float_t* exh = 0, const Float_t* eyl = 0, const Float_t* eyh = 0, const Float_t* exld = 0, const Float_t* exhd = 0, const Float_t* eyld = 0, const Float_t* eyhd = 0); TGraphBentErrors(Int_t n, const Double_t* x, const Double_t* y, const Double_t* exl = 0, const Double_t* exh = 0, const Double_t* eyl = 0, const D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraphBentErrors.html:430,perform,performed,430,root/html534/TGraphBentErrors.html,https://root.cern,https://root.cern/root/html534/TGraphBentErrors.html,1,['perform'],['performed']
Performance,". TGraphBentErrors. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraphBentErrors. class TGraphBentErrors: public TGraph. TGraphBentErrors class; A TGraphBentErrors is a TGraph with bent, assymetric error bars. The TGraphBentErrors painting is performed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class. The picture below gives an example:. Picture; Source. {; c1 = new TCanvas(""c1"",""A Simple Graph with bent error bars"",200,10,700,500);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; return c1;; } . Function Members (Methods); public:. virtual~TGraphBentErrors(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(TF1* f); virtual voidTGraph::Browse(TBrowser* b); virtual Double_tTGraph::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraphBentErrors.html:430,perform,performed,430,root/html602/TGraphBentErrors.html,https://root.cern,https://root.cern/root/html602/TGraphBentErrors.html,2,['perform'],['performed']
Performance,". TGraphErrors. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraphErrors. class TGraphErrors: public TGraph. TGraphErrors class; A TGraphErrors is a TGraph with error bars. The TGraphErrors painting is performed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class. The picture below gives an example:. Picture; Source. {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetFillColor(42);; c1->SetGrid();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; return c1;; } . Function Members (Methods); public:. TGraphErrors(); TGraphErrors(Int_t n); TGraphErrors(const TGraphErrors& gr); TGraphErrors(const TH1* h); TGraphErrors(const char* filename, const char* format = ""%lg %lg %lg %lg"", Option_t* option = """"); TGraphErrors(const TVectorF& vx, const TVectorF& vy, const TVectorF& vex, const TVectorF& vey); TGraphErrors(const TVectorD& vx, const TVectorD& vy, const TVectorD& vex, const TVectorD& vey); TGraphErrors(Int_t n, const Float_t* x, const Float_t* y, const Float_t* ex = 0, const Float_t* ey = 0); TGraphErrors(Int_t n, const Double_t* x, const Double_t* y, const Double_t* ex = 0, const Double_t* ey = 0); virtual~TGraphErrors(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(TF1* f); virtual voidTGraph::Browse(TBro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraphErrors.html:389,perform,performed,389,root/html534/TGraphErrors.html,https://root.cern,https://root.cern/root/html534/TGraphErrors.html,1,['perform'],['performed']
Performance,". TGraphErrors. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraphErrors. class TGraphErrors: public TGraph. TGraphErrors class; A TGraphErrors is a TGraph with error bars. The TGraphErrors painting is performed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class. The picture below gives an example:. Picture; Source. {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetFillColor(42);; c1->SetGrid();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; return c1;; } . Function Members (Methods); public:. virtual~TGraphErrors(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(TF1* f); virtual voidTGraph::Browse(TBrowser* b); static Int_tCalculateScanfFields(const char* fmt); virtual Double_tTGraph::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; static Bool_tTGraph::CompareArg(const TGraph* gr, Int_t left, Int_t right); static Bool_tTGraph::CompareRadius(const TGraph* gr, Int_t left, Int_t right); static Bool_tTGraph::CompareX(const TGraph* gr, Int_t left, Int_t right); st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraphErrors.html:389,perform,performed,389,root/html602/TGraphErrors.html,https://root.cern,https://root.cern/root/html602/TGraphErrors.html,2,['perform'],['performed']
Performance,". TGrid. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TGrid. class TGrid: public TObject. TGrid. Abstract base class defining interface to common GRID services. To open a connection to a GRID use the static method Connect().; The argument of Connect() is of the form:; <grid>[://<host>][:<port>], e.g.; alien, alien://alice.cern.ch, globus://glsvr1.cern.ch, ...; Depending on the <grid> specified an appropriate plugin library; will be loaded which will provide the real interface. Related classes are TGridResult. Function Members (Methods); public:. TGrid(); TGrid(const TGrid&); virtual~TGrid(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCd(const char* = """", Bool_t = kFALSE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual TGridResult*Command(const char*, Bool_t = kFALSE, UInt_t = 2); virtual Int_tTObject::Compare(const TObject* obj) const; static TGrid*Connect(const char* grid, const char* uid = 0, const char* pw = 0, const char* options = 0); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGrid.html:620,load,loaded,620,root/html528/TGrid.html,https://root.cern,https://root.cern/root/html528/TGrid.html,4,['load'],['loaded']
Performance,". TGrid. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TGrid. class TGrid: public TObject. TGrid. Abstract base class defining interface to common GRID services. To open a connection to a GRID use the static method Connect().; The argument of Connect() is of the form:; <grid>[://<host>][:<port>], e.g.; alien, alien://alice.cern.ch, globus://glsvr1.cern.ch, ...; Depending on the <grid> specified an appropriate plugin library; will be loaded which will provide the real interface. Related classes are TGridResult. Function Members (Methods); public:. virtual~TGrid(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCd(const char* = """", Bool_t = kFALSE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual TGridResult*Command(const char*, Bool_t = kFALSE, UInt_t = 2); virtual Int_tTObject::Compare(const TObject* obj) const; static TGrid*Connect(const char* grid, const char* uid = 0, const char* pw = 0, const char* options = 0); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGrid.html:620,load,loaded,620,root/html602/TGrid.html,https://root.cern,https://root.cern/root/html602/TGrid.html,2,['load'],['loaded']
Performance,". THbookFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HBOOK; » THbookFile. class THbookFile: public TNamed. This class is an interface to the Hbook objects in Hbook files; Any Hbook object (1-D, 2-D, Profile, RWN or CWN can be read; NB: a THbookFile can only be used in READ mode; Use the utility in $ROOTSYS/bin/h2root to convert Hbook to Root. Example of use:; gSystem->Load(""libHbook"");; THbookFile f(""myfile.hbook"");; f.ls();; TH1F *h1 = (TH1F*)f.Get(1); //import histogram ID=1 in h1; h1->Fit(""gaus"");; THbookTree *T = (THbookTree*)f.Get(111); //import ntuple header; T->Print(); //show the Hbook ntuple variables; T->Draw(""x"",""y<0""); // as in normal TTree::Draw. THbookFile can be browsed via TBrowser. Function Members (Methods); public:. THbookFile(); THbookFile(const THbookFile&); THbookFile(const char* fname, Int_t lrecl = 1024); virtual~THbookFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual Bool_tcd(const char* dirname = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TObject*Convert1D(Int_t id); virtual TObject*Convert2D(Int_t id); virtual TFile*Convert2root(const char* rootname = """", Int_t lrecl = 0, Option_t* option = """")MENU ; virtual TObject*ConvertCWN(Int_t id); virtual TObject*ConvertProfile(Int_t id); virtual TObject*ConvertRWN(Int_t id); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteID(Int_t id); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THbookFile.html:555,Load,Load,555,root/html528/THbookFile.html,https://root.cern,https://root.cern/root/html528/THbookFile.html,4,['Load'],['Load']
Performance,". THbookFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HBOOK; » THbookFile. class THbookFile: public TNamed. This class is an interface to the Hbook objects in Hbook files; Any Hbook object (1-D, 2-D, Profile, RWN or CWN can be read; NB: a THbookFile can only be used in READ mode; Use the utility in $ROOTSYS/bin/h2root to convert Hbook to Root. Example of use:; gSystem->Load(""libHbook"");; THbookFile f(""myfile.hbook"");; f.ls();; TH1F *h1 = (TH1F*)f.Get(1); //import histogram ID=1 in h1; h1->Fit(""gaus"");; THbookTree *T = (THbookTree*)f.Get(111); //import ntuple header; T->Print(); //show the Hbook ntuple variables; T->Draw(""x"",""y<0""); // as in normal TTree::Draw. THbookFile can be browsed via TBrowser. Function Members (Methods); public:. virtual~THbookFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual Bool_tcd(const char* dirname = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TObject*Convert1D(Int_t id); virtual TObject*Convert2D(Int_t id); virtual TFile*Convert2root(const char* rootname = """", Int_t lrecl = 0, Option_t* option = """")MENU ; virtual TObject*ConvertCWN(Int_t id); virtual TObject*ConvertProfile(Int_t id); virtual TObject*ConvertRWN(Int_t id); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteID(Int_t id); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THbookFile.html:555,Load,Load,555,root/html602/THbookFile.html,https://root.cern,https://root.cern/root/html602/THbookFile.html,2,['Load'],['Load']
Performance,". TIsAProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TIsAProxy. class TIsAProxy: public TVirtualIsAProxy. TClass. TIsAProxy implementation class. Function Members (Methods); public:. virtual~TIsAProxy(); virtual TClass*operator()(const void* obj); virtual voidSetClass(TClass* cl); TIsAProxy(const type_info& typ). protected:. TIsAProxy&operator=(const TIsAProxy&); TIsAProxy(const TIsAProxy&). private:. void*CacheSubType(const type_info*, TClass*); void*FindSubType(const type_info*) const. Data Members; private:. Atomic_t<TClass*>fClassActual TClass; Atomic_t<Bool_t>fInitInitialization flag; Atomic_t<void*>fLastpoints into fSubTypes map for last used values; Char_tfSubTypes[72]map of known sub-types; Atomic_t<UInt_t>fSubTypesReadersnumber of readers of fSubTypes; Atomic_t<Bool_t>fSubTypesWriteLockTakenTrue if there is a writer; const type_info*fTypeActual typeid of the proxy; Bool_tfVirtualFlag if class is virtual. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TIsAProxy(const std::type_info& typ); Standard initializing constructor. ~TIsAProxy(); Standard destructor. void SetClass(TClass* cl); Set class pointer; This method is not thread safe. TClass* operator()(const void* obj); IsA callback. void* FindSubType(const type_info* ) const; See if we have already cached the TClass that correspond to this type_info. void* CacheSubType(const type_info* , TClass* ); Record the TClass found for a type_info, so that we can retrieved it faster. TIsAProxy(const TIsAProxy& ). TIsAProxy& operator=(const TIsAProxy& ). » Author: Markus Frank 20/05/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-30 15:13; This page has been automatically generated. For comments or suggestions rega",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TIsAProxy.html:601,Cache,CacheSubType,601,root/html602/TIsAProxy.html,https://root.cern,https://root.cern/root/html602/TIsAProxy.html,1,['Cache'],['CacheSubType']
Performance,". TIsAProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TIsAProxy. class TIsAProxy: public TVirtualIsAProxy. TClass. TIsAProxy implementation class. Function Members (Methods); public:. virtual~TIsAProxy(); virtual TClass*operator()(const void* obj); virtual voidSetClass(TClass* cl); TIsAProxy(const type_info& typ). protected:. TIsAProxy&operator=(const TIsAProxy&); TIsAProxy(const TIsAProxy&). private:. void*CacheSubType(const type_info*, TClass*); void*FindSubType(const type_info*) const. Data Members; private:. Atomic_t<TClass*>fClassActual TClass; Atomic_t<Bool_t>fInitInitialization flag; Atomic_t<void*>fLastpoints into fSubTypes map for last used values; Char_tfSubTypes[72]map of known sub-types; Atomic_t<UInt_t>fSubTypesReadersnumber of readers of fSubTypes; Atomic_t<Bool_t>fSubTypesWriteLockTakenTrue if there is a writer; const type_info*fTypeActual typeid of the proxy; Bool_tfVirtualFlag if class is virtual. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TIsAProxy(const std::type_info& typ); Standard initializing constructor. ~TIsAProxy(); Standard destructor. void SetClass(TClass* cl); Set class pointer; This method is not thread safe. TClass* operator()(const void* obj); IsA callback. void* FindSubType(const type_info* ) const; See if we have already cached the TClass that correspond to this type_info. void* CacheSubType(const type_info* , TClass* ); Record the TClass found for a type_info, so that we can retrieved it faster. TIsAProxy(const TIsAProxy& ). TIsAProxy& operator=(const TIsAProxy& ). » Author: Markus Frank 20/05/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions rega",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TIsAProxy.html:601,Cache,CacheSubType,601,root/html604/TIsAProxy.html,https://root.cern,https://root.cern/root/html604/TIsAProxy.html,1,['Cache'],['CacheSubType']
Performance,". TLibraryDocInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HTML; » TLibraryDocInfo. class TLibraryDocInfo: public TNamed. Cache doc info for all known classes. Function Members (Methods); public:. TLibraryDocInfo(); TLibraryDocInfo(const char* lib); TLibraryDocInfo(const TLibraryDocInfo&); ~TLibraryDocInfo(); voidTObject::AbstractMethod(const char* method) const; voidAddDependency(const string& lib); voidAddModule(const string& module); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; set<std::string>&GetDependencies(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLibraryDocInfo.html:271,Cache,Cache,271,root/html528/TLibraryDocInfo.html,https://root.cern,https://root.cern/root/html528/TLibraryDocInfo.html,1,['Cache'],['Cache']
Performance,". TLibraryDocInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HTML; » TLibraryDocInfo. class TLibraryDocInfo: public TNamed. Cache doc info for all known classes. Function Members (Methods); public:. TLibraryDocInfo(); TLibraryDocInfo(const char* lib); TLibraryDocInfo(const TLibraryDocInfo&); ~TLibraryDocInfo(); voidTObject::AbstractMethod(const char* method) const; voidAddDependency(const string& lib); voidAddModule(const string& module); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; set<std::string>&GetDependencies(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TLibraryDocInfo.html:273,Cache,Cache,273,root/html530/TLibraryDocInfo.html,https://root.cern,https://root.cern/root/html530/TLibraryDocInfo.html,3,['Cache'],['Cache']
Performance,". TLibraryDocInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HTML; » TLibraryDocInfo. class TLibraryDocInfo: public TNamed. Caches class documentation information, like which module it belongs to,; and whether THtml should generate documentation for the class. Function Members (Methods); public:. virtual~TLibraryDocInfo(); voidTObject::AbstractMethod(const char* method) const; voidAddDependency(const string& lib); voidAddModule(const string& module); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; set<string>&GetDependencies(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TLibraryDocInfo.html:297,Cache,Caches,297,root/html602/TLibraryDocInfo.html,https://root.cern,https://root.cern/root/html602/TLibraryDocInfo.html,2,['Cache'],['Caches']
Performance,". TLinearFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TLinearFitter. class TLinearFitter: public TVirtualFitter. The Linear Fitter - fitting functions that are LINEAR IN PARAMETERS. Linear fitter is used to fit a set of data points with a linear; combination of specified functions. Note, that ""linear"" in the name; stands only for the model dependency on parameters, the specified; functions can be nonlinear.; The general form of this kind of model is. y(x) = a[0] + a[1]*f[1](x)+...a[n]*f[n](x). Functions f are fixed functions of x. For example, fitting with a; polynomial is linear fitting in this sense. The fitting method. The fit is performed using the Normal Equations method with Cholesky; decomposition. Why should it be used?. The linear fitter is considerably faster than general non-linear; fitters and doesn't require to set the initial values of parameters. Using the fitter:. 1.Adding the data points:; 1.1 To store or not to store the input data?; - There are 2 options in the constructor - to store or not; store the input data. The advantages of storing the data; are that you'll be able to reset the fitting model without; adding all the points again, and that for very large sets; of points the chisquare is calculated more precisely.; The obvious disadvantage is the amount of memory used to; keep all the points.; - Before you start adding the points, you can change the; store/not store option by StoreData() method.; 1.2 The data can be added:; - simply point by point - AddPoint() method; - an array of points at once:; If the data is already stored in some arrays, this data; can be assigned to the linear fitter without physically; coping bytes, thanks to the Use() method of; TVector and TMatrix classes - AssignData() method. 2.Setting the formula; 2.1 The linear formula sy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLinearFitter.html:837,perform,performed,837,root/html528/TLinearFitter.html,https://root.cern,https://root.cern/root/html528/TLinearFitter.html,6,['perform'],['performed']
Performance,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. TLockGuard(TVirtualMutex* mutex); virtual~TLockGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TLockGuard(const TLockGuard&); TLockGuard&operator=(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. virtual ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualMutex.h 25230 2008-08-25 15:22:04Z rdm $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLockGuard.html:419,load,loaded,419,root/html528/TLockGuard.html,https://root.cern,https://root.cern/root/html528/TLockGuard.html,1,['load'],['loaded']
Performance,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. TLockGuard(TVirtualMutex* mutex); virtual~TLockGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TLockGuard(const TLockGuard&); TLockGuard&operator=(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. virtual ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualMutex.h 25230 2008-08-25 15:22:04Z rdm $ » Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TLockGuard.html:419,load,loaded,419,root/html530/TLockGuard.html,https://root.cern,https://root.cern/root/html530/TLockGuard.html,1,['load'],['loaded']
Performance,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. TLockGuard(TVirtualMutex* mutex); virtual~TLockGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TLockGuard(const TLockGuard&); TLockGuard&operator=(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. virtual ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualMutex.h 25230 2008-08-25 15:22:04Z rdm $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLockGuard.html:419,load,loaded,419,root/html532/TLockGuard.html,https://root.cern,https://root.cern/root/html532/TLockGuard.html,1,['load'],['loaded']
Performance,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. TLockGuard(TVirtualMutex* mutex); virtual~TLockGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TLockGuard(const TLockGuard&); TLockGuard&operator=(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. virtual ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TLockGuard.html:419,load,loaded,419,root/html534/TLockGuard.html,https://root.cern,https://root.cern/root/html534/TLockGuard.html,1,['load'],['loaded']
Performance,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. ~TLockGuard(); static TClass*Class(); TClass*IsA() const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TLockGuard(TVirtualMutex* mutex); Int_tUnLock(). private:. TLockGuard&operator=(const TLockGuard&); TLockGuard(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t UnLock(). TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 13:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TLockGuard.html:419,load,loaded,419,root/html602/TLockGuard.html,https://root.cern,https://root.cern/root/html602/TLockGuard.html,1,['load'],['loaded']
Performance,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. ~TLockGuard(); static TClass*Class(); TClass*IsA() const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TLockGuard(TVirtualMutex* mutex); Int_tUnLock(). private:. TLockGuard&operator=(const TLockGuard&); TLockGuard(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t UnLock(). TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TLockGuard.html:419,load,loaded,419,root/html604/TLockGuard.html,https://root.cern,https://root.cern/root/html604/TLockGuard.html,1,['load'],['loaded']
Performance,". TMVA::MethodBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodBase. class TMVA::MethodBase: public TMVA::IMethod, public TMVA::Configurable. Virtual base Class for all MVA method; MethodBase hosts several specific evaluation methods.; The kind of MVA that provides optimal performance in an analysis strongly; depends on the particular application. The evaluation factory provides a; number of numerical benchmark results to directly assess the performance; of the MVA training on the independent test sample. These are:; ; The signal efficiency at three representative background efficiencies; (which is 1 − rejection).; The significance of an MVA estimator, defined by the difference; between the MVA mean values for signal and background, divided by the; quadratic sum of their root mean squares.; The separation of an MVA x, defined by the integral; ½∫(S(x) − B(x))2/(S(x) + B(x))dx, where; S(x) and B(x) are the signal and background distributions, respectively.; The separation is zero for identical signal and background MVA shapes,; and it is one for disjunctive shapes.; ; The average, ∫x μ(S(x))dx, of the signal μ-transform.; The μ-transform of an MVA denotes the transformation that yields; a uniform background distribution. In this way, the signal distributions; S(x) can be directly compared among the various MVAs. The stronger S(x); peaks towards one, the better is the discrimination of the MVA. The; μ-transform is; documented here.; ; The MVA standard output also prints the linear correlation coefficients between; signal and background, which can be useful to eliminate variables that exhibit too; strong correlations.; ; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; pub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodBase.html:466,perform,performance,466,root/html528/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodBase.html,10,['perform'],['performance']
Performance,". TMVA::MethodBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodBase. class TMVA::MethodBase: public TMVA::IMethod, public TMVA::Configurable. Virtual base Class for all MVA method; MethodBase hosts several specific evaluation methods.; The kind of MVA that provides optimal performance in an analysis strongly; depends on the particular application. The evaluation factory provides a; number of numerical benchmark results to directly assess the performance; of the MVA training on the independent test sample. These are:; ; The signal efficiency at three representative background efficiencies; (which is 1 − rejection).; The significance of an MVA estimator, defined by the difference; between the MVA mean values for signal and background, divided by the; quadratic sum of their root mean squares.; The separation of an MVA x, defined by the integral; ½∫(S(x) − B(x))2/(S(x) + B(x))dx, where; S(x) and B(x) are the signal and background distributions, respectively.; The separation is zero for identical signal and background MVA shapes,; and it is one for disjunctive shapes.; ; The average, ∫x μ(S(x))dx, of the signal μ-transform.; The μ-transform of an MVA denotes the transformation that yields; a uniform background distribution. In this way, the signal distributions; S(x) can be directly compared among the various MVAs. The stronger S(x); peaks towards one, the better is the discrimination of the MVA. The; μ-transform is; documented here.; ; The MVA standard output also prints the linear correlation coefficients between; signal and background, which can be useful to eliminate variables that exhibit too; strong correlations.; ; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__MethodBase.html:474,perform,performance,474,root/html604/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html604/TMVA__MethodBase.html,2,['perform'],['performance']
Performance,". TMVA::MethodBoost. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodBoost. class TMVA::MethodBoost: public TMVA::MethodCompositeBase. This class is meant to boost a single classifier. Boosting means; training the classifier a few times. Everytime the wieghts of the; events are modified according to how well the classifier performed; on the test sample. Function Members (Methods); public:. virtual~MethodBoost(); voidTObject::AbstractMethod(const char* method) const; voidAddMonitoringHist(TH1* hist); voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidTMVA::MethodCompositeBase::AddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; Bool_tBookMethod(TMVA::Types::EMVA theMethod, TString methodTitle, TString theOption); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanBoostOptions(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodBoost.html:512,perform,performed,512,root/html528/TMVA__MethodBoost.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodBoost.html,3,['perform'],['performed']
Performance,". TMVA::MethodBoost. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodBoost. class TMVA::MethodBoost: public TMVA::MethodCompositeBase. This class is meant to boost a single classifier. Boosting means; training the classifier a few times. Everytime the wieghts of the; events are modified according to how well the classifier performed; on the test sample. Function Members (Methods); public:. virtual~MethodBoost(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidTMVA::MethodCompositeBase::AddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; Bool_tBookMethod(TMVA::Types::EMVA theMethod, TString methodTitle, TString theOption); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanBoostOptions(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodBoost.html:512,perform,performed,512,root/html602/TMVA__MethodBoost.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodBoost.html,1,['perform'],['performed']
Performance,". TMVA::MethodBoost. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodBoost. class TMVA::MethodBoost: public TMVA::MethodCompositeBase. This class is meant to boost a single classifier. Boosting means; training the classifier a few times. Everytime the wieghts of the; events are modified according to how well the classifier performed; on the test sample. Function Members (Methods); public:. virtual~MethodBoost(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidTMVA::MethodCompositeBase::AddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; Bool_tBookMethod(TMVA::Types::EMVA theMethod, TString methodTitle, TString theOption); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanBoostOptions(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodBoost.html:512,perform,performed,512,root/html534/TMVA__MethodBoost.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodBoost.html,1,['perform'],['performed']
Performance,". TMVA::MethodBoost. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodBoost. class TMVA::MethodBoost: public TMVA::MethodCompositeBase. This class is meant to boost a single classifier. Boosting means; training the classifier a few times. Everytime the wieghts of the; events are modified according to how well the classifier performed; on the test sample. Function Members (Methods); public:. virtual~MethodBoost(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidTMVA::MethodCompositeBase::AddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; Bool_tBookMethod(TMVA::Types::EMVA theMethod, TString methodTitle, TString theOption); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanBoostOptions(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__MethodBoost.html:520,perform,performed,520,root/html604/TMVA__MethodBoost.html,https://root.cern,https://root.cern/root/html604/TMVA__MethodBoost.html,1,['perform'],['performed']
Performance,". TMVA::MethodCompositeBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodCompositeBase. class TMVA::MethodCompositeBase: public TMVA::MethodBase. This class is virtual class meant to combine more than one classifier; together. The training of the classifiers is done by classes that are; derived from this one, while the saving and loading of weights file; and the evaluation is done here. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodCompositeBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodCompositeBase.html:523,load,loading,523,root/html602/TMVA__MethodCompositeBase.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodCompositeBase.html,1,['load'],['loading']
Performance,". TMVA::MethodCompositeBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodCompositeBase. class TMVA::MethodCompositeBase: public TMVA::MethodBase. This class is virtual class meant to combine more than one classifier; together. The training of the classifiers is done by classes that are; derived from this one, while the saving and loading of weights file; and the evaluation is done here. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodCompositeBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::Dista",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCompositeBase.html:523,load,loading,523,root/html528/TMVA__MethodCompositeBase.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCompositeBase.html,4,['load'],['loading']
Performance,". TMVA::MethodCompositeBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodCompositeBase. class TMVA::MethodCompositeBase: public TMVA::MethodBase. This class is virtual class meant to combine more than one classifier; together. The training of the classifiers is done by classes that are; derived from this one, while the saving and loading of weights file; and the evaluation is done here. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodCompositeBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__MethodCompositeBase.html:531,load,loading,531,root/html604/TMVA__MethodCompositeBase.html,https://root.cern,https://root.cern/root/html604/TMVA__MethodCompositeBase.html,1,['load'],['loading']
Performance,". TMVA::MethodFisher. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodFisher. class TMVA::MethodFisher: public TMVA::MethodBase. Fisher and Mahalanobis Discriminants (Linear Discriminant Analysis); ; In the method of Fisher discriminants event selection is performed; in a transformed variable space with zero linear correlations, by; distinguishing the mean values of the signal and background; distributions. The linear discriminant analysis determines an axis in the (correlated); hyperspace of the input variables; such that, when projecting the output classes (signal and background); upon this axis, they are pushed as far as possible away from each other,; while events of a same class are confined in a close vicinity.; The linearity property of this method is reflected in the metric with; which ""far apart"" and ""close vicinity"" are determined: the covariance; matrix of the discriminant variable space.; . The classification of the events in signal and background classes; relies on the following characteristics (only): overall sample means,; xi, for each input variable, i,; class-specific sample means, xS(B),i,; and total covariance matrix Tij. The covariance matrix; can be decomposed into the sum of a within- (Wij); and a between-class (Bij) class matrix. They describe; the dispersion of events relative to the means of their own class (within-class; matrix), and relative to the overall sample means (between-class matrix).; The Fisher coefficients, Fi, are then given by . where in TMVA is set NS=NB, so that the factor; in front of the sum simplifies to ½.; The Fisher discriminant then reads. The offset F0 centers the sample mean of xFi; at zero. Instead of using the within-class matrix, the Mahalanobis variant; determines the Fisher coefficients as follows:. with resulting xMa that are v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodFisher.html:444,perform,performed,444,root/html528/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodFisher.html,5,['perform'],['performed']
Performance,". TMVA::MethodFisher. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodFisher. class TMVA::MethodFisher: public TMVA::MethodBase. Fisher and Mahalanobis Discriminants (Linear Discriminant Analysis); ; In the method of Fisher discriminants event selection is performed; in a transformed variable space with zero linear correlations, by; distinguishing the mean values of the signal and background; distributions. The linear discriminant analysis determines an axis in the (correlated); hyperspace of the input variables; such that, when projecting the output classes (signal and background); upon this axis, they are pushed as far as possible away from each other,; while events of a same class are confined in a close vicinity.; The linearity property of this method is reflected in the metric with; which ""far apart"" and ""close vicinity"" are determined: the covariance; matrix of the discriminant variable space.; . The classification of the events in signal and background classes; relies on the following characteristics (only): overall sample means,; xi, for each input variable, i,; class-specific sample means, xS(B),i,; and total covariance matrix Tij. The covariance matrix; can be decomposed into the sum of a within- (Wij); and a between-class (Bij) class matrix. They describe; the dispersion of events relative to the means of their own class (within-class; matrix), and relative to the overall sample means (between-class matrix).; The Fisher coefficients, Fi, are then given by . where in TMVA is set NS=NB, so that the factor; in front of the sum simplifies to ½.; The Fisher discriminant then reads. The offset F0 centers the sample mean of xFi; at zero. Instead of using the within-class matrix, the Mahalanobis variant; determines the Fisher coefficients as follows:. with resulting xMa th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__MethodFisher.html:452,perform,performed,452,root/html604/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html,1,['perform'],['performed']
Performance,". TMVA::OptimizeConfigParameters. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::OptimizeConfigParameters. class TMVA::OptimizeConfigParameters: public TMVA::IFitterTarget. Function Members (Methods); public:. virtual~OptimizeConfigParameters(); static TClass*Class(); TMVA::IFitterTargetTMVA::IFitterTarget::IFitterTarget(); TMVA::IFitterTargetTMVA::IFitterTarget::IFitterTarget(const TMVA::IFitterTarget&); virtual TClass*IsA() const; TMVA::OptimizeConfigParameters&operator=(const TMVA::OptimizeConfigParameters&); map<TString,Double_t>optimize(); TMVA::OptimizeConfigParametersOptimizeConfigParameters(const TMVA::OptimizeConfigParameters&); TMVA::OptimizeConfigParametersOptimizeConfigParameters(TMVA::MethodBase*const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); virtual voidTMVA::IFitterTarget::ProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. virtual Double_tEstimatorFunction(vector<Double_t>&); Double_tGetBkgEffAtSigEff(Double_t sigEff = 0.5); Double_tGetBkgRejAtSigEff(Double_t sigEff = 0.5); Double_tGetFOM(); TMVA::MethodBase*GetMethod(); voidGetMVADists(); Double_tGetROCIntegral(); vector<int>GetScanIndices(int val, vector<int> base); Double_tGetSeparation(); Double_tGetSigEffAtBkgEff(Double_t bkgEff = 0.10000000000000001); TMVA::MsgLogger&Log() const; voidoptimizeFit(); voidoptimizeScan(). Data Members; private:. map<vector<Double_t>,Double_t>fAlreadyTrainedParCombinationsave parameters for which the FOM is already known (GA seems to evaluate the same parameters several times); TStringfFOMTypethe FOM type (Separation, ROC integra.. whaeter you implemented..; vector<Float_t>f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__OptimizeConfigParameters.html:8,Optimiz,OptimizeConfigParameters,8,root/html602/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html602/TMVA__OptimizeConfigParameters.html,12,"['Optimiz', 'optimiz', 'tune']","['OptimizeConfigParameters', 'OptimizeConfigParametersOptimizeConfigParameters', 'optimizationType', 'optimize', 'tuneParameters']"
Performance,". TMVA::OptimizeConfigParameters. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::OptimizeConfigParameters. class TMVA::OptimizeConfigParameters: public TMVA::IFitterTarget. Function Members (Methods); public:. virtual~OptimizeConfigParameters(); static TClass*Class(); virtual TClass*IsA() const; TMVA::IFitterTarget&TMVA::IFitterTarget::operator=(const TMVA::IFitterTarget&); map<TString,Double_t>optimize(); TMVA::OptimizeConfigParametersOptimizeConfigParameters(const TMVA::OptimizeConfigParameters&); TMVA::OptimizeConfigParametersOptimizeConfigParameters(TMVA::MethodBase *const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); virtual voidTMVA::IFitterTarget::ProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. virtual Double_tEstimatorFunction(vector<Double_t>&); Double_tGetBkgEffAtSigEff(Double_t sigEff = 0.5); Double_tGetBkgRejAtSigEff(Double_t sigEff = 0.5); Double_tGetFOM(); TMVA::MethodBase*GetMethod(); voidGetMVADists(); Double_tGetROCIntegral(); vector<int>GetScanIndices(int val, vector<int> base); Double_tGetSeparation(); Double_tGetSigEffAtBkgEff(Double_t bkgEff = 0.1); TMVA::MsgLogger&Log() const; voidoptimizeFit(); voidoptimizeScan(). Data Members; private:. map<std::vector<Double_t>,Double_t>fAlreadyTrainedParCombinationsave parameters for which the FOM is already known (GA seems to evaluate the same parameters several times); TStringfFOMTypethe FOM type (Separation, ROC integra.. whaeter you implemented..; vector<Float_t>fFOMvsItergraph showing the develompment of the Figure Of Merit values during the fit; TMVA::MsgLogger*fLoggermessage logger; TMVA::MethodBase *constfMethodThe MVA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__OptimizeConfigParameters.html:8,Optimiz,OptimizeConfigParameters,8,root/html534/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html534/TMVA__OptimizeConfigParameters.html,10,"['Optimiz', 'optimiz', 'tune']","['OptimizeConfigParameters', 'OptimizeConfigParametersOptimizeConfigParameters', 'optimizationType', 'optimize', 'tuneParameters']"
Performance,". TMVA::OptimizeConfigParameters. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::OptimizeConfigParameters. class TMVA::OptimizeConfigParameters: public TMVA::IFitterTarget. Function Members (Methods); public:. virtual~OptimizeConfigParameters(); static TClass*Class(); virtual TClass*IsA() const; TMVA::IFitterTarget&TMVA::IFitterTarget::operator=(const TMVA::IFitterTarget&); map<TString,Double_t>optimize(); TMVA::OptimizeConfigParametersOptimizeConfigParameters(const TMVA::OptimizeConfigParameters&); TMVA::OptimizeConfigParametersOptimizeConfigParameters(TMVA::MethodBase *const method, map<TString,TMVA::Interval> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); virtual voidTMVA::IFitterTarget::ProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. virtual Double_tEstimatorFunction(vector<Double_t>&); Double_tGetBkgEffAtSigEff(Double_t sigEff = 0.5); Double_tGetBkgRejAtSigEff(Double_t sigEff = 0.5); Double_tGetFOM(); TMVA::MethodBase*GetMethod(); voidGetMVADists(); Double_tGetROCIntegral(); vector<int>GetScanIndices(int val, vector<int> base); Double_tGetSeparation(); Double_tGetSigEffAtBkgEff(Double_t bkgEff = 0.1); TMVA::MsgLogger&Log() const; voidoptimizeFit(); voidoptimizeScan(). Data Members; private:. map<std::vector<Double_t>,Double_t>fAlreadyTrainedParCombinationsave parameters for which the FOM is already known (GA seems to evaluate the same parameters several times); TStringfFOMTypethe FOM type (Separation, ROC integra.. whaeter you implemented..; vector<Float_t>fFOMvsItergraph showing the develompment of the Figure Of Merit values during the fit; TMVA::MsgLogger*fLoggermessage logger; TMVA::MethodBase *constfMethodThe MVA method to be evalua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__OptimizeConfigParameters.html:8,Optimiz,OptimizeConfigParameters,8,root/html530/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html530/TMVA__OptimizeConfigParameters.html,20,"['Optimiz', 'optimiz', 'tune']","['OptimizeConfigParameters', 'OptimizeConfigParametersOptimizeConfigParameters', 'optimizationType', 'optimize', 'tuneParameters']"
Performance,". TMVA::OptimizeConfigParameters. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::OptimizeConfigParameters. class TMVA::OptimizeConfigParameters: public TMVA::IFitterTarget. Function Members (Methods); public:. virtual~OptimizeConfigParameters(); static TClass*Class(); virtual TClass*IsA() const; TMVA::IFitterTarget&TMVA::IFitterTarget::operator=(const TMVA::IFitterTarget&); map<TString,Double_t>optimize(); TMVA::OptimizeConfigParametersOptimizeConfigParameters(const TMVA::OptimizeConfigParameters&); TMVA::OptimizeConfigParametersOptimizeConfigParameters(TMVA::MethodBase *const method, map<TString,TMVA::Interval> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); virtual voidTMVA::IFitterTarget::ProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. virtual Double_tEstimatorFunction(vector<Double_t>&); Double_tGetFOM(); TMVA::MethodBase*GetMethod(); voidGetMVADists(); Double_tGetROCIntegral(); Double_tGetSeparation(); Double_tGetSigEffAt(Double_t bkgEff = 0.1); TMVA::MsgLogger&Log() const; voidoptimizeFit(); voidoptimizeScan(). Data Members; private:. map<std::vector<Double_t>,Double_t>fAlreadyTrainedParCombinationsave parameters for which the FOM is already known (GA seems to evaluate the same parameters several times); TStringfFOMTypethe FOM type (Separation, ROC integra.. whaeter you implemented..; vector<Float_t>fFOMvsItergraph showing the develompment of the Figure Of Merit values during the fit; TMVA::MsgLogger*fLoggermessage logger; TMVA::MethodBase *constfMethodThe MVA method to be evaluated; TH1D*fMvaBkgMVA distrituion for bakgr. events, used for spline fit; TH1D*fMvaBkgFineBinMVA distrituion for bakgr. events; TH1D*fMvaSigMVA distrituion for s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__OptimizeConfigParameters.html:8,Optimiz,OptimizeConfigParameters,8,root/html528/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html528/TMVA__OptimizeConfigParameters.html,10,"['Optimiz', 'optimiz', 'tune']","['OptimizeConfigParameters', 'OptimizeConfigParametersOptimizeConfigParameters', 'optimizationType', 'optimize', 'tuneParameters']"
Performance,". TMVA::OptimizeConfigParameters. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::OptimizeConfigParameters. class TMVA::OptimizeConfigParameters: public TMVA::IFitterTarget. Function Members (Methods); public:. virtual~OptimizeConfigParameters(); static TClass*Class(); TMVA::IFitterTargetTMVA::IFitterTarget::IFitterTarget(); TMVA::IFitterTargetTMVA::IFitterTarget::IFitterTarget(const TMVA::IFitterTarget&); virtual TClass*IsA() const; TMVA::OptimizeConfigParameters&operator=(const TMVA::OptimizeConfigParameters&); map<TString,Double_t>optimize(); TMVA::OptimizeConfigParametersOptimizeConfigParameters(const TMVA::OptimizeConfigParameters&); TMVA::OptimizeConfigParametersOptimizeConfigParameters(TMVA::MethodBase*const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); virtual voidTMVA::IFitterTarget::ProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. virtual Double_tEstimatorFunction(vector<Double_t>&); Double_tGetBkgEffAtSigEff(Double_t sigEff = 0.5); Double_tGetBkgRejAtSigEff(Double_t sigEff = 0.5); Double_tGetFOM(); TMVA::MethodBase*GetMethod(); voidGetMVADists(); Double_tGetROCIntegral(); vector<int>GetScanIndices(int val, vector<int> base); Double_tGetSeparation(); Double_tGetSigEffAtBkgEff(Double_t bkgEff = 0.10000000000000001); TMVA::MsgLogger&Log() const; voidoptimizeFit(); voidoptimizeScan(). Data Members; private:. map<vector<Double_t>,Double_t>fAlreadyTrainedParCombinationsave parameters for which the FOM is already known (GA seems to evaluate the same parameters several times); TStringfFOMTypethe FOM type (Separation, ROC integra.. whaeter you implemented..; vector<F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html:8,Optimiz,OptimizeConfigParameters,8,root/html604/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html604/TMVA__OptimizeConfigParameters.html,12,"['Optimiz', 'optimiz', 'tune']","['OptimizeConfigParameters', 'OptimizeConfigParametersOptimizeConfigParameters', 'optimizationType', 'optimize', 'tuneParameters']"
Performance,". TMVA::RootFinder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TMVA::RootFinder. class TMVA::RootFinder: public TObject. User Class to find the Root of one dimensional functions.; The GSL Methods are implemented in MathMore and they are loaded automatically; via the plug-in manager. The possible types of Root-finding algorithms are:; <ul>; <li>Root Bracketing Algorithms which do not require function derivatives; <ol>; <li>RootFinder::kBRENT (default method implemented in MathCore); <li>RootFinder::kGSL_BISECTION; <li>RootFinder::kGSL_FALSE_POS; <li>RootFinder::kGSL_BRENT; </ol>; <li>Root Finding Algorithms using Derivatives; <ol>; <li>RootFinder::kGSL_NEWTON; <li>RootFinder::kGSL_SECANT; <li>RootFinder::kGSL_STEFFENSON; </ol>; </ul>. This class does not cupport copying. @ingroup RootFinders. Function Members (Methods); public:. virtual~RootFinder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__RootFinder.html:405,load,loaded,405,root/html602/TMVA__RootFinder.html,https://root.cern,https://root.cern/root/html602/TMVA__RootFinder.html,2,['load'],['loaded']
Performance,". TMatrixDColumn(A,j) *= r; column \(j\). TMatrixDDiag(A) *= r; matrix diagonal. TMatrixDSub(A,i,l,j,k) *= r; sub matrix. Description; Format; Comment. TMatrixDRow(A,i1) += TMatrixDRow const(B,i2); add row \(i2\) to row \(i1\). add matrix slice; TMatrixDColumn(A,j1) += TMatrixDColumn const(A,j2); add column \(j2\) to column \(j1\). TMatrixDDiag(A) += TMatrixDDiag const(B); add \(B\) diagonal to \(A\) diagonal. TMatrixDRow(A,i1) *= TMatrixDRow const(B,i2); multiply row \(i2\) with row \(i1\) element wise. TMatrixDColumn(A,j1) *= TMatrixDColumn const(A,j2); multiply column \(j2\) with column \(j1\) element wise. multiply matrix slice; TMatrixDDiag(A) *= TMatrixDDiag const(B); multiply \(B\) diagonal with \(A\) diagonal element wise. TMatrixDSub(A,i1,l1,j1,k1) *= TMatrixDSub(B,i2,l2,j2,k2); multiply sub matrix of \(A\) with sub matrix of \(B\). TMatrixDSub(A,i,l,j,k) *= B; multiply sub matrix of \(A\) with matrix of \(B\). In the current implementation of the matrix views, the user could perform operations on a symmetric matrix that violate the symmetry. No checking is done. For instance, the following code violates the symmetry.; TMatrixDSym A(5);; A.UnitMatrix();; TMatrixDRow(A,1)[0] = 1;; TMatrixDRow(A,1)[2] = 1;; 14.5.2 View Examples; Inserting row i1into rowi2 of matrix \(A\) can easily accomplished through:; TMatrixDRow(A,i1) = TMatrixDRow(A,i2); Which more readable than:; const Int_t ncols = A.GetNcols();; Double_t *start = A.GetMatrixArray();; Double_t *rp1 = start+i*ncols;; const Double_t *rp2 = start+j*ncols;; while (rp1 < start+ncols) *rp1++ = *rp2++;; Check that the columns of a Haar -matrix of order order are indeed orthogonal:; const TMatrixD haar = THaarMatrixD(order);; TVectorD colj(1<<order);; TVectorD coll(1<<order);; for (Int_t j = haar.GetColLwb(); j <= haar.GetColUpb(); j++) {; colj = TMatrixDColumn_const(haar,j);; Assert(TMath::Abs(colj*colj-1.0) <= 1.0e-15);. for (Int_t l = j+1; l <= haar.GetColUpb(); l++) {; coll = TMatrixDColumn_const(haar,l);;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:787218,perform,perform,787218,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['perform']
Performance,". TMonaLisaText. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » NET; » MONALISA; » TMonaLisaText. class TMonaLisaText: public TNamed. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Function Members (Methods); public:. TMonaLisaText(const TMonaLisaText&); TMonaLisaText(const char* name, const char* text); virtual~TMonaLisaText(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMonaLisaText.html:756,optimiz,optimized,756,root/html530/TMonaLisaText.html,https://root.cern,https://root.cern/root/html530/TMonaLisaText.html,2,['optimiz'],['optimized']
Performance,". TMonaLisaValue. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » NET; » MONALISA; » TMonaLisaValue. class TMonaLisaValue: public TNamed. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Function Members (Methods); public:. TMonaLisaValue(const char* name, Double_t value); virtual~TMonaLisaValue(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMonaLisaValue.html:759,optimiz,optimized,759,root/html530/TMonaLisaValue.html,https://root.cern,https://root.cern/root/html530/TMonaLisaValue.html,2,['optimiz'],['optimized']
Performance,". TMonaLisaWriter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » MONALISA; » TMonaLisaWriter. class TMonaLisaWriter: public TVirtualMonitoringWriter. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_c-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Additions/modifications by Fabrizio Furano 10/04/2008; - The implementation of TFile throughput and info sending was; just sending 'regular' samples about the activity of the single TFile; instance that happened to trigger an activity in the right moment.; - Now TMonaLisaWriter keeps internally track of every activity; and regularly sends summaries valid for all the files which had; activity in the last time interval.; - Additionally, it's now finalized the infrastructure able to measure; and keep track of the file Open latency. A packet is sent for each; successful Open, sending the measures of the latencies for the; various phases of the open. Currently exploited fully by TAlienFile; and TXNetFile. Easy to report from other TFiles too.; - Now, the hook for the Close() func triggers sending of a packet; containing various information about the performance related to that; file only.; - Added support also for performance monitoring when writing. Function Members (Methods",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMonaLisaWriter.html:802,optimiz,optimized,802,root/html530/TMonaLisaWriter.html,https://root.cern,https://root.cern/root/html530/TMonaLisaWriter.html,2,['optimiz'],['optimized']
Performance,". TMultiGraph. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TMultiGraph. class TMultiGraph: public TNamed. TMultiGraph class; A TMultiGraph is a collection of TGraph (or derived) objects. It allows to; manipulate a set of graphs as a single entity. In particular, when drawn,; the X and Y axis ranges are automatically computed such as all the graphs; will be visible. TMultiGraph::Add should be used to add a new graph to the list. The TMultiGraph owns the objects in the list. The drawing options are the same as for TGraph.; Like for TGraph, the painting is performed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class.; Example:. TGraph *gr1 = new TGraph(...; TGraphErrors *gr2 = new TGraphErrors(...; TMultiGraph *mg = new TMultiGraph();; mg->Add(gr1,""lp"");; mg->Add(gr2,""cp"");; mg->Draw(""a"");. A special option 3D allows to draw the graphs in a 3D space. See the; following example:. Picture; Source. {; c0 = new TCanvas(""c1"",""multigraph L3"",200,10,700,500);; c0->SetFrameFillColor(30);. TMultiGraph *mg = new TMultiGraph();. TGraph *gr1 = new TGraph(); gr1->SetLineColor(kBlue);; TGraph *gr2 = new TGraph(); gr2->SetLineColor(kRed);; TGraph *gr3 = new TGraph(); gr3->SetLineColor(kGreen);; TGraph *gr4 = new TGraph(); gr4->SetLineColor(kOrange);. Double_t dx = 6.28/100;; Double_t x = -3.14;. for (int i=0; i<=100; i++) {; x = x+dx;; gr1->SetPoint(i,x,2.*TMath::Sin(x));; gr2->SetPoint(i,x,TMath::Cos(x));; gr3->SetPoint(i,x,TMath::Cos(x*x));; gr4->SetPoint(i,x,TMath::Cos(x*x*x));; }. mg->Add(gr4); gr4->SetTitle(""Cos(x*x*x)""); gr4->SetLineWidth(3);; mg->Add(gr3); gr3->SetTitle(""Cos(x*x)"") ; gr3->SetLineWidth(3);; mg->Add(gr2); gr2->SetTitle(""Cos(x)"") ; gr2->SetLineWidth(3);; mg->Add(gr1); gr1->SetTitle(""2*Sin(x)"") ; gr1->SetLineWidth(3);. mg->D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiGraph.html:747,perform,performed,747,root/html534/TMultiGraph.html,https://root.cern,https://root.cern/root/html534/TMultiGraph.html,3,['perform'],['performed']
Performance,". TMultiGraph. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TMultiGraph. class TMultiGraph: public TNamed. TMultiGraph class; A TMultiGraph is a collection of TGraph (or derived) objects. It allows to; manipulate a set of graphs as a single entity. In particular, when drawn,; the X and Y axis ranges are automatically computed such as all the graphs; will be visible. TMultiGraph::Add should be used to add a new graph to the list. The TMultiGraph owns the objects in the list. The drawing options are the same as for TGraph.; Like for TGraph, the painting is performed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class.; Example:. TGraph *gr1 = new TGraph(...; TGraphErrors *gr2 = new TGraphErrors(...; TMultiGraph *mg = new TMultiGraph();; mg->Add(gr1,""lp"");; mg->Add(gr2,""cp"");; mg->Draw(""a"");. The number of graphs in a multigraph can be retrieve with:. mg->GetListOfGraphs()->GetSize();. The drawing option for each TGraph may be specified as an optional; second argument of the Add function. If a draw option is specified, it will be used to draw the graph,; otherwise the graph will be drawn with the option specified in; TMultiGraph::Draw. The following example shows how to fit a TMultiGraph. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);. Double_t x1[2] = {2.,4.};; Double_t dx1[2] = {0.1,0.1};; Double_t y1[2] = {2.1,4.0};; Double_t dy1[2] = {0.3,0.2};. Double_t x2[2] = {3.,5.};; Double_t dx2[2] = {0.1,0.1};; Double_t y2[2] = {3.2,4.8};; Double_t dy2[2] = {0.3,0.2};. gStyle->SetOptFit(0001);. TGraphErrors *g1 = new TGraphErrors(2,x1,y1,dx1,dy1);; g1->SetMarkerStyle(21);; g1->SetMarkerColor(2);. TGraphErrors *g2 = new TGraphErrors(2,x2,y2,dx2,dy2);; g2->SetMarkerStyle(22);; g2->SetMarkerColor(3);. TMultiGraph *g = new",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMultiGraph.html:747,perform,performed,747,root/html530/TMultiGraph.html,https://root.cern,https://root.cern/root/html530/TMultiGraph.html,2,['perform'],['performed']
Performance,". TObjectTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TObjectTable. class TObjectTable: public TObject. This class registers all instances of TObject and its derived; classes in a hash table. The Add() and Remove() members are called; from the TObject ctor and dtor, repectively. Using the Print(); member one can see all currently active objects in the system.; Using the resource (in .rootrc): Root.ObjectStat one can toggle this; feature on or off.; Using the compile option R__NOSTATS one can de-active this feature; for the entire system (for maximum performance in highly time; critical applications). The following output has been produced in a ROOT interactive session; via the command gObjectTable->Print(); class cnt on heap size total size heap size. TKey 4 4 72 288 288; TClass 84 84 80 6720 6720; TDataMember 276 276 24 6624 6624; TObject 11 11 12 132 132; TMethod 1974 1974 64 126336 126336; TDataType 34 34 56 1904 1904; TList 2328 2328 36 83808 83808; TH1F 1 1 448 448 448; TText 2688 2688 56 150528 150528; TGaxis 1 0 120 120 0; TAxis 6 3 88 528 264; TBox 57 57 52 2964 2964; TLine 118 118 40 4720 4720; TWbox 1 1 56 56 56; TArrow 1 1 64 64 64; TPaveText 59 59 124 7316 7316; TPave 1 1 92 92 92; TFile 1 1 136 136 136; TCanvas 3 3 444 1332 1332; TPad 1 1 312 312 312; TContextMenu 3 3 48 144 144; TMethodArg 2166 2166 44 95304 95304; TPaveLabel 1 1 120 120 120; THtml 1 1 32 32 32; TROOT 1 0 208 208 0; TApplication 1 1 28 28 28; TFileHandler 1 1 20 20 20; TColor 163 163 40 6520 6520; TStyle 1 1 364 364 364; TRealData 117 117 28 3276 3276; TBaseClass 88 88 36 3168 3168; THashList 5 5 40 200 200; THashTable 5 5 36 180 180; TGeometry 1 1 64 64 64; TLink 7 7 60 420 420; TPostScript 1 1 764 764 764; TMinuit 1 1 792 792 792; TStopwatch 1 0 56 56 0; TRootGuiFactory 1 1 28 28 28; TGX11 1 1 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TObjectTable.html:749,perform,performance,749,root/html528/TObjectTable.html,https://root.cern,https://root.cern/root/html528/TObjectTable.html,6,['perform'],['performance']
Performance,". TPServerSocket. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TPServerSocket. class TPServerSocket: public TServerSocket. TPServerSocket. This class implements parallel server sockets. A parallel server; socket waits for requests to come in over the network. It performs; some operation based on that request and then possibly returns a; full duplex parallel socket to the requester. The actual work is; done via the TSystem class (either TUnixSystem or TWinNTSystem). Function Members (Methods); public:. TPServerSocket(Int_t port, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); TPServerSocket(const char* service, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); virtual~TPServerSocket(); voidTObject::AbstractMethod(const char* method) const; virtual TSocket*Accept(UChar_t Opt = kSrvNoAuth); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTSocket::Close(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static TSocket*TSocket::CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); static TSocket*TSocket::CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPServerSocket.html:447,perform,performs,447,root/html528/TPServerSocket.html,https://root.cern,https://root.cern/root/html528/TPServerSocket.html,1,['perform'],['performs']
Performance,". TPServerSocket. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TPServerSocket. class TPServerSocket: public TServerSocket. TPServerSocket. This class implements parallel server sockets. A parallel server; socket waits for requests to come in over the network. It performs; some operation based on that request and then possibly returns a; full duplex parallel socket to the requester. The actual work is; done via the TSystem class (either TUnixSystem or TWinNTSystem). Function Members (Methods); public:. TPServerSocket(Int_t port, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); TPServerSocket(const char* service, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); virtual~TPServerSocket(); voidTObject::AbstractMethod(const char* method) const; virtual TSocket*Accept(UChar_t Opt = kSrvNoAuth); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTSocket::Close(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static TSocket*TSocket::CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); static TSocket*TSocket::CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPServerSocket.html:447,perform,performs,447,root/html530/TPServerSocket.html,https://root.cern,https://root.cern/root/html530/TPServerSocket.html,3,['perform'],['performs']
Performance,". TPServerSocket. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TPServerSocket. class TPServerSocket: public TServerSocket. TPServerSocket. This class implements parallel server sockets. A parallel server; socket waits for requests to come in over the network. It performs; some operation based on that request and then possibly returns a; full duplex parallel socket to the requester. The actual work is; done via the TSystem class (either TUnixSystem or TWinNTSystem). Function Members (Methods); public:. virtual~TPServerSocket(); voidTObject::AbstractMethod(const char* method) const; virtual TSocket*Accept(UChar_t Opt = kSrvNoAuth); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTSocket::Close(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static TSocket*TSocket::CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); static TSocket*TSocket::CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPServerSocket.html:447,perform,performs,447,root/html602/TPServerSocket.html,https://root.cern,https://root.cern/root/html602/TPServerSocket.html,2,['perform'],['performs']
Performance,". TPSocket. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TPSocket. class TPSocket: public TSocket. TPSocket. This class implements parallel client sockets. A parallel socket is; an endpoint for communication between two machines. It is parallel; because several TSockets are open at the same time to the same; destination. This especially speeds up communication over Big Fat; Pipes (i.e. high bandwidth, high latency WAN connections). Function Members (Methods); public:. TPSocket(TInetAddress address, const char* service, Int_t size, Int_t tcpwindowsize = -1); TPSocket(TInetAddress address, Int_t port, Int_t size, Int_t tcpwindowsize = -1); TPSocket(const char* host, const char* service, Int_t size, Int_t tcpwindowsize = -1); TPSocket(const char* host, Int_t port, Int_t size, Int_t tcpwindowsize = -1); TPSocket(const char* host, Int_t port, Int_t size, TSocket* sock); virtual~TPSocket(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static TSocket*TSocket::CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); static TSocket*TSocket::CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPSocket.html:594,latency,latency,594,root/html528/TPSocket.html,https://root.cern,https://root.cern/root/html528/TPSocket.html,1,['latency'],['latency']
Performance,". TPSocket. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TPSocket. class TPSocket: public TSocket. TPSocket. This class implements parallel client sockets. A parallel socket is; an endpoint for communication between two machines. It is parallel; because several TSockets are open at the same time to the same; destination. This especially speeds up communication over Big Fat; Pipes (i.e. high bandwidth, high latency WAN connections). Function Members (Methods); public:. TPSocket(TInetAddress address, const char* service, Int_t size, Int_t tcpwindowsize = -1); TPSocket(TInetAddress address, Int_t port, Int_t size, Int_t tcpwindowsize = -1); TPSocket(const char* host, const char* service, Int_t size, Int_t tcpwindowsize = -1); TPSocket(const char* host, Int_t port, Int_t size, Int_t tcpwindowsize = -1); TPSocket(const char* host, Int_t port, Int_t size, TSocket* sock); virtual~TPSocket(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static TSocket*TSocket::CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); static TSocket*TSocket::CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Dra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPSocket.html:594,latency,latency,594,root/html530/TPSocket.html,https://root.cern,https://root.cern/root/html530/TPSocket.html,3,['latency'],['latency']
Performance,". TPSocket. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TPSocket. class TPSocket: public TSocket. TPSocket. This class implements parallel client sockets. A parallel socket is; an endpoint for communication between two machines. It is parallel; because several TSockets are open at the same time to the same; destination. This especially speeds up communication over Big Fat; Pipes (i.e. high bandwidth, high latency WAN connections). Function Members (Methods); public:. virtual~TPSocket(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static TSocket*TSocket::CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); static TSocket*TSocket::CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* param",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPSocket.html:594,latency,latency,594,root/html602/TPSocket.html,https://root.cern,https://root.cern/root/html602/TPSocket.html,2,['latency'],['latency']
Performance,". TPacketizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPacketizer. class TPacketizer: public TVirtualPacketizer. TPacketizer. This class generates packets to be processed on PROOF worker servers.; A packet is an event range (begin entry and number of entries) or; object range (first object and number of objects) in a TTree; (entries) or a directory (objects) in a file.; Packets are generated taking into account the performance of the; remote machine, the time it took to process a previous packet on; the remote machine, the locality of the database files, etc. Function Members (Methods); public:. TPacketizer(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); virtual~TPacketizer(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTVirtualPacketizer::AddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual Int_tAddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPacketizer.html:619,perform,performance,619,root/html534/TPacketizer.html,https://root.cern,https://root.cern/root/html534/TPacketizer.html,1,['perform'],['performance']
Performance,". TPacketizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPacketizer. class TPacketizer: public TVirtualPacketizer. TPacketizer. This class generates packets to be processed on PROOF worker servers.; A packet is an event range (begin entry and number of entries) or; object range (first object and number of objects) in a TTree; (entries) or a directory (objects) in a file.; Packets are generated taking into account the performance of the; remote machine, the time it took to process a previous packet on; the remote machine, the locality of the database files, etc. Function Members (Methods); public:. TPacketizer(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); virtual~TPacketizer(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTVirtualPacketizer::AddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* meth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPacketizer.html:619,perform,performance,619,root/html528/TPacketizer.html,https://root.cern,https://root.cern/root/html528/TPacketizer.html,3,['perform'],['performance']
Performance,". TPacketizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPacketizer. class TPacketizer: public TVirtualPacketizer. TPacketizer. This class generates packets to be processed on PROOF worker servers.; A packet is an event range (begin entry and number of entries) or; object range (first object and number of objects) in a TTree; (entries) or a directory (objects) in a file.; Packets are generated taking into account the performance of the; remote machine, the time it took to process a previous packet on; the remote machine, the locality of the database files, etc. Function Members (Methods); public:. virtual~TPacketizer(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTVirtualPacketizer::AddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual Int_tAddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tTVirtualPacketizer::AssignWork(TDSet*, Long64_t, Long64_t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TPacketizer.html:619,perform,performance,619,root/html604/TPacketizer.html,https://root.cern,https://root.cern/root/html604/TPacketizer.html,1,['perform'],['performance']
Performance,". TPacketizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPacketizer. class TPacketizer: public TVirtualPacketizer. TPacketizer. This class generates packets to be processed on PROOF worker servers.; A packet is an event range (begin entry and number of entries) or; object range (first object and number of objects) in a TTree; (entries) or a directory (objects) in a file.; Packets are generated taking into account the performance of the; remote machine, the time it took to process a previous packet on; the remote machine, the locality of the database files, etc. Function Members (Methods); public:. virtual~TPacketizer(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTVirtualPacketizer::AddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual Int_tTVirtualPacketizer::AddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tTVirtualPacketizer::AssignWork(TDSet*, Long64_t, Long64_t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPacketizer.html:619,perform,performance,619,root/html602/TPacketizer.html,https://root.cern,https://root.cern/root/html602/TPacketizer.html,1,['perform'],['performance']
Performance,". TPacketizerAdaptive. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPacketizerAdaptive. class TPacketizerAdaptive: public TVirtualPacketizer. TPacketizerAdaptive. This packetizer is based on TPacketizer but uses different; load-balancing algorithms and data structures.; Two main improvements in the load-balancing strategy:; - First one was to change the order in which the files are assigned; to the computing nodes in such a way that network transfers are; evenly distributed in the query time. Transfer of the remote files; was often becoming a bottleneck at the end of a query.; - The other improvement is the use of time-based packet size. We; measure the processing rate of all the nodes and calculate the; packet size, so that it takes certain amount of time. In this way; packetizer prevents the situation where the query can't finish; because of one slow node. The data structures: TFileStat, TFileNode and TSlaveStat are; enriched + changed and TFileNode::Compare method is changed. Function Members (Methods); public:. TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); virtual~TPacketizerAdaptive(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); virtual Int_tTVirtualPacketizer::AddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Int_tCalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPacketizerAdaptive.html:418,load,load-balancing,418,root/html534/TPacketizerAdaptive.html,https://root.cern,https://root.cern/root/html534/TPacketizerAdaptive.html,3,"['bottleneck', 'load']","['bottleneck', 'load-balancing']"
Performance,". TPacketizerAdaptive. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPacketizerAdaptive. class TPacketizerAdaptive: public TVirtualPacketizer. TPacketizerAdaptive. This packetizer is based on TPacketizer but uses different; load-balancing algorithms and data structures.; Two main improvements in the load-balancing strategy:; - First one was to change the order in which the files are assigned; to the computing nodes in such a way that network transfers are; evenly distributed in the query time. Transfer of the remote files; was often becoming a bottleneck at the end of a query.; - The other improvement is the use of time-based packet size. We; measure the processing rate of all the nodes and calculate the; packet size, so that it takes certain amount of time. In this way; packetizer prevents the situation where the query can't finish; because of one slow node. The data structures: TFileStat, TFileNode and TSlaveStat are; enriched + changed and TFileNode::Compare method is changed. Function Members (Methods); public:. TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); virtual~TPacketizerAdaptive(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Int_tCalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPacketizerAdaptive.html:418,load,load-balancing,418,root/html528/TPacketizerAdaptive.html,https://root.cern,https://root.cern/root/html528/TPacketizerAdaptive.html,9,"['bottleneck', 'load']","['bottleneck', 'load-balancing']"
Performance,". TPacketizerAdaptive. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPacketizerAdaptive. class TPacketizerAdaptive: public TVirtualPacketizer. TPacketizerAdaptive. This packetizer is based on TPacketizer but uses different; load-balancing algorithms and data structures.; Two main improvements in the load-balancing strategy:; - First one was to change the order in which the files are assigned; to the computing nodes in such a way that network transfers are; evenly distributed in the query time. Transfer of the remote files; was often becoming a bottleneck at the end of a query.; - The other improvement is the use of time-based packet size. We; measure the processing rate of all the nodes and calculate the; packet size, so that it takes certain amount of time. In this way; packetizer prevents the situation where the query can't finish; because of one slow node. The data structures: TFileStat, TFileNode and TSlaveStat are; enriched + changed and TFileNode::Compare method is changed. Function Members (Methods); public:. virtual~TPacketizerAdaptive(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); virtual Int_tTVirtualPacketizer::AddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tTVirtualPacketizer::AssignWork(TDSet*, Long64_t, Long64_t); virtual voidTObject::Browse(TBrowser* b); Int_tCalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPacketizerAdaptive.html:418,load,load-balancing,418,root/html602/TPacketizerAdaptive.html,https://root.cern,https://root.cern/root/html602/TPacketizerAdaptive.html,6,"['bottleneck', 'load']","['bottleneck', 'load-balancing']"
Performance,". TPacketizerUnit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPacketizerUnit. class TPacketizerUnit: public TVirtualPacketizer. TPacketizerUnit. This packetizer generates packets of generic units, representing the; number of times an operation cycle has to be repeated by the worker; node, e.g. the number of Monte carlo events to be generated.; Packets sizes are generated taking into account the performance of; worker nodes, based on the time needed to process previous packets,; with the goal of having all workers ending at the same time. Function Members (Methods); public:. TPacketizerUnit(TList* slaves, Long64_t num, TList* input, TProofProgressStatus* st = 0); virtual~TPacketizerUnit(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTVirtualPacketizer::AddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual Int_tAddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tAssignWork(TDSet*, Long64_t, Long64_t num); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPacketizerUnit.html:595,perform,performance,595,root/html534/TPacketizerUnit.html,https://root.cern,https://root.cern/root/html534/TPacketizerUnit.html,1,['perform'],['performance']
Performance,". TPacketizerUnit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPacketizerUnit. class TPacketizerUnit: public TVirtualPacketizer. TPacketizerUnit. This packetizer generates packets of generic units, representing the; number of times an operation cycle has to be repeated by the worker; node, e.g. the number of Monte carlo events to be generated.; Packets sizes are generated taking into account the performance of; worker nodes, based on the time needed to process previous packets,; with the goal of having all workers ending at the same time. Function Members (Methods); public:. TPacketizerUnit(TList* slaves, Long64_t num, TList* input, TProofProgressStatus* st = 0); virtual~TPacketizerUnit(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTVirtualPacketizer::AddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPacketizerUnit.html:595,perform,performance,595,root/html530/TPacketizerUnit.html,https://root.cern,https://root.cern/root/html530/TPacketizerUnit.html,2,['perform'],['performance']
Performance,". TPacketizerUnit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPacketizerUnit. class TPacketizerUnit: public TVirtualPacketizer. TPacketizerUnit. This packetizer generates packets of generic units, representing the; number of times an operation cycle has to be repeated by the worker; node, e.g. the number of Monte carlo events to be generated.; Packets sizes are generated taking into account the performance of; worker nodes, based on the time needed to process previous packets,; with the goal of having all workers ending at the same time. Function Members (Methods); public:. virtual~TPacketizerUnit(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTVirtualPacketizer::AddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual Int_tAddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tAssignWork(TDSet*, Long64_t, Long64_t num); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* erro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPacketizerUnit.html:595,perform,performance,595,root/html602/TPacketizerUnit.html,https://root.cern,https://root.cern/root/html602/TPacketizerUnit.html,2,['perform'],['performance']
Performance,". TPacketizerUnit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPacketizerUnit. class TPacketizerUnit: public TVirtualPacketizer. TPacketizerUnit. This packetizer generates packets of generic units, representing the; number of times an operation cycle has to be repeated by the worker; node, e.g. the number of Monte carlo events to be generated.; Packets sizes are generated taking into account the performance of; worker nodes, based on the time needed to process previous packets. Function Members (Methods); public:. TPacketizerUnit(TList* slaves, Long64_t num, TList* input, TProofProgressStatus* st = 0); virtual~TPacketizerUnit(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTVirtualPacketizer::AddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPacketizerUnit.html:595,perform,performance,595,root/html528/TPacketizerUnit.html,https://root.cern,https://root.cern/root/html528/TPacketizerUnit.html,1,['perform'],['performance']
Performance,". TPad. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TPad. class TPad: public TVirtualPad, public TAttBBox2D. The Pad class is the most important graphics class in the ROOT system. /*. */. A Pad is contained in a Canvas.; A Pad may contain other pads (unlimited pad hierarchy).; A pad is a linked list of primitives of any type (graphics objects,; histograms, detectors, tracks, etc.).; Adding a new element into a pad is in general performed by the Draw; member function of the object classes.; It is important to realize that the pad is a linked list of references; to the original object.; For example, in case of a histogram, the histogram.Draw() operation; only stores a reference to the histogram object and not a graphical; representation of this histogram.; When the mouse is used to change (say the bin content), the bin content; of the original histogram is changed !!. The convention used in ROOT is that a Draw operation only adds; a reference to the object. The effective drawing is performed; when the canvas receives a signal to be painted.; This signal is generally sent when typing carriage return in the; command input or when a graphical operation has been performed on one; of the pads of this canvas.; When a Canvas/Pad is repainted, the member function Paint for all; objects in the Pad linked list is invoked. When the mouse is moved on the Pad, The member function DistancetoPrimitive; is called for all the elements in the pad. DistancetoPrimitive returns; the distance in pixels to this object.; when the object is within the distance window, the member function; ExecuteEvent is called for this object.; in ExecuteEvent, move, changes can be performed on the object.; For examples of DistancetoPrimitive and ExecuteEvent functions,; see classes TLine::DistancetoPrimitive, TLine::Execut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPad.html:621,perform,performed,621,root/html534/TPad.html,https://root.cern,https://root.cern/root/html534/TPad.html,3,['perform'],['performed']
Performance,". TPad. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TPad. class TPad: public TVirtualPad. The Pad class is the most important graphics class in the ROOT system. /*. */. A Pad is contained in a Canvas.; A Pad may contain other pads (unlimited pad hierarchy).; A pad is a linked list of primitives of any type (graphics objects,; histograms, detectors, tracks, etc.).; Adding a new element into a pad is in general performed by the Draw; member function of the object classes.; It is important to realize that the pad is a linked list of references; to the original object.; For example, in case of a histogram, the histogram.Draw() operation; only stores a reference to the histogram object and not a graphical; representation of this histogram.; When the mouse is used to change (say the bin content), the bin content; of the original histogram is changed !!. The convention used in ROOT is that a Draw operation only adds; a reference to the object. The effective drawing is performed; when the canvas receives a signal to be painted.; This signal is generally sent when typing carriage return in the; command input or when a graphical operation has been performed on one; of the pads of this canvas.; When a Canvas/Pad is repainted, the member function Paint for all; objects in the Pad linked list is invoked. When the mouse is moved on the Pad, The member function DistancetoPrimitive; is called for all the elements in the pad. DistancetoPrimitive returns; the distance in pixels to this object.; when the object is within the distance window, the member function; ExecuteEvent is called for this object.; in ExecuteEvent, move, changes can be performed on the object.; For examples of DistancetoPrimitive and ExecuteEvent functions,; see classes TLine::DistancetoPrimitive, TLine::ExecuteEvent; TBox::Dista",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPad.html:602,perform,performed,602,root/html528/TPad.html,https://root.cern,https://root.cern/root/html528/TPad.html,3,['perform'],['performed']
Performance,". TPerfEvent. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPerfEvent. class TPerfEvent: public TObject. TPerfStats. Provides the interface for the PROOF internal performance measurment; and event tracing. Function Members (Methods); public:. TPerfEvent(TTimeStamp* offset = 0); TPerfEvent(const TPerfEvent&); virtual~TPerfEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPerfEvent.html:357,perform,performance,357,root/html528/TPerfEvent.html,https://root.cern,https://root.cern/root/html528/TPerfEvent.html,4,['perform'],['performance']
Performance,". TPerfEvent. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPerfEvent. class TPerfEvent: public TObject. TPerfStats. Provides the interface for the PROOF internal performance measurment; and event tracing. Function Members (Methods); public:. virtual~TPerfEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectSta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPerfEvent.html:357,perform,performance,357,root/html602/TPerfEvent.html,https://root.cern,https://root.cern/root/html602/TPerfEvent.html,2,['perform'],['performance']
Performance,". TPerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPerfStats. class TPerfStats: public TVirtualPerfStats. TPerfStats. Provides the interface for the PROOF internal performance measurment; and event tracing. Function Members (Methods); public:. TPerfStats(const TPerfStats&); virtual~TPerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*TVirtualPerfStats::EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const char* filename, Double_t start); virtual voidFileReadEvent(TFile* file, Int_t len, Double_t start",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPerfStats.html:367,perform,performance,367,root/html528/TPerfStats.html,https://root.cern,https://root.cern/root/html528/TPerfStats.html,1,['perform'],['performance']
Performance,". TPerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPerfStats. class TPerfStats: public TVirtualPerfStats. TPerfStats. Provides the interface for the PROOF internal performance measurment; and event tracing. Function Members (Methods); public:. virtual~TPerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TVirtualPerfStats*&TVirtualPerfStats::CurrentPerfStats(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*TVirtualPerfStats::EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const char* filename, Double_t start); virtual voidFileReadEvent(TFil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPerfStats.html:367,perform,performance,367,root/html534/TPerfStats.html,https://root.cern,https://root.cern/root/html534/TPerfStats.html,3,['perform'],['performance']
Performance,". TPerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPerfStats. class TPerfStats: public TVirtualPerfStats. TPerfStats. Provides the interface for the PROOF internal performance measurment; and event tracing. Function Members (Methods); public:. virtual~TPerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*TVirtualPerfStats::EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const char* filename, Double_t start); virtual voidFileReadEvent(TFile* file, Int_t len, Double_t start); virtual voidFileUnzipEvent(T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPerfStats.html:367,perform,performance,367,root/html530/TPerfStats.html,https://root.cern,https://root.cern/root/html530/TPerfStats.html,2,['perform'],['performance']
Performance,". TPluginHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginHandler. class TPluginHandler: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPluginHandler.html:461,load,load,461,root/html528/TPluginHandler.html,https://root.cern,https://root.cern/root/html528/TPluginHandler.html,18,['load'],"['load', 'loading']"
Performance,". TPluginManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginManager. class TPluginManager: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPluginManager.html:461,load,load,461,root/html528/TPluginManager.html,https://root.cern,https://root.cern/root/html528/TPluginManager.html,18,['load'],"['load', 'loading']"
Performance,". TProofBenchRunDataRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFBENCH; » TProofBenchRunDataRead. class TProofBenchRunDataRead: public TProofBenchRun. TProofBenchRunDataRead. I/O-intensive PROOF benchmark test reads in event files distributed; on the cluster. Number of events processed per second and size of; events processed per second are plotted against number of active; workers. Performance rate for unit packets and performance rate; for query are plotted. Function Members (Methods); public:. TProofBenchRunDataRead(const TProofBenchRunDataRead&); TProofBenchRunDataRead(TProofBenchDataSet* pbds, TPBReadType* readtype = 0, TDirectory* dirproofbench = 0, TProof* proof = 0, TProofNodes* nodes = 0, Long64_t nevents = -1, Int_t ntries = 2, Int_t start = 1, Int_t stop = -1, Int_t step = 1, Int_t debug = 0); virtual~TProofBenchRunDataRead(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawPerfProfiles(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofBenchRunDataRead.html:576,Perform,Performance,576,root/html530/TProofBenchRunDataRead.html,https://root.cern,https://root.cern/root/html530/TProofBenchRunDataRead.html,6,"['Perform', 'perform']","['Performance', 'performance']"
Performance,". TProofBenchRunDataRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFBENCH; » TProofBenchRunDataRead. class TProofBenchRunDataRead: public TProofBenchRun. TProofBenchRunDataRead. I/O-intensive PROOF benchmark test reads in event files distributed; on the cluster. Number of events processed per second and size of; events processed per second are plotted against number of active; workers. Performance rate for unit packets and performance rate; for query are plotted. Function Members (Methods); public:. virtual~TProofBenchRunDataRead(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawPerfProfiles(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofBenchRunDataRead.html:576,Perform,Performance,576,root/html602/TProofBenchRunDataRead.html,https://root.cern,https://root.cern/root/html602/TProofBenchRunDataRead.html,4,"['Perform', 'perform']","['Performance', 'performance']"
Performance,". TProofPerfAnalysis. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFBENCH; » TProofPerfAnalysis. class TProofPerfAnalysis: public TNamed. TProofPerfAnalysis. Set of tools to analyse the performance tree. Function Members (Methods); public:. TProofPerfAnalysis(TTree* tree, const char* title = """"); TProofPerfAnalysis(const char* perffile, const char* title = """", const char* treename = ""PROOF_PerfStats""); virtual~TProofPerfAnalysis(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidEventDist(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFileDist(Bool_t writedet = kFALSE); voidFileProcPlot(const char* fn, const char* out = 0); voidFileRatePlot(const char* fns = 0); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPerfAnalysis.html:345,perform,performance,345,root/html534/TProofPerfAnalysis.html,https://root.cern,https://root.cern/root/html534/TProofPerfAnalysis.html,1,['perform'],['performance']
Performance,". TProofPerfAnalysis. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFBENCH; » TProofPerfAnalysis. class TProofPerfAnalysis: public TNamed. TProofPerfAnalysis. Set of tools to analyse the performance tree. Function Members (Methods); public:. virtual~TProofPerfAnalysis(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidEventDist(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFileDist(Bool_t writedet = kFALSE); voidFileProcPlot(const char* fn, const char* out = 0); voidFileRatePlot(const char* fns = 0); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGetAverages(Double_t& evtmax, Double_t& mbmax, Double_t& evt, Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPerfAnalysis.html:369,perform,performance,369,root/html602/TProofPerfAnalysis.html,https://root.cern,https://root.cern/root/html602/TProofPerfAnalysis.html,2,['perform'],['performance']
Performance,". TProofServLite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TProofServLite. class TProofServLite: public TProofServ. TProofServLite. TProofServLite is the version of the PROOF worker server for local; running. The client starts directly the desired number of these; workers; the master and daemons are eliminated, optimizing the number; of messages exchanged and created / destroyed. Function Members (Methods); public:. TProofServLite(Int_t* argc, char** argv, FILE* flog = 0); virtual~TProofServLite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TApplication::ApplicationName() const; static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; Int_tTApplication::Argc() const; char**TApplication::Argv() const; char*TApplication::Argv(Int_t index) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTApplication::ClearInputFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServLite.html:505,optimiz,optimizing,505,root/html528/TProofServLite.html,https://root.cern,https://root.cern/root/html528/TProofServLite.html,4,['optimiz'],['optimizing']
Performance,". TProofServLite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TProofServLite. class TProofServLite: public TProofServ. TProofServLite. TProofServLite is the version of the PROOF worker server for local; running. The client starts directly the desired number of these; workers; the master and daemons are eliminated, optimizing the number; of messages exchanged and created / destroyed. Function Members (Methods); public:. virtual~TProofServLite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TApplication::ApplicationName() const; static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; Int_tTApplication::Argc() const; char**TApplication::Argv() const; char*TApplication::Argv(Int_t index) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTApplication::ClearInputFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObject& objec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofServLite.html:505,optimiz,optimizing,505,root/html602/TProofServLite.html,https://root.cern,https://root.cern/root/html602/TProofServLite.html,2,['optimiz'],['optimizing']
Performance,". TQpDataBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpDataBase. class TQpDataBase: public TObject. TQpDataBase. Data for the general QP formulation. The Data class stores the data defining the problem and provides; methods for performing the operations with this data required by; the interior-point algorithms. These operations include assembling; the linear systems (5) or (7), performing matrix-vector operations; with the data, calculating norms of the data, reading input into the; data structure from various sources, generating random problem; instances, and printing the data. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpDataBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidAmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidATransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCTransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Double_tDataNorm(); virtual voidDataRandom(TVectorD& x, TVectorD& y, TVectorD& z, TVectorD& s); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQpDataBase.html:447,perform,performing,447,root/html602/TQpDataBase.html,https://root.cern,https://root.cern/root/html602/TQpDataBase.html,4,['perform'],['performing']
Performance,". TQpDataBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpDataBase. class TQpDataBase: public TObject. TQpDataBase. Data for the general QP formulation. The Data class stores the data defining the problem and provides; methods for performing the operations with this data required by; the interior-point algorithms. These operations include assembling; the linear systems (5) or (7), performing matrix-vector operations; with the data, calculating norms of the data, reading input into the; data structure from various sources, generating random problem; instances, and printing the data. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpDataBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidAmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidATransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCTransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Double_tDataNorm(); virtual voidDataRandom(TVectorD& x, TVectorD& y, TVectorD& z, TVectorD& s); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQpDataBase.html:423,perform,performing,423,root/html528/TQpDataBase.html,https://root.cern,https://root.cern/root/html528/TQpDataBase.html,8,['perform'],['performing']
Performance,". TRefTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TRefTable. class TRefTable: public TObject. A TRefTable maintains the association between a referenced object; and the parent object supporting this referenced object. The parent object is typically a branch of a TTree. For each object; referenced in a TTree entry, the corresponding entry in the TTree's; TBranchRef::fRefTable contains the index of the branch that; needs to be loaded to bring the object into memory. Persistency of a TRefTable is split into two parts:; * entry specific information is stored (read) by FillBuffer; (ReadBuffer). For each referenced object the object's fUniqueID; and the referencing TRef::fPID is stored (to allow the TRefTable; to autoload references created by different processes).; * non-entry specific, i.e. global information is stored (read) by; the Streamer function. This comprises all members marked as; persistent. As TObject::fUniqueID is only unique for a given TProcessID, a table; of unique IDs is kept for each used TProcessID. There is no natural; order of TProcessIDs, so TRefTable stores a vector of the TGUID of; all known TProcessIDs in fProcessGUIDs; the index of a TProcessID in; this vector defines the index of the auto-loading info in fParentIDs; for that TProcessID. The mapping of TProcessID* to index is cached; for quick non-persistent lookup. Function Members (Methods); public:. virtual~TRefTable(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAdd(Int_t uid, TProcessID* context = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """"",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRefTable.html:647,load,loaded,647,root/html602/TRefTable.html,https://root.cern,https://root.cern/root/html602/TRefTable.html,2,['load'],['loaded']
Performance,". TRefTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TRefTable. class TRefTable: public TObject. A TRefTable maintains the association between a referenced object; and the parent object supporting this referenced object. The parent object is typically a branch of a TTree. For each object; referenced in a TTree entry, the corresponding entry in the TTree's; TBranchRef::fRefTable contains the index of the branch that; needs to be loaded to bring the object into memory. Persistency of a TRefTable is split into two parts:; * entry specific information is stored (read) by FillBuffer; (ReadBuffer). For each referenced object the object's fUniqueID; and the referencing TRef::fPID is stored (to allow the TRefTable; to autoload references created by different processes).; * non-entry specific, i.e. global information is stored (read) by; the Streamer function. This comprises all members marked as; persistent. As TObject::fUniqueID is only unique for a given TProcessID, a table; of unique IDs is kept for each used TProcessID. There is no natural; order of TProcessIDs, so TRefTable stores a vector of the TGUID of; all known TProcessIDs in fProcessGUIDs; the index of a TProcessID in; this vector defines the index of the auto-loading info in fParentIDs; for that TProcessID. The mapping of TProcessID* to index is cached; for quick non-persistent lookup. Function Members (Methods); public:. TRefTable(); TRefTable(const TRefTable&); TRefTable(TObject* owner, Int_t size); virtual~TRefTable(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAdd(Int_t uid, TProcessID* context = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRefTable.html:623,load,loaded,623,root/html528/TRefTable.html,https://root.cern,https://root.cern/root/html528/TRefTable.html,4,['load'],['loaded']
Performance,". TRootAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » AUTH; » TRootAuth. class TRootAuth: public TVirtualAuth. TRootAuth. TVirtualAuth implementation based on the old client authentication; code. Function Members (Methods); public:. virtual~TRootAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options = """"); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode = -1); virtual TClass*IsA() const; virtual const char*Name(); TRootAuth&operator=(const TRootAuth&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TRootAuth(); TRootAuth(const TRootAuth&). Class Charts. Inheritance Chart:. TVirtualAuth. ←; TRootAuth. Function documentation; TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options = """"); Runs authentication on socket s.; Invoked when dynamic loading is needed.; Returns 1 on success, 0 on failure. Int_t ClientVersion(); Return client version;. void ErrorMsg(const char* where, Int_t ecode = -1); Print error string corresponding to ecode, prepending location. TRootAuth(); { }. virtual ~TRootAuth(); { }. const char * Name(); { return ""Root""; }. » Author: Gerardo Ganis 08/07/05 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/auth:$Id$ » Last generated: 2015-06-30 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRootAuth.html:1198,load,loading,1198,root/html602/TRootAuth.html,https://root.cern,https://root.cern/root/html602/TRootAuth.html,1,['load'],['loading']
Performance,". TRootAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » AUTH; » TRootAuth. class TRootAuth: public TVirtualAuth. TRootAuth. TVirtualAuth implementation based on the old client authentication; code. Function Members (Methods); public:. virtual~TRootAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options = """"); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode = -1); virtual TClass*IsA() const; virtual const char*Name(); TRootAuth&operator=(const TRootAuth&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TRootAuth(); TRootAuth(const TRootAuth&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options = """"); Runs authentication on socket s.; Invoked when dynamic loading is needed.; Returns 1 on success, 0 on failure. Int_t ClientVersion(); Return client version;. void ErrorMsg(const char* where, Int_t ecode = -1); Print error string corresponding to ecode, prepending location. TRootAuth(); { }. virtual ~TRootAuth(); { }. const char * Name(); { return ""Root""; }. » Author: Gerardo Ganis 08/07/05 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/auth:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TRootAuth.html:1179,load,loading,1179,root/html604/TRootAuth.html,https://root.cern,https://root.cern/root/html604/TRootAuth.html,1,['load'],['loading']
Performance,". TSPlot. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SPLOT; » TSPlot. class TSPlot: public TObject. . Overview. A common method used in High Energy Physics to perform measurements is; the maximum Likelihood method, exploiting discriminating variables to; disentangle signal from background. The crucial point for such an; analysis to be reliable is to use an exhaustive list of sources of; events combined with an accurate description of all the Probability; Density Functions (PDF).; To assess the validity of the fit, a convincing quality check; is to explore further the data sample by examining the distributions of; control variables. A control variable can be obtained for instance by; removing one of the discriminating variables before performing again; the maximum Likelihood fit: this removed variable is a control; variable. The expected distribution of this control variable, for; signal, is to be compared to the one extracted, for signal, from the; data sample. In order to be able to do so, one must be able to unfold; from the distribution of the whole data sample.; The TSPlot method allows to reconstruct the distributions for; the control variable, independently for each of the various sources of; events, without making use of any a priori knowledge on this; variable. The aim is thus to use the knowledge available for the; discriminating variables to infer the behaviour of the individual; sources of events with respect to the control variable. TSPlot is optimal if the control variable is uncorrelated with the discriminating variables. A detail description of the formalism itself, called ; , is given in [1]. The method. The ; technique is developped in the above context of a maximum Likelihood method making use of discriminating variables.; One considers a data sampl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSPlot.html:363,perform,perform,363,root/html602/TSPlot.html,https://root.cern,https://root.cern/root/html602/TSPlot.html,4,['perform'],"['perform', 'performing']"
Performance,". TSPlot. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SPLOT; » TSPlot. class TSPlot: public TObject. . Overview. A common method used in High Energy Physics to perform measurements is; the maximum Likelihood method, exploiting discriminating variables to; disentangle signal from background. The crucial point for such an; analysis to be reliable is to use an exhaustive list of sources of; events combined with an accurate description of all the Probability; Density Functions (PDF).; To assess the validity of the fit, a convincing quality check; is to explore further the data sample by examining the distributions of; control variables. A control variable can be obtained for instance by; removing one of the discriminating variables before performing again; the maximum Likelihood fit: this removed variable is a control; variable. The expected distribution of this control variable, for; signal, is to be compared to the one extracted, for signal, from the; data sample. In order to be able to do so, one must be able to unfold; from the distribution of the whole data sample.; The TSPlot method allows to reconstruct the distributions for; the control variable, independently for each of the various sources of; events, without making use of any a priori knowledge on this; variable. The aim is thus to use the knowledge available for the; discriminating variables to infer the behaviour of the individual; sources of events with respect to the control variable. TSPlot is optimal if the control variable is uncorrelated with the discriminating variables. A detail description of the formalism itself, called ; , is given in [1]. The method. The ; technique is developped in the above context of a maximum Likelihood method making use of discriminating variables.; One considers a data sample in which are merged se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSPlot.html:339,perform,perform,339,root/html528/TSPlot.html,https://root.cern,https://root.cern/root/html528/TSPlot.html,8,['perform'],"['perform', 'performing']"
Performance,". TSQLObjectDataPool. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » SQL; » TSQLObjectDataPool. class TSQLObjectDataPool: public TObject. TSQLObjectDataPool contains list (pool) of data from single class table; for differents objects, all belonging to the same key.; This is typical situation when list of objects stored as single key.; To optimize reading of such data, one query is submitted and results of that; query kept in TSQLObjectDataPool object. Function Members (Methods); public:. virtual~TSQLObjectDataPool(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TSQLRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLObjectDataPool.html:538,optimiz,optimize,538,root/html602/TSQLObjectDataPool.html,https://root.cern,https://root.cern/root/html602/TSQLObjectDataPool.html,2,['optimiz'],['optimize']
Performance,". TSQLObjectDataPool. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » SQL; » TSQLObjectDataPool. class TSQLObjectDataPool: public TObject. TSQLObjectDataPool contains list (pool) of data from single class table; for differents objects, all belonging to the same key.; This is typical situation when list of objects stored as single key.; To optimize reading of such data, one query is submitted and results of that; query kept in TSQLObjectDataPool object. Function Members (Methods); public:. TSQLObjectDataPool(); TSQLObjectDataPool(const TSQLObjectDataPool&); TSQLObjectDataPool(TSQLClassInfo* info, TSQLResult* data); virtual~TSQLObjectDataPool(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSQLObjectDataPool.html:514,optimiz,optimize,514,root/html530/TSQLObjectDataPool.html,https://root.cern,https://root.cern/root/html530/TSQLObjectDataPool.html,3,['optimiz'],['optimize']
Performance,". TSQLServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLServer. class TSQLServer: public TObject. TSQLServer. Abstract base class defining interface to a SQL server. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; <dbms>://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main, ...; Depending on the <dbms> specified an appropriate plugin library; will be loaded which will provide the real interface.; For SQLite, the syntax is slightly different:; sqlite://<database>; The string 'database' is directly passed to sqlite3_open(_v2),; so e.g. a filename or "":memory:"" are possible values.; For SQLite versions >= 3.7.7, SQLITE_OPEN_URI is activated to also; allow URI-parameters if needed. Related classes are TSQLResult and TSQLRow. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLServer.html:679,load,loaded,679,root/html602/TSQLServer.html,https://root.cern,https://root.cern/root/html602/TSQLServer.html,2,['load'],['loaded']
Performance,". TSQLServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLServer. class TSQLServer: public TObject. TSQLServer. Abstract base class defining interface to a SQL server. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; <dbms>://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main, ...; Depending on the <dbms> specified an appropriate plugin library; will be loaded which will provide the real interface. Related classes are TSQLResult and TSQLRow. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tDropDataBase(const char* dbname); virtual voidTObject::Dump() constMENU ; virtual voidEnableErrorOutput(Bool_t on = kTRUE); virtual voidTObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSQLServer.html:655,load,loaded,655,root/html528/TSQLServer.html,https://root.cern,https://root.cern/root/html528/TSQLServer.html,3,['load'],['loaded']
Performance,". TSQLServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLServer. class TSQLServer: public TObject. TSQLServer. Abstract base class defining interface to a SQL server. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; <dbms>://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main, ...; Depending on the <dbms> specified an appropriate plugin library; will be loaded which will provide the real interface.; For SQLite, the syntax is slightly different:; sqlite://<database>; The string 'database' is directly passed to sqlite3_open(_v2),; so e.g. a filename or "":memory:"" are possible values.; For SQLite versions >= 3.7.7, SQLITE_OPEN_URI is activated to also; allow URI-parameters if needed. Related classes are TSQLResult and TSQLRow. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSQLServer.html:655,load,loaded,655,root/html534/TSQLServer.html,https://root.cern,https://root.cern/root/html534/TSQLServer.html,1,['load'],['loaded']
Performance,". TSVG. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TSVG. class TSVG: public TVirtualPS. TSVG: Graphics interface to SVG; SVG; (Scalable Vector Graphics) is a language for describing two-dimensional; graphics in XML. SVG allows high quality vector graphics in; HTML pages. To print a ROOT canvas ""c1"" into an SVG file simply do:. c1->Print(""c1.svg"");. The result is the ASCII file c1.svg. It can be open direclty using a web browser or included in a html document; the following way:. <embed width=""95%"" height=""500"" src=""c1.svg"" />>. It is best viewed with Internet Explorer and you need the; Adobe SVG; Viewer. To zoom using the Adobe SVG Viewer, position the mouse over; the area you want to zoom and click the right button. To define the zoom area,; use Control+drag to mark the boundaries of the zoom area. To pan, use Alt+drag.; By clicking with the right mouse button on the SVG graphics you will get; a pop-up menu giving other ways to interact with the image. SVG files can be used directly in compressed mode to minimize the time; transfer over the network. Compressed SVG files should be created using; gzip on a normal ASCII SVG file and should then be renamed; using the file extension .svgz.; . Function Members (Methods); public:. virtual~TSVG(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSVG.html:347,Scalab,Scalable,347,root/html602/TSVG.html,https://root.cern,https://root.cern/root/html602/TSVG.html,2,['Scalab'],['Scalable']
Performance,". TSVG. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TSVG. class TSVG: public TVirtualPS. TSVG: Graphics interface to SVG; SVG; (Scalable Vector Graphics) is a language for describing two-dimensional; graphics in XML. SVG allows high quality vector graphics in; HTML pages. To print a ROOT canvas ""c1"" into an SVG file simply do:. c1->Print(""c1.svg"");. The result is the ASCII file c1.svg. It can be open direclty using a web browser or included in a html document; the following way:. <embed width=""95%"" height=""500"" src=""c1.svg"" />>. It is best viewed with Internet Explorer and you need the; Adobe SVG; Viewer. To zoom using the Adobe SVG Viewer, position the mouse over; the area you want to zoom and click the right button. To define the zoom area,; use Control+drag to mark the boundaries of the zoom area. To pan, use Alt+drag.; By clicking with the right mouse button on the SVG graphics you will get; a pop-up menu giving other ways to interact with the image. SVG files can be used directly in compressed mode to minimize the time; transfer over the network. Compressed SVG files should be created using; gzip on a normal ASCII SVG file and should then be renamed; using the file extension .svgz.; . Function Members (Methods); public:. TSVG(); TSVG(const char* filename, Int_t type = -113); virtual~TSVG(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSVG.html:323,Scalab,Scalable,323,root/html528/TSVG.html,https://root.cern,https://root.cern/root/html528/TSVG.html,4,['Scalab'],['Scalable']
Performance,". TServerSocket. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TServerSocket. class TServerSocket: public TSocket. TServerSocket. This class implements server sockets. A server socket waits for; requests to come in over the network. It performs some operation; based on that request and then possibly returns a full duplex socket; to the requester. The actual work is done via the TSystem class; (either TUnixSystem or TWinNTSystem). Function Members (Methods); public:. virtual~TServerSocket(); voidTObject::AbstractMethod(const char* method) const; virtual TSocket*Accept(UChar_t Opt = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTSocket::Close(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static TSocket*TSocket::CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); static TSocket*TSocket::CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TServerSocket.html:443,perform,performs,443,root/html602/TServerSocket.html,https://root.cern,https://root.cern/root/html602/TServerSocket.html,2,['perform'],['performs']
Performance,". TServerSocket. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TServerSocket. class TServerSocket: public TSocket. TServerSocket. This class implements server sockets. A server socket waits for; requests to come in over the network. It performs some operation; based on that request and then possibly returns a full duplex socket; to the requester. The actual work is done via the TSystem class; (either TUnixSystem or TWinNTSystem). Function Members (Methods); public:. TServerSocket(Int_t port, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); TServerSocket(const char* service, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); virtual~TServerSocket(); voidTObject::AbstractMethod(const char* method) const; virtual TSocket*Accept(UChar_t Opt = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTSocket::Close(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static TSocket*TSocket::CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); static TSocket*TSocket::CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TServerSocket.html:419,perform,performs,419,root/html528/TServerSocket.html,https://root.cern,https://root.cern/root/html528/TServerSocket.html,1,['perform'],['performs']
Performance,". TServerSocket. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TServerSocket. class TServerSocket: public TSocket. TServerSocket. This class implements server sockets. A server socket waits for; requests to come in over the network. It performs some operation; based on that request and then possibly returns a full duplex socket; to the requester. The actual work is done via the TSystem class; (either TUnixSystem or TWinNTSystem). Function Members (Methods); public:. TServerSocket(Int_t port, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); TServerSocket(const char* service, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); virtual~TServerSocket(); voidTObject::AbstractMethod(const char* method) const; virtual TSocket*Accept(UChar_t Opt = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTSocket::Close(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static TSocket*TSocket::CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); static TSocket*TSocket::CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TServerSocket.html:419,perform,performs,419,root/html530/TServerSocket.html,https://root.cern,https://root.cern/root/html530/TServerSocket.html,3,['perform'],['performs']
Performance,". TSlave. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TSlave. class TSlave: public TObject. TSlave. This class describes a PROOF slave server.; It contains information like the slaves host name, ordinal number,; performance index, socket, etc. Objects of this class can only be; created via TProof member functions. Function Members (Methods); public:. virtual~TSlave(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetArchCompiler() const; Long64_tGetBytesRead() const; Float_tGetCpuTime() const; virtual Option_t*TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSlave.html:425,perform,performance,425,root/html602/TSlave.html,https://root.cern,https://root.cern/root/html602/TSlave.html,2,['perform'],['performance']
Performance,". TSlave. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TSlave. class TSlave: public TObject. TSlave. This class describes a PROOF slave server.; It contains information like the slaves host name, ordinal number,; performance index, socket, etc. Objects of this class can only be; created via TProof member functions. Function Members (Methods); public:. virtual~TSlave(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetArchCompiler() const; Long64_tGetBytesRead() const; Float_tGetCpuTime() const; virtual Option_t*TObject::GetDrawOption() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSlave.html:401,perform,performance,401,root/html528/TSlave.html,https://root.cern,https://root.cern/root/html528/TSlave.html,4,['perform'],['performance']
Performance,". TString. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TString. class TString. TString. Basic string class. Cannot be stored in a TCollection... use TObjString instead. The underlying string is stored as a char* that can be accessed via; TString::Data().; TString provides Short String Optimization (SSO) so that short; strings (<15 on 64-bit and <11 on 32-bit) are contained in the; TString internal data structure without the need for mallocing the; required space. Substring operations are provided by the TSubString class, which; holds a reference to the original string and its data, along with; the offset and length of the substring. To retrieve the substring; as a TString, construct a TString from it, eg:; root [0] TString s(""hello world""); root [1] TString s2( s(0,5) ); root [2] s2; (class TString)""hello"". Function Members (Methods); public:. virtual~TString(); TString&Append(const char* cs); TString&Append(const TString& s); TString&Append(const char* cs, Ssiz_t n); TString&Append(const TString& s, Ssiz_t n); TString&Append(char c, Ssiz_t rep = 1); Double_tAtof() const; Int_tAtoi() const; Long64_tAtoll() const; static TStringBaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); Bool_tBeginsWith(const char* s, TString::ECaseCompare cmp = kExact) const; Bool_tBeginsWith(const TString& pat, TString::ECaseCompare cmp = kExact) const; Ssiz_tCapacity() const; Ssiz_tCapacity(Ssiz_t n); TString&Chop(); static TClass*Class(); voidClear(); intCompareTo(const char* cs, TString::ECaseCompare cmp = kExact) const; intCompareTo(const TString& st, TString::ECaseCompare cmp = kExact) const; Bool_tContains(const TRegexp& pat) const; Bool_tContains(TPRegexp& pat) const; Bool_tContains(const char* pat, TString::ECaseCompare cmp = kExact) const; Bool_tContains(const T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TString.html:497,Optimiz,Optimization,497,root/html602/TString.html,https://root.cern,https://root.cern/root/html602/TString.html,2,['Optimiz'],['Optimization']
Performance,". TString. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TString. class TString. TString. Basic string class. Cannot be stored in a TCollection... use TObjString instead. The underlying string is stored as a char* that can be accessed via; TString::Data().; TString provides Short String Optimization (SSO) so that short; strings (<15 on 64-bit and <11 on 32-bit) are contained in the; TString internal data structure without the need for mallocing the; required space. Substring operations are provided by the TSubString class, which; holds a reference to the original string and its data, along with; the offset and length of the substring. To retrieve the substring; as a TString, construct a TString from it, eg:; root [0] TString s(""hello world""); root [1] TString s2( s(0,5) ); root [2] s2; (class TString)""hello"". This class is also known as (typedefs to this class)vector<TString,allocator<TString> >::value_type. Function Members (Methods); public:. TString(); TString(Ssiz_t ic); TString(const TString& s); TString(const char* s); TString(const string& s); TString(char c); TString(const TSubString& sub); TString(const char* s, Ssiz_t n); TString(char c, Ssiz_t s); virtual~TString(); TString&Append(const char* cs); TString&Append(const TString& s); TString&Append(const char* cs, Ssiz_t n); TString&Append(const TString& s, Ssiz_t n); TString&Append(char c, Ssiz_t rep = 1); Double_tAtof() const; Int_tAtoi() const; Long64_tAtoll() const; static TStringBaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); Bool_tBeginsWith(const char* s, TString::ECaseCompare cmp = kExact) const; Bool_tBeginsWith(const TString& pat, TString::ECaseCompare cmp = kExact) const; Ssiz_tCapacity() const; Ssiz_tCapacity(Ssiz_t n); TString&Chop(); static TClass*Class(); voidClear(); intCompareTo(const char* cs,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TString.html:473,Optimiz,Optimization,473,root/html534/TString.html,https://root.cern,https://root.cern/root/html534/TString.html,1,['Optimiz'],['Optimization']
Performance,". TString ; indent = """" . ); const. overridevirtual . Print multi line detailed information of this RooAbsPdf. ; Reimplemented from RooAbsArg.; Reimplemented in RooGenericPdf, and RooResolutionModel.; Definition at line 1100 of file RooAbsPdf.cxx. ◆ printValue(). void RooAbsPdf::printValue ; (; std::ostream & ; os); const. overridevirtual . Print value of p.d.f, also print normalization integral that was last used, if any. ; Reimplemented from RooPrintable.; Definition at line 1081 of file RooAbsPdf.cxx. ◆ randomizeProtoOrder(). Int_t * RooAbsPdf::randomizeProtoOrder ; (; Int_t ; nProto, . Int_t ; nGen, . bool ; resample = false . ); const. protected . Return lookup table with randomized order for nProto prototype events. ; Definition at line 1485 of file RooAbsPdf.cxx. ◆ redirectServersHook(). bool RooAbsPdf::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursiveStep . ). overrideprotectedvirtual . The cache manager. ; Hook function intercepting redirectServer calls.; Discard current normalization object if any server is redirected ; Reimplemented from RooAbsArg.; Reimplemented in RooAddPdf, RooProdPdf, RooGenericPdf, RooResolutionModel, and RooProjectedPdf.; Definition at line 2768 of file RooAbsPdf.cxx. ◆ resetErrorCounters(). void RooAbsPdf::resetErrorCounters ; (; Int_t ; resetValue = 10). virtual . Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ; Reimplemented in RooAddModel, and RooAddPdf.; Definition at line 586 of file RooAbsPdf.cxx. ◆ selfNormalized(). virtual bool RooAbsPdf::selfNormalized ; (; ); const. inlinevirtual . Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ; Always returns false, unless a PDF overrides this function. ; Reimplemented in RooHistConstraint, RooIntegralMorph, RooMomentMorph, RooAbsCachedPdf, RooAddModel, RooAddPdf, RooBinSamplingPdf, RooExte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:151303,cache,cache,151303,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['cache'],['cache']
Performance,". TSubString. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TSubString. class TSubString. TString. Basic string class. Cannot be stored in a TCollection... use TObjString instead. The underlying string is stored as a char* that can be accessed via; TString::Data().; TString provides Short String Optimization (SSO) so that short; strings (<15 on 64-bit and <11 on 32-bit) are contained in the; TString internal data structure without the need for mallocing the; required space. Substring operations are provided by the TSubString class, which; holds a reference to the original string and its data, along with; the offset and length of the substring. To retrieve the substring; as a TString, construct a TString from it, eg:; root [0] TString s(""hello world""); root [1] TString s2( s(0,5) ); root [2] s2; (class TString)""hello"". Function Members (Methods); public:. ~TSubString(); const char*Data() const; Bool_tIsNull() const; Ssiz_tLength() const; intoperator!() const; char&operator()(Ssiz_t i); charoperator()(Ssiz_t i) const; TSubString&operator=(const char* s); TSubString&operator=(const TString& s); TSubString&operator=(const TSubString& s); char&operator[](Ssiz_t i); charoperator[](Ssiz_t i) const; Ssiz_tStart() const; TString&String(); voidToLower(); voidToUpper(); TSubString(const TSubString& s). protected:. voidAssertElement(Ssiz_t i) const; voidSubStringError(Ssiz_t, Ssiz_t, Ssiz_t) const. private:. TSubString(const TString& s, Ssiz_t start, Ssiz_t len). Data Members; private:. Ssiz_tfBeginIndex of starting character; Ssiz_tfExtentLength of TSubString; TString&fStrReferenced string. Class Charts. Inheritance Chart:. TSubString. Function documentation; TSubString(const TString& s, Ssiz_t start, Ssiz_t len); Private constructor. char& operator[](Ssiz_t i); Return cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSubString.html:506,Optimiz,Optimization,506,root/html602/TSubString.html,https://root.cern,https://root.cern/root/html602/TSubString.html,1,['Optimiz'],['Optimization']
Performance,". TSubString. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TSubString. class TSubString. TString. Basic string class. Cannot be stored in a TCollection... use TObjString instead. The underlying string is stored as a char* that can be accessed via; TString::Data().; TString provides Short String Optimization (SSO) so that short; strings (<15 on 64-bit and <11 on 32-bit) are contained in the; TString internal data structure without the need for mallocing the; required space. Substring operations are provided by the TSubString class, which; holds a reference to the original string and its data, along with; the offset and length of the substring. To retrieve the substring; as a TString, construct a TString from it, eg:; root [0] TString s(""hello world""); root [1] TString s2( s(0,5) ); root [2] s2; (class TString)""hello"". Function Members (Methods); public:. ~TSubString(); const char*Data() const; Bool_tIsNull() const; Ssiz_tLength() const; stringoperator basic_string() const; string_viewoperator basic_string_view() const; intoperator!() const; char&operator()(Ssiz_t i); charoperator()(Ssiz_t i) const; TSubString&operator=(const char* s); TSubString&operator=(const TString& s); TSubString&operator=(const TSubString& s); char&operator[](Ssiz_t i); charoperator[](Ssiz_t i) const; Ssiz_tStart() const; TString&String(); voidToLower(); voidToUpper(); TSubString(const TSubString& s). protected:. voidAssertElement(Ssiz_t i) const; voidSubStringError(Ssiz_t, Ssiz_t, Ssiz_t) const. private:. TSubString(const TString& s, Ssiz_t start, Ssiz_t len). Data Members; private:. Ssiz_tfBeginIndex of starting character; Ssiz_tfExtentLength of TSubString; TString&fStrReferenced string. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSubString(const TString& s, Ssiz_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TSubString.html:482,Optimiz,Optimization,482,root/html604/TSubString.html,https://root.cern,https://root.cern/root/html604/TSubString.html,1,['Optimiz'],['Optimization']
Performance,". TTabCom. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » RINT; » TTabCom. class TTabCom. TTabCom. This class performs basic tab completion.; You should be able to hit [TAB] to complete a partially typed:. username; environment variable; preprocessor directive; pragma; filename (with a context-sensitive path); public member function or data member (including base classes); global variable, function, or class name. Also, something like. someObject->Func([TAB]; someObject.Func([TAB]; someClass::Func([TAB]; someClass var([TAB]; new someClass([TAB]. will print a list of prototypes for the indicated; method or constructor. Current limitations and bugs:. 1. you can only use one member access operator at a time.; eg, this will work: gROOT->GetListOfG[TAB]; but this will not: gROOT->GetListOfGlobals()->Conta[TAB]. 2. nothing is guaranteed to work on windows; (for one thing, /bin/env and /etc/passwd are hardcoded). 3. CINT shortcut #2 is deliberately not supported.; (using ""operator.()"" instead of ""operator->()""). 4. most identifiers (including C++ identifiers, usernames,; environment variables, etc); are restriceted to this character set: [_a-zA-Z0-9]; therefore, you won't be able to complete things like. operator new; operator+; etc. 5. ~whatever[TAB] always tries to complete a username.; use whitespace (~ whatever[TAB]) if you want to complete a global; identifier. 6. CINT shortcut #3 is not supported when trying to complete; the name of a global object. (it is supported when trying to; complete a member of a global object). 7. the list of #pragma's is hardcoded; (ie not obtained from the interpreter at runtime); ==> user-defined #pragma's will not be recognized. 8. the system include directories are also hardcoded; because i don't know how to get them from the interpreter.; f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTabCom.html:310,perform,performs,310,root/html602/TTabCom.html,https://root.cern,https://root.cern/root/html602/TTabCom.html,2,['perform'],['performs']
Performance,". TTabCom. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » RINT; » TTabCom. class TTabCom. TTabCom. This class performs basic tab completion.; You should be able to hit [TAB] to complete a partially typed:. username; environment variable; preprocessor directive; pragma; filename (with a context-sensitive path); public member function or data member (including base classes); global variable, function, or class name. Also, something like. someObject->Func([TAB]; someObject.Func([TAB]; someClass::Func([TAB]; someClass var([TAB]; new someClass([TAB]. will print a list of prototypes for the indicated; method or constructor. Current limitations and bugs:. 1. you can only use one member access operator at a time.; eg, this will work: gROOT->GetListOfG[TAB]; but this will not: gROOT->GetListOfGlobals()->Conta[TAB]. 2. nothing is guaranteed to work on windows or VMS; (for one thing, /bin/env and /etc/passwd are hardcoded). 3. CINT shortcut #2 is deliberately not supported.; (using ""operator.()"" instead of ""operator->()""). 4. most identifiers (including C++ identifiers, usernames,; environment variables, etc); are restriceted to this character set: [_a-zA-Z0-9]; therefore, you won't be able to complete things like. operator new; operator+; etc. 5. ~whatever[TAB] always tries to complete a username.; use whitespace (~ whatever[TAB]) if you want to complete a global; identifier. 6. CINT shortcut #3 is not supported when trying to complete; the name of a global object. (it is supported when trying to; complete a member of a global object). 7. the list of #pragma's is hardcoded; (ie not obtained from the interpreter at runtime); ==> user-defined #pragma's will not be recognized. 8. the system include directories are also hardcoded; because i don't know how to get them from the interpreter.; fons, maybe they s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTabCom.html:286,perform,performs,286,root/html528/TTabCom.html,https://root.cern,https://root.cern/root/html528/TTabCom.html,3,['perform'],['performs']
Performance,". TTabCom. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » RINT; » TTabCom. class TTabCom. TTabCom. This class performs basic tab completion.; You should be able to hit [TAB] to complete a partially typed:. username; environment variable; preprocessor directive; pragma; filename (with a context-sensitive path); public member function or data member (including base classes); global variable, function, or class name. Also, something like. someObject->Func([TAB]; someObject.Func([TAB]; someClass::Func([TAB]; someClass var([TAB]; new someClass([TAB]. will print a list of prototypes for the indicated; method or constructor. Current limitations and bugs:. 1. you can only use one member access operator at a time.; eg, this will work: gROOT->GetListOfG[TAB]; but this will not: gROOT->GetListOfGlobals()->Conta[TAB]. 2. nothing is guaranteed to work on windows; (for one thing, /bin/env and /etc/passwd are hardcoded). 3. CINT shortcut #2 is deliberately not supported.; (using ""operator.()"" instead of ""operator->()""). 4. most identifiers (including C++ identifiers, usernames,; environment variables, etc); are restriceted to this character set: [_a-zA-Z0-9]; therefore, you won't be able to complete things like. operator new; operator+; etc. 5. ~whatever[TAB] always tries to complete a username.; use whitespace (~ whatever[TAB]) if you want to complete a global; identifier. 6. CINT shortcut #3 is not supported when trying to complete; the name of a global object. (it is supported when trying to; complete a member of a global object). 7. the list of #pragma's is hardcoded; (ie not obtained from the interpreter at runtime); ==> user-defined #pragma's will not be recognized. 8. the system include directories are also hardcoded; because i don't know how to get them from the interpreter.; fons, maybe they should b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTabCom.html:286,perform,performs,286,root/html534/TTabCom.html,https://root.cern,https://root.cern/root/html534/TTabCom.html,1,['perform'],['performs']
Performance,". TTableRange. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TTableRange. class TTableRange. TGTable. TGTable implements a table widget to display data in rows and; columns. The data is supplied by a TVirtualTableInterface. The table is a TGCanvas to make use of already available viewport; functionality and drawing optimizations. The top left cell in a table has coordinates (0,0). A TObjArray is used internally to ensure little overhead and fast; acces to cells. If the data source has more rows than the default 50 rows of cells in; memory, buttons at the bottom of the table can be used to load the; next or previous chunk of data. At the top of the table, a frame is visible that shows the coordinates; of the top left cell currently in memmory in row,column. The amount of; rows and columns is also shown in rows x columns. These values can be; edited to move to a different area of the data source or to resize the; table. Tab will switch between the enties, return will move to the; currently entered range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate; TVirtualTableInterface from the data that needs visualization and; then creating the TGTable using this interface. A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTableRange.html:524,optimiz,optimizations,524,root/html602/TTableRange.html,https://root.cern,https://root.cern/root/html602/TTableRange.html,4,"['load', 'optimiz']","['load', 'optimizations']"
Performance,". TTableRange. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TTableRange. class TTableRange. TGTable; ; TGTable implements a table widget to display data in rows and ; columns. The data is supplied by a TVirtualTableInterface. . The table is a TGCanvas to make use of already available viewport ; functionality and drawing optimizations. . The top left cell in a table has coordinates (0,0) . A TObjArray is used internally to ensure little overhead and fast ; acces to cells. . If the data source has more rows than the default 50 rows of cells in; memory, buttons at the bottom of the table can be used to load the; next or previous chunk of data. At the top of the table, a frame is visible that shows the coordinates; of the top left cell currently in memmory in row,column. The amount of; rows and columns is also shown in rows x columns. These values can be; edited to move to a different area of the data source or to resize the; table. Tab will switch between the enties, return will move to the; currently entered range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate ; TVirtualTableInterface from the data that needs visualization and ; then creating the TGTable using this interface. . A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimpleTableI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTableRange.html:506,optimiz,optimizations,506,root/html528/TTableRange.html,https://root.cern,https://root.cern/root/html528/TTableRange.html,6,"['load', 'optimiz']","['load', 'optimizations']"
Performance,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:409,cache,cache,409,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,6,"['cache', 'latency', 'perform']","['cache', 'latency', 'performance']"
Performance,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the '",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:409,cache,cache,409,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,6,"['cache', 'latency', 'perform']","['cache', 'latency', 'performance']"
Performance,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:385,cache,cache,385,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,6,"['cache', 'latency', 'perform']","['cache', 'latency', 'performance']"
Performance,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:385,cache,cache,385,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,18,"['cache', 'latency', 'perform']","['cache', 'latency', 'performance']"
Performance,". TTreeCacheUnzip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCacheUnzip. class TTreeCacheUnzip: public TTreeCache. Parallel Unzipping. TTreeCache has been specialised in order to let additional threads; free to unzip in advance its content. In this implementation we; support up to 10 threads, but right now it makes more sense to; limit their number to 1-2. The application reading data is carefully synchronized, in order to:; - if the block it wants is not unzipped, it self-unzips it without; waiting; - if the block is being unzipped in parallel, it waits only; for that unzip to finish; - if the block has already been unzipped, it takes it. This is supposed to cancel a part of the unzipping latency, at the; expenses of cpu time. The default parameters are the same of the prev version, i.e. 20%; of the TTreeCache cache size. To change it use; TTreeCache::SetUnzipBufferSize(Long64_t bufferSize); where bufferSize must be passed in bytes. Function Members (Methods); public:. virtual~TTreeCacheUnzip(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual Int_tAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCacheUnzip.html:917,latency,latency,917,root/html604/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html,1,['latency'],['latency']
Performance,". TTreeCacheUnzip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCacheUnzip. class TTreeCacheUnzip: public TTreeCache. Parallel Unzipping. TTreeCache has been specialised in order to let additional threads; free to unzip in advance its content. In this implementation we; support up to 10 threads, but right now it makes more sense to; limit their number to 1-2. The application reading data is carefully synchronized, in order to:; - if the block it wants is not unzipped, it self-unzips it without; waiting; - if the block is being unzipped in parallel, it waits only; for that unzip to finish; - if the block has already been unzipped, it takes it. This is supposed to cancel a part of the unzipping latency, at the; expenses of cpu time. The default parameters are the same of the prev version, i.e. 20%; of the TTreeCache cache size. To change it use; TTreeCache::SetUnzipBufferSize(Long64_t bufferSize); where bufferSize must be passed in bytes. Function Members (Methods); public:. virtual~TTreeCacheUnzip(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCacheUnzip.html:917,latency,latency,917,root/html602/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html,1,['latency'],['latency']
Performance,". TTreeCacheUnzip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCacheUnzip. class TTreeCacheUnzip: public TTreeCache. Parallel Unzipping. TTreeCache has been specialised in order to let additional threads; free to unzip in advance its content. In this implementation we; support up to 10 threads, but right now it makes more sense to; limit their number to 1-2. The application reading data is carefully synchronized, in order to:; - if the block it wants is not unzipped, it self-unzips it without; waiting; - if the block is being unzipped in parallel, it waits only; for that unzip to finish; - if the block has already been unzipped, it takes it. This is supposed to cancel a part of the unzipping latency, at the; expenses of cpu time. The default parameters are the same of the prev version, i.e. 20%; of the TTreeCache cache size. To change it use; TTreeCache::SetUnzipBufferSize(Long64_t bufferSize); where bufferSize must be passed in bytes. Function Members (Methods); public:. TTreeCacheUnzip(); TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); virtual~TTreeCacheUnzip(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCacheUnzip.html:893,latency,latency,893,root/html534/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html,1,['latency'],['latency']
Performance,". TTreeCacheUnzip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCacheUnzip. class TTreeCacheUnzip: public TTreeCache. Parallel Unzipping. TTreeCache has been specialised in order to let additional threads; free to unzip in advance its content. In this implementation we; support up to 10 threads, but right now it makes more sense to; limit their number to 1-2. The application reading data is carefully synchronized, in order to:; - if the block it wants is not unzipped, it self-unzips it without; waiting; - if the block is being unzipped in parallel, it waits only; for that unzip to finish; - if the block has already been unzipped, it takes it. This is supposed to cancel a part of the unzipping latency, at the; expenses of cpu time. The default parameters are the same of the prev version, i.e. 20%; of the TTreeCache cache size. To change it use; TTreeCache::SetUnzipBufferSize(Long64_t bufferSize); where bufferSize must be passed in bytes. Function Members (Methods); public:. TTreeCacheUnzip(); TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); virtual~TTreeCacheUnzip(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCacheUnzip.html:893,latency,latency,893,root/html528/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html528/TTreeCacheUnzip.html,3,['latency'],['latency']
Performance,". TTreeFormula * GetMajorFormula(); Return a pointer to the TreeFormula corresponding to the majorname. TTreeFormula * GetMinorFormula(); Return a pointer to the TreeFormula corresponding to the minorname. TTreeFormula * GetMajorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the majorname in parent tree. TTreeFormula * GetMinorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the minorname in parent tree. void Print(Option_t* option = """") const; Print the table with : serial number, majorname, minorname.; if option = ""10"" print only the first 10 entries; if option = ""100"" print only the first 100 entries; if option = ""1000"" print only the first 1000 entries. void Streamer(TBuffer& ); Stream an object of class TTreeIndex.; Note that this Streamer should be changed to an automatic Streamer; once TStreamerInfo supports an index of type Long64_t. void UpdateFormulaLeaves(const TTree* parent); Called by TChain::LoadTree when the parent chain changes it's tree. void SetTree(const TTree* T); this function is called by TChain::LoadTree and TTreePlayer::UpdateFormulaLeaves; when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreeIndex. TTreeIndex(const TTreeIndex& ). TTreeIndex & operator=(const TTreeIndex& ). Long64_t * GetIndex() const; {return fIndex;}. Long64_t * GetIndexValues() const; {return fIndexValues;}. const char * GetMajorName() const; {return fMajorName.Data();}. const char * GetMinorName() const; {return fMinorName.Data();}. Long64_t GetN() const; {return fN;}. » Author: Rene Brun 05/07/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeIndex.html:13165,Load,LoadTree,13165,root/html534/TTreeIndex.html,https://root.cern,https://root.cern/root/html534/TTreeIndex.html,2,"['Load', 'load']","['LoadTree', 'loaded']"
Performance,". TTreeFormula * GetMajorFormula(); Return a pointer to the TreeFormula corresponding to the majorname. TTreeFormula * GetMinorFormula(); Return a pointer to the TreeFormula corresponding to the minorname. TTreeFormula * GetMajorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the majorname in parent tree. TTreeFormula * GetMinorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the minorname in parent tree. void Print(Option_t* option = """") const; Print the table with : serial number, majorname, minorname.; if option = ""10"" print only the first 10 entries; if option = ""100"" print only the first 100 entries; if option = ""1000"" print only the first 1000 entries. void Streamer(TBuffer& ); Stream an object of class TTreeIndex.; Note that this Streamer should be changed to an automatic Streamer; once TStreamerInfo supports an index of type Long64_t. void UpdateFormulaLeaves(const TTree* parent); Called by TChain::LoadTree when the parent chain changes it's tree. void SetTree(const TTree* T); this function is called by TChain::LoadTree and TTreePlayer::UpdateFormulaLeaves; when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreeIndex. TTreeIndex(const TTreeIndex& ). TTreeIndex & operator=(const TTreeIndex& ). Long64_t * GetIndex() const; {return fIndex;}. Long64_t * GetIndexValues() const; {return fIndexValues;}. const char * GetMajorName() const; {return fMajorName.Data();}. const char * GetMinorName() const; {return fMinorName.Data();}. Long64_t GetN() const; {return fN;}. » Author: Rene Brun 05/07/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeIndex.html:13670,Load,LoadTree,13670,root/html604/TTreeIndex.html,https://root.cern,https://root.cern/root/html604/TTreeIndex.html,2,"['Load', 'load']","['LoadTree', 'loaded']"
Performance,". TTreeFormula * GetMajorFormula(); Return a pointer to the TreeFormula corresponding to the majorname. TTreeFormula * GetMinorFormula(); Return a pointer to the TreeFormula corresponding to the minorname. TTreeFormula * GetMajorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the majorname in parent tree. TTreeFormula * GetMinorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the minorname in parent tree. void Print(Option_t* option = """") const; Print the table with : serial number, majorname, minorname.; if option = ""10"" print only the first 10 entries; if option = ""100"" print only the first 100 entries; if option = ""1000"" print only the first 1000 entries. void Streamer(TBuffer& ); Stream an object of class TTreeIndex.; Note that this Streamer should be changed to an automatic Streamer; once TStreamerInfo supports an index of type Long64_t. void UpdateFormulaLeaves(const TTree* parent); Called by TChain::LoadTree when the parent chain changes it's tree. void SetTree(const TTree* T); this function is called by TChain::LoadTree and TTreePlayer::UpdateFormulaLeaves; when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreeIndex. TTreeIndex(const TTreeIndex& ). TTreeIndex & operator=(const TTreeIndex& ). Long64_t * GetIndex() const; {return fIndex;}. Long64_t * GetIndexValues() const; {return fIndexValues;}. const char * GetMajorName() const; {return fMajorName.Data();}. const char * GetMinorName() const; {return fMinorName.Data();}. Long64_t GetN() const; {return fN;}. » Author: Rene Brun 05/07/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeIndex.html:13670,Load,LoadTree,13670,root/html602/TTreeIndex.html,https://root.cern,https://root.cern/root/html602/TTreeIndex.html,2,"['Load', 'load']","['LoadTree', 'loaded']"
Performance,". TTreePerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreePerfStats. class TTreePerfStats: public TVirtualPerfStats. TTreePerfStats. TTree I/O performance measurement. see example of use below. The function FileReadEvent is called from TFile::ReadBuffer.; For each call the following information is stored in fGraphIO; - x[i] = Tree entry number; - y[i] = 1e-6*(file position); - ey[i] = 1e-9*number of bytes read; For each call the following information is stored in fGraphTime; - x[i] = Tree entry number; - y[i] = Time now; - ey[i] = readtime, eg timenow - start; The TTreePerfStats object can be saved in a ROOT file in such a way that; its inspection can be done outside the job that generated it. Example of use; {; TFile *f = TFile::Open(""RelValMinBias-GEN-SIM-RECO.root"");; T = (TTree*)f->Get(""Events"");; Long64_t nentries = T->GetEntries();; T->SetCacheSize(10000000);; T->SetCacheEntryRange(0,nentries);; T->AddBranchToCache(""*"");. TTreePerfStats *ps= new TTreePerfStats(""ioperf"",T);. for (Int_t i=0;i<nentries;i++) {; T->GetEntry(i);; }; ps->SaveAs(""cmsperf.root"");; }. then, in a root interactive session, one can do:; root > TFile f(""cmsperf.root"");; root > ioperf->Draw();; root > ioperf->Print();. The Draw or Print functions print the following information:; TreeCache = TTree cache size in MBytes; N leaves = Number of leaves in the TTree; ReadTotal = Total number of zipped bytes read; ReadUnZip = Total number of unzipped bytes read; ReadCalls = Total number of disk reads; ReadSize = Average read size in KBytes; Readahead = Readahead size in KBytes; Readextra = Readahead overhead in percent; Real Time = Real Time in seconds; CPU Time = CPU Time in seconds; Disk Time = Real Time spent in pure raw disk IO; Disk IO = Raw disk IO speed in MBytes/second; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreePerfStats.html:369,perform,performance,369,root/html602/TTreePerfStats.html,https://root.cern,https://root.cern/root/html602/TTreePerfStats.html,2,['perform'],['performance']
Performance,". TTreePerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreePerfStats. class TTreePerfStats: public TVirtualPerfStats. TTreePerfStats. TTree I/O performance measurement. see example of use below. The function FileReadEvent is called from TFile::ReadBuffer.; For each call the following information is stored in fGraphIO; - x[i] = Tree entry number; - y[i] = 1e-6*(file position); - ey[i] = 1e-9*number of bytes read; For each call the following information is stored in fGraphTime; - x[i] = Tree entry number; - y[i] = Time now; - ey[i] = readtime, eg timenow - start; The TTreePerfStats object can be saved in a ROOT file in such a way that; its inspection can be done outside the job that generated it. Example of use; {; TFile *f = TFile::Open(""RelValMinBias-GEN-SIM-RECO.root"");; T = (TTree*)f->Get(""Events"");; Long64_t nentries = T->GetEntries();; T->SetCacheSize(10000000);; T->SetCacheEntryRange(0,nentries);; T->AddBranchToCache(""*"");. TTreePerfStats *ps= new TTreePerfStats(""ioperf"",T);. for (Int_t i=0;i<nentries;i++) {; T->GetEntry(i);; }; ps->SaveAs(""cmsperf.root"");; }. then, in a root interactive session, one can do:; root > TFile f(""cmsperf.root"");; root > ioperf->Draw();; root > ioperf->Print();. The Draw or Print functions print the following information:; TreeCache = TTree cache size in MBytes; N leaves = Number of leaves in the TTree; ReadTotal = Total number of zipped bytes read; ReadUnZip = Total number of unzipped bytes read; ReadCalls = Total number of disk reads; ReadSize = Average read size in KBytes; Readahead = Readahead size in KBytes; Readextra = Readahead overhead in percent; Real Time = Real Time in seconds; CPU Time = CPU Time in seconds; Disk Time = Real Time spent in pure raw disk IO; Disk IO = Raw disk IO speed in MBytes/second; ReadUZRT = Unzipped MByt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePerfStats.html:345,perform,performance,345,root/html528/TTreePerfStats.html,https://root.cern,https://root.cern/root/html528/TTreePerfStats.html,4,['perform'],['performance']
Performance,". TVirtualMutex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualMutex. class TVirtualMutex: public TObject. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMutex(); voidTObject::AbstractMethod(const char* method) const; Int_tAcquire(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualMutex.html:468,load,loaded,468,root/html602/TVirtualMutex.html,https://root.cern,https://root.cern/root/html602/TVirtualMutex.html,2,['load'],['loaded']
Performance,". TVirtualMutex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualMutex. class TVirtualMutex: public TObject. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMutex(); voidTObject::AbstractMethod(const char* method) const; Int_tAcquire(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMutex.html:444,load,loaded,444,root/html528/TVirtualMutex.html,https://root.cern,https://root.cern/root/html528/TVirtualMutex.html,4,['load'],['loaded']
Performance,". TVirtualPacketizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TVirtualPacketizer. class TVirtualPacketizer: public TObject. TVirtualPacketizer. The packetizer is a load balancing object created for each query.; It generates packets to be processed on PROOF worker servers.; A packet is an event range (begin entry and number of entries) or; object range (first object and number of objects) in a TTree; (entries) or a directory (objects) in a file.; Packets are generated taking into account the performance of the; remote machine, the time it took to process a previous packet on; the remote machine, the locality of the database files, etc. TVirtualPacketizer includes common parts of PROOF packetizers.; Look in subclasses for details.; The default packetizer is TPacketizerAdaptive.; To use an alternative one, for instance - the TPacketizer, call:; proof->SetParameter(""PROOF_Packetizer"", ""TPacketizer"");. Function Members (Methods); public:. virtual~TVirtualPacketizer(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual Int_tAddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tAssignWork(TDSet*, Long64_t, Long64_t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualPacketizer.html:387,load,load,387,root/html602/TVirtualPacketizer.html,https://root.cern,https://root.cern/root/html602/TVirtualPacketizer.html,4,"['load', 'perform']","['load', 'performance']"
Performance,". TVirtualPacketizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TVirtualPacketizer. class TVirtualPacketizer: public TObject. TVirtualPacketizer. The packetizer is a load balancing object created for each query.; It generates packets to be processed on PROOF worker servers.; A packet is an event range (begin entry and number of entries) or; object range (first object and number of objects) in a TTree; (entries) or a directory (objects) in a file.; Packets are generated taking into account the performance of the; remote machine, the time it took to process a previous packet on; the remote machine, the locality of the database files, etc. TVirtualPacketizer includes common parts of PROOF packetizers.; Look in subclasses for details.; The default packetizer is TPacketizerAdaptive.; To use an alternative one, for instance - the TPacketizer, call:; proof->SetParameter(""PROOF_Packetizer"", ""TPacketizer"");. Function Members (Methods); public:. virtual~TVirtualPacketizer(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual Int_tAddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualPacketizer.html:363,load,load,363,root/html534/TVirtualPacketizer.html,https://root.cern,https://root.cern/root/html534/TVirtualPacketizer.html,2,"['load', 'perform']","['load', 'performance']"
Performance,". TVirtualPacketizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TVirtualPacketizer. class TVirtualPacketizer: public TObject. TVirtualPacketizer. The packetizer is a load balancing object created for each query.; It generates packets to be processed on PROOF worker servers.; A packet is an event range (begin entry and number of entries) or; object range (first object and number of objects) in a TTree; (entries) or a directory (objects) in a file.; Packets are generated taking into account the performance of the; remote machine, the time it took to process a previous packet on; the remote machine, the locality of the database files, etc. TVirtualPacketizer includes common parts of PROOF packetizers.; Look in subclasses for details.; The default packetizer is TPacketizerAdaptive.; To use an alternative one, for instance - the TPacketizer, call:; proof->SetParameter(""PROOF_Packetizer"", ""TPacketizer"");. Function Members (Methods); public:. virtual~TVirtualPacketizer(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualPacketizer.html:363,load,load,363,root/html528/TVirtualPacketizer.html,https://root.cern,https://root.cern/root/html528/TVirtualPacketizer.html,6,"['load', 'perform']","['load', 'performance']"
Performance,". TVirtualPerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPerfStats. class TVirtualPerfStats: public TObject. TVirtualPerfStats. Provides the interface for the PROOF internal performance measurment; and event tracing. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TVirtualPerfStats*&CurrentPerfStats(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualPerfStats.html:401,perform,performance,401,root/html602/TVirtualPerfStats.html,https://root.cern,https://root.cern/root/html602/TVirtualPerfStats.html,2,['perform'],['performance']
Performance,". TVirtualPerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPerfStats. class TVirtualPerfStats: public TObject. TVirtualPerfStats. Provides the interface for the PROOF internal performance measurment; and event tracing. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TVirtualPerfStats*&CurrentPerfStats(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualPerfStats.html:377,perform,performance,377,root/html534/TVirtualPerfStats.html,https://root.cern,https://root.cern/root/html534/TVirtualPerfStats.html,1,['perform'],['performance']
Performance,". TVirtualPerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPerfStats. class TVirtualPerfStats: public TObject. TVirtualPerfStats. Provides the interface for the PROOF internal performance measurment; and event tracing. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualPerfStats.html:377,perform,performance,377,root/html528/TVirtualPerfStats.html,https://root.cern,https://root.cern/root/html528/TVirtualPerfStats.html,3,['perform'],['performance']
Performance,". TVolumeView. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TVolumeView. class TVolumeView: public TObjectSet, public TAtt3D. TVolumeView. TVolumeView class is a special kind of TDataSet with one extra; pointer to wrap any TObject onto TDataSet object. BE CAREFUL !!!; One has to use it carefully no control over that extra object; is performed. This means: the object m_Obj data-member points to can; be destroyed with no this kbject notifying.; There is no tool /protection to check whether m_Obj is till alive.; It is one's code responsilitiy. Function Members (Methods); public:. virtual~TVolumeView(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TDataSet* dataset); virtual voidAdd(TVolumeView* node); virtual voidAdd(TShape* shape, Bool_t IsMaster = kFALSE); virtual voidTDataSet::AddAt(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddAtAndExpand(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddFirst(TDataSet* dataset); virtual voidTDataSet::AddLast(TDataSet* dataset); virtual TVolume*AddNode(TVolume* node); virtual TObject*TObjectSet::AddObject(TObject* obj, Bool_t makeOwner = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); TDataSet*TDataSet::At(Int_t idx) const; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObjectSet::Delete(Option_t* opt = """"); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTObjectSet::DoOwner(Bool_t done = kTRUE); virtual voidDraw(Option_t* depth = ""3"")MENU ; virtual voidTObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVolumeView.html:546,perform,performed,546,root/html602/TVolumeView.html,https://root.cern,https://root.cern/root/html602/TVolumeView.html,2,['perform'],['performed']
Performance,". TVolumeView. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TVolumeView. class TVolumeView: public TObjectSet, public TAtt3D. TVolumeView. TVolumeView class is a special kind of TDataSet with one extra; pointer to wrap any TObject onto TDataSet object. BE CAREFUL !!!; One has to use it carefully no control over that extra object; is performed. This means: the object m_Obj data-member points to can; be destroyed with no this kbject notifying.; There is no tool /protection to check whether m_Obj is till alive.; It is one's code responsilitiy. Function Members (Methods); public:. TVolumeView(); TVolumeView(TVolumeView* viewNode, TVolumePosition* nodePosition = 0); TVolumeView(TVolumeView* viewNode, TVolumeView* topNode); TVolumeView(TVolume* thisNode, TVolumePosition* nodePosition); TVolumeView(TVolumeView* viewNode, const Char_t* NodeName1, const Char_t* NodeName2 = 0); TVolumeView(TVolumeView* viewNode, const TVolumeView* node1, const TVolumeView* node2); TVolumeView(TVolume& pattern, Int_t maxDepLevel = 0, const TVolumePosition* nodePosition = 0, TDataSet::EDataSetPass iopt = kMarked, TVolumeView* root = 0); TVolumeView(Double_t* translate, Double_t* rotate, UInt_t positionId, TVolume* thisNode, const Char_t* thisNodePath, const Char_t* matrixName = 0, Int_t matrixType = 0); virtual~TVolumeView(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TDataSet* dataset); virtual voidAdd(TVolumeView* node); virtual voidAdd(TShape* shape, Bool_t IsMaster = kFALSE); virtual voidTDataSet::AddAt(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddAtAndExpand(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddFirst(TDataSet* dataset); virtual voidTDataSet::AddLast(TDataSet* dataset); virtual TVolume*AddNode(TVolume* node); virtual TObject*TObjectSet::AddObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVolumeView.html:522,perform,performed,522,root/html528/TVolumeView.html,https://root.cern,https://root.cern/root/html528/TVolumeView.html,4,['perform'],['performed']
Performance,". TXMLPlayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » XML; » TXMLPlayer. class TXMLPlayer: public TObject. Class for xml code generation; It should be used for generation of xml steramers, which could be used outside root; environment. This means, that with help of such streamers user can read and write; objects from/to xml file, which later can be accepted by ROOT. At the moment supported only classes, which are not inherited from TObject; and which not contains any TObject members. To generate xml code:. 1. ROOT library with required classes should be created.; In general, without such library non of user objects can be stored and; retrived from any ROOT file. 2. Generate xml streamers by root script like:. void generate() {; gSystem->Load(""libRXML.so""); // load ROOT xml library; gSystem->Load(""libuser.so""); // load user ROOT library. TList lst;; lst.Add(TClass::GetClass(""TUserClass1""));; lst.Add(TClass::GetClass(""TUserClass2""));. TXMLPlayer player;; player.ProduceCode(&lst, ""streamers""); // create xml streamers; }. 3. Copy ""streamers.h"", ""streamers.cxx"", ""TXmlFile.h"", ""TXmlFile.cxx"" files; to user project and compile them. TXmlFile class implementation can be taken; from http://www-linux.gsi.de/~linev/xmlfile.tar.gz. TXMLPlayer class generates one function per class, which called class streamer.; Name of such function for class TExample will be TExample_streamer. Following data members for streamed classes are supported:; - simple data types (int, double, float); - array of simple types (int[5], double[5][6]); - dynamic array of simple types (int* with comment field // [fSize]); - const char*; - object of any nonROOT class; - pointer on object; - array of objects; - array of pointers on objects; - stl string; - stl vector, list, deque, set, multiset, map, multima",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXMLPlayer.html:952,Load,Load,952,root/html602/TXMLPlayer.html,https://root.cern,https://root.cern/root/html602/TXMLPlayer.html,6,"['Load', 'load']","['Load', 'load']"
Performance,". TXMLPlayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » XML; » TXMLPlayer. class TXMLPlayer: public TObject. Class for xml code generation; It should be used for generation of xml steramers, which could be used outside root; enviroment. This means, that with help of such streamers user can read and write; objects from/to xml file, which later can be accepted by ROOT. At the moment supported only classes, which are not inherited from TObject; and which not contains any TObject members. To generate xml code:. 1. ROOT library with required classes should be created.; In general, without such library non of user objects can be stored and; retrived from any ROOT file. 2. Generate xml streamers by root script like:. void generate() {; gSystem->Load(""libRXML.so""); // load ROOT xml library; gSystem->Load(""libuser.so""); // load user ROOT library. TList lst;; lst.Add(TClass::GetClass(""TUserClass1""));; lst.Add(TClass::GetClass(""TUserClass2""));. TXMLPlayer player;; player.ProduceCode(&lst, ""streamers""); // create xml streamers; }. 3. Copy ""streamers.h"", ""streamers.cxx"", ""TXmlFile.h"", ""TXmlFile.cxx"" files; to user project and compile them. TXmlFile class implementation can be taken; from http://www-linux.gsi.de/~linev/xmlfile.tar.gz. TXMLPlayer class generates one function per class, which called class streamer.; Name of such function for class TExample will be TExample_streamer. Following data members for streamed classes are supported:; - simple data types (int, double, float); - array of simple types (int[5], double[5][6]); - dynamic array of simple types (int* with comment field // [fSize]); - const char*; - object of any nonROOT class; - pointer on object; - array of objects; - array of pointers on objects; - stl string; - stl vector, list, deque, set, multiset, map, multimap; - allowed arguments fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLPlayer.html:927,Load,Load,927,root/html528/TXMLPlayer.html,https://root.cern,https://root.cern/root/html528/TXMLPlayer.html,9,"['Load', 'load']","['Load', 'load']"
Performance,". TXMLPlayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » XML; » TXMLPlayer. class TXMLPlayer: public TObject. Class for xml code generation; It should be used for generation of xml steramers, which could be used outside root; environment. This means, that with help of such streamers user can read and write; objects from/to xml file, which later can be accepted by ROOT. At the moment supported only classes, which are not inherited from TObject; and which not contains any TObject members. To generate xml code:. 1. ROOT library with required classes should be created.; In general, without such library non of user objects can be stored and; retrived from any ROOT file. 2. Generate xml streamers by root script like:. void generate() {; gSystem->Load(""libRXML.so""); // load ROOT xml library; gSystem->Load(""libuser.so""); // load user ROOT library. TList lst;; lst.Add(TClass::GetClass(""TUserClass1""));; lst.Add(TClass::GetClass(""TUserClass2""));. TXMLPlayer player;; player.ProduceCode(&lst, ""streamers""); // create xml streamers; }. 3. Copy ""streamers.h"", ""streamers.cxx"", ""TXmlFile.h"", ""TXmlFile.cxx"" files; to user project and compile them. TXmlFile class implementation can be taken; from http://www-linux.gsi.de/~linev/xmlfile.tar.gz. TXMLPlayer class generates one function per class, which called class streamer.; Name of such function for class TExample will be TExample_streamer. Following data members for streamed classes are supported:; - simple data types (int, double, float); - array of simple types (int[5], double[5][6]); - dynamic array of simple types (int* with comment field // [fSize]); - const char*; - object of any nonROOT class; - pointer on object; - array of objects; - array of pointers on objects; - stl string; - stl vector, list, deque, set, multiset, map, multimap; - allowed arguments f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXMLPlayer.html:928,Load,Load,928,root/html534/TXMLPlayer.html,https://root.cern,https://root.cern/root/html534/TXMLPlayer.html,3,"['Load', 'load']","['Load', 'load']"
Performance,". TXNetFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NETX; » TXNetFile. class TXNetFile: public TNetFile. TXNetFile. Authors: Alvise Dorigo, Fabrizio Furano; INFN Padova, 2003; Interfaced to the standalone client (XrdClient): G. Ganis, CERN. TXNetFile is an extension of TNetFile able to deal with new xrootd; server. Its new features are:; - Automatic server kind recognition (xrootd load balancer, xrootd; data server, old rootd); - Backward compatibility with old rootd server (acts as an old; TNetFile); - Fault tolerance for read/write operations (read/write timeouts; and retry); - Internal connection timeout (tunable indipendently from the OS; one) handled by threads; - handling of redirections from server; - Single TCP physical channel for multiple TXNetFile's instances; inside the same application; So, each TXNetFile object client must send messages containing; its ID (streamid). The server, of course, will respond with; messages containing the client's ID, in order to make the client; able to recognize its message by matching its streamid with that; one contained in the server's response.; - Tunable log verbosity level (0 = nothing, 3 = dump read/write; buffers too!); - Many parameters configurable via TEnv facility (see SetParm(); methods). Function Members (Methods); public:. virtual~TXNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXNetFile.html:591,load,load,591,root/html602/TXNetFile.html,https://root.cern,https://root.cern/root/html602/TXNetFile.html,1,['load'],['load']
Performance,". TXNetFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NETX; » TXNetFile. class TXNetFile: public TNetFile. TXNetFile. Authors: Alvise Dorigo, Fabrizio Furano; INFN Padova, 2003; Interfaced to the standalone client (XrdClient): G. Ganis, CERN. TXNetFile is an extension of TNetFile able to deal with new xrootd; server. Its new features are:; - Automatic server kind recognition (xrootd load balancer, xrootd; data server, old rootd); - Backward compatibility with old rootd server (acts as an old; TNetFile); - Fault tolerance for read/write operations (read/write timeouts; and retry); - Internal connection timeout (tunable indipendently from the OS; one) handled by threads; - handling of redirections from server; - Single TCP physical channel for multiple TXNetFile's instances; inside the same application; So, each TXNetFile object client must send messages containing; its ID (streamid). The server, of course, will respond with; messages containing the client's ID, in order to make the client; able to recognize its message by matching its streamid with that; one contained in the server's response.; - Tunable log verbosity level (0 = nothing, 3 = dump read/write; buffers too!); - Many parameters configurable via TEnv facility (see SetParm(); methods). Function Members (Methods); public:. TXNetFile(); TXNetFile(const char* url, Option_t* option = """", const char* fTitle = """", Int_t compress = 1, Int_t netopt = 0, Bool_t parallelopen = kFALSE, const char* logicalurl = 0); virtual~TXNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetFile.html:567,load,load,567,root/html528/TXNetFile.html,https://root.cern,https://root.cern/root/html528/TXNetFile.html,4,['load'],['load']
Performance,". TXNetFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NETX; » TXNetFile. class TXNetFile: public TNetFile. TXNetFile. Authors: Alvise Dorigo, Fabrizio Furano; INFN Padova, 2003; Interfaced to the standalone client (XrdClient): G. Ganis, CERN. TXNetFile is an extension of TNetFile able to deal with new xrootd; server. Its new features are:; - Automatic server kind recognition (xrootd load balancer, xrootd; data server, old rootd); - Backward compatibility with old rootd server (acts as an old; TNetFile); - Fault tolerance for read/write operations (read/write timeouts; and retry); - Internal connection timeout (tunable indipendently from the OS; one) handled by threads; - handling of redirections from server; - Single TCP physical channel for multiple TXNetFile's instances; inside the same application; So, each TXNetFile object client must send messages containing; its ID (streamid). The server, of course, will respond with; messages containing the client's ID, in order to make the client; able to recognize its message by matching its streamid with that; one contained in the server's response.; - Tunable log verbosity level (0 = nothing, 3 = dump read/write; buffers too!); - Many parameters configurable via TEnv facility (see SetParm(); methods). Function Members (Methods); public:. virtual~TXNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TXNetFile.html:567,load,load,567,root/html604/TXNetFile.html,https://root.cern,https://root.cern/root/html604/TXNetFile.html,1,['load'],['load']
Performance,". The concrete types are optimized; 86for element access.; 87*/; 88class TGenVectorBoolProxy : public TGenCollectionProxy {; 89 Bool_t fLastValue;; 90 ; 91public:; 92 TGenVectorBoolProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c), fLastValue(false); 93 {; 94 // Standard Constructor.; 95 }; 96 ~TGenVectorBoolProxy() override; 97 {; 98 // Standard Destructor.; 99 }; 100 void* At(UInt_t idx) override; 101 {; 102 // Return the address of the value at index 'idx'; 103 ; 104 // However we can 'take' the address of the content of std::vector<bool>.; 105 if ( fEnv && fEnv->fObject ) {; 106 auto vec = (std::vector<bool> *)(fEnv->fObject);; 107 fLastValue = (*vec)[idx];; 108 fEnv->fIdx = idx;; 109 return &fLastValue;; 110 }; 111 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 112 return nullptr;; 113 }; 114 ; 115 void DeleteItem(Bool_t force, void* ptr) const override; 116 {; 117 // Call to delete/destruct individual item; 118 if ( force && ptr ) {; 119 fVal->DeleteItem(ptr);; 120 }; 121 }; 122};; 123 ; 124//////////////////////////////////////////////////////////////////////////; 125// //; 126// class TGenBitsetProxy; 127//; 128// Local optimization class.; 129//; 130// Collection proxies get copied. On copy we switch the type of the; 131// proxy to the concrete STL type. The concrete types are optimized; 132// for element access.; 133//; 134//////////////////////////////////////////////////////////////////////////; 135class TGenBitsetProxy : public TGenCollectionProxy {; 136 ; 137public:; 138 TGenBitsetProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c); 139 {; 140 // Standard Constructor.; 141 }; 142 ~TGenBitsetProxy() override; 143 {; 144 // Standard Destructor.; 145 }; 146 void* At(UInt_t idx) override; 147 {; 148 // Return the address of the value at index 'idx'; 149 ; 150 if ( fEnv && fEnv->fObject ) {; 151 switch( idx ) {; 152 case 0:; 153 fEnv->fStart = fFirst.invoke(fEnv);; 154 fEnv->fIdx = idx;; 155 break;; 156 default:; 157 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:3795,optimiz,optimization,3795,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['optimiz'],['optimization']
Performance,". The dimensions; of the cache are automatically matched to the number of observables used; in each use context. Multiple cache in different observable may exists; simultanously if the cached p.d.f is used with multiple observable; configurations simultaneously. RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedPdf(const RooCachedPdf& other, const char* name = 0); Copy constructor. ~RooCachedPdf(); Destructor. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cachePdf) const; Update contents of cache histogram by resampling the input p.d.f. Note that; the cache is filled with normalized p.d.f values so that the RooHistPdf; that represents the cache contents can be explicitly declared as self normalized; eliminating the need for superfluous numeric calculations of unit normalization.s. void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const; Defer preferred scan order to cached pdf prefernece. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedPdf.html:42316,cache,cache,42316,root/html526/RooCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooCachedPdf.html,7,['cache'],['cache']
Performance,". The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called 'master' and the frame of the positioned volume - 'local'. If T is a transformation used for positioning volume daughters, then:; MASTER = T * LOCAL; Therefore a local-to-master conversion will be performed by using T, while a master-to-local by using its inverse. The second use case is the computation of the global transformation of a given object in the geometry. Since the geometry is built as 'volumes-inside-volumes', this global transformation represent the pile-up of all local transformations in the corresponding branch. The conversion from the global reference frame and the given object is also called master-to-local, but it is handled by the manager class. A general homogenous transformation is defined as a 4x4 matrix embedding a rotation, a translation and a scale. The advantage of this description is that each basic transformation can be represented as a homogenous matrix, composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1; Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1; Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1; where:; rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on each axis,. The disadvantage in using this approach is that computation for 4x4 matrices is expensive. Even combining two translation would become a multiplication of their corresponding matrices, which is quite an undesired effect. On the other hand, it is not a good idea to store a translation as a block of 16 numbers. We have therefore chosen to implement each basic transformation type as a class deriving from the sam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoMatrix.html:1735,perform,performed,1735,doc/master/classTGeoMatrix.html,https://root.cern,https://root.cern/doc/master/classTGeoMatrix.html,1,['perform'],['performed']
Performance,". The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 301 of file RooKeysPdf.cxx. ◆ getMaxVal(). Int_t RooKeysPdf::getMaxVal ; (; const RooArgSet & ; vars); const. overridevirtual . Advertise capability to determine maximum value of function for given set of observables. ; If no direct generator method is provided, this information will assist the accept/reject generator to operate more efficiently as it can skip the initial trial sampling phase to empirically find the function maximum ; Reimplemented from RooAbsReal.; Definition at line 348 of file RooKeysPdf.cxx. ◆ IsA(). TClass * RooKeysPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 80 of file RooKeysPdf.h. ◆ LoadDataSet(). void RooKeysPdf::LoadDataSet ; (; RooDataSet & ; data). Definition at line 148 of file RooKeysPdf.cxx. ◆ maxVal(). double RooKeysPdf::maxVal ; (; Int_t ; code); const. overridevirtual . Return maximum value for set of observables identified by code assigned in getMaxVal. ; Reimplemented from RooAbsReal.; Definition at line 354 of file RooKeysPdf.cxx. ◆ Streamer(). void RooKeysPdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooKeysPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 80 of file RooKeysPdf.h. Member Data Documentation. ◆ _asymLeft. bool RooKeysPdf::_asymLeft = false. private . Definition at line 72 of file RooKeysPdf.h. ◆ _asymRight. bool RooKeysPdf::_asymRight = false. private . Definition at line 73 of file RooKeysPdf.h. ◆ _binWidth. double RooKeysPdf::_binWidth. private . Definition at line 77 of file RooKeysPdf.h. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooKeysPdf.html:79265,Load,LoadDataSet,79265,doc/master/classRooKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRooKeysPdf.html,1,['Load'],['LoadDataSet']
Performance,". The most common change, namely where to find; 2791/// header files, will be available through the function; 2792/// TSystem::SetIncludePath().; 2793/// A good default will be provided so that a typical user session should be at; 2794/// most:; 2795/// ~~~ {.cpp}; 2796/// root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; 2797/// -I$HOME/mypackage/include"");; 2798/// root[2] .x myfunc.C++(10,20);; 2799/// ~~~; 2800/// The user may sometimes try to compile a script before it has loaded all the; 2801/// needed shared libraries. In this case we want to be helpful and output a; 2802/// list of the unresolved symbols. So if the loading of the created shared; 2803/// library fails, we will try to build a executable that contains the; 2804/// script. The linker should then output a list of missing symbols.; 2805///; 2806/// To support this we provide a TSystem::SetMakeExe() function, that sets the; 2807/// directive telling how to create an executable. The loader will need; 2808/// to be informed of all the libraries available. The information about; 2809/// the libraries that has been loaded by .L and TSystem::Load() is accessible; 2810/// to the script compiler. However, the information about; 2811/// the libraries that have been selected at link time by the application; 2812/// builder (like the root libraries for root.exe) are not available and need; 2813/// to be explicitly listed in fLinkedLibs (either by default or by a call to; 2814/// TSystem::SetLinkedLibs()).; 2815///; 2816/// To simplify customization we could also add to the .rootrc support for the; 2817/// variables; 2818/// ~~~ {.cpp}; 2819/// Unix.*.Root.IncludePath: -I$ROOTSYS/include; 2820/// WinNT.*.Root.IncludePath: -I%ROOTSYS%/include; 2821///; 2822/// Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; 2823/// WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....; 2824/// ~~~; 2825/// And also support for MakeSharedLibs() and MakeExe().; 2826///; 2827/// (the ... have to be replaced by the ac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:92524,load,loader,92524,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['loader']
Performance,". The regularisation of the unfolding is implemented via a discrete minimum-curvature condition. ; Monte Carlo inputs: . xini: true underlying spectrum (TH1D, n bins) . bini: reconstructed spectrum (TH1D, n bins) . Adet: response matrix (TH2D, nxn bins) . Consider the unfolding of a measured spectrum bdat with covariance matrix Bcov (if not passed explicitly, a diagonal covariance will be built given the errors of bdat). The corresponding spectrum in the Monte Carlo is given by bini, with the true underlying spectrum given by xini. The detector response is described by Adet, with Adet filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis. ; The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of xini and Adet. The unfolding can be performed by TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TSVDUnfoldSVD Approach to Data Unfolding.Definition TSVDUnfold.h:46; TSVDUnfold::UnfoldTH1D * Unfold(Int_t kreg)Perform the unfolding with regularisation parameter kreg.Definition TSVDUnfold.cxx:237; where kreg determines the regularisation of the unfolding. In general, overregularisation (too small kreg) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large kreg) will lead to large fluctuations in the unfolded spectrum. The optimal regularisation can be determined following guidelines in Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307] using the distribution of the |d_i| that can be obtained by tsvdunf->GetD() and/or using pseudo-experiments. ; Covariance matrices on the measured spectrum (for either the total uncertainties or individual sources of uncertainties) can be propagated to covariance matrices using the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSVDUnfold.html:1667,perform,performed,1667,doc/master/classTSVDUnfold.html,https://root.cern,https://root.cern/doc/master/classTSVDUnfold.html,1,['perform'],['performed']
Performance,". The vector classes are not loaded by default, and to run it, you will need to load libPhysics.so first:; root[] .L $ROOTSYS/lib/libPhysics.so; root[] .x TestVectors.cxx; To load the physics vector library in a ROOT application use:; gSystem->Load(""libPhysics"");; The example $ROOTSYS/test/TestVectors.cxx does not return much, especially if all went well, but when you look at the code you will find examples for many calls.; 18 The Geometry Package. The new ROOT geometry package is a tool for building, browsing, navigating and visualizing detector geometries. The code works standalone with respect to any tracking Monte-Carlo engine; therefore, it does not contain any constraints related to physics. However, the navigation features provided by the package are designed to optimize particle transport through complex geometries, working in correlation with simulation packages such as GEANT3, GEANT4 and FLUKA.; 18.1 Quick Start: Creating the “world”; This chapter will provide a detailed description on how to build valid geometries as well as the ways to optimize them. There are several components gluing together the geometrical model, but for the time being let us get used with the most basic concepts.; The basic bricks for building-up the model are called volumes.These represent the un-positioned pieces of the geometry puzzle. The difference is just that the relationship between the pieces is not defined by neighbors, but by containment. In other words, volumes are put one inside another making an in-depth hierarchy. From outside, the whole thing looks like a big pack that you can open finding out other smaller packs nicely arranged waiting to be opened at their turn. The biggest one containing all others defines the “world” of the model. We will often call this master reference system (MARS). Going on and opening our packs, we will obviously find out some empty ones, otherwise, something is very wrong… We will call these leaves (by analogy with a tree structure).; On th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:875356,optimiz,optimize,875356,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['optimiz'],['optimize']
Performance,". Therefore, the time spent by the main thread waiting for the data before processing considerably decreases. Besides the prefetching mechanisms there is also a local caching option which can be enabled by the user. Both capabilities are disabled by default and must be explicitly enabled by the user. ; Definition at line 33 of file TFilePrefetch.h. Public Member Functions;  TFilePrefetch (TFile *);  Constructor. ;  ;  ~TFilePrefetch () override;  Destructor. ;  ; void AddPendingBlock (TFPBlock *);  Safe method to add a block to the pendingList. ;  ; void AddReadBlock (TFPBlock *);  Safe method to add a block to the readList. ;  ; Bool_t BinarySearchReadList (TFPBlock *, Long64_t, Int_t, Int_t *);  Search for a requested element in a block and return the index. ;  ; Bool_t CheckBlockInCache (char *&, TFPBlock *);  Test if the block is in cache. ;  ; TFPBlock * CreateBlockObj (Long64_t *, Int_t *, Int_t);  Create a new block or recycle an old one. ;  ; char * GetBlockFromCache (const char *, Int_t);  Return a buffer from cache. ;  ; std::condition_variable & GetCondNewBlock ();  ; TFPBlock * GetPendingBlock ();  Safe method to remove a block from the pendingList. ;  ; TThread * GetThread () const;  Return reference to the consumer thread. ;  ; Long64_t GetWaitTime ();  Return the time spent wating for buffer to be read in microseconds. ;  ; TClass * IsA () const override;  ; Bool_t IsPrefetchFinished () const;  ; void ReadAsync (TFPBlock *, Bool_t &);  Read one block and insert it in prefetchBuffers list. ;  ; void ReadBlock (Long64_t *, Int_t *, Int_t);  Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. ;  ; Bool_t ReadBuffer (char *, Long64_t, Int_t);  Return a prefetched element. ;  ; void ReadListOfBlocks ();  Get blocks specified in prefetchBlocks. ;  ; void SaveBlockInCache (TFPBlock *);  Save the block content in cache. ;  ; Bool_t SetCache (const char *);  Set the path of the cache directory. ;  ; void SetFile (TFile *file, TFile::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFilePrefetch.html:1619,cache,cache,1619,doc/master/classTFilePrefetch.html,https://root.cern,https://root.cern/doc/master/classTFilePrefetch.html,1,['cache'],['cache']
Performance,". This is ok in binary classification but in in multi class classification, the ROC surface is an N dimensional shape, where N is number of classes - 1. ; Definition at line 988 of file Factory.cxx. ◆ GetROCCurveAsMultiGraph() [2/2]. TMultiGraph * TMVA::Factory::GetROCCurveAsMultiGraph ; (; TString ; datasetname, . UInt_t ; iClass, . Types::ETreeType ; type = Types::kTesting . ). Generate a collection of graphs, for all methods for a given class. ; Suitable for comparing method performance.; Argument iClass specifies the class to generate the ROC curve in a multiclass setting. It is ignored for binary classification.; NOTE: The ROC curve is 1 vs. all where the given class is considered signal and the others considered background. This is ok in binary classification but in in multi class classification, the ROC surface is an N dimensional shape, where N is number of classes - 1. ; Definition at line 1005 of file Factory.cxx. ◆ GetROCIntegral() [1/2]. Double_t TMVA::Factory::GetROCIntegral ; (; TMVA::DataLoader * ; loader, . TString ; theMethodName, . UInt_t ; iClass = 0, . Types::ETreeType ; type = Types::kTesting . ). Calculate the integral of the ROC curve, also known as the area under curve (AUC), for a given method. ; Argument iClass specifies the class to generate the ROC curve in a multiclass setting. It is ignored for binary classification. ; Definition at line 849 of file Factory.cxx. ◆ GetROCIntegral() [2/2]. Double_t TMVA::Factory::GetROCIntegral ; (; TString ; datasetname, . TString ; theMethodName, . UInt_t ; iClass = 0, . Types::ETreeType ; type = Types::kTesting . ). Calculate the integral of the ROC curve, also known as the area under curve (AUC), for a given method. ; Argument iClass specifies the class to generate the ROC curve in a multiclass setting. It is ignored for binary classification. ; Definition at line 862 of file Factory.cxx. ◆ Greetings(). void TMVA::Factory::Greetings ; (; ). private . Print welcome message. ; Options are: kLogoWelcomeMs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory.html:30982,load,loader,30982,doc/master/classTMVA_1_1Factory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory.html,1,['load'],['loader']
Performance,". WVE ownership issue here!! Caller (a RooAbsData) should take ownership of all arguments, but only does for the first one here... ; Implements RooAbsDataStore.; Definition at line 320 of file RooCompositeDataStore.cxx. ◆ append(). void RooCompositeDataStore::append ; (; RooAbsDataStore & ; other). overridevirtual . Implements RooAbsDataStore.; Definition at line 346 of file RooCompositeDataStore.cxx. ◆ attachBuffers(). void RooCompositeDataStore::attachBuffers ; (; const RooArgSet & ; extObs). overridevirtual . Implements RooAbsDataStore.; Definition at line 435 of file RooCompositeDataStore.cxx. ◆ attachCache(). void RooCompositeDataStore::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). overrideprotectedvirtual . Initialize cache of dataset: attach variables of cache ArgSet to the corresponding TTree branches. ; Implements RooAbsDataStore.; Definition at line 411 of file RooCompositeDataStore.cxx. ◆ cacheArgs(). void RooCompositeDataStore::cacheArgs ; (; const RooAbsArg * ; owner, . RooArgSet & ; varSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = false . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 384 of file RooCompositeDataStore.cxx. ◆ cacheOwner(). const RooAbsArg * RooCompositeDataStore::cacheOwner ; (; ). inlineoverridevirtual . Implements RooAbsDataStore.; Definition at line 94 of file RooCompositeDataStore.h. ◆ changeObservableName(). bool RooCompositeDataStore::changeObservableName ; (; const char * ; from, . const char * ; to . ). overridevirtual . Change name of internal observable named 'from' into 'to'. ; Implements RooAbsDataStore.; Definition at line 290 of file RooCompositeDataStore.cxx. ◆ Class(). static TClass * RooCompositeDataStore::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooCompositeDataStore::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooComposite",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCompositeDataStore.html:22437,cache,cacheArgs,22437,doc/master/classRooCompositeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooCompositeDataStore.html,1,['cache'],['cacheArgs']
Performance,". We book a Boosted Decision Tree method (BDT); ; ; # Boosted Decision Trees; if useTMVABDT:; factory.BookMethod(; loader,; TMVA.Types.kBDT,; ""BDT"",; V=False,; NTrees=400,; MinNodeSize=""2.5%"",; MaxDepth=2,; BoostType=""AdaBoost"",; AdaBoostBeta=0.5,; UseBaggedBoost=True,; BaggedSampleFraction=0.5,; SeparationType=""GiniIndex"",; nCuts=20,; ); ; ; #### Booking Deep Neural Network; ; # Here we book the DNN of TMVA. See the example TMVA_Higgs_Classification.C for a detailed description of the; # options; ; if useTMVADNN:; layoutString = ROOT.TString(; ""DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,DENSE|1|LINEAR""; ); ; # Training strategies; # one can catenate several training strings with different parameters (e.g. learning rates or regularizations; # parameters) The training string must be concatenated with the `|` delimiter; trainingString1 = ROOT.TString(; ""LearningRate=1e-3,Momentum=0.9,Repetitions=1,""; ""ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,""; ""WeightDecay=1e-4,Regularization=None,""; ""Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0.""; ) # + ""|"" + trainingString2 + ...; trainingString1 += "",MaxEpochs="" + str(max_epochs); ; # Build now the full DNN Option string; dnnMethodName = ""TMVA_DNN_CPU""; ; # use GPU if available; dnnOptions = ""CPU""; if hasGPU :; dnnOptions = ""GPU""; dnnMethodName = ""TMVA_DNN_GPU""; ; factory.BookMethod(; loader,; TMVA.Types.kDL,; dnnMethodName,; H=False,; V=True,; ErrorStrategy=""CROSSENTROPY"",; VarTransform=None,; WeightInitialization=""XAVIER"",; Layout=layoutString,; TrainingStrategy=trainingString1,; Architecture=dnnOptions; ); ; ; ### Book Convolutional Neural Network in TMVA; ; # For building a CNN one needs to define; ; # - Input Layout : number of channels (in this case = 1) | image height | image width; # - Batch Layout : batch size | number of channels | image size = (height*width); ; # Then one add Convolutional layers and MaxPool layers.; ; # - For Convolutional layer the option string has to be:; # - ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html:10372,Optimiz,Optimizer,10372,doc/master/TMVA__CNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html,1,['Optimiz'],['Optimizer']
Performance,". __device__ AFloat TMVA::DNN::Cuda::AtomicAdd ; (; AFloat * ; address, . AFloat ; val . ). ◆ AtomicAdd() [2/3]. template<> . __device__ double TMVA::DNN::Cuda::AtomicAdd ; (; double * ; address, . double ; val . ). Definition at line 34 of file Kernels.cuh. ◆ AtomicAdd() [3/3]. template<> . __device__ float TMVA::DNN::Cuda::AtomicAdd ; (; float * ; address, . float ; val . ). Definition at line 48 of file Kernels.cuh. ◆ calculateDimension(). __device__ int TMVA::DNN::Cuda::calculateDimension ; (; int ; imgDim, . int ; fltDim, . int ; padding, . int ; stride . ). Calculate the dimension of an output volume, given the sliding parameters and the input shape. ; Parameters. [in]imgDimThe size of the input tensor in a spatial dimension. ; [in]fltDimThe size of the sliding filter in the same dimension. ; [in]paddingNumber of zeroes to pad the input with. ; [in]strideNumber of pixels the kernel is sliding in each iteration. . ReturnsThe output dimension.; Note that no checks are performed to assert validity of the input parameters. We are allowed to assume them valid because those checks have already been performed prior to the invocation of the kernel. ; Definition at line 226 of file Kernels.cuh. ◆ ConstAdd(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::ConstAdd ; (; AFloat * ; A, . AFloat ; beta, . int ; m, . int ; n . ). Definition at line 335 of file Kernels.cuh. ◆ ConstMult(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::ConstMult ; (; AFloat * ; A, . AFloat ; beta, . int ; m, . int ; n . ). Definition at line 349 of file Kernels.cuh. ◆ CrossEntropy(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::CrossEntropy ; (; AFloat * ; result, . const AFloat * ; Y, . const AFloat * ; output, . const AFloat * ; weights, . int ; m, . int ; n . ). Definition at line 800 of file Kernels.cuh. ◆ CrossEntropyGradients(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::CrossEntropyGradients ; (; AFloat * ; dY, . const AFl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMVA_1_1DNN_1_1Cuda.html:10679,perform,performed,10679,doc/master/namespaceTMVA_1_1DNN_1_1Cuda.html,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1DNN_1_1Cuda.html,1,['perform'],['performed']
Performance,". class RooSimWSTool::BuildConfig. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'maste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSimWSTool__BuildConfig.html:1279,perform,performed,1279,root/html534/RooSimWSTool__BuildConfig.html,https://root.cern,https://root.cern/root/html534/RooSimWSTool__BuildConfig.html,3,['perform'],['performed']
Performance,". const RooArgSet * ; nset . ); const. protected . Update the coefficient values in the given cache element: calculate new remainder fraction, normalize fractions obtained from extended ML terms to unity, and multiply the various range and dimensional corrections needed in the current use context. ; Definition at line 333 of file RooAddModel.cxx. Friends And Related Symbol Documentation. ◆ RooAddGenContext. friend class RooAddGenContext. friend . Definition at line 89 of file RooAddModel.h. Member Data Documentation. ◆ _allExtendable. bool RooAddModel::_allExtendable = false. protected . Flag indicating if all PDF components are extendable. ; Definition at line 123 of file RooAddModel.h. ◆ _codeReg. RooAICRegistry RooAddModel::_codeReg = 10. mutableprotected . ! Registry of component analytical integration codes ; Definition at line 116 of file RooAddModel.h. ◆ _coefCache. std::vector<double> RooAddModel::_coefCache. mutableprotected . ! Transient cache with transformed values of coefficients ; Definition at line 99 of file RooAddModel.h. ◆ _coefErrCount. Int_t RooAddModel::_coefErrCount. mutableprotected . ! Coefficient error counter ; Definition at line 125 of file RooAddModel.h. ◆ _coefList. RooListProxy RooAddModel::_coefList. protected . List of coefficients. ; Definition at line 119 of file RooAddModel.h. ◆ _haveLastCoef. bool RooAddModel::_haveLastCoef = false. protected . Flag indicating if last PDFs coefficient was supplied in the constructor. ; Definition at line 122 of file RooAddModel.h. ◆ _intCacheMgr. RooObjCacheManager RooAddModel::_intCacheMgr. mutableprotected . ! Manager of cache with integrals ; Definition at line 114 of file RooAddModel.h. ◆ _ownedComps. RooArgSet RooAddModel::_ownedComps. mutableprotected . ! Owned components ; Definition at line 127 of file RooAddModel.h. ◆ _pdfList. RooListProxy RooAddModel::_pdfList. protected . List of component PDFs. ; Definition at line 118 of file RooAddModel.h. ◆ _projCacheMgr. RooObjCacheManager RooAddMo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:91524,cache,cache,91524,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['cache'],['cache']
Performance,". enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPyROOTApplication(const char* acn, Int_t* argc, char** argv, Bool_t bLoadLibs = kTRUE); Create a TApplication derived for use with interactive ROOT from python. A; set of standard, often used libs is loaded if bLoadLibs is true (default). Bool_t CreatePyROOTApplication(Bool_t bLoadLibs = kTRUE); Create a TPyROOTApplication. Returns false if gApplication is not null. Bool_t InitROOTGlobals(); Setup the basic ROOT globals gBenchmark, gStyle, gProgname, if not already; set. Always returns true. Bool_t InitCINTMessageCallback(); Install CINT message callback which will turn CINT error message into; python exceptions. Always returns true. Bool_t InitROOTMessageCallback(); Install ROOT message handler which will turn ROOT error message into; python exceptions. Always returns true. virtual ~TPyROOTApplication(); { }. » Last changed: Thu Sep 23 19:55:51 2010 » Last generated: 2010-09-23 19:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/PyROOT__TPyROOTApplication.html:13242,load,loaded,13242,root/html528/PyROOT__TPyROOTApplication.html,https://root.cern,https://root.cern/root/html528/PyROOT__TPyROOTApplication.html,1,['load'],['loaded']
Performance,". enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPyROOTApplication(const char* acn, Int_t* argc, char** argv, Bool_t bLoadLibs = kTRUE); Create a TApplication derived for use with interactive ROOT from python. A; set of standard, often used libs is loaded if bLoadLibs is true (default). Bool_t CreatePyROOTApplication(Bool_t bLoadLibs = kTRUE); Create a TPyROOTApplication. Returns false if gApplication is not null. Bool_t InitROOTGlobals(); Setup the basic ROOT globals gBenchmark, gStyle, gProgname, if not already; set. Always returns true. Bool_t InitCINTMessageCallback(); Install CINT message callback which will turn CINT error message into; python exceptions. Always returns true. Bool_t InitROOTMessageCallback(); Install ROOT message handler which will turn ROOT error message into; python exceptions. Always returns true. virtual ~TPyROOTApplication(); { }. » Last changed: Tue Mar 17 20:53:08 2015 » Last generated: 2015-03-17 20:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/PyROOT__TPyROOTApplication.html:13412,load,loaded,13412,root/html534/PyROOT__TPyROOTApplication.html,https://root.cern,https://root.cern/root/html534/PyROOT__TPyROOTApplication.html,1,['load'],['loaded']
Performance,". inlineoverridevirtual . Reimplemented from RooAbsNumGenerator.; Definition at line 46 of file RooFoamGenerator.h. ◆ canSampleConditional(). bool RooFoamGenerator::canSampleConditional ; (; ); const. inlineoverridevirtual . Reimplemented from RooAbsNumGenerator.; Definition at line 45 of file RooFoamGenerator.h. ◆ clone(). RooAbsNumGenerator * RooFoamGenerator::clone ; (; const RooAbsReal & ; func, . const RooArgSet & ; genVars, . const RooArgSet & ; , . const RooNumGenConfig & ; config, . bool ; verbose = false, . const RooAbsReal * ; maxFuncVal = nullptr . ); const. inlineoverridevirtual . Implements RooAbsNumGenerator.; Definition at line 36 of file RooFoamGenerator.h. ◆ engine(). TFoam & RooFoamGenerator::engine ; (; ). inline . Definition at line 43 of file RooFoamGenerator.h. ◆ generateEvent(). const RooArgSet * RooFoamGenerator::generateEvent ; (; UInt_t ; remaining, . double & ; resampleRatio . ). overridevirtual . are we actually generating anything? (the cache always contains at least our function value) ; Implements RooAbsNumGenerator.; Definition at line 140 of file RooFoamGenerator.cxx. ◆ generatorName(). std::string const & RooFoamGenerator::generatorName ; (; ); const. overridevirtual . Return unique name of generator implementation. ; Implements RooAbsNumGenerator.; Definition at line 158 of file RooFoamGenerator.cxx. ◆ registerSampler(). void RooFoamGenerator::registerSampler ; (; RooNumGenFactory & ; fact). staticprotected . Register RooIntegrator1D, is parameters and capabilities with RooNumIntFactory. ; Definition at line 86 of file RooFoamGenerator.cxx. Friends And Related Symbol Documentation. ◆ RooNumGenFactory. friend class RooNumGenFactory. friend . Definition at line 52 of file RooFoamGenerator.h. Member Data Documentation. ◆ _binding. std::unique_ptr<TFoamIntegrand> RooFoamGenerator::_binding. protected . Binding of RooAbsReal to TFoam function interface. ; Definition at line 55 of file RooFoamGenerator.h. ◆ _range. std::vector<double> Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFoamGenerator.html:5566,cache,cache,5566,doc/master/classRooFoamGenerator.html,https://root.cern,https://root.cern/doc/master/classRooFoamGenerator.html,1,['cache'],['cache']
Performance,". inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 162 of file RooMomentMorphFuncND.h. ◆ clone(). TObject * RooMomentMorphFuncND::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 108 of file RooMomentMorphFuncND.h. ◆ DeclFileName(). static const char * RooMomentMorphFuncND::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 162 of file RooMomentMorphFuncND.h. ◆ evaluate(). double RooMomentMorphFuncND::evaluate ; (; ); const. overridevirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 533 of file RooMomentMorphFuncND.cxx. ◆ findShape(). void RooMomentMorphFuncND::findShape ; (; const std::vector< double > & ; x); const. protected . Definition at line 712 of file RooMomentMorphFuncND.cxx. ◆ getCache(). RooMomentMorphFuncND::CacheElem * RooMomentMorphFuncND::getCache ; (; const RooArgSet * ; nset); const. protected . Definition at line 351 of file RooMomentMorphFuncND.cxx. ◆ getValV(). double RooMomentMorphFuncND::getValV ; (; const RooArgSet * ; nset = nullptr); const. overridevirtual . Return value of object. ; If the cache is clean, return the cached value, otherwise recalculate on the fly and refill the cache ; Reimplemented from RooAbsReal.; Definition at line 514 of file RooMomentMorphFuncND.cxx. ◆ initialize(). void RooMomentMorphFuncND::initialize ; (; ). protected . Definition at line 200 of file RooMomentMorphFuncND.cxx. ◆ IsA(). TClass * RooMomentMorphFuncND::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsReal.; Definition at line 162 of file RooMomentMorphFuncND.h. ◆ setBinIntegrator(). bool RooMomentMorphFuncND::setBinIntegrator ; (; RooArgSet & ; allVars). Definition at line 795 of file RooMomentMorphFuncND.cxx. ◆ setMode(). void RooMomentMorphFuncND::setMode",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMomentMorphFuncND.html:64757,Cache,CacheElem,64757,doc/master/classRooMomentMorphFuncND.html,https://root.cern,https://root.cern/doc/master/classRooMomentMorphFuncND.html,1,['Cache'],['CacheElem']
Performance,". private:. voidInitTreePruningMetaData(TMVA::DecisionTreeNode* n); TMVA::MsgLogger&Log() const; voidOptimize(TMVA::DecisionTree* dt, Double_t weights). Data Members; private:. TMVA::MsgLogger*fLogger! output stream to save logging information; Int_tfOptimalK! the optimal index of the prune sequence; vector<TMVA::DecisionTreeNode*,allocator<TMVA::DecisionTreeNode*> >fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Double_t>fPruneStrengthList! map of alpha -> pruning index; vector<Double_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::SeparationBase*fQualityIndexTool! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CostComplexityPruneTool( SeparationBase* qualityIndex ); the constructor for the cost complexity prunig. ~CostComplexityPruneTool(); the destructor for the cost complexity prunig. CalculatePruningInfo(TMVA::DecisionTree* dt, const vector<TMVA::Event*,allocator<TMVA::Event*> >* testEvents = NULL, Bool_t isAutomatic = kFALSE). void InitTreePruningMetaData(TMVA::DecisionTreeNode* n); initialise ""meta data"" for the pruning, like the ""costcomplexity"", the; critical alpha, the minimal alpha down the tree, etc... for each node!!. void Optimize(TMVA::DecisionTree* dt, Double_t weights); after the critical alpha values (at which the corresponding nodes would; be pruned away) had been established in the ""InitMetaData"" we need now:; automatic pruning:; find the value of ""alpha"" for which the test sample gives minimal error,; on the tree with all nodes pruned that have alpha_critital < alpha,; fixed parameter pruning. CostComplexityPruneTool( SeparationBase* qualityIndex = NULL ). » Last changed: Fri Nov 26 14:26:56 2010 » Last generated: 2010-11-26 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__CostComplexityPruneTool.html:2178,Optimiz,Optimize,2178,root/html528/TMVA__CostComplexityPruneTool.html,https://root.cern,https://root.cern/root/html528/TMVA__CostComplexityPruneTool.html,1,['Optimiz'],['Optimize']
Performance,". protected:. TStringAccessHeader(TString& buf, const char* name, const char* value = 0, Bool_t doing_set = kFALSE); TStringCountHeader(const TString& buf, Int_t number = -1111) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Bool_tIsBinData() const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. void*fBinData! binary data, assigned with http call; Long_tfBinDataLength! length of binary data; TConditionfCond! condition used to wait for processing; TStringfContent! text content (if any); TStringfContentType! type of content; TStringfFileName! file name; TStringfHeader! response header like ContentEncoding, Cache-Control and so on; TStringfMethod! request method like GET or POST; TStringfPathName! item path; void*fPostData! binary data received with post request; Long_tfPostDataLength! length of binary data; TStringfQuery! additional arguments; TStringfRequestHeader! complete header, provided with request; TStringfTopName! top item name; TStringfUserName! authenticated user name (if any); Int_tfZipping! indicate if content should be zipped. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THttpCallArg(); constructor. ~THttpCallArg(); destructor. TString AccessHeader(TString& buf, const char* name, const char* value = 0, Bool_t doing_set = kFALSE); method used to get or set http header in the string buffer; Header has following format:; field1 : value1\r\n; field2 : value2\r\n; Such format corresponds to header format in HTTP requests. TString CountHeader(const TString& buf, Int_t number = -1111) const; method used to counter number of headers or returns name of specified header. void SetPostData(void* data, L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THttpCallArg.html:7178,Cache,Cache-Control,7178,root/html534/THttpCallArg.html,https://root.cern,https://root.cern/root/html534/THttpCallArg.html,1,['Cache'],['Cache-Control']
Performance,". strong . EnumeratorkGauss ; kUniform ; kIdentity ; kZero ; kGlorotNormal ; kGlorotUniform . Definition at line 72 of file Functions.h. ◆ ELossFunction. enum class TMVA::DNN::ELossFunction. strong . Enum that represents objective functions for the net, i.e. ; functions that take the output from the last layer in the net together with the truths and return the objective function values that is to be minimized in the training process. . EnumeratorkCrossEntropy ; kMeanSquaredError ; kSoftmaxCrossEntropy . Definition at line 56 of file Functions.h. ◆ EnumFunction. enum class TMVA::DNN::EnumFunction. strong . EnumeratorZERO ; LINEAR ; TANH ; RELU ; SYMMRELU ; TANHSHIFT ; SIGMOID ; SOFTSIGN ; GAUSS ; GAUSSCOMPLEMENT . Definition at line 156 of file NeuralNet.h. ◆ EnumRegularization. enum class TMVA::DNN::EnumRegularization. strong . EnumeratorNONE ; L1 ; L2 ; L1MAX . Definition at line 172 of file NeuralNet.h. ◆ EOptimizer. enum class TMVA::DNN::EOptimizer. strong . Enum representing the optimizer used for training. . EnumeratorkSGD ; kAdam ; kAdagrad ; kRMSProp ; kAdadelta . Definition at line 82 of file Functions.h. ◆ EOutputFunction. enum class TMVA::DNN::EOutputFunction. strong . Enum that represents output functions. . EnumeratorkIdentity ; kSigmoid ; kSoftmax . Definition at line 45 of file Functions.h. ◆ ERegularization. enum class TMVA::DNN::ERegularization. strong . Enum representing the regularization type applied for a given layer. . EnumeratorkNone ; kL1 ; kL2 . Definition at line 64 of file Functions.h. ◆ MinimizerType. enum TMVA::DNN::MinimizerType. < list all the minimizer types . EnumeratorfSteepest SGD. . Definition at line 320 of file NeuralNet.h. ◆ ModeErrorFunction. enum class TMVA::DNN::ModeErrorFunction. strong . error functions to be chosen from . EnumeratorSUMOFSQUARES ; CROSSENTROPY ; CROSSENTROPY_MUTUALEXCLUSIVE . Definition at line 1038 of file NeuralNet.h. ◆ ModeOutput. enum class TMVA::DNN::ModeOutput. strong . EnumeratorFETCH . Definition at ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html:21188,optimiz,optimizer,21188,doc/master/namespaceTMVA_1_1DNN.html,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html,2,['optimiz'],['optimizer']
Performance,". virtual . If the formula is for linear fitting, change the title to normal and fill the LinearParts array. ; Definition at line 3306 of file TFormula_v5.cxx. ◆ SetAction(). void ROOT::v5::TFormula::SetAction ; (; Int_t ; code, . Int_t ; value, . Int_t ; param = 0 . ). inlineprotected . Definition at line 107 of file TFormula.h. ◆ SetActionOptimized(). void ROOT::v5::TFormula::SetActionOptimized ; (; Int_t ; code, . Int_t ; value, . Int_t ; param = 0 . ). inlineprotected . Definition at line 115 of file TFormula.h. ◆ SetMaxima(). void TFormula::SetMaxima ; (; Int_t ; maxop = 1000, . Int_t ; maxpar = 1000, . Int_t ; maxconst = 1000 . ). static . static function to set the maximum value of 3 parameters . maxop : maximum number of operations; maxpar : maximum number of parameters; maxconst : maximum number of constants. None of these parameters cannot be less than 10 (default is 1000) call this function to increase one or all maxima when processing very complex formula, eg TFormula::SetMaxima(100000,1000,1000000); If you process many functions with a small number of operations/parameters you may gain some memory and performance by decreasing these values. ; Definition at line 4527 of file TFormula_v5.cxx. ◆ SetNumber(). virtual void ROOT::v5::TFormula::SetNumber ; (; Int_t ; number). inlinevirtual . Definition at line 251 of file TFormula.h. ◆ SetParameter() [1/2]. void TFormula::SetParameter ; (; const char * ; name, . Double_t ; parvalue . ). virtual . Initialize parameter number ipar. ; Definition at line 3375 of file TFormula_v5.cxx. ◆ SetParameter() [2/2]. void TFormula::SetParameter ; (; Int_t ; ipar, . Double_t ; parvalue . ). virtual . Initialize parameter number ipar. ; Definition at line 3386 of file TFormula_v5.cxx. ◆ SetParameters() [1/2]. void TFormula::SetParameters ; (; const Double_t * ; params). virtual . Initialize array of all parameters. ; See also the next function with the same name. ; Definition at line 3397 of file TFormula_v5.cxx. ◆ SetParamet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1v5_1_1TFormula.html:49410,perform,performance,49410,doc/master/classROOT_1_1v5_1_1TFormula.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1v5_1_1TFormula.html,1,['perform'],['performance']
Performance,". virtual double RooAbsDataStore::sumEntries ; (; ); const. inlinevirtual . Reimplemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore.; Definition at line 96 of file RooAbsDataStore.h. ◆ tree(). virtual const TTree * RooAbsDataStore::tree ; (; ); const. inlinevirtual . Reimplemented in RooTreeDataStore.; Definition at line 141 of file RooAbsDataStore.h. ◆ weight() [1/2]. virtual double RooAbsDataStore::weight ; (; ); const. pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, RooVectorDataStore, RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ weight() [2/2]. double RooAbsDataStore::weight ; (; Int_t ; index); const. inline . Definition at line 66 of file RooAbsDataStore.h. ◆ weightError() [1/2]. virtual void RooAbsDataStore::weightError ; (; double & ; lo, . double & ; hi, . RooAbsData::ErrorType ; etype = RooAbsData::Poisson . ); const. pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ weightError() [2/2]. virtual double RooAbsDataStore::weightError ; (; RooAbsData::ErrorType ; etype = RooAbsData::Poisson); const. pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. Member Data Documentation. ◆ _cachedVars. RooArgSet RooAbsDataStore::_cachedVars. protected . Definition at line 152 of file RooAbsDataStore.h. ◆ _doDirtyProp. bool RooAbsDataStore::_doDirtyProp = true. protected . Switch do (de)activate dirty state propagation when loading a data point. ; Definition at line 154 of file RooAbsDataStore.h. ◆ _vars. RooArgSet RooAbsDataStore::_vars. protected . Definition at line 151 of file RooAbsDataStore.h. Libraries for RooAbsDataStore:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooAbsDataStore.h; roofit/roofitcore/src/RooAbsDataStore.cxx. RooAbsDataStore. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:40 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsDataStore.html:30003,load,loading,30003,doc/master/classRooAbsDataStore.html,https://root.cern,https://root.cern/doc/master/classRooAbsDataStore.html,1,['load'],['loading']
Performance,". virtual~SeparationBase(); static TClass*Class(); const TString&GetName(); virtual Double_tGetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::SeparationBase&operator=(const TMVA::SeparationBase&); TMVA::SeparationBaseSeparationBase(); TMVA::SeparationBaseSeparationBase(const TMVA::SeparationBase& s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation; Double_tfPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SeparationBase(); default constructor. SeparationBase(const TMVA::SeparationBase& s); copy constructor. Double_t GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system (making the best selection. virtual ~SeparationBase(); destructor. {}. Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Return the separation index (a measure for ""purity"" of the sample""). const TString& GetName(); Return the name of the concrete Index implementation. { return fName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__SeparationBase.html:1786,optimiz,optimized,1786,root/html604/TMVA__SeparationBase.html,https://root.cern,https://root.cern/root/html604/TMVA__SeparationBase.html,1,['optimiz'],['optimized']
Performance,". virtual~SeparationBase(); static TClass*Class(); const TString&GetName(); virtual Double_tGetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::SeparationBase&operator=(const TMVA::SeparationBase&); TMVA::SeparationBaseSeparationBase(); TMVA::SeparationBaseSeparationBase(const TMVA::SeparationBase& s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation; Double_tfPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SeparationBase(); default constructor. SeparationBase(const TMVA::SeparationBase& s); copy constructor. Double_t GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system (making the best selection. virtual ~SeparationBase(); destructor. {}. Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Return the separation index (a measure for ""purity"" of the sample""). const TString& GetName(); Return the name of the concrete Index implementation. { return fName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__SeparationBase.html:1778,optimiz,optimized,1778,root/html602/TMVA__SeparationBase.html,https://root.cern,https://root.cern/root/html602/TMVA__SeparationBase.html,1,['optimiz'],['optimized']
Performance,". void LineToBounds(TEveVectorD& p); Propagatate neutral particle with momentum p to bounds. Bool_t HelixIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); Intersect helix with a plane. Current position and argument p define; the helix. Bool_t LineIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); Intersect line with a plane. Current position and argument p define; the line. Bool_t IntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); Find intersection of currently propagated track with a plane.; Current track position is used as starting point. Args:; p - track momentum to use for extrapolation; point - a point on a plane; normal - normal of the plane; itsect - output, point of intersection; Returns:; kFALSE if intersection can not be found, kTRUE otherwise. void FillPointSet(TEvePointSet* ps) const; Reset ps and populate it with points in propagation cache. void RebuildTracks(); Rebuild all tracks using this render-style. void SetMagField(Double_t bX, Double_t bY, Double_t bZ); Set constant magnetic field and rebuild tracks. void SetMagFieldObj(TEveMagField* field, Bool_t own_field = kTRUE); Set constant magnetic field and rebuild tracks. void PrintMagField(Double_t x, Double_t y, Double_t z) const. void SetMaxR(Double_t x); Set maximum radius and rebuild tracks. void SetMaxZ(Double_t x); Set maximum z and rebuild tracks. void SetMaxOrbs(Double_t x); Set maximum number of orbits and rebuild tracks. void SetMinAng(Double_t x); Set maximum step angle and rebuild tracks.; WARNING -- this method / variable was mis-named. Double_t GetMinAng() const; Get maximum step angle.; WARNING -- this method / variable was mis-named. void SetMaxAng(Double_t x); Set maximum step angle and rebuild tracks. void SetMaxStep(Double_t x); Set maximum step-size and rebuild tracks. void SetDelta(Double_t x); Set ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveTrackPropagator.html:28108,cache,cache,28108,root/html530/TEveTrackPropagator.html,https://root.cern,https://root.cern/root/html530/TEveTrackPropagator.html,2,['cache'],['cache']
Performance,". void Mixture(Int_t& kmat, const char* name, Float_t* a, Float_t* z, Double_t dens, Int_t nlmat, Float_t* wmat); The same as previous but in double precision; Define mixture or compound; with a number kmat composed by the basic nlmat materials defined; by arrays a, z and wmat. If nlmat > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then wmat contains the number of atoms; of a given kind into the molecule of the compound.; In this case, wmat in output is changed to relative; weights. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf); The same as previous but in double precision; Define a medium.; kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field:; - ifield = 0 if no magnetic field;; - ifield = -1 if user decision in guswim;; - ifield = 1 if tracking performed with g3rkuta;; - ifield = 2 if tracking performed with g3helix;; - ifield = 3 if tracking performed with g3helx3.; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm); ubuf pointer to an array of user words; nbuf number of user words. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ); The same as previous but in double precision; Define a rotation matrix; krot rotation matrix number assigned; thetaX polar angle for axis X; phiX azimuthal angle for axis X; thetaY polar angle for axis Y; phiY azimuthal angle for axis Y; thetaZ polar angle for axis Z; phiZ azimuthal angle for axis Z. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np); C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMC.html:18819,perform,performed,18819,root/html528/TVirtualMC.html,https://root.cern,https://root.cern/root/html528/TVirtualMC.html,18,['perform'],['performed']
Performance,". void SetCanSplit(Int_t splitmode); Set the splitability of this class:; -1: Use the default calculation; 0: Disallow splitting; 1: Always allow splitting. void SetClassVersion(Version_t version); Private function. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassTable.cxx. Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the; I/O should use the TClass checksum to distinguish the layout of the class. TVirtualStreamerInfo* DetermineCurrentStreamerInfo(); Determine and set pointer to current TVirtualStreamerInfo. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. TClass * LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:51640,Load,Load,51640,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,4,['Load'],['Load']
Performance,". void SetCanSplit(Int_t splitmode); Set the splitability of this class:; -1: Use the default calculation; 0: Disallow splitting; 1: Always allow splitting. void SetClassVersion(Version_t version); Private function. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassTable.cxx. Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the; I/O should use the TClass checksum to distinguish the layout of the class. TVirtualStreamerInfo* DetermineCurrentStreamerInfo(); Determine and set pointer to current TVirtualStreamerInfo. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStreamerInfo. Int_t Size() const; Return size of object of this class. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClass.html:39679,Load,Load,39679,root/html534/TClass.html,https://root.cern,https://root.cern/root/html534/TClass.html,2,['Load'],['Load']
Performance,". void SetPlotEt(Bool_t x); Set E/Et plot. Float_t GetMaxVal() const. void SetPhiWithRng(Float_t x, Float_t r); Set phi range. Float_t GetTransitionTheta() const; Get transition angle between barrel and end-cap cells, assuming fEndCapPosF = -fEndCapPosB. Float_t GetTransitionEta() const; Get transition eta between barrel and end-cap cells, assuming fEndCapPosF = -fEndCapPosB. Float_t GetTransitionThetaForward() const; Get transition angle between barrel and forward end-cap cells. Float_t GetTransitionEtaForward() const; Get transition eta between barrel and forward end-cap cells. Float_t GetTransitionThetaBackward() const; Get transition angle between barrel and backward end-cap cells. Float_t GetTransitionEtaBackward() const; Get transition eta between barrel and backward end-cap cells. void SetData(TEveCaloData* d); Set calorimeter event data. void DataChanged(); Update setting and cache on data changed.; Called from TEvecaloData::BroadcastDataChange(). Bool_t AssertCellIdCache() const; Assert cell id cache is ok.; Returns true if the cache has been updated. Bool_t CellInEtaPhiRng(TEveCaloData::CellData_t& ) const; Returns true if given cell is in the ceta phi range. void AssignCaloVizParameters(TEveCaloViz* cv); Assign paramteres from given model. void SetPalette(TEveRGBAPalette* p); Set TEveRGBAPalette object pointer. Float_t GetValToHeight() const; Get transformation factor from E/Et to height. TEveRGBAPalette* AssertPalette(); Make sure the TEveRGBAPalette pointer is not null.; If it is not set, a new one is instantiated and the range is set; to current min/max signal values. void Paint(Option_t* option = """"); Paint this object. Only direct rendering is supported. TClass* ProjectedClass(const TEveProjection* p) const; Virtual from TEveProjectable, returns TEveCalo2D class. void SetupColorHeight(Float_t value, Int_t slice, Float_t& height) const; Set color and height for a given value and slice using slice color or TEveRGBAPalette. TEveCaloViz& operator=(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveCaloViz.html:24356,cache,cache,24356,root/html534/TEveCaloViz.html,https://root.cern,https://root.cern/root/html534/TEveCaloViz.html,1,['cache'],['cache']
Performance,". void SetPlotEt(Bool_t x); Set E/Et plot. Float_t GetMaxVal() const. void SetPhiWithRng(Float_t x, Float_t r); Set phi range. Float_t GetTransitionTheta() const; Get transition angle between barrel and end-cap cells, assuming fEndCapPosF = -fEndCapPosB. Float_t GetTransitionEta() const; Get transition eta between barrel and end-cap cells, assuming fEndCapPosF = -fEndCapPosB. Float_t GetTransitionThetaForward() const; Get transition angle between barrel and forward end-cap cells. Float_t GetTransitionEtaForward() const; Get transition eta between barrel and forward end-cap cells. Float_t GetTransitionThetaBackward() const; Get transition angle between barrel and backward end-cap cells. Float_t GetTransitionEtaBackward() const; Get transition eta between barrel and backward end-cap cells. void SetData(TEveCaloData* d); Set calorimeter event data. void DataChanged(); Update setting and cache on data changed.; Called from TEvecaloData::BroadcastDataChange(). Bool_t AssertCellIdCache() const; Assert cell id cache is ok.; Returns true if the cache has been updated. Bool_t CellInEtaPhiRng(TEveCaloData::CellData_t& ) const; Returns true if given cell is in the ceta phi range. void AssignCaloVizParameters(TEveCaloViz* cv); Assign paramteres from given model. void SetPalette(TEveRGBAPalette* p); Set TEveRGBAPalette object pointer. Float_t GetValToHeight() const; Get transformation factor from E/Et to height. TEveRGBAPalette* AssertPalette(); Make sure the TEveRGBAPalette pointer is not null.; If it is not set, a new one is instantiated and the range is set; to current min/max signal values. void Paint(Option_t* option = """"); Paint this object. Only direct rendering is supported. TClass* ProjectedClass(const TEveProjection* p) const; Virtual from TEveProjectable, returns TEveCalo2D class. void SetupColorHeight(Float_t value, Int_t slice, Float_t& height) const; Set color and height for a given value and slice using slice color or TEveRGBAPalette. TEveCaloViz(const TEveCaloViz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveCaloViz.html:25506,cache,cache,25506,root/html602/TEveCaloViz.html,https://root.cern,https://root.cern/root/html602/TEveCaloViz.html,2,['cache'],['cache']
Performance,". void SetRTLD_LAZY() const; {;}. void SetTempLevel(int ) const; {;}. int UnloadFile(const char* ) const; {return 0;}. TInterpreterValue * CreateTemporary(); { return 0; }. EReturnType MethodCallReturnType(TFunction* func) const; core/meta helper functions. ULong64_t GetInterpreterStateMarker() const. DeclId_t GetDeclId(CallFunc_t* info) const. DeclId_t GetDeclId(ClassInfo_t* info) const. DeclId_t GetDeclId(DataMemberInfo_t* info) const. DeclId_t GetDeclId(FuncTempInfo_t* info) const. DeclId_t GetDeclId(MethodInfo_t* info) const. DeclId_t GetDeclId(TypedefInfo_t* info) const. void SetDeclAttr(TInterpreter::DeclId_t , const char* ). DeclId_t GetDataMember(ClassInfo_t* cl, const char* name) const. DeclId_t GetDataMemberAtAddr(const void* addr) const. DeclId_t GetDataMemberWithValue(const void* ptrvalue) const. DeclId_t GetEnum(TClass* cl, const char* name) const. TEnum* CreateEnum(void* VD, TClass* cl) const. void UpdateEnumConstants(TEnum* enumObj, TClass* cl) const. void LoadEnums(TListOfEnums& cl) const. DeclId_t GetFunction(ClassInfo_t* cl, const char* funcname). DeclId_t GetFunctionWithPrototype(ClassInfo_t* cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch). DeclId_t GetFunctionWithValues(ClassInfo_t* cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE). DeclId_t GetFunctionTemplate(ClassInfo_t* cl, const char* funcname). void GetFunctionOverloads(ClassInfo_t* cl, const char* funcname, vector<TInterpreter::DeclId_t>& res) const. void LoadFunctionTemplates(TClass* cl) const. void CallFunc_Delete(CallFunc_t* ) const; CallFunc interface. {;}. void CallFunc_Exec(CallFunc_t* , void* ) const; {;}. void CallFunc_Exec(CallFunc_t* , void* , TInterpreterValue& ) const; {;}. void CallFunc_ExecWithReturn(CallFunc_t* , void* , void* ) const; {;}. void CallFunc_ExecWithArgsAndReturn(CallFunc_t* , void* , const void*[] = 0, int = 0, void* = 0) const; {}. Long_t CallFunc_ExecInt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TInterpreter.html:32187,Load,LoadEnums,32187,root/html602/TInterpreter.html,https://root.cern,https://root.cern/root/html602/TInterpreter.html,2,['Load'],['LoadEnums']
Performance,". void Show(Long64_t entry = -1, Int_t lenmax = 20); Print values of all active leaves for entry. if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. void StartViewer(); Start the TTreeViewer on this tree. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. void StopCacheLearningPhase(); stop the cache learning phase. void Streamer(TBuffer& ); Stream a class object. Int_t UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Unbinned fit of one or more variable(s) from a tree. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parameters, you can do:; func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; func->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100. For the fit to be meaningful, the function must be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectively just maximize the; area. It is mandatory to have a normalization variable; which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:138281,Perform,Perform,138281,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,2,['Perform'],['Perform']
Performance,". void TColor::CreateColorsCircle ; (; Int_t ; offset, . const char * ; name, . UChar_t * ; rgb . ). static . Create the ""circle"" colors in the color wheel. ; Definition at line 1378 of file TColor.cxx. ◆ CreateColorsGray(). void TColor::CreateColorsGray ; (; ). static . Create the Gray scale colors in the Color Wheel. ; Definition at line 1362 of file TColor.cxx. ◆ CreateColorsRectangle(). void TColor::CreateColorsRectangle ; (; Int_t ; offset, . const char * ; name, . UChar_t * ; rgb . ). static . Create the ""rectangular"" colors in the color wheel. ; Definition at line 1397 of file TColor.cxx. ◆ CreateColorTableFromFile(). Int_t TColor::CreateColorTableFromFile ; (; TString ; fileName, . Float_t ; alpha = 1. . ). static . Static function creating a color palette based on an input text file. ; Every color in the file will take the same amount of space in the palette.; See alsohttps://doi.org/10.1038/s41467-020-19160-7 ; NoteThis function is designed to load into ROOT the colour-vision deficiency friendly and perceptually uniform colour maps specially designed in https://doi.org/10.5281/zenodo.4491293, namely the .txt files stored in the subfolders of ScientificColourMaps7.zip, e.g. batlow/batlow.txt; Parameters. fileNameName of a .txt file (ASCII) containing three floats per line, separated by spaces, namely the r g b fractions of the color, each value being in the range [0,1]. ; alphathe global opacity for all colors within this palette . Returnsa positive value on success and -1 on error. ; AuthorFernando Hueso-González ; Definition at line 2624 of file TColor.cxx. ◆ CreateColorWheel(). void TColor::CreateColorWheel ; (; ). static . Static function steering the creation of all colors in the color wheel. ; Definition at line 1416 of file TColor.cxx. ◆ CreateGradientColorTable(). Int_t TColor::CreateGradientColorTable ; (; UInt_t ; Number, . Double_t * ; Stops, . Double_t * ; Red, . Double_t * ; Green, . Double_t * ; Blue, . UInt_t ; NColors, . Float_t ; alpha = 1.,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTColor.html:46728,load,load,46728,doc/master/classTColor.html,https://root.cern,https://root.cern/doc/master/classTColor.html,1,['load'],['load']
Performance,". void TMinuit::mnmatu ; (; Int_t ; kode). virtual . Prints the covariance matrix v when KODE=1. ; always prints the global correlations, and calculates and prints the individual correlation coefficients ; Definition at line 4968 of file TMinuit.cxx. ◆ mnmigr(). void TMinuit::mnmigr ; (; ). virtual . Performs a local function minimization. ; Performs a local function minimization using basically the method of Davidon-Fletcher-Powell as modified by Fletcher; ref. – Fletcher, Comp.J. 13,317 (1970) ""switching method"" ; Definition at line 5048 of file TMinuit.cxx. ◆ mnmnos(). void TMinuit::mnmnos ; (; ). virtual . Performs a MINOS error analysis. ; Performs a MINOS error analysis on those parameters for which it is requested on the MINOS command by calling MNMNOT for each parameter requested. ; Definition at line 5388 of file TMinuit.cxx. ◆ mnmnot(). void TMinuit::mnmnot ; (; Int_t ; ilax, . Int_t ; ilax2, . Double_t & ; val2pl, . Double_t & ; val2mi . ). virtual . Performs a MINOS error analysis on one parameter. ; The parameter ILAX is varied, and the minimum of the function with respect to the other parameters is followed until it crosses the value FMIN+UP. ; Definition at line 5463 of file TMinuit.cxx. ◆ mnparm(). void TMinuit::mnparm ; (; Int_t ; k1, . TString ; cnamj, . Double_t ; uk, . Double_t ; wk, . Double_t ; a, . Double_t ; b, . Int_t & ; ierflg . ). virtual . Implements one parameter definition. ; Called from MNPARS and user-callable Implements one parameter definition, that is:; K (external) parameter number; CNAMK parameter name; UK starting value; WK starting step size or uncertainty; A, B lower and upper physical parameter limits and sets up (updates) the parameter lists. Output:; IERFLG=0 if no problems; >0 if MNPARM unable to implement definition . Definition at line 5665 of file TMinuit.cxx. ◆ mnpars(). void TMinuit::mnpars ; (; TString & ; crdbuf, . Int_t & ; icondn . ). virtual . Implements one parameter definition. ; Called from MNREAD and user-ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:56872,Perform,Performs,56872,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,1,['Perform'],['Performs']
Performance,". void TProof::SetRealTimeLog ; (; Bool_t ; on = kTRUE). Switch ON/OFF the real-time logging facility. ; When this option is ON, log messages from processing are sent back as they come, instead of being sent back at the end in one go. This may help debugging or monitoring in some cases, but, depending on the amount of log, it may have significant consequencies on the load over the network, so it must be used with care. ; Definition at line 7096 of file TProof.cxx. ◆ SetRunStatus(). void TProof::SetRunStatus ; (; ERunStatus ; rst). inlineprivate . Definition at line 672 of file TProof.h. ◆ SetupWorkersEnv(). void TProof::SetupWorkersEnv ; (; TList * ; wrks, . Bool_t ; increasingpool = kFALSE . ). protected . Set up packages, loaded macros, include and lib paths ... ; Definition at line 1528 of file TProof.cxx. ◆ ShowCache(). void TProof::ShowCache ; (; Bool_t ; all = kFALSE). virtual . List contents of file cache. ; If all is true show all caches also on slaves. If everything is ok all caches are to be the same. ; Reimplemented in TProofLite.; Definition at line 7691 of file TProof.cxx. ◆ ShowData(). void TProof::ShowData ; (; ). virtual . List contents of the data directory in the sandbox. ; This is the place where files produced by the client queries are kept ; Reimplemented in TProofLite.; Definition at line 7396 of file TProof.cxx. ◆ ShowDataSet(). void TProof::ShowDataSet ; (; const char * ; dataset = """", . const char * ; opt = ""filter:SsCc"" . ). display meta-info for given dataset usi ; Definition at line 10977 of file TProof.cxx. ◆ ShowDataSetCache(). void TProof::ShowDataSetCache ; (; const char * ; dataset = 0). virtual . Display the content of the dataset cache, if any (matching 'dataset', if defined). ; Reimplemented in TProofLite.; Definition at line 10914 of file TProof.cxx. ◆ ShowDataSetQuota(). void TProof::ShowDataSetQuota ; (; Option_t * ; opt = 0). shows the quota and usage of all groups if opt contains ""U"" shows also distribution of usage on user-le",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:148005,cache,caches,148005,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['cache'],['caches']
Performance,". void setCallWarning(Int_t threshold = 2000); Activate warning messages if number of function calls needed for evaluation of convolution integral; exceeds given threshold. void setCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); Activate call profile if flag is set to true. A 2-D histogram is kept that stores the required number; of function calls versus the value of x, the convolution variable. All clones of RooNumConvolution objects will keep logging to the histogram of the original class; so that performance of temporary object clones, such as used in e.g. fitting, plotting and generating; are all logged in a single place. Function caller should take ownership of profiling histogram as it is not deleted at the RooNumConvolution dtor. Calling this function with flag set to false will deactivate call profiling and delete the profiling histogram. void printCompactTreeHook(ostream& os, const char* indent = """"); Hook function to intercept printCompactTree() calls so that it can print out; the content of its private cache in the print sequence. TObject* clone(const char* newname) const; { return new RooNumConvolution(*this,newname) ; }. RooNumIntConfig& convIntConfig(); { _init = kFALSE ; return _convIntConfig ; }. const RooNumIntConfig& convIntConfig() const; { _init = kFALSE ; return _convIntConfig ; }. const TH2* profileData() const; { return _doProf ? _callHist : 0 ; }. RooRealVar& var() const; Access components. { return (RooRealVar&) _origVar.arg() ; }. RooAbsReal& pdf() const; { return (RooAbsReal&) _origPdf.arg() ; }. RooAbsReal& model() const; { return (RooAbsReal&) _origModel.arg() ; }. RooRealVar& cloneVar() const; { if (!_init) initialize() ; return (RooRealVar&) *_cloneVar ; }. RooAbsReal& clonePdf() const; { if (!_init) initialize() ; return (RooAbsReal&) *_clonePdf ; }. RooAbsReal& cloneModel() const; { if (!_init) initialize() ; return (RooAbsReal&) *_cloneModel ; }. » Last changed: Mon Jul 4 15:23:34 2011 » Las",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumConvolution.html:39322,cache,cache,39322,root/html530/RooNumConvolution.html,https://root.cern,https://root.cern/root/html530/RooNumConvolution.html,1,['cache'],['cache']
Performance,". void setCallWarning(Int_t threshold = 2000); Activate warning messages if number of function calls needed for evaluation of convolution integral; exceeds given threshold. void setCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); Activate call profile if flag is set to true. A 2-D histogram is kept that stores the required number; of function calls versus the value of x, the convolution variable. All clones of RooNumConvolution objects will keep logging to the histogram of the original class; so that performance of temporary object clones, such as used in e.g. fitting, plotting and generating; are all logged in a single place. Function caller should take ownership of profiling histogram as it is not deleted at the RooNumConvolution dtor. Calling this function with flag set to false will deactivate call profiling and delete the profiling histogram. void printCompactTreeHook(ostream& os, const char* indent = """"); Hook function to intercept printCompactTree() calls so that it can print out; the content of its private cache in the print sequence. TObject* clone(const char* newname) const; { return new RooNumConvolution(*this,newname) ; }. RooNumIntConfig& convIntConfig(); { _init = kFALSE ; return _convIntConfig ; }. const RooNumIntConfig& convIntConfig() const; { _init = kFALSE ; return _convIntConfig ; }. const TH2* profileData() const; { return _doProf ? _callHist : 0 ; }. RooRealVar& var() const; Access components. { return (RooRealVar&) _origVar.arg() ; }. RooAbsReal& pdf() const; { return (RooAbsReal&) _origPdf.arg() ; }. RooAbsReal& model() const; { return (RooAbsReal&) _origModel.arg() ; }. RooRealVar& cloneVar() const; { if (!_init) initialize() ; return (RooRealVar&) *_cloneVar ; }. RooAbsReal& clonePdf() const; { if (!_init) initialize() ; return (RooAbsReal&) *_clonePdf ; }. RooAbsReal& cloneModel() const; { if (!_init) initialize() ; return (RooAbsReal&) *_cloneModel ; }. » Last changed: Thu Nov 3 20:08:50 2011 » Las",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumConvolution.html:39701,cache,cache,39701,root/html532/RooNumConvolution.html,https://root.cern,https://root.cern/root/html532/RooNumConvolution.html,1,['cache'],['cache']
Performance,". void setCallWarning(Int_t threshold = 2000); Activate warning messages if number of function calls needed for evaluation of convolution integral; exceeds given threshold. void setCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); Activate call profile if flag is set to true. A 2-D histogram is kept that stores the required number; of function calls versus the value of x, the convolution variable. All clones of RooNumConvolution objects will keep logging to the histogram of the original class; so that performance of temporary object clones, such as used in e.g. fitting, plotting and generating; are all logged in a single place. Function caller should take ownership of profiling histogram as it is not deleted at the RooNumConvolution dtor. Calling this function with flag set to false will deactivate call profiling and delete the profiling histogram. void printCompactTreeHook(ostream& os, const char* indent = """"); Hook function to intercept printCompactTree() calls so that it can print out; the content of its private cache in the print sequence. TObject* clone(const char* newname) const; { return new RooNumConvolution(*this,newname) ; }. RooNumIntConfig& convIntConfig(); { _init = kFALSE ; return _convIntConfig ; }. const RooNumIntConfig& convIntConfig() const; { _init = kFALSE ; return _convIntConfig ; }. const TH2* profileData() const; { return _doProf ? _callHist : 0 ; }. RooRealVar& var() const; Access components. { return (RooRealVar&) _origVar.arg() ; }. RooAbsReal& pdf() const; { return (RooAbsReal&) _origPdf.arg() ; }. RooAbsReal& model() const; { return (RooAbsReal&) _origModel.arg() ; }. RooRealVar& cloneVar() const; { if (!_init) initialize() ; return (RooRealVar&) *_cloneVar ; }. RooAbsReal& clonePdf() const; { if (!_init) initialize() ; return (RooAbsReal&) *_clonePdf ; }. RooAbsReal& cloneModel() const; { if (!_init) initialize() ; return (RooAbsReal&) *_cloneModel ; }. » Last changed: Thu Sep 23 20:00:23 2010 » La",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNumConvolution.html:38805,cache,cache,38805,root/html528/RooNumConvolution.html,https://root.cern,https://root.cern/root/html528/RooNumConvolution.html,1,['cache'],['cache']
Performance,". void setCallWarning(Int_t threshold = 2000); Activate warning messages if number of function calls needed for evaluation of convolution integral; exceeds given threshold. void setCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); Activate call profile if flag is set to true. A 2-D histogram is kept that stores the required number; of function calls versus the value of x, the convolution variable. All clones of RooNumConvolution objects will keep logging to the histogram of the original class; so that performance of temporary object clones, such as used in e.g. fitting, plotting and generating; are all logged in a single place. Function caller should take ownership of profiling histogram as it is not deleted at the RooNumConvolution dtor. Calling this function with flag set to false will deactivate call profiling and delete the profiling histogram. void printCompactTreeHook(ostream& os, const char* indent = """"); Hook function to intercept printCompactTree() calls so that it can print out; the content of its private cache in the print sequence. TObject* clone(const char* newname) const; { return new RooNumConvolution(*this,newname) ; }. RooNumIntConfig& convIntConfig(); { _init = kFALSE ; return _convIntConfig ; }. const RooNumIntConfig& convIntConfig() const; { _init = kFALSE ; return _convIntConfig ; }. const TH2* profileData() const; { return _doProf ? _callHist : 0 ; }. RooRealVar& var() const; Access components. { return (RooRealVar&) _origVar.arg() ; }. RooAbsReal& pdf() const; { return (RooAbsReal&) _origPdf.arg() ; }. RooAbsReal& model() const; { return (RooAbsReal&) _origModel.arg() ; }. RooRealVar& cloneVar() const; { if (!_init) initialize() ; return (RooRealVar&) *_cloneVar ; }. RooAbsReal& clonePdf() const; { if (!_init) initialize() ; return (RooAbsReal&) *_clonePdf ; }. RooAbsReal& cloneModel() const; { if (!_init) initialize() ; return (RooAbsReal&) *_cloneModel ; }. » Last changed: Tue Jun 2 15:32:41 2015 » Las",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooNumConvolution.html:43385,cache,cache,43385,root/html604/RooNumConvolution.html,https://root.cern,https://root.cern/root/html604/RooNumConvolution.html,1,['cache'],['cache']
Performance,". void setCallWarning(Int_t threshold = 2000); Activate warning messages if number of function calls needed for evaluation of convolution integral; exceeds given threshold. void setCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); Activate call profile if flag is set to true. A 2-D histogram is kept that stores the required number; of function calls versus the value of x, the convolution variable. All clones of RooNumConvolution objects will keep logging to the histogram of the original class; so that performance of temporary object clones, such as used in e.g. fitting, plotting and generating; are all logged in a single place. Function caller should take ownership of profiling histogram as it is not deleted at the RooNumConvolution dtor. Calling this function with flag set to false will deactivate call profiling and delete the profiling histogram. void printCompactTreeHook(ostream& os, const char* indent = """"); Hook function to intercept printCompactTree() calls so that it can print out; the content of its private cache in the print sequence. TObject* clone(const char* newname) const; { return new RooNumConvolution(*this,newname) ; }. RooNumIntConfig& convIntConfig(); { _init = kFALSE ; return _convIntConfig ; }. const RooNumIntConfig& convIntConfig() const; { _init = kFALSE ; return _convIntConfig ; }. const TH2* profileData() const; { return _doProf ? _callHist : 0 ; }. RooRealVar& var() const; Access components. { return (RooRealVar&) _origVar.arg() ; }. RooAbsReal& pdf() const; { return (RooAbsReal&) _origPdf.arg() ; }. RooAbsReal& model() const; { return (RooAbsReal&) _origModel.arg() ; }. RooRealVar& cloneVar() const; { if (!_init) initialize() ; return (RooRealVar&) *_cloneVar ; }. RooAbsReal& clonePdf() const; { if (!_init) initialize() ; return (RooAbsReal&) *_clonePdf ; }. RooAbsReal& cloneModel() const; { if (!_init) initialize() ; return (RooAbsReal&) *_cloneModel ; }. » Last changed: Tue Jun 30 14:34:35 2015 » La",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumConvolution.html:43385,cache,cache,43385,root/html602/RooNumConvolution.html,https://root.cern,https://root.cern/root/html602/RooNumConvolution.html,1,['cache'],['cache']
Performance,". void setCallWarning(Int_t threshold = 2000); Activate warning messages if number of function calls needed for evaluation of convolution integral; exceeds given threshold. void setCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); Activate call profile if flag is set to true. A 2-D histogram is kept that stores the required number; of function calls versus the value of x, the convolution variable. All clones of RooNumConvolution objects will keep logging to the histogram of the original class; so that performance of temporary object clones, such as used in e.g. fitting, plotting and generating; are all logged in a single place. Function caller should take ownership of profiling histogram as it is not deleted at the RooNumConvolution dtor. Calling this function with flag set to false will deactivate call profiling and delete the profiling histogram. void printCompactTreeHook(ostream& os, const char* indent = """"); Hook function to intercept printCompactTree() calls so that it can print out; the content of its private cache in the print sequence. TObject* clone(const char* newname) const; { return new RooNumConvolution(*this,newname) ; }. RooNumIntConfig& convIntConfig(); { _init = kFALSE ; return _convIntConfig ; }. const RooNumIntConfig& convIntConfig() const; { _init = kFALSE ; return _convIntConfig ; }. const TH2* profileData() const; { return _doProf ? _callHist : 0 ; }. RooRealVar& var() const; Access components. { return (RooRealVar&) _origVar.arg() ; }. RooAbsReal& pdf() const; { return (RooAbsReal&) _origPdf.arg() ; }. RooAbsReal& model() const; { return (RooAbsReal&) _origModel.arg() ; }. RooRealVar& cloneVar() const; { if (!_init) initialize() ; return (RooRealVar&) *_cloneVar ; }. RooAbsReal& clonePdf() const; { if (!_init) initialize() ; return (RooAbsReal&) *_clonePdf ; }. RooAbsReal& cloneModel() const; { if (!_init) initialize() ; return (RooAbsReal&) *_cloneModel ; }. » Last changed: Tue Mar 10 17:18:14 2015 » La",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvolution.html:41874,cache,cache,41874,root/html534/RooNumConvolution.html,https://root.cern,https://root.cern/root/html534/RooNumConvolution.html,1,['cache'],['cache']
Performance,". void setCallWarning(Int_t threshold = 2000); Activate warning messages if number of function calls needed for evaluation of convolution integral; exceeds given threshold. void setCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); Activate call profile if flag is set to true. A 2-D histogram is kept that stores the required number; of function calls versus the value of x, the convolution variable. All clones of RooNumConvolution objects will keep logging to the histogram of the original class; so that performance of temporary object clones, such as used in e.g. fitting, plotting and generating; are all logged in a single place. Function caller should take ownership of profiling histogram as it is not deleted at the RooNumConvolution dtor. Calling this function with flag set to false will deactivate call profiling and delete the profiling histogram. void printCompactTreeHook(ostream& os, const char* indent = """"); Hook function to intercept printCompactTree() calls so that it can print out; the content of its private cache in the print sequence. TObject* clone(const char* newname) const; { return new RooNumConvolution(*this,newname) ; }. RooNumIntConfig& convIntConfig(); { _init = kFALSE ; return _convIntConfig ; }. const RooNumIntConfig& convIntConfig(); { _init = kFALSE ; return _convIntConfig ; }. const TH2* profileData() const; { return _doProf ? _callHist : 0 ; }. RooRealVar& var() const; Access components. { return (RooRealVar&) _origVar.arg() ; }. RooAbsReal& pdf() const; { return (RooAbsReal&) _origPdf.arg() ; }. RooAbsReal& model() const; { return (RooAbsReal&) _origModel.arg() ; }. RooRealVar& cloneVar() const; { if (!_init) initialize() ; return (RooRealVar&) *_cloneVar ; }. RooAbsReal& clonePdf() const; { if (!_init) initialize() ; return (RooAbsReal&) *_clonePdf ; }. RooAbsReal& cloneModel() const; { if (!_init) initialize() ; return (RooAbsReal&) *_cloneModel ; }. » Last changed: Mon Dec 7 13:48:31 2009 » Last gene",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvolution.html:38564,cache,cache,38564,root/html526/RooNumConvolution.html,https://root.cern,https://root.cern/root/html526/RooNumConvolution.html,1,['cache'],['cache']
Performance,".  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TLegend Class ReferenceGraphics » 2D Graphics » Basic graphics. ; This class displays a legend box (TPaveText) containing several legend entries. ; Each legend entry is made of a reference to a ROOT object, a text label and an option specifying which graphical attributes (marker/line/fill) should be displayed.; The following example shows how to create a legend. In this example the legend contains a histogram, a function and a graph. The histogram is put in the legend using its reference pointer whereas the graph and the function are added using their names. Note that, because TGraph constructors do not have the TGraph name as parameter, the graph name should be specified using the SetName method.; When an object is added by name, a scan is performed on the list of objects contained in the current pad (gPad) and also in the possible TMultiGraph and THStack present in the pad. If a matching name is found, the corresponding object is added in the legend using its pointer.; {; auto c1 = new TCanvas(""c1"",""c1"",600,500);; gStyle->SetOptStat(0);; ; auto h1 = new TH1F(""h1"",""TLegend Example"",200,-10,10);; h1->FillRandom(""gaus"",30000);; h1->SetFillColor(kGreen);; h1->SetFillStyle(3003);; h1->Draw();; ; auto f1=new TF1(""f1"",""1000*TMath::Abs(sin(x)/x)"",-10,10);; f1->SetLineColor(kBlue);; f1->SetLineWidth(4);; f1->Draw(""same"");; ; const Int_t n = 20;; Double_t x[n], y[n], ex[n], ey[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 1000*sin(x[i]+0.2);; x[i] = 17.8*x[i]-8.9;; ex[i] = 1.0;; ey[i] = 10.*i;; }; auto gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetName(""gr"");; gr->SetLineColor(kRed);; gr->SetLineWidth(2);; gr->SetMarkerStyle(21);; gr->SetMarkerSize(1.3);; gr->SetMarkerColor(7);; gr->Draw(""P"");; ; auto legend = new TLegend(0.1,0.7,0.48,0.9);; legend->SetHeader(""The Lege",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLegend.html:1025,perform,performed,1025,doc/master/classTLegend.html,https://root.cern,https://root.cern/doc/master/classTLegend.html,1,['perform'],['performed']
Performance,". ◆ BombTranslation(). void TGeoManager::BombTranslation ; (; const Double_t * ; tr, . Double_t * ; bombtr . ). Get the new 'bombed' translation vector according current exploded view mode. ; Definition at line 1078 of file TGeoManager.cxx. ◆ Browse(). void TGeoManager::Browse ; (; TBrowser * ; b). overridevirtual . Describe how to browse this object. ; Reimplemented from TObject.; Definition at line 1023 of file TGeoManager.cxx. ◆ BuildDefaultMaterials(). void TGeoManager::BuildDefaultMaterials ; (; ). Now just a shortcut for GetElementTable. ; Definition at line 3615 of file TGeoManager.cxx. ◆ cd(). Bool_t TGeoManager::cd ; (; const char * ; path = """"). virtual . Browse the tree of nodes starting from fTopNode according to pathname. ; Changes the path accordingly. ; Definition at line 1707 of file TGeoManager.cxx. ◆ CdDown(). void TGeoManager::CdDown ; (; Int_t ; index). Make a daughter of current node current. ; Can be called only with a valid daughter index (no check). Updates cache accordingly. ; Definition at line 1690 of file TGeoManager.cxx. ◆ CdNext(). void TGeoManager::CdNext ; (; ). Do a cd to the node found next by FindNextBoundary. ; Definition at line 1698 of file TGeoManager.cxx. ◆ CdNode(). void TGeoManager::CdNode ; (; Int_t ; nodeid). Change current path to point to the node having this id. ; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons) ; Definition at line 1655 of file TGeoManager.cxx. ◆ CdTop(). void TGeoManager::CdTop ; (; ). Make top level node the current node. ; Updates the cache accordingly. Determine the overlapping state of current node. ; Definition at line 1672 of file TGeoManager.cxx. ◆ CdUp(). void TGeoManager::CdUp ; (; ). Go one level up in geometry. ; Updates cache accordingly. Determine the overlapping state of current node. ; Definition at line 1681 of file TGeoManager.cxx. ◆ CheckBoundaryErrors(). void TGeoManager::CheckBoundaryErrors ; (; Int_t ; ntracks = 1000000, . Double_t ; radius = -1. . ). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:72736,cache,cache,72736,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['cache'],['cache']
Performance,". ◆ ClearDataSetCache(). void TProofLite::ClearDataSetCache ; (; const char * ; dataset = 0). overridevirtual . Clear the content of the dataset cache, if any (matching 'dataset', if defined). ; Reimplemented from TProof.; Definition at line 2282 of file TProofLite.cxx. ◆ CopyMacroToCache(). Int_t TProofLite::CopyMacroToCache ; (; const char * ; macro, . Int_t ; headerRequired = 0, . TSelector ** ; selector = 0, . Int_t ; opt = 0, . TList * ; wrks = 0 . ). protected . Copy a macro, and its possible associated .h[h] file, to the cache directory, from where the workers can get the file. ; If headerRequired is 1, return -1 in case the header is not found. If headerRequired is 0, try to copy header too. If headerRequired is -1, don't look for header, only copy macro. If the selector pionter is not 0, consider the macro to be a selector and try to load the selector and set it to the pointer. The mask 'opt' is an or of ESendFileOpt: kCpBin (0x8) Retrieve from the cache the binaries associated with the file kCp (0x10) Retrieve the files from the cache Return -1 in case of error, 0 otherwise. ; Definition at line 1593 of file TProofLite.cxx. ◆ CreateSandbox(). Int_t TProofLite::CreateSandbox ; (; ). private . Create the sandbox for this session. ; Definition at line 880 of file TProofLite.cxx. ◆ DeclFileName(). static const char * TProofLite::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 170 of file TProofLite.h. ◆ DrawSelect(). Long64_t TProofLite::DrawSelect ; (; TDSet * ; dset, . const char * ; varexp, . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; first = 0 . ). overridevirtual . Execute the specified drawing action on a data set (TDSet). ; Event- or Entry-lists should be set in the data set object using TDSet::SetEntryList. Returns -1 in case of error or number of selected events otherwise. ; Reimplemented from TProof.; Definition at line 1053 of f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:49960,cache,cache,49960,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,2,['cache'],['cache']
Performance,". ◆ IsA(). TClass * TGTextView::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGCompositeFrame.; Reimplemented in TGTextViewostream.; Definition at line 141 of file TGTextView.h. ◆ IsMarked(). Bool_t TGTextView::IsMarked ; (; ); const. inline . Definition at line 119 of file TGTextView.h. ◆ IsReadOnly(). Bool_t TGTextView::IsReadOnly ; (; ); const. inline . Definition at line 118 of file TGTextView.h. ◆ IsSaved(). virtual Bool_t TGTextView::IsSaved ; (; ). inlinevirtual . Definition at line 77 of file TGTextView.h. ◆ Layout(). void TGTextView::Layout ; (; ). overridevirtual . Layout the components of view. ; Reimplemented from TGCompositeFrame.; Definition at line 1329 of file TGTextView.cxx. ◆ LoadBuffer(). Bool_t TGTextView::LoadBuffer ; (; const char * ; txtbuf). virtual . Load text from a text buffer. Return false in case of failure. ; Definition at line 471 of file TGTextView.cxx. ◆ LoadFile(). Bool_t TGTextView::LoadFile ; (; const char * ; filename, . long ; startpos = 0, . long ; length = -1 . ). virtual . Load a file in the text view widget. ; Return false in case file does not exist. ; Definition at line 454 of file TGTextView.cxx. ◆ Mark(). void TGTextView::Mark ; (; Long_t ; xPos, . Long_t ; yPos . ). protectedvirtual . Mark a text region from xPos to yPos. ; Definition at line 1170 of file TGTextView.cxx. ◆ Marked(). virtual void TGTextView::Marked ; (; Bool_t ; mark). inlinevirtual . Definition at line 137 of file TGTextView.h. ◆ operator=(). TGTextView & TGTextView::operator= ; (; const TGTextView & ; ). privatedelete . ◆ ReturnHeighestColHeight(). virtual Long_t TGTextView::ReturnHeighestColHeight ; (; ). inlinevirtual . Definition at line 90 of file TGTextView.h. ◆ ReturnLineCount(). virtual Long_t TGTextView::ReturnLineCount ; (; ). inlinevirtual . Definition at line 94 of file TGTextView.h. ◆ ReturnLineLength(). virtual Long_t TGTextView::ReturnLineLength ; (; Long_t ; line). inlinevirtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextView.html:49186,Load,LoadFile,49186,doc/master/classTGTextView.html,https://root.cern,https://root.cern/doc/master/classTGTextView.html,1,['Load'],['LoadFile']
Performance,". ◆ LocalToMasterVect(). void TGeoScale::LocalToMasterVect ; (; const Double_t * ; local, . Double_t * ; master . ); const. inlineoverridevirtual . convert a vector by multiplying its column vector (x, y, z, 1) to matrix inverse ; Reimplemented from TGeoMatrix.; Definition at line 276 of file TGeoMatrix.h. ◆ MakeClone(). TGeoMatrix * TGeoScale::MakeClone ; (; ); const. overridevirtual . Make a clone of this matrix. ; Implements TGeoMatrix.; Definition at line 1632 of file TGeoMatrix.cxx. ◆ MasterToLocal() [1/2]. void TGeoScale::MasterToLocal ; (; const Double_t * ; master, . Double_t * ; local . ); const. overridevirtual . Convert a global point to local frame. ; Reimplemented from TGeoMatrix.; Definition at line 1641 of file TGeoMatrix.cxx. ◆ MasterToLocal() [2/2]. Double_t TGeoScale::MasterToLocal ; (; Double_t ; dist, . const Double_t * ; dir = nullptr . ); const. Convert the distance along unit vector DIR to local frame. ; If DIR is not specified perform a conversion such as the returned distance is the the minimum for all possible directions. ; Definition at line 1653 of file TGeoMatrix.cxx. ◆ MasterToLocalVect(). void TGeoScale::MasterToLocalVect ; (; const Double_t * ; master, . Double_t * ; local . ); const. inlineoverridevirtual . convert a point by multiplying its column vector (x, y, z, 1) to matrix ; Reimplemented from TGeoMatrix.; Definition at line 283 of file TGeoMatrix.h. ◆ operator*() [1/2]. TGeoHMatrix TGeoScale::operator* ; (; const TGeoMatrix & ; right); const. Definition at line 1531 of file TGeoMatrix.cxx. ◆ operator*() [2/2]. TGeoScale TGeoScale::operator* ; (; const TGeoScale & ; other); const. Definition at line 1524 of file TGeoMatrix.cxx. ◆ operator*=(). TGeoScale & TGeoScale::operator*= ; (; const TGeoScale & ; other). Scale composition. ; Definition at line 1512 of file TGeoMatrix.cxx. ◆ operator=() [1/2]. TGeoScale & TGeoScale::operator= ; (; const TGeoMatrix & ; other). Assignment from a general matrix. ; Definition at line 1496 of file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoScale.html:20704,perform,perform,20704,doc/master/classTGeoScale.html,https://root.cern,https://root.cern/doc/master/classTGeoScale.html,1,['perform'],['perform']
Performance,". ◆ mnrset(). void TMinuit::mnrset ; (; Int_t ; iopt). virtual . Resets function value and errors to UNDEFINED. . If IOPT=1,; If IOPT=0, sets only MINOS errors to undefined Called from MNCLER and whenever problem changes, for example after SET LIMITS, SET PARAM, CALL FCN 6 . Definition at line 6661 of file TMinuit.cxx. ◆ mnsave(). void TMinuit::mnsave ; (; ). virtual . Writes current parameter values and step sizes onto file ISYSSA. ; in format which can be reread by Minuit for restarting. The covariance matrix is also output if it exists. ; Definition at line 6695 of file TMinuit.cxx. ◆ mnscan(). void TMinuit::mnscan ; (; ). virtual . Scans the values of FCN as a function of one parameter. ; and plots the resulting values as a curve using MNPLOT. It may be called to scan one parameter or all parameters. retains the best function and parameter values found. ; Definition at line 6708 of file TMinuit.cxx. ◆ mnseek(). void TMinuit::mnseek ; (; ). virtual . Performs a rough (but global) minimization by monte carlo search. ; Each time a new minimum is found, the search area is shifted to be centered at the best value. Random points are chosen uniformly over a hypercube determined by current step sizes. The Metropolis algorithm accepts a worse point with probability exp(-d/UP), where d is the degradation. Improved points are of course always accepted. Actual steps are random multiples of the nominal steps (DIRIN). ; Definition at line 6818 of file TMinuit.cxx. ◆ mnset(). void TMinuit::mnset ; (; ). virtual . Interprets the commands that start with SET and SHOW. ; Called from MNEXCM file characteristics for SET INPUT 'SET ' or 'SHOW', 'ON ' or 'OFF', 'SUPPRESSED' or 'REPORTED ' explanation of print level numbers -1:3 and strategies 0:2 identification of debug options things that can be set or shown options not intended for normal users ; Definition at line 6913 of file TMinuit.cxx. ◆ mnsimp(). void TMinuit::mnsimp ; (; ). virtual . Minimization using the simplex method of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:63399,Perform,Performs,63399,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,1,['Perform'],['Performs']
Performance,". ◆ operator+(). TFoamVect TFoamVect::operator+ ; (; const TFoamVect & ; p2). addition operator +; sum of 2 vectors: c=a+b, a=a+b, NEVER USE IT, VERY SLOW!!! ; Definition at line 157 of file TFoamVect.cxx. ◆ operator+=(). TFoamVect & TFoamVect::operator+= ; (; const TFoamVect & ; Shift). unary addition operator +=; adding vector c*=x, ; Definition at line 130 of file TFoamVect.cxx. ◆ operator-(). TFoamVect TFoamVect::operator- ; (; const TFoamVect & ; p2). subtraction operator -; difference of 2 vectors; c=a-b, a=a-b, NEVER USE IT, VERY SLOW!!! ; Definition at line 169 of file TFoamVect.cxx. ◆ operator-=(). TFoamVect & TFoamVect::operator-= ; (; const TFoamVect & ; Shift). unary subtraction operator -= ; Definition at line 143 of file TFoamVect.cxx. ◆ operator=() [1/3]. TFoamVect & TFoamVect::operator= ; (; const TFoamVect & ; Vect). substitution operator ; Definition at line 86 of file TFoamVect.cxx. ◆ operator=() [2/3]. TFoamVect & TFoamVect::operator= ; (; Double_t ; x). Loading in double prec. number, sometimes can be useful. ; Definition at line 191 of file TFoamVect.cxx. ◆ operator=() [3/3]. TFoamVect & TFoamVect::operator= ; (; Double_t ; Vect[]). Loading in ordinary double prec. vector, sometimes can be useful. ; Definition at line 180 of file TFoamVect.cxx. ◆ operator[](). Double_t & TFoamVect::operator[] ; (; Int_t ; n). [] is for access to elements as in ordinary matrix like a[j]=b[j] (Perhaps against some strict rules but rather practical.) Range protection is built in, consequently for substitution one should use rather use a=b than explicit loop! ; Definition at line 109 of file TFoamVect.cxx. ◆ Print(). void TFoamVect::Print ; (; Option_t * ; option); const. overridevirtual . Printout of all vector components on ""std::cout"". ; Reimplemented from TObject.; Definition at line 203 of file TFoamVect.cxx. ◆ Streamer(). void TFoamVect::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ Strea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFoamVect.html:14290,Load,Loading,14290,doc/master/classTFoamVect.html,https://root.cern,https://root.cern/doc/master/classTFoamVect.html,1,['Load'],['Loading']
Performance,".. Loading TTree's Data; For the analysis example we need to access the events' size, which is accessible through the TTreeReaderValue eventSize. But the TTreeReader first needs to get told about which TTree entry to access. For that call TTreeReader::Next() in a loop. It will return false once it has reached the end of the TTree.; In the same loop, compute the total size of all events (simply add the current event size to the total size); ... // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Get the data from the current TTree entry by getting; // the value from the connected reader (eventSize):; totalSize += *eventSize;; }. Accessing the Analysis Result; At the end of the loop, print the sum of all event sizes. This sum shows you the real power of a TTree: even though you can analyze large amounts of data (our example tree with 22MB is tiny!) ROOT needs just a few MB of your RAM, no matter how many events you analyze. Imagine what it would be like if you had to load all data into memory, e.g. using a simple vector!; ... Int_t sizeInMB = totalSize/1024/1024;; printf(""Total size of all events: %d MB\n"", sizeInMB);; }. Running the Macro; To run this macro, simply type .x AnalyzeTree.C and ROOT will execute it. If it finds an error it might be wise to quit ROOT (.q) and try again!; If, for any reason, you don't manage to get it working, you can download a working macro file here: CountEvents.C; Here again, if you are using ROOT via ssh, you have to download the file with wget from your remote directory:; wget http://root-mirror.github.io/training/intro/CountEvents.C; . ‹ TTree and Its Data; up; Histogramming ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; Th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/using-macro-read-ttree.html:5084,load,load,5084,d/using-macro-read-ttree.html,https://root.cern,https://root.cern/d/using-macro-read-ttree.html,1,['load'],['load']
Performance,".. and that's the one that will later on be used; in the main training loop. void TrainAllMethods(); iterates through all booked methods and calls training. void TestAllMethods(). void MakeClass(const TString& methodTitle = """") const; Print predefined help message of classifier; iterate over methods and test. void PrintHelpMessage(const TString& methodTitle = """") const; Print predefined help message of classifier; iterate over methods and test. void EvaluateAllVariables(TString options = """"); iterates over all MVA input varables and evaluates them. void EvaluateAllMethods( void ); iterates over all MVAs that have been booked, and calls their evaluation methods. const char* GetName() const; { return ""Factory""; }. void AddRegressionTree(TTree* tree, Double_t weight = 1.0, TMVA::Types::ETreeType treetype = Types::kMaxTreeType); special case: regression. void AddRegressionTarget(const TString& expression, const TString& title = """", const TString& unit = """", Double_t min = 0, Double_t max = 0). MethodBase* BookMethod(TString theMethodName, TString methodTitle, TString theOption = """"). void OptimizeAllMethodsForClassification(TString fomType = ""ROCIntegral"", TString fitType = ""Scan""); { OptimizeAllMethods(fomType,fitType); }. void OptimizeAllMethodsForRegression(TString fomType = ""ROCIntegral"", TString fitType = ""Scan""); { OptimizeAllMethods(fomType,fitType); }. void TrainAllMethodsForClassification( void ); { TrainAllMethods(); }. void TrainAllMethodsForRegression( void ); { TrainAllMethods(); }. Bool_t Verbose( void ); { return fVerbose; }. TDirectory* RootBaseDir(); { return (TDirectory*)fgTargetFile; }. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: Factory.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-12-01 16:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__Factory.html:20634,Optimiz,OptimizeAllMethodsForClassification,20634,root/html528/TMVA__Factory.html,https://root.cern,https://root.cern/root/html528/TMVA__Factory.html,4,['Optimiz'],"['OptimizeAllMethods', 'OptimizeAllMethodsForClassification', 'OptimizeAllMethodsForRegression']"
Performance,"....: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void St",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:24796,cache,cache,24796,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,1,['cache'],['cache']
Performance,"....: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); Update pointer to current Tree and recompute pointers to the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:22905,cache,cache,22905,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,1,['cache'],['cache']
Performance,...; Factory : Test method: PDEFoam for Multiclass classification performance; : ; : Dataset[dataset] : Create results for testing; : Dataset[dataset] : Multiclass evaluation of PDEFoam on testing sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 0.122 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; Factory : Test method: DL_CPU for Multiclass classification performance; : ; : Dataset[dataset] : Create results for testing; : Dataset[dataset] : Multiclass evaluation of DL_CPU on testing sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 0.105 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; Factory : ␛[1mEvaluate all methods␛[0m; : Evaluate multiclass classification method: BDTG; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; TFHandler_BDTG : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.070153 1.0224 [ -4.0592 3.5808 ]; : var2: 0.30372 1.0460 [ -3.6952 3.7877 ]; : var3: 0.12152 1.1222 [ -3.6800 3.9200 ]; : var4: -0.072602 1.2766 [ -4.8486 4.2221 ]; : -----------------------------------------------------------; : Evaluate multiclass classification method: MLP; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; TFHandler_MLP : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.070153 1.0224 [ -4.0592 3.5808 ]; : var2: 0.30372 1.0460 [ -3.6952 3.7877 ]; : var3: 0.12152 1.1222 [ -3.6800 3.9200 ]; : var4: -0.072602 1.2766 [ -4.8486 4.2221 ]; : -----------------------------------------------------------; : Evaluate multiclass classification,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:21066,perform,performance,21066,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['perform'],['performance']
Performance,"...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Private Attributes |; List of all members ; TGeoHMatrix Class ReferenceThe Geometry Package » Geometry classes. ; Matrix class used for computing global transformations Should NOT be used for node definition. ; An instance of this class is generally used to pile-up local transformations starting from the top level physical node, down to the current node. ; Definition at line 458 of file TGeoMatrix.h. Public Member Functions;  TGeoHMatrix ();  dummy ctor ;  ;  TGeoHMatrix (const char *name);  constructor ;  ;  TGeoHMatrix (const TGeoHMatrix &other);  ;  TGeoHMatrix (const TGeoMatrix &matrix);  assignment ;  ;  ~TGeoHMatrix () override;  destructor ;  ; void Clear (Option_t *option="""") override;  clear the data for this matrix ;  ; void CopyFrom (const TGeoMatrix *other);  Fast copy method. ;  ; Double_t Determinant () const;  computes determinant of the rotation matrix ;  ; void FastRotZ (const Double_t *sincos);  Perform a rotation about Z having the sine/cosine of the rotation angle. ;  ; virtual Double_t * GetRotationMatrix ();  ; const Double_t * GetRotationMatrix () const override;  ; virtual Double_t * GetScale ();  ; const Double_t * GetScale () const override;  ; virtual Double_t * GetTranslation ();  ; const Double_t * GetTranslation () const override;  ; TGeoHMatrix Inverse () const override;  Return a temporary inverse of this. ;  ; TClass * IsA () const override;  ; TGeoMatrix * MakeClone () const override;  Make a clone of this matrix. ;  ; void Multiply (const TGeoMatrix &right);  ; void Multiply (const TGeoMatrix *right);  multiply to the right with an other transformation if right is identity matrix, just return ;  ; void MultiplyLeft (const TGeoMatrix &left);  ; void MultiplyLeft (const TGeoMatrix *left);  multiply to the left with an other transformation if right is identity matrix, just return ;  ; TGeoHMatrix operator* (const TGeoMatrix &other) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHMatrix.html:1129,Perform,Perform,1129,doc/master/classTGeoHMatrix.html,https://root.cern,https://root.cern/doc/master/classTGeoHMatrix.html,1,['Perform'],['Perform']
Performance,"...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; List of all members ; RooBMixDecay Class ReferenceRooFit » RooFit. ; Class RooBMixDecay is a RooAbsAnaConvPdf implementation that describes the decay of B mesons with the effects of B0/B0bar mixing. ; This function can be analytically convolved with any RooResolutionModel implementation ; Definition at line 23 of file RooBMixDecay.h. Public Types; enum  DecayType { SingleSided; , DoubleSided; , Flipped; };  ;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBMixDecay.html:1050,Cache,CacheMode,1050,doc/master/classRooBMixDecay.html,https://root.cern,https://root.cern/doc/master/classRooBMixDecay.html,1,['Cache'],['CacheMode']
Performance,..;  ; class  IBaseFunctionMultiDimTempl;  Documentation for the abstract class IBaseFunctionMultiDim. More...;  ; class  IBaseFunctionOneDim;  Interface (abstract class) for generic functions objects of one-dimension Provides a method to evaluate the function given a value (simple double) by implementing operator() (const double ). More...;  ; class  IBaseParam;  Documentation for the abstract class IBaseParam. More...;  ; class  IGradientFunctionMultiDimTempl;  Interface (abstract class) for multi-dimensional functions providing a gradient calculation. More...;  ; class  IGradientFunctionOneDim;  Interface (abstract class) for one-dimensional functions providing a gradient calculation. More...;  ; class  IGradientMultiDimTempl;  ; class  IMinimizer1D;  Interface class for numerical methods for one-dimensional minimization. More...;  ; class  IntegrandTransform;  Auxiliary inner class for mapping infinite and semi-infinite integrals. More...;  ; class  IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  Interpolator;  Class for performing function interpolation of points. More...;  ; class  Inverter;  Matrix Inverter class Class to specialize calls to Dinv. More...;  ; class  Inverter< 0 >;  Inverter<0>. More...;  ; class  Inverter< 1 >;  1x1 matrix inversion \(a_{11} \to 1/a_{11}\) More...;  ; class  Inverter< 2 >;  2x2 matrix inversion using Cramers rule. More...;  ; class  IOptions;  Generic interface for defining configuration options of a numerical algorithm. More...;  ; class  IParametricFunctionMultiDimTempl;  IParamFunction interface (abstract class) describing multi-dimensional parametric functions It is a derive,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:17191,perform,performing,17191,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['perform'],['performing']
Performance,"..>(*(ColumnNames_t*)(&columnList))""; 1487 RInterface<RLoopManager> resRDF(std::make_shared<ROOT::Detail::RDF::RLoopManager>(0));; 1488 cacheCall << ""*reinterpret_cast<ROOT::RDF::RInterface<ROOT::Detail::RDF::RLoopManager>*>(""; 1489 << RDFInternal::PrettyPrintAddr(&resRDF); 1490 << "") = reinterpret_cast<ROOT::RDF::RInterface<ROOT::Detail::RDF::RNodeBase>*>(""; 1491 << RDFInternal::PrettyPrintAddr(&upcastInterface) << "")->Cache<"";; 1492 ; 1493 const auto columnListWithoutSizeColumns = RDFInternal::FilterArraySizeColNames(columnList, ""Cache"");; 1494 ; 1495 const auto validColumnNames =; 1496 GetValidatedColumnNames(columnListWithoutSizeColumns.size(), columnListWithoutSizeColumns);; 1497 const auto colTypes = GetValidatedArgTypes(validColumnNames, fColRegister, fLoopManager->GetTree(), fDataSource,; 1498 ""Cache"", /*vector2RVec=*/false);; 1499 for (const auto &colType : colTypes); 1500 cacheCall << colType << "", "";; 1501 if (!columnListWithoutSizeColumns.empty()); 1502 cacheCall.seekp(-2, cacheCall.cur); // remove the last "",; 1503 cacheCall << "">(*reinterpret_cast<std::vector<std::string>*>("" // vector<string> should be ColumnNames_t; 1504 << RDFInternal::PrettyPrintAddr(&columnListWithoutSizeColumns) << ""));"";; 1505 ; 1506 // book the code to jit with the RLoopManager and trigger the event loop; 1507 fLoopManager->ToJitExec(cacheCall.str());; 1508 fLoopManager->Jit();; 1509 ; 1510 return resRDF;; 1511 }; 1512 ; 1513 ////////////////////////////////////////////////////////////////////////////; 1514 /// \brief Save selected columns in memory.; 1515 /// \param[in] columnNameRegexp The regular expression to match the column names to be selected. The presence of a '^' and a '$' at the end of the string is implicitly assumed if they are not specified. The dialect supported is PCRE via the TPRegexp class. An empty string signals the selection of all columns.; 1516 /// \return a `RDataFrame` that wraps the cached dataset.; 1517 ///; 1518 /// The existing columns are matched a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:83675,cache,cacheCall,83675,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['cache'],['cacheCall']
Performance,".0 and 1.0 ; Reimplemented from TVirtualX.; Definition at line 4097 of file TGWin32.cxx. ◆ SetSelectionOwner(). Bool_t TGWin32::SetSelectionOwner ; (; Window_t ; owner, . Atom_t & ; sel . ). overridevirtual . Assigns owner of Clipboard. ; Reimplemented from TVirtualX.; Definition at line 7681 of file TGWin32.cxx. ◆ SetTextAlign(). void TGWin32::SetTextAlign ; (; Short_t ; talign = 11). overridevirtual . Set text alignment. ; txalh : horizontal text alignment txalv : vertical text alignment ; Reimplemented from TAttText.; Definition at line 4134 of file TGWin32.cxx. ◆ SetTextColor(). void TGWin32::SetTextColor ; (; Color_t ; cindex). overridevirtual . Set color index for text. ; Reimplemented from TAttText.; Definition at line 4194 of file TGWin32.cxx. ◆ SetTextFont() [1/2]. Int_t TGWin32::SetTextFont ; (; char * ; fontname, . ETextSetMode ; mode . ). overridevirtual . Set text font to specified name. ; mode : loading flag mode=0 : search if the font exist (kCheck) mode=1 : search the font and load it if it exists (kLoad) font : font name; Set text font to specified name. This function returns 0 if the specified font is found, 1 if not. ; Reimplemented from TVirtualX.; Definition at line 1552 of file TGWin32.cxx. ◆ SetTextFont() [2/2]. void TGWin32::SetTextFont ; (; Font_t ; fontnumber). overridevirtual . Set specified font. ; Reimplemented from TAttText.; Definition at line 1536 of file TGWin32.cxx. ◆ SetTextMagnitude(). void TGWin32::SetTextMagnitude ; (; Float_t ; mgn = 1). inlineoverridevirtual . Sets the current text magnification factor to ""mgn"". ; Reimplemented from TVirtualX.; Definition at line 219 of file TGWin32.h. ◆ SetTextSize(). void TGWin32::SetTextSize ; (; Float_t ; textsize). overridevirtual . Set current text size. ; Reimplemented from TAttText.; Definition at line 1560 of file TGWin32.cxx. ◆ SetTypeList(). void TGWin32::SetTypeList ; (; Window_t ; win, . Atom_t ; prop, . Atom_t * ; typelist . ). overridevirtual . Add the list of drag and drop type",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32.html:113164,load,loading,113164,doc/master/classTGWin32.html,https://root.cern,https://root.cern/doc/master/classTGWin32.html,2,['load'],"['load', 'loading']"
Performance,".1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 35 out-of-range events; RooDataSet::ds[x,y] = 65 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds2) Ignored 36 out-of-range events; RooDataSet::ds2[x,y,z] = 26 entries; [#1] INFO:DataHandling -- RooAbsReal::attachToTree(i) TTree Int_t branch i will be converted to double precision.; RooDataSet::ds3[i,x] = 100 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #2 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #5 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #8 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #11 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds4) Ignored 33 out-of-range events; RooDataSet::ds4[i,x] = 67",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf401__importttreethx_8C.html:8205,load,loadValues,8205,doc/master/rf401__importttreethx_8C.html,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8C.html,1,['load'],['loadValues']
Performance,.320979 0.311994 0.080369 0.00694962 43585.2 0; : 15 Minimum Test error found - save the configuration ; : 15 | 0.316442 0.305918 0.0803736 0.00690045 43553.3 0; : 16 Minimum Test error found - save the configuration ; : 16 | 0.311672 0.301667 0.0807629 0.00695777 43357.4 0; : 17 Minimum Test error found - save the configuration ; : 17 | 0.306787 0.297289 0.0804752 0.00690149 43493.8 0; : 18 Minimum Test error found - save the configuration ; : 18 | 0.303107 0.295781 0.0805443 0.00693772 43474.3 0; : 19 Minimum Test error found - save the configuration ; : 19 | 0.300241 0.290359 0.0805629 0.00693546 43462 0; : 20 | 0.29682 0.292587 0.0806285 0.00686869 43384.1 1; : ; : Elapsed time for training with 4000 events: 1.62 sec ; : Dataset[dataset] : Create results for training; : Dataset[dataset] : Multiclass evaluation of DL_CPU on training sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 0.106 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAMulticlass_DL_CPU.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAMulticlass_DL_CPU.class.C␛[0m; Factory : Training finished; : ; : Ranking input variables (method specific)...; BDTG : Ranking result (top variable is best ranked); : --------------------------------------; : Rank : Variable : Variable Importance; : --------------------------------------; : 1 : var4 : 3.117e-01; : 2 : var1 : 2.504e-01; : 3 : var2 : 2.430e-01; : 4 : var3 : 1.949e-01; : --------------------------------------; MLP : Ranking result (top variable is best ranked); : -----------------------------; : Rank : Variable : Importance; : -----------------------------; : 1 : var4 : 6.076e+01; : 2 : var2 : 4.824e+01; : 3 : var1 : 2.116e+01; : 4 : var3 : 1.692e+01; : -----------------------------; PDEFoam : Ranking result (top variable is best ranked); : --------------------------------------; : Rank : Variable : Va,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:17317,perform,performance,17317,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['perform'],['performance']
Performance,".4); frame5.Draw(); ; c.SaveAs(""rf102_dataimport.png""); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_dh) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #0 because y cannot accommodate the value 14.424; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #3 because y cannot accommodate the value -12.0022; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #5 because y cannot accommodate the value 13.8261; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #6 because y cannot accommodate the value -14.9925; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 36 out-of-range events; [#1] INFO:DataHandling -- RooDataSet::read: reading file rf102_testData.txt; [#1] INFO:DataHandling -- RooDataSet::read: read 64 events (ignored 0 out of range events); DataStore dataset (rf102_testData.txt); Contains 64 entries; Observables: ; 1) x = 9.46654 L(-10 - 10) ""x""; 2) y = 0.0174204 L(-10 - 10) ""y""; 3) blindState = Normal(idx = 0); ""Blinding State""; 1) RooRealVar:: y = 0.0106407; 2) RooRealVar:: x = -0.79919; 1) RooRealVar:: x = 0.0106407; 2) RooRealVar:: y = -0.79919; 3) RooCategory:: blindState = Normal(idx = 0); ; RooDataSet::ds[y,x] = 64 entries; ; -----------------------; Reading data from ASCII; ; Original data, lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf102__dataimport_8py.html:6819,load,loadValues,6819,doc/master/rf102__dataimport_8py.html,https://root.cern,https://root.cern/doc/master/rf102__dataimport_8py.html,1,['load'],['loadValues']
Performance,".423 5.19 3.54 | 3.006 3.034; : datasetreg PDEFoam : 8.35e-07 0.106 8.04 6.57 | 2.488 2.579; : datasetreg LD :-1.03e-06 1.54 20.1 18.5 | 2.134 2.153; : --------------------------------------------------------------------------------------------------; : ; Dataset:datasetreg : Created tree 'TestTree' with 9000 events; : ; Dataset:datasetreg : Created tree 'TrainTree' with 1000 events; : ; Factory : ␛[1mThank you for using TMVA!␛[0m; : ␛[1mFor citation information, please visit: http://tmva.sf.net/citeTMVA.html␛[0m; ==> Wrote root file: TMVAReg.root; ==> TMVARegression is done!; ; #include <cstdlib>; #include <iostream>; #include <map>; #include <string>; ; #include ""TChain.h""; #include ""TFile.h""; #include ""TTree.h""; #include ""TString.h""; #include ""TObjString.h""; #include ""TSystem.h""; #include ""TROOT.h""; ; #include ""TMVA/Tools.h""; #include ""TMVA/Factory.h""; #include ""TMVA/DataLoader.h""; #include ""TMVA/TMVARegGui.h""; ; ; using namespace TMVA;; ; void TMVARegression( TString myMethodList = """" ); {; // The explicit loading of the shared libTMVA is done in TMVAlogon.C, defined in .rootrc; // if you use your private .rootrc, or run from a different directory, please copy the; // corresponding lines from .rootrc; ; // methods to be processed can be given as an argument; use format:; //; // mylinux~> root -l TMVARegression.C\‍(\""myMethod1,myMethod2,myMethod3\""\‍); //; ; //---------------------------------------------------------------; // This loads the library; TMVA::Tools::Instance();; ; ; ; // Default MVA methods to be trained + tested; std::map<std::string,int> Use;; ; // Mutidimensional likelihood and Nearest-Neighbour methods; Use[""PDERS""] = 0;; Use[""PDEFoam""] = 1;; Use[""KNN""] = 1;; //; // Linear Discriminant Analysis; Use[""LD""] = 1;; //; // Function Discriminant analysis; Use[""FDA_GA""] = 0;; Use[""FDA_MC""] = 0;; Use[""FDA_MT""] = 0;; Use[""FDA_GAMT""] = 0;; //; // Neural Network; Use[""MLP""] = 0;; // Deep neural network (with CPU or GPU); #ifdef R__HAS_TMVAGPU; Use[""DNN_GPU""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:134875,load,loading,134875,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['load'],['loading']
Performance,".924) 0.942 (0.933) 0.866 (0.887) - ; : ; : -------------------------------------------------------------------------------------------------------; : ; Dataset:dataset : Created tree 'TestTree' with 4000 events; : ; Dataset:dataset : Created tree 'TrainTree' with 4000 events; : ; Factory : ␛[1mThank you for using TMVA!␛[0m; : ␛[1mFor citation information, please visit: http://tmva.sf.net/citeTMVA.html␛[0m; ==> Wrote root file: TMVAMulticlass.root; ==> TMVAMulticlass is done!; ; #include <cstdlib>; #include <iostream>; #include <map>; #include <string>; ; #include ""TFile.h""; #include ""TTree.h""; #include ""TString.h""; #include ""TSystem.h""; #include ""TROOT.h""; ; ; #include ""TMVA/Tools.h""; #include ""TMVA/Factory.h""; #include ""TMVA/DataLoader.h""; #include ""TMVA/TMVAMultiClassGui.h""; ; ; using namespace TMVA;; ; void TMVAMulticlass( TString myMethodList = """" ); {; ; // This loads the library; TMVA::Tools::Instance();; ; // to get access to the GUI and all tmva macros; //; // TString tmva_dir(TString(gRootDir) + ""/tmva"");; // if(gSystem->Getenv(""TMVASYS"")); // tmva_dir = TString(gSystem->Getenv(""TMVASYS""));; // gROOT->SetMacroPath(tmva_dir + ""/test/:"" + gROOT->GetMacroPath() );; // gROOT->ProcessLine("".L TMVAMultiClassGui.C"");; ; ; //---------------------------------------------------------------; // Default MVA methods to be trained + tested; std::map<std::string,int> Use;; Use[""MLP""] = 1;; Use[""BDTG""] = 1;; #ifdef R__HAS_TMVAGPU; Use[""DL_CPU""] = 1;; Use[""DL_GPU""] = 1;; #else; Use[""DL_CPU""] = 1;; Use[""DL_GPU""] = 0;; #endif; Use[""FDA_GA""] = 0;; Use[""PDEFoam""] = 1;; ; //---------------------------------------------------------------; ; std::cout << std::endl;; std::cout << ""==> Start TMVAMulticlass"" << std::endl;; ; if (myMethodList != """") {; for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) it->second = 0;; ; std::vector<TString> mlist = TMVA::gTools().SplitString( myMethodList, ',' );; for (UInt_t i=0; i<mlist.size(); i++) {; std::string re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:31792,load,loads,31792,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['load'],['loads']
Performance,".; 1617 ; 1618TCling::~TCling(); 1619{; 1620 // ROOT's atexit functions require the interepreter to be available.; 1621 // Run them before shutting down.; 1622 if (!IsFromRootCling()); 1623 GetInterpreterImpl()->runAtExitFuncs();; 1624 fIsShuttingDown = true;; 1625 delete fMapfile;; 1626 delete fRootmapFiles;; 1627 delete fTemporaries;; 1628 delete fNormalizedCtxt;; 1629 delete fLookupHelper;; 1630 gCling = nullptr;; 1631}; 1632 ; 1633////////////////////////////////////////////////////////////////////////////////; 1634/// Initialize the interpreter, once TROOT::fInterpreter is set.; 1635 ; 1636void TCling::Initialize(); 1637{; 1638 fClingCallbacks->Initialize();; 1639 ; 1640 // We are set up. Enable ROOT's AutoLoading.; 1641 if (IsFromRootCling()); 1642 return;; 1643 ; 1644 // Read the rules before enabling the auto loading to not inadvertently; 1645 // load the libraries for the classes concerned even-though the user is; 1646 // *not* using them.; 1647 // Note this call must happen before the first call to LoadLibraryMap.; 1648 assert(GetRootMapFiles() == nullptr && ""Must be called before LoadLibraryMap!"");; 1649 TClass::ReadRules(); // Read the default customization rules ...; 1650 ; 1651 LoadLibraryMap();; 1652 SetClassAutoLoading(true);; 1653}; 1654 ; 1655void TCling::ShutDown(); 1656{; 1657 fIsShuttingDown = true;; 1658 ResetGlobals();; 1659}; 1660 ; 1661////////////////////////////////////////////////////////////////////////////////; 1662/// Helper to initialize TVirtualStreamerInfo's factor early.; 1663/// Use static initialization to insure only one TStreamerInfo is created.; 1664static bool R__InitStreamerInfoFactory(); 1665{; 1666 // Use lambda since SetFactory return void.; 1667 auto setFactory = []() {; 1668 TVirtualStreamerInfo::SetFactory(new TStreamerInfo());; 1669 return kTRUE;; 1670 };; 1671 static bool doneFactory = setFactory();; 1672 return doneFactory; // avoid unused variable warning.; 1673}; 1674 ; 1675/////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:61737,Load,LoadLibraryMap,61737,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['LoadLibraryMap']
Performance,".; 895 ; 896void ROOT::AddClass(const char *cname, Version_t id,; 897 const std::type_info& info,; 898 DictFuncPtr_t dict,; 899 Int_t pragmabits); 900{; 901 if (!TROOT::Initialized() && !gClassTable) {; 902 auto r = std::unique_ptr<TClassRec>(new TClassRec(nullptr));; 903 r->fName = StrDup(cname);; 904 r->fId = id;; 905 r->fBits = pragmabits;; 906 r->fDict = dict;; 907 r->fInfo = &info;; 908 GetDelayedAddClass().emplace_back(std::move(r));; 909 } else {; 910 TClassTable::Add(cname, id, info, dict, pragmabits);; 911 }; 912}; 913 ; 914////////////////////////////////////////////////////////////////////////////////; 915/// Global function called by GenerateInitInstance.; 916/// (see the ClassImp macro).; 917 ; 918ROOT::TClassAlt* ROOT::AddClassAlternate(const char *normName, const char *alternate); 919{; 920 if (!TROOT::Initialized() && !gClassTable) {; 921 GetDelayedAddClassAlternate().emplace_back(normName, alternate);; 922 // If a library is loaded before gROOT is initialized we can assume; 923 // it is hard linked along side libCore (or is libCore) thus can't; 924 // really be unloaded.; 925 return nullptr;; 926 } else {; 927 return TClassTable::AddAlternate(normName, alternate);; 928 }; 929}; 930 ; 931void ROOT::RemoveClassAlternate(TClassAlt *alt); 932{; 933 // This routine is meant to be called (indirectly) by dlclose so we; 934 // we are guaranteed that the library initialization has completed.; 935 TClassTable::RemoveAlternate(alt);; 936}; 937 ; 938////////////////////////////////////////////////////////////////////////////////; 939/// Global function to update the version number.; 940/// This is called via the RootClassVersion macro.; 941///; 942/// if cl!=0 and cname==-1, set the new class version if and only is; 943/// greater than the existing one and greater or equal to 2;; 944/// and also ignore the request if fVersionUsed is true.; 945///; 946/// Note on class version number:; 947/// - If no class has been specified, TClass::GetVersion will return -1; 94",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClassTable_8cxx_source.html:29799,load,loaded,29799,doc/master/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html,2,['load'],['loaded']
Performance,".; Definition at line 438 of file TFormLeafInfo.cxx. ◆ HasCounter(). bool TFormLeafInfo::HasCounter ; (; ); const. virtual . Return true if any of underlying data has a array size counter. ; Reimplemented in TFormLeafInfoCollection, and TFormLeafInfoReference.; Definition at line 341 of file TFormLeafInfo.cxx. ◆ IsInteger(). bool TFormLeafInfo::IsInteger ; (; ); const. virtual . Return true if the underlying data is an integral value. ; Reimplemented in TFormLeafInfoMethod, and TFormLeafInfoReference.; Definition at line 374 of file TFormLeafInfo.cxx. ◆ IsReference(). virtual bool TFormLeafInfo::IsReference ; (; ); const. inlinevirtual . Reimplemented in TFormLeafInfoReference.; Definition at line 99 of file TFormLeafInfo.h. ◆ IsString(). bool TFormLeafInfo::IsString ; (; ); const. virtual . Return true if the underlying data is a string. ; Reimplemented in TFormLeafInfoNumerical, TFormLeafInfoMethod, and TFormLeafInfoReference.; Definition at line 351 of file TFormLeafInfo.cxx. ◆ LoadSizes(). void TFormLeafInfo::LoadSizes ; (; TBranch * ; branch). virtual . Load the current array sizes. ; Reimplemented in TFormLeafInfoMultiVarDim, TFormLeafInfoMultiVarDimCollection, and TFormLeafInfoMultiVarDimClones.; Definition at line 467 of file TFormLeafInfo.cxx. ◆ operator=(). TFormLeafInfo & TFormLeafInfo::operator= ; (; const TFormLeafInfo & ; orig). Exception safe assignment operator. ; Definition at line 98 of file TFormLeafInfo.cxx. ◆ ReadCounterValue(). Int_t TFormLeafInfo::ReadCounterValue ; (; char * ; where). virtual . Return the size of the underlying array for the current entry in the TTree. ; Reimplemented in TFormLeafInfoClones, TFormLeafInfoCollection, and TFormLeafInfoReference.; Definition at line 588 of file TFormLeafInfo.cxx. ◆ ReadTypedValue(). template<typename T > . T TFormLeafInfo::ReadTypedValue ; (; char * ; where, . Int_t ; instance = 0 . ). inline . Definition at line 124 of file TFormLeafInfo.h. ◆ ReadValue(). virtual Double_t TFormLeafInfo::ReadValu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFormLeafInfo.html:25431,Load,LoadSizes,25431,doc/master/classTFormLeafInfo.html,https://root.cern,https://root.cern/doc/master/classTFormLeafInfo.html,1,['Load'],['LoadSizes']
Performance,".; Definition at line 62 of file RooObjCacheManager.h. ◆ operModeHook(). void RooObjCacheManager::operModeHook ; (; ). overridevirtual . Intercept changes to cache operation mode and forward to cache elements. ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 108 of file RooObjCacheManager.cxx. ◆ optimizeCacheMode(). void RooObjCacheManager::optimizeCacheMode ; (; const RooArgSet & ; obs, . RooArgSet & ; optNodes, . RooLinkedList & ; processedNodes . ). overridevirtual . Intercept calls to perform automatic optimization of cache mode operation. ; Forward calls to existing cache elements and save configuration of cache mode optimization so that it can be applied on new cache elements upon insertion ; Reimplemented from RooAbsCache.; Definition at line 129 of file RooObjCacheManager.cxx. ◆ printCompactTreeHook(). void RooObjCacheManager::printCompactTreeHook ; (; std::ostream & ; os, . const char * ; indent . ). overridevirtual . Add details on cache contents when printing in tree mode. ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 194 of file RooObjCacheManager.cxx. ◆ redirectServersHook(). bool RooObjCacheManager::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursive . ). overridevirtual . Intercept server redirect calls. ; If clearOnRedirect was set, sterilize the cache (i.e. keep the structure but delete all contents). If not forward serverRedirect to cache elements ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 84 of file RooObjCacheManager.cxx. ◆ setClearOnRedirect(). void RooObjCacheManager::setClearOnRedirect ; (; bool ; flag). inline . Definition at line 50 of file RooObjCacheManager.h. ◆ sterilize(). void RooObjCacheManager::sterilize ; (; ). overridevirtual . Clear the cache payload but retain slot mapping w.r.t to normalization and integration sets. ; Reimplemented from RooCacheMana",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:10793,cache,cache,10793,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,1,['cache'],['cache']
Performance,".; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY flag. TGeoVolume * Volume(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t npar = 0); Create a volume in GEANT3 style.; NAME Volume name; SHAPE Volume type; NMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters. TGeoVolume * Volume(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t npar = 0); Create a volume in GEANT3 style.; NAME Volume name; SHAPE Volume type; NMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters. void SetAllIndex(); Assigns uid's for all materials,media and matrices. void ClearAttributes(); Reset all attributes to default ones. Default attributes for visualization; are those defined before closing the geometry. void CloseGeometry(Option_t* option = ""d""); Closing geometry implies checking the geometry validity, fixing shapes; with negative parameters (run-time shapes)building the cache manager,; voxelizing all volumes, counting the total number of physical nodes and; registring the manager class to the browser. void ClearOverlaps(); Clear the list of overlaps. void ClearShape(const TGeoShape* shape); Remove a shape from the list of shapes. void CleanGarbage(); Clean temporary volumes and shapes from garbage collection. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Int_t GetCurrentNodeId() const; Get the unique ID of the current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accord",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:43668,cache,cache,43668,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,6,['cache'],['cache']
Performance,".; Reimplemented in TProofPlayerRemote.; Definition at line 724 of file TProofPlayer.cxx. ◆ FeedBackCanvas(). void TProofPlayer::FeedBackCanvas ; (; const char * ; name, . Bool_t ; create . ). Create/destroy a named canvas for feedback. ; Definition at line 1765 of file TProofPlayer.cxx. ◆ Finalize() [1/2]. Long64_t TProofPlayer::Finalize ; (; Bool_t ; force = kFALSE, . Bool_t ; sync = kFALSE . ). overridevirtual . Finalize query (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote, and TProofPlayerLite.; Definition at line 1571 of file TProofPlayer.cxx. ◆ Finalize() [2/2]. Long64_t TProofPlayer::Finalize ; (; TQueryResult * ; qr). overridevirtual . Finalize query (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote, and TProofPlayerLite.; Definition at line 1580 of file TProofPlayer.cxx. ◆ GetCacheSize(). Long64_t TProofPlayer::GetCacheSize ; (; ). overridevirtual . Return the size in bytes of the cache. ; Implements TVirtualProofPlayer.; Definition at line 1796 of file TProofPlayer.cxx. ◆ GetCurrentQuery(). TQueryResult * TProofPlayer::GetCurrentQuery ; (; ); const. inlineoverridevirtual . Implements TVirtualProofPlayer.; Definition at line 164 of file TProofPlayer.h. ◆ GetDrawArgs(). Int_t TProofPlayer::GetDrawArgs ; (; const char * ; var, . const char * ; sel, . Option_t * ; opt, . TString & ; selector, . TString & ; objname . ). overridevirtual . Parse the arguments from var, sel and opt and fill the selector and object name accordingly. ; Return 0 in case of success, 1 if libProofDraw is not available. ; Implements TVirtualProofPlayer.; Definition at line 1730 of file TProofPlayer.cxx. ◆ GetEventsProcessed(). Long64_t TProofPlayer::GetEventsProcessed ; (; ); const. inlineoverridevirtual . Implements TVirtualProofPlayer.; Definition at line 206 of file TProofPlayer.h. ◆ GetExitStatus(). EExitStatus TProofPlayer::GetExitStatus ; (; ); const. inlineoverridevirtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:29514,cache,cache,29514,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['cache'],['cache']
Performance,".; The left side of the bar is drawn with a light fill color.; The right side of the bar is drawn with a dark fill color.; The percentage of the bar drawn with either the light or dark color is:. 0% for option ""(h)bar"" or ""(h)bar0""; 10% for option ""(h)bar1""; 20% for option ""(h)bar2""; 30% for option ""(h)bar3""; 40% for option ""(h)bar4"". Picture; Source. // Example of bar charts with 1-d histograms; // Author: Rene Brun; void hbars() {; cout << gSystem->DirName(__FILE__) << endl;; // try to open first the file cernstaff.root in tutorials/tree directory; TString filedir = gSystem->DirName(__FILE__);; filedir += TString(""/../tree/"");; TString filename = ""cernstaff.root"";; bool fileNotFound = gSystem->AccessPathName(filename); // note opposite return code; // if file is not found try to generate it uing the macro tree/cernbuild.C; if (fileNotFound) {; TString macroName = filedir + ""cernbuild.C"";; if (!gInterpreter->IsLoaded(macroName)) gInterpreter->LoadMacro(macroName);; gROOT->ProcessLineFast(""cernbuild()"");; }; TFile * f = TFile::Open(filename);; if (!f) {; Error(""hbars"",""file cernstaff.root not found"");; return;; }; TTree *T = (TTree*)f->Get(""T"");; if (!T) {; Error(""hbars"",""Tree T is not present in file %s"",f->GetName() );; return;; }; T->SetFillColor(45);; TCanvas *c1 = new TCanvas(""c1"",""histograms with bars"",700,800);; c1->SetFillColor(42);; c1->Divide(1,2);. //horizontal bar chart; c1->cd(1); gPad->SetGrid(); gPad->SetLogx(); gPad->SetFrameFillColor(33);; T->Draw(""Nation"","""",""hbar2"");. //vertical bar chart; c1->cd(2); gPad->SetGrid(); gPad->SetFrameFillColor(33);; T->Draw(""Division>>hDiv"","""",""goff"");; TH1F *hDiv = (TH1F*)gDirectory->Get(""hDiv"");; hDiv->SetStats(0);; TH1F *hDivFR = (TH1F*)hDiv->Clone(""hDivFR"");; T->Draw(""Division>>hDivFR"",""Nation==\""FR\"""",""goff"");; hDiv->SetBarWidth(0.45);; hDiv->SetBarOffset(0.1);; hDiv->SetFillColor(49);; TH1 *h1 = hDiv->DrawCopy(""bar2"");; hDivFR->SetBarWidth(0.4);; hDivFR->SetBarOffset(0.55);; hDivFR->SetFillColor(50);; TH1 *h2 =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THistPainter.html:24129,Load,LoadMacro,24129,root/html602/THistPainter.html,https://root.cern,https://root.cern/root/html602/THistPainter.html,1,['Load'],['LoadMacro']
Performance,".; Through the function TSystem::SetMakeSharedLib(), the user will be able to indicate, with shell commands, how to build a shared library (a good default will be provided). The most common change, namely where to find header files, will be available through the function TSystem::SetIncludePath(). A good default will be provided so that a typical user session should be at most: root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::SetIncludePathvirtual void SetIncludePath(const char *includePath)IncludePath should contain the list of compiler flags to indicate where to find user defined header f...Definition TSystem.cxx:4194; The user may sometimes try to compile a script before it has loaded all the needed shared libraries. In this case we want to be helpful and output a list of the unresolved symbols. So if the loading of the created shared library fails, we will try to build a executable that contains the script. The linker should then output a list of missing symbols.; To support this we provide a TSystem::SetMakeExe() function, that sets the directive telling how to create an executable. The loader will need to be informed of all the libraries available. The information about the libraries that has been loaded by .L and TSystem::Load() is accessible to the script compiler. However, the information about the libraries that have been selected at link time by the application builder (like the root libraries for root.exe) are not available and need to be explicitly listed in fLinkedLibs (either by default or by a call to TSystem::SetLinkedLibs()).; To simplify customization we could also add to the .rootrc support for the variables Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include; ; Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....; I#d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:44993,load,loading,44993,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['load'],['loading']
Performance,".; know options: VariableTransform=None,Decorrelated,PCA to use transformed variables; instead of the original ones; VariableTransformType=Signal,Background which decorrelation matrix to use; in the method. Only the Likelihood; Method can make proper use of independent; transformations of signal and background; fNbinsMVAPdf = 50 Number of bins used to create a PDF of MVA; fNsmoothMVAPdf = 2 Number of times a histogram is smoothed before creating the PDF; fHasMVAPdfs create PDFs for the MVA outputs; V for Verbose output (!V) for non verbos; H for Help message. void ProcessBaseOptions(); the option string is decoded, for availabel options see ""DeclareOptions"". void CreateVariableTransforms(const TString& trafoDefinition, TMVA::DataSetInfo& dataInfo, TMVA::TransformationHandler& transformationHandler, TMVA::MsgLogger& log); create variable transformations. void DeclareCompatibilityOptions(). std::map<TString,Double_t> OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); call the Optimzier with the set of paremeters and ranges that; are meant to be tuned. void SetTuneParameters(map<TString,Double_t> tuneParameters); set the tuning parameters accoding to the argument; This is just a dummy .. have a look at the MethodBDT how you could; perhaps implment the same thing for the other Classifiers.. void TrainMethod(). void GetRegressionDeviation(UInt_t tgtNum, TMVA::Types::ETreeType type, Double_t& stddev, Double_t& stddev90Percent) const. void AddRegressionOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddMulticlassOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void NoErrorCalc(Double_t *const err, Double_t *const errUpper). Double_t GetMvaValue(const TMVA::Event *const ev, Double_t* err = 0, Double_t* errUpper = 0). Bool_t IsSignalLike(). Bool_t IsSignalLike(Double_t mvaVal). void AddClassifierOutput(TMVA::Types::ETreeType type); pre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodBase.html:21905,Optimiz,OptimizeTuningParameters,21905,root/html530/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodBase.html,4,"['Optimiz', 'tune']","['OptimizeTuningParameters', 'tuned']"
Performance,".AddLine(""model.add(Dense(64, activation='relu'))"");; m.AddLine(""model.add(Dense(64, activation='relu'))"");; m.AddLine(""model.add(Dense(64, activation='relu'))"");; m.AddLine(""model.add(Dense(2, activation='sigmoid'))"");; m.AddLine(""model.compile(loss = 'binary_crossentropy', optimizer = Adam(learning_rate = 0.001), weighted_metrics = ['accuracy'])"");; m.AddLine(""model.save('Higgs_model.h5')"");; m.AddLine(""model.summary()"");; ; m.SaveSource(""make_higgs_model.py"");; // execute; auto ret = (TString *)gROOT->ProcessLine(""TMVA::Python_Executable()"");; TString python_exe = (ret) ? *(ret) : ""python"";; gSystem->Exec(python_exe + "" make_higgs_model.py"");; ; if (gSystem->AccessPathName(""Higgs_model.h5"")) {; Warning(""TMVA_Higgs_Classification"", ""Error creating Keras model file - skip using Keras"");; } else {; // book PyKeras method only if Keras model could be created; Info(""TMVA_Higgs_Classification"", ""Booking tf.Keras Dense model"");; factory.BookMethod(; loader, TMVA::Types::kPyKeras, ""PyKeras"",; ""H:!V:VarTransform=None:FilenameModel=Higgs_model.h5:tf.keras:""; ""FilenameTrainedModel=Higgs_trained_model.h5:NumEpochs=20:BatchSize=100:""; ""GpuOptions=allow_growth=True""); // needed for RTX NVidia card and to avoid TF allocates all GPU memory; }; }; ; /**; ## Train Methods; ; Here we train all the previously booked methods.; ; */; ; factory.TrainAllMethods();; ; /**; ## Test all methods; ; Now we test and evaluate all methods using the test data set; */; ; factory.TestAllMethods();; ; factory.EvaluateAllMethods();; ; /// after we get the ROC curve and we display; ; auto c1 = factory.GetROCCurve(loader);; c1->Draw();; ; /// at the end we close the output file which contains the evaluation result of all methods and it can be used by TMVAGUI; /// to display additional plots; ; outputFile->Close();; ; ; }; Double_tdouble Double_tDefinition RtypesCore.h:59; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:68795,load,loader,68795,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['load'],['loader']
Performance,".Definition DataRange.h:35; ROOT::Fit::DataRange::AddRangevoid AddRange(unsigned int icoord, double xmin, double xmax)add a range [xmin,xmax] for the new coordinate icoord Adding a range does not delete existing one,...Definition DataRange.cxx:94; ROOT::Fit::DataRange::Sizeunsigned int Size(unsigned int icoord=0) constreturn range size for coordinate icoord (starts from zero) Size == 0 indicates no range is present [-...Definition DataRange.h:71; ROOT::Fit::DataRange::GetRangevoid GetRange(unsigned int irange, unsigned int icoord, double &xmin, double &xmax) constget the i-th range for given coordinate.Definition DataRange.h:104; ROOT::Fit::FitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::SetMinosErrorsvoid SetMinosErrors(bool on=true)set Minos errors computation to be performed after fittingDefinition FitConfig.h:229; ROOT::Fit::FitConfig::SetNormErrorsvoid SetNormErrors(bool on=true)set the option to normalize the error on the result according to chi2/ndfDefinition FitConfig.h:223; ROOT::Fit::FitConfig::NormalizeErrorsbool NormalizeErrors() constflag to check if resulting errors are be normalized according to chi2/ndfDefinition FitConfig.h:202; ROOT::Fit::FitConfig::SetMinimizerOptionsvoid SetMinimizerOptions(const ROOT::Math::MinimizerOptions &minopt)set all the minimizer options using class MinimizerOptionsDefinition FitConfig.cxx:257; ROOT::Fit::FitConfig::SetWeightCorrectionvoid SetWeightCorrection(bool on=true)apply the weight correction for error matrix computationDefinition FitConfig.h:232; ROOT::Fit::FitConfig::SetParabErrorsvoid SetParabErrors(bool on=true)set parabolic errorsDefinition FitConfig.h:226; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer pack",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitImpl_8cxx_source.html:46048,perform,performed,46048,doc/master/HFitImpl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitImpl_8cxx_source.html,1,['perform'],['performed']
Performance,".Definition JSONIO.h:26; TMVA_SOFIE_GNN_Parser.treetreeDefinition TMVA_SOFIE_GNN_Parser.py:169; rf102_dataimportDefinition rf102_dataimport.py:1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_dh) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #0 because y cannot accommodate the value 14.424; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #3 because y cannot accommodate the value -12.0022; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #5 because y cannot accommodate the value 13.8261; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #6 because y cannot accommodate the value -14.9925; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 36 out-of-range events; ; -----------------------; Reading data from ASCII; [#1] INFO:DataHandling -- RooDataSet::read: reading file rf102_testData.txt; [#1] INFO:DataHandling -- RooDataSet::read: read 64 events (ignored 0 out of range events); DataStore dataset (rf102_testData.txt); Contains 64 entries; Observables: ; 1) x = 0.0174204 L(-10 - 10) ""x""; 2) y = 9.46654 L(-10 - 10) ""y""; 3) blindState = Normal(idx = 0); ""Blinding State""; ; Original data, line 20:; 1) RooRealVar:: x = -0.79919; 2) RooRealVar:: y = 0.0106407; ; Read-back data, line 20:; 1) RooRealVar:: x = -0.79919; 2) RooRealVar:: y = 0.0106407; 3) RooCategory:: blindState = Normal(idx = 0); ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf102__dataimport_8C.html:11032,load,loadValues,11032,doc/master/rf102__dataimport_8C.html,https://root.cern,https://root.cern/doc/master/rf102__dataimport_8C.html,1,['load'],['loadValues']
Performance,".Definition TClass.h:81; TClass::AddClassstatic void AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TClass.cxx:494; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5749; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::RemoveClassstatic void RemoveClass(TClass *cl)static: Remove a class from the list and map of classesDefinition TClass.cxx:520; TClass::GetClassInfoClassInfo_t * GetClassInfo() constDefinition TClass.h:433; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4874; TClass::GetDeclFileNameconst char * GetDeclFileName() constReturn name of the file containing the declaration of this class.Definition TClass.cxx:3463; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:2968; TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TCollection.cxx:574; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::AddAllvirtual void AddAll(const TCollection *col)Add all objects from collection col to this collection.Definition TCollection.cxx:195; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TCollection::Addvirtual void Add(TObject *obj)=0; TCollection::FindObjectTObject * FindObject(const char *name) const over",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:131648,load,load,131648,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,1,['load'],['load']
Performance,".Definition TClass.h:81; TClass::AddClassstatic void AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TClass.cxx:555; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5816; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::RemoveClassstatic void RemoveClass(TClass *cl)static: Remove a class from the list and map of classesDefinition TClass.cxx:585; TClass::GetClassInfoClassInfo_t * GetClassInfo() constDefinition TClass.h:433; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetDeclFileNameconst char * GetDeclFileName() constReturn name of the file containing the declaration of this class.Definition TClass.cxx:3530; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TCollection.cxx:574; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::AddAllvirtual void AddAll(const TCollection *col)Add all objects from collection col to this collection.Definition TCollection.cxx:195; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TCollection::Addvirtual void Add(TObject *obj)=0; TCollection::FindObjectTObject * FindObject(const char *name) const over",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:131824,load,load,131824,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['load'],['load']
Performance,".Filter(""x>1""));; ROOT::RDF::Experimental::AddProgressBar(df_1);; ROOT::RDF::RNodeRInterface<::ROOT::Detail::RDF::RNodeBase, void > RNodeDefinition InterfaceUtils.hxx:57; Examples of implemented progress bars can be seen by running Higgs to Four Lepton tutorial and Dimuon tutorial. Efficient analysis in Python; You can use RDataFrame in Python thanks to the dynamic Python/C++ translation of PyROOT. In general, the interface is the same as for C++, a simple example follows.; df = ROOT.RDataFrame(""myTree"", ""myFile.root""); sum = df.Filter(""x > 10"").Sum(""y""); print(sum.GetValue()). User code in the RDataFrame workflow; C++ code; In the simple example that was shown above, a C++ expression is passed to the Filter() operation as a string (""x > 0""), even if we call the method from Python. Indeed, under the hood, the analysis computations run in C++, while Python is just the interface language.; To perform more complex operations that don't fit into a simple expression string, you can just-in-time compile C++ functions - via the C++ interpreter cling - and use those functions in an expression. See the following snippet for an example:; # JIT a C++ function from Python; ROOT.gInterpreter.Declare(""""""; bool myFilter(float x) {; return x > 10;; }; """"""); ; df = ROOT.RDataFrame(""myTree"", ""myFile.root""); # Use the function in an RDF operation; sum = df.Filter(""myFilter(x)"").Sum(""y""); print(sum.GetValue()); To increase the performance even further, you can also pre-compile a C++ library with full code optimizations and load the function into the RDataFrame computation as follows.; ROOT.gSystem.Load(""path/to/myLibrary.so"") # Library with the myFilter function; ROOT.gInterpreter.Declare('#include ""myLibrary.h""') # Header with the declaration of the myFilter function; df = ROOT.RDataFrame(""myTree"", ""myFile.root""); sum = df.Filter(""myFilter(x)"").Sum(""y""); print(sum.GetValue()); A more thorough explanation of how to use C++ code from Python can be found in the PyROOT manual.; Python code",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:80281,perform,perform,80281,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['perform'],['perform']
Performance,".Index(re) == kNPOS) continue;; 399 }; 400 object->ls(option);; 401 }; 402 TROOT::DecreaseDirLevel();; 403}; 404 ; 405////////////////////////////////////////////////////////////////////////////////; 406/// 'Notify' all objects in this collection.; 407Bool_t TCollection::Notify(); 408{; 409 Bool_t success = true;; 410 for (auto obj : *this) success &= obj->Notify();; 411 return success;; 412}; 413 ; 414////////////////////////////////////////////////////////////////////////////////; 415/// Paint all objects in this collection.; 416 ; 417void TCollection::Paint(Option_t *option); 418{; 419 this->R__FOR_EACH(TObject,Paint)(option);; 420}; 421 ; 422////////////////////////////////////////////////////////////////////////////////; 423/// Print the collection header.; 424 ; 425void TCollection::PrintCollectionHeader(Option_t*) const; 426{; 427 TROOT::IndentLevel();; 428 printf(""Collection name='%s', class='%s', size=%d\n"",; 429 GetName(), ClassName(), GetSize());; 430}; 431 ; 432////////////////////////////////////////////////////////////////////////////////; 433/// For given collection entry return the string that is used to; 434/// identify the object and, potentially, perform wildcard/regexp; 435/// filtering on.; 436 ; 437const char* TCollection::GetCollectionEntryName(TObject* entry) const; 438{; 439 return entry->GetName();; 440}; 441 ; 442////////////////////////////////////////////////////////////////////////////////; 443/// Print the collection entry.; 444 ; 445void TCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; 446{; 447 TCollection* coll = dynamic_cast<TCollection*>(entry);; 448 if (coll) {; 449 coll->Print(option, recurse);; 450 } else {; 451 TROOT::IndentLevel();; 452 entry->Print(option);; 453 }; 454}; 455 ; 456////////////////////////////////////////////////////////////////////////////////; 457/// Default print for collections, calls Print(option, 1).; 458/// This will print the collection header and Print() method",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8cxx_source.html:15011,perform,perform,15011,doc/master/TCollection_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html,1,['perform'],['perform']
Performance,".VectorMultiplication(v);; v = l * v;; v.Transform(l);; v *= l; // v = l*v; 17.5.5 Physics Vector Example; The test file $ROOTSYS/test/TestVectors.cxx is an example of using physics vectors. The vector classes are not loaded by default, and to run it, you will need to load libPhysics.so first:; root[] .L $ROOTSYS/lib/libPhysics.so; root[] .x TestVectors.cxx; To load the physics vector library in a ROOT application use:; gSystem->Load(""libPhysics"");; The example $ROOTSYS/test/TestVectors.cxx does not return much, especially if all went well, but when you look at the code you will find examples for many calls.; 18 The Geometry Package. The new ROOT geometry package is a tool for building, browsing, navigating and visualizing detector geometries. The code works standalone with respect to any tracking Monte-Carlo engine; therefore, it does not contain any constraints related to physics. However, the navigation features provided by the package are designed to optimize particle transport through complex geometries, working in correlation with simulation packages such as GEANT3, GEANT4 and FLUKA.; 18.1 Quick Start: Creating the “world”; This chapter will provide a detailed description on how to build valid geometries as well as the ways to optimize them. There are several components gluing together the geometrical model, but for the time being let us get used with the most basic concepts.; The basic bricks for building-up the model are called volumes.These represent the un-positioned pieces of the geometry puzzle. The difference is just that the relationship between the pieces is not defined by neighbors, but by containment. In other words, volumes are put one inside another making an in-depth hierarchy. From outside, the whole thing looks like a big pack that you can open finding out other smaller packs nicely arranged waiting to be opened at their turn. The biggest one containing all others defines the “world” of the model. We will often call this master reference system ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:875072,optimiz,optimize,875072,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['optimiz'],['optimize']
Performance,".add(Dropout(0.2)); model.add(Dense(2, activation=""sigmoid"")); model.compile(loss=""binary_crossentropy"", optimizer=Adam(learning_rate=0.001), weighted_metrics=[""accuracy""]); model.save(""model_cnn.h5""); model.summary(); ; if not os.path.exists(""model_cnn.h5""):; raise FileNotFoundError(""Error creating Keras model file - skip using Keras""); else:; # book PyKeras method only if Keras model could be created; ROOT.Info(""TMVA_CNN_Classification"", ""Booking convolutional keras model""); factory.BookMethod(; loader,; TMVA.Types.kPyKeras,; ""PyKeras"",; H=True,; V=False,; VarTransform=None,; FilenameModel=""model_cnn.h5"",; FilenameTrainedModel=""trained_model_cnn.h5"",; NumEpochs=max_epochs,; BatchSize=100,; GpuOptions=""allow_growth=True"",; ) # needed for RTX NVidia card and to avoid TF allocates all GPU memory; ; ; ; ## Train Methods; ; factory.TrainAllMethods(); ; ## Test and Evaluate Methods; ; factory.TestAllMethods(); ; factory.EvaluateAllMethods(); ; ## Plot ROC Curve; ; c1 = factory.GetROCCurve(loader); c1.Draw(); ; # close outputfile to save output file; outputFile.Close(); lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t UChar_t lenDefinition TGWin32VirtualXProxy.cxx:249; formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html:15927,load,loader,15927,doc/master/TMVA__CNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html,1,['load'],['loader']
Performance,".cpp}; 222 Font number TTF Names PostScript/PDF Names; 223 1 : ""Free Serif Italic"" ""Times-Italic""; 224 2 : ""Free Serif Bold"" ""Times-Bold""; 225 3 : ""Free Serif Bold Italic"" ""Times-BoldItalic""; 226 4 : ""Tex Gyre Regular"" ""Helvetica""; 227 5 : ""Tex Gyre Italic"" ""Helvetica-Oblique""; 228 6 : ""Tex Gyre Bold"" ""Helvetica-Bold""; 229 7 : ""Tex Gyre Bold Italic"" ""Helvetica-BoldOblique""; 230 8 : ""Free Mono"" ""Courier""; 231 9 : ""Free Mono Oblique"" ""Courier-Oblique""; 232 10 : ""Free Mono Bold"" ""Courier-Bold""; 233 11 : ""Free Mono Bold Oblique"" ""Courier-BoldOblique""; 234 12 : ""Symbol"" ""Symbol""; 235 13 : ""Free Serif"" ""Times-Roman""; 236 14 : ""Wingdings"" ""ZapfDingbats""; 237~~~; 238 ; 239The PostScript and PDF backends use the original PostScript-defined 13 fonts' styles; 240forming four type families (Courier, Helvetica, Times, Symbol) as listed in the; 241""Core Font Set"" section of [this page](https://en.wikipedia.org/wiki/PostScript_fonts).; 242These fonts are always available and do not need to be loaded in the PS or PDF files; 243allowing to keep the files' sizes small.; 244 ; 245On screen, text is rendered using free TTF fonts similar to the PDF ones. The corresponding; 246font files are coming with the ROOT distribution in `$ROOTSYS/fonts/Free*`.; 247 ; 248Begin_Macro; 249fonts.C; 250End_Macro; 251*/; 252 ; 253////////////////////////////////////////////////////////////////////////////////; 254/// AttText default constructor.; 255///; 256/// Default text attributes are taken from the current style.; 257 ; 258TAttText::TAttText(); 259{; 260 if (!gStyle) {; 261 ResetAttText();; 262 return;; 263 }; 264 fTextAlign = gStyle->GetTextAlign();; 265 fTextAngle = gStyle->GetTextAngle();; 266 fTextColor = gStyle->GetTextColor();; 267 fTextFont = gStyle->GetTextFont();; 268 fTextSize = gStyle->GetTextSize();; 269}; 270 ; 271////////////////////////////////////////////////////////////////////////////////; 272/// AttText normal constructor.; 273///; 274/// Text attributes are taken from the argum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TAttText_8cxx_source.html:8397,load,loaded,8397,doc/master/TAttText_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TAttText_8cxx_source.html,1,['load'],['loaded']
Performance,".cxx. ◆ EnableParBranchProcessing(). void ROOT::Internal::EnableParBranchProcessing ; (; ). Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in ROOT, activating the required locks. ; This IMT use case, implemented in TTree::GetEntry, spawns a task for each branch of the tree. Therefore, a task takes care of the reading, decompression and deserialisation of a given branch. ; Definition at line 420 of file TROOT.cxx. ◆ GenericShowMembers(). void ROOT::Internal::GenericShowMembers ; (; const char * ; topClassName, . void * ; obj, . TMemberInspector & ; R__insp, . bool ; transientMember . ). inline . Definition at line 24 of file RtypesImp.h. ◆ GetArrayType(). TString ROOT::Internal::GetArrayType ; (; TStreamerElement * ; element, . const char * ; subtype, . TTreeProxyGenerator::EContainer ; container . ). Definition at line 131 of file TTreeProxyGenerator.cxx. ◆ GetClassHelper() [1/2]. template<typename T > . TClass * ROOT::Internal::GetClassHelper ; (; Bool_t ; load, . Bool_t ; silent, . std::false_type ;  . ). Definition at line 646 of file TClass.h. ◆ GetClassHelper() [2/2]. template<typename T > . TClass * ROOT::Internal::GetClassHelper ; (; Bool_t ; , . Bool_t ; , . std::true_type ;  . ). Definition at line 624 of file TClass.h. ◆ GetDemangledTypeName(). std::string ROOT::Internal::GetDemangledTypeName ; (; const std::type_info & ; t). Definition at line 30 of file TGenericClassInfo.cxx. ◆ GetErrorSystemMsgHandler(). ErrorSystemMsgHandlerFunc_t ROOT::Internal::GetErrorSystemMsgHandler ; (; ). Definition at line 51 of file TError.cxx. ◆ GetGlobalTaskArena(). std::shared_ptr< ROOT::Internal::RTaskArenaWrapper > ROOT::Internal::GetGlobalTaskArena ; (; unsigned ; maxConcurrency = 0). Factory function returning a shared pointer to the instance of the global RTaskArenaWrapper. ; Allows for reinstantiation of the global RTaskArenaWrapper once all the references to the previous one are gone and the object destroyed. ; Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html:33299,load,load,33299,doc/v632/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html,1,['load'],['load']
Performance,".cxx. ◆ ListSymbols(). void TSystem::ListSymbols ; (; const char * ; module, . const char * ; re = """" . ). virtual . List symbols in a shared library. ; Reimplemented in TUnixSystem.; Definition at line 2064 of file TSystem.cxx. ◆ Load(). int TSystem::Load ; (; const char * ; module, . const char * ; entry = """", . Bool_t ; system = kFALSE . ). virtual . Load a shared library. ; Returns 0 on successful loading, 1 in case lib was already loaded, -1 in case lib does not exist or in case of error and -2 in case of version mismatch. When entry is specified the loaded lib is searched for this entry point (return -1 when entry does not exist, 0 otherwise). When the system flag is kTRUE, the library is considered a permanent system library that should not be unloaded during the course of the session. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1857 of file TSystem.cxx. ◆ LoadAllLibraries(). UInt_t TSystem::LoadAllLibraries ; (; ). virtual . Load all libraries known to ROOT via the rootmap system. ; Returns the number of top level libraries successfully loaded. ; Definition at line 1970 of file TSystem.cxx. ◆ MakeDirectory(). int TSystem::MakeDirectory ; (; const char * ; name). virtual . Make a directory. ; Returns 0 in case of success and -1 if the directory could not be created (either already exists or illegal path name). ; Reimplemented in TDavixSystem, TNetXNGSystem, TUnixSystem, TWinNTSystem, TDCacheSystem, TNetSystem, and TWebSystem.; Definition at line 827 of file TSystem.cxx. ◆ mkdir(). int TSystem::mkdir ; (; const char * ; name, . Bool_t ; recursive = kFALSE . ). virtual . Make a file system directory. ; Returns 0 in case of success and -1 if the directory could not be created (either already exists or illegal path name). If 'recursive' is true, makes parent directories as needed. ; Reimplemented in TWinNTSystem.; Definition at line 906 of file TSystem.cxx. ◆ NextTimeOut(). Long_t TSystem::NextTimeOut ; (; Bool_t ; mode). virtual . Time w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:73696,Load,Load,73696,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['Load'],['Load']
Performance,".cxx. ◆ RetrieveFieldId(). ROOT::Experimental::DescriptorId_t ROOT::Experimental::RNTupleReader::RetrieveFieldId ; (; std::string_view ; fieldName); const. private . Definition at line 238 of file RNTupleReader.cxx. ◆ Show(). void ROOT::Experimental::RNTupleReader::Show ; (; NTupleSize_t ; index, . std::ostream & ; output = std::cout . ). Shows the values of the i-th entry/row, starting with 0 for the first entry. ; By default, prints the output in JSON format. Uses the visitor pattern to traverse through each field of the given entry. ; Definition at line 208 of file RNTupleReader.cxx. Member Data Documentation. ◆ fCachedDescriptor. std::unique_ptr<RNTupleDescriptor> ROOT::Experimental::RNTupleReader::fCachedDescriptor. private . The ntuple descriptor in the page source is protected by a read-write lock. ; We don't expose that to the users of RNTupleReader::GetDescriptor(). Instead, if descriptor information is needed, we clone the descriptor. Using the descriptor's generation number, we know if the cached descriptor is stale. Retrieving descriptor data from an RNTupleReader is supposed to be for testing and information purposes, not on a hot code path. ; Definition at line 89 of file RNTupleReader.hxx. ◆ fDisplayReader. std::unique_ptr<RNTupleReader> ROOT::Experimental::RNTupleReader::fDisplayReader. private . We use a dedicated on-demand reader for Show() and Scan(). ; Printing data uses all the fields from the full model even if the analysis code uses only a subset of fields. The display reader is a clone of the original reader. ; Definition at line 83 of file RNTupleReader.hxx. ◆ fMetrics. Detail::RNTupleMetrics ROOT::Experimental::RNTupleReader::fMetrics. private . Definition at line 90 of file RNTupleReader.hxx. ◆ fModel. std::unique_ptr<RNTupleModel> ROOT::Experimental::RNTupleReader::fModel. private . Needs to be destructed before fSource. ; Definition at line 79 of file RNTupleReader.hxx. ◆ fSource. std::unique_ptr<Internal::RPageSource> ROOT::Experimental:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html:18132,cache,cached,18132,doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,1,['cache'],['cached']
Performance,".cxx. ◆ TGeoNavigator() [3/3]. TGeoNavigator::TGeoNavigator ; (; TGeoManager * ; geom). Constructor. ; Definition at line 109 of file TGeoNavigator.cxx. ◆ ~TGeoNavigator(). TGeoNavigator::~TGeoNavigator ; (; ). override . Destructor. ; Definition at line 169 of file TGeoNavigator.cxx. Member Function Documentation. ◆ BuildCache(). void TGeoNavigator::BuildCache ; (; Bool_t ; dummy = kFALSE, . Bool_t ; nodeid = kFALSE . ). Builds the cache for physical nodes and global matrices. ; Definition at line 182 of file TGeoNavigator.cxx. ◆ cd(). Bool_t TGeoNavigator::cd ; (; const char * ; path = """"). Browse the tree of nodes starting from top node according to pathname. ; Changes the path accordingly. The path is changed to point to the top node in case of failure. ; Definition at line 210 of file TGeoNavigator.cxx. ◆ CdDown() [1/2]. void TGeoNavigator::CdDown ; (; Int_t ; index). Make a daughter of current node current. ; Can be called only with a valid daughter index (no check). Updates cache accordingly. ; Definition at line 313 of file TGeoNavigator.cxx. ◆ CdDown() [2/2]. void TGeoNavigator::CdDown ; (; TGeoNode * ; node). Make a daughter of current node current. ; Can be called only with a valid daughter node (no check). Updates cache accordingly. ; Definition at line 333 of file TGeoNavigator.cxx. ◆ CdNext(). void TGeoNavigator::CdNext ; (; ). Do a cd to the node found next by FindNextBoundary. ; Definition at line 405 of file TGeoNavigator.cxx. ◆ CdNode(). void TGeoNavigator::CdNode ; (; Int_t ; nodeid). Change current path to point to the node having this id. ; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons) ; Definition at line 301 of file TGeoNavigator.cxx. ◆ CdTop(). void TGeoNavigator::CdTop ; (; ). Make top level node the current node. ; Updates the cache accordingly. Determine the overlapping state of current node. ; Definition at line 386 of file TGeoNavigator.cxx. ◆ CdUp(). void TGeoNavigator::CdUp ; (; ). Go one level up in geo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:23676,cache,cache,23676,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['cache'],['cache']
Performance,".cxx. ◆ setCacheAndTrackHints(). virtual void RooAbsArg::setCacheAndTrackHints ; (; RooArgSet & ; ). inlinevirtual . Reimplemented in RooLagrangianMorphFunc, RooAbsAnaConvPdf, RooAddPdf, RooProdPdf, RooProduct, RooRealSumFunc, and RooRealSumPdf.; Definition at line 385 of file RooAbsArg.h. ◆ setCachedValue(). virtual void RooAbsArg::setCachedValue ; (; double ; , . bool ; = true . ). inlinevirtual . Overwrite the current value stored in this object, making it look like this object computed that value. ; recompute their values. ; Reimplemented in RooAbsCategory, and RooAbsReal.; Definition at line 481 of file RooAbsArg.h. ◆ setDataToken(). void RooAbsArg::setDataToken ; (; std::size_t ; index). Sets the token for retrieving results in the BatchMode. For internal use only. ; Definition at line 2555 of file RooAbsArg.cxx. ◆ setDirtyInhibit(). void RooAbsArg::setDirtyInhibit ; (; bool ; flag). static . Control global dirty inhibit mode. ; When set to true no value or shape dirty flags are propagated and cache is always considered to be dirty. ; Definition at line 204 of file RooAbsArg.cxx. ◆ setExpensiveObjectCache(). virtual void RooAbsArg::setExpensiveObjectCache ; (; RooExpensiveObjectCache & ; cache). inlinevirtual . Reimplemented in RooRealVar.; Definition at line 475 of file RooAbsArg.h. ◆ setLocalNoDirtyInhibit(). void RooAbsArg::setLocalNoDirtyInhibit ; (; bool ; flag); const. inline . Definition at line 674 of file RooAbsArg.h. ◆ SetName(). void RooAbsArg::SetName ; (; const char * ; name). overridevirtual . Set the name of the TNamed. ; WARNING: if the object is a member of a THashTable or THashList container the container must be Rehash()'ed after SetName(). For example the list of objects in the current directory is a THashList. ; Reimplemented from TNamed.; Definition at line 2367 of file RooAbsArg.cxx. ◆ SetNameTitle(). void RooAbsArg::SetNameTitle ; (; const char * ; name, . const char * ; title . ). overridevirtual . Set all the TNamed parameters (name a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:96923,cache,cache,96923,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['cache'],['cache']
Performance,".cxx. ◆ translateImpl(). std::string RooRealSumPdf::translateImpl ; (; RooFit::Detail::CodeSquashContext & ; ctx, . RooAbsArg const * ; klass, . RooArgList const & ; funcList, . RooArgList const & ; coefList, . bool ; normalize = false . ). staticprivate . Definition at line 300 of file RooRealSumPdf.cxx. Friends And Related Symbol Documentation. ◆ RooAddition. friend class RooAddition. friend . Definition at line 99 of file RooRealSumPdf.h. ◆ RooAddPdf. friend class RooAddPdf. friend . Definition at line 98 of file RooRealSumPdf.h. ◆ RooRealSumFunc. friend class RooRealSumFunc. friend . Definition at line 100 of file RooRealSumPdf.h. Member Data Documentation. ◆ _coefList. RooListProxy RooRealSumPdf::_coefList. protected . List of coefficients. ; Definition at line 89 of file RooRealSumPdf.h. ◆ _doFloor. bool RooRealSumPdf::_doFloor = false. protected . Introduce floor at zero in pdf. ; Definition at line 92 of file RooRealSumPdf.h. ◆ _doFloorGlobal. bool RooRealSumPdf::_doFloorGlobal = false. staticprotected . Global flag for introducing floor at zero in pdf. ; Definition at line 94 of file RooRealSumPdf.h. ◆ _extended. bool RooRealSumPdf::_extended. protected . Allow use as extended p.d.f. ; Definition at line 90 of file RooRealSumPdf.h. ◆ _funcList. RooListProxy RooRealSumPdf::_funcList. protected . List of component FUNCs. ; Definition at line 88 of file RooRealSumPdf.h. ◆ _haveWarned. bool RooRealSumPdf::_haveWarned {false}. mutableprotected . ! ; Definition at line 93 of file RooRealSumPdf.h. ◆ _normIntMgr. RooObjCacheManager RooRealSumPdf::_normIntMgr. mutableprotected . ! The integration cache manager ; Definition at line 85 of file RooRealSumPdf.h. Libraries for RooRealSumPdf:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooRealSumPdf.h; roofit/roofitcore/src/RooRealSumPdf.cxx. RooRealSumPdf. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:07 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealSumPdf.html:93197,cache,cache,93197,doc/master/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/master/classRooRealSumPdf.html,1,['cache'],['cache']
Performance,".cxx:48; ROOT::RBrowserDataCleanup::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from a list.Definition RBrowserData.cxx:50; ROOT::RBrowserDataWay to browse (hopefully) everything in ROOT.Definition RBrowserData.hxx:37; ROOT::RBrowserData::SetTopElementvoid SetTopElement(std::shared_ptr< Browsable::RElement > elem)set top element for browsingDefinition RBrowserData.cxx:88; ROOT::RBrowserData::fLastSortedItemsstd::vector< const Browsable::RItem * > fLastSortedItems! sorted child items, used in requestsDefinition RBrowserData.hxx:51; ROOT::RBrowserData::fWorkingPathBrowsable::RElementPath_t fWorkingPath! path showed in BreadcrumbDefinition RBrowserData.hxx:43; ROOT::RBrowserData::RemoveFromCachebool RemoveFromCache(void *obj)Remove object from cache If nullptr specified - removes no-longer-valid elements Returns true if any ...Definition RBrowserData.cxx:380; ROOT::RBrowserData::GetSubElementstd::shared_ptr< Browsable::RElement > GetSubElement(const Browsable::RElementPath_t &path)Returns sub-element starting from top, using cached data.Definition RBrowserData.cxx:308; ROOT::RBrowserData::fCachestd::vector< std::pair< Browsable::RElementPath_t, std::shared_ptr< Browsable::RElement > > > fCache! already requested elementsDefinition RBrowserData.hxx:45; ROOT::RBrowserData::fCleanupHandlestd::unique_ptr< TObject > fCleanupHandle! cleanup handle for RecursiveRemoveDefinition RBrowserData.hxx:54; ROOT::RBrowserData::DecomposePathBrowsable::RElementPath_t DecomposePath(const std::string &path, bool relative_to_work_element)Decompose path to elements Returns array of names for each element in the path, first element either ...Definition RBrowserData.cxx:155; ROOT::RBrowserData::fLastAllChildsbool fLastAllChilds! if all chlds were extractedDefinition RBrowserData.hxx:50; ROOT::RBrowserData::~RBrowserDatavirtual ~RBrowserData()Destructor.Definition RBrowserData.cxx:78; ROOT::RBrowserData::ProcessBrowserRequestbool ProcessBrowserReque",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RBrowserData_8cxx_source.html:16235,cache,cached,16235,doc/master/RBrowserData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RBrowserData_8cxx_source.html,2,['cache'],['cached']
Performance,".define() and JSROOT.require() functions only available after JSRoot.core.js loading; Support of require.js and openui5 loaders was removed; Global hierarchy painter JSROOT.hpainter no longer existing, one can use getHPainter function:. import { getHPainter } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let hpainter = getHPainter();. All math functions previously available via JSROOT.Math should be imported from base/math.mjs module:. import * as math from 'https://root.cern/js/7.0.0/modules/base/math.mjs';. Indication of batch mode JSROOT.batch_mode should be accessed via functions:. import { isBatchMode, setBatchMode } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let was_batch = isBatchMode();; if (!was_batch) setBatchMode(true);. JSROOT.extend() function was removed, use Object.assign() instead. 1.11.11 Migration v5 -> v6. Main script was renamed to JSRoot.core.js. Old JSRootCore.js was deprecated and removed in v6.2. All URL parameters for main script ignored now, to load JSROOT functionality one should use JSROOT.require function. To create standard GUI, JSROOT.buildGUI function has to be used.; Instead of JSROOT.JSONR_unref() one can use JSROOT.parse(). If object is provided to JSROOT.parse() it just replaces all references which were introduced by TBufferJSON::ToJSON() method.; Instead of JSROOT.console() one should use console.log(). Instead of JSROOT.alert() one should use console.error().; Many settings were moved from JSROOT.gStyle to JSROOT.settings object. It was done to keep only TStyle-related members in JSROOT.gStyle.; Basic painter classes were renamed and made public:. JSROOT.TBasePainter -> JSROOT.BasePainter; JSROOT.TObjectPainter -> JSROOT.ObjectPainter. Internal ObjectPainter.DrawingReady api was deprecated. Draw function has to return Promise if object drawing postponed. As argument of returned promise object painter has to be used.; Many function names where adjusted to naming conventions. Like:. JSROOT.CreateHistogram -> JSRO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:35808,load,load,35808,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['load'],['load']
Performance,".fPx[2];; 6694/// ~~~; 6695/// is executed by one of the method of the skeleton,; 6696/// somePx will updated with the current value of fPx of the 3rd track.; 6697///; 6698/// Both macrofilename and the optional cutfilename are expected to be; 6699/// the name of source files which contain at least a free standing; 6700/// function with the signature:; 6701/// ~~~ {.cpp}; 6702/// x_t macrofilename(); // i.e function with the same name as the file; 6703/// ~~~; 6704/// and; 6705/// ~~~ {.cpp}; 6706/// y_t cutfilename(); // i.e function with the same name as the file; 6707/// ~~~; 6708/// x_t and y_t needs to be types that can convert respectively to a double; 6709/// and a bool (because the skeleton uses:; 6710///; 6711/// if (cutfilename()) htemp->Fill(macrofilename());; 6712///; 6713/// These two functions are run in a context such that the branch names are; 6714/// available as local variables of the correct (read-only) type.; 6715///; 6716/// Note that if you use the same 'variable' twice, it is more efficient; 6717/// to 'cache' the value. For example:; 6718/// ~~~ {.cpp}; 6719/// Int_t n = fEventNumber; // Read fEventNumber; 6720/// if (n<10 || n>10) { ... }; 6721/// ~~~; 6722/// is more efficient than; 6723/// ~~~ {.cpp}; 6724/// if (fEventNumber<10 || fEventNumber>10); 6725/// ~~~; 6726/// Also, optionally, the generated selector will also call methods named; 6727/// macrofilename_methodname in each of 6 main selector methods if the method; 6728/// macrofilename_methodname exist (Where macrofilename is stripped of its; 6729/// extension).; 6730///; 6731/// Concretely, with the script named h1analysisProxy.C,; 6732///; 6733/// - The method calls the method (if it exist); 6734/// - Begin -> void h1analysisProxy_Begin(TTree*);; 6735/// - SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; 6736/// - Notify -> bool h1analysisProxy_Notify();; 6737/// - Process -> bool h1analysisProxy_Process(Long64_t);; 6738/// - SlaveTerminate -> void h1analysisProxy_SlaveTerm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:262536,cache,cache,262536,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,".h""; #include ""TLine.h""; #include ""TEventList.h"". const Double_t dxbin = (0.17-0.13)/40; // Bin-width; const Double_t sigma = 0.0012;; TEventList *elist = 0;; Bool_t useList, fillList;; TH1F *hdmd;; TH2F *h2;. //_________________________________________________________; Double_t fdm5(Double_t *xx, Double_t *par); {; Double_t x = xx[0];; if (x <= 0.13957) return 0;; Double_t xp3 = (x-par[3])*(x-par[3]);; Double_t res = dxbin*(par[0]*TMath::Power(x-0.13957,par[1]); + par[2]/2.5066/par[4]*TMath::Exp(-xp3/2/par[4]/par[4]));; return res;; }. //_________________________________________________________; Double_t fdm2(Double_t *xx, Double_t *par); {; Double_t x = xx[0];; if (x <= 0.13957) return 0;; Double_t xp3 = (x-0.1454)*(x-0.1454);; Double_t res = dxbin*(par[0]*TMath::Power(x-0.13957,0.25); + par[1]/2.5066/sigma*TMath::Exp(-xp3/2/sigma/sigma));; return res;; }. //_________________________________________________________; void h1analysis::Begin(TTree *tree); {; // function called before starting the event loop; // -it performs some cleanup; // -it creates histograms; // -it sets some initialization for the event list. //initialize the Tree branch addresses; Init(tree);. //print the option specified in the Process function; TString option = GetOption();; printf(""Starting h1analysis with process option: %sn"",option.Data());. //Some cleanup in case this function had already been executed; //Delete any previously generated histograms or functions; gDirectory->Delete(""hdmd"");; gDirectory->Delete(""h2*"");; delete gROOT->GetFunction(""f5"");; delete gROOT->GetFunction(""f2"");. //create histograms; hdmd = new TH1F(""hdmd"",""dm_d"",40,0.13,0.17);; h2 = new TH2F(""h2"",""ptD0 vs dm_d"",30,0.135,0.165,30,-3,6);. //process cases with event list; fillList = kFALSE;; useList = kFALSE;; fChain->SetEventList(0);; delete gDirectory->GetList()->FindObject(""elist"");. // case when one creates/fills the event list; if (option.Contains(""fillList"")) {; fillList = kTRUE;; elist = new TEventList(""elist"",""s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1092662,perform,performs,1092662,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performs']
Performance,".h. Constructor & Destructor Documentation. ◆ TGeoPhysicalNode() [1/3]. TGeoPhysicalNode::TGeoPhysicalNode ; (; const TGeoPhysicalNode & ; ). protecteddelete . ◆ TGeoPhysicalNode() [2/3]. TGeoPhysicalNode::TGeoPhysicalNode ; (; ). Default constructor. ; Definition at line 77 of file TGeoPhysicalNode.cxx. ◆ TGeoPhysicalNode() [3/3]. TGeoPhysicalNode::TGeoPhysicalNode ; (; const char * ; path). Constructor. ; Definition at line 92 of file TGeoPhysicalNode.cxx. ◆ ~TGeoPhysicalNode(). TGeoPhysicalNode::~TGeoPhysicalNode ; (; ). override . Destructor. ; Definition at line 112 of file TGeoPhysicalNode.cxx. Member Function Documentation. ◆ Align(). Bool_t TGeoPhysicalNode::Align ; (; TGeoMatrix * ; newmat = nullptr, . TGeoShape * ; newshape = nullptr, . Bool_t ; check = kFALSE, . Double_t ; ovlp = 0.001 . ). Align a physical node with a new relative matrix/shape. ; Example: /TOP_1/A_1/B_1/C_1 node->Align(transl_1, box) will perform:; change RELATIVE translation of C_1 node (with respect to its container volume B) to transl_1; change the shape of the C volume NOTE The operations will affect ONLY the LAST node in the branch. All volumes/nodes in the branch represented by this physical node are CLONED so the operation does not affect other possible replicas. . Definition at line 135 of file TGeoPhysicalNode.cxx. ◆ cd(). void TGeoPhysicalNode::cd ; (; ); const. Definition at line 366 of file TGeoPhysicalNode.cxx. ◆ Class(). static TClass * TGeoPhysicalNode::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGeoPhysicalNode::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGeoPhysicalNode::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 90 of file TGeoPhysicalNode.h. ◆ DeclFileName(). static const char * TGeoPhysicalNode::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPhysicalNode.html:18039,perform,perform,18039,doc/master/classTGeoPhysicalNode.html,https://root.cern,https://root.cern/doc/master/classTGeoPhysicalNode.html,1,['perform'],['perform']
Performance,".h. Public Types; enum  ESlaveStatus { kInvalid; , kActive; , kInactive; };  ; enum  ESlaveType { kMaster; , kSlave; };  ; enum  EStatusBits { kOutputRequested = (1ULL << ( 15 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  ~TSlave () override;  Destroy slave. ;  ; virtual void Close (Option_t *opt="""");  Close slave socket. ;  ; Int_t Compare (const TObject *obj) const override;  Used to sort slaves by performance index. ;  ; const char * GetArchCompiler () const;  ; Long64_t GetBytesRead () const;  ; Float_t GetCpuTime () const;  ; const char * GetGroup () const;  ; const char * GetImage () const;  ; TFileHandler * GetInputHandler () const;  ; const char * GetMsd () const;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetOrdinal () const;  ; Int_t GetParallel () const;  ; Int_t GetPerfIdx () const;  ; Int_t GetPort () const;  ; TProof * GetProof () const;  ; const char * GetProofWorkDir () const;  ; Int_t GetProtocol () const;  ; Float_t GetRealTime () const;  ; const char * GetROOTVersion () const;  ; const char * GetSessionTag () const;  ; Int_t GetSlaveType () const;  ; TSocket * GetSocket () const;  ; Int_t GetStatus () const;  ; const char * GetUser () const;  ; const char * GetWorkDir () const;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; virtual Bool_t IsValid () const;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSlave.html:1731,perform,performance,1731,doc/master/classTSlave.html,https://root.cern,https://root.cern/doc/master/classTSlave.html,1,['perform'],['performance']
Performance,".h. ◆ GetSize(). virtual Int_t TFFTReal::GetSize ; (; ); const. inlinevirtual . Definition at line 42 of file TFFTReal.h. ◆ GetTransformFlag(). Option_t * TFFTReal::GetTransformFlag ; (; ); const. inlineoverridevirtual . Implements TVirtualFFT.; Definition at line 47 of file TFFTReal.h. ◆ GetType(). Option_t * TFFTReal::GetType ; (; ); const. overridevirtual . Returns the type of the transform. ; Implements TVirtualFFT.; Definition at line 210 of file TFFTReal.cxx. ◆ Init(). void TFFTReal::Init ; (; Option_t * ; flags, . Int_t ; sign, . const Int_t * ; kind . ). overridevirtual . Creates the fftw-plan. ; NOTE: input and output arrays are overwritten during initialisation, so don't set any points, before running this function!!!!!; 1st parameter:; Possible flag_options:. ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal performance; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and type are going to be done. Planning is only done once, for the first transform of this size and type. 2nd parameter:; is dummy and doesn't need to be specified; 3rd parameter:; transform kind for each dimension 4 different kinds of sine and cosine transforms are available; DCT-I - kind=0; DCT-II - kind=1; DCT-III - kind=2; DCT-IV - kind=3; DST-I - kind=4; DST-II - kind=5; DSTIII - kind=6; DSTIV - kind=7 . Implements TVirtualFFT.; Definition at line 176 of file TFFTReal.cxx. ◆ IsA(). TClass * TFFTReal::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 69 of file TFFTReal.h. ◆ IsInplace(). Bool_t TFFTReal::IsInplace ; (; ); const. inlineoverridevirtual . Implements TVirtualFFT.; Definition at line 48 of file TFFTRea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFFTReal.html:20615,perform,performance,20615,doc/master/classTFFTReal.html,https://root.cern,https://root.cern/doc/master/classTFFTReal.html,1,['perform'],['performance']
Performance,".h. ◆ IsA(). virtual TClass * RooAbsCache::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented in RooCacheManager< T >, RooCacheManager< RooAbsCacheElement >, and RooObjCacheManager.; Definition at line 63 of file RooAbsCache.h. ◆ operModeHook(). virtual void RooAbsCache::operModeHook ; (; ). inlinevirtual . Interface for operation mode changes. ; Reimplemented in RooCacheManager< T >, RooCacheManager< RooAbsCacheElement >, and RooObjCacheManager.; Definition at line 46 of file RooAbsCache.h. ◆ optimizeCacheMode(). virtual void RooAbsCache::optimizeCacheMode ; (; const RooArgSet & ; , . RooArgSet & ; , . RooLinkedList & ;  . ). inlinevirtual . Interface for processing of cache mode optimization calls. ; Reimplemented in RooObjCacheManager.; Definition at line 49 of file RooAbsCache.h. ◆ printCompactTreeHook(). virtual void RooAbsCache::printCompactTreeHook ; (; std::ostream & ; , . const char * ;  . ). inlinevirtual . Interface for printing of cache guts in tree mode printing. ; Reimplemented in RooCacheManager< T >, RooCacheManager< RooAbsCacheElement >, and RooObjCacheManager.; Definition at line 55 of file RooAbsCache.h. ◆ redirectServersHook(). virtual bool RooAbsCache::redirectServersHook ; (; const RooAbsCollection & ; , . bool ; , . bool ; , . bool ;  . ). inlinevirtual . Interface for server redirect calls. ; Reimplemented in RooCacheManager< T >, RooCacheManager< RooAbsCacheElement >, RooObjCacheManager, and RooMappedCategoryCache.; Definition at line 40 of file RooAbsCache.h. ◆ setOwner(). void RooAbsCache::setOwner ; (; RooAbsArg * ; owner). Reset the owner, triggering the owner to register this cache in its list of caches. ; Definition at line 71 of file RooAbsCache.cxx. ◆ Streamer(). virtual void RooAbsCache::Streamer ; (; TBuffer & ; ). virtual . Reimplemented in RooCacheManager< T >, RooCacheManager< RooAbsCacheElement >, and RooObjCacheManager. ◆ StreamerNVirtual(). void RooAbsCache::StreamerNVirtual ; (; TBuffe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCache.html:4868,cache,cache,4868,doc/master/classRooAbsCache.html,https://root.cern,https://root.cern/doc/master/classRooAbsCache.html,1,['cache'],['cache']
Performance,".h. ◆ TestPrunedTreeQuality(). Double_t TMVA::DecisionTree::TestPrunedTreeQuality ; (; const DecisionTreeNode * ; dt = nullptr, . Int_t ; mode = 0 . ); const. return the misclassification rate of a pruned tree a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at any node, hence this tree quality testing will stop there, hence test the pruned tree (while the full tree is still in place for normal/later use) ; Definition at line 1043 of file DecisionTree.cxx. ◆ TrainNode(). Double_t TMVA::DecisionTree::TrainNode ; (; const EventConstList & ; eventSample, . DecisionTreeNode * ; node . ). inline . Definition at line 108 of file DecisionTree.h. ◆ TrainNodeFast(). Double_t TMVA::DecisionTree::TrainNodeFast ; (; const EventConstList & ; eventSample, . TMVA::DecisionTreeNode * ; node . ). Decide how to split a node using one of the variables that gives the best separation of signal/background. ; In order to do this, for each variable a scan of the different cut values in a grid (grid = fNCuts) is performed and the resulting separation gains are compared. in addition to the individual variables, one can also ask for a fisher discriminant being built out of (some) of the variables and used as a possible multivariate split. ; Definition at line 1374 of file DecisionTree.cxx. ◆ TrainNodeFull(). Double_t TMVA::DecisionTree::TrainNodeFull ; (; const EventConstList & ; eventSample, . TMVA::DecisionTreeNode * ; node . ). train a node by finding the single optimal cut for a single variable that best separates signal and background (maximizes the separation gain) ; Definition at line 2536 of file DecisionTree.cxx. Member Data Documentation. ◆ fAnalysisType. Types::EAnalysisType TMVA::DecisionTree::fAnalysisType. private . kClassification(=0=false) or kRegression(=1=true) ; Definition at line 239 of file DecisionTree.h. ◆ fDataSetInfo. DataSetInfo* TMVA::DecisionTree::fDataSetInfo. private . Definition at line 241 of file DecisionTree.h. ◆ fgDebugLevel. const Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html:26704,perform,performed,26704,doc/master/classTMVA_1_1DecisionTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html,1,['perform'],['performed']
Performance,".h. ◆ _cacheMgr. RooObjCacheManager RooLagrangianMorphFunc::_cacheMgr. mutableprivate . Definition at line 245 of file RooLagrangianMorphFunc.h. ◆ _config. Config RooLagrangianMorphFunc::_config. private . Definition at line 253 of file RooLagrangianMorphFunc.h. ◆ _diagrams. std::vector<std::vector<RooListProxy *> > RooLagrangianMorphFunc::_diagrams. private . Definition at line 254 of file RooLagrangianMorphFunc.h. ◆ _flags. RooListProxy RooLagrangianMorphFunc::_flags. private . Definition at line 252 of file RooLagrangianMorphFunc.h. ◆ _nonInterfering. std::vector<std::vector<std::string> > RooLagrangianMorphFunc::_nonInterfering. private . Definition at line 255 of file RooLagrangianMorphFunc.h. ◆ _observables. RooListProxy RooLagrangianMorphFunc::_observables. private . Definition at line 250 of file RooLagrangianMorphFunc.h. ◆ _operators. RooSetProxy RooLagrangianMorphFunc::_operators. private . Definition at line 249 of file RooLagrangianMorphFunc.h. ◆ _physics. RooListProxy RooLagrangianMorphFunc::_physics. private . Definition at line 248 of file RooLagrangianMorphFunc.h. ◆ _sampleMap. std::map<std::string, int> RooLagrangianMorphFunc::_sampleMap. private . Definition at line 247 of file RooLagrangianMorphFunc.h. ◆ _scale. double RooLagrangianMorphFunc::_scale = 1.0. private . The cache manager. ; Definition at line 246 of file RooLagrangianMorphFunc.h. ◆ implementedPrecision. constexpr double RooLagrangianMorphFunc::implementedPrecision = RooFit::SuperFloatPrecision::digits10. staticconstexpr . length of floating point digits precision supported by implementation. ; Definition at line 189 of file RooLagrangianMorphFunc.h. Libraries for RooLagrangianMorphFunc:. [legend]; The documentation for this class was generated from the following files:; roofit/roofit/inc/RooLagrangianMorphFunc.h; roofit/roofit/src/RooLagrangianMorphFunc.cxx. RooLagrangianMorphFunc. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:58 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLagrangianMorphFunc.html:96956,cache,cache,96956,doc/master/classRooLagrangianMorphFunc.html,https://root.cern,https://root.cern/doc/master/classRooLagrangianMorphFunc.html,1,['cache'],['cache']
Performance,".h. ◆ clearObsList(). static bool RooObjCacheManager::clearObsList ; (; ). inlinestatic . Definition at line 48 of file RooObjCacheManager.h. ◆ DeclFileName(). static const char * RooObjCacheManager::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 62 of file RooObjCacheManager.h. ◆ doClearObsList(). static void RooObjCacheManager::doClearObsList ; (; bool ; flag). inlinestatic . Definition at line 47 of file RooObjCacheManager.h. ◆ findConstantNodes(). void RooObjCacheManager::findConstantNodes ; (; const RooArgSet & ; obs, . RooArgSet & ; cacheList, . RooLinkedList & ; processedNodes . ). overridevirtual . If clearOnRedirect is false, forward constant term optimization calls to cache elements. ; Reimplemented from RooAbsCache.; Definition at line 209 of file RooObjCacheManager.cxx. ◆ insertObjectHook(). void RooObjCacheManager::insertObjectHook ; (; RooAbsCacheElement & ; obj). overridevirtual . Set owner link on all object inserted into cache. ; Also if cache mode optimization was requested, apply it now to cache element being inserted ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 175 of file RooObjCacheManager.cxx. ◆ IsA(). TClass * RooObjCacheManager::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 62 of file RooObjCacheManager.h. ◆ operModeHook(). void RooObjCacheManager::operModeHook ; (; ). overridevirtual . Intercept changes to cache operation mode and forward to cache elements. ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 108 of file RooObjCacheManager.cxx. ◆ optimizeCacheMode(). void RooObjCacheManager::optimizeCacheMode ; (; const RooArgSet & ; obs, . RooArgSet & ; optNodes, . RooLinkedList & ; processedNodes . ). overridevirtual . Intercept calls to perform automatic optimization of cache mode operation. ; Fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:9410,cache,cache,9410,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,1,['cache'],['cache']
Performance,".h:118; ROOT::GetClassTClass * GetClass(T *)Definition TClass.h:663; ROOT::CreateClassTClass * CreateClass(const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il)Global function called by a class' static Dictionary() method (see the ClassDef macro).Definition TClass.cxx:5936; ROOT::DelFunc_tvoid(* DelFunc_t)(void *)Definition Rtypes.h:116; ROOT::ESTLTypeESTLTypeDefinition ESTLType.h:28; ROOT::NewArrFunc_tvoid *(* NewArrFunc_t)(Long_t size, void *arena)Definition Rtypes.h:115; ROOT::EFunctionMatchModeEFunctionMatchModeDefinition TDictionary.h:161; ROOT::kConversionMatch@ kConversionMatchDefinition TDictionary.h:163; ROOT::ResetClassVersionvoid ResetClassVersion(TClass *, const char *, Short_t)Global function to update the version number.Definition TClassTable.cxx:951; ROOT::DelArrFunc_tvoid(* DelArrFunc_t)(void *)Definition Rtypes.h:117; ROOT::NewFunc_tvoid *(* NewFunc_t)(void *)Definition Rtypes.h:114; ROOT::MergeFunc_tLong64_t(* MergeFunc_t)(void *, TCollection *, TFileMergeInfo *)Definition Rtypes.h:120; whatstatic const char * whatDefinition stlLoader.cc:5; ROOT::Internal::TClassGetClassHelperDefinition TClass.h:630; ROOT::Internal::TClassGetClassHelper::GetClassstatic TClass * GetClass(Bool_t load, Bool_t silent)Definition TClass.h:631; TClass::ObjectPtrDefinition TClass.h:140; TClass::ObjectPtr::fPtrvoid * fPtrDefinition TClass.h:141; TClass::ObjectPtr::GetAllocatorTVirtualStreamerInfo * GetAllocator() constDefinition TClass.h:149; TClass::ObjectPtr::GetPtrvoid * GetPtr() constDefinition TClass.h:147; TClass::ObjectPtr::fAllocatorTVirtualStreamerInfo * fAllocatorDefinition TClass.h:143; TClass::ObjectPtr::ObjectPtrObjectPtr(void *ptr=nullptr, TVirtualStreamerInfo *allocator=nullptr)Definition TClass.h:145; Drawth1 Draw(); lTLine lDefinition textangle.C:4. coremetaincTClass.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:85714,load,load,85714,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,1,['load'],['load']
Performance,".h:77; TEntryList::fBlocksTObjArray * fBlocksblocks with indices of passing events (TEntryListBlocks)Definition TEntryList.h:35; TEntryList::GetEntryAndTreevirtual Long64_t GetEntryAndTree(Long64_t index, Int_t &treenum)Return the index of ""index""-th non-zero entry in the TTree or TChain and the # of the corresponding t...Definition TEntryList.cxx:835; TEntryList::GetFileNamevirtual const char * GetFileName() constDefinition TEntryList.h:80; TEntryList::Scanstatic Int_t Scan(const char *fn, TList *roots)Scan TEntryList in 'fn' to find the common parts of paths.Definition TEntryList.cxx:1608; TEntryList::DirectoryAutoAddvirtual void DirectoryAutoAdd(TDirectory *)Called by TKey and others to automatically add us to a directory when we are read from a file.Definition TEntryList.cxx:619; TEntryList::kBlockSize@ kBlockSizeDefinition TEntryList.h:54; TEntryList::fNLong64_t fNnumber of entries in the listDefinition TEntryList.h:36; TEntryList::fLastIndexReturnedLong64_t fLastIndexReturned! used to optimize GetEntry() function from a loopDefinition TEntryList.h:45; TEntryList::Nextvirtual Long64_t Next()Return the next non-zero entry index (next after fLastIndexQueried) this function is faster than GetE...Definition TEntryList.cxx:998; TEntryList::SetDirectoryvirtual void SetDirectory(TDirectory *dir)Add reference to directory dir. dir can be 0.Definition TEntryList.cxx:1170; TEntryList::EnterRangevoid EnterRange(Long64_t start, Long64_t end, TTree *tree=nullptr, UInt_t step=1U)Enter all entries in a range in the TEntryList.Definition TEntryList.cxx:703; TEntryList::Resetvirtual void Reset()Reset this list.Definition TEntryList.cxx:1138; TEntryList::fNBlocksInt_t fNBlocksnumber of TEntryListBlocksDefinition TEntryList.h:34; TEntryList::GetEntryvirtual Long64_t GetEntry(Long64_t index)Return the number of the entry #index of this TEntryList in the TTree or TChain See also Next().Definition TEntryList.cxx:759; TEntryList::Streamervoid Streamer(TBuffer &) overrideCustom streame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEntryList_8cxx_source.html:64796,optimiz,optimize,64796,doc/master/TEntryList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html,1,['optimiz'],['optimize']
Performance,".py:1; xmlio::Nameconst char * NameDefinition TXMLSetup.cxx:67; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; RooLagrangianMorphFunc::ConfigDefinition RooLagrangianMorphFunc.h:85; RooLagrangianMorphFunc::Config::couplingsRooArgList couplingsDefinition RooLagrangianMorphFunc.h:92; RooLagrangianMorphFunc::Config::observableNamestd::string observableNameDefinition RooLagrangianMorphFunc.h:86; RooLagrangianMorphFunc::Config::fileNamestd::string fileNameDefinition RooLagrangianMorphFunc.h:88; RooLagrangianMorphFunc::Config::folderNamesstd::vector< std::string > folderNamesDefinition RooLagrangianMorphFunc.h:91; ; [#0] PROGRESS:InputArguments -- initializing physics inputs from file /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/roofit/input_histos_rf_lagrangianmorph.root with object name(s) 'pTV'; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x7ffccdd4a418; [#0] PROGRESS:Caching -- current storage has size 3; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; [#1] INFO:DataHandling -- RooDataHist::adjustBinning(morph_dh_cHq3=0.01): fit range of variable pTV expanded to nearest bin boundaries: [10,600] --> [0,600]; [#1] INFO:InputArguments -- RooAbsData::plotOn(SM_NPsq0) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:InputArguments -- RooAbsData::plotOn(cHq3_NPsq1) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 24931.9 will supersede previous event count of 10852.3 for normalization of PDF projections; [#1] INFO:InputArguments -- RooAbsData::plotOn(cHq3_NPsq2) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 29789.2 will supersede previous event count of 249",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf711__lagrangianmorph_8C.html:13413,cache,cache,13413,doc/master/rf711__lagrangianmorph_8C.html,https://root.cern,https://root.cern/doc/master/rf711__lagrangianmorph_8C.html,1,['cache'],['cache']
Performance,".r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. Int_t setObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Setter function without integration set. Int_t lastIndex() const; Return index of slot used in last get or set operation. Int_t cacheSize() const; Return size of cache. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface function to intercept server redirects. void operModeHook(); Interface function to intercept cache operation mode changes. void printCompactTreeHook(ostream& , const char* ); Interface function to cache add contents to output in tree printing mode. void insertObjectHook(RooAbsCacheElement& ); Interface function to perform post-insert operations on cached object. » Last changed: Thu Sep 23 19:59:10 2010 » Last generated: 2010-09-23 19:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCacheManager_RooAbsCacheElement_.html:4613,cache,cacheSize,4613,root/html528/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html528/RooCacheManager_RooAbsCacheElement_.html,6,"['cache', 'perform']","['cache', 'cacheSize', 'cached', 'perform']"
Performance,"/ - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1808 ; 1809void TFumili::FitChisquareI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871///////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:52734,cache,cache,52734,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,2,['cache'],['cache']
Performance,"/ Add sub entry lists to the global list; 567/// elists.AddSubList(&elist1);; 568/// elists.AddSubList(&elist2);; 569///; 570/// // Set the entry list in the chain. Note the usage of option ""sync""; 571/// chain.SetEntryList(&elists, ""sync"");; 572/// ~~~; 573 ; 574void TEntryList::AddSubList(TEntryList *elist){; 575 ; 576 auto elistcopy = new TEntryList{*elist};; 577 ; 578 fN += elistcopy->fN;; 579 ; 580 if (!fLists){; 581 fLists = new TList();; 582 }; 583 fLists->Add(elistcopy);; 584}; 585 ; 586////////////////////////////////////////////////////////////////////////////////; 587/// - When tree = 0, returns from the current list; 588/// - When tree != 0, finds the list, corresponding to this tree; 589/// - When tree is a chain, the entry is assumed to be global index and the local; 590/// entry is recomputed from the treeoffset information of the chain; 591 ; 592Int_t TEntryList::Contains(Long64_t entry, TTree *tree); 593{; 594 if (!tree){; 595 if (fBlocks) {; 596 //this entry list doesn't contain any sub-lists; 597 TEntryListBlock *block = nullptr;; 598 Int_t nblock = entry/kBlockSize;; 599 if (nblock >= fNBlocks) return 0;; 600 block = (TEntryListBlock*)fBlocks->UncheckedAt(nblock);; 601 return block->Contains(entry-nblock*kBlockSize);; 602 }; 603 if (fLists) {; 604 if (!fCurrent) fCurrent = (TEntryList*)fLists->First();; 605 return fCurrent->Contains(entry);; 606 }; 607 return 0;; 608 } else {; 609 Long64_t localEntry = tree->LoadTree(entry);; 610 SetTree(tree->GetTree());; 611 if (fCurrent); 612 return fCurrent->Contains(localEntry);; 613 }; 614 return 0;; 615 ; 616}; 617 ; 618////////////////////////////////////////////////////////////////////////////////; 619/// Called by TKey and others to automatically add us to a directory when we are read from a file.; 620 ; 621void TEntryList::DirectoryAutoAdd(TDirectory* dir); 622{; 623 SetDirectory(dir);; 624}; 625 ; 626////////////////////////////////////////////////////////////////////////////////; 627/// Add entry \#en",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEntryList_8cxx_source.html:20938,Load,LoadTree,20938,doc/master/TEntryList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html,1,['Load'],['LoadTree']
Performance,"/ Append string to the storage if not added already.; 1013 ; 1014inline bool TCling::TUniqueString::Append(const std::string& str); 1015{; 1016 bool notPresent = fLinesHashSet.emplace(fHashFunc(str)).second;; 1017 if (notPresent){; 1018 fContent+=str;; 1019 }; 1020 return notPresent;; 1021}; 1022 ; 1023std::string TCling::ToString(const char* type, void* obj); 1024{; 1025 return fInterpreter->toString(type, obj);; 1026}; 1027 ; 1028////////////////////////////////////////////////////////////////////////////////; 1029///\returns true if the module was loaded.; 1030static bool LoadModule(const std::string &ModuleName, cling::Interpreter &interp); 1031{; 1032 // When starting up ROOT, cling would load all modulemap files on the include; 1033 // paths. However, in a ROOT session, it is very common to run aclic which; 1034 // will invoke rootcling and possibly produce a modulemap and a module in; 1035 // the current folder.; 1036 //; 1037 // Before failing, try loading the modulemap in the current folder and try; 1038 // loading the requested module from it.; 1039 std::string currentDir = gSystem->WorkingDirectory();; 1040 assert(!currentDir.empty());; 1041 gCling->RegisterPrebuiltModulePath(currentDir);; 1042 if (gDebug > 2); 1043 ::Info(""TCling::__LoadModule"", ""Preloading module %s. \n"",; 1044 ModuleName.c_str());; 1045 ; 1046 return interp.loadModule(ModuleName, /*Complain=*/true);; 1047}; 1048 ; 1049////////////////////////////////////////////////////////////////////////////////; 1050/// Loads the C++ modules that we require to run any ROOT program. This is just; 1051/// supposed to make a C++ module from a modulemap available to the interpreter.; 1052static void LoadModules(const std::vector<std::string> &modules, cling::Interpreter &interp); 1053{; 1054 for (const auto &modName : modules); 1055 LoadModule(modName, interp);; 1056}; 1057 ; 1058static bool IsFromRootCling() {; 1059 // rootcling also uses TCling for generating the dictionary ROOT files.; 1060 const stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:36743,load,loading,36743,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,['load'],['loading']
Performance,"/ If check is true it will only check if filename exists and is; 2264/// readable.; 2265/// Returns 0 on successful loading and -1 in case filename does not; 2266/// exist or in case of error.; 2267 ; 2268Int_t TROOT::LoadMacro(const char *filename, int *error, Bool_t check); 2269{; 2270 Int_t err = -1;; 2271 Int_t lerr, *terr;; 2272 if (error); 2273 terr = error;; 2274 else; 2275 terr = &lerr;; 2276 ; 2277 if (fInterpreter) {; 2278 TString aclicMode;; 2279 TString arguments;; 2280 TString io;; 2281 TString fname = gSystem->SplitAclicMode(filename, aclicMode, arguments, io);; 2282 ; 2283 if (arguments.Length()) {; 2284 Warning(""LoadMacro"", ""argument(%s) ignored in %s"", arguments.Data(), GetMacroPath());; 2285 }; 2286 char *mac = gSystem->Which(GetMacroPath(), fname, kReadPermission);; 2287 if (!mac) {; 2288 if (!check); 2289 Error(""LoadMacro"", ""macro %s not found in path %s"", fname.Data(), GetMacroPath());; 2290 *terr = TInterpreter::kFatal;; 2291 } else {; 2292 err = 0;; 2293 if (!check) {; 2294 fname = mac;; 2295 fname += aclicMode;; 2296 fname += io;; 2297 gInterpreter->LoadMacro(fname.Data(), (TInterpreter::EErrorCode*)terr);; 2298 if (*terr); 2299 err = -1;; 2300 }; 2301 }; 2302 delete [] mac;; 2303 }; 2304 return err;; 2305}; 2306 ; 2307////////////////////////////////////////////////////////////////////////////////; 2308/// Execute a macro in the interpreter. Equivalent to the command line; 2309/// command "".x filename"". If the filename has ""+"" or ""++"" appended; 2310/// the macro will be compiled by ACLiC. The filename must have the format:; 2311/// [path/]macro.C[+|++[g|O]][(args)].; 2312/// The possible error codes are defined by TInterpreter::EErrorCode.; 2313/// If padUpdate is true (default) update the current pad.; 2314/// Returns the macro return value.; 2315 ; 2316Longptr_t TROOT::Macro(const char *filename, Int_t *error, Bool_t padUpdate); 2317{; 2318 Longptr_t result = 0;; 2319 ; 2320 if (fInterpreter) {; 2321 TString aclicMode;; 2322 TString argumen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:87535,Load,LoadMacro,87535,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['Load'],['LoadMacro']
Performance,"/ If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,; 1694/// Otherwise just call the iterator's destructor.; 1695 ; 1696TVirtualCollectionProxy::DeleteIterator_t TGenCollectionProxy::GetFunctionDeleteIterator(Bool_t read); 1697{; 1698 if (read) {; 1699 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1700 if ( (fProperties & kIsAssociative) && read); 1701 return TGenCollectionProxy__StagingDeleteSingleIterators;; 1702 }; 1703 ; 1704 if ( fFunctionDeleteIterator ) return fFunctionDeleteIterator;; 1705 ; 1706 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1707 ; 1708 // TODO can we do better than the default for RVec?; 1709 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1710 return fFunctionDeleteIterator = TGenCollectionProxy__VectorDeleteSingleIterators;; 1711 else if ( (fProperties & kIsAssociative) && read); 1712 return TGenCollectionProxy__StagingDeleteSingleIterators;; 1713 else; 1714 return fFunctionDeleteIterator = TGenCollectionProxy__SlowDeleteSingleIterators;; 1715}; 1716 ; 1717////////////////////////////////////////////////////////////////////////////////; 1718/// See typedef void (*DeleteTwoIterators_t)(void *begin, void *end);; 1719/// If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,; 1720/// Otherwise just call the iterator's destructor.; 1721 ; 1722TVirtualCollectionProxy::DeleteTwoIterators_t TGenCollectionProxy::GetFunctionDeleteTwoIterators(Bool_t read); 1723{; 1724 if (read) {; 1725 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1726 if ( (fProperties & kIsAssociative) && read); 1727 return TGenCollectionProxy__StagingDeleteTwoIterators;; 1728 }; 1729 ; 1730 if ( fFunctionDeleteTwoIterators ) return fFunctionDeleteTwoIterators;; 1731 ; 1732 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1733 ; 1734 // TODO could RVec use something faster than SlowCopyIterator?; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:56889,load,load,56889,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['load'],['load']
Performance,"/ Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any.; 7203 ; 7204TVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const TClass* cl, UInt_t checksum ) const; 7205{; 7206 //---------------------------------------------------------------------------; 7207 // Check if the classname was specified correctly; 7208 /////////////////////////////////////////////////////////////////////////////; 7209 ; 7210 if( !cl ); 7211 return nullptr;; 7212 ; 7213 if( cl == this ); 7214 return FindStreamerInfo( checksum );; 7215 ; 7216 //----------------------------------------------------------------------------; 7217 // Check if we already have it; 7218 /////////////////////////////////////////////////////////////////////////////; 7219 ; 7220 TObjArray* arr = nullptr;; 7221 TVirtualStreamerInfo* info = nullptr;; 7222 if (fConversionStreamerInfo.load()) {; 7223 std::map<std::string, TObjArray*>::iterator it;; 7224 ; 7225 R__LOCKGUARD(gInterpreterMutex);; 7226 ; 7227 it = (*fConversionStreamerInfo).find( cl->GetName() );; 7228 ; 7229 if( it != (*fConversionStreamerInfo).end() ) {; 7230 arr = it->second;; 7231 }; 7232 if (arr) {; 7233 info = FindStreamerInfo( arr, checksum );; 7234 }; 7235 }; 7236 ; 7237 if( info ); 7238 return info;; 7239 ; 7240 R__LOCKGUARD(gInterpreterMutex);; 7241 ; 7242 //----------------------------------------------------------------------------; 7243 // Get it from the foreign class; 7244 /////////////////////////////////////////////////////////////////////////////; 7245 ; 7246 info = cl->FindStreamerInfo( checksum );; 7247 ; 7248 if( !info ); 7249 return nullptr;; 7250 ; 7251 //----------------------------------------------------------------------------; 7252 // We have the right info so we need to clone it to create new object with; 7253 // non artificial streamer elements and we should build it for current class; 7254 ////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:277404,load,load,277404,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"/ Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any.; 7270 ; 7271TVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const TClass* cl, UInt_t checksum ) const; 7272{; 7273 //---------------------------------------------------------------------------; 7274 // Check if the classname was specified correctly; 7275 /////////////////////////////////////////////////////////////////////////////; 7276 ; 7277 if( !cl ); 7278 return nullptr;; 7279 ; 7280 if( cl == this ); 7281 return FindStreamerInfo( checksum );; 7282 ; 7283 //----------------------------------------------------------------------------; 7284 // Check if we already have it; 7285 /////////////////////////////////////////////////////////////////////////////; 7286 ; 7287 TObjArray* arr = nullptr;; 7288 TVirtualStreamerInfo* info = nullptr;; 7289 if (fConversionStreamerInfo.load()) {; 7290 std::map<std::string, TObjArray*>::iterator it;; 7291 ; 7292 R__LOCKGUARD(gInterpreterMutex);; 7293 ; 7294 it = (*fConversionStreamerInfo).find( cl->GetName() );; 7295 ; 7296 if( it != (*fConversionStreamerInfo).end() ) {; 7297 arr = it->second;; 7298 }; 7299 if (arr) {; 7300 info = FindStreamerInfo( arr, checksum );; 7301 }; 7302 }; 7303 ; 7304 if( info ); 7305 return info;; 7306 ; 7307 R__LOCKGUARD(gInterpreterMutex);; 7308 ; 7309 //----------------------------------------------------------------------------; 7310 // Get it from the foreign class; 7311 /////////////////////////////////////////////////////////////////////////////; 7312 ; 7313 info = cl->FindStreamerInfo( checksum );; 7314 ; 7315 if( !info ); 7316 return nullptr;; 7317 ; 7318 //----------------------------------------------------------------------------; 7319 // We have the right info so we need to clone it to create new object with; 7320 // non artificial streamer elements and we should build it for current class; 7321 ////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:280155,load,load,280155,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"/ Return list containing the TBaseClass(es) of a class.; 3635 ; 3636TList *TClass::GetListOfBases(); 3637{; 3638 if (!fBase.load()) {; 3639 if (fCanLoadClassInfo) {; 3640 if (fState == kHasTClassInit) {; 3641 ; 3642 R__LOCKGUARD(gInterpreterMutex);; 3643 if (!fHasRootPcmInfo) {; 3644 // The bases are in our ProtoClass; we don't need the class info.; 3645 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 3646 if (proto && proto->FillTClass(this)); 3647 return fBase;; 3648 }; 3649 }; 3650 // We test again on fCanLoadClassInfo has another thread may have executed it.; 3651 if (!fHasRootPcmInfo && fCanLoadClassInfo) {; 3652 LoadClassInfo();; 3653 }; 3654 }; 3655 if (!fClassInfo); 3656 return nullptr;; 3657 ; 3658 if (!gInterpreter); 3659 Fatal(""GetListOfBases"", ""gInterpreter not initialized"");; 3660 ; 3661 R__LOCKGUARD(gInterpreterMutex);; 3662 if (!fBase.load()) {; 3663 gInterpreter->CreateListOfBaseClasses(this);; 3664 }; 3665 }; 3666 return fBase;; 3667}; 3668 ; 3669////////////////////////////////////////////////////////////////////////////////; 3670/// Return a list containing the TEnums of a class.; 3671///; 3672/// The list returned is safe to use from multiple thread without explicitly; 3673/// taking the ROOT global lock.; 3674///; 3675/// In the case the TClass represents a namespace, the returned list will; 3676/// implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); 3677///; 3678/// In the case the TClass represents a class or struct and requestListLoading; 3679/// is true, the list is immutable (and thus safe to access from multiple thread; 3680/// without taking the global lock at all).; 3681///; 3682/// In the case the TClass represents a class or struct and requestListLoading; 3683/// is false, the list is mutable and thus we return a TListOfEnumsWithLock; 3684/// which will implicit take the ROOT global lock upon any access.; 3685 ; 3686TList *TClass::GetListOfEnums(Bool_t requestListLoading /* = kTRUE */); 3687{; 3688",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:138586,load,load,138586,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"/ Return list containing the TBaseClass(es) of a class.; 3702 ; 3703TList *TClass::GetListOfBases(); 3704{; 3705 if (!fBase.load()) {; 3706 if (fCanLoadClassInfo) {; 3707 if (fState == kHasTClassInit) {; 3708 ; 3709 R__LOCKGUARD(gInterpreterMutex);; 3710 if (!fHasRootPcmInfo) {; 3711 // The bases are in our ProtoClass; we don't need the class info.; 3712 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 3713 if (proto && proto->FillTClass(this)); 3714 return fBase;; 3715 }; 3716 }; 3717 // We test again on fCanLoadClassInfo has another thread may have executed it.; 3718 if (!fHasRootPcmInfo && fCanLoadClassInfo) {; 3719 LoadClassInfo();; 3720 }; 3721 }; 3722 if (!fClassInfo); 3723 return nullptr;; 3724 ; 3725 if (!gInterpreter); 3726 Fatal(""GetListOfBases"", ""gInterpreter not initialized"");; 3727 ; 3728 R__LOCKGUARD(gInterpreterMutex);; 3729 if (!fBase.load()) {; 3730 gInterpreter->CreateListOfBaseClasses(this);; 3731 }; 3732 }; 3733 return fBase;; 3734}; 3735 ; 3736////////////////////////////////////////////////////////////////////////////////; 3737/// Return a list containing the TEnums of a class.; 3738///; 3739/// The list returned is safe to use from multiple thread without explicitly; 3740/// taking the ROOT global lock.; 3741///; 3742/// In the case the TClass represents a namespace, the returned list will; 3743/// implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); 3744///; 3745/// In the case the TClass represents a class or struct and requestListLoading; 3746/// is true, the list is immutable (and thus safe to access from multiple thread; 3747/// without taking the global lock at all).; 3748///; 3749/// In the case the TClass represents a class or struct and requestListLoading; 3750/// is false, the list is mutable and thus we return a TListOfEnumsWithLock; 3751/// which will implicit take the ROOT global lock upon any access.; 3752 ; 3753TList *TClass::GetListOfEnums(Bool_t requestListLoading /* = kTRUE */); 3754{; 3755",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:141337,load,load,141337,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"/ cleaning information; 2458 TMVA::MethodBase *ssmethod = dynamic_cast<TMVA::MethodBase *>(fMethodsMap[ybitset.to_string().c_str()][0][0]);; 2459 TMVA::ResultsClassification *ssresults = (TMVA::ResultsClassification *)ssmethod->Data()->GetResults(; 2460 ssmethod->GetMethodName(), Types::kTesting, Types::kClassification);; 2461 delete ssresults;; 2462 delete subseedloader;; 2463 this->DeleteAllMethods();; 2464 fMethodsMap.clear();; 2465 }; 2466 }; 2467 std::cout << ""--- Variable Importance Results (Short)"" << std::endl;; 2468 return GetImportance(nbits, importances, varNames);; 2469}; 2470 ; 2471////////////////////////////////////////////////////////////////////////////////; 2472 ; 2473TH1F *TMVA::Factory::EvaluateImportanceRandom(DataLoader *loader, UInt_t nseeds, Types::EMVA theMethod,; 2474 TString methodTitle, const char *theOption); 2475{; 2476 TRandom3 *rangen = new TRandom3(0); // Random Gen.; 2477 ; 2478 uint64_t x = 0;; 2479 uint64_t y = 0;; 2480 ; 2481 // getting number of variables and variable names from loader; 2482 const int nbits = loader->GetDataSetInfo().GetNVariables();; 2483 std::vector<TString> varNames = loader->GetDataSetInfo().GetListOfVariables();; 2484 ; 2485 long int range = pow(2, nbits);; 2486 ; 2487 // vector to save importances; 2488 std::vector<Double_t> importances(nbits);; 2489 for (int i = 0; i < nbits; i++); 2490 importances[i] = 0;; 2491 ; 2492 Double_t SROC, SSROC; // computed ROC value; 2493 for (UInt_t n = 0; n < nseeds; n++) {; 2494 x = rangen->Integer(range);; 2495 ; 2496 std::bitset<32> xbitset(x);; 2497 if (x == 0); 2498 continue; // data loader need at least one variable; 2499 ; 2500 // creating loader for seed; 2501 TMVA::DataLoader *seedloader = new TMVA::DataLoader(xbitset.to_string());; 2502 ; 2503 // adding variables from seed; 2504 for (int index = 0; index < nbits; index++) {; 2505 if (xbitset[index]); 2506 seedloader->AddVariable(varNames[index], 'F');; 2507 }; 2508 ; 2509 // Loading Dataset; 2510 DataLoaderCopy(se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:103090,load,loader,103090,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,2,['load'],['loader']
Performance,"/ columnListWithoutSizeColumns (still with aliases in it, passed through snapHelperArgs) as output column names.; 3189 auto resPtr = CreateAction<RDFInternal::ActionTags::Snapshot, ColumnTypes...>(validCols, newRDF, snapHelperArgs,; 3190 fProxiedPtr);; 3191 ; 3192 if (!options.fLazy); 3193 *resPtr;; 3194 return resPtr;; 3195 }; 3196 ; 3197 ////////////////////////////////////////////////////////////////////////////; 3198 /// \brief Implementation of cache.; 3199 template <typename... ColTypes, std::size_t... S>; 3200 RInterface<RLoopManager> CacheImpl(const ColumnNames_t &columnList, std::index_sequence<S...>); 3201 {; 3202 const auto columnListWithoutSizeColumns = RDFInternal::FilterArraySizeColNames(columnList, ""Snapshot"");; 3203 ; 3204 // Check at compile time that the columns types are copy constructible; 3205 constexpr bool areCopyConstructible =; 3206 RDFInternal::TEvalAnd<std::is_copy_constructible<ColTypes>::value...>::value;; 3207 static_assert(areCopyConstructible, ""Columns of a type which is not copy constructible cannot be cached yet."");; 3208 ; 3209 RDFInternal::CheckTypesAndPars(sizeof...(ColTypes), columnListWithoutSizeColumns.size());; 3210 ; 3211 auto colHolders = std::make_tuple(Take<ColTypes>(columnListWithoutSizeColumns[S])...);; 3212 auto ds = std::make_unique<RLazyDS<ColTypes...>>(; 3213 std::make_pair(columnListWithoutSizeColumns[S], std::get<S>(colHolders))...);; 3214 ; 3215 RInterface<RLoopManager> cachedRDF(std::make_shared<RLoopManager>(std::move(ds), columnListWithoutSizeColumns));; 3216 ; 3217 return cachedRDF;; 3218 }; 3219 ; 3220 template <bool IsSingleColumn, typename F>; 3221 RInterface<Proxied, DS_t>; 3222 VaryImpl(const std::vector<std::string> &colNames, F &&expression, const ColumnNames_t &inputColumns,; 3223 const std::vector<std::string> &variationTags, std::string_view variationName); 3224 {; 3225 using F_t = std::decay_t<F>;; 3226 using ColTypes_t = typename TTraits::CallableTraits<F_t>::arg_types;; 3227 using RetType = typen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:182660,cache,cached,182660,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['cache'],['cached']
Performance,"/ false,; 3248 /*CacheFail*/ false);; 3249 if (FE) {; 3250 // check in the source manager if the file is actually loaded; 3251 clang::SourceManager &SM = fInterpreter->getCI()->getSourceManager();; 3252 // this works only with header (and source) files...; 3253 clang::FileID FID = SM.translateFile(*FE);; 3254 if (!FID.isInvalid() && FID.getHashValue() == 0); 3255 return kFALSE;; 3256 else {; 3257 clang::SrcMgr::SLocEntry SLocE = SM.getSLocEntry(FID);; 3258 if (SLocE.isFile() && !SLocE.getFile().getContentCache().getBufferIfLoaded()); 3259 return kFALSE;; 3260 if (!FID.isInvalid()); 3261 return kTRUE;; 3262 }; 3263 // ...then check shared library again, but with full path now; 3264 sFilename = FE->getName().str();; 3265 if (gSystem->FindDynamicLibrary(sFilename, kTRUE); 3266 && fileMap.count(sFilename.Data())) {; 3267 return kTRUE;; 3268 }; 3269 }; 3270 return kFALSE;; 3271}; 3272 ; 3273 ; 3274#if defined(R__MACOSX); 3275 ; 3276////////////////////////////////////////////////////////////////////////////////; 3277/// Check if lib is in the dynamic linker cache, returns true if it is, and if so,; 3278/// modifies the library file name parameter `lib` from `/usr/lib/libFOO.dylib`; 3279/// to `-lFOO` such that it can be passed to the linker.; 3280/// This is a unique feature of macOS 11.; 3281 ; 3282static bool R__UpdateLibFileForLinking(TString &lib); 3283{; 3284 const char *mapfile = nullptr;; 3285#if __x86_64__; 3286 mapfile = ""/System/Library/dyld/dyld_shared_cache_x86_64.map"";; 3287#elif __arm64__; 3288 mapfile = ""/System/Library/dyld/dyld_shared_cache_arm64e.map"";; 3289#else; 3290 #error unsupported architecture; 3291#endif; 3292 if (std::ifstream cacheMap{mapfile}) {; 3293 std::string line;; 3294 while (getline(cacheMap, line)) {; 3295 if (line.find(lib) != std::string::npos) {; 3296 lib.ReplaceAll(""/usr/lib/lib"",""-l"");; 3297 lib.ReplaceAll("".dylib"","""");; 3298 return true;; 3299 }; 3300 }; 3301 return false;; 3302 }; 3303 return false;; 3304}; 3305#endif // R__MAC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:126729,cache,cache,126729,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['cache'],['cache']
Performance,"/ interface for non-modules.; 2365 if (!fCxxModulesEnabled); 2366 return;; 2367 ; 2368 if (IdentifierInfoLookup *External = C.Idents.getExternalIdentifierLookup()) {; 2369 std::unique_ptr<IdentifierIterator> Iter(External->getIdentifiers());; 2370 for (llvm::StringRef Ident = Iter->Next(); !Ident.empty(); Ident = Iter->Next()) {; 2371 std::string I = Ident.str();; 2372 if (!Idents.Contains(I.data())); 2373 Idents.Add(new TObjString(I.c_str()));; 2374 }; 2375 }; 2376}; 2377 ; 2378 ; 2379////////////////////////////////////////////////////////////////////////////////; 2380/// Register classes that already existed prior to their dictionary loading; 2381/// and that already had a ClassInfo (and thus would not be refresh via; 2382/// UpdateClassInfo.; 2383 ; 2384void TCling::RegisterTClassUpdate(TClass *oldcl,DictFuncPtr_t dict); 2385{; 2386 fClassesToUpdate.push_back(std::make_pair(oldcl,dict));; 2387}; 2388 ; 2389////////////////////////////////////////////////////////////////////////////////; 2390/// If the dictionary is loaded, we can remove the class from the list; 2391/// (otherwise the class might be loaded twice).; 2392 ; 2393void TCling::UnRegisterTClassUpdate(const TClass *oldcl); 2394{; 2395 typedef std::vector<std::pair<TClass*,DictFuncPtr_t> >::iterator iterator;; 2396 iterator stop = fClassesToUpdate.end();; 2397 for(iterator i = fClassesToUpdate.begin();; 2398 i != stop;; 2399 ++i); 2400 {; 2401 if ( i->first == oldcl ) {; 2402 fClassesToUpdate.erase(i);; 2403 return;; 2404 }; 2405 }; 2406}; 2407 ; 2408 ; 2409////////////////////////////////////////////////////////////////////////////////; 2410/// Let cling process a command line.; 2411///; 2412/// If the command is executed and the error is 0, then the return value; 2413/// is the int value corresponding to the result of the executed command; 2414/// (float and double return values will be truncated).; 2415///; 2416 ; 2417// Method for handling the interpreter exceptions.; 2418// the MetaProcessor is pass",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:92757,load,loaded,92757,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,['load'],['loaded']
Performance,"/ settings.batchSize);; 1347 minValError += regzTerm;; 1348 ; 1349 ; 1350 // create a pointer to base class VOptimizer; 1351 std::unique_ptr<DNN::VOptimizer<Architecture_t, Layer_t, DeepNet_t>> optimizer;; 1352 ; 1353 // initialize the base class pointer with the corresponding derived class object.; 1354 switch (O) {; 1355 ; 1356 case EOptimizer::kSGD:; 1357 optimizer = std::unique_ptr<DNN::TSGD<Architecture_t, Layer_t, DeepNet_t>>(; 1358 new DNN::TSGD<Architecture_t, Layer_t, DeepNet_t>(settings.learningRate, deepNet, settings.momentum));; 1359 break;; 1360 ; 1361 case EOptimizer::kAdam: {; 1362 optimizer = std::unique_ptr<DNN::TAdam<Architecture_t, Layer_t, DeepNet_t>>(; 1363 new DNN::TAdam<Architecture_t, Layer_t, DeepNet_t>(; 1364 deepNet, settings.learningRate, settings.optimizerParams[""ADAM_beta1""],; 1365 settings.optimizerParams[""ADAM_beta2""], settings.optimizerParams[""ADAM_eps""]));; 1366 break;; 1367 }; 1368 ; 1369 case EOptimizer::kAdagrad:; 1370 optimizer = std::unique_ptr<DNN::TAdagrad<Architecture_t, Layer_t, DeepNet_t>>(; 1371 new DNN::TAdagrad<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate,; 1372 settings.optimizerParams[""ADAGRAD_eps""]));; 1373 break;; 1374 ; 1375 case EOptimizer::kRMSProp:; 1376 optimizer = std::unique_ptr<DNN::TRMSProp<Architecture_t, Layer_t, DeepNet_t>>(; 1377 new DNN::TRMSProp<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate, settings.momentum,; 1378 settings.optimizerParams[""RMSPROP_rho""],; 1379 settings.optimizerParams[""RMSPROP_eps""]));; 1380 break;; 1381 ; 1382 case EOptimizer::kAdadelta:; 1383 optimizer = std::unique_ptr<DNN::TAdadelta<Architecture_t, Layer_t, DeepNet_t>>(; 1384 new DNN::TAdadelta<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate,; 1385 settings.optimizerParams[""ADADELTA_rho""],; 1386 settings.optimizerParams[""ADADELTA_eps""]));; 1387 break;; 1388 }; 1389 ; 1390 ; 1391 // Initialize the vector of batches, one batch for one slave network; 1392 std::vector<TTe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:54119,optimiz,optimizerParams,54119,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,2,['optimiz'],"['optimizer', 'optimizerParams']"
Performance,"/ setup; 614 if (!Initialize()); 615 return kFALSE;; 616 ; 617 PyGILRAII gilRaii;; 618 ; 619 // direct pointer comparison of type member; 620 return CPyCppyy::Overload_CheckExact(pyobject);; 621}; 622 ; 623////////////////////////////////////////////////////////////////////////////////; 624/// Extract the object pointer held by the CPPInstance pyobject.; 625 ; 626void *TPython::CPPInstance_AsVoidPtr(PyObject *pyobject); 627{; 628 // setup; 629 if (!Initialize()); 630 return 0;; 631 ; 632 PyGILRAII gilRaii;; 633 ; 634 // get held object (may be null); 635 return CPyCppyy::Instance_AsVoidPtr(pyobject);; 636}; 637 ; 638////////////////////////////////////////////////////////////////////////////////; 639/// Bind the addr to a python object of class defined by classname.; 640 ; 641PyObject *TPython::CPPInstance_FromVoidPtr(void *addr, const char *classname, Bool_t python_owns); 642{; 643 // setup; 644 if (!Initialize()); 645 return 0;; 646 ; 647 PyGILRAII gilRaii;; 648 ; 649 // perform cast (the call will check TClass and addr, and set python errors); 650 // give ownership, for ref-counting, to the python side, if so requested; 651 return CPyCppyy::Instance_FromVoidPtr(addr, classname, python_owns);; 652}; API.h; PyBytes_Check#define PyBytes_CheckDefinition CPyCppyy.h:61; PyObject_object PyObjectDefinition PyMethodBase.h:43; Riostream.h; Bool_tbool Bool_tDefinition RtypesCore.h:63; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TClassRef.h; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPython_8cxx_source.html:21176,perform,perform,21176,doc/master/TPython_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html,1,['perform'],['perform']
Performance,"/ the architecture can now be set at runtime as an option; 247 ; 248 ; 249 if (fArchitectureString == ""GPU"" || fArchitectureString == ""CUDNN"") {; 250#ifdef R__HAS_TMVAGPU; 251 Log() << kINFO << ""Will now use the GPU architecture !"" << Endl;; 252#else // case TMVA does not support GPU; 253 Log() << kERROR << ""CUDA backend not enabled. Please make sure ""; 254 ""you have CUDA installed and it was successfully ""; 255 ""detected by CMAKE by using -Dtmva-gpu=On ""; 256 << Endl;; 257 fArchitectureString = ""CPU"";; 258 Log() << kINFO << ""Will now use instead the CPU architecture !"" << Endl;; 259#endif; 260 }; 261 ; 262 if (fArchitectureString == ""CPU"") {; 263#ifdef R__HAS_TMVACPU // TMVA has CPU BLAS and IMT support; 264 Log() << kINFO << ""Will now use the CPU architecture with BLAS and IMT support !"" << Endl;; 265#else // TMVA has no CPU BLAS or IMT support; 266 Log() << kINFO << ""Multi-core CPU backend not enabled. For better performances, make sure ""; 267 ""you have a BLAS implementation and it was successfully ""; 268 ""detected by CMake as well that the imt CMake flag is set.""; 269 << Endl;; 270 Log() << kINFO << ""Will use anyway the CPU architecture but with slower performance"" << Endl;; 271#endif; 272 }; 273 ; 274 // Input Layout; 275 ParseInputLayout();; 276 ParseBatchLayout();; 277 ; 278 // Loss function and output.; 279 fOutputFunction = EOutputFunction::kSigmoid;; 280 if (fAnalysisType == Types::kClassification) {; 281 if (fErrorStrategy == ""SUMOFSQUARES"") {; 282 fLossFunction = ELossFunction::kMeanSquaredError;; 283 }; 284 if (fErrorStrategy == ""CROSSENTROPY"") {; 285 fLossFunction = ELossFunction::kCrossEntropy;; 286 }; 287 fOutputFunction = EOutputFunction::kSigmoid;; 288 } else if (fAnalysisType == Types::kRegression) {; 289 if (fErrorStrategy != ""SUMOFSQUARES"") {; 290 Log() << kWARNING << ""For regression only SUMOFSQUARES is a valid ""; 291 << "" neural net error function. Setting error function to ""; 292 << "" SUMOFSQUARES now."" << Endl;; 293 }; 294 ; 295 fLossFunctio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:9934,perform,performances,9934,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['perform'],['performances']
Performance,"/ ~~~ {.cpp}; 7364/// ******TreeCache statistics for file: cms2.root ******; 7365/// Reading 73921562 bytes in 716 transactions; 7366/// Average transaction = 103.242405 Kbytes; 7367/// Number of blocks in current cache: 202, total size : 6001193; 7368/// ~~~; 7369/// if option = ""a"" the list of blocks in the cache is printed; 7370 ; 7371void TTree::PrintCacheStats(Option_t* option) const; 7372{; 7373 TFile *f = GetCurrentFile();; 7374 if (!f) return;; 7375 TTreeCache *tc = GetReadCache(f);; 7376 if (tc) tc->Print(option);; 7377}; 7378 ; 7379////////////////////////////////////////////////////////////////////////////////; 7380/// Process this tree executing the TSelector code in the specified filename.; 7381/// The return value is -1 in case of error and TSelector::GetStatus() in; 7382/// in case of success.; 7383///; 7384/// The code in filename is loaded (interpreted or compiled, see below),; 7385/// filename must contain a valid class implementation derived from TSelector,; 7386/// where TSelector has the following member functions:; 7387///; 7388/// - `Begin()`: called every time a loop on the tree starts,; 7389/// a convenient place to create your histograms.; 7390/// - `SlaveBegin()`: called after Begin(), when on PROOF called only on the; 7391/// slave servers.; 7392/// - `Process()`: called for each event, in this function you decide what; 7393/// to read and fill your histograms.; 7394/// - `SlaveTerminate`: called at the end of the loop on the tree, when on PROOF; 7395/// called only on the slave servers.; 7396/// - `Terminate()`: called at the end of the loop on the tree,; 7397/// a convenient place to draw/fit your histograms.; 7398///; 7399/// If filename is of the form file.C, the file will be interpreted.; 7400///; 7401/// If filename is of the form file.C++, the file file.C will be compiled; 7402/// and dynamically loaded.; 7403///; 7404/// If filename is of the form file.C+, the file file.C will be compiled; 7405/// and dynamically loaded. At next ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:290119,load,loaded,290119,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['load'],['loaded']
Performance,"/"");  Return the drive letter in pathname. ;  ; int Exec (const char *shellcmd) override;  Execute a command. ;  ; void Exit (int code, Bool_t mode=kTRUE) override;  Exit the application. ;  ; void ExitLoop () override;  Exit from event loop. ;  ; char * ExpandPathName (const char *path) override;  Expand a pathname getting rid of special shell characaters like ~. ;  ; Bool_t ExpandPathName (TString &patbuf) override;  Expand a pathname getting rid of special shell characaters like ~.$, etc. ;  ; const char * FindDynamicLibrary (TString &lib, Bool_t quiet=kFALSE) override;  Returns and updates sLib to the path of a dynamic library (searches for library in the dynamic library search path). ;  ; const char * FindFile (const char *search, TString &file, EAccessMode mode=kFileExists) override;  Find location of file in a search path. ;  ; void FreeDirectory (void *dirp) override;  Close a WinNT file system directory. ;  ; Int_t GetCpuInfo (CpuInfo_t *info, Int_t sampleTime=1000) const override;  Returns cpu load average and load info into the CpuInfo_t structure. ;  ; Double_t GetCPUTime ();  ; Int_t GetCryptoRandom (void *buf, Int_t len) override;  Return cryptographic random number Fill provided buffer with random values Returns number of bytes written to buffer or -1 in case of error. ;  ; const char * GetDirEntry (void *dirp) override;  Returns the next directory entry. ;  ; TString GetDirName (const char *pathname) override;  Return the directory name in pathname. ;  ; const char * GetDynamicPath () override;  Return the dynamic path (used to find shared libraries). ;  ; Int_t GetEffectiveGid () override;  Returns the effective group id. ;  ; Int_t GetEffectiveUid () override;  Returns the effective user id. ;  ; const char * Getenv (const char *name) override;  Get environment variable. ;  ; const char * GetError () override;  Return system error string. ;  ; Int_t GetFPEMask () override;  Return the bitmap of conditions that trigger a floating point exception. ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:4560,load,load,4560,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,2,['load'],['load']
Performance,"/* do not optimize char* */; 3097 && (element->GetType() == (fComp[keep].fType%kRegrouped)); 3098 && ((element->GetOffset()-fComp[keep].fOffset) == (fComp[keep].fLength)*asize); 3099 && ((fOldVersion<6) || !previous || /* In version of TStreamerInfo less than 6, the Double32_t were merged even if their annotation (aka factor) were different */; 3100 ((element->GetFactor() == previous->GetFactor()); 3101 && (element->GetXmin() == previous->GetXmin()); 3102 && (element->GetXmax() == previous->GetXmax()); 3103 ); 3104 ); 3105 && (element->TestBit(TStreamerElement::kCache) == previous->TestBit(TStreamerElement::kCache)); 3106 && (element->TestBit(TStreamerElement::kWrite) == previous->TestBit(TStreamerElement::kWrite)); 3107 // kWholeObject and kDoNotDelete do not apply to numerical elements.; 3108 ); 3109 {; 3110 if (!previousOptimized) {; 3111 // The element was not yet optimized we first need to copy it into; 3112 // the set of original copies.; 3113 fComp[fNslots - (++optiOut) ] = fComp[keep]; // Copy the optimized out elements.; 3114 fCompFull[fNfulldata-1] = &(fComp[fNslots - optiOut]); // Reset the pointer in the full list.; 3115 }; 3116 fComp[fNslots - (++optiOut) ] = fComp[fNdata]; // Copy the optimized out elements.; 3117 fCompFull[fNfulldata] = &(fComp[fNslots - optiOut]);; 3118 ; 3119 R__ASSERT( keep < (fNslots - optiOut) );; 3120 ; 3121 if (fComp[keep].fLength == 0) {; 3122 fComp[keep].fLength++;; 3123 }; 3124 fComp[keep].fLength++;; 3125 fComp[keep].fType = element->GetType() + kRegrouped;; 3126 isOptimized = kTRUE;; 3127 previousOptimized = kTRUE;; 3128 } else if (element->GetType() < 0) {; 3129 ; 3130 // -- Deal with an ignored TObject base class.; 3131 // Note: The only allowed negative value here is -1,; 3132 // and signifies that Build() has found a TObject; 3133 // base class and TClass::IgnoreTObjectStreamer() was; 3134 // called. In this case the compiled version of the; 3135 // elements omits the TObject base class element,; 3136 // which has to be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:136307,optimiz,optimized,136307,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['optimiz'],['optimized']
Performance,"/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TGeoManager; 13#define ROOT_TGeoManager; 14 ; 15#include <mutex>; 16#include <thread>; 17#include <map>; 18 ; 19#include ""TNamed.h""; 20#include ""TObjArray.h""; 21#include ""TGeoNavigator.h""; 22 ; 23// forward declarations; 24class TVirtualGeoTrack;; 25class TGeoNode;; 26class TGeoPhysicalNode;; 27class TGeoPNEntry;; 28class TGeoVolume;; 29class TGeoVolumeMulti;; 30class TGeoMatrix;; 31class TGeoHMatrix;; 32class TGeoMaterial;; 33class TGeoMedium;; 34class TGeoShape;; 35class TVirtualGeoPainter;; 36class THashList;; 37class TGeoParallelWorld;; 38class TGeoRegion;; 39class TGDMLMatrix;; 40class TGeoOpticalSurface;; 41class TGeoSkinSurface;; 42class TGeoBorderSurface;; 43 ; 44class TGeoManager : public TNamed {; 45public:; 46 enum EDefaultUnits { kG4Units = 0, kRootUnits = 1 };; 47 ; 48protected:; 49 static std::mutex fgMutex; //! mutex for navigator booking in MT mode; 50 static Bool_t fgLock; //! Lock preventing a second geometry to be loaded; 51 static Int_t fgVerboseLevel; //! Verbosity level for Info messages (no IO).; 52 static Int_t fgMaxLevel; //! Maximum level in geometry; 53 static Int_t fgMaxDaughters; //! Maximum number of daughters; 54 static Int_t fgMaxXtruVert; //! Maximum number of Xtru vertices; 55 static UInt_t fgExportPrecision; //! Precision to be used in ASCII exports; 56 static EDefaultUnits fgDefaultUnits; //! Default units in GDML if not explicit in some tags; 57 ; 58 TGeoManager(const TGeoManager &) = delete;; 59 TGeoManager &operator=(const TGeoManager &) = delete;; 60 ; 61private:; 62 Double_t fPhimin; //! lowest range for phi cut; 63 Double_t fPhimax; //! high",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8h_source.html:1586,load,loaded,1586,doc/master/TGeoManager_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html,1,['load'],['loaded']
Performance,"// - If no class number has been specified, TClass::GetVersion will return -1; 5671/// - The Class Version 0 request the whole object to be transient; 5672/// - The Class Version 1, unless specified via ClassDef indicates that the; 5673/// I/O should use the TClass checksum to distinguish the layout of the class; 5674 ; 5675void TClass::SetClassVersion(Version_t version); 5676{; 5677 fClassVersion = version;; 5678 fCurrentInfo = nullptr;; 5679}; 5680 ; 5681////////////////////////////////////////////////////////////////////////////////; 5682/// Determine and set pointer to current TVirtualStreamerInfo; 5683 ; 5684TVirtualStreamerInfo* TClass::DetermineCurrentStreamerInfo(); 5685{; 5686 if(!fCurrentInfo.load()) {; 5687 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 5688 fCurrentInfo = (TVirtualStreamerInfo *)(fStreamerInfo->At(fClassVersion));; 5689 }; 5690 return fCurrentInfo;; 5691}; 5692 ; 5693////////////////////////////////////////////////////////////////////////////////; 5694/// Set pointer to current TVirtualStreamerInfo; 5695 ; 5696void TClass::SetCurrentStreamerInfo(TVirtualStreamerInfo *info); 5697{; 5698 fCurrentInfo = info;; 5699}; 5700 ; 5701////////////////////////////////////////////////////////////////////////////////; 5702/// Return size of object of this class.; 5703 ; 5704Int_t TClass::Size() const; 5705{; 5706 if (fSizeof!=-1) return fSizeof;; 5707 if (fCollectionProxy) return fCollectionProxy->Sizeof();; 5708 if (HasInterpreterInfo()) return gCling->ClassInfo_Size(GetClassInfo());; 5709 return GetStreamerInfo()->GetSize();; 5710}; 5711 ; 5712////////////////////////////////////////////////////////////////////////////////; 5713/// Load class description from I/O buffer and return class object.; 5714 ; 5715TClass *TClass::Load(TBuffer &b); 5716{; 5717 UInt_t maxsize = 256;; 5718 char *s = new char[maxsize];; 5719 ; 5720 Int_t pos = b.Length();; 5721 ; 5722 b.ReadString(s, maxsize); // Reads at most maxsize - 1 characters, plus null at end.; 5723 while (strle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:217927,load,load,217927,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"// - If no class number has been specified, TClass::GetVersion will return -1; 5738/// - The Class Version 0 request the whole object to be transient; 5739/// - The Class Version 1, unless specified via ClassDef indicates that the; 5740/// I/O should use the TClass checksum to distinguish the layout of the class; 5741 ; 5742void TClass::SetClassVersion(Version_t version); 5743{; 5744 fClassVersion = version;; 5745 fCurrentInfo = nullptr;; 5746}; 5747 ; 5748////////////////////////////////////////////////////////////////////////////////; 5749/// Determine and set pointer to current TVirtualStreamerInfo; 5750 ; 5751TVirtualStreamerInfo* TClass::DetermineCurrentStreamerInfo(); 5752{; 5753 if(!fCurrentInfo.load()) {; 5754 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 5755 fCurrentInfo = (TVirtualStreamerInfo *)(fStreamerInfo->At(fClassVersion));; 5756 }; 5757 return fCurrentInfo;; 5758}; 5759 ; 5760////////////////////////////////////////////////////////////////////////////////; 5761/// Set pointer to current TVirtualStreamerInfo; 5762 ; 5763void TClass::SetCurrentStreamerInfo(TVirtualStreamerInfo *info); 5764{; 5765 fCurrentInfo = info;; 5766}; 5767 ; 5768////////////////////////////////////////////////////////////////////////////////; 5769/// Return size of object of this class.; 5770 ; 5771Int_t TClass::Size() const; 5772{; 5773 if (fSizeof!=-1) return fSizeof;; 5774 if (fCollectionProxy) return fCollectionProxy->Sizeof();; 5775 if (HasInterpreterInfo()) return gCling->ClassInfo_Size(GetClassInfo());; 5776 return GetStreamerInfo()->GetSize();; 5777}; 5778 ; 5779////////////////////////////////////////////////////////////////////////////////; 5780/// Load class description from I/O buffer and return class object.; 5781 ; 5782TClass *TClass::Load(TBuffer &b); 5783{; 5784 UInt_t maxsize = 256;; 5785 char *s = new char[maxsize];; 5786 ; 5787 Int_t pos = b.Length();; 5788 ; 5789 b.ReadString(s, maxsize); // Reads at most maxsize - 1 characters, plus null at end.; 5790 while (strle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:220678,load,load,220678,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"// - kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; 6535/// - kWithTypeDef: use the sugared type name in the calculation.; 6536///; 6537/// This is needed for backward compatibility.; 6538///; 6539/// WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum.; 6540/// They are both used to handle backward compatibility and should both return the same values.; 6541/// TStreamerInfo uses the information in TStreamerElement while TClass uses the information; 6542/// from TClass::GetListOfBases and TClass::GetListOfDataMembers.; 6543 ; 6544UInt_t TClass::GetCheckSum(ECheckSum code, Bool_t &isvalid) const; 6545{; 6546 // fCheckSum is an atomic variable. Also once it has; 6547 // transition from a zero Value it never changes. If two; 6548 // thread reach past this if statement and calculated the; 6549 // 'kLastestCheckSum', they will by definition obtain the; 6550 // same value, so technically we could simply have:; 6551 // if (fCheckSum && code == kCurrentCheckSum) return fCheckSum;; 6552 // However save a little bit of barrier time by calling load(); 6553 // only once.; 6554 ; 6555 isvalid = kTRUE;; 6556 ; 6557 UInt_t currentChecksum = fCheckSum.load();; 6558 if (currentChecksum && code == kCurrentCheckSum) return currentChecksum;; 6559 ; 6560 R__LOCKGUARD(gInterpreterMutex);; 6561 ; 6562 // kCurrentCheckSum (0) is the default parameter value and should be kept; 6563 // for backward compatibility, too be able to use the inequality checks,; 6564 // we need to set the code to the largest value.; 6565 if (code == kCurrentCheckSum) code = kLatestCheckSum;; 6566 ; 6567 UInt_t id = 0;; 6568 ; 6569 int il;; 6570 TString name = GetName();; 6571 TString type;; 6572 il = name.Length();; 6573 for (int i=0; i<il; i++) id = id*3+name[i];; 6574 ; 6575 // Here we skip he base classes in case this is a pair or STL collection,; 6576 // otherwise, on some STL implementations, it can happen that",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:251808,load,load,251808,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"// - kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; 6602/// - kWithTypeDef: use the sugared type name in the calculation.; 6603///; 6604/// This is needed for backward compatibility.; 6605///; 6606/// WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum.; 6607/// They are both used to handle backward compatibility and should both return the same values.; 6608/// TStreamerInfo uses the information in TStreamerElement while TClass uses the information; 6609/// from TClass::GetListOfBases and TClass::GetListOfDataMembers.; 6610 ; 6611UInt_t TClass::GetCheckSum(ECheckSum code, Bool_t &isvalid) const; 6612{; 6613 // fCheckSum is an atomic variable. Also once it has; 6614 // transition from a zero Value it never changes. If two; 6615 // thread reach past this if statement and calculated the; 6616 // 'kLastestCheckSum', they will by definition obtain the; 6617 // same value, so technically we could simply have:; 6618 // if (fCheckSum && code == kCurrentCheckSum) return fCheckSum;; 6619 // However save a little bit of barrier time by calling load(); 6620 // only once.; 6621 ; 6622 isvalid = kTRUE;; 6623 ; 6624 UInt_t currentChecksum = fCheckSum.load();; 6625 if (currentChecksum && code == kCurrentCheckSum) return currentChecksum;; 6626 ; 6627 R__LOCKGUARD(gInterpreterMutex);; 6628 ; 6629 // kCurrentCheckSum (0) is the default parameter value and should be kept; 6630 // for backward compatibility, too be able to use the inequality checks,; 6631 // we need to set the code to the largest value.; 6632 if (code == kCurrentCheckSum) code = kLatestCheckSum;; 6633 ; 6634 UInt_t id = 0;; 6635 ; 6636 int il;; 6637 TString name = GetName();; 6638 TString type;; 6639 il = name.Length();; 6640 for (int i=0; i<il; i++) id = id*3+name[i];; 6641 ; 6642 // Here we skip he base classes in case this is a pair or STL collection,; 6643 // otherwise, on some STL implementations, it can happen that",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:254559,load,load,254559,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"// Early return to release the lock without having to execute the; 2990 // long-ish normalization.; 2991 if (cl && (cl->IsLoaded() || cl->TestBit(kUnloading))) return cl;; 2992 ; 2993 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2994 ; 2995 // Now that we got the write lock, another thread may have constructed the; 2996 // TClass while we were waiting, so we need to do the checks again.; 2997 ; 2998 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 2999 if (cl) {; 3000 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3001 ; 3002 // We could speed-up some of the search by adding (the equivalent of); 3003 //; 3004 // if (cl->GetState() == kInterpreter) return cl; 3005 //; 3006 // In this case, if a ROOT dictionary was available when the TClass; 3007 // was first requested it would have been used and if a ROOT dictionary is; 3008 // loaded later on TClassTable::Add will take care of updating the TClass.; 3009 // So as far as ROOT dictionary are concerned, if the current TClass is; 3010 // in interpreted state, we are sure there is nothing to load.; 3011 //; 3012 // However (see TROOT::LoadClass), the TClass can also be loaded/provided; 3013 // by a user provided TClassGenerator. We have no way of knowing whether; 3014 // those do (or even can) behave the same way as the ROOT dictionary and; 3015 // have the 'dictionary is now available for use' step informs the existing; 3016 // TClass that their dictionary is now available.; 3017 ; 3018 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3019 load = kTRUE;; 3020 }; 3021 ; 3022 if (TClassEdit::IsArtificial(name)) {; 3023 // If there is a @ symbol (followed by a version number) then this is a synthetic class name created; 3024 // from an already normalized name for the purpose of supporting schema evolution.; 3025 // There is no dictionary or interpreter information about this kind of class, the only; 3026 // (undesirable) side-effect of doing the search would be a waste of CPU time",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:113199,load,load,113199,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"// Early return to release the lock without having to execute the; 3057 // long-ish normalization.; 3058 if (cl && (cl->IsLoaded() || cl->TestBit(kUnloading))) return cl;; 3059 ; 3060 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3061 ; 3062 // Now that we got the write lock, another thread may have constructed the; 3063 // TClass while we were waiting, so we need to do the checks again.; 3064 ; 3065 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 3066 if (cl) {; 3067 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3068 ; 3069 // We could speed-up some of the search by adding (the equivalent of); 3070 //; 3071 // if (cl->GetState() == kInterpreter) return cl; 3072 //; 3073 // In this case, if a ROOT dictionary was available when the TClass; 3074 // was first requested it would have been used and if a ROOT dictionary is; 3075 // loaded later on TClassTable::Add will take care of updating the TClass.; 3076 // So as far as ROOT dictionary are concerned, if the current TClass is; 3077 // in interpreted state, we are sure there is nothing to load.; 3078 //; 3079 // However (see TROOT::LoadClass), the TClass can also be loaded/provided; 3080 // by a user provided TClassGenerator. We have no way of knowing whether; 3081 // those do (or even can) behave the same way as the ROOT dictionary and; 3082 // have the 'dictionary is now available for use' step informs the existing; 3083 // TClass that their dictionary is now available.; 3084 ; 3085 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3086 load = kTRUE;; 3087 }; 3088 ; 3089 if (TClassEdit::IsArtificial(name)) {; 3090 // If there is a @ symbol (followed by a version number) then this is a synthetic class name created; 3091 // from an already normalized name for the purpose of supporting schema evolution.; 3092 // There is no dictionary or interpreter information about this kind of class, the only; 3093 // (undesirable) side-effect of doing the search would be a waste of CPU time",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:115950,load,load,115950,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"// It is possible also to specify the number of training and testing events,; // note we disable the computation of the correlation matrix of the input variables; ; int nTrainSig = 0.8 * nEventsSig;; int nTrainBkg = 0.8 * nEventsBkg;; ; // build the string options for DataLoader::PrepareTrainingAndTestTree; TString prepareOptions = TString::Format(; ""nTrain_Signal=%d:nTrain_Background=%d:SplitMode=Random:SplitSeed=100:NormMode=NumEvents:!V:!CalcCorrelations"",; nTrainSig, nTrainBkg);; ; loader.PrepareTrainingAndTestTree(mycuts, mycutb, prepareOptions);; ; /***; ; DataSetInfo : [dataset] : Added class ""Signal""; : Add Tree sig_tree of type Signal with 10000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree bkg_tree of type Background with 10000 events; ; ; ; **/; ; /****; # Booking Methods; ; Here we book the TMVA methods. We book a Boosted Decision Tree method (BDT); ; **/; ; // Boosted Decision Trees; if (useTMVABDT) {; factory.BookMethod(&loader, TMVA::Types::kBDT, ""BDT"",; ""!V:NTrees=200:MinNodeSize=2.5%:MaxDepth=2:BoostType=AdaBoost:AdaBoostBeta=0.5:""; ""UseBaggedBoost:BaggedSampleFraction=0.5:SeparationType=GiniIndex:nCuts=20"");; }; /**; ; #### Booking Deep Neural Network; ; Here we book the DNN of TMVA. See the example TMVA_Higgs_Classification.C for a detailed description of the; options; ; **/; ; if (useTMVADNN) {; ; TString layoutString(; ""Layout=DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,DENSE|1|LINEAR"");; ; // Training strategies; // one can catenate several training strings with different parameters (e.g. learning rates or regularizations; // parameters) The training string must be concatenates with the `|` delimiter; TString trainingString1(""LearningRate=1e-3,Momentum=0.9,Repetitions=1,""; ""ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,""; ""MaxEpochs=10,WeightDecay=1e-4,Regularization=None,""; ""Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0."");; ; TString trainingStrategyString(""TrainingStrategy="");; traini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:53769,load,loader,53769,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['load'],['loader']
Performance,"// See typedef void (*CreateIterators_t)(void *collection, void *&begin_arena, void *&end_arena);; 1603/// begin_arena and end_arena should contain the location of memory arena of size fgIteratorSize.; 1604/// If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); 1605/// Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena.; 1606 ; 1607TVirtualCollectionProxy::CreateIterators_t TGenCollectionProxy::GetFunctionCreateIterators(Bool_t read); 1608{; 1609 if (read) {; 1610 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1611 if ( (fProperties & kIsAssociative) && read); 1612 return TGenCollectionProxy__StagingCreateIterators;; 1613 }; 1614 ; 1615 if ( fFunctionCreateIterators ) return fFunctionCreateIterators;; 1616 ; 1617 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1618 ; 1619// fprintf(stderr,""GetFunctinCreateIterator for %s will give: "",fClass.GetClassName());; 1620// if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1621// fprintf(stderr,""vector/emulated iterator\n"");; 1622// else if ( (fProperties & kIsAssociative) && read); 1623// fprintf(stderr,""an associative read iterator\n"");; 1624// else; 1625// fprintf(stderr,""a generic iterator\n"");; 1626 ; 1627 // TODO could we do better than SlowCreateIterators for RVec?; 1628 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1629 return fFunctionCreateIterators = TGenCollectionProxy__VectorCreateIterators;; 1630 else if ( (fProperties & kIsAssociative) && read); 1631 return TGenCollectionProxy__StagingCreateIterators;; 1632 else; 1633 return fFunctionCreateIterators = TGenCollectionProxy__SlowCreateIterators;; 1634}; 1635 ; 1636////////////////////////////////////////////////////////////////////////////////; 1637/// See typedef void (*CopyIterator_t)(void *&dest, const void *source",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:52363,load,load,52363,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['load'],['load']
Performance,"// we do not pass the 'suffix' as part of the file name, instead we; 418 // directly pass 'treename' to `AddFile`.; 419 nf += AddFile(path.c_str(), nentries, treename);; 420 } else {; 421 nf += AddFile(TString::Format(""%s%s"", path.c_str(), suffix.Data()), nentries);; 422 }; 423 }; 424 ; 425 if (fProofChain); 426 // This updates the proxy chain when we will really use PROOF; 427 ResetBit(kProofUptodate);; 428 ; 429 return nf;; 430}; 431 ; 432////////////////////////////////////////////////////////////////////////////////; 433/// Add a new file to this chain.; 434///; 435/// Filename formats are similar to TChain::Add. Wildcards are not; 436/// applied. urls may also contain query and fragment identifiers; 437/// where the tree name can be specified in the url fragment.; 438///; 439/// eg.; 440/// ~~~ {.cpp}; 441/// root://machine/path/file_name[?query[#tree_name]]; 442/// root://machine/path/file_name.root[.oext]/tree_name[?query]; 443/// ~~~; 444/// If tree_name is given as a part of the file name it is used to; 445/// as the name of the tree to load from the file. Otherwise if tname; 446/// argument is specified the chain will load the tree named tname from; 447/// the file, otherwise the original treename specified in the TChain; 448/// constructor will be used.; 449/// Tagging the tree_name with a slash [/tree_name] is only supported for; 450/// backward compatibility; it requires the file name ot contain the string; 451/// '.root' and its use is deprecated.; 452///; 453/// A. If nentries <= 0, the file is opened and the tree header read; 454/// into memory to get the number of entries.; 455///; 456/// B. If nentries > 0, the file is not opened, and nentries is assumed; 457/// to be the number of entries in the file. In this case, no check; 458/// is made that the file exists nor that the tree exists in the file,; 459/// nor that the real TTree entries match with the input argument.; 460/// This second mode is interesting in case the number of entries in; 461/// t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:17436,load,load,17436,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['load'],['load']
Performance,"/// New DL (CNN); TString cnnMethodName = ""TMVA_CNN_CPU"";; // use GPU if available; #ifdef R__HAS_TMVAGPU; cnnOptions += "":Architecture=GPU"";; cnnMethodName = ""TMVA_CNN_GPU"";; #else; cnnOptions += "":Architecture=CPU"";; cnnMethodName = ""TMVA_CNN_CPU"";; #endif; ; factory.BookMethod(&loader, TMVA::Types::kDL, cnnMethodName, cnnOptions);; }; ; /**; ### Book Convolutional Neural Network in Keras using a generated model; ; **/; ; #ifdef R__HAS_PYMVA; // The next section uses Python packages, execute it only if PyMVA is available; TString tmva_python_exe{TMVA::Python_Executable()};; TString python_exe = tmva_python_exe.IsNull() ? ""python"" : tmva_python_exe;; ; if (useKerasCNN) {; ; Info(""TMVA_CNN_Classification"", ""Building convolutional keras model"");; // create python script which can be executed; // create 2 conv2d layer + maxpool + dense; TMacro m;; m.AddLine(""import tensorflow"");; m.AddLine(""from tensorflow.keras.models import Sequential"");; m.AddLine(""from tensorflow.keras.optimizers import Adam"");; m.AddLine(; ""from tensorflow.keras.layers import Input, Dense, Dropout, Flatten, Conv2D, MaxPooling2D, Reshape, BatchNormalization"");; m.AddLine("""");; m.AddLine(""model = Sequential() "");; m.AddLine(""model.add(Reshape((16, 16, 1), input_shape = (256, )))"");; m.AddLine(""model.add(Conv2D(10, kernel_size = (3, 3), kernel_initializer = 'glorot_normal',activation = ""; ""'relu', padding = 'same'))"");; m.AddLine(""model.add(BatchNormalization())"");; m.AddLine(""model.add(Conv2D(10, kernel_size = (3, 3), kernel_initializer = 'glorot_normal',activation = ""; ""'relu', padding = 'same'))"");; // m.AddLine(""model.add(BatchNormalization())"");; m.AddLine(""model.add(MaxPooling2D(pool_size = (2, 2), strides = (1,1))) "");; m.AddLine(""model.add(Flatten())"");; m.AddLine(""model.add(Dense(256, activation = 'relu')) "");; m.AddLine(""model.add(Dense(2, activation = 'sigmoid')) "");; m.AddLine(""model.compile(loss = 'binary_crossentropy', optimizer = Adam(learning_rate = 0.001), weighted_metrics = ['accura",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:58522,optimiz,optimizers,58522,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['optimiz'],['optimizers']
Performance,"/// Refers to a subset of the methods in GetListOfMethods() so don't do; 3836/// GetListOfAllPublicMethods()->Delete().; 3837/// Algorithm used to get the list is:; 3838/// - put all methods of the class in the list (also protected and private; 3839/// ones).; 3840/// - loop over all base classes and add only those methods not already in the; 3841/// list (also protected and private ones).; 3842/// - once finished, loop over resulting list and remove all private and; 3843/// protected methods.; 3844 ; 3845const TList *TClass::GetListOfAllPublicMethods(Bool_t load /* = kTRUE */); 3846{; 3847 R__LOCKGUARD(gInterpreterMutex);; 3848 ; 3849 if (!fAllPubMethod) fAllPubMethod = new TViewPubFunctions(this);; 3850 if (load) {; 3851 if (gDebug>0) Info(""GetListOfAllPublicMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3852 fAllPubMethod->Load();; 3853 }; 3854 return fAllPubMethod;; 3855}; 3856 ; 3857////////////////////////////////////////////////////////////////////////////////; 3858/// Returns a list of all public data members of this class and its base; 3859/// classes. Refers to a subset of the data members in GetListOfDatamembers(); 3860/// so don't do GetListOfAllPublicDataMembers()->Delete().; 3861 ; 3862TList *TClass::GetListOfAllPublicDataMembers(Bool_t load /* = kTRUE */); 3863{; 3864 R__LOCKGUARD(gInterpreterMutex);; 3865 ; 3866 if (!fAllPubData) fAllPubData = new TViewPubDataMembers(this);; 3867 if (load) fAllPubData->Load();; 3868 return fAllPubData;; 3869}; 3870 ; 3871////////////////////////////////////////////////////////////////////////////////; 3872/// Returns list of methods accessible by context menu.; 3873 ; 3874void TClass::GetMenuItems(TList *list); 3875{; 3876 if (!HasInterpreterInfo()) return;; 3877 ; 3878 // get the base class; 3879 TIter nextBase(GetListOfBases(), kIterBackward);; 3880 TBaseClass *baseClass;; 3881 while ((baseClass = (TBaseClass *) nextBase())) {; 3882 TClass *base = baseClas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:145960,Load,Load,145960,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['Load'],['Load']
Performance,"/// Refers to a subset of the methods in GetListOfMethods() so don't do; 3903/// GetListOfAllPublicMethods()->Delete().; 3904/// Algorithm used to get the list is:; 3905/// - put all methods of the class in the list (also protected and private; 3906/// ones).; 3907/// - loop over all base classes and add only those methods not already in the; 3908/// list (also protected and private ones).; 3909/// - once finished, loop over resulting list and remove all private and; 3910/// protected methods.; 3911 ; 3912const TList *TClass::GetListOfAllPublicMethods(Bool_t load /* = kTRUE */); 3913{; 3914 R__LOCKGUARD(gInterpreterMutex);; 3915 ; 3916 if (!fAllPubMethod) fAllPubMethod = new TViewPubFunctions(this);; 3917 if (load) {; 3918 if (gDebug>0) Info(""GetListOfAllPublicMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3919 fAllPubMethod->Load();; 3920 }; 3921 return fAllPubMethod;; 3922}; 3923 ; 3924////////////////////////////////////////////////////////////////////////////////; 3925/// Returns a list of all public data members of this class and its base; 3926/// classes. Refers to a subset of the data members in GetListOfDatamembers(); 3927/// so don't do GetListOfAllPublicDataMembers()->Delete().; 3928 ; 3929TList *TClass::GetListOfAllPublicDataMembers(Bool_t load /* = kTRUE */); 3930{; 3931 R__LOCKGUARD(gInterpreterMutex);; 3932 ; 3933 if (!fAllPubData) fAllPubData = new TViewPubDataMembers(this);; 3934 if (load) fAllPubData->Load();; 3935 return fAllPubData;; 3936}; 3937 ; 3938////////////////////////////////////////////////////////////////////////////////; 3939/// Returns list of methods accessible by context menu.; 3940 ; 3941void TClass::GetMenuItems(TList *list); 3942{; 3943 if (!HasInterpreterInfo()) return;; 3944 ; 3945 // get the base class; 3946 TIter nextBase(GetListOfBases(), kIterBackward);; 3947 TBaseClass *baseClass;; 3948 while ((baseClass = (TBaseClass *) nextBase())) {; 3949 TClass *base = baseClas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:148711,Load,Load,148711,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['Load'],['Load']
Performance,"/// gSystem->ProcessEvents() calls. But be aware, that such timer can interrupt any system call; 488/// (like malloc) and can lead to dead locks, especially in multi-threaded applications.; 489 ; 490void THttpServer::SetTimer(Long_t milliSec, Bool_t mode); 491{; 492 if (fTimer) {; 493 fTimer->Stop();; 494 fTimer.reset();; 495 }; 496 if (milliSec > 0) {; 497 if (fOwnThread) {; 498 Error(""SetTimer"", ""Server runs already in special thread, therefore no any timer can be created"");; 499 } else {; 500 fTimer = std::make_unique<THttpTimer>(milliSec, mode, *this);; 501 fTimer->TurnOn();; 502 }; 503 }; 504}; 505 ; 506////////////////////////////////////////////////////////////////////////////////; 507/// Creates special thread to process all requests, directed to http server; 508///; 509/// Should be used with care - only dedicated instance of TRootSniffer is allowed; 510/// By default THttpServer allows to access global lists pointers gROOT or gFile.; 511/// To be on the safe side, all kind of such access performed from the main thread.; 512/// Therefore usage of specialized thread means that no any global pointers will; 513/// be accessible by THttpServer; 514 ; 515void THttpServer::CreateServerThread(); 516{; 517 if (fOwnThread); 518 return;; 519 ; 520 SetTimer(0);; 521 fMainThrdId = 0;; 522 fOwnThread = true;; 523 ; 524 std::thread thrd([this] {; 525 int nempty = 0;; 526 while (fOwnThread && !fTerminated) {; 527 int nprocess = ProcessRequests();; 528 if (nprocess > 0); 529 nempty = 0;; 530 else; 531 nempty++;; 532 if (nempty > 1000) {; 533 nempty = 0;; 534 std::this_thread::sleep_for(std::chrono::milliseconds(1));; 535 }; 536 }; 537 });; 538 ; 539 fThrd = std::move(thrd);; 540}; 541 ; 542////////////////////////////////////////////////////////////////////////////////; 543/// Stop server thread; 544///; 545/// Normally called shortly before http server destructor; 546 ; 547void THttpServer::StopServerThread(); 548{; 549 if (!fOwnThread); 550 return;; 551 ; 552 fOwnThread ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:17038,perform,performed,17038,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['perform'],['performed']
Performance,"/// library.; 2785///; 2786/// Of course the + and ++ notation is supported in similar way for .x and .L.; 2787///; 2788/// Through the function TSystem::SetMakeSharedLib(), the user will be able to; 2789/// indicate, with shell commands, how to build a shared library (a good; 2790/// default will be provided). The most common change, namely where to find; 2791/// header files, will be available through the function; 2792/// TSystem::SetIncludePath().; 2793/// A good default will be provided so that a typical user session should be at; 2794/// most:; 2795/// ~~~ {.cpp}; 2796/// root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; 2797/// -I$HOME/mypackage/include"");; 2798/// root[2] .x myfunc.C++(10,20);; 2799/// ~~~; 2800/// The user may sometimes try to compile a script before it has loaded all the; 2801/// needed shared libraries. In this case we want to be helpful and output a; 2802/// list of the unresolved symbols. So if the loading of the created shared; 2803/// library fails, we will try to build a executable that contains the; 2804/// script. The linker should then output a list of missing symbols.; 2805///; 2806/// To support this we provide a TSystem::SetMakeExe() function, that sets the; 2807/// directive telling how to create an executable. The loader will need; 2808/// to be informed of all the libraries available. The information about; 2809/// the libraries that has been loaded by .L and TSystem::Load() is accessible; 2810/// to the script compiler. However, the information about; 2811/// the libraries that have been selected at link time by the application; 2812/// builder (like the root libraries for root.exe) are not available and need; 2813/// to be explicitly listed in fLinkedLibs (either by default or by a call to; 2814/// TSystem::SetLinkedLibs()).; 2815///; 2816/// To simplify customization we could also add to the .rootrc support for the; 2817/// variables; 2818/// ~~~ {.cpp}; 2819/// Unix.*.Root.IncludePath: -I$ROOTSYS/include; 2820/// WinNT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:92191,load,loading,92191,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['loading']
Performance,"/// number of currently loaded methods use:; 4571/// cl->GetListOfMethods(false)->GetSize();; 4572 ; 4573Int_t TClass::GetNmethods(); 4574{; 4575 if (!HasInterpreterInfo()) return 0;; 4576 ; 4577 TList *lm = GetListOfMethods();; 4578 if (lm); 4579 return lm->GetSize();; 4580 else; 4581 return 0;; 4582}; 4583 ; 4584////////////////////////////////////////////////////////////////////////////////; 4585/// returns a pointer to the TVirtualStreamerInfo object for version; 4586/// If the object does not exist, it is created; 4587///; 4588/// Note: There are two special version numbers:; 4589///; 4590/// - 0: Use the class version from the currently loaded class library.; 4591/// - -1: Assume no class library loaded (emulated class).; 4592///; 4593/// Warning: If we create a new streamer info, whether or not the build; 4594/// optimizes is controlled externally to us by a global variable!; 4595/// Don't call us unless you have set that variable properly; 4596/// with TStreamer::Optimize()!; 4597///; 4598 ; 4599TVirtualStreamerInfo* TClass::GetStreamerInfo(Int_t version /* = 0 */, Bool_t isTransient /* = false */) const; 4600{; 4601 TVirtualStreamerInfo *sinfo = fLastReadInfo;; 4602 ; 4603 // Version 0 is special, it means the currently loaded version.; 4604 // We need to set it at the beginning to be able to guess it correctly.; 4605 ; 4606 if (version == 0); 4607 version = fClassVersion;; 4608 ; 4609 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4610 // guaranteed it was built and compiled.; 4611 if (sinfo && sinfo->GetClassVersion() == version); 4612 return sinfo;; 4613 ; 4614 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4615 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4616 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4617 // However, direct access to fClassVersion should be replaced",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:173509,optimiz,optimizes,173509,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,3,"['Optimiz', 'load', 'optimiz']","['Optimize', 'loaded', 'optimizes']"
Performance,"/// number of currently loaded methods use:; 4638/// cl->GetListOfMethods(false)->GetSize();; 4639 ; 4640Int_t TClass::GetNmethods(); 4641{; 4642 if (!HasInterpreterInfo()) return 0;; 4643 ; 4644 TList *lm = GetListOfMethods();; 4645 if (lm); 4646 return lm->GetSize();; 4647 else; 4648 return 0;; 4649}; 4650 ; 4651////////////////////////////////////////////////////////////////////////////////; 4652/// returns a pointer to the TVirtualStreamerInfo object for version; 4653/// If the object does not exist, it is created; 4654///; 4655/// Note: There are two special version numbers:; 4656///; 4657/// - 0: Use the class version from the currently loaded class library.; 4658/// - -1: Assume no class library loaded (emulated class).; 4659///; 4660/// Warning: If we create a new streamer info, whether or not the build; 4661/// optimizes is controlled externally to us by a global variable!; 4662/// Don't call us unless you have set that variable properly; 4663/// with TStreamer::Optimize()!; 4664///; 4665 ; 4666TVirtualStreamerInfo* TClass::GetStreamerInfo(Int_t version /* = 0 */, Bool_t isTransient /* = false */) const; 4667{; 4668 TVirtualStreamerInfo *sinfo = fLastReadInfo;; 4669 ; 4670 // Version 0 is special, it means the currently loaded version.; 4671 // We need to set it at the beginning to be able to guess it correctly.; 4672 ; 4673 if (version == 0); 4674 version = fClassVersion;; 4675 ; 4676 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4677 // guaranteed it was built and compiled.; 4678 if (sinfo && sinfo->GetClassVersion() == version); 4679 return sinfo;; 4680 ; 4681 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4682 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4683 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4684 // However, direct access to fClassVersion should be replaced",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:176260,optimiz,optimizes,176260,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,3,"['Optimiz', 'load', 'optimiz']","['Optimize', 'loaded', 'optimizes']"
Performance,"////////////////////////////////////////////////////////////////////////////////; 461 /// Keeps track of the status of ImplicitMT w/o resorting to the load of; 462 /// libImt; 463 static Bool_t &IsImplicitMTEnabledImpl(); 464 {; 465 static Bool_t isImplicitMTEnabled = kFALSE;; 466 return isImplicitMTEnabled;; 467 }; 468 ; 469} // end of Internal sub namespace; 470// back to ROOT namespace; 471 ; 472 TROOT *GetROOT() {; 473 return (*Internal::gGetROOT)();; 474 }; 475 ; 476 TString &GetMacroPath() {; 477 static TString macroPath;; 478 return macroPath;; 479 }; 480 ; 481 // clang-format off; 482 ////////////////////////////////////////////////////////////////////////////////; 483 /// Enables the global mutex to make ROOT thread safe/aware.; 484 ///; 485 /// The following becomes safe:; 486 /// - concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); 487 /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; 489 /// - concurrent calls to the interpreter through gInterpreter; 490 /// - concurrent loading of ROOT plug-ins; 491 ///; 492 /// In addition, gDirectory, gFile and gPad become a thread-local variable.; 493 /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.; 494 /// gFile and gPad default to nullptr, as it is for single-thread programs.; 495 ///; 496 /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; 497 /// canvases from different threads (and analogous operations such as invoking `Draw` on a `TObject`) is not thread-safe.; 498 ///; 499 /// Note that there is no `DisableThreadSafety()`. ROOT's thread-saf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:17101,concurren,concurrent,17101,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['concurren'],['concurrent']
Performance,"////////////////////////////////////////////////////////////////////////////////; 4885/// Get CPU load on Mac OS X.; 4886 ; 4887static void ReadDarwinCpu(long *ticks); 4888{; 4889 mach_msg_type_number_t count;; 4890 kern_return_t kr;; 4891 host_cpu_load_info_data_t cpu;; 4892 ; 4893 ticks[0] = ticks[1] = ticks[2] = ticks[3] = 0;; 4894 ; 4895 count = HOST_CPU_LOAD_INFO_COUNT;; 4896 kr = host_statistics(mach_host_self(), HOST_CPU_LOAD_INFO, (host_info_t)&cpu, &count);; 4897 if (kr != KERN_SUCCESS) {; 4898 ::Error(""TUnixSystem::ReadDarwinCpu"", ""host_statistics: %s"", mach_error_string(kr));; 4899 } else {; 4900 ticks[0] = cpu.cpu_ticks[CPU_STATE_USER];; 4901 ticks[1] = cpu.cpu_ticks[CPU_STATE_SYSTEM];; 4902 ticks[2] = cpu.cpu_ticks[CPU_STATE_IDLE];; 4903 ticks[3] = cpu.cpu_ticks[CPU_STATE_NICE];; 4904 }; 4905}; 4906 ; 4907////////////////////////////////////////////////////////////////////////////////; 4908/// Get CPU stat for Mac OS X. Use sampleTime to set the interval over which; 4909/// the CPU load will be measured, in ms (default 1000).; 4910 ; 4911static void GetDarwinCpuInfo(CpuInfo_t *cpuinfo, Int_t sampleTime); 4912{; 4913 Double_t avg[3];; 4914 if (getloadavg(avg, sizeof(avg)) < 0) {; 4915 ::Error(""TUnixSystem::GetDarwinCpuInfo"", ""getloadavg failed"");; 4916 } else {; 4917 cpuinfo->fLoad1m = (Float_t)avg[0];; 4918 cpuinfo->fLoad5m = (Float_t)avg[1];; 4919 cpuinfo->fLoad15m = (Float_t)avg[2];; 4920 }; 4921 ; 4922 Long_t cpu_ticks1[4], cpu_ticks2[4];; 4923 ReadDarwinCpu(cpu_ticks1);; 4924 gSystem->Sleep(sampleTime);; 4925 ReadDarwinCpu(cpu_ticks2);; 4926 ; 4927 Long_t userticks = (cpu_ticks2[0] + cpu_ticks2[3]) -; 4928 (cpu_ticks1[0] + cpu_ticks1[3]);; 4929 Long_t systicks = cpu_ticks2[1] - cpu_ticks1[1];; 4930 Long_t idleticks = cpu_ticks2[2] - cpu_ticks1[2];; 4931 if (userticks < 0) userticks = 0;; 4932 if (systicks < 0) systicks = 0;; 4933 if (idleticks < 0) idleticks = 0;; 4934 Long_t totalticks = userticks + systicks + idleticks;; 4935 if (totalticks) {; 49",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:157935,load,load,157935,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['load'],['load']
Performance,"/////////////////////////////////////////////////////////////////////////////; 1076/// Get the new 'bombed' translation vector according current exploded view mode.; 1077 ; 1078void TGeoManager::BombTranslation(const Double_t *tr, Double_t *bombtr); 1079{; 1080 if (fPainter); 1081 fPainter->BombTranslation(tr, bombtr);; 1082 return;; 1083}; 1084 ; 1085////////////////////////////////////////////////////////////////////////////////; 1086/// Get the new 'unbombed' translation vector according current exploded view mode.; 1087 ; 1088void TGeoManager::UnbombTranslation(const Double_t *tr, Double_t *bombtr); 1089{; 1090 if (fPainter); 1091 fPainter->UnbombTranslation(tr, bombtr);; 1092 return;; 1093}; 1094 ; 1095////////////////////////////////////////////////////////////////////////////////; 1096/// Backup the current state without affecting the cache stack.; 1097 ; 1098void TGeoManager::DoBackupState(); 1099{; 1100 GetCurrentNavigator()->DoBackupState();; 1101}; 1102 ; 1103////////////////////////////////////////////////////////////////////////////////; 1104/// Restore a backed-up state without affecting the cache stack.; 1105 ; 1106void TGeoManager::DoRestoreState(); 1107{; 1108 GetCurrentNavigator()->DoRestoreState();; 1109}; 1110 ; 1111////////////////////////////////////////////////////////////////////////////////; 1112/// Register a matrix to the list of matrices. It will be cleaned-up at the; 1113/// destruction TGeoManager.; 1114 ; 1115void TGeoManager::RegisterMatrix(const TGeoMatrix *matrix); 1116{; 1117 return TGeoBuilder::Instance(this)->RegisterMatrix((TGeoMatrix *)matrix);; 1118}; 1119 ; 1120////////////////////////////////////////////////////////////////////////////////; 1121/// Replaces all occurrences of VORIG with VNEW in the geometry tree. The volume VORIG; 1122/// is not replaced from the list of volumes, but all node referencing it will reference; 1123/// VNEW instead. Returns number of occurrences changed.; 1124 ; 1125Int_t TGeoManager::ReplaceVolum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:39794,cache,cache,39794,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['cache'],['cache']
Performance,"/////////////////////////////////////////////////////////////////////////////; 351/// Always return 0 (current processID).; 352 ; 353UShort_t TBuffer::WriteProcessID(TProcessID *); 354{; 355 return 0;; 356}; 357 ; 358////////////////////////////////////////////////////////////////////////////////; 359/// Push a new data cache area onto the list of area to be used for; 360/// temporarily store 'missing' data members.; 361 ; 362void TBuffer::PushDataCache(TVirtualArray *obj); 363{; 364 fCacheStack.push_back(obj);; 365}; 366 ; 367////////////////////////////////////////////////////////////////////////////////; 368/// Return the 'current' data cache area from the list of area to be used for; 369/// temporarily store 'missing' data members.; 370 ; 371TVirtualArray *TBuffer::PeekDataCache() const; 372{; 373 if (fCacheStack.empty()) return nullptr;; 374 return fCacheStack.back();; 375}; 376 ; 377////////////////////////////////////////////////////////////////////////////////; 378/// Pop and Return the 'current' data cache area from the list of area to be used for; 379/// temporarily store 'missing' data members.; 380 ; 381TVirtualArray *TBuffer::PopDataCache(); 382{; 383 TVirtualArray *val = PeekDataCache();; 384 fCacheStack.pop_back();; 385 return val;; 386}; 387 ; 388////////////////////////////////////////////////////////////////////////////////; 389/// Byte-swap N primitive-elements in the buffer.; 390/// Bulk API relies on this function.; 391 ; 392Bool_t TBuffer::ByteSwapBuffer(Long64_t n, EDataType type); 393{; 394 char *input_buf = GetCurrent();; 395 if ((type == EDataType::kShort_t) || (type == EDataType::kUShort_t)) {; 396#ifdef R__BYTESWAP; 397 Short_t *buf __attribute__((aligned(8))) = reinterpret_cast<Short_t*>(input_buf);; 398 for (int idx=0; idx<n; idx++) {; 399 Short_t tmp = *reinterpret_cast<Short_t*>(buf + idx); // Makes a copy of the values; frombuf can't handle aliasing.; 400 char *tmp_ptr = reinterpret_cast<char *>(&tmp);; 401 frombuf(tmp_ptr, buf + idx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBuffer_8cxx_source.html:12613,cache,cache,12613,doc/master/TBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html,1,['cache'],['cache']
Performance,"/////////////////////////////////////////////////////////////////////////////; 4692/// For the case where the requestor class is emulated and this class is abstract,; 4693/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; 4694/// representation whether or not the class is loaded.; 4695///; 4696/// If the object does not exist, it is created; 4697///; 4698/// Note: There are two special version numbers:; 4699///; 4700/// - 0: Use the class version from the currently loaded class library.; 4701/// - -1: Assume no class library loaded (emulated class).; 4702///; 4703/// Warning: If we create a new streamer info, whether or not the build; 4704/// optimizes is controlled externally to us by a global variable!; 4705/// Don't call us unless you have set that variable properly; 4706/// with TStreamer::Optimize()!; 4707///; 4708 ; 4709TVirtualStreamerInfo* TClass::GetStreamerInfoAbstractEmulated(Int_t version /* = 0 */) const; 4710{; 4711 TVirtualStreamerInfo *sinfo = nullptr;; 4712 ; 4713 TString newname(GetName());; 4714 newname += ""@@emulated"";; 4715 ; 4716 R__LOCKGUARD(gInterpreterMutex);; 4717 ; 4718 TClass *emulated = TClass::GetClass(newname);; 4719 ; 4720 if (emulated); 4721 sinfo = emulated->GetStreamerInfo(version);; 4722 ; 4723 if (!sinfo) {; 4724 // The emulated version of the streamerInfo is explicitly requested and has; 4725 // not been built yet.; 4726 ; 4727 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(version);; 4728 ; 4729 if (!sinfo && (version != fClassVersion)) {; 4730 // When the requested version does not exist we return; 4731 // the TVirtualStreamerInfo for the currently loaded class version.; 4732 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4733 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4734 }; 4735 ; 4736 if (!sinfo) {; 4737 // Let's take the first available StreamerInfo as a start; 4738 Int_t ninfos = fStreamerInfo->GetEntriesFast() - 1;; 4739 f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:178684,optimiz,optimizes,178684,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,"['Optimiz', 'optimiz']","['Optimize', 'optimizes']"
Performance,"/////////////////////////////////////////////////////////////////////////////; 4759/// For the case where the requestor class is emulated and this class is abstract,; 4760/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; 4761/// representation whether or not the class is loaded.; 4762///; 4763/// If the object does not exist, it is created; 4764///; 4765/// Note: There are two special version numbers:; 4766///; 4767/// - 0: Use the class version from the currently loaded class library.; 4768/// - -1: Assume no class library loaded (emulated class).; 4769///; 4770/// Warning: If we create a new streamer info, whether or not the build; 4771/// optimizes is controlled externally to us by a global variable!; 4772/// Don't call us unless you have set that variable properly; 4773/// with TStreamer::Optimize()!; 4774///; 4775 ; 4776TVirtualStreamerInfo* TClass::GetStreamerInfoAbstractEmulated(Int_t version /* = 0 */) const; 4777{; 4778 TVirtualStreamerInfo *sinfo = nullptr;; 4779 ; 4780 TString newname(GetName());; 4781 newname += ""@@emulated"";; 4782 ; 4783 R__LOCKGUARD(gInterpreterMutex);; 4784 ; 4785 TClass *emulated = TClass::GetClass(newname);; 4786 ; 4787 if (emulated); 4788 sinfo = emulated->GetStreamerInfo(version);; 4789 ; 4790 if (!sinfo) {; 4791 // The emulated version of the streamerInfo is explicitly requested and has; 4792 // not been built yet.; 4793 ; 4794 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(version);; 4795 ; 4796 if (!sinfo && (version != fClassVersion)) {; 4797 // When the requested version does not exist we return; 4798 // the TVirtualStreamerInfo for the currently loaded class version.; 4799 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4800 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4801 }; 4802 ; 4803 if (!sinfo) {; 4804 // Let's take the first available StreamerInfo as a start; 4805 Int_t ninfos = fStreamerInfo->GetEntriesFast() - 1;; 4806 f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:181435,optimiz,optimizes,181435,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,"['Optimiz', 'optimiz']","['Optimize', 'optimizes']"
Performance,"////////////////////////////////////////////////////////////////////////////; 6466/// Set current entry.; 6467///; 6468/// Returns -2 if entry does not exist (just as TChain::LoadTree()).; 6469/// Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; 6470///; 6471/// Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; 6472///; 6473/// \note This function is overloaded in TChain.; 6474Long64_t TTree::LoadTree(Long64_t entry); 6475{; 6476 // We have already been visited while recursively looking; 6477 // through the friend trees, let's return; 6478 if (kLoadTree & fFriendLockStatus) {; 6479 // We need to return a negative value to avoid a circular list of friends; 6480 // to think that there is always an entry somewhere in the list.; 6481 return -1;; 6482 }; 6483 ; 6484 // create cache if wanted; 6485 if (fCacheDoAutoInit && entry >=0); 6486 SetCacheSizeAux();; 6487 ; 6488 if (fNotify) {; 6489 if (fReadEntry < 0) {; 6490 fNotify->Notify();; 6491 }; 6492 }; 6493 fReadEntry = entry;; 6494 ; 6495 bool friendHasEntry = false;; 6496 if (fFriends) {; 6497 // Set current entry in friends as well.; 6498 //; 6499 // An alternative would move this code to each of the; 6500 // functions calling LoadTree (and to overload a few more).; 6501 bool needUpdate = false;; 6502 {; 6503 // This scope is need to insure the lock is released at the right time; 6504 TIter nextf(fFriends);; 6505 TFriendLock lock(this, kLoadTree);; 6506 TFriendElement* fe = nullptr;; 6507 while ((fe = (TFriendElement*) nextf())) {; 6508 if (fe->TestBit(TFriendElement::kFromChain)) {; 6509 // This friend element was added by the chain that owns this; 6510 // tree, the chain will deal with loading the correct entry.; 6511 continue;; 6512 }; 6513 TTree* friendTree = fe->GetTree();; 6514 if (friendTree) {; 6515 if (friendTree->LoadTreeFriend(entry, this) >= 0) {; 6516 friendHasEntry = true;; 6517 }; 6518 }; 6519 if (fe->IsUpdated()) {; 65",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:253515,cache,cache,253515,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////; 675/// Return hash value.; 676 ; 677UInt_t TString::Hash(ECaseCompare cmp) const; 678{; 679 return (cmp == kExact) ? HashCase() : HashFoldCase();; 680}; 681 ; 682 // MurmurHash3 - a blazingly fast public domain hash!; 683 // See http://code.google.com/p/smhasher/; 684 // There are two versions, one optimized for 32 bit and one for 64 bit.; 685 // They give different hash results!; 686 // We use only the 64 bit version which also works on 32 bit.; 687 ; 688 //-----------------------------------------------------------------------------; 689 // MurmurHash3 was written by Austin Appleby, and is placed in the public; 690 // domain. The author hereby disclaims copyright to this source code.; 691 ; 692 // Note - The x86 and x64 versions do _not_ produce the same results, as the; 693 // algorithms are optimized for their respective platforms. You can still; 694 // compile and run any of them on any platform, but your performance with the; 695 // non-native version will be less than optimal.; 696 ; 697 //-----------------------------------------------------------------------------; 698 // Platform-specific functions and macros; 699 ; 700 // From MurmurHash.h:; 701 ; 702#if defined(_MSC_VER) && (_MSC_VER < 1800); 703 // Microsoft Visual Studio; 704 typedef unsigned char uint8_t;; 705 typedef unsigned long uint32_t;; 706 typedef unsigned __int64 uint64_t;; 707#else // defined(_MSC_VER); 708 // Other compilers; 709#include <stdint.h>; 710#endif // !defined(_MSC_VER); 711 ; 712 // From MurmurHash.cpp:; 713#if defined(_MSC_VER); 714 // Microsoft Visual Studio; 715#include <stdlib.h>; 716#define ROTL64(x,y) _rotl64(x,y); 717#define BIG_CONSTANT(x) (x); 718#else // defined(_MSC_VER); 719 // Other compilers; 720 inline uint64_t rotl64 ( uint64_t x, int8_t r ); 721 {; 722 return (x << r) | (x >> (64 - r));; 723 }; 724 ; 725#define ROTL64(x,y) rotl64(x,y); 726#define BIG_CONSTANT(x) (x##LLU); 727#endif // !d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:20715,perform,performance,20715,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////; 627/// Add entry \#entry to the list; 628/// - When tree = 0, adds to the current list; 629/// - When tree != 0, finds the list, corresponding to this tree; 630/// - When tree is a chain, the entry is assumed to be global index and the local; 631/// entry is recomputed from the treeoffset information of the chain; 632 ; 633bool TEntryList::Enter(Long64_t entry, TTree *tree); 634{; 635 if (!tree){; 636 if (!fLists) {; 637 if (!fBlocks) fBlocks = new TObjArray();; 638 TEntryListBlock *block = nullptr;; 639 Long64_t nblock = entry/kBlockSize;; 640 if (nblock >= fNBlocks) {; 641 if (fNBlocks>0){; 642 block = (TEntryListBlock*)fBlocks->UncheckedAt(fNBlocks-1);; 643 if (!block) return false;; 644 block->OptimizeStorage();; 645 }; 646 for (Int_t i=fNBlocks; i<=nblock; i++){; 647 block = new TEntryListBlock();; 648 fBlocks->Add(block);; 649 }; 650 fNBlocks = nblock+1;; 651 }; 652 block = (TEntryListBlock*)fBlocks->UncheckedAt(nblock);; 653 if (block->Enter(entry-nblock*kBlockSize)) {; 654 fN++;; 655 return true;; 656 }; 657 } else {; 658 //the entry in the current entry list; 659 if (!fCurrent) fCurrent = (TEntryList*)fLists->First();; 660 if (fCurrent->Enter(entry)) {; 661 if (fLists); 662 fN++;; 663 return true;; 664 }; 665 }; 666 } else {; 667 Long64_t localentry = tree->LoadTree(entry);; 668 SetTree(tree->GetTree());; 669 if (fCurrent){; 670 if (fCurrent->Enter(localentry)) {; 671 if (fLists); 672 fN++;; 673 return true;; 674 }; 675 }; 676 }; 677 return false;; 678 ; 679}; 680 ; 681bool TEntryList::Enter(Long64_t localentry, const char *treename, const char *filename); 682{; 683 SetTree(treename, filename);; 684 if (fCurrent) {; 685 if (fCurrent->Enter(localentry)) {; 686 if (fLists); 687 fN++;; 688 return true;; 689 }; 690 }; 691 return false;; 692}; 693 ; 694/////////////////////////////////////////////////////////////////////////////; 695/// \brief Enter all entries in a range in the TEntryList.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEntryList_8cxx_source.html:22753,Load,LoadTree,22753,doc/master/TEntryList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html,1,['Load'],['LoadTree']
Performance,"//////////////////////////////////////////////////////////////////////; 187/// Set distance between the axis and the labels.; 188/// The distance is expressed in per cent of the pad width.; 189/// A negative value allow to draw the label on the other side of the axis.; 190 ; 191void TAttAxis::SetLabelOffset(Float_t offset); 192{; 193 fLabelOffset = offset;; 194 if (gPad) gPad->Modified();; 195}; 196 ; 197 ; 198////////////////////////////////////////////////////////////////////////////////; 199/// Set size of axis labels.; 200/// The size is expressed in per cent of the pad size, unless the font precision; 201/// is 3 and in that case the size is expressed in pixels.; 202 ; 203void TAttAxis::SetLabelSize(Float_t size); 204{; 205 fLabelSize = size;; 206 if (gPad) gPad->Modified();; 207}; 208 ; 209////////////////////////////////////////////////////////////////////////////////; 210/// Set the number of divisions for this axis.; 211///; 212/// - if optim = kTRUE (default), the number of divisions will be; 213/// optimized around the specified value.; 214/// - if optim = kFALSE, or n < 0, the axis will be forced to use; 215/// exactly n divisions.; 216///~~~ {.cpp}; 217/// n = n1 + 100*n2 + 10000*n3; 218///~~~; 219/// Where n1 is the number of primary divisions,; 220/// n2 is the number of second order divisions and; 221/// n3 is the number of third order divisions.; 222///; 223/// If the number of divisions is ""optimized"" (see above) n1, n2, n3 are; 224/// maximum values.; 225///; 226/// Examples:; 227///; 228/// - ndiv = 0: no tick marks.; 229/// - ndiv = 2: 2 divisions, one tick mark in the middle of the axis.; 230/// - ndiv = 510: 10 primary divisions, 5 secondary divisions.; 231/// - ndiv = -10: exactly 10 primary divisions.; 232 ; 233void TAttAxis::SetNdivisions(Int_t n, Bool_t optim); 234{; 235 Int_t ndiv = (n%1000000);; 236 Bool_t isOptimized = optim && (ndiv>0);; 237 Int_t current_maxDigits = abs(fNdivisions)/1000000;; 238 fNdivisions = abs(ndiv) + current_maxD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TAttAxis_8cxx_source.html:7444,optimiz,optimized,7444,doc/master/TAttAxis_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TAttAxis_8cxx_source.html,1,['optimiz'],['optimized']
Performance,"//////////////////////////////////////////////////////////////////////; 4624/// Sets the directory where to locally stage/cache remote files.; 4625/// If the directory is not writable by us return kFALSE.; 4626 ; 4627Bool_t TFile::SetCacheFileDir(std::string_view cachedir, Bool_t operatedisconnected,; 4628 Bool_t forcecacheread ); 4629{; 4630 TString cached{cachedir};; 4631 if (!cached.EndsWith(""/"")); 4632 cached += ""/"";; 4633 ; 4634 if (gSystem->AccessPathName(cached, kFileExists)) {; 4635 // try to create it; 4636 gSystem->mkdir(cached, kTRUE);; 4637 if (gSystem->AccessPathName(cached, kFileExists)) {; 4638 ::Error(""TFile::SetCacheFileDir"", ""no sufficient permissions on cache directory %s or cannot create it"", TString(cachedir).Data());; 4639 fgCacheFileDir = """";; 4640 return kFALSE;; 4641 }; 4642 gSystem->Chmod(cached, 0700);; 4643 }; 4644 if (gSystem->AccessPathName(cached, kWritePermission)); 4645 gSystem->Chmod(cached, 0700);; 4646 fgCacheFileDir = cached;; 4647 fgCacheFileDisconnected = operatedisconnected;; 4648 fgCacheFileForce = forcecacheread;; 4649 return kTRUE;; 4650}; 4651 ; 4652////////////////////////////////////////////////////////////////////////////////; 4653/// Get the directory where to locally stage/cache remote files.; 4654 ; 4655const char *TFile::GetCacheFileDir(); 4656{; 4657 return fgCacheFileDir;; 4658}; 4659 ; 4660////////////////////////////////////////////////////////////////////////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the minimum amount of time after; 4664/// the previous cleanup before the cleanup operation is repeated in; 4665/// the cache directory; 4666 ; 4667Bool_t TFile::ShrinkCacheFileDir(Long64_t shrinksize, Long_t cleanupinterval); 4668{; 4669 if (fgCacheFileDir == """") {; 4670 return kFALSE;; 4671 }; 4672 ; 4673 // check the last clean-up in the cache; 4674 Long_t id;; 4675 Long64_t size;; 4676 Long_t flags;; 4677 Long_t modtime;; 4678 ; 4679 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:169761,cache,cached,169761,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,5,['cache'],"['cache', 'cached']"
Performance,"////////////////////////////////////////////////////////////////////; 3403 ; 3404Bool_t TClass::GetClass(DeclId_t id, std::vector<TClass*> &classes); 3405{; 3406 if (!gROOT->GetListOfClasses()) return 0;; 3407 ; 3408 DeclIdMap_t* map = GetDeclIdMap();; 3409 // Get all the TClass pointer that have the same DeclId.; 3410 DeclIdMap_t::equal_range iter = map->Find(id);; 3411 if (iter.first == iter.second) return false;; 3412 std::vector<TClass*>::iterator vectIt = classes.begin();; 3413 for (DeclIdMap_t::const_iterator it = iter.first; it != iter.second; ++it); 3414 vectIt = classes.insert(vectIt, it->second);; 3415 return true;; 3416}; 3417 ; 3418////////////////////////////////////////////////////////////////////////////////; 3419/// Return a pointer to the dictionary loading function generated by; 3420/// rootcint; 3421 ; 3422DictFuncPtr_t TClass::GetDict (const char *cname); 3423{; 3424 return TClassTable::GetDict(cname);; 3425}; 3426 ; 3427////////////////////////////////////////////////////////////////////////////////; 3428/// Return a pointer to the dictionary loading function generated by; 3429/// rootcint; 3430 ; 3431DictFuncPtr_t TClass::GetDict (const std::type_info& info); 3432{; 3433 return TClassTable::GetDict(info);; 3434}; 3435 ; 3436////////////////////////////////////////////////////////////////////////////////; 3437/// Return pointer to datamember object with name ""datamember"".; 3438 ; 3439TDataMember *TClass::GetDataMember(const char *datamember) const; 3440{; 3441 if ((!(fData.load() && (*fData).IsLoaded()) && !HasInterpreterInfo()); 3442 || datamember == nullptr) return nullptr;; 3443 ; 3444 // Strip off leading *'s and trailing [; 3445 const char *start_name = datamember;; 3446 while (*start_name == '*') ++start_name;; 3447 ; 3448 // Empty name are 'legal', they represent anonymous unions.; 3449 // if (*start_name == 0) return 0;; 3450 ; 3451 if (const char *s = strchr(start_name, '[')){; 3452 UInt_t len = s-start_name;; 3453 TString name(start_nam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:130104,load,loading,130104,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,['load'],['loading']
Performance,"////////////////////////////////////////////////////////////////////; 3470 ; 3471Bool_t TClass::GetClass(DeclId_t id, std::vector<TClass*> &classes); 3472{; 3473 if (!gROOT->GetListOfClasses()) return 0;; 3474 ; 3475 DeclIdMap_t* map = GetDeclIdMap();; 3476 // Get all the TClass pointer that have the same DeclId.; 3477 DeclIdMap_t::equal_range iter = map->Find(id);; 3478 if (iter.first == iter.second) return false;; 3479 std::vector<TClass*>::iterator vectIt = classes.begin();; 3480 for (DeclIdMap_t::const_iterator it = iter.first; it != iter.second; ++it); 3481 vectIt = classes.insert(vectIt, it->second);; 3482 return true;; 3483}; 3484 ; 3485////////////////////////////////////////////////////////////////////////////////; 3486/// Return a pointer to the dictionary loading function generated by; 3487/// rootcint; 3488 ; 3489DictFuncPtr_t TClass::GetDict (const char *cname); 3490{; 3491 return TClassTable::GetDict(cname);; 3492}; 3493 ; 3494////////////////////////////////////////////////////////////////////////////////; 3495/// Return a pointer to the dictionary loading function generated by; 3496/// rootcint; 3497 ; 3498DictFuncPtr_t TClass::GetDict (const std::type_info& info); 3499{; 3500 return TClassTable::GetDict(info);; 3501}; 3502 ; 3503////////////////////////////////////////////////////////////////////////////////; 3504/// Return pointer to datamember object with name ""datamember"".; 3505 ; 3506TDataMember *TClass::GetDataMember(const char *datamember) const; 3507{; 3508 if ((!(fData.load() && (*fData).IsLoaded()) && !HasInterpreterInfo()); 3509 || datamember == nullptr) return nullptr;; 3510 ; 3511 // Strip off leading *'s and trailing [; 3512 const char *start_name = datamember;; 3513 while (*start_name == '*') ++start_name;; 3514 ; 3515 // Empty name are 'legal', they represent anonymous unions.; 3516 // if (*start_name == 0) return 0;; 3517 ; 3518 if (const char *s = strchr(start_name, '[')){; 3519 UInt_t len = s-start_name;; 3520 TString name(start_nam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:132855,load,loading,132855,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['load'],['loading']
Performance,"///////////////////////////////////////////////////////////////////; 95/// As the database is read-only, syncing data to disc is a no-op and always succeeds; 96int VfsRdOnlySync(sqlite3_file * /*pFile*/, int /*flags*/); 97{; 98 return SQLITE_OK;; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////; 102/// Returns the cached file size; 103int VfsRdOnlyFileSize(sqlite3_file *pFile, sqlite_int64 *pSize); 104{; 105 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 106 *pSize = p->fRawFile->GetSize();; 107 return SQLITE_OK;; 108}; 109 ; 110////////////////////////////////////////////////////////////////////////////; 111/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 112int VfsRdOnlyLock(sqlite3_file * /*pFile*/, int /*level*/); 113{; 114 return SQLITE_OK;; 115}; 116 ; 117////////////////////////////////////////////////////////////////////////////; 118/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 119int VfsRdOnlyUnlock(sqlite3_file * /*pFile*/, int /*level*/); 120{; 121 return SQLITE_OK;; 122}; 123 ; 124////////////////////////////////////////////////////////////////////////////; 125/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 126int VfsRdOnlyCheckReservedLock(sqlite3_file * /*pFile*/, int *pResOut); 127{; 128 *pResOut = 0;; 129 return SQLITE_OK;; 130}; 131 ; 132////////////////////////////////////////////////////////////////////////////; 133/// As the database is read-only, we know there are no additional control files such as a database journal; 134int VfsRdOnlyFileControl(sqlite3_file * /*p*/, int /*op*/, void * /*pArg*/); 135{; 136 return SQLITE_NOTFOUND;; 137}; 138 ; 139////////////////////////////////////////////////////////////////////////////; 140/// The database device's sector size is only needed for writing; 141int VfsRdOnlySectorSize(sqlite3_file * /*pFile*/); 142{; 143 retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RSqliteDS_8cxx_source.html:5475,concurren,concurrent,5475,doc/master/RSqliteDS_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html,1,['concurren'],['concurrent']
Performance,"///////////////////////////////////////////////////////////////; 877/// See TTree::GetReadEntry().; 878 ; 879TLeaf* TChain::FindLeaf(const char* searchname); 880{; 881 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 882 // Make sure the element list is up to date; 883 if (!TestBit(kProofUptodate)); 884 SetProof(true, true);; 885 return fProofChain->FindLeaf(searchname);; 886 }; 887 if (fTree) {; 888 return fTree->FindLeaf(searchname);; 889 }; 890 LoadTree(0);; 891 if (fTree) {; 892 return fTree->FindLeaf(searchname);; 893 }; 894 return nullptr;; 895}; 896 ; 897////////////////////////////////////////////////////////////////////////////////; 898/// Returns the expanded value of the alias. Search in the friends if any.; 899 ; 900const char* TChain::GetAlias(const char* aliasName) const; 901{; 902 const char* alias = TTree::GetAlias(aliasName);; 903 if (alias) {; 904 return alias;; 905 }; 906 if (fTree) {; 907 return fTree->GetAlias(aliasName);; 908 }; 909 const_cast<TChain*>(this)->LoadTree(0);; 910 if (fTree) {; 911 return fTree->GetAlias(aliasName);; 912 }; 913 return nullptr;; 914}; 915 ; 916////////////////////////////////////////////////////////////////////////////////; 917/// Return pointer to the branch name in the current tree.; 918 ; 919TBranch* TChain::GetBranch(const char* name); 920{; 921 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 922 // Make sure the element list is up to date; 923 if (!TestBit(kProofUptodate)); 924 SetProof(true, true);; 925 return fProofChain->GetBranch(name);; 926 }; 927 if (fTree) {; 928 return fTree->GetBranch(name);; 929 }; 930 LoadTree(0);; 931 if (fTree) {; 932 return fTree->GetBranch(name);; 933 }; 934 return nullptr;; 935}; 936 ; 937////////////////////////////////////////////////////////////////////////////////; 938/// See TTree::GetReadEntry().; 939 ; 940bool TChain::GetBranchStatus(const char* branchname) const; 941{; 942 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 943 // Make sure the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:34462,Load,LoadTree,34462,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['Load'],['LoadTree']
Performance,"///////////////////////////////////////////////////////////; 1967/// Load all libraries known to ROOT via the rootmap system.; 1968/// Returns the number of top level libraries successfully loaded.; 1969 ; 1970UInt_t TSystem::LoadAllLibraries(); 1971{; 1972 UInt_t nlibs = 0;; 1973 ; 1974 TEnv* mapfile = gInterpreter->GetMapfile();; 1975 if (!mapfile || !mapfile->GetTable()) return 0;; 1976 ; 1977 std::set<std::string> loadedlibs;; 1978 std::set<std::string> failedlibs;; 1979 ; 1980 TEnvRec* rec = nullptr;; 1981 TIter iEnvRec(mapfile->GetTable());; 1982 while ((rec = (TEnvRec*) iEnvRec())) {; 1983 TString libs = rec->GetValue();; 1984 TString lib;; 1985 Ssiz_t pos = 0;; 1986 while (libs.Tokenize(lib, pos)) {; 1987 // check that none of the libs failed to load; 1988 if (failedlibs.find(lib.Data()) != failedlibs.end()) {; 1989 // don't load it or any of its dependencies; 1990 libs = """";; 1991 break;; 1992 }; 1993 }; 1994 pos = 0;; 1995 while (libs.Tokenize(lib, pos)) {; 1996 // ignore libCore - it's already loaded; 1997 if (lib.BeginsWith(""libCore"")); 1998 continue;; 1999 ; 2000 if (loadedlibs.find(lib.Data()) == loadedlibs.end()) {; 2001 // just load the first library - TSystem will do the rest.; 2002 auto res = gSystem->Load(lib);; 2003 if (res >=0) {; 2004 if (res == 0) ++nlibs;; 2005 loadedlibs.insert(lib.Data());; 2006 } else {; 2007 failedlibs.insert(lib.Data());; 2008 }; 2009 }; 2010 }; 2011 }; 2012 return nlibs;; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Find a dynamic library called lib using the system search paths.; 2017/// Appends known extensions if needed. Returned string must be deleted; 2018/// by the user!; 2019 ; 2020char *TSystem::DynamicPathName(const char *lib, Bool_t quiet /*=kFALSE*/); 2021{; 2022 TString sLib(lib);; 2023 if (FindDynamicLibrary(sLib, quiet)); 2024 return StrDup(sLib);; 2025 return nullptr;; 2026}; 2027 ; 2028/////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:64511,load,loaded,64511,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['loaded']
Performance,"///////////////////////////////////////////////////////////; 2684 ; 2685RooAbsPdf::GenSpec::GenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen,; 2686 bool extended, bool randProto, bool resampleProto, TString dsetName, bool init) :; 2687 _genContext(context), _whatVars(whatVars), _protoData(protoData), _nGen(nGen), _extended(extended),; 2688 _randProto(randProto), _resampleProto(resampleProto), _dsetName(dsetName), _init(init); 2689{; 2690}; 2691 ; 2692 ; 2693namespace {; 2694 ; 2695void sterilizeClientCaches(RooAbsArg & arg) {; 2696 auto const& clients = arg.clients();; 2697 for(std::size_t iClient = 0; iClient < clients.size(); ++iClient) {; 2698 ; 2699 const std::size_t oldClientsSize = clients.size();; 2700 RooAbsArg* client = clients[iClient];; 2701 ; 2702 for(int iCache = 0; iCache < client->numCaches(); ++iCache) {; 2703 if(auto cacheMgr = dynamic_cast<RooObjCacheManager*>(client->getCache(iCache))) {; 2704 cacheMgr->sterilize();; 2705 }; 2706 }; 2707 ; 2708 // It can happen that the objects cached by the client are also clients of; 2709 // the arg itself! In that case, the position of the client in the client; 2710 // list might have changed, and we need to find the new index.; 2711 if(clients.size() != oldClientsSize) {; 2712 auto clientIter = std::find(clients.begin(), clients.end(), client);; 2713 if(clientIter == clients.end()) {; 2714 throw std::runtime_error(""After a clients caches were cleared, the client was gone! This should not happen."");; 2715 }; 2716 iClient = std::distance(clients.begin(), clientIter);; 2717 }; 2718 }; 2719}; 2720 ; 2721} // namespace; 2722 ; 2723 ; 2724////////////////////////////////////////////////////////////////////////////////; 2725 ; 2726void RooAbsPdf::setNormRange(const char* rangeName); 2727{; 2728 if (rangeName) {; 2729 _normRange = rangeName ;; 2730 } else {; 2731 _normRange.Clear() ;; 2732 }; 2733 ; 2734 // the stuff that the clients have cached may depend on the normaliz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:128587,cache,cacheMgr,128587,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,3,['cache'],"['cacheMgr', 'cached']"
Performance,"///////////////////////////////////////////////////////////; 5853///Returns the entry list assigned to this tree; 5854 ; 5855TEntryList* TTree::GetEntryList(); 5856{; 5857 return fEntryList;; 5858}; 5859 ; 5860////////////////////////////////////////////////////////////////////////////////; 5861/// Return entry number corresponding to entry.; 5862///; 5863/// if no TEntryList set returns entry; 5864/// else returns the entry number corresponding to the list index=entry; 5865 ; 5866Long64_t TTree::GetEntryNumber(Long64_t entry) const; 5867{; 5868 if (!fEntryList) {; 5869 return entry;; 5870 }; 5871 ; 5872 return fEntryList->GetEntry(entry);; 5873}; 5874 ; 5875////////////////////////////////////////////////////////////////////////////////; 5876/// Return entry number corresponding to major and minor number.; 5877/// Note that this function returns only the entry number, not the data; 5878/// To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; 5879/// the BuildIndex function has created a table of Long64_t* of sorted values; 5880/// corresponding to val = major<<31 + minor;; 5881/// The function performs binary search in this sorted table.; 5882/// If it finds a pair that matches val, it returns directly the; 5883/// index in the table.; 5884/// If an entry corresponding to major and minor is not found, the function; 5885/// returns the index of the major,minor pair immediately lower than the; 5886/// requested value, ie it will return -1 if the pair is lower than; 5887/// the first entry in the index.; 5888///; 5889/// See also GetEntryNumberWithIndex; 5890 ; 5891Long64_t TTree::GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; 5892{; 5893 if (!fTreeIndex) {; 5894 return -1;; 5895 }; 5896 return fTreeIndex->GetEntryNumberWithBestIndex(major, minor);; 5897}; 5898 ; 5899////////////////////////////////////////////////////////////////////////////////; 5900/// Return entry number corresponding to major and minor number.; 5901/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:231945,perform,performs,231945,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['perform'],['performs']
Performance,"///////////////////////////////////////////////////////////; 6304/// Load the TTreePlayer (if not already done).; 6305 ; 6306TVirtualTreePlayer* TTree::GetPlayer(); 6307{; 6308 if (fPlayer) {; 6309 return fPlayer;; 6310 }; 6311 fPlayer = TVirtualTreePlayer::TreePlayer(this);; 6312 return fPlayer;; 6313}; 6314 ; 6315////////////////////////////////////////////////////////////////////////////////; 6316/// Find and return the TTreeCache registered with the file and which may; 6317/// contain branches for us.; 6318 ; 6319TTreeCache *TTree::GetReadCache(TFile *file) const; 6320{; 6321 TTreeCache *pe = dynamic_cast<TTreeCache*>(file->GetCacheRead(GetTree()));; 6322 if (pe && pe->GetTree() != GetTree()); 6323 pe = nullptr;; 6324 return pe;; 6325}; 6326 ; 6327////////////////////////////////////////////////////////////////////////////////; 6328/// Find and return the TTreeCache registered with the file and which may; 6329/// contain branches for us. If create is true and there is no cache; 6330/// a new cache is created with default size.; 6331 ; 6332TTreeCache *TTree::GetReadCache(TFile *file, bool create); 6333{; 6334 TTreeCache *pe = GetReadCache(file);; 6335 if (create && !pe) {; 6336 if (fCacheDoAutoInit); 6337 SetCacheSizeAux(true, -1);; 6338 pe = dynamic_cast<TTreeCache*>(file->GetCacheRead(GetTree()));; 6339 if (pe && pe->GetTree() != GetTree()) pe = nullptr;; 6340 }; 6341 return pe;; 6342}; 6343 ; 6344////////////////////////////////////////////////////////////////////////////////; 6345/// Return a pointer to the list containing user objects associated to this tree.; 6346///; 6347/// The list is automatically created if it does not exist.; 6348///; 6349/// WARNING: By default the TTree destructor will delete all objects added; 6350/// to this list. If you do not want these objects to be deleted,; 6351/// call:; 6352///; 6353/// mytree->GetUserInfo()->Clear();; 6354///; 6355/// before deleting the tree.; 6356 ; 6357TList* TTree::GetUserInfo(); 6358{; 6359 if (!fUserI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:247656,cache,cache,247656,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,2,['cache'],['cache']
Performance,"//////////////////////////////////////////////////////////; 387/// Allow geting the tree from the context menu.; 388 ; 389void TTreeViewer::AppendTree(TTree *tree); 390{; 391 if (!tree) return;; 392 TTree *ftree;; 393 if (fTreeList) {; 394 if (fTreeList->FindObject(tree)) {; 395 printf(""Tree found\n"");; 396 TIter next(fTreeList);; 397 Int_t index = 0;; 398 while ((ftree = (TTree*)next())) {; 399 if (ftree==tree) {printf(""found at index %i\n"", index);break;}; 400 index++;; 401 }; 402 SwitchTree(index);; 403 if (fTree != fMappedTree) {; 404 // switch also the global ""tree"" variable; 405 fLVContainer->RemoveNonStatic();; 406 // map it on the right panel; 407 MapTree(fTree);; 408 fListView->Layout();; 409 TGListTreeItem *base = nullptr;; 410 TGListTreeItem *parent = fLt->FindChildByName(base, ""TreeList"");; 411 TGListTreeItem *item = fLt->FindChildByName(parent, fTree->GetName());; 412 fLt->ClearHighlighted();; 413 fLt->HighlightItem(item);; 414 fClient->NeedRedraw(fLt);; 415 }; 416 return;; 417 }; 418 }; 419 if (fTree != tree) {; 420 fTree = tree;; 421 // load the tree via the interpreter; 422 char command[100];; 423 command[0] = 0;; 424 // define a global ""tree"" variable for the same tree; 425 snprintf(command,100, ""tv__tree = (TTree *)0x%zx;"", (size_t)tree);; 426 ExecuteCommand(command);; 427 }; 428 //--- add the tree to the list if it is not already in; 429 if (fTreeList) fTreeList->Add(fTree);; 430 ExecuteCommand(""tv__tree_list->Add(tv__tree);"");; 431 //--- map this tree; 432 TGListTreeItem *base = nullptr;; 433 TGListTreeItem *parent = fLt->FindChildByName(base, ""TreeList"");; 434 if (!parent) parent = fLt->AddItem(base, ""TreeList"", new ULong_t(kLTNoType));; 435 ULong_t *itemType = new ULong_t((fTreeIndex << 8) | kLTTreeType);; 436 fTreeIndex++;; 437 TGListTreeItem *lTreeItem = fLt->AddItem(parent, tree->GetName(), itemType,; 438 gClient->GetPicture(""tree_t.xpm""), gClient->GetPicture(""tree_t.xpm""));; 439 MapTree(fTree, lTreeItem, false);; 440 fLt->OpenItem(parent);; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeViewer_8cxx_source.html:15360,load,load,15360,doc/master/TTreeViewer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html,1,['load'],['load']
Performance,"/////////////////////////////////////////////////////////; 302/// Insert object at position idx in the list.; 303 ; 304void TList::AddAt(TObject *obj, Int_t idx); 305{; 306 R__COLLECTION_WRITE_GUARD();; 307 ; 308 if (IsArgNull(""AddAt"", obj)) return;; 309 ; 310 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 311 ; 312 TObjLink *lnk = LinkAt(idx);; 313 if (!lnk); 314 TList::AddLast(obj);; 315 else if (lnk == fFirst.get()); 316 TList::AddFirst(obj);; 317 else {; 318 NewLink(obj, lnk->fPrev.lock());; 319 fSize++;; 320 Changed();; 321 }; 322}; 323 ; 324////////////////////////////////////////////////////////////////////////////////; 325/// Returns the object after object obj. Obj is found using the; 326/// object's IsEqual() method. Returns 0 if obj is last in list.; 327 ; 328TObject *TList::After(const TObject *obj) const; 329{; 330 R__COLLECTION_WRITE_GUARD();; 331 ; 332 TObjLink *t;; 333 ; 334 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 335 ; 336 auto cached = fCache.lock();; 337 if (cached.get() && cached->GetObject() && cached->GetObject()->IsEqual(obj)) {; 338 t = cached.get();; 339 ((TList*)this)->fCache = cached->fNext; //cast const away, fCache should be mutable; 340 } else {; 341 Int_t idx;; 342 t = FindLink(obj, idx);; 343 if (t) ((TList*)this)->fCache = t->fNext;; 344 }; 345 ; 346 if (t && t->Next()); 347 return t->Next()->GetObject();; 348 else; 349 return nullptr;; 350}; 351 ; 352////////////////////////////////////////////////////////////////////////////////; 353/// Returns the object at position idx. Returns 0 if idx is out of range.; 354 ; 355TObject *TList::At(Int_t idx) const; 356{; 357 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 358 R__COLLECTION_WRITE_GUARD();; 359 ; 360 TObjLink *lnk = LinkAt(idx);; 361 if (lnk) return lnk->GetObject();; 362 return nullptr;; 363}; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// Returns the object before object obj. Obj is found using the; 367/// object'",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TList_8cxx_source.html:9709,cache,cached,9709,doc/master/TList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html,1,['cache'],['cached']
Performance,"/////////////////////////////////////////////////////////; 4590/// Static function returning the total number of read calls from all files.; 4591 ; 4592Int_t TFile::GetFileReadCalls(); 4593{; 4594 return fgReadCalls;; 4595}; 4596 ; 4597////////////////////////////////////////////////////////////////////////////////; 4598/// Static function returning the readahead buffer size.; 4599 ; 4600Int_t TFile::GetReadaheadSize(); 4601{; 4602 return fgReadaheadSize;; 4603}; 4604 ; 4605//______________________________________________________________________________; 4606void TFile::SetReadaheadSize(Int_t bytes) { fgReadaheadSize = bytes; }; 4607 ; 4608//______________________________________________________________________________; 4609void TFile::SetFileBytesRead(Long64_t bytes) { fgBytesRead = bytes; }; 4610 ; 4611//______________________________________________________________________________; 4612void TFile::SetFileBytesWritten(Long64_t bytes) { fgBytesWrite = bytes; }; 4613 ; 4614//______________________________________________________________________________; 4615void TFile::SetFileReadCalls(Int_t readcalls) { fgReadCalls = readcalls; }; 4616 ; 4617//______________________________________________________________________________; 4618Long64_t TFile::GetFileCounter() { return fgFileCounter; }; 4619 ; 4620//______________________________________________________________________________; 4621void TFile::IncrementFileCounter() { fgFileCounter++; }; 4622 ; 4623////////////////////////////////////////////////////////////////////////////////; 4624/// Sets the directory where to locally stage/cache remote files.; 4625/// If the directory is not writable by us return kFALSE.; 4626 ; 4627Bool_t TFile::SetCacheFileDir(std::string_view cachedir, Bool_t operatedisconnected,; 4628 Bool_t forcecacheread ); 4629{; 4630 TString cached{cachedir};; 4631 if (!cached.EndsWith(""/"")); 4632 cached += ""/"";; 4633 ; 4634 if (gSystem->AccessPathName(cached, kFileExists)) {; 4635 // try to create it; 46",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:169057,cache,cache,169057,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////; 199/// Set size of axis labels.; 200/// The size is expressed in per cent of the pad size, unless the font precision; 201/// is 3 and in that case the size is expressed in pixels.; 202 ; 203void TAttAxis::SetLabelSize(Float_t size); 204{; 205 fLabelSize = size;; 206 if (gPad) gPad->Modified();; 207}; 208 ; 209////////////////////////////////////////////////////////////////////////////////; 210/// Set the number of divisions for this axis.; 211///; 212/// - if optim = kTRUE (default), the number of divisions will be; 213/// optimized around the specified value.; 214/// - if optim = kFALSE, or n < 0, the axis will be forced to use; 215/// exactly n divisions.; 216///~~~ {.cpp}; 217/// n = n1 + 100*n2 + 10000*n3; 218///~~~; 219/// Where n1 is the number of primary divisions,; 220/// n2 is the number of second order divisions and; 221/// n3 is the number of third order divisions.; 222///; 223/// If the number of divisions is ""optimized"" (see above) n1, n2, n3 are; 224/// maximum values.; 225///; 226/// Examples:; 227///; 228/// - ndiv = 0: no tick marks.; 229/// - ndiv = 2: 2 divisions, one tick mark in the middle of the axis.; 230/// - ndiv = 510: 10 primary divisions, 5 secondary divisions.; 231/// - ndiv = -10: exactly 10 primary divisions.; 232 ; 233void TAttAxis::SetNdivisions(Int_t n, Bool_t optim); 234{; 235 Int_t ndiv = (n%1000000);; 236 Bool_t isOptimized = optim && (ndiv>0);; 237 Int_t current_maxDigits = abs(fNdivisions)/1000000;; 238 fNdivisions = abs(ndiv) + current_maxDigits*1000000;; 239 if (!isOptimized) fNdivisions = -fNdivisions;; 240 ; 241 if (gPad) gPad->Modified();; 242}; 243 ; 244////////////////////////////////////////////////////////////////////////////////; 245/// Set the number of divisions for this axis using one `int` per division level.; 246 ; 247void TAttAxis::SetNdivisions(Int_t n1, Int_t n2, Int_t n3, Bool_t optim); 248{; 249 SetNdivisions(n1+100*n2+10000*n3, optim);; 250}; 251 ; 25",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TAttAxis_8cxx_source.html:7851,optimiz,optimized,7851,doc/master/TAttAxis_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TAttAxis_8cxx_source.html,1,['optimiz'],['optimized']
Performance,"////////////////////////////////////////////////////////; 856/// See TTree::GetReadEntry().; 857 ; 858TBranch* TChain::FindBranch(const char* branchname); 859{; 860 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 861 // Make sure the element list is up to date; 862 if (!TestBit(kProofUptodate)); 863 SetProof(true, true);; 864 return fProofChain->FindBranch(branchname);; 865 }; 866 if (fTree) {; 867 return fTree->FindBranch(branchname);; 868 }; 869 LoadTree(0);; 870 if (fTree) {; 871 return fTree->FindBranch(branchname);; 872 }; 873 return nullptr;; 874}; 875 ; 876////////////////////////////////////////////////////////////////////////////////; 877/// See TTree::GetReadEntry().; 878 ; 879TLeaf* TChain::FindLeaf(const char* searchname); 880{; 881 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 882 // Make sure the element list is up to date; 883 if (!TestBit(kProofUptodate)); 884 SetProof(true, true);; 885 return fProofChain->FindLeaf(searchname);; 886 }; 887 if (fTree) {; 888 return fTree->FindLeaf(searchname);; 889 }; 890 LoadTree(0);; 891 if (fTree) {; 892 return fTree->FindLeaf(searchname);; 893 }; 894 return nullptr;; 895}; 896 ; 897////////////////////////////////////////////////////////////////////////////////; 898/// Returns the expanded value of the alias. Search in the friends if any.; 899 ; 900const char* TChain::GetAlias(const char* aliasName) const; 901{; 902 const char* alias = TTree::GetAlias(aliasName);; 903 if (alias) {; 904 return alias;; 905 }; 906 if (fTree) {; 907 return fTree->GetAlias(aliasName);; 908 }; 909 const_cast<TChain*>(this)->LoadTree(0);; 910 if (fTree) {; 911 return fTree->GetAlias(aliasName);; 912 }; 913 return nullptr;; 914}; 915 ; 916////////////////////////////////////////////////////////////////////////////////; 917/// Return pointer to the branch name in the current tree.; 918 ; 919TBranch* TChain::GetBranch(const char* name); 920{; 921 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 922 // Make s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:33918,Load,LoadTree,33918,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['Load'],['LoadTree']
Performance,"///////////////////////////////////////////////////////; 1959/// Get the regression output values for a single event; 1960//////////////////////////////////////////////////////////////////////////; 1961const std::vector<Float_t> & TMVA::MethodDL::GetRegressionValues(); 1962{; 1963 ; 1964 FillInputTensor ();; 1965 ; 1966 // perform the network prediction; 1967 fNet->Prediction(*fYHat, fXInput, fOutputFunction);; 1968 ; 1969 size_t nTargets = DataInfo().GetNTargets();; 1970 R__ASSERT(nTargets == fYHat->GetNcols());; 1971 ; 1972 std::vector<Float_t> output(nTargets);; 1973 for (size_t i = 0; i < nTargets; i++); 1974 output[i] = (*fYHat)(0, i);; 1975 ; 1976 // ned to transform back output values; 1977 if (fRegressionReturnVal == NULL); 1978 fRegressionReturnVal = new std::vector<Float_t>(nTargets);; 1979 R__ASSERT(fRegressionReturnVal->size() == nTargets);; 1980 ; 1981 // N.B. one should cache here temporary event class; 1982 Event *evT = new Event(*GetEvent());; 1983 for (size_t i = 0; i < nTargets; ++i) {; 1984 evT->SetTarget(i, output[i]);; 1985 }; 1986 const Event *evT2 = GetTransformationHandler().InverseTransform(evT);; 1987 for (size_t i = 0; i < nTargets; ++i) {; 1988 (*fRegressionReturnVal)[i] = evT2->GetTarget(i);; 1989 }; 1990 delete evT;; 1991 return *fRegressionReturnVal;; 1992}; 1993//////////////////////////////////////////////////////////////////////////; 1994/// Get the multi-class output values for a single event; 1995//////////////////////////////////////////////////////////////////////////; 1996const std::vector<Float_t> &TMVA::MethodDL::GetMulticlassValues(); 1997{; 1998 ; 1999 FillInputTensor();; 2000 ; 2001 fNet->Prediction(*fYHat, fXInput, fOutputFunction);; 2002 ; 2003 size_t nClasses = DataInfo().GetNClasses();; 2004 R__ASSERT(nClasses == fYHat->GetNcols());; 2005 ; 2006 if (fMulticlassReturnVal == NULL) {; 2007 fMulticlassReturnVal = new std::vector<Float_t>(nClasses);; 2008 }; 2009 R__ASSERT(fMulticlassReturnVal->size() == nClasses);; 2010 ; 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:78736,cache,cache,78736,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['cache'],['cache']
Performance,"///////////////////////////////////////////////////////; 6262/// Load library containing the specified class. Returns 0 in case of error; 6263/// and 1 in case if success.; 6264 ; 6265Int_t TCling::AutoLoad(const char *cls, Bool_t knowDictNotLoaded /* = kFALSE */); 6266{; 6267 // Prevent update to IsClassAutoloading between our check and our actions.; 6268 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 6269 ; 6270 // TClass::GetClass explicitly calls gInterpreter->AutoLoad. When called from; 6271 // rootcling (in *_rdict.pcm file generation) it is a no op.; 6272 // FIXME: We should avoid calling autoload when we know we are not supposed; 6273 // to and transform this check into an assert.; 6274 if (!IsClassAutoLoadingEnabled()) {; 6275 // Never load any library from rootcling/genreflex.; 6276 if (gDebug > 2) {; 6277 Info(""TCling::AutoLoad"", ""Explicitly disabled (the class name is %s)"", cls);; 6278 }; 6279 return 0;; 6280 }; 6281 ; 6282 assert(IsClassAutoLoadingEnabled() && ""Calling when AutoLoading is off!"");; 6283 ; 6284 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 6285 ; 6286 if (!knowDictNotLoaded && gClassTable->GetDictNorm(cls)) {; 6287 // The library is already loaded as the class's dictionary is known.; 6288 // Return success.; 6289 // Note: the name (cls) is expected to be normalized as it comes either; 6290 // from a callbacks (that can/should calculate the normalized name from the; 6291 // decl) or from TClass::GetClass (which does also calculate the normalized; 6292 // name).; 6293 return 1;; 6294 }; 6295 ; 6296 if (gDebug > 2) {; 6297 Info(""TCling::AutoLoad"",; 6298 ""Trying to autoload for %s"", cls);; 6299 }; 6300 ; 6301 if (!gROOT || !gInterpreter || gROOT->TestBit(TObject::kInvalidObject)) {; 6302 if (gDebug > 2) {; 6303 Info(""TCling::AutoLoad"",; 6304 ""Disabled due to gROOT or gInterpreter being invalid/not ready (the class name is %s)"", cls);; 6305 }; 6306 return 0;; 6307 }; 6308 // Prevent the recursion when the library dictionary are loaded.; 6309 SuspendAutoLoading",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:244109,load,loaded,244109,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loaded']
Performance,"///////////////////////////////////////////////////////; 7095/// Return a Conversion StreamerInfo from the class represented by cl for version number 'version' to this class, if any.; 7096 ; 7097TVirtualStreamerInfo *TClass::GetConversionStreamerInfo( const TClass* cl, Int_t version ) const; 7098{; 7099 //----------------------------------------------------------------------------; 7100 // Check if the classname was specified correctly; 7101 /////////////////////////////////////////////////////////////////////////////; 7102 ; 7103 if( !cl ); 7104 return nullptr;; 7105 ; 7106 if( cl == this ); 7107 return GetStreamerInfo( version );; 7108 ; 7109 //----------------------------------------------------------------------------; 7110 // Check if we already have it; 7111 /////////////////////////////////////////////////////////////////////////////; 7112 ; 7113 TObjArray* arr = nullptr;; 7114 if (fConversionStreamerInfo.load()) {; 7115 std::map<std::string, TObjArray*>::iterator it;; 7116 R__LOCKGUARD(gInterpreterMutex);; 7117 ; 7118 it = (*fConversionStreamerInfo).find( cl->GetName() );; 7119 ; 7120 if( it != (*fConversionStreamerInfo).end() ) {; 7121 arr = it->second;; 7122 }; 7123 ; 7124 if( arr && version >= -1 && version < arr->GetSize() && arr->At( version ) ); 7125 return (TVirtualStreamerInfo*) arr->At( version );; 7126 }; 7127 ; 7128 R__LOCKGUARD(gInterpreterMutex);; 7129 ; 7130 //----------------------------------------------------------------------------; 7131 // We don't have the streamer info so find it in other class; 7132 /////////////////////////////////////////////////////////////////////////////; 7133 ; 7134 const TObjArray *clSI = cl->GetStreamerInfos();; 7135 TVirtualStreamerInfo* info = nullptr;; 7136 if( version >= -1 && version < clSI->GetSize() ); 7137 info = (TVirtualStreamerInfo*)clSI->At( version );; 7138 ; 7139 if (!info && cl->GetCollectionProxy()) {; 7140 info = cl->GetStreamerInfo(); // instantiate the StreamerInfo for STL collections.; 7141 }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:272952,load,load,272952,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"///////////////////////////////////////////////////////; 7162/// Return a Conversion StreamerInfo from the class represented by cl for version number 'version' to this class, if any.; 7163 ; 7164TVirtualStreamerInfo *TClass::GetConversionStreamerInfo( const TClass* cl, Int_t version ) const; 7165{; 7166 //----------------------------------------------------------------------------; 7167 // Check if the classname was specified correctly; 7168 /////////////////////////////////////////////////////////////////////////////; 7169 ; 7170 if( !cl ); 7171 return nullptr;; 7172 ; 7173 if( cl == this ); 7174 return GetStreamerInfo( version );; 7175 ; 7176 //----------------------------------------------------------------------------; 7177 // Check if we already have it; 7178 /////////////////////////////////////////////////////////////////////////////; 7179 ; 7180 TObjArray* arr = nullptr;; 7181 if (fConversionStreamerInfo.load()) {; 7182 std::map<std::string, TObjArray*>::iterator it;; 7183 R__LOCKGUARD(gInterpreterMutex);; 7184 ; 7185 it = (*fConversionStreamerInfo).find( cl->GetName() );; 7186 ; 7187 if( it != (*fConversionStreamerInfo).end() ) {; 7188 arr = it->second;; 7189 }; 7190 ; 7191 if( arr && version >= -1 && version < arr->GetSize() && arr->At( version ) ); 7192 return (TVirtualStreamerInfo*) arr->At( version );; 7193 }; 7194 ; 7195 R__LOCKGUARD(gInterpreterMutex);; 7196 ; 7197 //----------------------------------------------------------------------------; 7198 // We don't have the streamer info so find it in other class; 7199 /////////////////////////////////////////////////////////////////////////////; 7200 ; 7201 const TObjArray *clSI = cl->GetStreamerInfos();; 7202 TVirtualStreamerInfo* info = nullptr;; 7203 if( version >= -1 && version < clSI->GetSize() ); 7204 info = (TVirtualStreamerInfo*)clSI->At( version );; 7205 ; 7206 if (!info && cl->GetCollectionProxy()) {; 7207 info = cl->GetStreamerInfo(); // instantiate the StreamerInfo for STL collections.; 7208 }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:275703,load,load,275703,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"/////////////////////////////////////////////////////; 102/// Returns the cached file size; 103int VfsRdOnlyFileSize(sqlite3_file *pFile, sqlite_int64 *pSize); 104{; 105 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 106 *pSize = p->fRawFile->GetSize();; 107 return SQLITE_OK;; 108}; 109 ; 110////////////////////////////////////////////////////////////////////////////; 111/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 112int VfsRdOnlyLock(sqlite3_file * /*pFile*/, int /*level*/); 113{; 114 return SQLITE_OK;; 115}; 116 ; 117////////////////////////////////////////////////////////////////////////////; 118/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 119int VfsRdOnlyUnlock(sqlite3_file * /*pFile*/, int /*level*/); 120{; 121 return SQLITE_OK;; 122}; 123 ; 124////////////////////////////////////////////////////////////////////////////; 125/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 126int VfsRdOnlyCheckReservedLock(sqlite3_file * /*pFile*/, int *pResOut); 127{; 128 *pResOut = 0;; 129 return SQLITE_OK;; 130}; 131 ; 132////////////////////////////////////////////////////////////////////////////; 133/// As the database is read-only, we know there are no additional control files such as a database journal; 134int VfsRdOnlyFileControl(sqlite3_file * /*p*/, int /*op*/, void * /*pArg*/); 135{; 136 return SQLITE_NOTFOUND;; 137}; 138 ; 139////////////////////////////////////////////////////////////////////////////; 140/// The database device's sector size is only needed for writing; 141int VfsRdOnlySectorSize(sqlite3_file * /*pFile*/); 142{; 143 return SQLITE_OPEN_READONLY;; 144}; 145 ; 146////////////////////////////////////////////////////////////////////////////; 147/// The database device's properties are only needed for writing; 148int VfsRdOnlyDeviceCharacteristics(sqlite3_file * /*pFile*/); 149{; 150 return SQLITE_OPEN_RE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RSqliteDS_8cxx_source.html:5759,concurren,concurrent,5759,doc/master/RSqliteDS_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html,1,['concurren'],['concurrent']
Performance,"////////////////////////////////////////////////////; 225/// static: Return the Error Definition; 226 ; 227Double_t TVirtualFitter::GetErrorDef(); 228{; 229// return fgErrorDef;; 230 return ROOT::Math::MinimizerOptions::DefaultErrorDef();; 231}; 232 ; 233////////////////////////////////////////////////////////////////////////////////; 234/// static: Return the fit relative precision; 235 ; 236Double_t TVirtualFitter::GetPrecision(); 237{; 238 //return fgPrecision;; 239 return ROOT::Math::MinimizerOptions::DefaultTolerance();; 240}; 241 ; 242////////////////////////////////////////////////////////////////////////////////; 243/// static: set name of default fitter; 244 ; 245void TVirtualFitter::SetDefaultFitter(const char *name); 246{; 247 ROOT::Math::MinimizerOptions::SetDefaultMinimizer(name,"""");; 248 if (GetGlobalDefault() == name) return;; 249 delete GetGlobalFitter();; 250 GetGlobalFitter() = nullptr;; 251 GetGlobalDefault() = name;; 252}; 253 ; 254////////////////////////////////////////////////////////////////////////////////; 255/// Static function to set an alternative fitter; 256 ; 257void TVirtualFitter::SetFitter(TVirtualFitter *fitter, Int_t maxpar); 258{; 259 GetGlobalFitter() = fitter;; 260 GetGlobalMaxPar() = maxpar;; 261}; 262 ; 263////////////////////////////////////////////////////////////////////////////////; 264/// To set the address of the minimization objective function; 265/// called by the native compiler (see function below when called by CINT); 266 ; 267void TVirtualFitter::SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); 268{; 269 fFCN = fcn;; 270}; 271 ; 272////////////////////////////////////////////////////////////////////////////////; 273/// Initialize the cache array; 274/// npoints is the number of points to be stored (or already stored) in the cache; 275/// psize is the number of elements per point; 276///; 277/// if (npoints*psize > fCacheSize) the existing cache is deleted; 278/// and a new array is created.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html:8537,cache,cache,8537,doc/master/TVirtualFitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html,3,['cache'],['cache']
Performance,"///////////////////////////////////////////////////; 249/// A module and its headers. Intentionally not a copy:; 250/// If these strings end up in this struct they are; 251/// long lived by definition because they get passed in; 252/// before initialization of TCling.; 253 ; 254namespace {; 255 struct ModuleHeaderInfo_t {; 256 ModuleHeaderInfo_t(const char* moduleName,; 257 const char** headers,; 258 const char** includePaths,; 259 const char* payloadCode,; 260 const char* fwdDeclCode,; 261 void (*triggerFunc)(),; 262 const TROOT::FwdDeclArgsToKeepCollection_t& fwdDeclsArgToSkip,; 263 const char **classesHeaders,; 264 bool hasCxxModule):; 265 fModuleName(moduleName),; 266 fHeaders(headers),; 267 fPayloadCode(payloadCode),; 268 fFwdDeclCode(fwdDeclCode),; 269 fIncludePaths(includePaths),; 270 fTriggerFunc(triggerFunc),; 271 fClassesHeaders(classesHeaders),; 272 fFwdNargsToKeepColl(fwdDeclsArgToSkip),; 273 fHasCxxModule(hasCxxModule) {}; 274 ; 275 const char* fModuleName; // module name; 276 const char** fHeaders; // 0-terminated array of header files; 277 const char* fPayloadCode; // Additional code to be given to cling at library load; 278 const char* fFwdDeclCode; // Additional code to let cling know about selected classes and functions; 279 const char** fIncludePaths; // 0-terminated array of header files; 280 void (*fTriggerFunc)(); // Pointer to the dict initialization used to find the library name; 281 const char** fClassesHeaders; // 0-terminated list of classes and related header files; 282 const TROOT::FwdDeclArgsToKeepCollection_t fFwdNargsToKeepColl; // Collection of; 283 // pairs of template fwd decls and number of; 284 bool fHasCxxModule; // Whether this module has a C++ module alongside it.; 285 };; 286 ; 287 std::vector<ModuleHeaderInfo_t>& GetModuleHeaderInfoBuffer() {; 288 static std::vector<ModuleHeaderInfo_t> moduleHeaderInfoBuffer;; 289 return moduleHeaderInfoBuffer;; 290 }; 291}; 292 ; 293Int_t TROOT::fgDirLevel = 0;; 294Bool_t TROOT::fgRootInit ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:8934,load,load,8934,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['load']
Performance,"///////////////////////////////////////////////////; 366/// Lock the interpreter.; 367 ; 368extern ""C"" void *TCling__LockCompilationDuringUserCodeExecution(); 369{; 370 if (gInterpreterMutex) {; 371 gInterpreterMutex->Lock();; 372 }; 373 return nullptr;; 374}; 375 ; 376////////////////////////////////////////////////////////////////////////////////; 377/// Unlock the interpreter.; 378 ; 379extern ""C"" void TCling__UnlockCompilationDuringUserCodeExecution(void* /*state*/); 380{; 381 if (gInterpreterMutex) {; 382 gInterpreterMutex->UnLock();; 383 }; 384}; 385 ; 386////////////////////////////////////////////////////////////////////////////////; 387/// Update TClingClassInfo for a class (e.g. upon seeing a definition).; 388 ; 389static void TCling__UpdateClassInfo(const NamedDecl* TD); 390{; 391 static Bool_t entered = kFALSE;; 392 static vector<const NamedDecl*> updateList;; 393 Bool_t topLevel;; 394 ; 395 if (entered) topLevel = kFALSE;; 396 else {; 397 entered = kTRUE;; 398 topLevel = kTRUE;; 399 }; 400 if (topLevel) {; 401 ((TCling*)gInterpreter)->UpdateClassInfoWithDecl(TD);; 402 } else {; 403 // If we are called indirectly from within another call to; 404 // TCling::UpdateClassInfo, we delay the update until the dictionary loading; 405 // is finished (i.e. when we return to the top level TCling::UpdateClassInfo).; 406 // This allows for the dictionary to be fully populated when we actually; 407 // update the TClass object. The updating of the TClass sometimes; 408 // (STL containers and when there is an emulated class) forces the building; 409 // of the TClass object's real data (which needs the dictionary info).; 410 updateList.push_back(TD);; 411 }; 412 if (topLevel) {; 413 while (!updateList.empty()) {; 414 ((TCling*)gInterpreter)->UpdateClassInfoWithDecl(updateList.back());; 415 updateList.pop_back();; 416 }; 417 entered = kFALSE;; 418 }; 419}; 420 ; 421void TCling::UpdateEnumConstants(TEnum* enumObj, TClass* cl) const {; 422 const clang::Decl* D = static_cast",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:14174,load,loading,14174,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loading']
Performance,"///////////////////////////////////////////////////; 538/// Specify the path for this node.; 539 ; 540Bool_t TGeoPhysicalNode::SetPath(const char *path); 541{; 542 if (!gGeoManager->cd(path)) {; 543 Error(""SetPath"", ""wrong path -> maybe RestoreMasterVolume"");; 544 return kFALSE;; 545 }; 546 SetBranchAsState();; 547 return kTRUE;; 548}; 549 ; 550////////////////////////////////////////////////////////////////////////////////; 551/// Checks if a given navigator state matches this physical node; 552 ; 553Bool_t TGeoPhysicalNode::IsMatchingState(TGeoNavigator *nav) const; 554{; 555 TGeoNodeCache *cache = nav->GetCache();; 556 if (!cache) {; 557 Fatal(""SetBranchAsState"", ""no state available"");; 558 return kFALSE;; 559 }; 560 // the first condition is that the levels of navigator and this physical node must match; 561 if (cache->GetLevel() != fLevel) {; 562 return kFALSE;; 563 }; 564 // now we compare the nodes at each level; 565 // starting backwards since that enhances the probability of an early return; 566 TGeoNode **branch = (TGeoNode **)cache->GetBranch();; 567 for (Int_t i = fLevel; i >= 1; --i); 568 if (fNodes->At(i) != branch[i]); 569 return kFALSE;; 570 return kTRUE;; 571}; 572 ; 573ClassImp(TGeoPNEntry);; 574 ; 575////////////////////////////////////////////////////////////////////////////////; 576/// Default constructor; 577 ; 578TGeoPNEntry::TGeoPNEntry(); 579{; 580 fNode = nullptr;; 581 fMatrix = nullptr;; 582 fGlobalOrig = nullptr;; 583}; 584 ; 585////////////////////////////////////////////////////////////////////////////////; 586/// Default constructor; 587 ; 588TGeoPNEntry::TGeoPNEntry(const char *name, const char *path) : TNamed(name, path); 589{; 590 if (!gGeoManager || !gGeoManager->IsClosed() || !gGeoManager->CheckPath(path)) {; 591 TString errmsg(""Cannot define a physical node link without a closed geometry and a valid path !"");; 592 Error(""ctor"", ""%s"", errmsg.Data());; 593 throw errmsg;; 594 return;; 595 }; 596 gGeoManager->PushPath();; 597 gGeoMana",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:18688,cache,cache,18688,doc/master/TGeoPhysicalNode_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html,4,['cache'],['cache']
Performance,"///////////////////////////////////////////////////; 634/// Count total number of visible nodes.; 635 ; 636Int_t TGeoPainter::CountVisibleNodes(); 637{; 638 Int_t maxnodes = fGeoManager->GetMaxVisNodes();; 639 Int_t vislevel = fGeoManager->GetVisLevel();; 640 // TGeoVolume *top = fGeoManager->GetTopVolume();; 641 TGeoVolume *top = fTopVolume;; 642 if (maxnodes <= 0 && top) {; 643 fNVisNodes = CountNodes(top, vislevel);; 644 SetVisLevel(vislevel);; 645 return fNVisNodes;; 646 }; 647 // if (the total number of nodes of the top volume is less than maxnodes; 648 // we can visualize everything.; 649 // recompute the best visibility level; 650 if (!top) {; 651 SetVisLevel(vislevel);; 652 return 0;; 653 }; 654 fNVisNodes = -1;; 655 Bool_t again = kFALSE;; 656 for (Int_t level = 1; level < 20; level++) {; 657 vislevel = level;; 658 Int_t nnodes = CountNodes(top, level);; 659 if (top->IsVisOnly() || top->IsVisBranch()) {; 660 vislevel = fVisLevel;; 661 fNVisNodes = nnodes;; 662 break;; 663 }; 664 if (nnodes > maxnodes) {; 665 vislevel--;; 666 break;; 667 }; 668 if (nnodes == fNVisNodes) {; 669 if (again); 670 break;; 671 again = kTRUE;; 672 }; 673 fNVisNodes = nnodes;; 674 }; 675 SetVisLevel(vislevel);; 676 return fNVisNodes;; 677}; 678 ; 679////////////////////////////////////////////////////////////////////////////////; 680/// Check if Ged library is loaded and load geometry editor classe.; 681 ; 682void TGeoPainter::CheckEdit(); 683{; 684 if (fIsEditable); 685 return;; 686 if (!TClass::GetClass(""TGedEditor"")); 687 return;; 688 TPluginHandler *h;; 689 if ((h = gROOT->GetPluginManager()->FindHandler(""TGeoManagerEditor""))) {; 690 if (h->LoadPlugin() == -1); 691 return;; 692 h->ExecPlugin(0);; 693 }; 694 fIsEditable = kTRUE;; 695}; 696 ; 697////////////////////////////////////////////////////////////////////////////////; 698/// Start the geometry editor.; 699 ; 700void TGeoPainter::EditGeometry(Option_t *option); 701{; 702 if (!gPad); 703 return;; 704 if (!fIsEditable) {; 705 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8cxx_source.html:22197,load,loaded,22197,doc/master/TGeoPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html,2,['load'],"['load', 'loaded']"
Performance,"//////////////////////////////////////////////////; 3945/// Check moduleName validity from modulemap. Check if this module is defined or not.; 3946static bool CheckModuleValid(TModuleGenerator &modGen, const std::string &resourceDir, cling::Interpreter &interpreter,; 3947 llvm::StringRef LinkdefPath, const std::string &moduleName); 3948{; 3949 clang::CompilerInstance *CI = interpreter.getCI();; 3950 clang::HeaderSearch &headerSearch = CI->getPreprocessor().getHeaderSearchInfo();; 3951 headerSearch.loadTopLevelSystemModules();; 3952 ; 3953 // Actually lookup the module on the computed module name.; 3954 clang::Module *module = headerSearch.lookupModule(llvm::StringRef(moduleName));; 3955 ; 3956 // Inform the user and abort if we can't find a module with a given name.; 3957 if (!module) {; 3958 ROOT::TMetaUtils::Error(""CheckModuleValid"", ""Couldn't find module with name '%s' in modulemap!\n"",; 3959 moduleName.c_str());; 3960 return false;; 3961 }; 3962 ; 3963 // Check if the loaded module covers all headers that were specified; 3964 // by the user on the command line. This is an integrity check to; 3965 // ensure that our used module map is not containing extraneous headers.; 3966 std::vector<std::array<std::string, 2>> missingHdrMod;; 3967 if (!ModuleContainsHeaders(modGen, headerSearch, module, missingHdrMod)) {; 3968 // FIXME: Upgrade this to an error once modules are stable.; 3969 std::stringstream msgStream;; 3970 msgStream << ""after creating module \"""" << module->Name << ""\"" "";; 3971 if (!module->PresumedModuleMapFile.empty()); 3972 msgStream << ""using modulemap \"""" << module->PresumedModuleMapFile << ""\"" "";; 3973 msgStream << ""the following headers are not part of that module:\n"";; 3974 for (auto &H : missingHdrMod) {; 3975 msgStream << "" "" << H[0];; 3976 if (!H[1].empty()); 3977 msgStream << "" (already part of module \"""" << H[1] << ""\"")"";; 3978 msgStream << ""\n"";; 3979 }; 3980 std::string warningMessage = msgStream.str();; 3981 ; 3982 bool maybeUmbrella = modGen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:160273,load,loaded,160273,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['load'],['loaded']
Performance,"/////////////////////////////////////////////////; 1029///\returns true if the module was loaded.; 1030static bool LoadModule(const std::string &ModuleName, cling::Interpreter &interp); 1031{; 1032 // When starting up ROOT, cling would load all modulemap files on the include; 1033 // paths. However, in a ROOT session, it is very common to run aclic which; 1034 // will invoke rootcling and possibly produce a modulemap and a module in; 1035 // the current folder.; 1036 //; 1037 // Before failing, try loading the modulemap in the current folder and try; 1038 // loading the requested module from it.; 1039 std::string currentDir = gSystem->WorkingDirectory();; 1040 assert(!currentDir.empty());; 1041 gCling->RegisterPrebuiltModulePath(currentDir);; 1042 if (gDebug > 2); 1043 ::Info(""TCling::__LoadModule"", ""Preloading module %s. \n"",; 1044 ModuleName.c_str());; 1045 ; 1046 return interp.loadModule(ModuleName, /*Complain=*/true);; 1047}; 1048 ; 1049////////////////////////////////////////////////////////////////////////////////; 1050/// Loads the C++ modules that we require to run any ROOT program. This is just; 1051/// supposed to make a C++ module from a modulemap available to the interpreter.; 1052static void LoadModules(const std::vector<std::string> &modules, cling::Interpreter &interp); 1053{; 1054 for (const auto &modName : modules); 1055 LoadModule(modName, interp);; 1056}; 1057 ; 1058static bool IsFromRootCling() {; 1059 // rootcling also uses TCling for generating the dictionary ROOT files.; 1060 const static bool foundSymbol = dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"");; 1061 return foundSymbol;; 1062}; 1063 ; 1064/// Checks if there is an ASTFile on disk for the given module \c M.; 1065static bool HasASTFileOnDisk(clang::Module *M, const clang::Preprocessor &PP, std::string *FullFileName = nullptr); 1066{; 1067 const HeaderSearchOptions &HSOpts = PP.getHeaderSearchInfo().getHeaderSearchOpts();; 1068 ; 1069 std::string ModuleFileName;; 1070 if (!HSOpts",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:37132,load,loadModule,37132,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,"['Load', 'load']","['Loads', 'loadModule']"
