quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Performance,"umEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCachedReal.html:18764,optimiz,optimizeCacheMode,18764,root/html530/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html,96,['optimiz'],['optimizeCacheMode']
Performance,"umEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooHistFunc.html:18428,optimiz,optimizeCacheMode,18428,root/html530/RooHistFunc.html,https://root.cern,https://root.cern/root/html530/RooHistFunc.html,4,['optimiz'],['optimizeCacheMode']
Performance,"umEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsMoment&operator=(const RooAbsMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsMoment.html:19349,optimiz,optimizeCacheMode,19349,root/html602/RooAbsMoment.html,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html,2,['optimiz'],['optimizeCacheMode']
Performance,"umEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooLinearVar&operator=(const RooLinearVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLinearVar.html:23410,optimiz,optimizeCacheMode,23410,root/html602/RooLinearVar.html,https://root.cern,https://root.cern/root/html602/RooLinearVar.html,2,['optimiz'],['optimizeCacheMode']
Performance,"umEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooProfileLL&operator=(const RooProfileLL&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProfileLL.html:19749,optimiz,optimizeCacheMode,19749,root/html602/RooProfileLL.html,https://root.cern,https://root.cern/root/html602/RooProfileLL.html,2,['optimiz'],['optimizeCacheMode']
Performance,"umEvent@ NumEventDefinition RooAbsReal.h:276; RooAbsReal::Relative@ RelativeDefinition RooAbsReal.h:276; RooAbsReal::Raw@ RawDefinition RooAbsReal.h:276. Reimplemented from RooAbsReal.; Reimplemented in RooSimultaneous.; Definition at line 2221 of file RooAbsPdf.cxx. ◆ plotOn() [3/3]. RooPlot * RooAbsPdf::plotOn ; (; RooPlot * ; frame, . RooLinkedList & ; cmdList . ); const. overridevirtual . Plot (project) PDF on specified frame. . If a PDF is plotted in an empty frame, it will show a unit-normalized curve in the frame variable. When projecting a multi- dimensional PDF onto the frame axis, hidden parameters are taken are taken at their current value.; If a PDF is plotted in a frame in which a dataset has already been plotted, it will show a projection integrated over all variables that were present in the shown dataset (except for the one on the x-axis). The normalization of the curve will be adjusted to the event count of the plotted dataset. An informational message will be printed for each projection step that is performed.; If a PDF is plotted in a frame showing a dataset after a fit, the above happens, but the PDF will be drawn and normalised only in the fit range. If this is not desired, plotting and normalisation range can be overridden using Range() and NormRange() as documented in the table below. This function takes the following named arguments (for more arguments, see also RooAbsReal::plotOn(RooPlot*,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,; const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,; const RooCmdArg&) const ). Type of argument Controlling normalisation . NormRange(const char* name) Calculate curve normalization w.r.t. specified range[s]. See the tutorial rf212_plottingInRanges_blinding.C NoteSetting a Range() by default also sets a NormRange() on the same range, meaning that the PDF is plotted and normalised in the same range. Overriding this can be useful if the PDF was fit in limit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:139528,perform,performed,139528,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['perform'],['performed']
Performance,"umIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_set1Set of input fractions; TIterator*_setIter1! Iterator over set of input fractions; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFracRemainder.html:33129,cache,cache,33129,root/html532/RooFracRemainder.html,https://root.cern,https://root.cern/root/html532/RooFracRemainder.html,1,['cache'],['cache']
Performance,umber of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooAbsOptTestStatistic::_optimized!; RooAbsData*RooAbsOptTestStatistic::_origDataOriginal data; RooAbsReal*RooAbsOptTestStatistic::_origFuncOriginal function; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestSta,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChi2Var.html:43521,cache,cache,43521,root/html602/RooChi2Var.html,https://root.cern,https://root.cern/root/html602/RooChi2Var.html,4,['cache'],['cache']
Performance,"umber of events in the dataset to obtain the fit function; # If model is an extended p.d.f, expected number events is used; # instead of the observed number of events.; ll = ROOT.RooLinkedList(); model.chi2FitTo(dh, ll); ; # NB: It is also possible to fit a ROOT.RooAbsReal function to a ROOT.RooDataHist; # using chi2FitTo().; ; # Note that entries with zero bins are _not_ allowed; # for a proper chi^2 calculation and will give error; # messages; dsmall = d.reduce(ROOT.RooFit.EventRange(1, 100)); dhsmall = dsmall.binnedClone(); chi2_lowstat = model.createChi2(dhsmall); print(chi2_lowstat.getVal()); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 104.639633447510988; Edm = 0.000778057047730882148; Nfcn = 70; a0 = 0.501526 +/- 0.0229096 (limited); a1 = 0.158456 +/- 0.0368354 (limited); bkgfrac = 0.506609 +/- 0.011349 (limited); sig1frac = 0.815448 +/- 0.0373695 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 90.86495991394004; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf602_chi2fit.py. tutorialsroofitrf602_chi2fit.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf602__chi2fit_8py.html:2803,optimiz,optimization,2803,doc/master/rf602__chi2fit_8py.html,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8py.html,4,"['cache', 'optimiz']","['cache-and-track', 'cached', 'optimization']"
Performance,"umber of extra bytes (overhead) read by the readahead buffer; Bool_tfEnablePrefetchingreading by prefetching asynchronously ; TFile*fFilePointer to file; Bool_tfIsSortedTrue if fSeek array is sorted; Bool_tfIsTransferredTrue when fBuffer contains something valid; Int_t*fLen[fNb] Length of long buffers; Int_tfNbNumber of long buffers; Long64_tfNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tfNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tfNseekNumber of blocks to be prefetched; Int_tfNtotTotal size of prefetched blocks; Long64_t*fPos[fNb] start of long buffers; TFilePrefetch*fPrefetch!Object that does the asynchronous reading in another thread; Long64_tfPrefetchedBlocksNumber of blocks prefetched.; Int_tfReadCallsNumber of read calls for this cache; Long64_t*fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*fSeekIndex[fNseek] sorted index table of fSeek; Int_t*fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tfSeekSizeAllocated size of fSeek; Long64_t*fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheRead(); Default Constructor. TFileCacheRead(TFile* file, Int_t buffersize, TObject* tree = 0); Creates a TFileCacheRead data structure. ~TFileCacheRead(); Destructor. void Close(Option_t* option = """"); Close out any threads or asynchronous fetches used by the underlying; implementation.; This is called by TFile::Close to prevent usage of the file handles; after the closing of the file. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void SecondPrefetch(Long64_t , Int_t ). void Print(Option_t* option = """") const; Print cache ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFileCacheRead.html:8632,cache,cache,8632,root/html534/TFileCacheRead.html,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html,1,['cache'],['cache']
Performance,"umber of extra bytes (overhead) read by the readahead buffer; Bool_tfEnablePrefetchingreading by prefetching asynchronously; TFile*fFilePointer to file; Bool_tfIsSortedTrue if fSeek array is sorted; Bool_tfIsTransferredTrue when fBuffer contains something valid; Int_t*fLen[fNb] Length of long buffers; Int_tfNbNumber of long buffers; Long64_tfNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tfNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tfNseekNumber of blocks to be prefetched; Int_tfNtotTotal size of prefetched blocks; Long64_t*fPos[fNb] start of long buffers; TFilePrefetch*fPrefetch! Object that does the asynchronous reading in another thread; Long64_tfPrefetchedBlocksNumber of blocks prefetched.; Int_tfReadCallsNumber of read calls for this cache; Long64_t*fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*fSeekIndex[fNseek] sorted index table of fSeek; Int_t*fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tfSeekSizeAllocated size of fSeek; Long64_t*fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheRead(); Default Constructor. TFileCacheRead(TFile* file, Int_t buffersize, TObject* tree = 0); Creates a TFileCacheRead data structure. ~TFileCacheRead(); Destructor. void Close(Option_t* option = """"); Close out any threads or asynchronous fetches used by the underlying; implementation.; This is called by TFile::Close to prevent usage of the file handles; after the closing of the file. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void SecondPrefetch(Long64_t , Int_t ). void Print(Option_t* option = """") const; Print cache ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFileCacheRead.html:9159,cache,cache,9159,root/html602/TFileCacheRead.html,https://root.cern,https://root.cern/root/html602/TFileCacheRead.html,2,['cache'],['cache']
Performance,"umber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); Bool_tfCanChangeConfig! variable indicates can be basic configuration changed or not; TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; Bool_tfIdsTableExists! indicate if IdsTable exists; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; ofstream*fLogFile! log file with SQL statements; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; Int_tfModifyCounter! indicates how many changes was done with database tables; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNby",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSQLFile.html:28928,Cache,Cached,28928,root/html530/TSQLFile.html,https://root.cern,https://root.cern/root/html530/TSQLFile.html,2,['Cache'],['Cached']
Performance,"umber of matrices in the tensor. ; Definition at line 55 of file TensorDataLoader.h. ◆ fBatchHeight. template<typename AData , typename AReal > . size_t TMVA::DNN::TTensorDataLoader< AData, TReference< AReal > >::fBatchHeight. private . The number od rows in each matrix. ; Definition at line 56 of file TensorDataLoader.h. ◆ fBatchIndex. template<typename AData , typename AReal > . size_t TMVA::DNN::TTensorDataLoader< AData, TReference< AReal > >::fBatchIndex. private . The index of the batch when there are multiple batches in parallel. ; Definition at line 59 of file TensorDataLoader.h. ◆ fBatchWidth. template<typename AData , typename AReal > . size_t TMVA::DNN::TTensorDataLoader< AData, TReference< AReal > >::fBatchWidth. private . The number of columns in each matrix. ; Definition at line 57 of file TensorDataLoader.h. ◆ fData. template<typename AData , typename AReal > . const AData& TMVA::DNN::TTensorDataLoader< AData, TReference< AReal > >::fData. private . The data that should be loaded in the batches. ; Definition at line 51 of file TensorDataLoader.h. ◆ fInputShape. template<typename AData , typename AReal > . std::vector<size_t> TMVA::DNN::TTensorDataLoader< AData, TReference< AReal > >::fInputShape. private . Defines the batch depth, no. of channels and spatial dimensions of an input tensor. ; Definition at line 61 of file TensorDataLoader.h. ◆ fNOutputFeatures. template<typename AData , typename AReal > . size_t TMVA::DNN::TTensorDataLoader< AData, TReference< AReal > >::fNOutputFeatures. private . The number of outputs from the classifier/regressor. ; Definition at line 58 of file TensorDataLoader.h. ◆ fNSamples. template<typename AData , typename AReal > . size_t TMVA::DNN::TTensorDataLoader< AData, TReference< AReal > >::fNSamples. private . The total number of samples in the dataset. ; Definition at line 53 of file TensorDataLoader.h. ◆ fSampleIndices. template<typename AData , typename AReal > . std::vector<size_t> TMVA::DNN::TTensorDataLoader< AData",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TTensorDataLoader_3_01AData_00_01TReference_3_01AReal_01_4_01_4.html:7902,load,loaded,7902,doc/master/classTMVA_1_1DNN_1_1TTensorDataLoader_3_01AData_00_01TReference_3_01AReal_01_4_01_4.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TTensorDataLoader_3_01AData_00_01TReference_3_01AReal_01_4_01_4.html,1,['load'],['loaded']
Performance,"umber of rows found in the file The second argument ""branchDescriptor"" is currently not used. ;  ; void ResetBranchAddress (TBranch *) override;  Reset the branch addresses to the internal fArgs array. ;  ; void ResetBranchAddresses () override;  Reset the branch addresses to the internal fArgs array. ;  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TTree;  TTree ();  Default constructor and I/O constructor. ;  ;  TTree (const char *name, const char *title, Int_t splitlevel=99, TDirectory *dir=(::ROOT::Internal::TDirectoryAtomicAdapter{}));  Normal tree constructor. ;  ;  TTree (const TTree &tt)=delete;  ;  ~TTree () override;  Destructor. ;  ; void AddAllocationCount (UInt_t count);  ; virtual Int_t AddBranchToCache (const char *bname, bool subbranches=false);  Add branch with name bname to the Tree cache. ;  ; virtual Int_t AddBranchToCache (TBranch *branch, bool subbranches=false);  Add branch b to the Tree cache. ;  ; void AddClone (TTree *);  Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ;  ; virtual TFriendElement * AddFriend (const char *treename, const char *filename="""");  Add a TFriendElement to the list of friends. ;  ; virtual TFriendElement * AddFriend (const char *treename, TFile *file);  Add a TFriendElement to the list of friends. ;  ; virtual TFriendElement * AddFriend (TTree *tree, const char *alias="""", bool warn=false);  Add a TFriendElement to the list of friends. ;  ; virtual void AddTotBytes (Int_t tot);  ; virtual void AddZipBytes (Int_t zip);  ; virtual Long64_t AutoSave (Option_t *option="""");  AutoSave tree header every fAutoSave bytes. ;  ; virtual Int_t Branch (const char *folder, Int_t bufsize=32000, Int_t splitlevel=99);  Create one branch for each element in the folder. ;  ; TBranch * Branch (const char *name, char *address, const char *leafli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNtuple.html:3242,cache,cache,3242,doc/master/classTNtuple.html,https://root.cern,https://root.cern/doc/master/classTNtuple.html,2,['cache'],['cache']
Performance,"umber of the given coordinates. ; If only a subset of the internal coordinates are passed, the missing coordinates are taken at their current value. Parameters. [in]coordVariables that are representing the coordinates. ; [in]fastIf the variables in coord and the ones of the data hist have the same size and layout, fast can be set to skip checking that all variables are present in coord. . NoteThis overload only exists because there is an implicit conversion from RooAbsArg to RooArgSet, and this needs to remain supported. This enables code like RooRealVar x(...);; dataHist.getIndex(x);; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; xDouble_t x[n]Definition legend1.C:17; It is, however, recommended to use dataHist.getIndex(RooArgSet(x));; in this case. ; Definition at line 160 of file RooDataHist.h. ◆ getVarInfo(). RooDataHist::VarInfo const & RooDataHist::getVarInfo ; (; ). private . Return reference to VarInfo struct with cached histogram variable information that is frequently used for histogram weights retrieval. ; If the _varInfo struct was not initialized yet, it will be initialized in this function. ; Definition at line 2424 of file RooDataHist.cxx. ◆ getWeightBatch(). std::span< const double > RooDataHist::getWeightBatch ; (; std::size_t ; first, . std::size_t ; len, . bool ; sumW2 = false . ); const. overridevirtual . Return event weights of all events in range [first, first+len). ; If cacheValidEntries() has been called, out-of-range events will have a weight of 0. ; Implements RooAbsData.; Definition at line 2406 of file RooDataHist.cxx. ◆ importDHistSet(). void RooDataHist::importDHistSet ; (; const RooArgList & ; vars, . RooCategory & ; indexCat, . std::map< std::string, RooDataHist * > ; dmap, . double ; initWgt . ). protected . Import data from given set of TH1/2/3 into this RooDataHist. ; The category indexCat labels the sources in the constructed RooDataHist. The stl map provides the mapping between the indexCat st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:60445,cache,cached,60445,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['cache'],['cached']
Performance,"umber of times a histogram is smoothed before creating the PDF; fHasMVAPdfs create PDFs for the MVA outputs; V for Verbose output (!V) for non verbos; H for Help message. void ProcessBaseOptions(); the option string is decoded, for availabel options see ""DeclareOptions"". void CreateVariableTransforms(const TString& trafoDefinition, TMVA::DataSetInfo& dataInfo, TMVA::TransformationHandler& transformationHandler, TMVA::MsgLogger& log); create variable transformations. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility; they are hence without any effect (the reader is only reading the training; options that HAD been used at the training of the .xml weightfile at hand. std::map<TString,Double_t> OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); call the Optimzier with the set of paremeters and ranges that; are meant to be tuned. void SetTuneParameters(map<TString,Double_t> tuneParameters); set the tuning parameters accoding to the argument; This is just a dummy .. have a look at the MethodBDT how you could; perhaps implment the same thing for the other Classifiers.. void TrainMethod(). void GetRegressionDeviation(UInt_t tgtNum, TMVA::Types::ETreeType type, Double_t& stddev, Double_t& stddev90Percent) const. void AddRegressionOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddMulticlassOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void NoErrorCalc(Double_t *const err, Double_t *const errUpper). Double_t GetMvaValue(const TMVA::Event *const ev, Double_t* err = 0, Double_t* errUpper = 0). Bool_t IsSignalLike(); uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation); for a quick determination if an event would be selected as signal or background. Bool_t IsSignalLike(Double_t mvaVal); uses a pre-set cut on the MVA output (SetSigna",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodBase.html:22318,tune,tuneParameters,22318,root/html534/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodBase.html,1,['tune'],['tuneParameters']
Performance,"umber of times a histogram is smoothed before creating the PDF; fHasMVAPdfs create PDFs for the MVA outputs; V for Verbose output (!V) for non verbos; H for Help message. void ProcessBaseOptions(); the option string is decoded, for availabel options see ""DeclareOptions"". void CreateVariableTransforms(const TString& trafoDefinition, TMVA::DataSetInfo& dataInfo, TMVA::TransformationHandler& transformationHandler, TMVA::MsgLogger& log); create variable transformations. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility; they are hence without any effect (the reader is only reading the training; options that HAD been used at the training of the .xml weightfile at hand. std::map<TString,Double_t> OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); call the Optimzier with the set of paremeters and ranges that; are meant to be tuned. void SetTuneParameters(map<TString,Double_t> tuneParameters); set the tuning parameters accoding to the argument; This is just a dummy .. have a look at the MethodBDT how you could; perhaps implment the same thing for the other Classifiers.. void TrainMethod(). void GetRegressionDeviation(UInt_t tgtNum, TMVA::Types::ETreeType type, Double_t& stddev, Double_t& stddev90Percent) const. void AddRegressionOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddMulticlassOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void NoErrorCalc(Double_t*const err, Double_t*const errUpper). Double_t GetMvaValue(const TMVA::Event*const ev, Double_t* err = 0, Double_t* errUpper = 0). Bool_t IsSignalLike(); uses a pre-set cut on the MVA output (SetSignalReferenceCut and SetSignalReferenceCutOrientation); for a quick determination if an event would be selected as signal or background. Bool_t IsSignalLike(Double_t mvaVal); uses a pre-set cut on the MVA output (SetSignalRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodBase.html:23831,tune,tuneParameters,23831,root/html602/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodBase.html,2,['tune'],['tuneParameters']
Performance,umberCountingCombination.C;   'Number Counting Example' RooStats tutorial macro #100 ;  ; file  rs_numbercountingutils.C;   'Number Counting Utils' RooStats tutorial ;  ; file  rs_numbercountingutils.py;   'Number Counting Utils' RooStats tutorial ;  ; file  StandardBayesianMCMCDemo.C;   Standard demo of the Bayesian MCMC calculator ;  ; file  StandardBayesianNumericalDemo.C;   Standard demo of the numerical Bayesian calculator ;  ; file  StandardFeldmanCousinsDemo.C;   Standard demo of the Feldman-Cousins calculator StandardFeldmanCousinsDemo ;  ; file  StandardFrequentistDiscovery.C;   StandardFrequentistDiscovery ;  ; file  StandardHistFactoryPlotsWithCategories.C;   StandardHistFactoryPlotsWithCategories ;  ; file  StandardHypoTestDemo.C;   Standard tutorial macro for hypothesis test (for computing the discovery significance) using all RooStats hypothesis tests calculators and test statistics. ;  ; file  StandardHypoTestInvDemo.C;   Standard tutorial macro for performing an inverted hypothesis test for computing an interval ;  ; file  StandardProfileInspectorDemo.C;   Standard demo of the ProfileInspector class StandardProfileInspectorDemo ;  ; file  StandardProfileInspectorDemo.py;   Standard demo of the ProfileInspector class StandardProfileInspectorDemo ;  ; file  StandardProfileLikelihoodDemo.C;   Standard demo of the Profile Likelihood calculator StandardProfileLikelihoodDemo ;  ; file  StandardProfileLikelihoodDemo.py;   Standard demo of the Profile Likelihood calculator StandardProfileLikelihoodDemo ;  ; file  StandardTestStatDistributionDemo.C;   StandardTestStatDistributionDemo.C ;  ; file  TestNonCentral.C;   Demonstrates non central chi-square. ;  ; file  TwoSidedFrequentistUpperLimitWithBands.C;   TwoSidedFrequentistUpperLimitWithBands ;  ; file  Zbi_Zgamma.C;   Demonstrate Z_Bi = Z_Gamma ;  ; file  Zbi_Zgamma.py;   Demonstrate Z_Bi = Z_Gamma ;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:34 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__roostats.html:3828,perform,performing,3828,doc/master/group__tutorial__roostats.html,https://root.cern,https://root.cern/doc/master/group__tutorial__roostats.html,1,['perform'],['performing']
Performance,"umed=0, Option_t *option="""")Division a la G3.Definition TGeoVolume.cxx:1103; where SLICE is the name of the new family representing all slices and 1 is the slicing axis. The meaning of the axis index is the following: for all volumes having shapes like box, trd1, trd2, trap, gtra or para - 1,2,3 means X,Y,Z; for tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi. In fact, the division operation has the same effect as positioning volumes in a given order inside the divided container - the advantage being that the navigation in such a structure is much faster. When a volume is divided, a volume family corresponding to the slices is created. In case all slices can be represented by a single shape, only one volume is added to the family and positioned N times inside the divided volume, otherwise, each slice will be represented by a distinct volume in the family. Divisions can be also performed in a given range of one axis. For that, one have to specify also the starting coordinate value and the step:; TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N, start, step);; A check is always done on the resulting division range : if not fitting into the container limits, an error message is posted. If we will browse the divided volume we will notice that it will contain N nodes starting with index 1 upto N. The first one has the lower X limit at START position, while the last one will have the upper X limit at START+N*STEP. The resulting slices cannot be positioned inside an other volume (they are by default positioned inside the divided one) but can be further divided and may contain other volumes:; TGeoVolume *slicey = slicex->Divide(""SLICEY"", 2, N1);; slicey->AddNode(other_vol, index, some_matrix);; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolumeMulti.html:5892,perform,performed,5892,doc/master/classTGeoVolumeMulti.html,https://root.cern,https://root.cern/doc/master/classTGeoVolumeMulti.html,1,['perform'],['performed']
Performance,"umeric integrator RooIntegrator1D to calculate Int(cpsi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7f337a0 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[cpsi]_NORM_cpsi for nset (cpsi) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(Mf_over_Mf_Int[cpsi]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_Mf_over_Mf_Int[cpsi]_MfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7e9d680 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[cpsi] for nset () with code 1 from preexisting content.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Mf_Int[cpsi]) using numeric integrator RooIntegrator1D to calculate Int(cpsi); [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7e9d680 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[cpsi]_NORM_cpsi for nset (cpsi) with code 0; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_CONV_Rpsi_CACHE_Obs[cpsi]_NORM_cpsi_Int[cpsi]) using numeric integrator RooIntegrator1D to calculate Int(cpsi); [#1] INFO:NumericIntegration -- RooRealIntegral::init(T_Int[cpsi]) using numeric integrator RooIntegrator1D to calculate Int(cpsi); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf210_angularconv.py. tutorialsroofitrf210_angularconv.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf210__angularconv_8py.html:7800,optimiz,optimization,7800,doc/master/rf210__angularconv_8py.html,https://root.cern,https://root.cern/doc/master/rf210__angularconv_8py.html,2,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"umerically. The optional; config object prescribes how these numeric integrations are configured. void autoSelectDirtyMode(); Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealIntegral.html:38789,cache,cache,38789,root/html534/RooRealIntegral.html,https://root.cern,https://root.cern/root/html534/RooRealIntegral.html,9,['cache'],"['cache', 'cached']"
Performance,"umn ""x"":; 1282~~~{.cpp}; 1283// Single-thread evaluation of RMS of column ""x"" using Foreach; 1284double sumSq = 0.;; 1285unsigned int n = 0;; 1286df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; 1287std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; 1288~~~; 1289In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; 1290thread will execute the expression concurrently.; 1291The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; 1292this is probably too much head-scratch for such a simple operation.; 1293 ; 1294ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; 1295additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; 1296guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; 1297executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; 1298We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; 1299~~~{.cpp}; 1300// Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; 1301ROOT::EnableImplicitMT();; 1302const unsigned int nSlots = df.GetNSlots();; 1303std::vector<double> sumSqs(nSlots, 0.);; 1304std::vector<unsigned int> ns(nSlots, 0);; 1305 ; 1306df.ForeachSlot([&sumSqs, &ns](unsigned int slot, double x) { sumSqs[slot] += x*x; ns[slot] += 1; }, {""x""});; 1307double sumSq = std::accumulate(sumSqs.begin(), sumSqs.end(), 0.); // sum all squares; 1308unsigned int n = std::accumulate(ns.begin(), ns.end(), 0); // sum all counts; 1309std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; 1310~~~; 1311Notice how we created one `double` variable for each processing slot and later merged their results via `std::accumulate`.; 1312 ; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:75336,concurren,concurrent,75336,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['concurren'],['concurrent']
Performance,"umn ""x"":; 1322~~~{.cpp}; 1323// Single-thread evaluation of RMS of column ""x"" using Foreach; 1324double sumSq = 0.;; 1325unsigned int n = 0;; 1326df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; 1327std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; 1328~~~; 1329In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; 1330thread will execute the expression concurrently.; 1331The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; 1332this is probably too much head-scratch for such a simple operation.; 1333 ; 1334ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; 1335additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; 1336guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; 1337executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; 1338We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; 1339~~~{.cpp}; 1340// Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; 1341ROOT::EnableImplicitMT();; 1342const unsigned int nSlots = df.GetNSlots();; 1343std::vector<double> sumSqs(nSlots, 0.);; 1344std::vector<unsigned int> ns(nSlots, 0);; 1345 ; 1346df.ForeachSlot([&sumSqs, &ns](unsigned int slot, double x) { sumSqs[slot] += x*x; ns[slot] += 1; }, {""x""});; 1347double sumSq = std::accumulate(sumSqs.begin(), sumSqs.end(), 0.); // sum all squares; 1348unsigned int n = std::accumulate(ns.begin(), ns.end(), 0); // sum all counts; 1349std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; 1350~~~; 1351Notice how we created one `double` variable for each processing slot and later merged their results via `std::accumulate`.; 1352 ; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:77016,concurren,concurrent,77016,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['concurren'],['concurrent']
Performance,"umn (RooAbsArg &var, bool adjustRange=true) override;  WVE ownership issue here!! Caller (a RooAbsData) should take ownership of all arguments, but only does for the first one here... ;  ; void append (RooAbsDataStore &other) override;  ; void attachBuffers (const RooArgSet &extObs) override;  ; void cacheArgs (const RooAbsArg *owner, RooArgSet &varSet, const RooArgSet *nset=nullptr, bool skipZeroWeights=false) override;  ; const RooAbsArg * cacheOwner () override;  ; bool changeObservableName (const char *from, const char *to) override;  Change name of internal observable named 'from' into 'to'. ;  ; RooAbsDataStore * clone (const char *newname=nullptr) const override;  ; RooAbsDataStore * clone (const RooArgSet &vars, const char *newname=nullptr) const override;  ; void dump () override;  ; Int_t fill () override;  Forward fill request to appropriate subset. ;  ; void forceCacheUpdate () override;  ; virtual const RooArgSet * get () const;  ; const RooArgSet * get (Int_t index) const override;  Load the n-th data point (n='idx') in memory and return a pointer to the internal RooArgSet holding its coordinates. ;  ; virtual const RooArgSet * get (Int_t index) const=0;  ; RooAbsData::RealSpans getBatches (std::size_t first, std::size_t len) const override;  Retrieve batches for all observables in this data store. ;  ; std::span< const double > getWeightBatch (std::size_t first, std::size_t len) const override;  Get the weights of the events in the range [first, first+len). ;  ; bool hasFilledCache () const override;  ; RooCategory * index ();  ; TClass * IsA () const override;  ; bool isWeighted () const override;  ; void loadValues (const RooAbsDataStore *tds, const RooFormulaVar *select=nullptr, const char *rangeName=nullptr, std::size_t nStart=0, std::size_t nStop=std::numeric_limits< std::size_t >::max()) override;  ; RooAbsDataStore * merge (const RooArgSet &allvars, std::list< RooAbsDataStore * > dstoreList) override;  ; Int_t numEntries () const override;  ; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCompositeDataStore.html:2665,Load,Load,2665,doc/master/classRooCompositeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooCompositeDataStore.html,1,['Load'],['Load']
Performance,"umn() [2/2]. TObjArray * TFITSHDU::GetTabStringColumn ; (; Int_t ; colnum). Get a string-typed column from a table HDU given its column index (>=0). ; Definition at line 1266 of file TFITS.cxx. ◆ GetTabVarLengthVectorCell() [1/2]. TArrayD * TFITSHDU::GetTabVarLengthVectorCell ; (; Int_t ; rownum, . const char * ; colname . ). Get the variable-length array contained in a cell given by (row>=0, column name) ; Definition at line 1606 of file TFITS.cxx. ◆ GetTabVarLengthVectorCell() [2/2]. TArrayD * TFITSHDU::GetTabVarLengthVectorCell ; (; Int_t ; rownum, . Int_t ; colnum . ). Get the variable-length array contained in a cell given by (row>=0, column name) ; Definition at line 1583 of file TFITS.cxx. ◆ IsA(). TClass * TFITSHDU::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 145 of file TFITS.h. ◆ LoadHDU(). Bool_t TFITSHDU::LoadHDU ; (; TString & ; filepath_filter). protected . Load HDU from fits file satisfying the specified filter. ; Returns kTRUE if success. Otherwise kFALSE. If filter == """" then the primary array is selected ; Definition at line 237 of file TFITS.cxx. ◆ Print(). void TFITSHDU::Print ; (; const Option_t * ; opt = """"); const. override . Print metadata. ; Currently supported options:. """" : print HDU record data; ""F"" : print FITS file's extension names, numbers and types; ""F+"": print FITS file's extension names and types and their record data; ""T"" : print column information when HDU is a table; ""T+"" : print full table (columns header and rows) . Definition at line 858 of file TFITS.cxx. ◆ PrintColumnInfo(). void TFITSHDU::PrintColumnInfo ; (; const Option_t * ; ); const. protected . Print column information. ; Definition at line 766 of file TFITS.cxx. ◆ PrintFileMetadata(). void TFITSHDU::PrintFileMetadata ; (; const Option_t * ; opt = """"); const. protected . Print HDU's parent file's metadata. ; Definition at line 665 of file TFITS.cxx. ◆ PrintFullTable(). void TFITSHD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFITSHDU.html:23813,Load,Load,23813,doc/master/classTFITSHDU.html,https://root.cern,https://root.cern/doc/master/classTFITSHDU.html,1,['Load'],['Load']
Performance,"umn. See DefineSlot() for more information. . RedefineSlotEntry() Overwrite the value and/or type of an existing column. See DefineSlotEntry() for more information. . Vary() Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). . Actions; Actions aggregate data into a result. Each one is described in more detail in the reference guide.; In the following, whenever we say an action ""returns"" something, we always mean it returns a smart pointer to it. Actions only act on events that pass all preceding filters.; Lazy actions only trigger the event loop when one of the results is accessed for the first time, making it easy to produce many different results in one event loop. Instant actions trigger the event loop instantly. Lazy action Description . Aggregate() Execute a user-defined accumulation operation on the processed column values. . Book() Book execution of a custom action using a user-defined helper object. . Cache() Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). . Count() Return the number of events processed. Useful e.g. to get a quick count of the number of events passing a Filter. . Display() Provides a printable representation of the dataset contents. The method returns a ROOT::RDF::RDisplay() instance which can print a tabular representation of the data or return it as a string. . Fill() Fill a user-defined object with the values of the specified columns, as if by calling Obj.Fill(col1, col2, ...). . Graph() Fills a TGraph with the two columns provided. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. . GraphAsymmErrors() Fills a TGraphAsymmErrors. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. . Histo1D(), Histo2D(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:5166,Cache,Cache,5166,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,4,['Cache'],['Cache']
Performance,"umn_double(fDataSet->fQuery, i); break;; 559 case ETypes::kText:; 560 nbytes = sqlite3_column_bytes(fDataSet->fQuery, i);; 561 if (nbytes == 0) {; 562 fValues[i].fText = """";; 563 } else {; 564 fValues[i].fText = reinterpret_cast<const char *>(sqlite3_column_text(fDataSet->fQuery, i));; 565 }; 566 break;; 567 case ETypes::kBlob:; 568 nbytes = sqlite3_column_bytes(fDataSet->fQuery, i);; 569 fValues[i].fBlob.resize(nbytes);; 570 if (nbytes > 0) {; 571 std::memcpy(fValues[i].fBlob.data(), sqlite3_column_blob(fDataSet->fQuery, i), nbytes);; 572 }; 573 break;; 574 case ETypes::kNull: break;; 575 default: throw std::runtime_error(""Unhandled column type"");; 576 }; 577 }; 578 return true;; 579}; 580 ; 581////////////////////////////////////////////////////////////////////////////////////////////////; 582/// Almost a no-op, many slots can in fact reduce the performance due to thread synchronization.; 583void RSqliteDS::SetNSlots(unsigned int nSlots); 584{; 585 if (nSlots > 1) {; 586 ::Warning(""SetNSlots"", ""Currently the SQlite data source faces performance degradation in multi-threaded mode. ""; 587 ""Consider turning off IMT."");; 588 }; 589 fNSlots = nSlots;; 590}; 591 ; 592////////////////////////////////////////////////////////////////////////////////////////////////; 593/// Helper function to throw an exception if there is a fatal sqlite error, e.g. an I/O error.; 594void RSqliteDS::SqliteError(int errcode); 595{; 596 std::string errmsg = ""SQlite error: "";; 597#if SQLITE_VERSION_NUMBER < 3007015; 598 errmsg += std::to_string(errcode);; 599#else; 600 errmsg += sqlite3_errstr(errcode);; 601#endif; 602 throw std::runtime_error(errmsg);; 603}; 604 ; 605} // namespace RDF; 606 ; 607} // namespace ROOT; RRawFile.hxx; RSqliteDS.hxx; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RSqliteDS_8cxx_source.html:24411,perform,performance,24411,doc/master/RSqliteDS_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html,2,"['multi-thread', 'perform']","['multi-threaded', 'performance']"
Performance,"umw2(Bool_t sumw2=kTRUE)When this static function is called with sumw2=kTRUE, all new histograms will automatically activate ...Definition TH1.cxx:6703; TH1::IsBinOverflowBool_t IsBinOverflow(Int_t bin, Int_t axis=0) constReturn true if the bin is overflow.Definition TH1.cxx:5182; TH1::GetAxisLabelStatusUInt_t GetAxisLabelStatus() constInternal function used in TH1::Fill to see which axis is full alphanumeric, i.e.Definition TH1.cxx:6675; TH1::fIntegralDouble_t * fIntegral! Integral of bins used by GetRandomDefinition TH1.h:111; TH1::fMinimumDouble_t fMinimumMinimum value for plotting.Definition TH1.h:101; TH1::Integralvirtual Double_t Integral(Option_t *option="""") constReturn integral of bin contents.Definition TH1.cxx:7941; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Double_t content)Set bin content see convention for numbering bins in TH1::GetBin In case the bin number is greater th...Definition TH1.cxx:9222; TH1::DirectoryAutoAddvirtual void DirectoryAutoAdd(TDirectory *)Perform the automatic addition of the histogram to the given directory.Definition TH1.cxx:2801; TH1::GetLowEdgevirtual void GetLowEdge(Double_t *edge) constFill array with low edge of bins for 1D histogram Better to use h1.GetXaxis()->GetLowEdge(edge)Definition TH1.cxx:9187; TH1::GetBinLowEdgevirtual Double_t GetBinLowEdge(Int_t bin) constReturn bin lower edge for 1D histogram.Definition TH1.cxx:9152; TH1::Buildvoid Build()Creates histogram basic data structure.Definition TH1.cxx:771; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::GetFunctionvirtual TF1 * GetFunction(const char *name) constReturn pointer to function with name.Definition TH1.cxx:9051; TH1::Rebinvirtual TH1 * Rebin(Int_t ngroup=2, const char *newname="""", const Double_t *xbins=nullptr)Rebin this histogram.Definition TH1.cxx:6275; TH1::BufferFillvirtual Int_t BufferFill(Double_t x, Double_t w)accumulate arguments in buffer.Definition TH1.cxx:1506; TH1::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:448822,Perform,Perform,448822,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['Perform'],['Perform']
Performance,"un.; If opt == 1, only the preparation phase (asserting and, eventually, downloading; of the package) is done; '*path' contains the full path to the; package to be passed in the next call; If opt == 2, only the building phase is run using *path .; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kBuildPackage; case). Keep in sync in case of changes. Int_t LoadPackage(const char* package, Bool_t notOnClient = kFALSE, TList* loadopts = 0); Load specified package. Executes the PROOF-INF/SETUP.C script; on all active nodes. If notOnClient = true, don't load package; on the client. The default is to load the package also on the client.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t LoadPackageOnClient(const char* package, TList* loadopts = 0); Load specified package in the client. Executes the PROOF-INF/SETUP.C; script on the client. Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kLoadPackage; case). Keep in sync in case of changes.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t UnloadPackage(const char* package); Unload specified package.; Returns 0 in case of success and -1 in case of error. Int_t UnloadPackageOnClient(const char* package); Unload a specific package on the client.; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::UnloadPackage; case). Keep in sync in case of changes. Int_t UnloadPackages(); Unload all packages.; Returns 0 in case of success and -1 in case of e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:62932,Load,LoadPackageOnClient,62932,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,9,"['Load', 'load']","['Load', 'LoadPackageOnClient', 'loadopts']"
Performance,"unc_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int OpenConnection(const char* server, int port, int tcpwindowsize = -1); Open a connection to another host. int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service. int AnnounceUnixService(int port, int backlog); Announce unix domain service. int AnnounceUnixServic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:34674,load,loaded,34674,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,2,['load'],['loaded']
Performance,"unc_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); Open a connection to another host. int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service. int AnnounceUdpService(int port, int backlog); Announce UDP service. i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSystem.html:34827,load,loaded,34827,root/html532/TSystem.html,https://root.cern,https://root.cern/root/html532/TSystem.html,1,['load'],['loaded']
Performance,"uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; If the change of size means some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:25114,cache,cachedbranches,25114,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,2,['cache'],"['cached', 'cachedbranches']"
Performance,"uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:24782,cache,cachedbranches,24782,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,2,['cache'],"['cached', 'cachedbranches']"
Performance,"uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static funct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:24165,cache,cachedbranches,24165,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,2,['cache'],"['cached', 'cachedbranches']"
Performance,"unction (using ROOT's Landau and Gauss functions) ;  line3Dfit.C Fitting of a TGraph2D with a 3D straight line ;  minuit2FitBench.C Demonstrate performance and usage of Minuit2 and Fumili2 for monodimensional fits ;  minuit2FitBench2D.C ;  minuit2GausFit.C Perform fits with different configurations using Minuit2 ;  multidimfit.C Multi-Dimensional Parametrisation and Fitting ;  multifit.C Fitting multiple functions to different ranges of a 1-D histogram Example showing how to fit in a sub-range of an histogram An histogram is created and filled with the bin contents and errors defined in the table below ;  myfit.C Get in memory an histogram from a root file and fit a user defined function ;  NumericalMinimization.C Example on how to use the new Minimizer class in ROOT Show usage with all the possible minimizers ;  qa2.C Test generation of random numbers distributed according to a function defined by the user ;  TestBinomial.C Perform a fit to a set of data with binomial errors like those derived from the division of two histograms ;  TwoHistoFit2D.C Example to fit two histograms at the same time ;  vectorizedFit.C use it for fitting an histogram ;  ► fitsio;  FITS_tutorial1.C ;  FITS_tutorial2.C ;  FITS_tutorial3.C ;  FITS_tutorial4.C ;  FITS_tutorial5.C ;  FITS_tutorial6.C ;  FITS_tutorial7.C ;  ► foam;  foam_demo.C Demonstrate the TFoam class ;  foam_demopers.C This simple macro demonstrates persistency of FOAM object ;  foam_kanwa.C This program can be execute from the command line as folows: ;  ► geom;  assembly.CGeometry detector assembly example ;  building.CDrawing a building where Dept ;  cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ;  csgdemo.CCombinatorial Solid Geometry example ;  geo2stp.CExports a geometry in step format ;  geodemo.CGUI to draw the geometry shapes ;  geomAlice.CScript drawing a detector geometry (here ALICE) ;  geomAlice_itsv.CScript drawing a detect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:110090,Perform,Perform,110090,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['Perform'],['Perform']
Performance,unction (using ROOT's Landau and Gauss functions) ;  line3Dfit.C Fitting of a TGraph2D with a 3D straight line ;  minuit2FitBench.C Demonstrate performance and usage of Minuit2 and Fumili2 for monodimensional fits ;  minuit2FitBench2D.C ;  minuit2GausFit.C Perform fits with different configurations using Minuit2 ;  multidimfit.C Multi-Dimensional Parametrisation and Fitting ;  multifit.C Fitting multiple functions to different ranges of a 1-D histogram Example showing how to fit in a sub-range of an histogram An histogram is created and filled with the bin contents and errors defined in the table below ;  myfit.C Get in memory an histogram from a root file and fit a user defined function ;  NumericalMinimization.C Example on how to use the new Minimizer class in ROOT Show usage with all the possible minimizers ;  qa2.C Test generation of random numbers distributed according to a function defined by the user ;  TestBinomial.C Perform a fit to a set of data with binomial errors like those derived from the division of two histograms ;  TwoHistoFit2D.C Example to fit two histograms at the same time ;  vectorizedFit.C use it for fitting an histogram ;  ► fitsio;  FITS_tutorial1.COpen a FITS file and retrieve the first plane of the image array as a TImage object ;  FITS_tutorial2.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial3.COpen a FITS file and retrieve the first plane of the image array as a TImage object ;  FITS_tutorial4.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial5.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial6.COpen a FITS file whose primary array represents a spectrum table (flux vs wavelength) and dump its columns ;  FITS_tutorial7.COpen a FITS file that contains a catalog of astronomical objects and dump some of its columns ;  ► foam;  foam_demo.C Demonstrate the TFoam class ;  foam_demopers.C This simple m,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:105788,Perform,Perform,105788,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,2,['Perform'],['Perform']
Performance,unction (using ROOT's Landau and Gauss functions) ;  line3Dfit.C Fitting of a TGraph2D with a 3D straight line ;  minuit2FitBench.C Demonstrate performance and usage of Minuit2 and Fumili2 for monodimensional fits ;  minuit2FitBench2D.C ;  minuit2GausFit.C Perform fits with different configurations using Minuit2 ;  multidimfit.C Multi-Dimensional Parametrisation and Fitting ;  multifit.C Fitting multiple functions to different ranges of a 1-D histogram Example showing how to fit in a sub-range of an histogram An histogram is created and filled with the bin contents and errors defined in the table below ;  myfit.C Get in memory an histogram from a root file and fit a user defined function ;  NumericalMinimization.C Example on how to use the new Minimizer class in ROOT Show usage with all the possible minimizers ;  qa2.C Test generation of random numbers distributed according to a function defined by the user ;  TestBinomial.C Perform a fit to a set of data with binomial errors like those derived from the division of two histograms ;  TwoHistoFit2D.C Example to fit two histograms at the same time ;  ► fitsio;  FITS_tutorial1.COpen a FITS file and retrieve the first plane of the image array as a TImage object ;  FITS_tutorial2.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial3.COpen a FITS file and retrieve the first plane of the image array as a TImage object ;  FITS_tutorial4.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial5.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial6.COpen a FITS file whose primary array represents a spectrum table (flux vs wavelength) and dump its columns ;  ► foam;  foam_demo.C Demonstrate the TFoam class ;  foam_demopers.C This simple macro demonstrates persistency of FOAM object ;  foam_kanwa.C This program can be execute from the command line as folows: ;  ► geom;  assembly.CGeometry detector as,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:107426,Perform,Perform,107426,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,2,['Perform'],['Perform']
Performance,"unction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cachen inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values (only the cached one in this class,leave unchanges those of TF1). unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter name (this is stored in TF1). void ParameterGradient(double x, const double* par, double* grad) const; evaluate the derivative of the function with respect to the parameters. void FdF(double x, double& f, double& deriv) const; calculate function and derivative at same time (required by IGradient interface). void SetDerivPrecision(double eps); precision value used for calculating the derivative step-size; h = eps * |x|. The default is 0.001, give a smaller in case function changes rapidly. double GetDerivPrecision(); get precision value used for calculating the derivative step-size. double DoEvalPar(double x, const double* p) const; evaluate function passing coordinates x and vector of parameters. double DoEval(double x) const; evaluate function using the cached parameter values of this class (not of TF1); re-implement for better efficiency. double DoDerivative(double x) const; return the function derivatives w.r.t. x. double DoParameterDerivative(double x, const double* p, unsigned int ipar) const; evaluate the derivative of the function with respect to the parameters. » Author: L. Moneta Wed Sep 6 09:52:26 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: WrappedTF1.h 31207 2009-11-16 16:52:00Z moneta $ » Last generated: 2009-12-07 13:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__WrappedTF1.html:4181,cache,cached,4181,root/html526/ROOT__Math__WrappedTF1.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__WrappedTF1.html,1,['cache'],['cached']
Performance,"unction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cachen inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values (only the cached one in this class,leave unchanges those of TF1). unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter name (this is stored in TF1). void ParameterGradient(double x, const double* par, double* grad) const; evaluate the derivative of the function with respect to the parameters. void FdF(double x, double& f, double& deriv) const; calculate function and derivative at same time (required by IGradient interface). void SetDerivPrecision(double eps); precision value used for calculating the derivative step-size; h = eps * |x|. The default is 0.001, give a smaller in case function changes rapidly. double GetDerivPrecision(); get precision value used for calculating the derivative step-size. double DoEvalPar(double x, const double* p) const; evaluate function passing coordinates x and vector of parameters. double DoEval(double x) const; evaluate function using the cached parameter values of this class (not of TF1); re-implement for better efficiency. double DoDerivative(double x) const; return the function derivatives w.r.t. x. double DoParameterDerivative(double x, const double* p, unsigned int ipar) const; evaluate the derivative of the function with respect to the parameters. » Author: L. Moneta Wed Sep 6 09:52:26 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: WrappedTF1.h 34993 2010-08-25 10:41:19Z moneta $ » Last generated: 2010-09-23 19:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__WrappedTF1.html:4114,cache,cached,4114,root/html528/ROOT__Math__WrappedTF1.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__WrappedTF1.html,1,['cache'],['cached']
Performance,"unction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cachen inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values (only the cached one in this class,leave unchanges those of TF1). unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter name (this is stored in TF1). void ParameterGradient(double x, const double* par, double* grad) const; evaluate the derivative of the function with respect to the parameters. void FdF(double x, double& f, double& deriv) const; calculate function and derivative at same time (required by IGradient interface). void SetDerivPrecision(double eps); precision value used for calculating the derivative step-size; h = eps * |x|. The default is 0.001, give a smaller in case function changes rapidly. double GetDerivPrecision(); get precision value used for calculating the derivative step-size. double DoEvalPar(double x, const double* p) const; evaluate function passing coordinates x and vector of parameters. double DoEval(double x) const; evaluate function using the cached parameter values of this class (not of TF1); re-implement for better efficiency. double DoDerivative(double x) const; return the function derivatives w.r.t. x. double DoParameterDerivative(double x, const double* p, unsigned int ipar) const; evaluate the derivative of the function with respect to the parameters. » Author: L. Moneta Wed Sep 6 09:52:26 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: WrappedTF1.h 34993 2010-08-25 10:41:19Z moneta $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__WrappedTF1.html:4116,cache,cached,4116,root/html530/ROOT__Math__WrappedTF1.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__WrappedTF1.html,1,['cache'],['cached']
Performance,"unction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cachen inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values (only the cached one in this class,leave unchanges those of TF1). unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter name (this is stored in TF1). void ParameterGradient(double x, const double* par, double* grad) const; evaluate the derivative of the function with respect to the parameters. void FdF(double x, double& f, double& deriv) const; calculate function and derivative at same time (required by IGradient interface). void SetDerivPrecision(double eps); precision value used for calculating the derivative step-size; h = eps * |x|. The default is 0.001, give a smaller in case function changes rapidly. double GetDerivPrecision(); get precision value used for calculating the derivative step-size. double DoEvalPar(double x, const double* p) const; evaluate function passing coordinates x and vector of parameters. double DoEval(double x) const; evaluate function using the cached parameter values of this class (not of TF1); re-implement for better efficiency. double DoDerivative(double x) const; return the function derivatives w.r.t. x. double DoParameterDerivative(double x, const double* p, unsigned int ipar) const; evaluate the derivative of the function with respect to the parameters. » Author: L. Moneta Wed Sep 6 09:52:26 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: WrappedTF1.h 34993 2010-08-25 10:41:19Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__WrappedTF1.html:4116,cache,cached,4116,root/html532/ROOT__Math__WrappedTF1.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__WrappedTF1.html,1,['cache'],['cached']
Performance,"unction TSystem::SetMakeSharedLib(), the user will be able to; indicate, with shell commands, how to build a shared library (a good; default will be provided). The most common change, namely where to find; header files, will be available through the function; TSystem::SetIncludePath().; A good default will be provided so that a typical user session should be at; most:. root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);. The user may sometimes try to compile a script before it has loaded all the; needed shared libraries. In this case we want to be helpfull and output a; list of the unresolved symbols. So if the loading of the created shared; library fails, we will try to build a executable that contains the; script. The linker should then output a list of missing symbols. To support this we provide a TSystem::SetMakeExe() function, that sets the; directive telling how to create an executable. The loader will need; to be informed of all the libraries available. The information about; the libraries that has been loaded by .L and TSystem::Load() is accesible; to the script compiler. However, the information about; the libraries that have been selected at link time by the application; builder (like the root libraries for root.exe) are not available and need; to be explictly listed in fLinkedLibs (either by default or by a call to; TSystem::SetLinkedLibs()). To simplify customization we could also add to the .rootrc support for the; variables. Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include. Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib .... And also support for MakeSharedLibs() and MakeExe(). (the ... have to be replaced by the actual values and are here only to; shorten this comment). Int_t GetAclicProperties() const; Return the ACLiC properties field. See EAclicProperties for details; on the semantic of ea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:41404,load,loader,41404,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,6,['load'],['loader']
Performance,"unction binding and a given configuration ;  CRooNumIntConfigRooNumIntConfig holds the configuration parameters of the various numeric integrators used by RooRealIntegral ;  CRooNumIntFactoryRooNumIntFactory is a factory to instantiate numeric integrators from a given function binding and a given configuration ;  ►CRooNumRunningIntClass RooNumRunningInt is an implementation of RooAbsCachedReal that represents a running integral ; \[ RI(f(x)) = \int_{xlow}^{x} f(x') dx' \]. that is calculated internally with a numeric technique: The input function is first sampled into a histogram, which is then numerically integrated ;  CRICacheElem;  CRooObjCacheManagerClass RooObjCacheManager is an implementation of class RooCacheManager<RooAbsCacheElement> and specializes in the storage of cache elements that contain RooAbsArg objects ;  CRooParamBinningClass RooParamBinning is an implementation of RooAbsBinning that constructs a binning with a range definition that depends on external RooAbsReal objects ;  CRooParametricStepFunctionThe Parametric Step Function PDF is a binned distribution whose parameters are the heights of each bin ;  CRooParamHistFunc;  ►CRooPlotA RooPlot is a plot frame and a container for graphics objects within that frame ;  CDrawOpt;  CRooPlotableClass RooPotable is a base class for objects that can be inserted into RooPlots and take advantage of its internal normalization and axis range adjustment features ;  CRooPoissonPoisson pdf ;  CRooPolynomialRooPolynomial implements a polynomial p.d.f of the form ; \[ f(x) = \sum_{i} a_{i} * x^i \]. By default coefficient a_0 is chosen to be 1, as polynomial probability density functions have one degree of freedom less than polynomial functions due to the normalization condition ;  CRooPolyVarClass RooPolyVar is a RooAbsReal implementing a polynomial in terms of a list of RooAbsReal coefficients ; \[f(x) = \sum_{i} a_{i}x \]. Class RooPolyvar implements analytical integrals of all polynomials it can define ;  CRooPr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:108004,cache,cache,108004,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,3,['cache'],['cache']
Performance,"unction documentation; ~RooAbsString(); Destructor. const char* getVal() const; Return value of object. Calculated if dirty, otherwise cached value is returned. Bool_t operator==(const char* ) const; Equality operator comparing with a TString. Bool_t operator==(const RooAbsArg& other); Equality operator comparing to another RooAbsArg. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) const; Print value. Bool_t isValid() const; Check if current value is valid. Bool_t isValidString(const char* , Bool_t printError = kFALSE) const; Check if given string value is valid. Bool_t traceEvalHook(const char* value) const; Hook function for trace evaluation. const char* traceEval() const; Calculate current value of object, with error tracing wrapper. void syncCache(const RooArgSet* nset = 0); Forcibly bring internal cache up-to-date. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDiry = kTRUE); Copy cache of another RooAbsArg to our cache. Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. void fillTreeBranch(TTree& t); Fill tree branch associated with this object. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooStringVar fundamental object with our properties. TString evaluate() const; { return """" ; }. void attachToVStore(RooVectorDataStore& ); {}. » Last changed: Thu Nov 3 20:06:51 2011 » Last generated: 2011-11-03 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsString.html:20570,cache,cache,20570,root/html532/RooAbsString.html,https://root.cern,https://root.cern/root/html532/RooAbsString.html,1,['cache'],['cache']
Performance,"unction in; a (tight) loop where no new types will be created; you can set load=kFALSE (default). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the given include file correspond to a class that has; been loaded through a compiled dictionnary. void InitSystem(); Initialize operating system interface. void InitThreads(); Load and initialize thread library. TClass * LoadClass(const char* name, Bool_t silent = kFALSE) const; Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). Int_t LoadClass(const char* classname, const char* libname, Bool_t check = kFALSE); Check if class ""classname"" is known to the interpreter (in fact,; this check is not needed anymore, so classname is ignored). If; not it will load library ""libname"". If the library name does; not start with ""lib"", ""lib"" will be prepended and a search will; be made in the DynamicPath (see .rootrc). If not found a search; will be made on libname (without ""lib"" prepended) and if not found; a direct try of libname will be made (in case it contained an; absolute path).; If check is true it will only check if libname exists and is; readable.; Returns 0 on successful loading, -1 in case libname does not; exist or in case of error and -2 in case of version mismatch. void ls(Option_t* option = """") const; To list all objects of the application.; Loop on all objects created in the ROOT linked lists.; Objects may be files and windows or any other object directly; attached to the ROOT linked list. Int_t LoadMacro(const char* filename, Int_t* error = 0, Bool_t check = kFALSE); Load a macro in the interpreter's memory. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:26555,Load,LoadClass,26555,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,1,['Load'],['LoadClass']
Performance,"unction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set the FCN function represented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer is guranteed to be valid as far as the fitter class is valid and a new fit is not redone.; To be used only after fitti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Fit__Fitter.html:11150,perform,perform,11150,root/html604/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html604/ROOT__Fit__Fitter.html,1,['perform'],['perform']
Performance,"unction. ; Definition at line 446 of file TEntryListBlock.cxx. ◆ operator=(). TEntryListBlock & TEntryListBlock::operator= ; (; const TEntryListBlock & ; rhs). Definition at line 98 of file TEntryListBlock.cxx. ◆ OptimizeStorage(). void TEntryListBlock::OptimizeStorage ; (; ). If there are < kBlockSize or >kBlockSize*15 entries, change to an array representation. ; Definition at line 546 of file TEntryListBlock.cxx. ◆ Print(). void TEntryListBlock::Print ; (; const Option_t * ; option = """"); const. override . Print the entries in this block. ; Definition at line 492 of file TEntryListBlock.cxx. ◆ PrintWithShift(). void TEntryListBlock::PrintWithShift ; (; Int_t ; shift); const. Print the indices of this block + shift (used from TEntryList::Print()) to print the current values. ; Definition at line 503 of file TEntryListBlock.cxx. ◆ Remove(). bool TEntryListBlock::Remove ; (; Int_t ; entry). Remove entry #entry If the block has already been optimized and the entries are stored as a list and not as bits, trying to remove a new entry will make the block switch to bits representation. ; Definition at line 165 of file TEntryListBlock.cxx. ◆ ResetIndices(). void TEntryListBlock::ResetIndices ; (; ). inline . Definition at line 74 of file TEntryListBlock.h. ◆ Streamer(). void TEntryListBlock::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TEntryListBlock::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 80 of file TEntryListBlock.h. ◆ Transform(). void TEntryListBlock::Transform ; (; bool ; dir, . UShort_t * ; indexnew . ). protected . Transform the existing fIndices. . dir=0 - transform from bits to a list; dir=1 - tranform from a list to bits . Definition at line 563 of file TEntryListBlock.cxx. Member Data Documentation. ◆ fCurrent. UShort_t TEntryListBlock::fCurrent. protected . ! to fasten Contains() in list mode ; Definition at li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryListBlock.html:17100,optimiz,optimized,17100,doc/master/classTEntryListBlock.html,https://root.cern,https://root.cern/doc/master/classTEntryListBlock.html,1,['optimiz'],['optimized']
Performance,"unction.Definition TROOT.cxx:3189; TROOT::GetGitBranchconst char * GetGitBranch() constDefinition TROOT.h:224; TROOT::fForceStyleBool_t fForceStyleForce setting of current style when reading objects.Definition TROOT.h:133; TROOT::FromPopUpBool_t FromPopUp() constDefinition TROOT.h:207; TROOT::GetSelectedPrimitiveconst TObject * GetSelectedPrimitive() constDefinition TROOT.h:270; TROOT::MakeDefCanvasTCanvas * MakeDefCanvas() constReturn a default canvas.Definition TROOT.cxx:1554; TROOT::fTypesTCollection * fTypesList of data types definition.Definition TROOT.h:141; TROOT::GetColorTColor * GetColor(Int_t color) constReturn address of color with index color.Definition TROOT.cxx:1536; TROOT::IsLineProcessingBool_t IsLineProcessing() constDefinition TROOT.h:284; TROOT::GetGlobalTGlobal * GetGlobal(const char *name, Bool_t load=kFALSE) constReturn pointer to global variable by name.Definition TROOT.cxx:1631; TROOT::FindSTLClassTClass * FindSTLClass(const char *name, Bool_t load, Bool_t silent=kFALSE) constreturn a TClass object corresponding to 'name' assuming it is an STL container.Definition TROOT.cxx:1484; TROOT::fStreamerInfoTSeqCollection * fStreamerInfoList of active StreamerInfo classes.Definition TROOT.h:159; TROOT::Appendvoid Append(TObject *obj, Bool_t replace=kFALSE) overrideAppend object to this directory.Definition TROOT.cxx:1047; TROOT::GetIconPathstatic const TString & GetIconPath()Get the icon path in the installation. Static utility function.Definition TROOT.cxx:3168; TROOT::GetListOfCanvasesTSeqCollection * GetListOfCanvases() constDefinition TROOT.h:240; TROOT::AListOfEnums_tstd::atomic< TListOfEnums * > AListOfEnums_tDefinition TROOT.h:109; TROOT::GetListOfGlobalFunctionsTCollection * GetListOfGlobalFunctions(Bool_t load=kFALSE)Return list containing the TFunctions currently defined.Definition TROOT.cxx:1826; TROOT::fGitDateTString fGitDateDate and time when make was run.Definition TROOT.h:122; TROOT::fSpecialsTSeqCollection * fSpecialsList of special ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8h_source.html:34157,load,load,34157,doc/v632/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8h_source.html,1,['load'],['load']
Performance,"unction.Definition TROOT.cxx:3193; TROOT::GetGitBranchconst char * GetGitBranch() constDefinition TROOT.h:224; TROOT::fForceStyleBool_t fForceStyleForce setting of current style when reading objects.Definition TROOT.h:133; TROOT::FromPopUpBool_t FromPopUp() constDefinition TROOT.h:207; TROOT::GetSelectedPrimitiveconst TObject * GetSelectedPrimitive() constDefinition TROOT.h:270; TROOT::MakeDefCanvasTCanvas * MakeDefCanvas() constReturn a default canvas.Definition TROOT.cxx:1554; TROOT::fTypesTCollection * fTypesList of data types definition.Definition TROOT.h:141; TROOT::GetColorTColor * GetColor(Int_t color) constReturn address of color with index color.Definition TROOT.cxx:1536; TROOT::IsLineProcessingBool_t IsLineProcessing() constDefinition TROOT.h:284; TROOT::GetGlobalTGlobal * GetGlobal(const char *name, Bool_t load=kFALSE) constReturn pointer to global variable by name.Definition TROOT.cxx:1631; TROOT::FindSTLClassTClass * FindSTLClass(const char *name, Bool_t load, Bool_t silent=kFALSE) constreturn a TClass object corresponding to 'name' assuming it is an STL container.Definition TROOT.cxx:1484; TROOT::fStreamerInfoTSeqCollection * fStreamerInfoList of active StreamerInfo classes.Definition TROOT.h:159; TROOT::Appendvoid Append(TObject *obj, Bool_t replace=kFALSE) overrideAppend object to this directory.Definition TROOT.cxx:1047; TROOT::GetIconPathstatic const TString & GetIconPath()Get the icon path in the installation. Static utility function.Definition TROOT.cxx:3172; TROOT::GetListOfCanvasesTSeqCollection * GetListOfCanvases() constDefinition TROOT.h:240; TROOT::AListOfEnums_tstd::atomic< TListOfEnums * > AListOfEnums_tDefinition TROOT.h:109; TROOT::GetListOfGlobalFunctionsTCollection * GetListOfGlobalFunctions(Bool_t load=kFALSE)Return list containing the TFunctions currently defined.Definition TROOT.cxx:1826; TROOT::fGitDateTString fGitDateDate and time when make was run.Definition TROOT.h:122; TROOT::fSpecialsTSeqCollection * fSpecialsList of special ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:34156,load,load,34156,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,1,['load'],['load']
Performance,"unction; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderDerivation order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; ROOT::Math::RichardsonDerivator*_rd! Derivator ; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_xObservable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDerivative.html:32856,cache,cache,32856,root/html532/RooDerivative.html,https://root.cern,https://root.cern/root/html532/RooDerivative.html,1,['cache'],['cache']
Performance,"unction; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; const RooArgSet*_projDepsPointer to set with projected observables; TRefArrayRooAbsArg::_proxyListlist of proxies; string_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_t_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_t_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsTestStatistic.html:34797,cache,cache,34797,root/html532/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsTestStatistic.html,1,['cache'],['cache']
Performance,"unction<void(unsigned, const std::string &)>. function signature for call-backs from the window clients first argument is connection id, second is received data ; Definition at line 41 of file RWebWindow.hxx. ◆ WebWindowDeleteCallback_t. using ROOT::WebWindowDeleteCallback_t = typedef std::function<void(RWebWindow &)>. function signature for callback when RWebWindow destroyed ; Definition at line 37 of file RWebWindowsManager.hxx. ◆ WebWindowShowCallback_t. using ROOT::WebWindowShowCallback_t = typedef std::function<bool(RWebWindow &, const RWebDisplayArgs &)>. function signature for catching show calls of arbitrary RWebWindow if returns true, normal show procedure will not be invoked ; Definition at line 34 of file RWebWindowsManager.hxx. ◆ WebWindowWaitFunc_t. using ROOT::WebWindowWaitFunc_t = typedef std::function<int(double)>. function signature for waiting call-backs Such callback used when calling thread need to waits for some special data, but wants to run application event loop As argument, spent time in second will be provided Waiting will be performed until function returns non-zero value ; Definition at line 48 of file RWebWindow.hxx. Enumeration Type Documentation. ◆ EExecutionPolicy. enum class ROOT::EExecutionPolicy. strong . EnumeratorkSequential ; kMultiThread ; kMultiProcess . Definition at line 5 of file EExecutionPolicy.hxx. ◆ EFromHumanReadableSize. enum class ROOT::EFromHumanReadableSize. strong . EnumeratorkSuccess ; kParseFail ; kOverflow . Definition at line 69 of file StringConv.hxx. ◆ EFunctionMatchMode. enum ROOT::EFunctionMatchMode. EnumeratorkExactMatch ; kConversionMatch . Definition at line 161 of file TDictionary.h. ◆ EIOFeatures. enum class ROOT::EIOFeatures. strong . EnumeratorkSupported . Definition at line 39 of file TIOFeatures.hxx. ◆ ESTLType. enum ROOT::ESTLType. EnumeratorkNotSTL ; kSTLvector ; kSTLlist ; kSTLdeque ; kSTLmap ; kSTLmultimap ; kSTLset ; kSTLmultiset ; kSTLbitset ; kSTLforwardlist ; kSTLunorderedset ; kSTLunordere",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:26428,perform,performed,26428,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,1,['perform'],['performed']
Performance,"unctionTemplate::ExtraProperty ; (; ); const. Get the properties not already defined in Property.See TDictionary's EFunctionProperty. ; Definition at line 132 of file TFunctionTemplate.cxx. ◆ GetDeclId(). TDictionary::DeclId_t TFunctionTemplate::GetDeclId ; (; ); const. Definition at line 139 of file TFunctionTemplate.cxx. ◆ GetTemplateMinReqArgs(). UInt_t TFunctionTemplate::GetTemplateMinReqArgs ; (; ); const. Number of function optional (default) arguments. ; Definition at line 115 of file TFunctionTemplate.cxx. ◆ GetTemplateNargs(). UInt_t TFunctionTemplate::GetTemplateNargs ; (; ); const. Number of function arguments. ; Definition at line 107 of file TFunctionTemplate.cxx. ◆ IsA(). TClass * TFunctionTemplate::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TDictionary.; Definition at line 49 of file TFunctionTemplate.h. ◆ IsValid(). Bool_t TFunctionTemplate::IsValid ; (; ). virtual . Return true if this function template object is pointing to a currently loaded function. ; If a function is unloaded after the TFunction is created, the TFunction will be set to be invalid. ; Definition at line 89 of file TFunctionTemplate.cxx. ◆ operator=(). TFunctionTemplate & TFunctionTemplate::operator= ; (; const TFunctionTemplate & ; rhs). Assignment operator. ; Definition at line 50 of file TFunctionTemplate.cxx. ◆ Property(). Long_t TFunctionTemplate::Property ; (; ); const. overridevirtual . Get property description word. For meaning of bits see EProperty. ; Implements TDictionary.; Definition at line 124 of file TFunctionTemplate.cxx. ◆ Streamer(). void TFunctionTemplate::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TDictionary. ◆ StreamerNVirtual(). void TFunctionTemplate::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 49 of file TFunctionTemplate.h. ◆ Update(). Bool_t TFunctionTemplate::Update ; (; FuncTempInfo_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFunctionTemplate.html:16753,load,loaded,16753,doc/master/classTFunctionTemplate.html,https://root.cern,https://root.cern/doc/master/classTFunctionTemplate.html,1,['load'],['loaded']
Performance,"unctionality; Major JSROOT functions are located in main.mjs module and can be imported like:; <script type='module'>; import { openFile, draw } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/hsimple.root"";; let file = await openFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; </script>; Here the default location https://root.cern/js/latest/ is specified. One always can install JSROOT on private web server. When JSROOT is used with THttpServer, the address looks like:; <script type='module'>; import { httpRequest, draw } from 'http://your_root_server:8080/jsrootsys/modules/main.mjs';; let obj = await httpRequest('http://your_root_server:8080/Objects/hist/root.json','object');; await draw('drawing', obj, 'hist');; </script>; Loading main module is enough to get public JSROOT functionality - reading files and drawing objects. One also can load some special components directly like:; <script type='module'>; import { HierarchyPainter } from 'https://root.cern/js/latest/modules/gui.mjs';. let h = new HierarchyPainter(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; After script loading one can configure different parameters in gStyle object. It is instance of the TStyle object and behaves like gStyle variable in ROOT. For instance, to change stat format using to display value in stats box:; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; There is also settings object which contains all other JSROOT settings. For instance, one can configure custom format for different axes:; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:23737,load,load,23737,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['load'],['load']
Performance,"unctions inherited from TEveElement;  TEveElement ();  Default constructor. ;  ;  TEveElement (Color_t &main_color);  Constructor. ;  ;  TEveElement (const TEveElement &e);  Copy constructor. ;  ; virtual ~TEveElement ();  Destructor. ;  ; virtual void AddElement (TEveElement *el);  Add el to the list of children. ;  ; virtual TGListTreeItem * AddIntoListTree (TGListTree *ltree, TEveElement *parent);  Add this render element into ltree to all items belonging to parent. ;  ; virtual TGListTreeItem * AddIntoListTree (TGListTree *ltree, TGListTreeItem *parent_lti);  Add this element into ltree to an already existing item parent_lti. ;  ; virtual TGListTreeItem * AddIntoListTrees (TEveElement *parent);  Add this render element into all list-trees and all items belonging to parent. ;  ; virtual void AddParent (TEveElement *re);  Add re into the list parents. ;  ; virtual void AddStamp (UChar_t bits);  Add (bitwise or) given stamps to fChangeBits. ;  ; virtual void Annihilate ();  Optimized destruction without check of reference-count. ;  ; virtual void AnnihilateElements ();  Annihilate elements. ;  ; Bool_t ApplyVizTag (const TString &tag, const TString &fallback_tag="""");  Set the VizTag, find model-element from the VizDB and copy visualization-parameters from it. ;  ; List_i BeginChildren ();  ; List_ci BeginChildren () const;  ; List_i BeginParents ();  ; List_ci BeginParents () const;  ; virtual Bool_t CanEditElement () const;  ; virtual Bool_t CanEditMainColor () const;  ; virtual Bool_t CanEditMainTrans () const;  ; virtual Bool_t CanEditMainTransparency () const;  ; virtual void CheckReferenceCount (const TEveException &eh=""TEveElement::CheckReferenceCount "");  Check external references to this and eventually auto-destruct the render-element. ;  ; virtual void ClearStamps ();  ; virtual void CloneChildrenRecurse (TEveElement *dest, Int_t level=0) const;  Clone children and attach them to the dest element. ;  ; virtual TEveElement * CloneElementRecurse (Int_t level",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveBox.html:5269,Optimiz,Optimized,5269,doc/master/classTEveBox.html,https://root.cern,https://root.cern/doc/master/classTEveBox.html,24,['Optimiz'],['Optimized']
Performance,"unctions inherited from TEveElement;  TEveElement ();  Default constructor. ;  ;  TEveElement (Color_t &main_color);  Constructor. ;  ;  TEveElement (const TEveElement &e);  Copy constructor. ;  ; virtual ~TEveElement ();  Destructor. ;  ; virtual void AddElement (TEveElement *el);  Add el to the list of children. ;  ; virtual TGListTreeItem * AddIntoListTree (TGListTree *ltree, TEveElement *parent);  Add this render element into ltree to all items belonging to parent. ;  ; virtual TGListTreeItem * AddIntoListTree (TGListTree *ltree, TGListTreeItem *parent_lti);  Add this element into ltree to an already existing item parent_lti. ;  ; virtual TGListTreeItem * AddIntoListTrees (TEveElement *parent);  Add this render element into all list-trees and all items belonging to parent. ;  ; virtual void AddParent (TEveElement *re);  Add re into the list parents. ;  ; virtual void AddStamp (UChar_t bits);  Add (bitwise or) given stamps to fChangeBits. ;  ; virtual void Annihilate ();  Optimized destruction without check of reference-count. ;  ; virtual void AnnihilateElements ();  Annihilate elements. ;  ; Bool_t ApplyVizTag (const TString &tag, const TString &fallback_tag="""");  Set the VizTag, find model-element from the VizDB and copy visualization-parameters from it. ;  ; List_i BeginChildren ();  ; List_ci BeginChildren () const;  ; List_i BeginParents ();  ; List_ci BeginParents () const;  ; virtual Bool_t CanEditElement () const;  ; virtual Bool_t CanEditMainColor () const;  ; virtual Bool_t CanEditMainTrans () const;  ; virtual Bool_t CanEditMainTransparency () const;  ; virtual void ClearStamps ();  ; virtual void CloneChildrenRecurse (TEveElement *dest, Int_t level=0) const;  Clone children and attach them to the dest element. ;  ; virtual TEveElement * CloneElementRecurse (Int_t level=0) const;  Clone elements and recurse 'level' deep over children. ;  ; virtual void CollectSceneParents (List_t &scenes);  Collect all parents of class TEveScene. ;  ; virtual void Col",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveTrackPropagator.html:10509,Optimiz,Optimized,10509,doc/master/classTEveTrackPropagator.html,https://root.cern,https://root.cern/doc/master/classTEveTrackPropagator.html,1,['Optimiz'],['Optimized']
Performance,"unctions inherited from TEveElement;  TEveElement ();  Default constructor. ;  ;  TEveElement (Color_t &main_color);  Constructor. ;  ;  TEveElement (const TEveElement &e);  Copy constructor. ;  ; virtual ~TEveElement ();  Destructor. ;  ; virtual void AddElement (TEveElement *el);  Add el to the list of children. ;  ; virtual TGListTreeItem * AddIntoListTree (TGListTree *ltree, TEveElement *parent);  Add this render element into ltree to all items belonging to parent. ;  ; virtual TGListTreeItem * AddIntoListTree (TGListTree *ltree, TGListTreeItem *parent_lti);  Add this element into ltree to an already existing item parent_lti. ;  ; virtual TGListTreeItem * AddIntoListTrees (TEveElement *parent);  Add this render element into all list-trees and all items belonging to parent. ;  ; virtual void AddParent (TEveElement *re);  Add re into the list parents. ;  ; virtual void AddStamp (UChar_t bits);  Add (bitwise or) given stamps to fChangeBits. ;  ; virtual void Annihilate ();  Optimized destruction without check of reference-count. ;  ; virtual void AnnihilateElements ();  Annihilate elements. ;  ; Bool_t ApplyVizTag (const TString &tag, const TString &fallback_tag="""");  Set the VizTag, find model-element from the VizDB and copy visualization-parameters from it. ;  ; List_i BeginChildren ();  ; List_ci BeginChildren () const;  ; List_i BeginParents ();  ; List_ci BeginParents () const;  ; virtual Bool_t CanEditElement () const;  ; virtual Bool_t CanEditMainColor () const;  ; virtual Bool_t CanEditMainTrans () const;  ; virtual void CheckReferenceCount (const TEveException &eh=""TEveElement::CheckReferenceCount "");  Check external references to this and eventually auto-destruct the render-element. ;  ; virtual void ClearStamps ();  ; virtual void CloneChildrenRecurse (TEveElement *dest, Int_t level=0) const;  Clone children and attach them to the dest element. ;  ; virtual TEveElement * CloneElementRecurse (Int_t level=0) const;  Clone elements and recurse 'level' deep ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveTriangleSet.html:4505,Optimiz,Optimized,4505,doc/master/classTEveTriangleSet.html,https://root.cern,https://root.cern/doc/master/classTEveTriangleSet.html,1,['Optimiz'],['Optimized']
Performance,"unctions |; Protected Attributes |; List of all members ; RooStats::PdfProposal Class ReferenceRooFit » RooStats. ; PdfProposal is a concrete implementation of the ProposalFunction interface. ; It proposes points across the parameter space in the distribution of the given PDF.; To make Propose(xPrime, x) dependent on x, configure with PdfProposal::AddMapping(varToUpdate, valueToUse). For example, suppose we have:; // our parameter; RooRealVar p(""p"", ""p"", 5, 0, 10);; ; // create mean and sigma for gaussian proposal function; RooRealVar meanP(""meanP"", ""meanP"", 0, 10);; RooRealVar sigma(""sigma"", ""sigma"", 1, 0, 5);; RooGaussian pGaussian(""pGaussian"", ""pGaussian"", p, meanP, sigma);; ; // configure proposal function; PdfProposal pdfProposal(pGaussian);; pdfProposal.AddMapping(meanP, p); // each call of Propose(xPrime, x), meanP in; // the proposal function will be updated to; // the value of p in x. this will center the; // proposal function about x's p when; // proposing for xPrime; ; // To improve performance, PdfProposal has the ability to cache a specified; // number of proposals. If you don't call this function, the default cache size; // is 1, which can be slow.; pdfProposal.SetCacheSize(desiredCacheSize);; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooStats::PdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface.Definition PdfProposal.h:30; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; PdfProposal currently uses a fixed cache size. Adaptive caching methods are in the works for future versions. ; Definition at line 30 of file PdfProposal.h. Public Member Functions;  PdfProposal ();  By default, PdfProposal does NOT own the PDF that serves as the proposal density function. ;  ;  PdfProposal (RooAbsPdf &pdf);  By default, PdfProposal does NOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1PdfProposal.html:1239,perform,performance,1239,doc/master/classRooStats_1_1PdfProposal.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1PdfProposal.html,2,"['cache', 'perform']","['cache', 'performance']"
Performance,"unctions;  TEveMacro ();  Default constructor. ;  ;  TEveMacro (const char *name);  ;  TEveMacro (const TEveMacro &);  ;  ~TEveMacro () override;  ; Longptr_t Exec (const char *params=""0"", Int_t *error=nullptr) override;  Execute the macro. ;  ; TClass * IsA () const override;  ; void ResetRoot ();  Call gROOT->Reset() via interpreter. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TMacro;  TMacro ();  Create an empty macro, use AddLine() or ReadFile() to fill this macro. ;  ;  TMacro (const char *name, const char *title="""");  Create a macro with a name and a title. ;  ;  TMacro (const TMacro &);  Copy constructor. ;  ; virtual ~TMacro ();  Delete this macro. ;  ; virtual TObjString * AddLine (const char *text);  Add line with text in the list of lines of this macro. ;  ; void Browse (TBrowser *b) override;  When clicking in the browser, the following action is performed on this macro, depending the content of the variable TMacro.Browse. ;  ; virtual TMD5 * Checksum ();  Returns checksum of the current content. ;  ; virtual TObjString * GetLineWith (const char *text) const;  Search the first line containing text. ;  ; TList * GetListOfLines () const;  ; TClass * IsA () const override;  ; virtual Bool_t Load () const;  Load the macro into the interpreter. ;  ; TMacro & operator= (const TMacro &);  Copy constructor. ;  ; void Paint (Option_t *option="""") override;  Execute this macro (called by TPad::Paint). ;  ; void Print (Option_t *option="""") const override;  Print contents of this macro. ;  ; virtual Int_t ReadFile (const char *filename);  Read lines in filename in this macro. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save macro source on stream out. ;  ; virtual void SaveSource (const char *filename);  Save macro source in filename. ;  ; virtual void SetParams (const char *params=nullptr);  Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveMacro.html:1464,perform,performed,1464,doc/master/classTEveMacro.html,https://root.cern,https://root.cern/doc/master/classTEveMacro.html,1,['perform'],['performed']
Performance,"unctionsPointer to list of functions (fits and user)Definition TGraph.h:49; TGraph::GetCovariancevirtual Double_t GetCovariance() constReturn covariance of vectors x,y.Definition TGraph.cxx:1308; TGraph::SwapValuesstatic void SwapValues(Double_t *arr, Int_t pos1, Int_t pos2)Swap values.Definition TGraph.cxx:2611; TGraph::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraph.Definition TGraph.cxx:2516; TGraph::Zerovoid Zero(Int_t &k, Double_t AZ, Double_t BZ, Double_t E2, Double_t &X, Double_t &Y, Int_t maxiterations)Find zero of a continuous function.Definition TGraph.cxx:2717; TGraph::Allocatevirtual Double_t ** Allocate(Int_t newsize)Allocate internal data structures for newsize points.Definition TGraph.cxx:590; TGraph::FitPanelvirtual void FitPanel()Display a GUI panel with all graph fit options.Definition TGraph.cxx:1274; TGraph::Browsevoid Browse(TBrowser *b) overrideBrowse.Definition TGraph.cxx:651; TGraph::DoMergevirtual Bool_t DoMerge(const TGraph *g)protected function to perform the merge operation of a graphDefinition TGraph.cxx:2676; TGraph::InsertPointBeforevirtual void InsertPointBefore(Int_t ipoint, Double_t x, Double_t y)Insert a new point with coordinates (x,y) before the point number ipoint.Definition TGraph.cxx:1749; TGraph::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TGraph.h:126; TGraph::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TGraph.cxx:1056; TGraph::GetXDouble_t * GetX() constDefinition TGraph.h:139; TGraph::SaveAsvoid SaveAs(const char *filename=""graph"", Option_t *option="""") const overrideSave the graph as .csv, .tsv or .txt.Definition TGraph.cxx:2093; TGraph::Evalvirtual Double_t Eval(Double_t x, TSpline *spline=nullptr, Option_t *option="""") constInterpolate points in this graph at x using a TSpline.Definition TGraph.cxx:953; TGraph::InitExpovirtual void InitExpo(Double_t xmin=0, Double_t xmax=0)Compute Initial values of p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:120541,perform,perform,120541,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['perform'],['perform']
Performance,"und, or NULL; if a library called lib was not found.; This function does not open the library. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int OpenConne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSystem.html:36025,load,loaded,36025,root/html602/TSystem.html,https://root.cern,https://root.cern/root/html602/TSystem.html,2,['load'],['loaded']
Performance,"underlying fProofChain (chain proxy) is always; rebuilt (even if already existing).; If gettreeheader is kTRUE the header of the tree will be read from the; PROOF cluster: this is only needed for browsing and should be used with; care because it may take a long time to execute. void SetWeight(Double_t w = 1, Option_t* option = """"); -- Set chain weight. The weight is used by TTree::Draw to automatically weight each; selected entry in the resulting histogram.; For example the equivalent of; chain.Draw(""x"",""w""); is; chain.SetWeight(w,""global"");; chain.Draw(""x"");. By default the weight used will be the weight; of each Tree in the TChain. However, one can force the individual; weights to be ignored by specifying the option ""global"".; In this case, the TChain global weight will be used for all Trees. void Streamer(TBuffer& ); -- Stream a class object. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); -- Dummy function kept for back compatibility.; The cache is now activated automatically when processing TTrees/TChain. TChain(const TChain& ). TChain& operator=(const TChain& ). void ReleaseChainProof(). Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0). Int_t Fill(); { MayNotUse(""Fill()""); return -1; }. Long64_t GetCacheSize() const; { return fTree ? fTree->GetCacheSize() : fCacheSize; }. Int_t GetNtrees() const; { return fNtrees; }. Long64_t GetEntries() const. TObjArray * GetListOfFiles() const; Warning, GetListOfFiles returns the list of TChainElements (not the list of files); see TChain::AddFile to see how to get the corresponding TFile objects. {return fFiles;}. TList * GetStatus() const; { return fStatus; }. TTree * GetTree() const; { return fTree; }. Int_t GetTreeNumber() const; { return fTreeNumber; }. Long64_t * GetTreeOffset() const; { return fTreeOffset; }. Int_t GetTreeOffsetLen() const; { return fTreeOffsetLen; }. void SetMakeClass(Int_t make); { TTree::SetMakeClass(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TChain.html:55949,cache,cache,55949,root/html534/TChain.html,https://root.cern,https://root.cern/root/html534/TChain.html,3,['cache'],['cache']
Performance,"uneStrength(Float_t alpha = -1.0). Data Members; private:. Float_tfAlpha! regularization parameter in CC pruning; Bool_tfDebug! debug flag; Int_tfOptimalK! index of the optimal tree in the pruned tree sequence; Bool_tfOwnQIndex! flag indicates if fQualityIndex is owned by this; vector<TMVA::DecisionTreeNode*>fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Float_t>fPruneStrengthList! map of alpha -> pruning index; TMVA::SeparationBase*fQualityIndex! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }; vector<Float_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::DecisionTree*fTree! (pruned) decision tree; const TMVA::DataSet*fValidationDataSet! the event sample to select the optimally-pruned tree; const TMVA::CCPruner::EventList*fValidationSample! the event sample to select the optimally-pruned tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCPruner( DecisionTree* t_max, const EventList* validationSample, SeparationBase* qualityIndex ); constructor. CCPruner( DecisionTree* t_max, const DataSet* validationSample, SeparationBase* qualityIndex ); constructor. ~CCPruner(). void Optimize(); determine the pruning sequence. std::vector<DecisionTreeNode*> GetOptimalPruneSequence() const; return the prune strength (=alpha) corresponding to the prune sequence. void SetPruneStrength(Float_t alpha = -1.0). CCPruner( DecisionTree* t_max, const EventList* validationSample, SeparationBase* qualityIndex = NULL ). Float_t GetOptimalQualityIndex() const; return the quality index from the validation sample for the optimal subtree T'. Float_t GetOptimalPruneStrength() const; return the prune strength (=alpha) corresponding to the prune sequence. » Last changed: Mon Jul 4 15:33:58 2011 » Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__CCPruner.html:2028,Optimiz,Optimize,2028,root/html530/TMVA__CCPruner.html,https://root.cern,https://root.cern/root/html530/TMVA__CCPruner.html,1,['Optimiz'],['Optimize']
Performance,"uneStrength(Float_t alpha = -1.0). Data Members; private:. Float_tfAlpha! regularization parameter in CC pruning; Bool_tfDebug! debug flag; Int_tfOptimalK! index of the optimal tree in the pruned tree sequence; Bool_tfOwnQIndex! flag indicates if fQualityIndex is owned by this; vector<TMVA::DecisionTreeNode*>fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Float_t>fPruneStrengthList! map of alpha -> pruning index; TMVA::SeparationBase*fQualityIndex! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }; vector<Float_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::DecisionTree*fTree! (pruned) decision tree; const TMVA::DataSet*fValidationDataSet! the event sample to select the optimally-pruned tree; const TMVA::CCPruner::EventList*fValidationSample! the event sample to select the optimally-pruned tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCPruner( DecisionTree* t_max, const EventList* validationSample, SeparationBase* qualityIndex ); constructor. CCPruner( DecisionTree* t_max, const DataSet* validationSample, SeparationBase* qualityIndex ); constructor. ~CCPruner(). void Optimize(); determine the pruning sequence. std::vector<DecisionTreeNode*> GetOptimalPruneSequence() const; return the prune strength (=alpha) corresponding to the prune sequence. void SetPruneStrength(Float_t alpha = -1.0). CCPruner( DecisionTree* t_max, const EventList* validationSample, SeparationBase* qualityIndex = NULL ). Float_t GetOptimalQualityIndex() const; return the quality index from the validation sample for the optimal subtree T'. Float_t GetOptimalPruneStrength() const; return the prune strength (=alpha) corresponding to the prune sequence. » Last changed: Thu Nov 3 20:19:24 2011 » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__CCPruner.html:2028,Optimiz,Optimize,2028,root/html532/TMVA__CCPruner.html,https://root.cern,https://root.cern/root/html532/TMVA__CCPruner.html,1,['Optimiz'],['Optimize']
Performance,"uneStrength(Float_t alpha = -1.0). Data Members; private:. Float_tfAlpha! regularization parameter in CC pruning; Bool_tfDebug! debug flag; Int_tfOptimalK! index of the optimal tree in the pruned tree sequence; Bool_tfOwnQIndex! flag indicates if fQualityIndex is owned by this; vector<TMVA::DecisionTreeNode*>fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Float_t>fPruneStrengthList! map of alpha -> pruning index; TMVA::SeparationBase*fQualityIndex! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }; vector<Float_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::DecisionTree*fTree! (pruned) decision tree; const TMVA::DataSet*fValidationDataSet! the event sample to select the optimally-pruned tree; const TMVA::CCPruner::EventList*fValidationSample! the event sample to select the optimally-pruned tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCPruner( DecisionTree* t_max, const EventList* validationSample, SeparationBase* qualityIndex ); constructor. CCPruner( DecisionTree* t_max, const DataSet* validationSample, SeparationBase* qualityIndex ); constructor. ~CCPruner(). void Optimize(); determine the pruning sequence. std::vector<DecisionTreeNode*> GetOptimalPruneSequence() const; return the prune strength (=alpha) corresponding to the prune sequence. void SetPruneStrength(Float_t alpha = -1.0). CCPruner( DecisionTree* t_max, const EventList* validationSample, SeparationBase* qualityIndex = NULL ). Float_t GetOptimalQualityIndex() const; return the quality index from the validation sample for the optimal subtree T'. Float_t GetOptimalPruneStrength() const; return the prune strength (=alpha) corresponding to the prune sequence. » Last changed: Tue Sep 8 17:04:39 2015 » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__CCPruner.html:2028,Optimiz,Optimize,2028,root/html534/TMVA__CCPruner.html,https://root.cern,https://root.cern/root/html534/TMVA__CCPruner.html,1,['Optimiz'],['Optimize']
Performance,"uned for a total write memory of around 300 MB per fill context. ; Definition at line 82 of file RNTupleWriteOptions.hxx. ◆ fUseBufferedWrite. bool ROOT::Experimental::RNTupleWriteOptions::fUseBufferedWrite = true. protected . Whether to use buffered writing (with RPageSinkBuf). ; This buffers compressed pages in memory, reorders them to keep pages of the same column adjacent, and coalesces the writes when committing a cluster. ; Definition at line 85 of file RNTupleWriteOptions.hxx. ◆ fUseDirectIO. bool ROOT::Experimental::RNTupleWriteOptions::fUseDirectIO = false. protected . Whether to use Direct I/O for writing. ; Note that this introduces alignment requirements that may very between filesystems and platforms. ; Definition at line 88 of file RNTupleWriteOptions.hxx. ◆ fUseImplicitMT. EImplicitMT ROOT::Experimental::RNTupleWriteOptions::fUseImplicitMT = EImplicitMT::kDefault. protected . Whether to use implicit multi-threading to compress pages. Only has an effect if buffered writing is turned on. ; Definition at line 93 of file RNTupleWriteOptions.hxx. ◆ fWriteBufferSize. std::size_t ROOT::Experimental::RNTupleWriteOptions::fWriteBufferSize = 4 * 1024 * 1024. protected . Buffer size to use for writing to files, must be a multiple of 4096 bytes. ; Testing suggests that 4MiB gives best performance (with Direct I/O) at a reasonable memory consumption. ; Definition at line 91 of file RNTupleWriteOptions.hxx. ◆ kDefaultMaxKeySize. constexpr std::uint64_t ROOT::Experimental::RNTupleWriteOptions::kDefaultMaxKeySize = 0x4000'0000. staticconstexpr . Definition at line 56 of file RNTupleWriteOptions.hxx. Libraries for ROOT::Experimental::RNTupleWriteOptions:. [legend]; The documentation for this class was generated from the following files:; tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx; tree/ntuple/v7/src/RNTupleWriteOptions.cxx. ROOTExperimentalRNTupleWriteOptions. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriteOptions.html:13023,perform,performance,13023,doc/master/classROOT_1_1Experimental_1_1RNTupleWriteOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriteOptions.html,1,['perform'],['performance']
Performance,"uner;  A helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) More...;  ; class  TMVA::CCTreeWrapper;  ; class  Classification;  Class to perform two class classification. More...;  ; class  ClassificationResult;  Class to save the results of the classifier. More...;  ; class  TMVA::ClassifierFactory;  This is the MVA factory. More...;  ; class  TMVA::ClassInfo;  Class that contains all the information of a class. More...;  ; class  TMVA::Config;  Singleton class for global configuration settings used by TMVA. More...;  ; class  TMVA::ConvergenceTest;  Check for convergence. More...;  ; class  TMVA::CostComplexityPruneTool;  A class to prune a decision tree using the Cost Complexity method. More...;  ; class  CreateMethodPlugins;  Plugins analysis. More...;  ; class  TMVA::CrossEntropy;  Implementation of the CrossEntropy as separation criterion. More...;  ; class  TMVA::CrossValidation;  Class to perform cross validation, splitting the dataloader into folds. More...;  ; class  TMVA::CrossValidationResult;  Class to save the results of cross validation, the metric for the classification ins ROC and you can ROC curves ROC integrals, ROC average and ROC standard deviation. More...;  ; class  TMVA::DataInputHandler;  Class that contains all the data information. More...;  ; class  TMVA::DataLoader;  ; class  TMVA::DataSet;  Class that contains all the data information. More...;  ; class  TMVA::DataSetFactory;  Class that contains all the data information. More...;  ; class  TMVA::DataSetInfo;  Class that contains all the data information. More...;  ; class  TMVA::DataSetManager;  Class that contains all the data information. More...;  ; class  TMVA::DecisionTree;  Implementation of a Decision Tree. More...;  ; class  TMVA::Envelope;  Abstract base class for all high level ml algorithms, you can book ml methods like BDT, MLP. More...;  ; class  TMVA::Event;  ; class  TMVA::ExpectedErrorPrune",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__TMVA.html:1962,perform,perform,1962,doc/master/group__TMVA.html,https://root.cern,https://root.cern/doc/master/group__TMVA.html,1,['perform'],['perform']
Performance,"unfolded spectrum. The unfolding procedure is based on singular value decomposition of the response matrix. The regularisation of the unfolding is implemented via a discrete minimum-curvature condition. Monte Carlo inputs:. xini: true underlying spectrum (TH1D, n bins); bini: reconstructed spectrum (TH1D, n bins); Adet: response matrix (TH2D, nxn bins). Consider the unfolding of a measured spectrum bdat with covariance matrix Bcov (if not passed explicitely, a diagonal covariance will be built given the errors of bdat). The corresponding spectrum in the Monte Carlo is given by bini, with the true underlying spectrum given by xini. The detector response is described by Adet, with Adet filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis. The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of xini and Adet. The unfolding can be performed by. TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );. where kreg determines the regularisation of the unfolding. In general, overregularisation (too small kreg) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large kreg) will lead to large fluctuations in the unfolded spectrum. The optimal regularisation can be determined following guidelines in Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307] using the distribution of the |d_i|<\tt> that can be obtained by tsvdunf->GetD() and/or using pseudo-experiments. Covariance matrices on the measured spectrum (for either the total uncertainties or individual sources of uncertainties) can be propagated to covariance matrices using the GetUnfoldCovMatrix method, which uses pseudo experiments for the propagation. In addition, GetAdetCovMatrix allows for the propagation of the statistical uncertainties on the response ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSVDUnfold.html:1613,perform,performed,1613,root/html532/TSVDUnfold.html,https://root.cern,https://root.cern/root/html532/TSVDUnfold.html,1,['perform'],['performed']
Performance,"unique_ptr< RooProdPdf::CacheElem > RooProdPdf::createCacheElem ; (; const RooArgSet * ; nset, . const RooArgSet * ; iset, . const char * ; isetRangeName = nullptr . ); const. private . Definition at line 674 of file RooProdPdf.cxx. ◆ createExpectedEventsFunc(). std::unique_ptr< RooAbsReal > RooProdPdf::createExpectedEventsFunc ; (; const RooArgSet * ; nset); const. overridevirtual . Returns an object that represents the expected number of events for a given normalization set, similar to how createIntegral() returns an object that returns the integral. ; This is used to build the computation graph for the final likelihood. ; Reimplemented from RooAbsPdf.; Definition at line 1681 of file RooProdPdf.cxx. ◆ DeclFileName(). static const char * RooProdPdf::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 190 of file RooProdPdf.h. ◆ doEvalImpl(). void RooProdPdf::doEvalImpl ; (; RooAbsArg const * ; caller, . const RooProdPdf::CacheElem & ; cache, . RooFit::EvalContext & ; ctx . ); const. private . Evaluate product of PDFs in batch mode. ; Definition at line 413 of file RooProdPdf.cxx. ◆ evaluate(). double RooProdPdf::evaluate ; (; ); const. overrideprivatevirtual . Calculate current value of object. ; Implements RooAbsReal.; Definition at line 371 of file RooProdPdf.cxx. ◆ expectedEvents(). double RooProdPdf::expectedEvents ; (; const RooArgSet * ; nset); const. overridevirtual . Return the expected number of events associated with the extendable input PDF in the product. ; If there is no extendable term, abort. ; Reimplemented from RooAbsPdf.; Definition at line 1671 of file RooProdPdf.cxx. ◆ extendMode(). RooAbsPdf::ExtendMode RooProdPdf::extendMode ; (; ); const. overridevirtual . If this product contains exactly one extendable p.d.f return the extension abilities of that p.d.f, otherwise return CanNotBeExtended. ; Reimplemented from RooAbsPdf.; Definition at line 1660 of file RooProdPdf.cxx. ◆ factorizePr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:88456,Cache,CacheElem,88456,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,2,"['Cache', 'cache']","['CacheElem', 'cache']"
Performance,"unless e.g. a new range is set for an observable).; Nodes of a computation graph are connected using instances of RooAbsProxy. If Node B declares a member RooTemplateProxy<TypeOfNodeA>, Node A will be registered as a server of values to Node B, and Node B will know that it is a client of node A. Using functions like dependsOn(), or getObservables() / getParameters(), the relation of A --> B can be queried. Using graphVizTree(), one can create a visualisation of the expression tree.; An instance of RooAbsArg can have named attributes. It also has flags to indicate that either its value or its shape were changed (= it is dirty). RooAbsArg provides functionality to manage client/server relations in a computation graph (clientServerInterface), and helps propagating value/shape changes through the graph. RooAbsArg implements interfaces for inspecting client/server relationships (clientServerInterface) and setting/clearing/querying named attributes. Caching of values; The values of nodes in the computation graph are cached in RooFit. If a value is used in two nodes of a graph, it doesn't need to be recomputed. If a node acquires a new value, it notifies its consumers (""clients"") that their cached values are dirty. See the functions in optimisationInterface for details. A node uses its isValueDirty() and isShapeDirty() functions to decide if a computation is necessary. Caching can be vetoed globally by setting a bit using setDirtyInhibit(). This will make computations slower, but all the nodes of the computation graph will be evaluated irrespective of whether their state is clean or dirty. Using setOperMode(), caching can also be enabled/disabled for single nodes. ; Definition at line 79 of file RooAbsArg.h. Classes; struct  ProxyListCache;  . Public Types; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; usin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:2395,cache,cached,2395,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['cache'],['cached']
Performance,"unsigned int i) constparameter value by indexDefinition FitResult.h:174; ROOT::Fit::FitResult::Statusint Status() constminimizer status codeDefinition FitResult.h:128; ROOT::Fit::FitResult::fParNamesstd::vector< std::string > fParNamesparameter names (only with FCN only fits, when fFitFunc=0)Definition FitResult.h:366; ROOT::Fit::FitResult::fMinosErrorsstd::map< unsigned int, std::pair< double, double > > fMinosErrorsmap contains the two Minos errorsDefinition FitResult.h:364; ROOT::Fit::FitResult::SetChi2AndNdfvoid SetChi2AndNdf(double chi2, unsigned int npoints)Set the chi2 and the ndf This function should be called when using an external FCN for fitting and on...Definition FitResult.cxx:311; ROOT::Fit::FitResult::FittedFunctionconst IModelFunction * FittedFunction() constfitting quantitiesDefinition FitResult.h:139; ROOT::Fit::FitResult::GlobalCCdouble GlobalCC(unsigned int i) constparameter global correlation coefficientDefinition FitResult.h:209; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IParametricFunctionMultiDimTempl< double >; TMatrixT< Double_t >; RooFit::MinimizerRooCmdArg Minimizer(const char *type, const char *alg=nullptr)Definition RooGlobalFunc.cxx:751; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)Definition HFitImpl.cxx:133; MathNamespace for new Math classes and functions.; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::Internal::UpdateDefinition TBranchProxyDirector.cxx:42. mathmathcoreincFitFitResult.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitResult_8h_source.html:27679,perform,performing,27679,doc/master/FitResult_8h_source.html,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html,1,['perform'],['performing']
Performance,"unsigned int ivar, const string& name, double val, double step); set free variable. bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetVariableValue(unsigned int ivar, double val); set the value of an existing variable. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of the existing parameters). bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return false; }. const double * Errors() const; return errors at the minimum. { return 0; }. double CovMatrix(unsigned int , unsigned int ) const; return covariance mat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__GSLSimAnMinimizer.html:6500,perform,perform,6500,root/html526/ROOT__Math__GSLSimAnMinimizer.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__GSLSimAnMinimizer.html,4,['perform'],['perform']
Performance,"unsigned int,unsigned int,double> ; RooCFunction3Ref<double,double,double,bool> ; RooCFunction3Ref<double,double,double,double> ; RooCFunction3Ref<double,double,int,int> ; RooCFunction3Ref<double,unsigned int,double,double> ; RooCFunction3Ref<double,unsigned int,double,unsigned int> ; RooCFunction3Ref<double,unsigned int,unsigned int,double> ; RooCFunction4Binding<double,double,double,double,bool> ; RooCFunction4Binding<double,double,double,double,double> ; RooCFunction4Binding<double,double,double,double,int> ; RooCFunction4PdfBinding<double,double,double,double,bool> ; RooCFunction4PdfBinding<double,double,double,double,double> ; RooCFunction4PdfBinding<double,double,double,double,int> ; RooCFunction4Ref<double,double,double,double,bool> ; RooCFunction4Ref<double,double,double,double,double> ; RooCFunction4Ref<double,double,double,double,int> ; RooCacheManager<RooAbsCacheElement> ; RooCacheManager<vector<double> > ; RooCachedPdf P.d.f class that wraps another p.d.f and caches its output; RooCachedReal P.d.f class that wraps another p.d.f and caches its output; RooCatType Category state, (name,index) pair; RooCategory Discrete valued variable type; RooCategoryProxy Proxy for a RooAbsCategory object; RooCategorySharedProperties Shared properties of a RooCategory clone set; RooChangeTracker Meta object that tracks changes in set of other arguments; RooChebychev Chebychev polynomial PDF; RooChi2MCSModule MCStudy module to calculate chi2 between binned data and fit; RooChi2Var Chi^2 function of p.d.f w.r.t a binned dataset; RooChiSquarePdf Chi Square distribution (eg. the PDF ); RooCintUtils ; RooClassFactory RooFit class code and instance factory; RooCmdArg Generic named argument container; RooCmdConfig Configurable parse of RooCmdArg objects; RooComplex a non-persistent bare-bones complex class; RooCompositeDataStore Composite Data Storage class; RooConstVar Constant RooAbsReal value object; RooConstraintSum sum of -log of set of RooAbsPdf representing parameter const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:29973,cache,caches,29973,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,2,['cache'],['caches']
Performance,untListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; TMatrixDSym*_corrMat; TMatrixDSym*_covMat; Double_t_d; RooDataSet&_data; vector<vector<Double_t> >_dataPts; vector<TVectorD>_dataPtsR; RooArgSet_dataVars; Bool_t_debug; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; TVectorD*_dx; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Bool_t_fixedShape; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooNDKeysPdf::BoxInfo_fullBoxInfo; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; vector<Int_t>_idx; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Double_t_maxWeight; vector<Double_t>_mean; Double_t_minWeight; Bool_t_mirror; Double_t_n; Int_t_nDim; Int_t_nEvents; Double_t_nEventsBMSW; Double_t_nEventsBW; Int_t_nEventsM; Double_t_nEventsW; Double_t_nSigma; static Int_tRooPrintable::_nameLength; TNamed*RooAbsAr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNDKeysPdf.html:44476,cache,cache,44476,root/html602/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html602/RooNDKeysPdf.html,2,['cache'],['cache']
Performance,"up_t structure. ;  ; std::string GetWorkingDirectory () const override;  Return working directory. ;  ; const char * HomeDirectory (const char *userName=nullptr) override;  Return the user's home directory. ;  ; const char * HostName () override;  Return the system's host name. ;  ; void IgnoreSignal (ESignals sig, Bool_t ignore=kTRUE) override;  If ignore is true ignore the specified signal, else restore previous behaviour. ;  ; Bool_t Init () override;  Initialize Unix system interface. ;  ; TClass * IsA () const override;  ; Bool_t IsPathLocal (const char *path) override;  Returns TRUE if the url in 'path' points to the local file system. ;  ; int Link (const char *from, const char *to) override;  Create a link from file1 to file2. ;  ; void ListLibraries (const char *regexp="""") override;  List all loaded shared libraries. ;  ; void ListSymbols (const char *module, const char *re="""") override;  List symbols in a shared library. ;  ; int Load (const char *module, const char *entry="""", Bool_t system=kFALSE) override;  Load a shared library. ;  ; int MakeDirectory (const char *name) override;  Make a Unix file system directory. ;  ; TTime Now () override;  Get current time in milliseconds since 0:00 Jan 1 1995. ;  ; int OpenConnection (const char *server, int port, int tcpwindowsize=-1, const char *protocol=""tcp"") override;  Open a connection to a service on a server. ;  ; void * OpenDirectory (const char *name) override;  Open a Unix file system directory. Returns 0 if directory does not exist. ;  ; void Openlog (const char *name, Int_t options, ELogFacility facility) override;  Open connection to system log daemon. ;  ; FILE * OpenPipe (const char *shellcmd, const char *mode) override;  Open a pipe. ;  ; const char * PrependPathName (const char *dir, TString &name) override;  Concatenate a directory and a file name. ;  ; int RecvBuf (int sock, void *buffer, int length) override;  Receive a buffer headed by a length indicator. ;  ; int RecvRaw (int sock, void *buffe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacOSXSystem.html:7992,Load,Load,7992,doc/master/classTMacOSXSystem.html,https://root.cern,https://root.cern/doc/master/classTMacOSXSystem.html,4,['Load'],['Load']
Performance,"updates the proxy chain when we will really use PROOF; 695 ResetBit(kProofUptodate);; 696 ; 697 // We need to invalidate the loading of the current tree because its list; 698 // of real friends is now obsolete. It is repairable only from LoadTree.; 699 InvalidateCurrentTree();; 700 ; 701 TTree* tree = fe->GetTree();; 702 if (!tree) {; 703 Warning(""AddFriend"", ""Unknown TChain %s"", chain);; 704 }; 705 return fe;; 706}; 707 ; 708////////////////////////////////////////////////////////////////////////////////; 709/// Add the whole chain or tree as a friend of this chain.; 710 ; 711TFriendElement* TChain::AddFriend(const char* chain, TFile* dummy); 712{; 713 if (!fFriends) fFriends = new TList();; 714 TFriendElement *fe = new TFriendElement(this,chain,dummy);; 715 ; 716 R__ASSERT(fe); // There used to be a ""if (fe)"" test ... Keep this assert until we are sure that fe is never null; 717 ; 718 fFriends->Add(fe);; 719 ; 720 if (fProofChain); 721 // This updates the proxy chain when we will really use PROOF; 722 ResetBit(kProofUptodate);; 723 ; 724 // We need to invalidate the loading of the current tree because its list; 725 // of real friend is now obsolete. It is repairable only from LoadTree; 726 InvalidateCurrentTree();; 727 ; 728 TTree *t = fe->GetTree();; 729 if (!t) {; 730 Warning(""AddFriend"",""Unknown TChain %s"",chain);; 731 }; 732 return fe;; 733}; 734 ; 735////////////////////////////////////////////////////////////////////////////////; 736/// Add the whole chain or tree as a friend of this chain.; 737 ; 738TFriendElement* TChain::AddFriend(TTree* chain, const char* alias, bool /* warn = false */); 739{; 740 if (!chain) return nullptr;; 741 if (!fFriends) fFriends = new TList();; 742 TFriendElement *fe = new TFriendElement(this,chain,alias);; 743 R__ASSERT(fe);; 744 ; 745 fFriends->Add(fe);; 746 ; 747 if (fProofChain); 748 // This updates the proxy chain when we will really use PROOF; 749 ResetBit(kProofUptodate);; 750 ; 751 // We need to invalidate the loading of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:28087,load,loading,28087,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['load'],['loading']
Performance,"uperfluous numeric calculations of unit normalization.s ; Implements RooAbsCachedPdf.; Definition at line 92 of file RooCachedPdf.cxx. ◆ inputBaseName(). const char * RooCachedPdf::inputBaseName ; (; ); const. inlineoverrideprotectedvirtual . Return the base name for cache objects, in this case the name of the cached p.d.f. ; Implements RooAbsCachedPdf.; Definition at line 33 of file RooCachedPdf.h. ◆ IsA(). TClass * RooCachedPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsCachedPdf.; Definition at line 51 of file RooCachedPdf.h. ◆ payloadUniqueSuffix(). const char * RooCachedPdf::payloadUniqueSuffix ; (; ); const. inlineoverrideprotectedvirtual . Reimplemented from RooAbsCachedPdf.; Definition at line 44 of file RooCachedPdf.h. ◆ preferredObservableScanOrder(). void RooCachedPdf::preferredObservableScanOrder ; (; const RooArgSet & ; obs, . RooArgSet & ; orderedObs . ); const. overridevirtual . Defer preferred scan order to cached pdf preference. ; Reimplemented from RooAbsReal.; Definition at line 114 of file RooCachedPdf.cxx. ◆ Streamer(). void RooCachedPdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsCachedPdf. ◆ StreamerNVirtual(). void RooCachedPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 51 of file RooCachedPdf.h. Member Data Documentation. ◆ _cacheObs. RooSetProxy RooCachedPdf::_cacheObs. protected . Observable to be cached. ; Definition at line 47 of file RooCachedPdf.h. ◆ pdf. RooRealProxy RooCachedPdf::pdf. protected . Proxy to p.d.f being cached. ; Definition at line 46 of file RooCachedPdf.h. Libraries for RooCachedPdf:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooCachedPdf.h; roofit/roofitcore/src/RooCachedPdf.cxx. RooCachedPdf. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:46 (GVA Time) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedPdf.html:82396,cache,cached,82396,doc/master/classRooCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooCachedPdf.html,1,['cache'],['cached']
Performance,"uple. More...;  ; class  ROOT::Experimental::Internal::RNTupleIndex;  Builds an index on one or several fields of an RNTuple so it can be joined onto other RNTuples. More...;  ; class  ROOT::Experimental::RNTupleInspector;  Inspect on-disk and storage-related information of an RNTuple. More...;  ; class  ROOT::Experimental::Internal::RNTupleMerger;  Given a set of RPageSources merge them into an RPageSink, optionally changing their compression. More...;  ; class  ROOT::Experimental::Detail::RNTupleMetrics;  A collection of Counter objects with a name, a unit, and a description. More...;  ; class  ROOT::Experimental::RNTupleModel;  The RNTupleModel encapulates the schema of an ntuple. More...;  ; class  ROOT::Experimental::Internal::RNTupleModelChangeset;  The incremental changes to a RNTupleModel More...;  ; class  ROOT::Experimental::RNTupleParallelWriter;  A writer to fill an RNTuple from multiple contexts. More...;  ; class  ROOT::Experimental::Detail::RNTuplePerfCounter;  A performance counter with a name and a unit, which can be activated on demand. More...;  ; class  ROOT::Experimental::Detail::RNTuplePlainCounter;  A non thread-safe integral performance counter. More...;  ; class  ROOT::Experimental::RNTupleProcessor;  Interface for iterating over entries of RNTuples and vertically concatenated RNTuples (chains). More...;  ; class  ROOT::Experimental::RNTupleReader;  An RNTuple that is used to read data from storage. More...;  ; class  ROOT::Experimental::RNTupleReadOptions;  Common user-tunable settings for reading ntuples. More...;  ; class  ROOT::Experimental::Internal::RNTupleSerializer;  A helper class for serializing and deserialization of the RNTuple binary format. More...;  ; class  ROOT::Experimental::Detail::RNTupleTickCounter< BaseCounterT >;  An either thread-safe or non thread safe counter for CPU ticks. More...;  ; class  ROOT::Experimental::Detail::RNTupleTimer< WallTimeT, CpuTimeT >;  Record wall time and CPU time between construction and dest",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__NTuple.html:9549,perform,performance,9549,doc/master/group__NTuple.html,https://root.cern,https://root.cern/doc/master/group__NTuple.html,1,['perform'],['performance']
Performance,"upport ;  CTVirtualCollectionIteratorsSmall helper class to generically acquire and release iterators ;  ►CTVirtualCollectionProxy;  CTPushPop;  ►CTVirtualCollectionPtrIterators;  CTInternalIterator;  CTVirtualDragManager;  CTVirtualFFTTVirtualFFT is an interface class for Fast Fourier Transforms ;  CTVirtualFitterAbstract Base Class for Fitting ;  CTVirtualGeoPainter;  CTVirtualGeoTrack;  CTVirtualGLManip;  CTVirtualGLPainter;  CTVirtualGraphPainterAbstract interface to a histogram painter ;  CTVirtualHistPainterAbstract interface to a histogram painter ;  CTVirtualIndexAbstract interface for Tree Index ;  CTVirtualIsAProxy;  CTVirtualMagField;  CTVirtualMC;  CTVirtualMCApplication;  CTVirtualMCDecayer;  CTVirtualMCGeometry;  CTVirtualMCStack;  CTVirtualMonitoringReader;  CTVirtualMonitoringWriter;  CTVirtualMutexThis class implements a mutex interface ;  CTVirtualObjectWrapper around an object and giving indirect access to its content even if the object is not of a class in the Cint/Reflex dictionary ;  ►CTVirtualPacketizer;  CTVirtualSlaveStat;  CTVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes ;  CTVirtualPadEditorAbstract base class used by ROOT graphics editor ;  CTVirtualPadPainterTo make it possible to use GL for 2D graphic in a TPad/TCanvas ;  CTVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing ;  CTVirtualProofPlayer;  CTVirtualPSTVirtualPS is an abstract interface to Postscript, PDF, SVG ;  CTVirtualRefProxy;  CTVirtualStreamerInfoAbstract Interface class describing Streamer information for one class ;  CTVirtualTableInterface;  CTVirtualTreePlayerAbstract base class defining the interface for the plugins that implement Draw, Scan, Process, MakeProxy, etc ;  CTVirtualVectorIterators;  CTVirtualViewer3DAbstract 3D shapes viewer ;  CTVirtualXSemi-Abstract base class defining a generic interface to the underlying, low level, native graphics backend (X11, Win32, MacOS, OpenGL.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:164674,perform,performance,164674,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['perform'],['performance']
Performance,"uration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsSelfCachedPdf(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsSelfCachedPdf(const RooAbsSelfCachedPdf& other, const char* name = 0); Copy constructor. ~RooAbsSelfCachedPdf(); Destructor. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Fill cache with sampling of p.d.f as defined by the evaluate() implementation. RooArgSet* actualObservables(const RooArgSet& nset) const; Defines observables to be cached, given a set of user defined observables; Returns the subset of nset that are observables this p.d.f. RooArgSet* actualParameters(const RooArgSet& nset) const; Defines parameters on which cache contents depends. Returns; subset of variables of self that is not contained in the; supplied nset. RooAbsSelfCachedPdf(); {}. const char* inputBaseName() const; Use own name as base name for caches. » Last changed: Tue Jun 30 14:30:31 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsSelfCachedPdf.html:47433,cache,cache,47433,root/html602/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsSelfCachedPdf.html,5,['cache'],"['cache', 'cached', 'caches']"
Performance,"uration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:60720,cache,cache,60720,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,7,['cache'],['cache']
Performance,"urce window ; [in]dest_x,dest_ycoordinates within the destination window ; [in]childreturns the child of ""dest"" if the coordinates are contained in a mapped child of the destination window; otherwise, child is set to 0 . Reimplemented from TVirtualX.; Definition at line 1335 of file TGCocoa.mm. ◆ UnionRectWithRegion(). void TGCocoa::UnionRectWithRegion ; (; Rectangle_t * ; rect, . Region_t ; src, . Region_t ; dest . ). overridevirtual . Updates the destination region from a union of the specified rectangle and the specified source region. ; Parameters. [in]rectspecifies the rectangle ; [in]srcspecifies the source region to be used ; [in]destreturns the destination region . Reimplemented from TVirtualX.; Definition at line 4300 of file TGCocoa.mm. ◆ UnionRegion(). void TGCocoa::UnionRegion ; (; Region_t ; rega, . Region_t ; regb, . Region_t ; result . ). overridevirtual . Computes the union of two regions. ; Parameters. [in]rega,regbspecify the two regions with which you want to perform the computation ; [in]resultreturns the result of the computation . Reimplemented from TVirtualX.; Definition at line 4323 of file TGCocoa.mm. ◆ UnmapWindow(). void TGCocoa::UnmapWindow ; (; Window_t ; id). overridevirtual . Unmaps the specified window ""id"". ; If the specified window is already unmapped, this function has no effect. Any child window will no longer be visible (but they are still mapped) until another map call is made on the parent. ; Reimplemented from TVirtualX.; Definition at line 1184 of file TGCocoa.mm. ◆ Update(). void TGCocoa::Update ; (; Int_t ; mode). overridevirtual . Flushes (mode = 0, default) or synchronizes (mode = 1) X output buffer. ; Flush flushes output buffer. Sync flushes buffer and waits till all requests have been processed by X server. ; Reimplemented from TVirtualX.; Definition at line 578 of file TGCocoa.mm. ◆ UpdateWindow(). void TGCocoa::UpdateWindow ; (; Int_t ; mode). overridevirtual . Updates or synchronises client and server once (not perm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:125801,perform,perform,125801,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['perform'],['perform']
Performance,"ure do the following instead:. TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; file->mkdir(""mydir"")->cd();; ch.Merge(file);. If 'option' contains the word 'fast' the merge will be done without; unzipping or unstreaming the baskets (i.e., a direct copy of the raw; bytes on disk). When 'fast' is specified, 'option' can also contains a; sorting order for the baskets in the output file. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file in the same order as in the original file; (i.e. the basket are sorted on their offset in the original; file; Usually this also means that the baskets are sorted; on the index/number of the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each; individual branches are stored contiguously. This tends to; optimize reading speed when reading a small number (1->5) of; branches, since all their baskets will be clustered together; instead of being spread across the file. However it might; decrease the performance when reading more branches (or the full; entry). When using SortBasketsByEntry the baskets with the lowest; starting entry are written first. (i.e. the baskets are; sorted on the index/number of the first entry they contain).; This means that on the file the baskets will be in the order; in which they will be needed when reading the whole tree; sequentially. IMPORTANT Note 1: AUTOMATIC FILE OVERFLOW. When merging many files, it may happen that the resulting file; reaches a size > TTree::fgMaxTreeSize (default = 1.9 GBytes).; In this case the current file is automatically closed and a new; file started. If the name of the merged file was ""merged.root"",; the subsequent files will be named ""merged_1.root"", ""merged_2.root"",; etc. fgMaxTreeSize may be modified via the static function; TTree::SetMaxTreeSize.; When in fast mode, the check and switch is only don",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TChain.html:40424,optimiz,optimize,40424,root/html526/TChain.html,https://root.cern,https://root.cern/root/html526/TChain.html,7,['optimiz'],['optimize']
Performance,"ure virtual . Implemented in ROOT::Experimental::Internal::RPageSourceDaos, ROOT::Experimental::Internal::RPageSourceFile, and ROOT::Experimental::Internal::RPageSourceFriends. ◆ LoadSealedPage(). virtual void ROOT::Experimental::Internal::RPageSource::LoadSealedPage ; (; DescriptorId_t ; physicalColumnId, . RClusterIndex ; clusterIndex, . RSealedPage & ; sealedPage . ). pure virtual . Read the packed and compressed bytes of a page into the memory buffer provided by sealedPage. ; The sealed page can be used subsequently in a call to RPageSink::CommitSealedPage. The fSize and fNElements member of the sealedPage parameters are always set. If sealedPage.fBuffer is nullptr, no data will be copied but the returned size information can be used by the caller to allocate a large enough buffer and call LoadSealedPage again. ; Implemented in ROOT::Experimental::Internal::RPageSourceFriends, ROOT::Experimental::Internal::RPageSourceDaos, and ROOT::Experimental::Internal::RPageSourceFile. ◆ LoadStructure(). void ROOT::Experimental::Internal::RPageSource::LoadStructure ; (; ). Loads header and footer without decompressing or deserializing them. ; This can be used to asynchronously open a file in the background. The method is idempotent and it is called as a first step in Attach(). Pages sources may or may not make use of splitting loading and processing meta-data. Therefore, LoadStructure() may do nothing and defer loading the meta-data to Attach(). ; Definition at line 188 of file RPageStorage.cxx. ◆ LoadStructureImpl(). virtual void ROOT::Experimental::Internal::RPageSource::LoadStructureImpl ; (; ). protectedpure virtual . Implemented in ROOT::Experimental::Internal::RPageSourceFriends, ROOT::Experimental::Internal::RPageSourceDaos, and ROOT::Experimental::Internal::RPageSourceFile. ◆ operator=() [1/2]. RPageSource & ROOT::Experimental::Internal::RPageSource::operator= ; (; const RPageSource & ; ). delete . ◆ operator=() [2/2]. RPageSource & ROOT::Experimental::Internal::RPage",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html:17049,Load,LoadStructure,17049,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,1,['Load'],['LoadStructure']
Performance,"ure. ; Definition at line 1085 of file TDataSetManagerFile.cxx. ◆ ChecksumDataSet(). Int_t TDataSetManagerFile::ChecksumDataSet ; (; const char * ; path, . const char * ; md5path, . TString & ; checksum . ). protected . Calculate the checksum of the indicated dataset at 'path' and save it to the appropriate file 'md5path'. ; The MD5 string is returned in 'md5sum'. Return 0 on success, -1 on error. ; Definition at line 1512 of file TDataSetManagerFile.cxx. ◆ Class(). static TClass * TDataSetManagerFile::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TDataSetManagerFile::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TDataSetManagerFile::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 100 of file TDataSetManagerFile.h. ◆ ClearCache(). Int_t TDataSetManagerFile::ClearCache ; (; const char * ; uri = 0). overridevirtual . Clear cached information matching uri. ; Reimplemented from TDataSetManager.; Definition at line 1253 of file TDataSetManagerFile.cxx. ◆ CreateLsFile(). Int_t TDataSetManagerFile::CreateLsFile ; (; const char * ; group, . const char * ; user, . Long_t & ; mtime, . TString & ; checksum . ). protected . Create or recreate the dataset lists for 'uri'. ; The list are saved in text form in 'uri'/ls.txt for fast browsing and in 'uri'/ls.root in form of TMacro for optimized and portable transfer. Return 0 on success, 1 if the file was empty, -1 on error ; Definition at line 474 of file TDataSetManagerFile.cxx. ◆ DeclFileName(). static const char * TDataSetManagerFile::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 100 of file TDataSetManagerFile.h. ◆ ExistsDataSet() [1/2]. Bool_t TDataSetManagerFile::ExistsDataSet ; (; const char * ; group, . const char * ; user, . const char * ; dsName . ). protected . Checks if the indicated dataset exits. ; D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManagerFile.html:23461,cache,cached,23461,doc/master/classTDataSetManagerFile.html,https://root.cern,https://root.cern/doc/master/classTDataSetManagerFile.html,1,['cache'],['cached']
Performance,"ure_t > > &batches, Scalar_t momentum);  Same as the Step(...) method for multiple batches but uses Nesterov momentum. ;  ; void StepReducedWeights (DeepNet_t &deepNet, std::vector< Matrix_t > &input, const Matrix_t &output, const Matrix_t &weights);  Does not evaluate the loss and therefore not trigger a possible synchronization with the device. ;  ; Scalar_t StepReducedWeightsLoss (DeepNet_t &deepNet, std::vector< Matrix_t > &input, const Matrix_t &output, const Matrix_t &weights);  Similar to StepReducedWeights(...) but also evaluates the loss. ;  . Private Attributes; size_t fBatchSize;  Batch size to use for the training. ;  ; size_t fConvergenceCount;  Current number of training epochs without. ;  ; size_t fConvergenceSteps;  Number of training epochs without considerable. ;  ; Scalar_t fLearningRate;  Learning rate \(\alpha\). ;  ; Scalar_t fMinimumError;  The minimum loss achieved on the training set during the current training session. ;  ; size_t fStepCount;  Number of steps performed in the current training session. ;  ; Scalar_t fTestError;  Holds the most recently computed test loss. ;  ; size_t fTestInterval;  Interval for the computation of the test error. ;  ; Scalar_t fTrainingError;  Holds the most recently computed training loss. ;  . #include <TMVA/DNN/DLMinimizers.h>; Member Typedef Documentation. ◆ DeepNet_t. template<typename Architecture_t > . using TMVA::DNN::TDLGradientDescent< Architecture_t >::DeepNet_t = TDeepNet<Architecture_t>. Definition at line 67 of file DLMinimizers.h. ◆ Matrix_t. template<typename Architecture_t > . using TMVA::DNN::TDLGradientDescent< Architecture_t >::Matrix_t = typename Architecture_t::Matrix_t. Definition at line 69 of file DLMinimizers.h. ◆ Scalar_t. template<typename Architecture_t > . using TMVA::DNN::TDLGradientDescent< Architecture_t >::Scalar_t = typename Architecture_t::Scalar_t. Definition at line 68 of file DLMinimizers.h. Constructor & Destructor Documentation. ◆ TDLGradientDescent() [1/2]. template<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html:3537,perform,performed,3537,doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,1,['perform'],['performed']
Performance,"ures is also a geometry validation check. Ray tracing can be activated at volume level as the normal Draw(). Ray-traced view in a pad. myVolume->Raytrace(); Once ray-tracing a view, this can be zoomed or rotated as a usual one. Objects on the screen are no longer highlighted when picking the vertices but the corresponding volumes is still accessible.; 18.7.3.1 Clipping Ray-traced Images; A ray-traced view can be clipped with any shape known by the modeller. This means that the region inside the clipping shape is subtracted from the current drawn geometry (become invisible). In order to activate clipping, one has to first define the clipping shape(s):; 1. TGeoShape *clip1, *clip2, ...; One might switch between several clipping shapes. Note that these shapes are considered defined in the current MARS. Composite shapes may be used.; 2. gGeoManager->SetClippingShape(clip1);; One can activate or deactivate clipping at any time: gGeoManager->SetClipping(flag);. Perform ray-tracing:gGeoManager->GetTopVolume()->Raytrace();. One can redo the steps 2-3 as many times as needed. Let us look how the rootgeom example looks clipped with a tube. Ray-tracing example with box-clipping. 18.8 Representing Misalignments of the Ideal Geometry; The ideal positioning of a detector does not match its position in the experimental hall. This generally happens not only for the detector modules, but also for their components. The accurate knowledge of the detector real misalignments can be extremely important for getting close to its designed resolution and the expected tracking efficiency. TGeo offers tools for representing positioning misalignments, applying them to the ideal geometry and performing navigation under these conditions. Detector tracking algorithms can then directly query the geometry for navigation purposes or for retrieving actual misalignment information.; 18.8.1 Physical Nodes; Physical nodes are the actual “touchable” objects in the geometry, representing actually a path of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1012780,Perform,Perform,1012780,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Perform'],['Perform']
Performance,"urn destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; Short_t fMaximum;  Maximum value if leaf range is specified. ;  ; Short_t fMinimum;  Minimum value if leaf range is specified. ;  ; Short_t ** fPointer;  ! Address of pointer to data buffer ;  ; Short_t * fValue;  ! Pointer to data buffer ;  ;  Protected Attributes inherited from TLeaf; TBranch * fBranch;  ! Pointer to supporting branch (we do not own the branch) ;  ; bool fIsRange;  (=true if leaf has a range, false otherwise). This is equivalent to being a 'leafcount'. For a TLeafElement the range information is actually store in the TBranchElement. ;  ; bool fIsUnsigned;  (=true if unsigned, false otherwise) ;  ; TLeaf * fLeafCount;  Pointer to Leaf count if variable length (we do not own the counter) ;  ; LeafCountValues * fLeafCountValues;  ! Cache of collection/array sizes ;  ; Int_t fLen;  Number of fixed length elements in the leaf's data. ;  ; Int_t fLenType;  Number of bytes for this data type. ;  ; Int_t fNdata;  ! Number of elements in fAddress data buffer. ;  ; Int_t fOffset;  Offset in ClonesArray object (if one) ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from TLeaf; enum class  DeserializeType { ;   kInvalid = 0; , kExternal; , kDestructive = kExternal; , kInPlace; , ;   kZeroCopy. };  ; enum  EStatusBits { kIndirectAddress = (1ULL << ( 11 )); , kNewValue = (1ULL << ( 12 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 ))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLeafS.html:14881,Cache,Cache,14881,doc/master/classTLeafS.html,https://root.cern,https://root.cern/doc/master/classTLeafS.html,1,['Cache'],['Cache']
Performance,"urn destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; void findShape (const std::vector< double > &x) const;  ; CacheElem * getCache (const RooArgSet *nset) const;  ; void initialize ();  ; int sij (const int &i, const int &j) const;  ; RooAbsReal * sumFunc (const RooArgSet *nset);  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMomentMorphFuncND.html:50308,Cache,CacheElem,50308,doc/master/classRooMomentMorphFuncND.html,https://root.cern,https://root.cern/doc/master/classRooMomentMorphFuncND.html,1,['Cache'],['CacheElem']
Performance,"urn fDebugMin; }. TDirectory * GetDirectory() const; { return fDirectory; }. Long64_t GetEntries() const; { return fEntries; }. Long64_t GetEntriesFast() const; { return fEntries; }. Long64_t GetEstimate() const; { return fEstimate; }. Int_t GetEvent(Long64_t entry = 0, Int_t getall = 0); { return GetEntry(entry, getall); }. TEventList * GetEventList() const; { return fEventList; }. Int_t GetFileNumber() const; { return fFileNumber; }. TH1 * GetHistogram(); { return GetPlayer()->GetHistogram(); }. Int_t * GetIndex(); { return &fIndex.fArray[0]; }. Double_t * GetIndexValues(); { return &fIndexValues.fArray[0]; }. TList * GetListOfClones(); { return fClones; }. TObjArray * GetListOfBranches(); { return &fBranches; }. TObjArray * GetListOfLeaves(); { return &fLeaves; }. TList * GetListOfFriends() const; { return fFriends; }. TList * GetListOfAliases() const; { return fAliases; }. Int_t GetMakeClass() const; GetMakeClass is left non-virtual for efficiency reason.; Making it virtual affects the performance of the I/O. { return fMakeClass; }. Long64_t GetMaxEntryLoop() const; { return fMaxEntryLoop; }. Long64_t GetMaxVirtualSize() const; { return fMaxVirtualSize; }. Int_t GetNbranches(); { return fBranches.GetEntriesFast(); }. TObject * GetNotify() const; { return fNotify; }. Int_t GetPacketSize() const; { return fPacketSize; }. Long64_t GetReadEntry() const; { return fReadEntry; }. Long64_t GetReadEvent() const; { return fReadEntry; }. Int_t GetScanField() const; { return fScanField; }. TTreeFormula * GetSelect(); { return GetPlayer()->GetSelect(); }. Long64_t GetSelectedRows(); { return GetPlayer()->GetSelectedRows(); }. Int_t GetTimerInterval() const; { return fTimerInterval; }. Long64_t GetTotBytes() const; { return fTotBytes; }. TTree * GetTree() const; { return const_cast<TTree*>(this); }. TVirtualIndex * GetTreeIndex() const; { return fTreeIndex; }. Int_t GetTreeNumber() const; { return 0; }. Int_t GetUpdate() const; { return fUpdate; }. TTreeFormula * GetVar(Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:130347,perform,performance,130347,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,3,['perform'],['performance']
Performance,"urn fDebugMin; }. TDirectory * GetDirectory() const; { return fDirectory; }. Long64_t GetEntries() const; { return fEntries; }. Long64_t GetEntriesFast() const; { return fEntries; }. Long64_t GetEstimate() const; { return fEstimate; }. Int_t GetEvent(Long64_t entry = 0, Int_t getall = 0); { return GetEntry(entry, getall); }. TEventList * GetEventList() const; { return fEventList; }. Int_t GetFileNumber() const; { return fFileNumber; }. TH1 * GetHistogram(); { return GetPlayer()->GetHistogram(); }. Int_t * GetIndex(); { return &fIndex.fArray[0]; }. Double_t * GetIndexValues(); { return &fIndexValues.fArray[0]; }. TList * GetListOfClones(); { return fClones; }. TObjArray * GetListOfBranches(); { return &fBranches; }. TObjArray * GetListOfLeaves(); { return &fLeaves; }. TList * GetListOfFriends() const; { return fFriends; }. TList * GetListOfAliases() const; { return fAliases; }. Int_t GetMakeClass() const; GetMakeClass is left non-virtual for efficiency reason.; Making it virtual affects the performance of the I/O. { return fMakeClass; }. Long64_t GetMaxEntryLoop() const; { return fMaxEntryLoop; }. Long64_t GetMaxVirtualSize() const; { return fMaxVirtualSize; }. Int_t GetNbranches(); { return fBranches.GetEntriesFast(); }. TObject * GetNotify() const; { return fNotify; }. Int_t GetPacketSize() const; { return fPacketSize; }. TVirtualPerfStats * GetPerfStats() const; { return fPerfStats; }. Long64_t GetReadEntry() const; { return fReadEntry; }. Long64_t GetReadEvent() const; { return fReadEntry; }. Int_t GetScanField() const; { return fScanField; }. TTreeFormula * GetSelect(); { return GetPlayer()->GetSelect(); }. Long64_t GetSelectedRows(); { return GetPlayer()->GetSelectedRows(); }. Int_t GetTimerInterval() const; { return fTimerInterval; }. Long64_t GetTotBytes() const; { return fTotBytes; }. TTree * GetTree() const; { return const_cast<TTree*>(this); }. TVirtualIndex * GetTreeIndex() const; { return fTreeIndex; }. Int_t GetTreeNumber() const; { return 0; }. Int_t Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:142657,perform,performance,142657,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['perform'],['performance']
Performance,"urn the newly created integral; 465 return norm ;; 466}; 467 ; 468 ; 469 ; 470////////////////////////////////////////////////////////////////////////////////; 471/// Verify that the normalization integral cached with this PDF; 472/// is valid for given set of normalization observables.; 473///; 474/// If not, the cached normalization integral (if any) is deleted; 475/// and a new integral is constructed for use with 'nset'.; 476/// Elements in 'nset' can be discrete and real, but must be lvalues.; 477///; 478/// For functions that declare to be self-normalized by overloading the; 479/// selfNormalized() function, a unit normalization is always constructed.; 480 ; 481bool RooAbsPdf::syncNormalization(const RooArgSet* nset, bool adjustProxies) const; 482{; 483 setActiveNormSet(nset);; 484 ; 485 // Check if data sets are identical; 486 CacheElem* cache = static_cast<CacheElem*>(_normMgr.getObj(nset)) ;; 487 if (cache) {; 488 ; 489 bool nintChanged = (_norm!=cache->_norm.get()) ;; 490 _norm = cache->_norm.get();; 491 ; 492 // In the past, this condition read `if (nintChanged && adjustProxies)`.; 493 // However, the cache checks if the nset was already cached **by content**,; 494 // and not by RooArgSet instance! So it can happen that the normalization; 495 // set object is different, but the integral object is the same, in which; 496 // case it would be wrong to not adjust the proxies. They always have to be; 497 // adjusted when the nset changed, which is always the case when; 498 // `syncNormalization()` is called.; 499 if (adjustProxies) {; 500 // Update dataset pointers of proxies; 501 const_cast<RooAbsPdf*>(this)->setProxyNormSet(nset) ;; 502 }; 503 ; 504 return nintChanged ;; 505 }; 506 ; 507 // Update dataset pointers of proxies; 508 if (adjustProxies) {; 509 const_cast<RooAbsPdf*>(this)->setProxyNormSet(nset) ;; 510 }; 511 ; 512 RooArgSet depList;; 513 getObservables(nset, depList);; 514 ; 515 if (_verboseEval>0) {; 516 if (!selfNormalized()) {; 517 cxcoutD(Trac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:18528,cache,cache,18528,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['cache'],['cache']
Performance,"urns THttpServer instance. ;  ; std::string GetServerAddr () const;  Returns http address of the server, empty string when not available. ;  ; void SetDeleteCallback (WebWindowDeleteCallback_t func);  Assign show callback which can catch window showing, used by RBrowser. ;  ; void SetShowCallback (WebWindowShowCallback_t func);  Assign show callback which can catch window showing, used by RBrowser. ;  ; void Terminate ();  Terminate http server and ROOT application. ;  . Static Public Member Functions; static void AddServerLocation (const std::string &server_prefix, const std::string &files_path);  Configure server location which can be used for loading of custom scripts or files When THttpServer instance of RWebWindowsManager will be created, THttpServer::AddLocation() method with correspondent arguments will be invoked. ;  ; static void AssignMainThrd ();  Re-assigns main thread id Normally main thread id recognized at the moment when library is loaded It supposed to be a thread where gApplication->Run() will be called If application runs in separate thread, one have to call this method to let RWebWindowsManager correctly recognize such situation. ;  ; static void ClearServerLocations ();  Clear all server locations Does not change configuration of already running HTTP server. ;  ; static std::map< std::string, std::string > GetServerLocations ();  Returns server locations as <std::string, std::string> Key is location name (with slash at the end) and value is file path. ;  ; static std::shared_ptr< RWebWindowsManager > & Instance ();  Returns default window manager Used to display all standard ROOT elements like TCanvas or TFitPanel. ;  ; static bool IsLoopbackMode ();  Returns true if loopback mode used by THttpServer for web widgets. ;  ; static bool IsMainThrd ();  Returns true when called from main process Main process recognized at the moment when library is loaded It supposed to be a thread where gApplication->Run() will be called If application runs in sepa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html:2092,load,loaded,2092,doc/master/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html,1,['load'],['loaded']
Performance,"urns entry #index; See also Next() for a faster alternative. Long64_t GetEntryAndTree(Int_t index, Int_t& treenum); return the entry corresponding to the index parameter and the; number of the tree, where this entry is. Long64_t GetEntries(); Returns the total number of entries in the list.; If some lists have not been loaded, loads them. Long64_t Next(); Returns the next entry in the list.; Faster than GetEntry(). Int_t LoadList(Int_t listnumber); Loads the list #listnumber; This is the only function that can modify fCurrent and fFile data members. void Print(Option_t* option = """") const; Print info about this list. TEntryListFromFile(const TEntryListFromFile& ). TEntryListFromFile & operator=(const TEntryListFromFile& ). void Add(const TEntryList* ); {}. Int_t Contains(Long64_t , TTree* ); {return 0;}. Bool_t Enter(Long64_t , TTree* ); {return 0;}. TEntryList * GetCurrentList() const; { return fCurrent; }. TEntryList * GetEntryList(const char* , const char* , Option_t* ); {return 0;}. Long64_t GetEntriesFast() const; { return fN; }. Long64_t GetN() const; { return fN; }. const char * GetTreeName() const; { return fTreeName.Data(); }. const char * GetFileName() const; { return fFileName.Data(); }. Int_t GetTreeNumber() const; { return fTreeNumber; }. Int_t Merge(TCollection* ); { return 0; }. void OptimizeStorage(); {}. Bool_t Remove(Long64_t , TTree* ); { return 0; }. void SetTree(const TTree* ); {}. void SetTree(const char* , const char* ); {}. void SetFileNames(TObjArray* names); { fFileNames = names; }. void SetTreeNumber(Int_t index); { fTreeNumber=index; }. void SetNFiles(Int_t nfiles); { fNFiles = nfiles; }. void Subtract(const TEntryList* ); {}. » Author: Anna Kreshuk 17/03/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-03-13 19:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEntryListFromFile.html:11905,Optimiz,OptimizeStorage,11905,root/html534/TEntryListFromFile.html,https://root.cern,https://root.cern/root/html534/TEntryListFromFile.html,1,['Optimiz'],['OptimizeStorage']
Performance,"urns maximum likelihood estimate of a specified parameter ;  CMCMCCalculatorBayesian Calculator estimating an interval or a credible region using the Markov-Chain Monte Carlo method to integrate the likelihood function with the prior to obtain the posterior function ;  CMCMCIntervalPlotThis class provides simple and straightforward utilities to plot a MCMCInterval object ;  CMetropolisHastingsThis class uses the Metropolis-Hastings algorithm to construct a Markov Chain of data points using Monte Carlo ;  CMinNLLTestStatMinNLLTestStat is an implementation of the TestStatistic interface that calculates the minimum value of the negative log likelihood function and returns it as a test statistic ;  CModelConfigModelConfig is a simple class that holds configuration information specifying how a model should be used in the context of various RooStats tools ;  CNeymanConstructionNeymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests, performs a NeymanConstruction ;  CNuisanceParametersSamplerHelper class for ToyMCSampler ;  CNumberCountingPdfFactory;  CNumEventsTestStatNumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting ;  CPdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface ;  CPointSetIntervalPointSetInterval is a concrete implementation of the ConfInterval interface ;  CProfileInspector;  CProfileLikelihoodCalculatorProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals) ;  CProfileLikelihoodTestStatProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset ;  CProofConfigHolds configuration options for proof and proof-lite ;  CProposalFunctionProposalFunction is an interface for all proposal funct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:7769,perform,performs,7769,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['perform'],['performs']
Performance,"urnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 120 of file TVirtualFitter.h. ◆ IsFixed(). virtual Bool_t TVirtualFitter::IsFixed ; (; Int_t ; ipar); const. pure virtual . Implemented in TBackCompFitter, TFumili, TFitter, and TLinearFitter. ◆ operator=(). TVirtualFitter & TVirtualFitter::operator= ; (; const TVirtualFitter & ; tvf). protected . assignment operator ; Definition at line 116 of file TVirtualFitter.cxx. ◆ PrintResults(). virtual void TVirtualFitter::PrintResults ; (; Int_t ; level, . Double_t ; amin . ); const. pure virtual . Implemented in TFumili, TBackCompFitter, TFitter, and TLinearFitter. ◆ ReleaseParameter(). virtual void TVirtualFitter::ReleaseParameter ; (; Int_t ; ipar). pure virtual . Implemented in TBackCompFitter, TFumili, TFitter, and TLinearFitter. ◆ SetCache(). Double_t * TVirtualFitter::SetCache ; (; Int_t ; npoints, . Int_t ; psize . ). virtual . Initialize the cache array npoints is the number of points to be stored (or already stored) in the cache psize is the number of elements per point. ; if (npoints*psize > fCacheSize) the existing cache is deleted and a new array is created. The function returns a pointer to the cache ; Definition at line 281 of file TVirtualFitter.cxx. ◆ SetDefaultFitter(). void TVirtualFitter::SetDefaultFitter ; (; const char * ; name = """"). static . static: set name of default fitter ; Definition at line 245 of file TVirtualFitter.cxx. ◆ SetErrorDef(). void TVirtualFitter::SetErrorDef ; (; Double_t ; errdef = 1). static . static: Set the Error Definition (default=1) For Minuit this is the value passed with the ""SET ERR"" command (see https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html) ; Definition at line 308 of file TVirtualFitter.cxx. ◆ SetFCN(). void TVirtualFitter::SetFCN ; (; void(*)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t) ; fcn). virtual . To set the address of the minimization objective function called by the native compiler (see function below whe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualFitter.html:25852,cache,cache,25852,doc/master/classTVirtualFitter.html,https://root.cern,https://root.cern/doc/master/classTVirtualFitter.html,2,['cache'],['cache']
Performance,"urrent FOM) for the fitting interface ; Implements TMVA::IFitterTarget.; Definition at line 307 of file OptimizeConfigParameters.cxx. ◆ GetBkgEffAtSigEff(). Double_t TMVA::OptimizeConfigParameters::GetBkgEffAtSigEff ; (; Double_t ; sigEff = 0.5). private . calculate the background efficiency for a given signal efficiency ; adapted by marc-.nosp@m.oliv.nosp@m.ier.b.nosp@m.ettl.nosp@m.er@ce.nosp@m.rn.c.nosp@m.h ; Definition at line 546 of file OptimizeConfigParameters.cxx. ◆ GetBkgRejAtSigEff(). Double_t TMVA::OptimizeConfigParameters::GetBkgRejAtSigEff ; (; Double_t ; sigEff = 0.5). private . calculate the background rejection for a given signal efficiency ; adapted by marc-.nosp@m.oliv.nosp@m.ier.b.nosp@m.ettl.nosp@m.er@ce.nosp@m.rn.c.nosp@m.h ; Definition at line 583 of file OptimizeConfigParameters.cxx. ◆ GetFOM(). Double_t TMVA::OptimizeConfigParameters::GetFOM ; (; ). private . Return the Figure of Merit (FOM) used in the parameter optimization process. ; Definition at line 350 of file OptimizeConfigParameters.cxx. ◆ GetMethod(). MethodBase * TMVA::OptimizeConfigParameters::GetMethod ; (; ). inlineprivate . Definition at line 72 of file OptimizeConfigParameters.h. ◆ GetMVADists(). void TMVA::OptimizeConfigParameters::GetMVADists ; (; ). private . fill the private histograms with the mva distributions for sig/bkg ; Definition at line 393 of file OptimizeConfigParameters.cxx. ◆ GetROCIntegral(). Double_t TMVA::OptimizeConfigParameters::GetROCIntegral ; (; ). private . calculate the area (integral) under the ROC curve as a overall quality measure of the classification ; making pdfs out of the MVA-output distributions doesn't work reliably for cases where the MVA-output isn't a smooth distribution. this happens ""frequently"" in BDTs for example when the number of trees is small resulting in only some discrete possible MVA output values. (I still leave the code here, but use this with care!!! The default however is to use the distributions!!! ; Definition at line 458 o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:6988,Optimiz,OptimizeConfigParameters,6988,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['Optimiz'],['OptimizeConfigParameters']
Performance,"urrent directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFrien",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:34854,cache,cache,34854,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,1,['cache'],['cache']
Performance,"urrent directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:35340,cache,cache,35340,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,1,['cache'],['cache']
Performance,"urrent directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:36586,cache,cache,36586,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,2,['cache'],['cache']
Performance,"urrent expression; TStringfInitialExp; TList*TSelector::fInputList of objects available during processing; TTreeFormulaManager*fManager; Int_tfMultiplicityIndicator of the variability of the size of entries; Bool_tfObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObject!Current object if processing object (vs. TTree); TStringTSelector::fOptionOption given to TTree::Process; TSelectorList*TSelector::fOutput!List of objects created during processing; TTreeFormula*fSelectPointer to selection formula; TStringfSelection; TStatus*fStatus; Long64_tTSelector::fStatusSelector status; TTree*fTree; TTreeDrawArgsParserfTreeDrawArgsParser; TTreeFormula*fVar[4]Pointer to variable formula; Double_tfWeightGlobal weight for fill actions; static TProofDraw::(anonymous)kWarn. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofDraw(); Constructor. ~TProofDraw(); Destructor. void Init(TTree* ); Init the tree. Bool_t Notify(); Called when a new tree is loaded. void Begin(TTree* ); Executed by the client before processing. void SlaveBegin(TTree* ); Executed by each slave before processing. void FillWeight(); Get weight from input list, if any. Bool_t ProcessSingle(Long64_t , Int_t ); Processes a single variable from an entry. Bool_t Process(Long64_t ); Executed for each entry. void SlaveTerminate(void); Executed by each slave after the processing has finished,; before returning the results to the client. void Terminate(void); Executed by the client after getting the processing retults. void ClearFormula(); Delete internal buffers. void SetCanvas(const char* objname); Move to a canvas named <name>_canvas; create the canvas if not existing.; Used to avoid screwing up existing plots when non default names are used; for the final objects. void SetDrawAtt(TObject* o); Set the drawing attributes from the input list. void SetError(const char* sub, const char* mesg); Sets the error status. Bool_t CompileVariables(); Compiles",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofDraw.html:8294,load,loaded,8294,root/html602/TProofDraw.html,https://root.cern,https://root.cern/root/html602/TProofDraw.html,2,['load'],['loaded']
Performance,"urrent geometry; - Current Directory in memory; - Current Directory on file. TObject * FindObjectAny(const char* name) const; Return a pointer to the first object with name starting at //root.; This function scans the list of all folders.; if no object found in folders, it scans the memory list of all files. TObject * FindObjectAnyFile(const char* name) const; Scan the memory lists of all files for an object with name. const char * FindObjectClassName(const char* name) const; Returns class name of a ROOT object including CINT globals. const char * FindObjectPathName(const TObject* obj) const; Return path name of obj somewhere in the //root/... path.; The function returns the first occurence of the object in the list; of folders. The returned string points to a static char array in TROOT.; If this function is called in a loop or recursively, it is the; user's responsability to copy this string in his area. TClass * FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; return a TClass object corresponding to 'name' assuming it is an STL container.; In particular we looking for possible alternative name (default template; parameter, typedefs template arguments, typedefed name). TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class with name. Obsolete, use TClass::GetClass directly. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TROOT.html:22800,load,load,22800,root/html530/TROOT.html,https://root.cern,https://root.cern/root/html530/TROOT.html,3,['load'],['load']
Performance,"urrent style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TGLScene;  TGLScene ();  ;  ~TGLScene () override;  Destroy scene objects. ;  ; virtual void AdoptLogical (TGLLogicalShape &shape);  Adopt dynamically created logical 'shape' - add to internal map and take responsibility for deleting. ;  ; virtual void AdoptPhysical (TGLPhysicalShape &shape);  Adopt dynamically created physical 'shape' - add to internal map and take responsibility for deleting. ;  ; UInt_t BeginSmartRefresh ();  Moves logicals that support smart-refresh to intermediate cache. ;  ; virtual Bool_t BeginUpdate ();  Put scene in update mode, return true if lock acquired. ;  ; void CalcBoundingBox () const override;  Encapsulates all physical shapes bounding box with axes aligned box. ;  ; TSceneInfo * CreateSceneInfo (TGLViewerBase *view) override;  Create a scene-info instance appropriate for this scene class. ;  ; virtual Bool_t DestroyLogical (TObject *logid, Bool_t mustFind=kTRUE);  Destroy logical shape defined by unique 'ID'. ;  ; virtual Int_t DestroyLogicals ();  Destroy all logical shapes in scene. ;  ; virtual Bool_t DestroyPhysical (UInt_t phid);  Destroy physical shape defined by unique 'ID'. ;  ; virtual Int_t DestroyPhysicals ();  Destroy physical shapes. ;  ; void DumpMapSizes () const;  Print sizes of logical and physical-shape maps. ;  ; void EndSmartRefresh ();  Wipes logicals in refresh-cache. ;  ; virtual void EndUpdate (Bool_t minorChange=kTRUE, Bool_t sceneChanged=kTRUE, Bool_t updateViewe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLScenePad.html:11467,cache,cache,11467,doc/master/classTGLScenePad.html,https://root.cern,https://root.cern/doc/master/classTGLScenePad.html,1,['cache'],['cache']
Performance,"urrentStreamerInfo()TClassinline; GetDataMember(const char *datamember) constTClass; GetDataMemberOffset(const char *membername) constTClass; GetDeclFileLine() constTClassinline; GetDeclFileName() constTClass; GetDeclIdMap()TClassprivatestatic; GetDelete() constTClass; GetDeleteArray() constTClass; GetDestructor() constTClass; GetDict(const char *cname)TClassstatic; GetDict(const std::type_info &info)TClassstatic; GetDictionary(const char *name)TDictionarystatic; GetDictionary(const std::type_info &typeinfo)TDictionarystatic; GetDirectoryAutoAdd() constTClass; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetFunctionTemplate(const char *name)TClass; GetHeapInstanceCount() constTClassinline; GetIconName() constTObjectvirtual; GetIdMap()TClassprivatestatic; GetImplFileLine() constTClassinline; GetImplFileName() constTClassinline; GetInstanceCount() constTClassinline; GetIsAProxy() constTClass; GetLastReadInfo() constTClassinline; GetListOfAllPublicDataMembers(Bool_t load=kTRUE)TClass; GetListOfAllPublicMethods(Bool_t load=kTRUE)TClass; GetListOfBases()TClass; GetListOfDataMembers(Bool_t load=kTRUE)TClass; GetListOfEnums(Bool_t load=kTRUE)TClass; GetListOfFunctionTemplates(Bool_t load=kTRUE)TClass; GetListOfMethodOverloads(const char *name) constTClass; GetListOfMethods(Bool_t load=kTRUE)TClass; GetListOfRealData() constTClassinline; GetListOfUsingDataMembers(Bool_t load=kTRUE)TClass; GetMenuItems(TList *listitems)TClass; GetMenuList() constTClass; GetMerge() constTClass; GetMethod(const char *method, const char *params, Bool_t objectIsConst=kFALSE)TClass; GetMethodAllAny(const char *method)TClass; GetMethodAny(const char *method)TClass; GetMethodList()TClassprivate; GetMethodWithPrototype(const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)TClass; GetMissingDictionaries(THashTable &result, bool recurse=false)TClass; GetMissingDictionariesForBaseClasses(TCollection &result, TCollecti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass-members.html:9306,load,load,9306,doc/master/classTClass-members.html,https://root.cern,https://root.cern/doc/master/classTClass-members.html,1,['load'],['load']
Performance,"urrenttype==1)); 167 ndiff++;; 168 }; 169 if (ndiff>0){; 170 delete fgFFT;; 171 fgFFT = nullptr;; 172 }; 173 }; 174 }; 175 ; 176 Int_t sign = 0;; 177 if (opt.Contains(""C2CB"") || opt.Contains(""C2R"")); 178 sign = 1;; 179 if (opt.Contains(""C2CF"") || opt.Contains(""R2C"")); 180 sign = -1;; 181 ; 182 TVirtualFFT *fft = nullptr;; 183 if (opt.Contains(""K"") || !fgFFT) {; 184 ; 185 R__LOCKGUARD(gROOTMutex);; 186 ; 187 TPluginHandler *h;; 188 TString pluginname;; 189 if (fgDefault.Length()==0) fgDefault=""fftw"";; 190 if (strcmp(fgDefault.Data(),""fftw"")==0) {; 191 if (opt.Contains(""C2C"")) pluginname = ""fftwc2c"";; 192 if (opt.Contains(""C2R"")) pluginname = ""fftwc2r"";; 193 if (opt.Contains(""R2C"")) pluginname = ""fftwr2c"";; 194 if (opt.Contains(""HC"") || opt.Contains(""DHT"")) pluginname = ""fftwr2r"";; 195 if ((h=gROOT->GetPluginManager()->FindHandler(""TVirtualFFT"", pluginname))) {; 196 if (h->LoadPlugin()==-1) {; 197 ::Error(""TVirtualFFT::FFT"", ""handler not found"");; 198 return nullptr;; 199 }; 200 fft = (TVirtualFFT*)h->ExecPlugin(3, ndim, n, kFALSE);; 201 if (!fft) {; 202 ::Error(""TVirtualFFT::FFT"", ""plugin failed to create TVirtualFFT object"");; 203 return nullptr;; 204 }; 205 Int_t *kind = new Int_t[1];; 206 if (pluginname==""fftwr2r"") {; 207 if (opt.Contains(""R2HC"")) kind[0] = 10;; 208 if (opt.Contains(""HC2R"")) kind[0] = 11;; 209 if (opt.Contains(""DHT"")) kind[0] = 12;; 210 }; 211 fft->Init(flag, sign, kind);; 212 if (!opt.Contains(""K"")) {; 213 fgFFT = fft;; 214 }; 215 delete [] kind;; 216 return fft;; 217 }; 218 else {; 219 ::Error(""TVirtualFFT::FFT"", ""plugin not found"");; 220 return nullptr;; 221 }; 222 }; 223 } else {; 224 ; 225 R__LOCKGUARD(gROOTMutex);; 226 ; 227 //if the global transform already exists and just needs to be reinitialised; 228 //with different parameters; 229 if (fgFFT->GetSign()!=sign || !opt.Contains(fgFFT->GetTransformFlag()) || !opt.Contains(fgFFT->GetType())) {; 230 Int_t *kind = new Int_t[1];; 231 if (inputtype==1) {; 232 if (opt.Contains(""R2HC"")) kind[0] = 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:7606,Load,LoadPlugin,7606,doc/master/TVirtualFFT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html,1,['Load'],['LoadPlugin']
Performance,"ursing is actively harmful:; 5721 // NOTE: must not recurse to prevent this visitor from triggering loading from; 5722 // the external AST source (i.e. autoloading). This would be triggered right here,; 5723 // before autoloading is even set up, as rootmap file parsing happens before that.; 5724 // Even if autoloading is off and has no effect, triggering loading from external; 5725 // AST source resets the flag setHasExternalLexicalStorage(), hiding this specialization; 5726 // from subsequent autoloads!; 5727 return false;; 5728 }; 5729 private:; 5730 std::unordered_set<const NamespaceDecl*>& fNSSet;; 5731 };; 5732}; 5733 ; 5734////////////////////////////////////////////////////////////////////////////////; 5735/// Load map between class and library. If rootmapfile is specified a; 5736/// specific rootmap file can be added (typically used by ACLiC).; 5737/// In case of error -1 is returned, 0 otherwise.; 5738/// The interpreter uses this information to automatically load the shared; 5739/// library for a class (autoload mechanism), see the AutoLoad() methods below.; 5740 ; 5741Int_t TCling::LoadLibraryMap(const char* rootmapfile); 5742{; 5743 if (rootmapfile && *rootmapfile && !requiresRootMap(rootmapfile)); 5744 return 0;; 5745 ; 5746 R__LOCKGUARD(gInterpreterMutex);; 5747 ; 5748 // open the [system].rootmap files; 5749 if (!fMapfile) {; 5750 fMapfile = new TEnv();; 5751 fMapfile->IgnoreDuplicates(kTRUE);; 5752 fRootmapFiles = new TObjArray;; 5753 fRootmapFiles->SetOwner();; 5754 InitRootmapFile("".rootmap"");; 5755 }; 5756 ; 5757 // Prepare a list of all forward declarations for cling; 5758 // For some experiments it is easily as big as 500k characters. To be on the; 5759 // safe side, we go for 1M.; 5760 TUniqueString uniqueString(1048576);; 5761 ; 5762 // Load all rootmap files in the dynamic load path ((DY)LD_LIBRARY_PATH, etc.).; 5763 // A rootmap file must end with the string "".rootmap"".; 5764 TString ldpath = gSystem->GetDynamicPath();; 5765 if (ldpath != fRo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:223705,load,load,223705,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['load']
Performance,"ursor ();  Flash the insertion cursor. ;  ; void FormBlocks ();  Add additional blocks to the block list in order to cover all elements on the element list. ;  ; int FormCount (TGHtmlInput *p, int radio);  Return the number of elments of type p in a form. ;  ; void FreeColor (ColorStruct_t *color);  Free system color. ;  ; GContext_t GetAnyGC ();  Retrieve any valid GC. ;  ; int GetColorByName (const char *zColor);  This routine returns an index between 0 and N_COLOR-1 which indicates which ColorStruct_t structure in the fApColor[] array should be used to describe the color specified by the given name. ;  ; int GetColorByValue (ColorStruct_t *pRef);  Find a color integer for the color whose color components are given by pRef. ;  ; SHtmlStyle_t GetCurrentStyle ();  Get the current rendering style. ;  ; int GetDarkShadowColor (int iBgColor);  Given that the background color is iBgColor, figure out an appropriate color for the dark part of a 3D shadow. ;  ; GContext_t GetGC (int color, int font);  Return a GC from the cache. ;  ; int GetImageAlignment (TGHtmlElement *p);  Find the alignment for an image. ;  ; int GetImageAt (int x, int y);  This routine searchs for an image beneath the coordinates x,y and returns the token number of the image, or -1 if no image found. ;  ; int GetIndex (const char *zIndex, TGHtmlElement **ppToken, int *pIndex);  This routine decodes a complete index specification. ;  ; int GetLightShadowColor (int iBgColor);  Given that the background color is iBgColor, figure out an appropriate color for the bright part of the 3D shadow. ;  ; int GetLinkColor (const char *zURL);  For the markup <a href=XXX>, find out if the URL has been visited before or not. ;  ; SHtmlTokenMap_t * GetMarkupMap (int n);  Returns token map at location n. ;  ; const char * GetPctWidth (TGHtmlElement *p, char *opt, char *ret);  Return the height and width, converting to percent if required ret must be at least 16 characters long. ;  ; const char * GetUid (const char *str",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtml.html:32007,cache,cache,32007,doc/master/classTGHtml.html,https://root.cern,https://root.cern/doc/master/classTGHtml.html,1,['cache'],['cache']
Performance,us)TFile::kStartBigFile; static TFile::EFileTypeTFile::kWeb; static TObject::(anonymous)TObject::kWriteDelete; static TFile::EStatusBitsTFile::kWriteError; static TObject::(anonymous)TObject::kZombie. protected:. TArchiveFile*TFile::fArchive!Archive file from which we read this file; Long64_tTFile::fArchiveOffset!Offset at which file starts in archive; TFileOpenHandle*TFile::fAsyncHandle!For proper automatic cleanup; TFile::EAsyncOpenStatusTFile::fAsyncOpenStatus!Status of an asynchronous open request; Long64_tTFile::fBEGINFirst used byte in file; TStringfBasicUrlbasic url without authentication and options; TStringfBasicUrlOrgsave original url in case of temp redirection; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tTFile::fBytesReadNumber of bytes read from this file; Long64_tTFile::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TMap*TFile::fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; Bool_tfHTTP11true if server support HTTP/1.1; Bool_tfHasModRoottrue if server has mod_root installed; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArc,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TWebFile.html:20171,cache,cache,20171,root/html602/TWebFile.html,https://root.cern,https://root.cern/root/html602/TWebFile.html,6,['cache'],['cache']
Performance,"us)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. static TStringfgDefaultdefault transformer; static TVirtualFFT*fgFFTcurrent transformer. Class Charts. Inheritance Chart:. TObject. ←; TVirtualFFT. ←. TFFTComplex. TFFTComplexReal. TFFTReal. TFFTRealComplex. Function documentation; ~TVirtualFFT(); destructor. TVirtualFFT* FFT(Int_t ndim, Int_t* n, Option_t* option); Returns a pointer to the FFT of requested size and type.; Parameters:; -ndim : number of transform dimensions; -n : sizes of each dimension (an array at least ndim long); -option : consists of 3 parts - flag option and an option to create a new TVirtualFFT; 1) transform type option:; Available transform types are:; C2CForward, C2CBackward, C2R, R2C, R2HC, HC2R, DHT; see class description for details; 2) flag option: choosing how much time should be spent in planning the transform:; Possible options:; ""ES"" (from ""estimate"") - no time in preparing the transform,; but probably sub-optimal performance; ""M"" (from ""measure"") - some time spend in finding the optimal way; to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way; to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the; same size and type are going to be done.; Planning is only done once, for the first transform of this size and type.; 3) option allowing to choose between the global fgFFT and a new TVirtualFFT object; """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT,; creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; Examples of valid options: ""R2C ES K"", ""C2CF M"", ""DHT P K"", etc. TVirtualFFT* SineCosine(Int_t ndim, Int_t* n, Int_t* r2rkind, Option_t* option); Returns a pointer to a sine or cosine transfor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualFFT.html:10904,perform,performance,10904,root/html602/TVirtualFFT.html,https://root.cern,https://root.cern/root/html602/TVirtualFFT.html,2,['perform'],['performance']
Performance,"us)TObject::kSingleKey; static TCondor::EStatekSuspended; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TList*fClaimslist of claims we manage; TStringfPoolthe condor pool to be accessed; TCondor::EStatefStateour claim state; Bool_tfValidaccess to Condor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondor(const char* pool = """"); Create Condor interface object. Uses Condor apps since there is no; API yet. ~TCondor(); Cleanup Condor interface. void Print(Option_t* option = """") const; Print master status. TCondorSlave * ClaimVM(const char* vm, const char* cmd); Claim a VirtualMachine for PROOF usage. TList * GetVirtualMachines() const; Get the names of the virtual machines in the pool.; Return a TList of TObjString or 0 in case of failure. TList * Claim(Int_t n, const char* cmd); Claim n virtual machines; This function figures out the image and performance index before returning; the list of condor slaves. TCondorSlave * Claim(const char* vmname, const char* cmd); Claim virtual machine with name vmname; This function does not figure out the image and performance index before; returning the condor slave. Bool_t SetState(TCondor::EState state); Set the state of workers. Bool_t Suspend(); Suspend worker. Bool_t Resume(); Resume worker. Bool_t Release(); Release worker. Bool_t GetVmInfo(const char* vm, TString& image, Int_t& perfidx) const; Get info about worker status. TString GetImage(const char* host) const; Get image of the worker. TCondor(const char* pool = """"). Bool_t IsValid() const; { return fValid; }. EState GetState() const; {return fState;}. » Author: Maarten Ballintijn 06/12/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-02 15:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TCondor.html:7263,perform,performance,7263,root/html604/TCondor.html,https://root.cern,https://root.cern/root/html604/TCondor.html,1,['perform'],['performance']
Performance,"us)TObject::kSingleKey; static TCondor::EStatekSuspended; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TList*fClaimslist of claims we manage; TStringfPoolthe condor pool to be accessed; TCondor::EStatefStateour claim state; Bool_tfValidaccess to Condor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondor(const char* pool = """"); Create Condor interface object. Uses Condor apps since there is no; API yet. ~TCondor(); Cleanup Condor interface. void Print(Option_t* option = """") const; Print master status. TCondorSlave * ClaimVM(const char* vm, const char* cmd); Claim a VirtualMachine for PROOF usage. TList * GetVirtualMachines() const; Get the names of the virtual machines in the pool.; Return a TList of TObjString or 0 in case of failure. TList * Claim(Int_t n, const char* cmd); Claim n virtual machines; This function figures out the image and performance index before returning; the list of condor slaves. TCondorSlave * Claim(const char* vmname, const char* cmd); Claim virtual machine with name vmname; This function does not figure out the image and performance index before; returning the condor slave. Bool_t SetState(TCondor::EState state); Set the state of workers. Bool_t Suspend(); Suspend worker. Bool_t Resume(); Resume worker. Bool_t Release(); Release worker. Bool_t GetVmInfo(const char* vm, TString& image, Int_t& perfidx) const; Get info about worker status. TString GetImage(const char* host) const; Get image of the worker. TCondor(const char* pool = """"). Bool_t IsValid() const; { return fValid; }. EState GetState() const; {return fState;}. » Author: Maarten Ballintijn 06/12/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCondor.html:7263,perform,performance,7263,root/html602/TCondor.html,https://root.cern,https://root.cern/root/html602/TCondor.html,1,['perform'],['performance']
Performance,"us. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. Int_t AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. void AddClone(TTree* ); Add a cloned tree to our",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:37827,cache,cache,37827,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,1,['cache'],['cache']
Performance,"usBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. UInt_t_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendMode_extendModeExtended mode capabilities of p.d.f.; RooDataSet*_genData! Data being generated; Bool_t_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_t_nextProtoIndexNext prototype event to load according to LUT; TString_normRangeNormalization range of pdf; Int_t*_protoOrderLUT with traversal order of prototype data; RooArgSet_protoVarsPrototype observables; const RooDataSet*_prototypePointer to prototype dataset; RooArgSet*_theEventPointer to observable event being generated; Bool_t_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE); Constructor. ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. RooDataSet * generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); Generate the specified number of events with nEvents>0 and; and ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsGenContext.html:9076,load,load,9076,root/html602/RooAbsGenContext.html,https://root.cern,https://root.cern/root/html602/RooAbsGenContext.html,2,['load'],['load']
Performance,"usage of ForeachSlot(). Parallel execution of multiple RDataFrame event loops; A complex analysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other. On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage. ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently: ROOT::EnableImplicitMT();; ROOT::RDataFrame df1(""tree1"", ""f1.root"");; ROOT::RDataFrame df2(""tree2"", ""f2.root"");; auto histo1 = df1.Histo1D(""x"");; auto histo2 = df2.Histo1D(""y"");; ; // just accessing result pointers, the event loops of separate RDataFrames run one after the other; histo1->Draw(); // runs first multi-thread event loop; histo2->Draw(); // runs second multi-thread event loop; ; // alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; ROOT::RDF::RunGraphs({histo1, histo2});; histo1->Draw(); // results can then be used as usual; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66. Performance considerations; To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible. For instance, Filter(""x > 0"") requires just-in-time compilation of the corresponding C++ logic, while the equivalent Filter([](float x) { return x > 0.; }, {""x""}) does not. Similarly, Histo1D(""x"") requires just-in-time compilation after the type of x is retrieved from the dataset, while Histo1D<float>(""x"") does not; the latter spelling should be preferred for performance-critical applications.; Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame. See",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:48803,multi-thread,multi-thread,48803,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,8,"['concurren', 'multi-thread']","['concurrently', 'multi-thread']"
Performance,"use later the TClonesArray with split>0. For example,; there is a problem with the following scenario:; 1- A class Foo has a TClonesArray of Bar objects; 2- The Foo object is written with split=0 to Tree T1.; In this case the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:17719,optimiz,optimized,17719,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,4,['optimiz'],['optimized']
Performance,"use later the TClonesArray with split>0. For example,; there is a problem with the following scenario:; 1- A class Foo has a TClonesArray of Bar objects; 2- The Foo object is written with split=0 to Tree T1.; In this case the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete(). void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and creat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClonesArray.html:14226,optimiz,optimized,14226,root/html526/TClonesArray.html,https://root.cern,https://root.cern/root/html526/TClonesArray.html,1,['optimiz'],['optimized']
Performance,"use later the TClonesArray with split>0. For example,; there is a problem with the following scenario:; 1- A class Foo has a TClonesArray of Bar objects; 2- The Foo object is written with split=0 to Tree T1.; In this case the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClonesArray.html:16879,optimiz,optimized,16879,root/html528/TClonesArray.html,https://root.cern,https://root.cern/root/html528/TClonesArray.html,2,['optimiz'],['optimized']
Performance,"use shapeClients(); RooAbsArg::serverMIterator(): use servers(); RooAbsCollection::createIterator(): use begin(), end() and range-based for loops; RooAbsCollection::iterator(): same; RooAbsCollection::fwdIterator(): same; RooWorkspace::componentIterator(): use RooWorkspace::components() with range-based loop. Deprecation of legacy test statistics classes in public interface; Instantiating the following classes and even including their header files is deprecated, and the headers will be removed in ROOT 6.34:. RooAbsTestStatistic; RooAbsOptTestStatistic; RooNLLVar; RooChi2Var; RooXYChi2Var. Please use the higher-level functions RooAbsPdf::createNLL() and RooAbsPdf::createChi2() if you want to create objects that represent test statistics.; Change of RooParamHistFunc; The RooParamHistFunc didn’t take any observable RooRealVar as constructor argument. It assumes as observable the internal variables in the passed RooDataHist. This means it was in most contexts unusable, because the input can’t be changed, other than loading a different bin in the dataset.; Furthermore, there was actually a constructor that took a RooAbsArg x, but it was simply ignored.; To fix all these problems, the existing constructors were replaced by a new one that takes the observable explicitly.; Since the old constructors resulted in wrong computation graphs that caused trouble with the new CPU evaluation backend, they had to be removed without deprecation. Please adapt your code if necessary.; Renaming of some RooFit classes; The RooPower was renamed to RooPowerSum, and RooExpPoly was renamed to RooLegacyExpPoly.; This was a necessary change, because the names of these classes introduced in ROOT 6.28 collided with some classes in CMS combine, which were around already long before. Therefore, the classes had to be renamed to not cause any problems for CMS.; In the unlikeliy case where you should have used these new classes for analysis already, please adapt your code to the new names and re-creat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:13897,load,loading,13897,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['load'],['loading']
Performance,user knows exactly what branches they are going to use. For the moment it's just a call to FillBuffer() since that method will create the buffer lists from the specified branches. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2186 of file TTreeCache.cxx. ◆ Streamer(). void TTreeCache::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip. ◆ StreamerNVirtual(). void TTreeCache::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 175 of file TTreeCache.h. ◆ UpdateBranches(). void TTreeCache::UpdateBranches ; (; TTree * ; tree). virtual . Update pointer to current Tree and recompute pointers to the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2210 of file TTreeCache.cxx. Member Data Documentation. ◆ fAutoCreated. bool TTreeCache::fAutoCreated {false}. protected . ! true if cache was automatically created ; Definition at line 66 of file TTreeCache.h. ◆ fBranches. TObjArray* TTreeCache::fBranches {nullptr}. protected . ! List of branches to be stored in the cache ; Definition at line 51 of file TTreeCache.h. ◆ fBrNames. TList* TTreeCache::fBrNames {nullptr}. protected . ! list of branch names in the cache ; Definition at line 52 of file TTreeCache.h. ◆ fCurrentClusterStart. Long64_t TTreeCache::fCurrentClusterStart {-1}. protected . ! Start of the cluster(s) where the current content was picked out ; Definition at line 42 of file TTreeCache.h. ◆ fEnabled. bool TTreeCache::fEnabled {true}. protected . ! cache enabled for cached reading ; Definition at line 63 of file TTreeCache.h. ◆ fEntryCurrent. Long64_t TTreeCache::fEntryCurrent {-1}. protected . ! current lowest entry number in the cache ; Definition at line 40 of file TTreeCache.h. ◆ fEntryMax. Long64_t TTreeCache::fEntryMax {1}. protected . ! last entry in the cache ; Definition at line 39 of file TTreeCache.h. ◆ fEntryMin. Long64_t,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:51907,cache,cache,51907,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['cache'],['cache']
Performance,user knows exactly what branches they are going to use. For the moment it's just a call to FillBuffer() since that method will create the buffer lists from the specified branches. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2187 of file TTreeCache.cxx. ◆ Streamer(). void TTreeCache::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip. ◆ StreamerNVirtual(). void TTreeCache::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 175 of file TTreeCache.h. ◆ UpdateBranches(). void TTreeCache::UpdateBranches ; (; TTree * ; tree). virtual . Update pointer to current Tree and recompute pointers to the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2211 of file TTreeCache.cxx. Member Data Documentation. ◆ fAutoCreated. bool TTreeCache::fAutoCreated {false}. protected . ! true if cache was automatically created ; Definition at line 66 of file TTreeCache.h. ◆ fBranches. TObjArray* TTreeCache::fBranches {nullptr}. protected . ! List of branches to be stored in the cache ; Definition at line 51 of file TTreeCache.h. ◆ fBrNames. TList* TTreeCache::fBrNames {nullptr}. protected . ! list of branch names in the cache ; Definition at line 52 of file TTreeCache.h. ◆ fCurrentClusterStart. Long64_t TTreeCache::fCurrentClusterStart {-1}. protected . ! Start of the cluster(s) where the current content was picked out ; Definition at line 42 of file TTreeCache.h. ◆ fEnabled. bool TTreeCache::fEnabled {true}. protected . ! cache enabled for cached reading ; Definition at line 63 of file TTreeCache.h. ◆ fEntryCurrent. Long64_t TTreeCache::fEntryCurrent {-1}. protected . ! current lowest entry number in the cache ; Definition at line 40 of file TTreeCache.h. ◆ fEntryMax. Long64_t TTreeCache::fEntryMax {1}. protected . ! last entry in the cache ; Definition at line 39 of file TTreeCache.h. ◆ fEntryMin. Long64_t,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:51977,cache,cache,51977,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['cache'],['cache']
Performance,"uset amd isetRangeName If sterileIdx is not null, it is set to the index of the sterile slot in cacse such a slot is recycled. ;  ; RooAbsCacheElement * getObj (const RooArgSet *nset, Int_t *sterileIndex=nullptr, const TNamed *isetRangeName=nullptr);  Getter function without integration set. ;  ; RooAbsCacheElement * getObjByIndex (Int_t index) const;  Retrieve payload object by slot index. ;  ; Int_t lastIndex () const;  Return index of slot used in last get or set operation. ;  ; void reset ();  Clear the cache. ;  ; RooArgSet selectFromSet1 (RooArgSet const &argSet, int index) const;  Create RooArgSet containing the objects that are both in the cached set 1 with a given index and an input argSet. ;  ; RooArgSet selectFromSet2 (RooArgSet const &argSet, int index) const;  Create RooArgSet containing the objects that are both in the cached set 2 with a given index and an input argSet. ;  ; Int_t setObj (const RooArgSet *nset, const RooArgSet *iset, RooAbsCacheElement *obj, const TNamed *isetRangeName=nullptr);  Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. ;  ; Int_t setObj (const RooArgSet *nset, RooAbsCacheElement *obj, const TNamed *isetRangeName=nullptr);  Setter function without integration set. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void wireCache () override;  ;  Public Member Functions inherited from RooAbsCache;  RooAbsCache (const RooAbsCache &, RooAbsArg *owner=nullptr);  Copy constructor. Takes owner as argument and registers cache with owne. ;  ;  RooAbsCache (RooAbsArg *owner=nullptr);  Constructor. Takes owner as argument and register cache with owner. ;  ; virtual ~RooAbsCache ();  Destructor. Unregisters cache with owner. ;  ; void setOwner (RooAbsArg *owner);  Reset the owner, triggering the owner to register this cache in its list of caches. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:4261,cache,cache,4261,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,1,['cache'],['cache']
Performance,"ush () const;  ; void Paint (Option_t *option="""") override;  Paint all objects in the file. ;  ; void Print (Option_t *option="""") const override;  Print all objects in the file. ;  ; virtual Bool_t ReadBufferAsync (Long64_t offs, Int_t len);  ; virtual void ReadFree ();  Read the FREE linked list. ;  ; virtual TProcessID * ReadProcessID (UShort_t pidf);  The TProcessID with number pidf is read from this file. ;  ; virtual void ReadStreamerInfo ();  Read the list of StreamerInfo from this file. ;  ; virtual Int_t Recover ();  Attempt to recover file if not correctly closed. ;  ; virtual Int_t ReOpen (Option_t *mode);  Reopen a file with a different access mode. ;  ; virtual void Seek (Long64_t offset, ERelativeTo pos=kBeg);  Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. ;  ; virtual void SetCacheRead (TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect);  Set a pointer to the read cache. ;  ; virtual void SetCacheWrite (TFileCacheWrite *cache);  Set a pointer to the write cache. ;  ; virtual void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Used to specify the compression level and algorithm. ;  ; virtual void SetEND (Long64_t last);  ; virtual void SetOffset (Long64_t offset, ERelativeTo pos=kBeg);  Set position from where to start reading. ;  ; virtual void SetOption (Option_t *option="">"");  ; virtual void SetReadCalls (Int_t readcalls=0);  ; virtual void ShowStreamerInfo ();  Show the StreamerInfo of all classes written to this file. ;  ; Int_t Sizeof () const override;  Return the size in bytes of the file header. ;  ; void Streamer (TBuffer &) override",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheFile.html:8968,cache,cache,8968,doc/master/classTDCacheFile.html,https://root.cern,https://root.cern/doc/master/classTDCacheFile.html,2,['cache'],['cache']
Performance,"using the supplied; normalization set in 'normSetList' for each component. void factorizeProduct(const RooArgSet& normSet, const RooArgSet& intSet, RooLinkedList& termList, RooLinkedList& normList, RooLinkedList& impDepList, RooLinkedList& crossDepList, RooLinkedList& intList) const; Factorize product in irreducible terms for given choice of integration/normalization. void getPartIntList(const RooArgSet* nset, const RooArgSet* iset, RooArgList*& partList, RooLinkedList*& nsetList, Int_t& code, const char* isetRangeName = 0) const; Return list of (partial) integrals of product terms for integration; of p.d.f over observables iset while normalization over observables nset.; Also return list of normalization sets to be used to evaluate; each component in the list correctly. RooAbsReal* makeCondPdfRatioCorr(RooAbsReal& term, const RooArgSet& termNset, const RooArgSet& termImpSet, const char* normRange, const char* refRange) const; For single normalization ranges. void rearrangeProduct(RooProdPdf::CacheElem& ) const. RooAbsReal* specializeRatio(RooFormulaVar& input, const char* targetRangeName) const. RooAbsReal* specializeIntegral(RooAbsReal& orig, const char* targetRangeName) const. void groupProductTerms(RooLinkedList& groupedTerms, RooArgSet& outerIntDeps, const RooLinkedList& terms, const RooLinkedList& norms, const RooLinkedList& imps, const RooLinkedList& ints, const RooLinkedList& cross) const; Group product into terms that can be calculated independently. std::vector<RooAbsReal*> processProductTerm(const RooArgSet* nset, const RooArgSet* iset, const char* isetRangeName, const RooArgSet* term, const RooArgSet& termNSet, const RooArgSet& termISet, Bool_t& isOwned, Bool_t forceWrap = kFALSE) const; Calculate integrals of factorized product terms over observables iset while normalized; to observables in nset. const char* makeRGPPName(const char* pfx, const RooArgSet& term, const RooArgSet& iset, const RooArgSet& nset, const char* isetRangeName) const; Make an approp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProdPdf.html:50420,Cache,CacheElem,50420,root/html528/RooProdPdf.html,https://root.cern,https://root.cern/root/html528/RooProdPdf.html,4,['Cache'],['CacheElem']
Performance,"using the supplied; normalization set in 'normSetList' for each component. void factorizeProduct(const RooArgSet& normSet, const RooArgSet& intSet, RooLinkedList& termList, RooLinkedList& normList, RooLinkedList& impDepList, RooLinkedList& crossDepList, RooLinkedList& intList) const; Factorize product in irreducible terms for given choice of integration/normalization. void getPartIntList(const RooArgSet* nset, const RooArgSet* iset, pRooArgList& partList, pRooLinkedList& nsetList, Int_t& code, const char* isetRangeName = 0) const; Return list of (partial) integrals of product terms for integration; of p.d.f over observables iset while normalization over observables nset.; Also return list of normalization sets to be used to evaluate; each component in the list correctly. RooAbsReal* makeCondPdfRatioCorr(RooAbsReal& term, const RooArgSet& termNset, const RooArgSet& termImpSet, const char* normRange, const char* refRange) const; For single normalization ranges. void rearrangeProduct(RooProdPdf::CacheElem& ) const. RooAbsReal* specializeRatio(RooFormulaVar& input, const char* targetRangeName) const. RooAbsReal* specializeIntegral(RooAbsReal& orig, const char* targetRangeName) const. void groupProductTerms(RooLinkedList& groupedTerms, RooArgSet& outerIntDeps, const RooLinkedList& terms, const RooLinkedList& norms, const RooLinkedList& imps, const RooLinkedList& ints, const RooLinkedList& cross) const; Group product into terms that can be calculated independently. std::vector<RooAbsReal*> processProductTerm(const RooArgSet* nset, const RooArgSet* iset, const char* isetRangeName, const RooArgSet* term, const RooArgSet& termNSet, const RooArgSet& termISet, Bool_t& isOwned, Bool_t forceWrap = kFALSE) const; Calculate integrals of factorized product terms over observables iset while normalized; to observables in nset. const char* makeRGPPName(const char* pfx, const RooArgSet& term, const RooArgSet& iset, const RooArgSet& nset, const char* isetRangeName) const; Make an approp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProdPdf.html:55219,Cache,CacheElem,55219,root/html602/RooProdPdf.html,https://root.cern,https://root.cern/root/html602/RooProdPdf.html,2,['Cache'],['CacheElem']
Performance,"ust be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectively just maximize the; area. It is mandatory to have a normalization variable; which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");. 1, 2 and 3 Dimensional fits are supported.; See also TTree::Fit. Return status. The function return the status of the fit in the following form; fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via; mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1. void UpdateFormulaLeaves(); this function is called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. TTreePlayer(const TTreePlayer& ). TTreePlayer& operator=(const TTreePlayer& ). void TakeAction(Int_t nfill, Int_t& npoints, Int_t& action, TObject* obj, Option_t* option). void TakeEstimate(Int_t nfill, Int_t& npoints, Int_t action, TObject* obj, Option_t* option). Int_t GetDimension() const; {return fDimension;}. TH1 * GetHistogram() const; {return fHistogram;}. Int_t GetNfill() const; {return fSelector->GetNfill();}. const char * GetScanFileName() const; {return fScanFileName;}. TTreeFormula * GetSelect() const; {return fSelector->GetSelect();}. Long64_t GetSelectedRows() const; {return fSelectedRows;}. TSelector * GetSelector() const; {return fSelector;}. TSelector * GetSelectorFromFile() const; See TSelectorDraw::GetVar. {return fSelectorFromFile;}. TTreeFormula * GetVar(Int_t i) const; See ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreePlayer.html:32199,Load,LoadTree,32199,root/html530/TTreePlayer.html,https://root.cern,https://root.cern/root/html530/TTreePlayer.html,10,"['Load', 'load']","['LoadTree', 'loaded']"
Performance,"ust be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectively just maximize the; area. It is mandatory to have a normalization variable; which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");. 1, 2 and 3 Dimensional fits are supported.; See also TTree::Fit. Return status. The function return the status of the fit in the following form; fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via; mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1. void UpdateFormulaLeaves(); this function is called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. TTreePlayer(const TTreePlayer& ). TTreePlayer& operator=(const TTreePlayer& ). void TakeAction(Int_t nfill, Int_t& npoints, Int_t& action, TObject* obj, Option_t* option). void TakeEstimate(Int_t nfill, Int_t& npoints, Int_t action, TObject* obj, Option_t* option). Int_t GetDimension() const; {return fDimension;}. TH1 * GetHistogram() const; {return fHistogram;}. Int_t GetNfill() const; {return fSelector->GetNfill();}. const char * GetScanFileName() const; {return fScanFileName;}. TTreeFormula * GetSelect() const; {return fSelector->GetSelect();}. Long64_t GetSelectedRows() const; {return fSelectedRows;}. TSelector * GetSelector() const; {return fSelector;}. TSelector * GetSelectorFromFile() const; {return fSelectorFromFile;}. TTreeFormula * GetVar(Int_t i) const; {return fSelector->GetVar(i);}.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:58002,Load,LoadTree,58002,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,2,"['Load', 'load']","['LoadTree', 'loaded']"
Performance,"ust implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientMultiDim(); doubleDerivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IGradientMultiDimIGradientMultiDim(); ROOT::Math::IGradientMultiDimIGradientMultiDim(const ROOT::Math::IGradientMultiDim&); ROOT::Math::IGradientMultiDim&operator=(const ROOT::Math::IGradientMultiDim&). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IGradientMultiDim(); virual destructor. {}. void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double* x, unsigned int icoord = 0) const. Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IGradientMultiDim.html:2182,Optimiz,Optimized,2182,root/html602/ROOT__Math__IGradientMultiDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IGradientMultiDim.html,2,"['Optimiz', 'perform']","['Optimized', 'performances']"
Performance,"ust implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientMultiDim(); doubleDerivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IGradientMultiDimIGradientMultiDim(); ROOT::Math::IGradientMultiDimIGradientMultiDim(const ROOT::Math::IGradientMultiDim&); ROOT::Math::IGradientMultiDim&operator=(const ROOT::Math::IGradientMultiDim&). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IGradientMultiDim(); virual destructor. {}. void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double* x, unsigned int icoord = 0) const. Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__IGradientMultiDim.html:2182,Optimiz,Optimized,2182,root/html604/ROOT__Math__IGradientMultiDim.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__IGradientMultiDim.html,2,"['Optimiz', 'perform']","['Optimized', 'performances']"
Performance,"ust the name and the anchor,...Definition TEntryList.cxx:870; TEntryList::GetNvirtual Long64_t GetN() constDefinition TEntryList.h:78; TEventList<div class=""legacybox""><h2>Legacy Code</h2> TEventList is a legacy interface: there will be no bug fi...Definition TEventList.h:31; TEventList::GetEntryvirtual Long64_t GetEntry(Int_t index) constReturn value of entry at index in the list.Definition TEventList.cxx:227; TEventList::GetReapplyCutvirtual bool GetReapplyCut() constDefinition TEventList.h:57; TEventList::GetNvirtual Int_t GetN() constDefinition TEventList.h:56; TFileInfoClass describing a generic file including meta information.Definition TFileInfo.h:39; TFileInfo::GetCurrentUrlTUrl * GetCurrentUrl() constReturn the current url.Definition TFileInfo.cxx:249; TFileMergeInfoDefinition TFileMergeInfo.h:42; TFileStagerDefinition TFileStager.h:36; TFileStager::Matchesvirtual Bool_t Matches(const char *s)Definition TFileStager.h:46; TFileStager::Openstatic TFileStager * Open(const char *stager)Open a stager, after having loaded the relevant plug-in.Definition TFileStager.cxx:101; TFileStager::Locatevirtual Int_t Locate(const char *u, TString &f)Just check if the file exists locally.Definition TFileStager.cxx:146; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::SetCacheReadvirtual void SetCacheRead(TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect)Set a pointer to the read cache.Definition TFile.cxx:2365; TFile::GetCompressionSettingsInt_t GetCompressionSettings() constDefinition TFile.h:397; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TFriendElementA TFriendElement TF describes a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:135580,load,loaded,135580,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['load'],['loaded']
Performance,"ustClean(kTRUE),fForceStyle(kFALSE),; 611 fInterrupt(kFALSE),fEscape(kFALSE),fExecutingMacro(kFALSE),fEditorMode(0),; 612 fPrimitive(nullptr),fSelectPad(nullptr),fClasses(nullptr),fTypes(nullptr),fGlobals(nullptr),fGlobalFunctions(nullptr),; 613 fClosedObjects(nullptr),fFiles(nullptr),fMappedFiles(nullptr),fSockets(nullptr),fCanvases(nullptr),fStyles(nullptr),fFunctions(nullptr),; 614 fTasks(nullptr),fColors(nullptr),fGeometries(nullptr),fBrowsers(nullptr),fSpecials(nullptr),fCleanups(nullptr),; 615 fMessageHandlers(nullptr),fStreamerInfo(nullptr),fClassGenerators(nullptr),fSecContexts(nullptr),; 616 fProofs(nullptr),fClipboard(nullptr),fDataSets(nullptr),fUUIDs(nullptr),fRootFolder(nullptr),fBrowsables(nullptr),; 617 fPluginManager(nullptr); 618{; 619}; 620 ; 621////////////////////////////////////////////////////////////////////////////////; 622/// Initialize the ROOT system. The creation of the TROOT object initializes; 623/// the ROOT system. It must be the first ROOT related action that is; 624/// performed by a program. The TROOT object must be created on the stack; 625/// (can not be called via new since ""operator new"" is protected). The; 626/// TROOT object is either created as a global object (outside the main(); 627/// program), or it is one of the first objects created in main().; 628/// Make sure that the TROOT object stays in scope for as long as ROOT; 629/// related actions are performed. TROOT is a so called singleton so; 630/// only one instance of it can be created. The single TROOT object can; 631/// always be accessed via the global pointer gROOT.; 632/// The name and title arguments can be used to identify the running; 633/// application. The initfunc argument can contain an array of; 634/// function pointers (last element must be 0). These functions are; 635/// executed at the end of the constructor. This way one can easily; 636/// extend the ROOT system without adding permanent dependencies; 637/// (e.g. the graphics system is initialized via su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:24149,perform,performed,24149,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['perform'],['performed']
Performance,"ustom streamer (member function). ; Definition at line 2939 of file TClass.cxx. ◆ GetStreamerInfo(). TVirtualStreamerInfo * TClass::GetStreamerInfo ; (; Int_t ; version = 0, . Bool_t ; isTransient = kFALSE . ); const. returns a pointer to the TVirtualStreamerInfo object for version If the object does not exist, it is created ; Note: There are two special version numbers: - 0: Use the class version from the currently loaded class library.; - -1: Assume no class library loaded (emulated class).; Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4599 of file TClass.cxx. ◆ GetStreamerInfoAbstractEmulated(). TVirtualStreamerInfo * TClass::GetStreamerInfoAbstractEmulated ; (; Int_t ; version = 0); const. For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ; If the object does not exist, it is created; Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4709 of file TClass.cxx. ◆ GetStreamerInfoImpl(). TVirtualStreamerInfo * TClass::GetStreamerInfoImpl ; (; Int_t ; version, . Bool_t ; silent . ); const. private . Definition at line 4634 of file TClass.cxx. ◆ GetStreamerInfos(). const TObjArray * TClass::GetStreamerInfos ; (; ); const. inline . Definition at line 492 of file TClass.h. ◆ GetTypeInfo(). const std::type_info * TClass::GetTypeInfo ; (; ); const. inline . Definition at line 496",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:92334,load,loaded,92334,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['load'],['loaded']
Performance,"ustom streamer (member function). ; Definition at line 3006 of file TClass.cxx. ◆ GetStreamerInfo(). TVirtualStreamerInfo * TClass::GetStreamerInfo ; (; Int_t ; version = 0, . Bool_t ; isTransient = kFALSE . ); const. returns a pointer to the TVirtualStreamerInfo object for version If the object does not exist, it is created ; Note: There are two special version numbers: - 0: Use the class version from the currently loaded class library.; - -1: Assume no class library loaded (emulated class).; Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4666 of file TClass.cxx. ◆ GetStreamerInfoAbstractEmulated(). TVirtualStreamerInfo * TClass::GetStreamerInfoAbstractEmulated ; (; Int_t ; version = 0); const. For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ; If the object does not exist, it is created; Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4776 of file TClass.cxx. ◆ GetStreamerInfoImpl(). TVirtualStreamerInfo * TClass::GetStreamerInfoImpl ; (; Int_t ; version, . Bool_t ; silent . ); const. private . Definition at line 4701 of file TClass.cxx. ◆ GetStreamerInfos(). const TObjArray * TClass::GetStreamerInfos ; (; ); const. inline . Definition at line 492 of file TClass.h. ◆ GetTypeInfo(). const std::type_info * TClass::GetTypeInfo ; (; ); const. inline . Definition at line 496",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:92335,load,loaded,92335,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['load'],['loaded']
Performance,"ustomContextMenu.CExample showing how to add a function to the class context menu ;  customTH1Fmenu.CExample showing how to customize a context menu for a class ;  drag_and_drop.CThis tutorial illustrates how to use drag and drop within ROOT ;  exec3.CExample of using signal/slot in TCanvas/TPad to get feedback about processed events ;  exec_macro.CThis utility macro executes the macro ""macro"" given as first argument and save a capture in a png file ;  games.CThis macro runs three ""games"" that each nicely illustrate the graphics capabilities of ROOT ;  gtreeTableTest.CThis TableTest class is a simple example of how to use a TGTreeTable ;  guilabels.CThis macro gives an example of how to create different kind of labels and the possibility to enable/disable them ;  guitest.CTest program for ROOT native GUI classes Exactly like $ROOTSYS/test/guitest.cxx but using the new signal and slots communication mechanism ;  guitest_playback.CThis macro plays a recorded ROOT session showing how to perform various interactive GUI operations with the guitest.C macro While replaying the session, several temporary macros (guitest0xx.C) macros will be saved ;  guiWithCINT.CA simple example of entering CINT commands and having the CINT output in a ROOT GUI application window ;  iconAsXPMData.CA simple example of creating icon image from XPM data, included into the code ;  listBox.CThis macro gives an example of how to create a list box and how to set and use its multiple selection feature ;  mditest.CGUI MDI features ;  ntupleTableTest.CThis TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface ;  numberEntry.CThis macro gives an example of how to create a number entry and how to update a label according to the changed value of this number entry ;  QtFileDialog.CThis is a small ROOT macro to use Qt 3.3 class: QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileName ;  QtMultiFileDialog.CThis is a small ROOT macro to use Qt 3.3 cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:119113,perform,perform,119113,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,5,['perform'],['perform']
Performance,"ustomization we could also add to the .rootrc support for the; variables. Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include. Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib .... And also support for MakeSharedLibs() and MakeExe(). (the ... have to be replaced by the actual values and are here only to; shorten this comment). Int_t GetAclicProperties() const; Return the ACLiC properties field. See EAclicProperties for details; on the semantic of each bit. const char * GetBuildArch() const; Return the build architecture. const char * GetBuildCompiler() const; Return the build compiler. const char * GetBuildCompilerVersion() const; Return the build compiler version. const char * GetBuildNode() const; Return the build node name. const char * GetBuildDir() const; Return the path of the build directory. const char * GetFlagsDebug() const; Return the debug flags. const char * GetFlagsOpt() const; Return the optimization flags. const char * GetMakeSharedLib() const; Return the command line use to make a shared library.; See TSystem::CompileMacro for more details. const char * GetMakeExe() const; Return the command line use to make an executable.; See TSystem::CompileMacro for more details. const char * GetIncludePath(); Get the list of include path. const char * GetLinkedLibs() const; Return the list of library linked to this executable.; See TSystem::CompileMacro for more details. const char * GetLinkdefSuffix() const; Return the linkdef suffix chosen by the user for ACLiC.; See TSystem::CompileMacro for more details. const char * GetSoExt() const; Get the shared library extension. const char * GetObjExt() const; Get the object file extension. void SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); Set the location where ACLiC will create libraries and use as; a scratch area.; If isflast is flase, then the libraries are actually stored in; sub-directories of 'build_d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:42897,optimiz,optimization,42897,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,6,['optimiz'],['optimization']
Performance,"ustum cache - call Apply() after last modifcation, before using. TGLVector3 EyeDirection() const; Extract the camera eye direction (vector), running from EyePoint(); Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVertex3 FrustumCenter() const; Find the center of the camera frustum from intersection of planes; This method will work even with parallel left/right & top/bottom and; infinite eye point of ortho cameras; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap FrustumOverlap(const TGLBoundingBox& box) const; Calcaulte overlap (kInside, kOutside, kPartial) of box with camera; frustum; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap ViewportOverlap(const TGLBoundingBox& box) const; Calculate overlap (kInside, kOutside, kPartial) of box projection onto viewport; (as rect) against the viewport rect.; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLRect ViewportRect(const TGLBoundingBox& box, TGLBoundingBox::EFace face) const; Calculate viewport rectangle which just contains projection of single 'face'; of world frame bounding box 'box' onto the viewport. Note use other version; of ViewportRect() if you want whole 'box' contained. TGLRect ViewportRect(const TGLBoundingBox& box, const TGLBoundingBox::EFace* face = 0) const; Calculate viewport rectangle which just contains projection of; world frame bounding box 'box' onto the viewport. If face is; null the rect contains the whole bounding box (8 vertices/6; faces). If face is non-null it indicates a box face, and the; rect contains the single face (4 vertices). Note use other; version of ViewportRect() if you wish to just pass a static; EFace enum member (e.g. kFaceLowX). Note:; i) Rectangle is NOT clipped by viewport limits - so can result; in rect with corners outside viewport - negative etc; ii) TGLRect provides int (pixel based)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLCamera.html:8458,cache,cache,8458,root/html528/TGLCamera.html,https://root.cern,https://root.cern/root/html528/TGLCamera.html,3,['cache'],['cache']
Performance,"ut << std::endl;; sgn.Fill();; bkg.Fill();; ; if (n == 1) {; auto c1 = new TCanvas();; c1->Divide(ntime, 2);; for (int j = 0; j < ntime; ++j) {; c1->cd(j + 1);; v1[j]->Draw();; }; for (int j = 0; j < ntime; ++j) {; c1->cd(ntime + j + 1);; v2[j]->Draw();; }; gPad->Update();; }; }; if (n > 1) {; sgn.Write();; bkg.Write();; sgn.Print();; bkg.Print();; f.Close();; }; }; /// macro for performing a classification using a Recurrent Neural Network; /// @param nevts = 2000 Number of events used. (increase for better classification results); /// @param use_type; /// use_type = 0 use Simple RNN network; /// use_type = 1 use LSTM network; /// use_type = 2 use GRU; /// use_type = 3 build 3 different networks with RNN, LSTM and GRU; ; void TMVA_RNN_Classification(int nevts = 2000, int use_type = 1); {; ; const int ninput = 30;; const int ntime = 10;; const int batchSize = 100;; const int maxepochs = 20;; ; int nTotEvts = nevts; // total events to be generated for signal or background; ; bool useKeras = true;; ; ; bool useTMVA_RNN = true;; bool useTMVA_DNN = true;; bool useTMVA_BDT = false;; ; std::vector<std::string> rnn_types = {""RNN"", ""LSTM"", ""GRU""};; std::vector<bool> use_rnn_type = {1, 1, 1};; if (use_type >=0 && use_type < 3) {; use_rnn_type = {0,0,0};; use_rnn_type[use_type] = 1;; }; bool useGPU = true; // use GPU for TMVA if available; ; #ifndef R__HAS_TMVAGPU; useGPU = false;; #ifndef R__HAS_TMVACPU; Warning(""TMVA_RNN_Classification"", ""TMVA is not build with GPU or CPU multi-thread support. Cannot use TMVA Deep Learning for RNN"");; useTMVA_RNN = false;; #endif; #endif; ; ; TString archString = (useGPU) ? ""GPU"" : ""CPU"";; ; bool writeOutputFile = true;; ; ; ; const char *rnn_type = ""RNN"";; ; #ifdef R__HAS_PYMVA; TMVA::PyMethodBase::PyInitialize();; #else; useKeras = false;; #endif; ; #ifdef R__USE_IMT; int num_threads = 4; // use max 4 threads; // switch off MT in OpenBLAS to avoid conflict with tbb; gSystem->Setenv(""OMP_NUM_THREADS"", ""1"");; ; // do enable MT running; if (n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:60842,multi-thread,multi-thread,60842,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['multi-thread'],['multi-thread']
Performance,"ut file %s - exit"", inputFileName.Data());; return;; }; ; // --- Register the training and test trees; ; auto signalTree = inputFile->Get<TTree>(""sig_tree"");; auto backgroundTree = inputFile->Get<TTree>(""bkg_tree"");; ; if (!signalTree) {; Error(""TMVA_CNN_Classification"", ""Could not find signal tree in file '%s'"", inputFileName.Data());; return;; }; if (!backgroundTree) {; Error(""TMVA_CNN_Classification"", ""Could not find background tree in file '%s'"", inputFileName.Data());; return;; }; ; int nEventsSig = signalTree->GetEntries();; int nEventsBkg = backgroundTree->GetEntries();; ; // global event weights per tree (see below for setting event-wise weights); Double_t signalWeight = 1.0;; Double_t backgroundWeight = 1.0;; ; // You can add an arbitrary number of signal or background trees; loader.AddSignalTree(signalTree, signalWeight);; loader.AddBackgroundTree(backgroundTree, backgroundWeight);; ; /// add event variables (image); /// use new method (from ROOT 6.20 to add a variable array for all image data); loader.AddVariablesArray(""vars"", imgSize);; ; // Set individual event weights (the variables must exist in the original TTree); // for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; // for background: factory->SetBackgroundWeightExpression(""weight1*weight2"");; // loader.SetBackgroundWeightExpression( ""weight"" );; ; // Apply additional cuts on the signal and background samples (can be different); TCut mycuts = """"; // for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; TCut mycutb = """"; // for example: TCut mycutb = ""abs(var1)<0.5"";; ; // Tell the factory how to use the training and testing events; //; // If no numbers of events are given, half of the events in the tree are used; // for training, and the other half for testing:; // loader.PrepareTrainingAndTestTree( mycut, ""SplitMode=random:!V"" );; // It is possible also to specify the number of training and testing events,; // note we disable the computation of the correlation matrix of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:51956,load,loader,51956,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['load'],['loader']
Performance,"ut file cannot be downloaded - exit""); else:; # file exists; inputFile = TFile.Open(inputFileName); ; ; # --- Register the training and test trees; signalTree = inputFile.Get(""sig_tree""); backgroundTree = inputFile.Get(""bkg_tree""); signalTree.Print(); ; ## Declare DataLoader(s); ; # The next step is to declare the DataLoader class that deals with input variables; # Define the input variables that shall be used for the MVA training; # note that you may also use variable expressions, which can be parsed by TTree::Draw( ""expression"" )]; loader = TMVA.DataLoader(""dataset""); ; loader.AddVariable(""m_jj""); loader.AddVariable(""m_jjj""); loader.AddVariable(""m_lv""); loader.AddVariable(""m_jlv""); loader.AddVariable(""m_bb""); loader.AddVariable(""m_wbb""); loader.AddVariable(""m_wwbb""); ; # We set now the input data trees in the TMVA DataLoader class; # global event weights per tree (see below for setting event-wise weights); signalWeight = 1.0; backgroundWeight = 1.0; # You can add an arbitrary number of signal or background trees; loader.AddSignalTree(signalTree, signalWeight); loader.AddBackgroundTree(backgroundTree, backgroundWeight); ; # Set individual event weights (the variables must exist in the original TTree); # for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; # for background: factory->SetBackgroundWeightExpression(""weight1*weight2"");; # loader->SetBackgroundWeightExpression( ""weight"" );; ; ; # Apply additional cuts on the signal and background samples (can be different); mycuts = ROOT.TCut("""") # for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; mycutb = ROOT.TCut("""") # for example: TCut mycutb = ""abs(var1)<0.5"";; ; # Tell the factory how to use the training and testing events; #; # If no numbers of events are given, half of the events in the tree are used; # for training, and the other half for testing:; # loader->PrepareTrainingAndTestTree( mycut, ""SplitMode=random:!V"" );; # To also specify the number of testing events, use:; ; loader.Pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:59792,load,loader,59792,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['load'],['loader']
Performance,"ut function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderDerivation order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; ROOT::Math::RichardsonDerivator*_rd! Derivator ; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_xObservable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDerivative.html:32477,cache,cache,32477,root/html530/RooDerivative.html,https://root.cern,https://root.cern/root/html530/RooDerivative.html,1,['cache'],['cache']
Performance,"ut, UInt_t option); Check for the 'ls.txt' for 'group' and 'user' and fill the path for the; ls file in 'out'.; If 'dsname' is defined, open the file and extract the relevant line.; Return 0 on success, -1 on failure. TFileCollection * GetDataSet(const char* group, const char* user, const char* dsName, UInt_t option = 0, TMD5** checksum = 0). Returns the dataset <dsName> of user <user> in group <group> .; If checksum is non-zero, it will contain the pointer to a TMD5 sum object; with the checksum of the file, has to be deleted by the user.; If option has the bi kReadShort set, the shortobject is read, that does not; contain the list of files. This is much faster. Int_t CheckLocalCache(const char* group, const char* user, const char* dsName = ""ls"", UInt_t option = 0); Check if the local cache information for group, user, dsName is up-to-date; If not, make the relevant updates; Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. Int_t ClearCache(const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). Writes indicated dataset.; If option has the bit kFileMustExist set, the file must still exist,; otherwise the new dataset is not written (returns 3 in this case).; If checksum is non-zero the files current checksum is checked against it,; if it does not match the file is not written (the function returns 2 in this; case, if the file has disappeared it is also not written (i.e. checksum; implies the bit kFileMustExist set in option).; Returns != 0 for success, 0 for error. Int_t ChecksumDataSet(const char* path, const char* md5path, TString& checksum); Calculate the checksum of the indicated dataset at 'path' and save it to the; appropriate file 'md5path'. The MD5 string is returned in 'md5sum'.; Return 0 on success, -1 on error. Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSetManagerFile.html:16464,cache,cached,16464,root/html528/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html528/TDataSetManagerFile.html,6,['cache'],['cached']
Performance,"utFileLink = ""http://root.cern.ch/files/"" + inputFileName; ; ; if ROOT.gSystem.AccessPathName(inputFileName):; ROOT.Info(""TMVA_Higgs_Classification"", ""Download Higgs_data.root file""); TFile.SetCacheFileDir("".""); inputFile = TFile.Open(inputFileLink, ""CACHEREAD""); if inputFile is None:; raise FileNotFoundError(""Input file cannot be downloaded - exit""); else:; # file exists; inputFile = TFile.Open(inputFileName); ; ; # --- Register the training and test trees; signalTree = inputFile.Get(""sig_tree""); backgroundTree = inputFile.Get(""bkg_tree""); signalTree.Print(); ; ## Declare DataLoader(s); ; # The next step is to declare the DataLoader class that deals with input variables; # Define the input variables that shall be used for the MVA training; # note that you may also use variable expressions, which can be parsed by TTree::Draw( ""expression"" )]; loader = TMVA.DataLoader(""dataset""); ; loader.AddVariable(""m_jj""); loader.AddVariable(""m_jjj""); loader.AddVariable(""m_lv""); loader.AddVariable(""m_jlv""); loader.AddVariable(""m_bb""); loader.AddVariable(""m_wbb""); loader.AddVariable(""m_wwbb""); ; # We set now the input data trees in the TMVA DataLoader class; # global event weights per tree (see below for setting event-wise weights); signalWeight = 1.0; backgroundWeight = 1.0; # You can add an arbitrary number of signal or background trees; loader.AddSignalTree(signalTree, signalWeight); loader.AddBackgroundTree(backgroundTree, backgroundWeight); ; # Set individual event weights (the variables must exist in the original TTree); # for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; # for background: factory->SetBackgroundWeightExpression(""weight1*weight2"");; # loader->SetBackgroundWeightExpression( ""weight"" );; ; ; # Apply additional cuts on the signal and background samples (can be different); mycuts = ROOT.TCut("""") # for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; mycutb = ROOT.TCut("""") # for example: TCut mycutb = ""abs(var1)<0.5"";; ; # Tell the fac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:59454,load,loader,59454,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['load'],['loader']
Performance,"utG and TEntryList used in the formula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayTFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this formula.; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_t*fLookupType[fNindex] array indicating how each leaf should be looked-up; TTreeFormulaManager*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tfNcodesNumber of leaves referenced in formula; Int_tTFormula::fNconstNumber of constants; Int_tfNdata[500]! This caches the physical number of element in the leaf or datamember.; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNdimensions[500]Number of array dimensions in each leaf; Bool_tfNeedLoading! If true, the current entry has not been loaded yet.; Int_tfNindexSize of fIndex; Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncTFormula::fOptimal!pointer to optimal function; Double_t*TFormu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeFormula.html:16210,optimiz,optimization,16210,root/html528/TTreeFormula.html,https://root.cern,https://root.cern/root/html528/TTreeFormula.html,8,"['cache', 'optimiz']","['caches', 'optimization']"
Performance,"utG and TEntryList used in the formula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayTFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this formula.; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_t*fLookupType[fNindex] array indicating how each leaf should be looked-up; TTreeFormulaManager*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tfNcodesNumber of leaves referenced in formula; Int_tTFormula::fNconstNumber of constants; Int_tfNdata[500]! This caches the physical number of element in the leaf or datamember.; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNdimensions[500]Number of array dimensions in each leaf; Bool_tfNeedLoading! If true, the current entry has not been loaded yet.; Int_tfNindexSize of fIndex; Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); TFormula::TFuncGTFormula::fOptimal!pointer to optimal function; Double_t*TF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeFormula.html:16285,optimiz,optimization,16285,root/html602/TTreeFormula.html,https://root.cern,https://root.cern/root/html602/TTreeFormula.html,2,"['cache', 'optimiz']","['caches', 'optimization']"
Performance,"utHeight() == 1 && GetInputDepth() == 1) n1 = fNet->GetBatchSize();; 1297 //fXInput = TensorImpl_t(1,n1,n2);; 1298 fXInput = ArchitectureImpl_t::CreateTensor(fNet->GetBatchSize(), GetInputDepth(), GetInputHeight(), GetInputWidth() );; 1299 if (batchDepth == 1 && GetInputHeight() == 1 && GetInputDepth() == 1); 1300 fXInput = TensorImpl_t( fNet->GetBatchSize(), GetInputWidth() );; 1301 fXInputBuffer = HostBufferImpl_t( fXInput.GetSize() );; 1302 ; 1303 ; 1304 // create pointer to output matrix used for the predictions; 1305 fYHat = std::unique_ptr<MatrixImpl_t>(new MatrixImpl_t(fNet->GetBatchSize(), fNet->GetOutputWidth() ) );; 1306 ; 1307 // print the created network; 1308 Log() << ""***** Deep Learning Network *****"" << Endl;; 1309 if (Log().GetMinType() <= kINFO); 1310 deepNet.Print();; 1311 }; 1312 Log() << ""Using "" << nTrainingSamples << "" events for training and "" << nValidationSamples << "" for testing"" << Endl;; 1313 ; 1314 // Loading the training and validation datasets; 1315 TMVAInput_t trainingTuple = std::tie(eventCollectionTraining, DataInfo());; 1316 TensorDataLoader_t trainingData(trainingTuple, nTrainingSamples, batchSize,; 1317 {inputDepth, inputHeight, inputWidth},; 1318 {deepNet.GetBatchDepth(), deepNet.GetBatchHeight(), deepNet.GetBatchWidth()} ,; 1319 deepNet.GetOutputWidth(), nThreads);; 1320 ; 1321 TMVAInput_t validationTuple = std::tie(eventCollectionValidation, DataInfo());; 1322 TensorDataLoader_t validationData(validationTuple, nValidationSamples, batchSize,; 1323 {inputDepth, inputHeight, inputWidth},; 1324 { deepNet.GetBatchDepth(),deepNet.GetBatchHeight(), deepNet.GetBatchWidth()} ,; 1325 deepNet.GetOutputWidth(), nThreads);; 1326 ; 1327 ; 1328 ; 1329 // do an evaluation of the network to compute initial minimum test error; 1330 ; 1331 Bool_t includeRegularization = (R != DNN::ERegularization::kNone);; 1332 ; 1333 Double_t minValError = 0.0;; 1334 Log() << ""Compute initial loss on the validation data "" << Endl;; 1335 for (auto batch : valida",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:51625,Load,Loading,51625,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['Load'],['Loading']
Performance,"utMatrix, weightMatrix);; 1226 }; 1227 testError /= (Double_t) (nTestSamples / settings.batchSize);; 1228 ; 1229 //Log the loss value; 1230 fTrainHistory.AddValue(""testError"",stepCount,testError);; 1231 ; 1232 end = std::chrono::system_clock::now();; 1233 ; 1234 // Compute training error.; 1235 Double_t trainingError = 0.0;; 1236 for (auto batch : trainingData) {; 1237 auto inputMatrix = batch.GetInput();; 1238 auto outputMatrix = batch.GetOutput();; 1239 auto weightMatrix = batch.GetWeights();; 1240 trainingError += net.Loss(inputMatrix, outputMatrix, weightMatrix);; 1241 }; 1242 trainingError /= (Double_t) (nTrainingSamples / settings.batchSize);; 1243 ; 1244 //Log the loss value; 1245 fTrainHistory.AddValue(""trainingError"",stepCount,trainingError);; 1246 ; 1247 if (fInteractive){; 1248 fInteractive->AddPoint(stepCount, trainingError, testError);; 1249 fIPyCurrentIter = 100*(double)minimizer.GetConvergenceCount() /(double)settings.convergenceSteps;; 1250 if (fExitFromTraining) break;; 1251 }; 1252 ; 1253 // Compute numerical throughput.; 1254 std::chrono::duration<double> elapsed_seconds = end - start;; 1255 double seconds = elapsed_seconds.count();; 1256 double nFlops = (double) (settings.testInterval * batchesInEpoch);; 1257 nFlops *= net.GetNFlops() * 1e-9;; 1258 ; 1259 converged = minimizer.HasConverged(testError);; 1260 start = std::chrono::system_clock::now();; 1261 ; 1262 if (fInteractive) {; 1263 fInteractive->AddPoint(stepCount, trainingError, testError);; 1264 fIPyCurrentIter = 100.0 * minimizer.GetConvergenceCount(); 1265 / minimizer.GetConvergenceSteps ();; 1266 if (fExitFromTraining) break;; 1267 } else {; 1268 Log() << std::setw(10) << stepCount << "" | ""; 1269 << std::setw(12) << trainingError; 1270 << std::setw(12) << testError; 1271 << std::setw(12) << nFlops / seconds; 1272 << std::setw(12) << minimizer.GetConvergenceCount() << Endl;; 1273 if (converged) {; 1274 Log() << Endl;; 1275 }; 1276 }; 1277 }; 1278 }; 1279 ; 1280 ; 1281 for (size_t l = 0; l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:45174,throughput,throughput,45174,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['throughput'],['throughput']
Performance,"utRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; TMVA_SOFIE_GNN_Parser.treetreeDefinition TMVA_SOFIE_GNN_Parser.py:169; rf401_importttreethxDefinition rf401_importttreethx.py:1; ; RooDataHist::dh[c,x] = 300 bins (2964 weights); RooDataHist::dh[c,x] = 300 bins (2964 weights); [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 35 out-of-range events; RooDataSet::ds[x,y] = 65 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds2) Ignored 36 out-of-range events; RooDataSet::ds2[x,y,z] = 26 entries; [#1] INFO:DataHan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf401__importttreethx_8C.html:7370,load,loadValues,7370,doc/master/rf401__importttreethx_8C.html,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8C.html,1,['load'],['loadValues']
Performance,"utation graph for all histograms at once now,; 202# by calling 'histos_mc[""nominal""].GetXaxis()'.; 203# Note, in this case the uncertainties are symmetric.; 204for i in range(0, histos_mc[""nominal""].GetXaxis().GetNbins()):; 205 (; 206 histos_mc[""nominal""].SetBinError(; 207 i, (histos_mc[""weight:up""].GetBinContent(i) - histos_mc[""nominal""].GetBinContent(i)); 208 ); 209 ); 210 ; 211# Make the plot of the data, individual MC contributions and the total MC scale factor systematic variations.; 212 ; 213# Set styles; 214ROOT.gROOT.SetStyle(""ATLAS""); 215 ; 216# Create canvas with pad; 217c1 = ROOT.TCanvas(""c"", """", 600, 600); 218pad = ROOT.TPad(""upper_pad"", """", 0, 0, 1, 1); 219pad.SetTickx(False); 220pad.SetTicky(False); 221pad.Draw(); 222pad.cd(); 223 ; 224# Draw stack with MC contributions; 225stack = ROOT.THStack(); 226 ; 227# Retrieve values of the data and MC histograms in order to plot them.; 228# Draw cloned histograms to preserve graphics when original objects goes out of scope; 229# Note: GetValue() action operation is performed after all lazy actions of the RDF were defined first.; 230h_data = histos[0].GetValue().Clone(); 231h_higgs = histos[1].GetValue().Clone(); 232h_zz = histos[2].GetValue().Clone(); 233h_other = histos[3].GetValue().Clone(); 234 ; 235for h, color in zip([h_other, h_zz, h_higgs], [ROOT.kViolet - 9, ROOT.kAzure - 9, ROOT.kRed + 2]):; 236 h.SetLineWidth(1); 237 h.SetLineColor(1); 238 h.SetFillColor(color); 239 stack.Add(h); 240 ; 241stack.Draw(""HIST""); 242stack.GetXaxis().SetLabelSize(0.04); 243stack.GetXaxis().SetTitleSize(0.045); 244stack.GetXaxis().SetTitleOffset(1.3); 245stack.GetXaxis().SetTitle(""m_{4l}^{H#rightarrow ZZ} [GeV]""); 246stack.GetYaxis().SetLabelSize(0.04); 247stack.GetYaxis().SetTitleSize(0.045); 248stack.GetYaxis().SetTitle(""Events""); 249stack.SetMaximum(35); 250stack.GetYaxis().ChangeLabel(1, -1, 0); 251 ; 252# Draw MC scale factor and variations; 253histos_mc[""nominal""].SetFillColor(ROOT.kBlack); 254histos_mc[""nominal""].SetFi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:10342,perform,performed,10342,doc/master/df106__HiggsToFourLeptons_8py_source.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html,1,['perform'],['performed']
Performance,"ute MINUIT commands. ; MINImize, SIMplex, MIGrad and FUMili all will call TFumili::Minimize method.; For full command list see MINUIT. Reference Manual. CERN Program Library Long Writeup D506.; Improvement and errors calculation are not yet implemented as well as Monte-Carlo seeking and minimization. Contour commands are also unsupported. command : command string; args : array of arguments; nargs : number of arguments . Implements TVirtualFitter.; Definition at line 391 of file TFumili.cxx. ◆ ExecuteSetCommand(). Int_t TFumili::ExecuteSetCommand ; (; Int_t ; nargs). Called from TFumili::ExecuteCommand in case of ""SET xxx"" and ""SHOW xxx"". ; Definition at line 558 of file TFumili.cxx. ◆ FitChisquare(). void TFumili::FitChisquare ; (; Int_t & ; npar, . Double_t * ; gin, . Double_t & ; f, . Double_t * ; u, . Int_t ; flag . ). virtual . Minimization function for H1s using a Chisquare method. ; Default method (function evaluated at center of bin) for each point the cache contains the following info; 1D : bc,e,xc (bin content, error, x of center of bin); 2D : bc,e,xc,yc; 3D : bc,e,xc,yc,zc . Definition at line 1738 of file TFumili.cxx. ◆ FitChisquareI(). void TFumili::FitChisquareI ; (; Int_t & ; npar, . Double_t * ; gin, . Double_t & ; f, . Double_t * ; u, . Int_t ; flag . ). virtual . Minimization function for H1s using a Chisquare method. ; The ""I""ntegral method is used for each point the cache contains the following info; 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 2D : bc,e,xc,xw,yc,yw; 3D : bc,e,xc,xw,yc,yw,zc,zw . Definition at line 1809 of file TFumili.cxx. ◆ FitLikelihood(). void TFumili::FitLikelihood ; (; Int_t & ; npar, . Double_t * ; gin, . Double_t & ; f, . Double_t * ; u, . Int_t ; flag . ). virtual . Minimization function for H1s using a Likelihood method. ; Basically, it forms the likelihood by determining the Poisson probability that given a number of entries in a particular bin, the fit would predict it's value. This is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFumili.html:29930,cache,cache,29930,doc/master/classTFumili.html,https://root.cern,https://root.cern/doc/master/classTFumili.html,1,['cache'],['cache']
Performance,"ute the complementarity gap resulting from a step of length ""alpha"" along; direction ""step"". void Saxpy(TQpVar* b, Double_t alpha); Perform a ""saxpy"" operation on all data vectors : x += alpha*y. void Negate(); Perform a ""negate"" operation on all data vectors : x = -x. Double_t StepBound(TQpVar* b); calculate the largest alpha in (0,1] such that the/ nonnegative variables stay; nonnegative in the given search direction. In the general QP problem formulation; this is the largest value of alpha such that; (t,u,v,w,lambda,pi,phi,gamma) + alpha * (b->t,b->u,b->v,b->w,b->lambda,b->pi,; b->phi,b->gamma) >= 0. Double_t StepBound(TVectorD& v, TVectorD& dir, Double_t maxStep); Find the maximum stepsize of v in direction dir; before violating the nonnegativity constraints. Bool_t IsInteriorPoint(); Is the current position an interior point ?. Double_t FindBlocking(TQpVar* step, Double_t& primalValue, Double_t& primalStep, Double_t& dualValue, Double_t& dualStep, Int_t& firstOrSecond); Performs the same function as StepBound, and supplies additional information about; which component of the nonnegative variables is responsible for restricting alpha.; In terms of the abstract formulation, the components have the following meanings :. primalValue : the value of the blocking component of the primal variables (u,t,v,w).; primalStep : the corresponding value of the blocking component of the primal step; variables (b->u,b->t,b->v,b->w); dualValue : the value of the blocking component of the dual variables; (lambda,pi,phi,gamma).; dualStep : the corresponding value of the blocking component of the dual step; variables (b->lambda,b->pi,b->phi,b->gamma); firstOrSecond : 1 if the primal step is blocking,; 2 if the dual step is block,; 0 if no step is blocking. Double_t FindBlocking(TVectorD& w, TVectorD& wstep, TVectorD& u, TVectorD& ustep, Double_t maxStep, Double_t& w_elt, Double_t& wstep_elt, Double_t& u_elt, Double_t& ustep_elt, int& first_or_second); See other FindBlocking function",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQpVar.html:8984,Perform,Performs,8984,root/html528/TQpVar.html,https://root.cern,https://root.cern/root/html528/TQpVar.html,6,['Perform'],['Performs']
Performance,"uteMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Bool_t IsErrorMessagesEnabled() const. Bool_t SetErrorMessages(Bool_t enable = kTRUE). Bool_t IsProcessLineLocked() const. void SetProcessLineLock(Bool_t lock = kTRUE). const char * TypeName(const char* s). int DisplayClass(FILE* , const char* , int , int ) const; All the functions below must be virtual with a dummy implementation; These functions are redefined in TCling.; The dummy implementation avoids an implementation in TGWin32InterpreterProxy; Misc. {return 0;}. int DisplayIncludePath(FILE* ) const; {return 0;}. void * FindSym(const char* ) const; {return 0;}. void GenericError(const char* ) const; {;}. Long_t GetExecByteCode() const; {return 0;}. Long_t Getgvp() const; {return 0;}. const char * Getp2f2funcname(void* ) const; {return 0;}. const char * GetTopLevelMacroName() const; {return 0;}. const char * GetCurrentMacroName() const; {return 0;}. int GetSecurityError() const; {return 0;}. int LoadFile(const char* ) const; {return 0;}. Bool_t LoadText(const char* ) const; {return kFALSE;}. const char * MapCppName(const char* ) const; {return 0;}. void SetAlloclockfunc(void(*)() ) const; {;}. void SetAllocunlockfunc(void(*)() ) const; {;}. int SetClassAutoloading(int ) const; {return 0;}. int SetClassAutoparsing(int ); {return 0;}. void SetErrmsgcallback(void* ) const; {;}. void Setgvp(Long_t ) const; {;}. void SetRTLD_NOW() const; {;}. void SetRTLD_LAZY() const; {;}. void SetTempLevel(int ) const; {;}. int UnloadFile(const char* ) const; {return 0;}. TInterpreterValue * CreateTemporary(); { return 0; }. EReturnType MethodCallReturnType(TFunction* func) const; core/meta helper functions. ULong64_t GetInterpreterStateMarker() const. DeclId_t GetDeclId(CallFunc_t* info) const. DeclId_t GetDeclId(ClassInfo_t* info) const. DeclId_t GetDeclId(DataMemberInfo_t* info) const. DeclId_t GetDeclId(FuncTempInfo_t* info) const. DeclId_t GetDeclId(MethodInfo_t* info) const. DeclId_t GetDeclId(TypedefInfo_t* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TInterpreter.html:30752,Load,LoadFile,30752,root/html602/TInterpreter.html,https://root.cern,https://root.cern/root/html602/TInterpreter.html,2,['Load'],['LoadFile']
Performance,"uteTextLayout() stores contiguous ranges of ""normal""; characters in a chunk, along with individual tab and newline chars in; their own chunks. All characters in the text layout are accounted for. void DrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Draw a string of characters on the screen. DrawCharsExp() expands; control characters that occur in the string to \X or \xXX sequences.; DrawChars() just draws the strings. dst -- Window or pixmap in which to draw.; gc -- Graphics context for drawing characters.; source -- Characters to be displayed. Need not be'\0' terminated.; For DrawChars(), all meta-characters (tabs, control; characters, and newlines) should be stripped out of the; string that is passed to this function. If they are not; stripped out, they will be displayed as regular printing; characters.; numChars -- Number of characters in string.; x, y -- Coordinates at which to place origin of string when drawing. void DrawChars(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Perform a quick sanity check to ensure we won't overflow the X; coordinate space. void SavePrimitive(ostream& out, Option_t* = """"); Save the used font as a C++ statement(s) on output stream out. FontAttributes_t& operator=(const TGFont& font). TGFont(const char* name); (used for simulating a native underlined or strikeout font). TGFont(const TGFont& font). FontH_t GetFontHandle() const; { return fFontH; }. FontStruct_t GetFontStruct() const; { return fFontStruct; }. FontAttributes_t GetFontAttributes() const; { return fFA; }. Int_t TextHeight() const; { return fFM.fLinespace; }. » Author: Fons Rademakers 20/5/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 15:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGFont.html:14904,Perform,Perform,14904,root/html604/TGFont.html,https://root.cern,https://root.cern/root/html604/TGFont.html,1,['Perform'],['Perform']
Performance,"uteTextLayout() stores contiguous ranges of ""normal""; characters in a chunk, along with individual tab and newline chars in; their own chunks. All characters in the text layout are accounted for. void DrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Draw a string of characters on the screen. DrawCharsExp() expands; control characters that occur in the string to \X or \xXX sequences.; DrawChars() just draws the strings. dst -- Window or pixmap in which to draw.; gc -- Graphics context for drawing characters.; source -- Characters to be displayed. Need not be'\0' terminated.; For DrawChars(), all meta-characters (tabs, control; characters, and newlines) should be stripped out of the; string that is passed to this function. If they are not; stripped out, they will be displayed as regular printing; characters.; numChars -- Number of characters in string.; x, y -- Coordinates at which to place origin of string when drawing. void DrawChars(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Perform a quick sanity check to ensure we won't overflow the X; coordinate space. void SavePrimitive(ostream& out, Option_t* = """"); Save the used font as a C++ statement(s) on output stream out. FontAttributes_t& operator=(const TGFont& font). TGFont(const char* name); (used for simulating a native underlined or strikeout font). TGFont(const TGFont& font). FontH_t GetFontHandle() const; { return fFontH; }. FontStruct_t GetFontStruct() const; { return fFontStruct; }. FontAttributes_t GetFontAttributes() const; { return fFA; }. Int_t TextHeight() const; { return fFM.fLinespace; }. » Author: Fons Rademakers 20/5/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-05 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGFont.html:14439,Perform,Perform,14439,root/html534/TGFont.html,https://root.cern,https://root.cern/root/html534/TGFont.html,1,['Perform'],['Perform']
Performance,"uteTextLayout() stores contiguous ranges of ""normal""; characters in a chunk, along with individual tab and newline chars in; their own chunks. All characters in the text layout are accounted for. void DrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Draw a string of characters on the screen. DrawCharsExp() expands; control characters that occur in the string to \X or \xXX sequences.; DrawChars() just draws the strings. dst -- Window or pixmap in which to draw.; gc -- Graphics context for drawing characters.; source -- Characters to be displayed. Need not be'\0' terminated.; For DrawChars(), all meta-characters (tabs, control; characters, and newlines) should be stripped out of the; string that is passed to this function. If they are not; stripped out, they will be displayed as regular printing; characters.; numChars -- Number of characters in string.; x, y -- Coordinates at which to place origin of string when drawing. void DrawChars(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Perform a quick sanity check to ensure we won't overflow the X; coordinate space. void SavePrimitive(ostream& out, Option_t* = """"); Save the used font as a C++ statement(s) on output stream out. FontAttributes_t& operator=(const TGFont& font). TGFont(const char* name); (used for simulating a native underlined or strikeout font). TGFont(const TGFont& font). FontH_t GetFontHandle() const; { return fFontH; }. FontStruct_t GetFontStruct() const; { return fFontStruct; }. FontAttributes_t GetFontAttributes() const; { return fFA; }. Int_t TextHeight() const; { return fFM.fLinespace; }. » Author: Fons Rademakers 20/5/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:51; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGFont.html:14904,Perform,Perform,14904,root/html602/TGFont.html,https://root.cern,https://root.cern/root/html602/TGFont.html,1,['Perform'],['Perform']
Performance,"uted after the event loop is finished; 294 /// \endcode; 295 ///; 296 /// A value of 0 for everyNEvents indicates the callback must be executed only once, before running the event loop.; 297 /// A conveniece definition `kOnce` is provided to make this fact more expressive in user code (see snippet below).; 298 /// Multiple callbacks can be registered with the same RResultPtr (i.e. results of RDataFrame actions) and will; 299 /// be executed sequentially. Callbacks are executed in the order they were registered.; 300 /// The type of the value contained in a RResultPtr is also available as RResultPtr<T>::Value_t, e.g.; 301 /// \code{.cpp}; 302 /// auto h = tdf.Histo1D(""x"");; 303 /// // h.kOnce is 0; 304 /// // decltype(h)::Value_t is TH1D; 305 /// \endcode; 306 ///; 307 /// When implicit multi-threading is enabled, the callback:; 308 /// - will never be executed by multiple threads concurrently: it needs not be thread-safe. For example the snippet; 309 /// above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; 310 /// - will always be executed ""everyNEvents"": partial results will ""contain"" that number of events more from; 311 /// one call to the next; 312 /// - might be executed by a different worker thread at different times: the value of `std::this_thread::get_id()`; 313 /// might change between calls; 314 ///; 315 /// To register a callback that is called by _each_ worker thread (concurrently) every N events one can use; 316 /// OnPartialResultSlot().; 317 // clang-format on; 318 RResultPtr<T> &OnPartialResult(ULong64_t everyNEvents, std::function<void(T &)> callback); 319 {; 320 ThrowIfNull();; 321 const auto nSlots = fLoopManager->GetNSlots();; 322 auto actionPtr = fActionPtr;; 323 auto c = [nSlots, actionPtr, callback](unsigned int slot) {; 324 if (slot != nSlots - 1); 325 return;; 326 auto partialResult = static_cast<Value_t *>(actionPtr->PartialUpdate(slot));; 327 callback(*partialResult);; 328 };; 329 fLoopManager->R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RResultPtr_8hxx_source.html:13328,multi-thread,multi-thread,13328,doc/master/RResultPtr_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html,1,['multi-thread'],['multi-thread']
Performance,"utes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TIterator*_compCIter! do not persist; RooListProxy_compCSet; TIterator*_compRIter! do not persist; RooListProxy_compRSet; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProduct.html:33372,cache,cache,33372,root/html534/RooProduct.html,https://root.cern,https://root.cern/root/html534/RooProduct.html,4,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"utes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions;  TBasket (const TBasket &);  TBasket objects are not copiable. ;  ; void AdoptBuffer (TBuffer *user_buffer);  Adopt a buffer from an external entity. ;  ; bool CanGenerateOffsetArray ();  Determine whether we can generate the offset array when this branch is read. ;  ; void DisownBuffer ();  Disown all references to the internal buffer - some other object likely now owns it. ;  ; Int_t * GetCalculatedEntryOffset ();  Calculates the entry offset array, if possible. ;  ; void InitializeCompressedBuffer (Int_t len, TFile *file);  Initialize the compressed buffer; either from the TTree or create a local one. ;  ; TBasket & operator= (const TBasket &);  TBasket objects are not copiable. ;  ; Int_t ReadBasketBuffersUncompressedCase ();  By-passing buffer unzipping has been requested and is possible (only 1 entry in this basket). ;  ; Int_t ReadBasketBuffersUnzip (char *, Int_t, bool, TFile *);  We always create the TBuffer for the basket but it hold the buffer from the cache. ;  ; void ResetEntryOffset ();  . Friends; class TBranch;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TBasket.h>. Inheritance diagram for TBasket:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EIOBits. enum class TBasket::EIOBits : Char_t. strong . EnumeratorkGenerateOffsetMap ; kSupported . Definition at line 97 of file TBasket.h. ◆ EUnsupportedIOBits. enum class TBasket::EUnsupportedIOBits : Char_t. strong . EnumeratorkUnsupported . Definition at line 109 of file TBasket.h. Constructor & Destructor Documentation. ◆ TBasket() [1/4]. TBasket::TBasket ; (; const TBasket & ; ). private . TBasket objects are not copiable. . ◆ TBasket() [2/4]. TBasket::TBasket ; (; ). Default constructor. ; Definition at line 47 of file TBasket.cxx. ◆ TBasket()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBasket.html:20744,cache,cache,20744,doc/master/classTBasket.html,https://root.cern,https://root.cern/doc/master/classTBasket.html,1,['cache'],['cache']
Performance,"utes |; List of all members ; TGeoCompositeShape Class ReferenceThe Geometry Package » Shapes. ; Composite shapes are Boolean combinations of two or more shape components. ; The supported Boolean operations are union (+), intersection (*) and subtraction(-). Composite shapes derive from the base TGeoShape** class, therefore providing all shape features: computation of bounding box, finding if a given point is inside or outside the combination, as well as computing the distance to entering/exiting. They can be directly used for creating volumes or used in the definition of other composite shapes.; Composite shapes are provided in order to complement and extend the set of basic shape primitives. They have a binary tree internal structure, therefore all shape-related geometry queries are signals propagated from top level down to the final leaves, while the provided answers are assembled and interpreted back at top. This CSG (composite solid geometry) hierarchy is effective for small number of components, while performance drops dramatically for large structures. Building a complete geometry in this style is virtually possible but highly not recommended.; The Structure of Composite Shapes; A composite shape can always be looked as the result of a Boolean operation between only two shape components. All information identifying these two components as well as their positions with respect to the frame of the composite is represented by an object called Boolean node. A composite shape has a pointer to such a Boolean node. Since the shape components may also be composites, they will also contain binary Boolean nodes branching out other two shapes in the hierarchy. Any such branch ends-up when the final leaves are no longer composite shapes, but basic primitives. The figure shows the composite shapes structure. The composite shapes structure; Suppose that A, B, C and D represent basic shapes, we will illustrate how the internal representation of few combinations look like. We",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCompositeShape.html:1276,perform,performance,1276,doc/master/classTGeoCompositeShape.html,https://root.cern,https://root.cern/doc/master/classTGeoCompositeShape.html,1,['perform'],['performance']
Performance,"uto h4 = new TH2F(""h4"",""h4"",40,-3,3,40,-3,3);; h1->SetBit(TH1::kNoStats);; for (Int_t i=0;i<5000;i++) {; double x,y;; gRandom->Rannor(x,y);; if(x>0 && y>0) h1->Fill(x,y,4);; if(x<0 && y<0) h2->Fill(x,y,3);; if(x>0 && y<0) h3->Fill(x,y,2);; if(x<0 && y>0) h4->Fill(x,y,1);; }; h1->Draw(""colz"");; h2->Draw(""col same"");; h3->Draw(""col same"");; h4->Draw(""col same"");; }; c#define c(i)Definition RSha256.hxx:101; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786. The option COL can be combined with the option POL:; {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hcol1 = new TH2F(""hcol1"",""Option COLor combined with POL"",40,-4,4,40,-4,4);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcol1->Fill(px,py);; }; hcol1->Draw(""COLZPOL"");; }. SinceROOT version 6.07/03:; A second rendering technique is also available with the COL2 and COLZ2 options.; These options provide potential performance improvements compared to the standard COL option. The performance comparison of the COL2 to the COL option depends on the histogram and the size of the rendering region in the current pad. In general, a small (approx. less than 100 bins per axis), sparsely populated TH2 will render faster with the COL option.; However, for larger histograms (approx. more than 100 bins per axis) that are not sparse, the COL2 option will provide up to 20 times performance improvements. For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude faster with the COL2 option.; The COL2 option will also scale its performance based on the size of the pixmap the histogram image is being rendered into. It also is much better optimized for sessions where the user is forwarding X11 windows through an ssh connection.; For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL and COLZ options. There is one major difference and that concerns the treatment of bins with",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:47961,perform,performance,47961,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['perform'],['performance']
Performance,"utomatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:1468,cache,cache,1468,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,1,['cache'],['cache']
Performance,"utorials. Detailed Description; Likelihood and minimization: visualization of errors from a covariance matrix . ; #include ""RooRealVar.h""; #include ""RooDataHist.h""; #include ""RooGaussian.h""; #include ""RooAddPdf.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TAxis.h""; using namespace RooFit;; ; void rf610_visualerror(); {; // S e t u p e x a m p l e f i t; // ---------------------------------------; ; // Create sum of two Gaussians pdf with factory; RooRealVar x(""x"", ""x"", -10, 10);; ; RooRealVar m(""m"", ""m"", 0, -10, 10);; RooRealVar s(""s"", ""s"", 2, 1, 50);; RooGaussian sig(""sig"", ""sig"", x, m, s);; ; RooRealVar m2(""m2"", ""m2"", -1, -10, 10);; RooRealVar s2(""s2"", ""s2"", 6, 1, 50);; RooGaussian bkg(""bkg"", ""bkg"", x, m2, s2);; ; RooRealVar fsig(""fsig"", ""fsig"", 0.33, 0, 1);; RooAddPdf model(""model"", ""model"", RooArgList(sig, bkg), fsig);; ; // Create binned dataset; x.setBins(25);; std::unique_ptr<RooAbsData> d{model.generateBinned(x, 1000)};; ; // Perform fit and save fit result; std::unique_ptr<RooFitResult> r{model.fitTo(*d, Save(), PrintLevel(-1))};; ; // V i s u a l i z e f i t e r r o r; // -------------------------------------; ; // Make plot frame; RooPlot *frame = x.frame(Bins(40), Title(""P.d.f with visualized 1-sigma error band""));; d->plotOn(frame);; ; // Visualize 1-sigma error encoded in fit result 'r' as orange band using linear error propagation; // This results in an error band that is by construction symmetric; //; // The linear error is calculated as; // error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); //; // where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; //; // with f(x) = the plotted curve; // 'da' = error taken from the fit result; // Corr(a,a') = the correlation matrix from the fit result; // Z = requested significance 'Z sigma band'; //; // The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters),; // but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf610__visualerror_8C.html:1177,Perform,Perform,1177,doc/master/rf610__visualerror_8C.html,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html,1,['Perform'],['Perform']
Performance,"utorials/tree/cernbuild.C ;  tcl.C How to write a TClonesArray to a TTree ;  tree.C Display the Tree data structures ;  tree0.C Simple Event class example ;  tree1.C This example is a variant of hsimple.C but using a TTree instead of a TNtuple ;  tree2.C This example illustrates how to make a Tree from variables or arrays in a C struct ;  tree2a.C This example is the same as tree2.C, but uses a class instead of a C-struct ;  tree3.C Example of a Tree where branches are variable length arrays A second Tree is created and filled in parallel ;  tree4.C This example writes a tree with objects of the class Event ;  treefriend.C Illustrates how to use Tree friends: ;  treegetval.C Illustrates how to retrieve TTree variables in arrays ;  tv3.C;  tvdemo.C;  ► unuran;  unuranDemo.CExample macro to show unuran capabilities The results are compared with what is obtained using TRandom or TF1::GetRandom The macro is divided in 3 parts: ;  unuranFoamTest.CThis program must be compiled and executed with Aclic as follows ;  ► v7;  concurrentfill.cxx;  draw.cxx;  histops.cxx;  histspeedtest.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  benchmarks.CThis macro run several tests and produces an benchmark report ;  demos.CThis macro shows a control bar to run some of the ROOT tutorials ;  demoshelp.CThis macro shows help on running the Demos ;  geant3tasks.CThis script is a representation using TTasks of the Geant3 simulation program This example uses directly TTask objects ;  hsimple.C This program creates : ;  htmlex.CThis file demo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:157972,concurren,concurrentfill,157972,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['concurren'],['concurrentfill']
Performance,"utors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TStreamerInfo; 13#define ROOT_TStreamerInfo; 14 ; 15#include <atomic>; 16#include <vector>; 17 ; 18#include ""TVirtualStreamerInfo.h""; 19 ; 20#include ""TVirtualCollectionProxy.h""; 21 ; 22#include ""TObjArray.h""; 23 ; 24 ; 25class TFile;; 26class TClass;; 27class TClonesArray;; 28class TDataMember;; 29class TMemberStreamer;; 30class TStreamerElement;; 31class TStreamerBasicType;; 32class TClassStreamer;; 33class TVirtualArray;; 34namespace ROOT { namespace Detail { class TCollectionProxyInfo; } }; 35namespace ROOT { class TSchemaRule; }; 36 ; 37namespace TStreamerInfoActions { class TActionSequence; }; 38 ; 39class TStreamerInfo : public TVirtualStreamerInfo {; 40 ; 41 class TCompInfo {; 42 // Class used to cache information (see fComp); 43 private:; 44 // TCompInfo(const TCompInfo&) = default;; 45 // TCompInfo& operator=(const TCompInfo&) = default;; 46 public:; 47 Int_t fType;; 48 Int_t fNewType;; 49 Int_t fOffset;; 50 Int_t fLength;; 51 TStreamerElement *fElem; ///< Not Owned; 52 ULongptr_t fMethod;; 53 TClass *fClass; ///< Not Owned; 54 TClass *fNewClass; ///< Not Owned; 55 TString fClassName;; 56 TMemberStreamer *fStreamer; ///< Not Owned; 57 TCompInfo() : fType(-1), fNewType(0), fOffset(0), fLength(0), fElem(nullptr), fMethod(0),; 58 fClass(nullptr), fNewClass(nullptr), fClassName(), fStreamer(nullptr) {}; 59 ~TCompInfo() {}; 60 void Update(const TClass *oldcl, TClass *newcl);; 61 };; 62 friend class TStreamerInfoActions::TActionSequence;; 63 ; 64public:; 65 // make the opaque pointer public.; 66 typedef TCompInfo TCompInfo_t;; 67 ; 68protected:; 69 //---------------------------------------------------------------------------; 70 // Adapter class used to handle streaming collection of pointers; 71 //---------------------------------------------------------------------------; 72 class TPointerCollectionAdapter; 73 {; 74 public:; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8h_source.html:1349,cache,cache,1349,doc/master/TStreamerInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html,1,['cache'],['cache']
Performance,"utput file.; When a TTree is filled the data is stored in the individual branches' basket. Each basket is written individually to the disk as soon as it is full. In consequence the baskets of branches that contain 'large' data chunk are written to the disk more often.; There is currently 3 supported sorting order: SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry; When using SortBasketsByOffset the baskets are written in the output file in the same order as in the original file (i.e. the basket are sorted on their offset in the original file; Usually this also means that the baskets are sorted on the index/number of the last entry they contain); When using SortBasketsByBranch all the baskets of each individual branches are stored contiguously. This tends to optimize reading speed when reading a small number (1->5) of branches, since all their baskets will be clustered together instead of being spread across the file. However it might decrease the performance when reading more branches (or the full entry).; When using SortBasketsByEntry the baskets with the lowest starting entry are written first. (i.e. the baskets are sorted on the index/number of the first entry they contain). This means that on the file the baskets will be in the order in which they will be needed when reading the whole tree sequentially. ; Definition at line 104 of file TTreeCloner.cxx. ◆ TTreeCloner() [4/4]. TTreeCloner::TTreeCloner ; (; TTree * ; from, . TDirectory * ; newdirectory, . Option_t * ; method, . UInt_t ; options = kNone . ). Constructor. In place cloning. ; This object would transfer the data from 'from' the original location to 'newdirectory' the new directory using the sorting method indicated in method. It updates the 'from' TTree with the new information. See TTreeCloner::TTreeCloner(TTree *from, TTree *to, Option_t *method, UInt_t options) for details on the sorting methods. ; Definition at line 119 of file TTreeCloner.cxx. ◆ ~TTreeCloner(). TTreeCloner",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCloner.html:6719,perform,performance,6719,doc/master/classTTreeCloner.html,https://root.cern,https://root.cern/doc/master/classTTreeCloner.html,1,['perform'],['performance']
Performance,"utput values. (I still leave the code here, but use this with care!!! The default however is to use the distributions!!! ; Definition at line 458 of file OptimizeConfigParameters.cxx. ◆ GetScanIndices(). std::vector< int > TMVA::OptimizeConfigParameters::GetScanIndices ; (; int ; val, . std::vector< int > ; base . ). private . helper function to scan through the all the combinations in the parameter space ; Definition at line 149 of file OptimizeConfigParameters.cxx. ◆ GetSeparation(). Double_t TMVA::OptimizeConfigParameters::GetSeparation ; (; ). private . return the separation between the signal and background MVA ouput distribution ; Definition at line 434 of file OptimizeConfigParameters.cxx. ◆ GetSigEffAtBkgEff(). Double_t TMVA::OptimizeConfigParameters::GetSigEffAtBkgEff ; (; Double_t ; bkgEff = 0.1). private . calculate the signal efficiency for a given background efficiency ; Definition at line 509 of file OptimizeConfigParameters.cxx. ◆ IsA(). virtual TClass * TMVA::OptimizeConfigParameters::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::IFitterTarget.; Definition at line 100 of file OptimizeConfigParameters.h. ◆ Log(). MsgLogger & TMVA::OptimizeConfigParameters::Log ; (; ); const. inlineprivate . Definition at line 98 of file OptimizeConfigParameters.h. ◆ optimize(). std::map< TString, Double_t > TMVA::OptimizeConfigParameters::optimize ; (; ). Definition at line 127 of file OptimizeConfigParameters.cxx. ◆ optimizeFit(). void TMVA::OptimizeConfigParameters::optimizeFit ; (; ). private . Definition at line 242 of file OptimizeConfigParameters.cxx. ◆ optimizeScan(). void TMVA::OptimizeConfigParameters::optimizeScan ; (; ). private . do the actual optimization using a simple scan method, i.e. ; calculate the FOM for different tuning paraemters and remember which one is gave the best FOM ; Definition at line 164 of file OptimizeConfigParameters.cxx. ◆ Streamer(). virtual void TMVA::OptimizeConfigParameters",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:8827,Optimiz,OptimizeConfigParameters,8827,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['Optimiz'],['OptimizeConfigParameters']
Performance,"v = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. private:. Bool_tCheckDuplicateName(TObject* obj); Bool_tUnsetDirectory(TObject* obj). Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*THashList::fTableHashtable used for quick lookup of objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t UnsetDirectory(TObject* obj); If the class of obj has the SetDirectory(TDirectory*) method; call it to unset the directory assiciation. The objects in the; selector list or owned by the list and not by the directory that; was active when they were created. Returns true in case of success. Bool_t CheckDuplicateName(TObject* obj); Check for duplicate object names in the list. If an object with; the same name is added then the merge function will fail that will; look up objects in different output lists by name. Returns true; in case name is unique. void AddFirst(TObject* obj); Add at the start of the list. void AddFirst(TObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSelectorList.html:10015,cache,cache,10015,root/html534/TSelectorList.html,https://root.cern,https://root.cern/root/html534/TSelectorList.html,1,['cache'],['cache']
Performance,"vaBkg;  MVA distribution for bakgr. events, used for spline fit. ;  ; TH1D * fMvaBkgFineBin;  MVA distribution for bakgr. events. ;  ; TH1D * fMvaSig;  MVA distribution for signal events, used for spline fit. ;  ; TH1D * fMvaSigFineBin;  MVA distribution for signal events. ;  ; Bool_t fNotDoneYet;  flat to indicate of Method Transformations have been obtained yet or not (normally done in MethodBase::TrainMethod) ;  ; TString fOptimizationFitType;  which type of optimisation procedure to be used ;  ; std::map< TString, Double_t > fTunedParameters;  parameters included in the tuning ;  ; std::map< TString, TMVA::Interval * > fTuneParameters;  parameters included in the tuning ;  . #include <TMVA/OptimizeConfigParameters.h>. Inheritance diagram for TMVA::OptimizeConfigParameters:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ OptimizeConfigParameters(). TMVA::OptimizeConfigParameters::OptimizeConfigParameters ; (; MethodBase *const ; method, . std::map< TString, TMVA::Interval * > ; tuneParameters, . TString ; fomType = ""Separation"", . TString ; optimizationType = ""GA"" . ). Constructor which sets either ""Classification or Regression"". ; Definition at line 60 of file OptimizeConfigParameters.cxx. ◆ ~OptimizeConfigParameters(). TMVA::OptimizeConfigParameters::~OptimizeConfigParameters ; (; ). virtual . the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it) ; Definition at line 96 of file OptimizeConfigParameters.cxx. Member Function Documentation. ◆ Class(). static TClass * TMVA::OptimizeConfigParameters::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::OptimizeConfigParameters::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::OptimizeConfigParameters::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:4504,Optimiz,OptimizeConfigParameters,4504,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,2,['Optimiz'],['OptimizeConfigParameters']
Performance,"vaSigMVA distrituion for signal events, used for spline fit; TH1D*fMvaSigFineBinMVA distrituion for signal events; TStringfOptimizationFitTypewhich type of optimisation procedure to be used ; map<TString,TMVA::Interval>fTuneParametersparameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase *const method, map<TString,TMVA::Interval> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). std::vector< int > GetScanIndices(int val, vector<int> base); helper function to scan through the all the combinations in the; parameter space. void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__OptimizeConfigParameters.html:3101,optimiz,optimizeScan,3101,root/html530/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html530/TMVA__OptimizeConfigParameters.html,4,['optimiz'],"['optimization', 'optimizeScan']"
Performance,"vable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedReal(const RooCachedReal& other, const char* name = 0); Copy constructor. ~RooCachedReal(); Destructor. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Interface function to create an internal cache object that represent; each cached function configuration. This interface allows to create and; return a class derived from RooAbsCachedReal::FuncCacheElem so that; a derived class fillCacheObject implementation can utilize extra functionality; defined in such a derived cache class. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the external input p.d.f that are not one of; the cache observables. If this p.d.f is operated in automatic mode,; return the parameters of the external input p.d.f. void operModeHook(). RooCachedReal(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooCachedReal(*this,newname); }. void setCdfBoundaries(Bool_t flag); If flag is true the RooHistFunc that represent the cache histogram; will use special boundary conditions for use with cumulative distribution; functions: at the lower bound the function is forced to converge at zero and the upper; bound is the function is forced to converge at 1.0. Bool_t getCdfBoundaries() const; If true the c.d.f boundary mode is active. Bool_t cacheSource() const; { return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooCachedReal.html:40656,cache,cache,40656,root/html604/RooCachedReal.html,https://root.cern,https://root.cern/root/html604/RooCachedReal.html,1,['cache'],['cache']
Performance,"vable; configurations simultaneously. RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedPdf(const RooCachedPdf& other, const char* name = 0); Copy constructor. ~RooCachedPdf(); Destructor. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cachePdf) const; Update contents of cache histogram by resampling the input p.d.f. Note that; the cache is filled with normalized p.d.f values so that the RooHistPdf; that represents the cache contents can be explicitly declared as self normalized; eliminating the need for superfluous numeric calculations of unit normalization.s. void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const; Defer preferred scan order to cached pdf prefernece. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedPdf.html:42544,cache,cachePdf,42544,root/html526/RooCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooCachedPdf.html,14,['cache'],"['cache', 'cachePdf']"
Performance,"vableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooCategory&operator=(const RooCategory&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCategory.html:11897,optimiz,optimizeCacheMode,11897,root/html602/RooCategory.html,https://root.cern,https://root.cern/root/html602/RooCategory.html,2,['optimiz'],['optimizeCacheMode']
Performance,"vables listed in iset. ; If no nset argument is given the c.d.f normalization is constructed over the integrated observables, so that its maximum value is precisely 1. It is also possible to choose a different normalization for multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can construct a partial cdf c(x,y) that only when integrated itself over z results in a maximum value of 1. To construct such a cdf pass z as argument to the optional nset argument ; Definition at line 2468 of file RooAbsPdf.cxx. ◆ createCdf() [2/2]. RooAbsPdf::createCdf ; (; const RooArgSet & ; iset, . const RooCmdArg & ; arg1, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). Create an object that represents the integral of the function over one or more observables listed in iset. ; The actual integration calculation is only performed when the return object is evaluated. The name of the integral object is automatically constructed from the name of the input function, the variables it integrates and the range integrates over; The following named arguments are accepted . Type of CmdArg Effect on CDF . SupNormSet(const RooArgSet&) Observables over which should be normalized in addition to the integration observables . ScanNumCdf() Apply scanning technique if cdf integral involves numeric integration [ default ] . ScanAllCdf() Always apply scanning technique . ScanNoCdf() Never apply scanning technique . ScanParameters(Int_t nbins, Int_t intOrder) Parameters for scanning technique of making CDF: number of sampled bins and order of interpolation applied on numeric cdf . PyROOT; The RooAbsPdf::createCdf() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 2490 of file RooAbsPdf.cxx. ◆ createExpectedEventsFunc(). std::u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:85201,perform,performed,85201,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['perform'],['performed']
Performance,vables over which is integrated numerically. ; Definition at line 118 of file RooRealIntegral.h. ◆ _intOperMode. IntOperMode RooRealIntegral::_intOperMode = Hybrid. protected . integration operation mode ; Definition at line 134 of file RooRealIntegral.h. ◆ _jacList. RooSetProxy RooRealIntegral::_jacList. protected . Set of lvalue observables over which is analytically integration that have a non-unit Jacobian. ; Definition at line 120 of file RooRealIntegral.h. ◆ _mode. Int_t RooRealIntegral::_mode = 0. protected . Definition at line 133 of file RooRealIntegral.h. ◆ _numIntegrand. std::unique_ptr<RooAbsFunc> RooRealIntegral::_numIntegrand. mutableprotected . ! ; Definition at line 138 of file RooRealIntegral.h. ◆ _numIntEngine. std::unique_ptr<RooAbsIntegrator> RooRealIntegral::_numIntEngine. mutableprotected . ! ; Definition at line 137 of file RooRealIntegral.h. ◆ _params. std::unique_ptr<RooArgSet> RooRealIntegral::_params. mutableprotected . ! cache for set of parameters ; Definition at line 142 of file RooRealIntegral.h. ◆ _rangeName. TNamed* RooRealIntegral::_rangeName = nullptr. protected . Definition at line 140 of file RooRealIntegral.h. ◆ _respectCompSelect. bool RooRealIntegral::_respectCompSelect = true. protected . Definition at line 88 of file RooRealIntegral.h. ◆ _restartNumIntEngine. bool RooRealIntegral::_restartNumIntEngine = false. mutableprotected . ! ; Definition at line 136 of file RooRealIntegral.h. ◆ _saveInt. RooArgSet RooRealIntegral::_saveInt. protected . ! ; Definition at line 126 of file RooRealIntegral.h. ◆ _saveSum. RooArgSet RooRealIntegral::_saveSum. protected . ! ; Definition at line 127 of file RooRealIntegral.h. ◆ _sumCat. RooListProxy RooRealIntegral::_sumCat. protected . ! ; Definition at line 131 of file RooRealIntegral.h. ◆ _sumList. RooSetProxy RooRealIntegral::_sumList. protected . Set of discrete observable over which is summed numerically. ; Definition at line 117 of file RooRealIntegral.h. ◆ _valid. bool RooRealIntegral:,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:77644,cache,cache,77644,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,1,['cache'],['cache']
Performance,"vables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::move(integral));; 679 cachedIntegral->setCacheSource(true) ;; 680 if (integral->operMode()==ADirty) {; 681 cachedIntegral->setOperMode(ADirty) ;; 682 }; 683 //cachedIntegral->disableCache(true) ;; 684 return RooFit::makeOwningPtr<RooAbsReal>(std::move(cachedIntegral));; 685 }; 686 }; 687 ; 688 return RooFit::makeOwningPtr(std::move(integral));; 689}; 690 ; 691 ; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:26154,cache,cachedIntegral,26154,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['cache'],['cachedIntegral']
Performance,"vables(const RooArgSet& nset) const; virtual RooArgSet*actualParameters(const RooArgSet& nset) const; virtual voidRooAbsReal::attachToTree(TTree& t, Int_t bufSize = 32000); virtual const char*binningName() const; TStringcacheNameSuffix(const RooArgSet& nset) const; RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidclearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); virtual RooAbsCachedPdf::PdfCacheElem*createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; voiddisableCache(Bool_t flag); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tRooAbsReal::evaluate() const; virtual voidfillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; static Bool_tRooAbsArg::flipAClean(); virtual RooAbsGenContext*RooAbsPdf::genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto) const; RooAbsCachedPdf::PdfCacheElem*getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedPdf.html:31433,cache,cache,31433,root/html526/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedPdf.html,3,['cache'],['cache']
Performance,"vables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddPdf.html:47486,cache,caches,47486,doc/master/classRooAddPdf.html,https://root.cern,https://root.cern/doc/master/classRooAddPdf.html,6,['cache'],['caches']
Performance,"vables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:49334,cache,caches,49334,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,3,['cache'],['caches']
Performance,"vailable when TROOT is part of rootcling.; 1004 if (dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"")) {; 1005 // deleting the interpreter makes things crash at exit in some cases; 1006 delete fInterpreter;; 1007 }; 1008#else; 1009 // deleting the interpreter makes things crash at exit in some cases; 1010 delete fInterpreter;; 1011#endif; 1012 ; 1013 // Prints memory stats; 1014 TStorage::PrintStatistics();; 1015 ; 1016 gROOTLocal = nullptr;; 1017 fgRootInit = kFALSE;; 1018 }; 1019}; 1020 ; 1021////////////////////////////////////////////////////////////////////////////////; 1022/// Add a class to the list and map of classes.; 1023/// This routine is deprecated, use TClass::AddClass directly.; 1024 ; 1025void TROOT::AddClass(TClass *cl); 1026{; 1027 TClass::AddClass(cl);; 1028}; 1029 ; 1030////////////////////////////////////////////////////////////////////////////////; 1031/// Add a class generator. This generator will be called by TClass::GetClass; 1032/// in case its does not find a loaded rootcint dictionary to request the; 1033/// creation of a TClass object.; 1034 ; 1035void TROOT::AddClassGenerator(TClassGenerator *generator); 1036{; 1037 if (!generator) return;; 1038 fClassGenerators->Add(generator);; 1039}; 1040 ; 1041////////////////////////////////////////////////////////////////////////////////; 1042/// Append object to this directory.; 1043///; 1044/// If replace is true:; 1045/// remove any existing objects with the same same (if the name is not """"); 1046 ; 1047void TROOT::Append(TObject *obj, Bool_t replace /* = kFALSE */); 1048{; 1049 R__LOCKGUARD(gROOTMutex);; 1050 TDirectory::Append(obj,replace);; 1051}; 1052 ; 1053////////////////////////////////////////////////////////////////////////////////; 1054/// Add browsable objects to TBrowser.; 1055 ; 1056void TROOT::Browse(TBrowser *b); 1057{; 1058 TObject *obj;; 1059 TIter next(fBrowsables);; 1060 ; 1061 while ((obj = (TObject *) next())) {; 1062 const char *opt = next.GetOption();; 1063 if (opt && ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:40819,load,loaded,40819,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['loaded']
Performance,"val -- The FFT convolution 'model' will run with 50 bins. A decent accuracy for difficult convolutions is typically only reached with n >= 1000. Suggest to increase the number of bins of the observable 'mean'.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(gx_Int[mean,x]) using numeric integrator RooIntegrator1D to calculate Int(mean); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_mean_Int[mean]) using numeric integrator RooIntegrator1D to calculate Int(mean); [#0] WARNING:Integration -- RooRombergIntegrator::integral: integral of model_mean over range (-6,6) did not converge after 20 steps; [1] h = 1 , s = 0; [2] h = 0.25 , s = 6; [3] h = 0.0625 , s = 3; [4] h = 0.01562 , s = 4.5; [5] h = 0.003906 , s = 3.75; [6] h = 0.0009766 , s = 4.125; [7] h = 0.0002441 , s = 3.938; [8] h = 6.104e-05 , s = 4.031; [9] h = 1.526e-05 , s = 3.984; [10] h = 3.815e-06 , s = 4.008; [11] h = 9.537e-07 , s = 3.996; [12] h = 2.384e-07 , s = 4.002; [13] h = 5.96e-08 , s = 3.999; [14] h = 1.49e-08 , s = 4; [15] h = 3.725e-09 , s = 4; [16] h = 9.313e-10 , s = 4; [17] h = 2.328e-10 , s = 4; [18] h = 5.821e-11 , s = 4; [19] h = 1.455e-11 , s = 4; [20] h = 3.638e-12 , s = 4; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(model) creating new cache 0x56161efde710 with pdf gx_CONV_model_mean_CACHE_Obs[x,mean]_NORM_x_mean for nset (x,mean) with code 1; [#0] WARNING:Eval -- The FFT convolution 'model' will run with 50 bins. A decent accuracy for difficult convolutions is typically only reached with n >= 1000. Suggest to increase the number of bins of the observable 'mean'.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(model) creating new cache 0x56161efde710 with pdf gx_CONV_model_mean_CACHE_Obs[x,mean]_NORM_x for nset (x) with code 3 from preexisting content.; DateApril 2009 ; AuthorWouter Verkerke ; Definition in file rf211_paramconv.C. tutorialsroofitrf211_paramconv.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf211__paramconv_8C.html:33961,cache,cache,33961,doc/master/rf211__paramconv_8C.html,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8C.html,2,['cache'],['cache']
Performance,"val.cxx. Member Data Documentation. ◆ fBestFitParams. RooArgSet* RooStats::LikelihoodInterval::fBestFitParams. private . snapshot of the model parameters with best fit value (managed internally) ; Definition at line 100 of file LikelihoodInterval.h. ◆ fConfidenceLevel. double RooStats::LikelihoodInterval::fConfidenceLevel. private . Requested confidence level (eg. 0.95 for 95% CL) ; Definition at line 102 of file LikelihoodInterval.h. ◆ fFunctor. std::shared_ptr<RooFunctor> RooStats::LikelihoodInterval::fFunctor. private . ! transient pointer to functor class used by the minimizer ; Definition at line 106 of file LikelihoodInterval.h. ◆ fLikelihoodRatio. RooAbsReal* RooStats::LikelihoodInterval::fLikelihoodRatio. private . likelihood ratio function used to make contours (managed internally) ; Definition at line 101 of file LikelihoodInterval.h. ◆ fLowerLimits. std::map<std::string, double> RooStats::LikelihoodInterval::fLowerLimits. private . map with cached lower bound values ; Definition at line 103 of file LikelihoodInterval.h. ◆ fMinFunc. std::shared_ptr<ROOT::Math::IMultiGenFunction> RooStats::LikelihoodInterval::fMinFunc. private . ! transient pointer to the minimization function ; Definition at line 107 of file LikelihoodInterval.h. ◆ fMinimizer. std::shared_ptr<ROOT::Math::Minimizer > RooStats::LikelihoodInterval::fMinimizer. private . ! transient pointer to minimizer class used to find limits and contour ; Definition at line 105 of file LikelihoodInterval.h. ◆ fParameters. RooArgSet RooStats::LikelihoodInterval::fParameters. private . parameters of interest for this interval ; Definition at line 99 of file LikelihoodInterval.h. ◆ fUpperLimits. std::map<std::string, double> RooStats::LikelihoodInterval::fUpperLimits. private . map with cached upper bound values ; Definition at line 104 of file LikelihoodInterval.h. Libraries for RooStats::LikelihoodInterval:. [legend]; The documentation for this class was generated from the following files:; roofit/roostats/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1LikelihoodInterval.html:23951,cache,cached,23951,doc/master/classRooStats_1_1LikelihoodInterval.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1LikelihoodInterval.html,1,['cache'],['cached']
Performance,"val;; 6257 }; 6258 }; 6259 }; 6260 return cmax;; 6261}; 6262 ; 6263////////////////////////////////////////////////////////////////////////////////; 6264/// Static function which returns the tree file size limit in bytes.; 6265 ; 6266Long64_t TTree::GetMaxTreeSize(); 6267{; 6268 return fgMaxTreeSize;; 6269}; 6270 ; 6271////////////////////////////////////////////////////////////////////////////////; 6272/// Return minimum of column with name columname.; 6273/// if the Tree has an associated TEventList or TEntryList, the minimum; 6274/// is computed for the entries in this list.; 6275 ; 6276Double_t TTree::GetMinimum(const char* columname); 6277{; 6278 TLeaf* leaf = this->GetLeaf(columname);; 6279 if (!leaf) {; 6280 return 0;; 6281 }; 6282 ; 6283 // create cache if wanted; 6284 if (fCacheDoAutoInit); 6285 SetCacheSizeAux();; 6286 ; 6287 TBranch* branch = leaf->GetBranch();; 6288 Double_t cmin = DBL_MAX;; 6289 for (Long64_t i = 0; i < fEntries; ++i) {; 6290 Long64_t entryNumber = this->GetEntryNumber(i);; 6291 if (entryNumber < 0) break;; 6292 branch->GetEntry(entryNumber);; 6293 for (Int_t j = 0;j < leaf->GetLen(); ++j) {; 6294 Double_t val = leaf->GetValue(j);; 6295 if (val < cmin) {; 6296 cmin = val;; 6297 }; 6298 }; 6299 }; 6300 return cmin;; 6301}; 6302 ; 6303////////////////////////////////////////////////////////////////////////////////; 6304/// Load the TTreePlayer (if not already done).; 6305 ; 6306TVirtualTreePlayer* TTree::GetPlayer(); 6307{; 6308 if (fPlayer) {; 6309 return fPlayer;; 6310 }; 6311 fPlayer = TVirtualTreePlayer::TreePlayer(this);; 6312 return fPlayer;; 6313}; 6314 ; 6315////////////////////////////////////////////////////////////////////////////////; 6316/// Find and return the TTreeCache registered with the file and which may; 6317/// contain branches for us.; 6318 ; 6319TTreeCache *TTree::GetReadCache(TFile *file) const; 6320{; 6321 TTreeCache *pe = dynamic_cast<TTreeCache*>(file->GetCacheRead(GetTree()));; 6322 if (pe && pe->GetTree() != G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:246128,cache,cache,246128,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,2,"['Load', 'cache']","['Load', 'cache']"
Performance,"valError, Entries= 0, Total sum= 13.5872; TH1.Print Name = TrainingHistory_PyKeras_LSTM_'accuracy', Entries= 0, Total sum= 6.34883; TH1.Print Name = TrainingHistory_PyKeras_LSTM_'loss', Entries= 0, Total sum= 6.27501; TH1.Print Name = TrainingHistory_PyKeras_LSTM_'val_accuracy', Entries= 0, Total sum= 6.33125; TH1.Print Name = TrainingHistory_PyKeras_LSTM_'val_loss', Entries= 0, Total sum= 6.20691; Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_PyKeras_LSTM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_BDTG.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: TMVA_LSTM for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0494 sec ; Factory : Test method: TMVA_DNN for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0212 sec ; Factory : Test method: PyKeras_LSTM for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_LSTM.h5; PyKeras_LSTM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.202 sec ; Factory : Test method: BDTG for Classification performance",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:45063,perform,performance,45063,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['perform'],['performance']
Performance,"valErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction2Binding<double,int,int>&operator=(const RooCFunction2Binding<double,int,int>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2Binding_double_int_int_.html:19772,optimiz,optimizeCacheMode,19772,root/html602/RooCFunction2Binding_double_int_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2Binding_double_int_int_.html,2,['optimiz'],['optimizeCacheMode']
Performance,"valNumber evaluations used in last minimization; RooRealProxy_nllInput -log(L) function; RooSetProxy_obsParameters of profile likelihood; RooArgSet_obsAbsMinObservable values at absolute minimum; TIterator*_oiter! Iterator of profile likelihood output parameter(s); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_parMarginialized parameters of likelihood; RooArgSet_paramAbsMinParameter values at absolute minimum; map<std::string,bool>_paramFixedParameter constant status at last time of use; TIterator*_piter! Iterator over profile likelihood parameters to be minimized ; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_t_startFromMinAlways start minimization for global minimum?; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProfileLL.html:35808,cache,cache,35808,root/html534/RooProfileLL.html,https://root.cern,https://root.cern/root/html534/RooProfileLL.html,1,['cache'],['cache']
Performance,"validationSample, . SeparationBase * ; qualityIndex = nullptr . ). constructor ; Definition at line 69 of file CCPruner.cxx. ◆ CCPruner() [2/2]. CCPruner::CCPruner ; (; DecisionTree * ; t_max, . const DataSet * ; validationSample, . SeparationBase * ; qualityIndex = nullptr . ). constructor ; Definition at line 92 of file CCPruner.cxx. ◆ ~CCPruner(). CCPruner::~CCPruner ; (; ). Definition at line 115 of file CCPruner.cxx. Member Function Documentation. ◆ GetOptimalPruneSequence(). std::vector< DecisionTreeNode * > CCPruner::GetOptimalPruneSequence ; (; ); const. return the prune strength (=alpha) corresponding to the prune sequence ; Definition at line 240 of file CCPruner.cxx. ◆ GetOptimalPruneStrength(). Float_t TMVA::CCPruner::GetOptimalPruneStrength ; (; ); const. inline . Definition at line 89 of file CCPruner.h. ◆ GetOptimalQualityIndex(). Float_t TMVA::CCPruner::GetOptimalQualityIndex ; (; ); const. inline . Definition at line 85 of file CCPruner.h. ◆ Optimize(). void CCPruner::Optimize ; (; ). determine the pruning sequence ; Definition at line 124 of file CCPruner.cxx. ◆ SetPruneStrength(). void TMVA::CCPruner::SetPruneStrength ; (; Float_t ; alpha = -1.0). inline . Definition at line 110 of file CCPruner.h. Member Data Documentation. ◆ fAlpha. Float_t TMVA::CCPruner::fAlpha. private . ! regularization parameter in CC pruning ; Definition at line 93 of file CCPruner.h. ◆ fDebug. Bool_t TMVA::CCPruner::fDebug. private . ! debug flag ; Definition at line 106 of file CCPruner.h. ◆ fOptimalK. Int_t TMVA::CCPruner::fOptimalK. private . ! index of the optimal tree in the pruned tree sequence ; Definition at line 105 of file CCPruner.h. ◆ fOwnQIndex. Bool_t TMVA::CCPruner::fOwnQIndex. private . ! flag indicates if fQualityIndex is owned by this ; Definition at line 97 of file CCPruner.h. ◆ fPruneSequence. std::vector<TMVA::DecisionTreeNode*> TMVA::CCPruner::fPruneSequence. private . ! map of weakest links (i.e., branches to prune) -> pruning index ; Definition at ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1CCPruner.html:4305,Optimiz,Optimize,4305,doc/master/classTMVA_1_1CCPruner.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1CCPruner.html,1,['Optimiz'],['Optimize']
Performance,"valuate product of input functions. ;  ; Int_t getPartIntList (const RooArgSet *iset, const char *rangeName=nullptr) const;  Return list of (partial) integrals whose product defines the integral of this RooProduct over the observables in iset in range isetRange. ;  ; ProdMap * groupProductTerms (const RooArgSet &) const;  Group observables into subsets in which the product factorizes and that can thus be integrated separately. ;  ; void ioStreamerPass2 () override;  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; const char * makeFPName (const char *pfx, const RooArgSet &terms) const;  Construct automatic name for internal product terms. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProduct.html:49325,cache,cached,49325,doc/master/classRooProduct.html,https://root.cern,https://root.cern/doc/master/classRooProduct.html,2,['cache'],"['cache', 'cached']"
Performance,valuation of 4000 events: 1.01 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; Factory : Test method: MLP for Multiclass classification performance; : ; : Dataset[dataset] : Create results for testing; : Dataset[dataset] : Multiclass evaluation of MLP on testing sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 0.0114 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; Factory : Test method: PDEFoam for Multiclass classification performance; : ; : Dataset[dataset] : Create results for testing; : Dataset[dataset] : Multiclass evaluation of PDEFoam on testing sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 0.122 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; Factory : Test method: DL_CPU for Multiclass classification performance; : ; : Dataset[dataset] : Create results for testing; : Dataset[dataset] : Multiclass evaluation of DL_CPU on testing sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 0.105 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; Factory : ␛[1mEvaluate all methods␛[0m; : Evaluate multiclass classification method: BDTG; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; TFHandler_BDTG : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.070153 1.0224 [ -4.0592 3.5808 ]; : var2: 0.30372 1.0460 [ -3.6952 3.7877 ]; : var3: 0.12152 1.1222 [ -3.6800 3.9200 ]; : var4: -0.072602 1.2766 [ -4.8486 4.2221 ]; : -----------------------------------------------------------; : Evaluate multiclass classification method: MLP; : Creating multiclass response histograms...; : Creating multiclass performance hi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:20502,perform,performance,20502,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['perform'],['performance']
Performance,"value gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if he puts limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it is; recommended that:. Limits on variable parameters should be used only when needed in order; to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or re-perform the; error analysis without limits. How to get the right answer from MINUIT. MINUIT offers the user a choice of several minimization algorithms. The; MIGRAD algorithm is in general the best minimizer for; nearly all functions. It is a variable-metric method with inexact line; search, a stable metric updating scheme, and checks for; positive-definiteness. Its main weakness is that it depends heavily on; knowledge of the first derivatives, and fails miserably if they are very; inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. Getting the right minimum with limits. If MIGRAD converges normally to a point where no parameter is near one of; its limits, then the existence of limits has probably not prevented MINUIT; from finding the right minimum. On the other hand, if one or more; parameters is near its limit at the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:4771,perform,perform,4771,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,8,['perform'],['perform']
Performance,"value of the current entry.; 185 /// Return a nullptr and print an error if no entry has been loaded yet.; 186 /// The returned address is guaranteed to stay constant while a given TTree is being read from a given file,; 187 /// unless the branch addresses are manipulated directly (e.g. through TTree::SetBranchAddress()).; 188 /// The address might also change when the underlying TTree/TFile is switched, e.g. when a TChain switches files.; 189 T *Get(); 190 {; 191 if (!fProxy) {; 192 ErrorAboutMissingProxyIfNeeded();; 193 return nullptr;; 194 }; 195 void *address = GetAddress(); // Needed to figure out if it's a pointer; 196 return fProxy->IsaPointer() ? *(T **)address : (T *)address;; 197 }; 198 ; 199 /// Return a pointer to the value of the current entry.; 200 /// Equivalent to Get().; 201 T* operator->() { return Get(); }; 202 ; 203 /// Return a reference to the value of the current entry.; 204 /// Equivalent to dereferencing the pointer returned by Get(). Behavior is undefined if no entry has been loaded yet.; 205 /// Most likely a crash will occur.; 206 T& operator*() { return *Get(); }; 207 ; 208protected:; 209 // FIXME: use IsA() instead once we have ClassDefTInline; 210 /// Get the template argument as a string.; 211 const char* GetDerivedTypeName() const override {; 212 static const std::string sElementTypeName = GetElementTypeName(typeid(T));; 213 return sElementTypeName.data();; 214 }; 215 ; 216 // FIXME: re-introduce once we have ClassDefTInline!; 217 //ClassDefT(TTreeReaderValue, 0);//Accessor to data via TTreeReader; 218};; 219 ; 220namespace cling {; 221std::string printValue(ROOT::Internal::TTreeReaderValueBase *val);; 222template <typename T>; 223std::string printValue(TTreeReaderValue<T> *val); 224{; 225 return printValue(static_cast<ROOT::Internal::TTreeReaderValueBase *>(val));; 226}; 227} // namespace cling; 228 ; 229#endif // ROOT_TTreeReaderValue; TBranchProxy.h; TDictionary.h; TString.h; ROOT::Detail::TBranchProxyBase class for all the proxy o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReaderValue_8h_source.html:9142,load,loaded,9142,doc/master/TTreeReaderValue_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html,1,['load'],['loaded']
Performance,"value. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded, -1 in case lib does not exist; or in case of error and -2 in case of version mismatch.; When entry is specified the loaded lib is; searched for this entry point (return -1 when entry does not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Need to return the equivalent of LD_LIBRARY_PATH. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSystem.html:34343,load,loaded,34343,root/html534/TSystem.html,https://root.cern,https://root.cern/root/html534/TSystem.html,1,['load'],['loaded']
Performance,"value. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded, -1 in case lib does not exist; or in case of error and -2 in case of version mismatch.; When entry is specified the loaded lib is; searched for this entry point (return -1 when entry does not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Need to return the equivalent of LD_LIBRARY_PATH. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:34056,load,loaded,34056,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,3,['load'],['loaded']
Performance,"value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; TIterator*_varItr! do not persist; RooSetProxy_varList; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxym. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooMomentMorph(). RooMomentMorph(const char *name, const char *title, RooAbsReal& _m, const RooArgList& varList, const RooArgList& pdfList, const TVectorD& mrefpoints, const Setting& setting); CTOR. RooMomentMorph(const char *name, const char *title, RooAbsReal& _m, const RooArgList& varList, const RooArgList& pdfList, const RooArgList& mrefList, const Setting& setting); CTOR. RooMomentMorph(const RooMomentMorph& other, const char* name = 0). ~RooMomentMorph(). void initialize(). Double_t getVal(const RooArgSet* set = 0) const; Special version of getVal() overrides RooAbsReal::getVal() to save value of current normalization set. RooAbsPdf* sumPdf(const RooArgSet* nset). Double_t evaluate() const. int idxmin(const double& m) const. int idxmax(const double& m) const. TObject* clone(const char* newname) const; { return new RooMomentMorph(*this,newname); }. void setMode(const RooMomentMorph::Setting& setting); { _setting = setting; }. Bool_t selfNormalized() const; P.d.f is self normalized. CacheElem* getCache(const RooArgSet* nset) const. Int_t ij(const Int_t& i, const Int_t& j) const; { return (i*_varList.getSize()+j); }. » Last changed: Mon Dec 7 13:48:17 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMomentMorph.html:41136,Cache,CacheElem,41136,root/html526/RooMomentMorph.html,https://root.cern,https://root.cern/root/html526/RooMomentMorph.html,1,['Cache'],['CacheElem']
Performance,"value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* nset); Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:42750,perform,performance,42750,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['perform'],['performance']
Performance,"value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optional",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:43363,perform,performance,43363,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,2,['perform'],['performance']
Performance,"valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsSelfCachedPdf.html:2579,cache,cacheUniqueSuffix,2579,root/html532/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsSelfCachedPdf.html,1,['cache'],['cacheUniqueSuffix']
Performance,"valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCachedPdf.html:2143,cache,cacheUniqueSuffix,2143,root/html532/RooCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooCachedPdf.html,1,['cache'],['cacheUniqueSuffix']
Performance,"valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsSelfCachedPdf.html:2579,cache,cacheUniqueSuffix,2579,root/html528/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsSelfCachedPdf.html,2,['cache'],['cacheUniqueSuffix']
Performance,"valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCachedPdf.html:2143,cache,cacheUniqueSuffix,2143,root/html528/RooCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooCachedPdf.html,2,['cache'],['cacheUniqueSuffix']
Performance,"values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,unsigned int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction2Binding_double_unsigned_int_double_.html:32557,cache,cache,32557,root/html526/RooCFunction2Binding_double_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html526/RooCFunction2Binding_double_unsigned_int_double_.html,2,['cache'],['cache']
Performance,"values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_errorSymmetric error associated with current value; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; static RooRealVarSharedProperties_nullPropNull property; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; static Bool_t_printScientific; static Int_t_printSigDigits; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealVar.html:36326,cache,cache,36326,root/html526/RooRealVar.html,https://root.cern,https://root.cern/root/html526/RooRealVar.html,3,['cache'],['cache']
Performance,"values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsOptTestStatistic.html:36043,optimiz,optimizations,36043,root/html526/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsOptTestStatistic.html,3,['optimiz'],['optimizations']
Performance,"values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset); Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset); Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedPdf.html:41812,cache,cache,41812,root/html526/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedPdf.html,2,['cache'],['cache']
Performance,values; TArrayDfIndexValuesSorted index values; TObjArrayfLeavesDirect pointers to individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tfMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tfMaxClusterRange! Memory allocated for the cluster range.; Long64_tfMaxEntriesMaximum number of entries in case of circular buffers; Long64_tfMaxEntryLoopMaximum number of entries to process; Long64_tfMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tfNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tfNfill! Local for EntryLoop; TObject*fNotify! Object to be notified when loading a Tree; Int_tfPacketSize! Number of entries in one packet for parallel root; TVirtualTreePlayer*fPlayer! Pointer to current Tree player; Long64_tfReadEntry! Number of the entry being processed; Long64_tfSavedBytesNumber of autosaved bytes; Int_tfScanFieldNumber of runs before prompting in Scan; Int_tfTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tfTotBytesTotal number of bytes in all branches before compression; Long64_tfTotalBuffers! Total number of bytes in branch buffers; TBuffer*fTransientBuffer! Pointer to the current transient buffer.; TVirtualIndex*fTreeIndexPointer to the tree Index (if any); Int_tfUpdateUpdate frequency for EntryLoop; TList*fUserInfopointer to a list of user objects associated to this Tree; Double_tfWeightTree weight (see TTree::SetWeight); Long64_tfZipBytesTotal number of bytes in all branches after compression; static Int_tfgBranchStyleOld/New branch style; static Long64_tfgMaxTreeSizeMaximum size of a file containg a Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function d,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:32617,load,loading,32617,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,2,['load'],['loading']
Performance,"values; boolfPolynomialflag for polynomial functions; static doublefgEpsepsilon used in derivative calculation h ~ eps |p|. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; WrappedMultiTF1(TF1& f, unsigned int dim = 0). constructor from a function pointer to a TF1; If dim = 0 dimension is taken from TF1::GetNdim().; IN case of multi-dimensional function created using directly TF1 object the dimension; returned by TF1::GetNdim is always 1. The user must then pass the correct value of dim. virtual ~WrappedMultiTF1(). Destructor (no operations). Function pointer is not owned. { if (fOwnFunc && fFunc) delete fFunc; }. WrappedMultiTF1(const ROOT::Math::WrappedMultiTF1& rhs). Copy constructor. IMultiGenFunction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. unsigned int NDim() const; function dimension. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cached inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values (only the cached one in this class,leave unchanges those of TF1). unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter name (from TF1). void ParameterGradient(const double* x, const double* par, double* grad) const; evaluate the derivative of the function with respect to the parameters. void SetDerivPrecision(double eps); precision value used for calculating the derivative step-size; h = eps * |x|. The default is 0.001, give a smaller in case function changes rapidly. double GetDerivPrecision(); get precision value used for calculating the derivative step-size. const TF1 * GetFunction() const; method to retrieve the internal function pointer. { return fFunc; }. void SetAndCopyFunction(const TF1* f = 0); method to set a new function pointer and copy it inside.; By calling th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__WrappedMultiTF1.html:2960,cache,cached,2960,root/html534/ROOT__Math__WrappedMultiTF1.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__WrappedMultiTF1.html,2,['cache'],['cached']
Performance,"variables. ;  ; State _state;  ; RooRealMPFE * _updateMaster;  ! Update master ;  ; std::vector< bool > _valueChanged;  ! Flags if variable needs update on server-side ;  ; RooListProxy _vars;  Variables. ;  ; bool _verboseClient;  ; bool _verboseServer;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealMPFE.html:55874,Cache,Cache,55874,doc/master/classRooRealMPFE.html,https://root.cern,https://root.cern/doc/master/classRooRealMPFE.html,1,['Cache'],['Cache']
Performance,"variables. void CleanUpSelections(TParallelCoordRange* range); Clean up the selections from the ranges which could have been deleted; when a variable has been deleted. void DeleteSelection(TParallelCoordSelect* sel); Delete a selection. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute the distance from the TParallelCoord. void Draw(Option_t* options = """"); Draw the parallel coordinates graph. void ExecuteEvent(Int_t entry, Int_t px, Int_t py); Execute the corresponding entry. TParallelCoordSelect* GetCurrentSelection(); Return the selection currently being edited. TEntryList* GetEntryList(Bool_t sel = kTRUE); Get the whole entry list or one for a selection. Double_t GetGlobalMax(); return the global maximum. Double_t GetGlobalMin(); return the global minimum. Int_t GetNbins(); get the binning of the histograms. TParallelCoordSelect* GetSelection(const char* title); Get a selection from its title. TTree* GetTree(); return the tree if fTree is defined. If not, the method try to load the tree; from fTreeFileName. Double_t* GetVariable(const char* var); Get the variables values from its title. Double_t* GetVariable(Int_t i); Get the variables values from its index. void Init(); Initialise the data members of TParallelCoord. void Paint(Option_t* options = """"); Paint the parallel coordinates graph. void PaintEntries(TParallelCoordSelect* sel = NULL); Loop over the entries and paint them. void RemoveVariable(TParallelCoordVar* var); Delete a variable from the graph. TParallelCoordVar* RemoveVariable(const char* var); Delete the variable ""vartitle"" from the graph. void ResetTree(); Reset the tree entry list to the initial one.. void SaveEntryLists(const char* filename = """", Bool_t overwrite = kFALSE); Save the entry lists in a root file ""filename.root"". void SavePrimitive(ostream& out, Option_t* options); Save the TParallelCoord in a macro. void SaveTree(const char* filename = """", Bool_t overwrite = kFALSE); Save the tree in a file if fTreeFileName == """". void SetAxesP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TParallelCoord.html:14792,load,load,14792,root/html530/TParallelCoord.html,https://root.cern,https://root.cern/root/html530/TParallelCoord.html,3,['load'],['load']
Performance,"variables. void CleanUpSelections(TParallelCoordRange* range); Clean up the selections from the ranges which could have been deleted; when a variable has been deleted. void DeleteSelection(TParallelCoordSelect* sel); Delete a selection. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute the distance from the TParallelCoord. void Draw(Option_t* options = """"); Draw the parallel coordinates graph. void ExecuteEvent(Int_t entry, Int_t px, Int_t py); Execute the corresponding entry. TParallelCoordSelect* GetCurrentSelection(); Return the selection currently being edited. TEntryList* GetEntryList(Bool_t sel = kTRUE); Get the whole entry list or one for a selection. Double_t GetGlobalMax(); return the global maximum. Double_t GetGlobalMin(); return the global minimum. Int_t GetNbins(); get the binning of the histograms. TParallelCoordSelect* GetSelection(const char* title); Get a selection from its title. TTree* GetTree(); return the tree if fTree is defined. If not, the method try to load the tree; from fTreeFileName. Double_t* GetVariable(const char* var); Get the variables values from its title. Double_t* GetVariable(Int_t i); Get the variables values from its index. void Init(); Initialise the data members of TParallelCoord. void Paint(Option_t* options = """"); Paint the parallel coordinates graph. void PaintEntries(TParallelCoordSelect* sel = __null); Loop over the entries and paint them. void RemoveVariable(TParallelCoordVar* var); Delete a variable from the graph. TParallelCoordVar* RemoveVariable(const char* var); Delete the variable ""vartitle"" from the graph. void ResetTree(); Reset the tree entry list to the initial one.. void SaveEntryLists(const char* filename = """", Bool_t overwrite = kFALSE); Save the entry lists in a root file ""filename.root"". void SavePrimitive(ostream& out, Option_t* options); Save the TParallelCoord in a macro. void SaveTree(const char* filename = """", Bool_t overwrite = kFALSE); Save the tree in a file if fTreeFileName == """". void SetAxe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TParallelCoord.html:15477,load,load,15477,root/html602/TParallelCoord.html,https://root.cern,https://root.cern/root/html602/TParallelCoord.html,2,['load'],['load']
Performance,"vas (if exist); TClassMenuItem*fSelectedMenuItemselected class menu item; TFunction*fSelectedMethodselected method; TObject*fSelectedObjectselected object; TVirtualPad*fSelectedPadselected pad (if exist); TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TContextMenu(const char* name, const char* title = ""Context sensitive popup menu""); Create a context menu. ~TContextMenu(); Destroy a context menu. void Action(TObject* object, TMethod* method); Action to be performed when this menu item is selected.; If the selected method requires arguments we popup an; automatically generated dialog, otherwise the method is; directly executed. void Action(TClassMenuItem* classmenuitem); Action to be performed when this menu item is selected.; If the selected method requires arguments we popup an; automatically generated dialog, otherwise the method is; directly executed. void Action(TObject* object, TToggle* toggle); Action to be performed when this toggle menu item is selected. const char * CreateArgumentTitle(TMethodArg* argument); Create string describing argument (for use in dialog box). const char * CreateDialogTitle(TObject* object, TFunction* method); Create title for dialog box retrieving argument values. const char * CreatePopupTitle(TObject* object); Create title for popup menu. void Execute(TObject* object, TFunction* method, const char* params); Execute method with specified arguments for specified object. void Execute(TObject* object, TFunction* method, TObjArray* params); Execute method with specified arguments for specified object. void Popup(Int_t x, Int_t y, TObject* obj, TVirtualPad* c = 0, TVirtualPad* p = 0); Popup context menu at given location in canvas c and pad p for selected; object. void Popup(Int_t x, Int_t y, TObject* obj, TBrowser* b); Popup context menu at given location in browser b for selected object. TContextMenu(const TContextMenu& ). TContextMenu& operator=(const TConte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TContextMenu.html:8544,perform,performed,8544,root/html528/TContextMenu.html,https://root.cern,https://root.cern/root/html528/TContextMenu.html,6,['perform'],['performed']
Performance,"vas). ; Definition at line 2426 of file RInterface.hxx. ◆ Range() [1/2]. template<typename Proxied , typename DataSource = void> . RInterface< RDFDetail::RRange< Proxied >, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::Range ; (; unsigned int ; begin, . unsigned int ; end, . unsigned int ; stride = 1 . ). inline . Creates a node that filters entries based on range: [begin, end). ; Parameters. [in]beginInitial entry number considered for this range. ; [in]endFinal entry number (excluded) considered for this range. 0 means that the range goes until the end of the dataset. ; [in]strideProcess one entry of the [begin, end) range every stride entries. Must be strictly greater than 0. . Returnsthe first node of the computation graph for which the event loop is limited to a certain range of entries.; Note that in case of previous Ranges and Filters the selected range refers to the transformed dataset. Ranges are only available if EnableImplicitMT has not been called. Multi-thread ranges are not supported. Example usage:; auto d_0_30 = d.Range(0, 30); // Pick the first 30 entries; auto d_15_end = d.Range(15, 0); // Pick all entries from 15 onwards; auto d_15_end_3 = d.Range(15, 0, 3); // Stride: from event 15, pick an event every 3. Definition at line 1570 of file RInterface.hxx. ◆ Range() [2/2]. template<typename Proxied , typename DataSource = void> . RInterface< RDFDetail::RRange< Proxied >, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::Range ; (; unsigned int ; end). inline . Creates a node that filters entries based on range. ; Parameters. [in]endFinal entry number (excluded) considered for this range. 0 means that the range goes until the end of the dataset. . Returnsa node of the computation graph for which the range is defined.; See the other Range overload for a detailed description. ; Definition at line 1591 of file RInterface.hxx. ◆ Redefine() [1/2]. template<typename Proxied , typename DataSource = void> . template<typename F , std::enable_if_t<!std",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:114020,Multi-thread,Multi-thread,114020,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['Multi-thread'],['Multi-thread']
Performance,"vas.h:23; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::DrawLatexTLatex * DrawLatex(Double_t x, Double_t y, const char *text)Make a copy of this object with the new parameters And copy object attributes.Definition TLatex.cxx:1943; TObject::SaveAsvirtual void SaveAs(const char *filename="""", Option_t *option="""") constSave this object in the file specified by filename.Definition TObject.cxx:692; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; TText::SetNDCvirtual void SetNDC(Bool_t isNDC=kTRUE)Set NDC mode on if isNDC = kTRUE, off otherwise.Definition TText.cxx:823; ROOT::RDF::Experimental::AddProgressBarvoid AddProgressBar(ROOT::RDF::RNode df)Add ProgressBar to a ROOT::RDF::RNode.Definition RDFHelpers.cxx:373; ROOT::VecOpsDefinition TCollectionProxyInfo.h:42; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; df102_NanoAODDimuonAnalysisDefinition df102_NanoAODDimuonAnalysis.py:1; ; |> | [Elapsed time: 0:03m processing file: 1 / 1 processed evts: 1000 / 46836615 2.58e+02 evt/s 50:21:12h remaining time (per file being processed)] ; |====================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html:4679,multi-thread,multi-threading,4679,doc/master/df102__NanoAODDimuonAnalysis_8C.html,https://root.cern,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html,1,['multi-thread'],['multi-threading']
Performance,"vas; static TSlave::EStatusBitsTSlave::kOutputRequested; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TSlave::ESlaveTypeTSlave::kSlave; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTSlave::fArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tTSlave::fBytesReadbytes read by slave (info is obtained from slave); Float_tTSlave::fCpuTimeCPU time spent executing commands (info obtained from slave); TStringTSlave::fGroupslave's group id; TStringTSlave::fImageslave's image name; TFileHandler*TSlave::fInputinput handler related to this slave; TStringTSlave::fMsdmass storage domain of slave; TStringTSlave::fNameslave's hostname; TStringTSlave::fOrdinalslave's ordinal number; Int_tTSlave::fParallelnumber of active slaves; Int_tTSlave::fPerfIdxrelative CPU performance index; Int_tTSlave::fPortslave's port number; TProof*TSlave::fProofproof cluster to which slave belongs; TStringTSlave::fProofWorkDirbase proofserv working directory (info obtained from slave); Int_tTSlave::fProtocolslave's protocol level; TStringTSlave::fROOTVersROOT version run by worker; Float_tTSlave::fRealTimereal time spent executing commands (info obtained from slave); TStringTSlave::fSessionTagunique tag for ths worker process; TSlave::ESlaveTypeTSlave::fSlaveTypetype of slave (either kMaster or kSlave); TSocket*TSlave::fSocketsocket to slave; Int_tTSlave::fStatusremote return status; TStringTSlave::fUserslave's user id; TStringTSlave::fWorkDirslave's working directory (info obtained from slave). private:. TSignalHandler*fIntHandlerinterrupt signal handler (ctrl-c); Bool_tfValid. Class Charts. Inheritance Chart:. TObject. ←; TSlave. ←; TSlaveLite. Function documentation; void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). TSlaveLite(const char* ord, Int_t perf, const char* image, TProof* pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSlaveLite.html:8376,perform,performance,8376,root/html602/TSlaveLite.html,https://root.cern,https://root.cern/root/html602/TSlaveLite.html,2,['perform'],['performance']
Performance,"vas; static TSlave::EStatusBitsTSlave::kOutputRequested; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TSlave::ESlaveTypeTSlave::kSlave; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTSlave::fArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tTSlave::fBytesReadbytes read by slave (info is obtained from slave); Float_tTSlave::fCpuTimeCPU time spent executing commands (info obtained from slave); TStringTSlave::fGroupslave's group id; TStringTSlave::fImageslave's image name; TFileHandler*TSlave::fInputinput handler related to this slave; TStringTSlave::fMsdmass storage domain of slave; TStringTSlave::fNameslave's hostname; TStringTSlave::fOrdinalslave's ordinal number; Int_tTSlave::fParallelnumber of active slaves; Int_tTSlave::fPerfIdxrelative CPU performance index; Int_tTSlave::fPortslave's port number; TProof*TSlave::fProofproof cluster to which slave belongs; TStringTSlave::fProofWorkDirbase proofserv working directory (info obtained from slave); Int_tTSlave::fProtocolslave's protocol level; TStringTSlave::fROOTVersROOT version run by worker; Float_tTSlave::fRealTimereal time spent executing commands (info obtained from slave); TStringTSlave::fSessionTagunique tag for ths worker process; TSlave::ESlaveTypeTSlave::fSlaveTypetype of slave (either kMaster or kSlave); TSocket*TSlave::fSocketsocket to slave; Int_tTSlave::fStatusremote return status; TStringTSlave::fUserslave's user id; TStringTSlave::fWorkDirslave's working directory (info obtained from slave). private:. TSignalHandler*fIntHandlerinterrupt signal handler (ctrl-c); Int_tfNWrksNumber of workers when submaster in remote plite; Bool_tfValid. Class Charts. Inheritance Chart:. TObject. ←; TSlave. TXHandler. ←; TXSlave. Function documentation; void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXSlave.html:8537,perform,performance,8537,root/html602/TXSlave.html,https://root.cern,https://root.cern/root/html602/TXSlave.html,2,['perform'],['performance']
Performance,"vasImp; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Types; using PadPaintingReady_t = std::function< void(TPadWebSnapshot *)>;  Function called when pad painting produced. ;  . Protected Member Functions; void AddColorsPalette (TPadWebSnapshot &master);  Add special canvas objects with list of colors and color palette. ;  ; void AddCtrlMsg (unsigned connid, const std::string &key, const std::string &value);  Add control message for specified connection Same control message can be overwritten many time before it really sends to the client If connid == 0, message will be add to all connections After ctrl message is add to the output, short timer is activated and message send afterwards. ;  ; void AddCustomFonts (TPadWebSnapshot &master);  Add special canvas objects with custom fonts. ;  ; void AddSendQueue (unsigned connid, const std::string &msg);  Add message to send queue for specified connection If connid == 0, message will be add to all connections. ;  ; void AssignStatusBits (UInt_t bits);  Assign clients bits. ;  ; UInt_t CalculateColorsHash ();  Calculate hash function for all colors and palette. ;  ; virtual Bool_t CanCreateObject (const std::string &);  ; Bool_t CheckCanvasModified (bool force_modified=false);  Check if any pad on the canvas was modified If yes, increment version of correspondent pad Returns true when canvas really modified. ;  ; Bool_t CheckDataToSend (unsigned connid=0);  Check if any data should be send to client If connid != 0, only selected connection will be checked. ;  ; void CheckPadModified (TPad *pad);  Returns true if any pad in the canvas were modified Reset modified flags, increment canvas version (if inc_version is true) ;  ; void CreateObjectSnapshot (TPadWebSnapshot &master, TPad *pad, TObject *obj, const char *opt, TWebPS *masterps=nullptr);  Creates representation of the object for painting in web browser",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebCanvas.html:9421,queue,queue,9421,doc/master/classTWebCanvas.html,https://root.cern,https://root.cern/doc/master/classTWebCanvas.html,1,['queue'],['queue']
Performance,vate . Current number of training epochs without. ; considerable decrease in the test error. ; Definition at line 76 of file DLMinimizers.h. ◆ fConvergenceSteps. template<typename Architecture_t > . size_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fConvergenceSteps. private . Number of training epochs without considerable. ; decrease in the test error for convergence. ; Definition at line 74 of file DLMinimizers.h. ◆ fLearningRate. template<typename Architecture_t > . Scalar_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fLearningRate. private . Learning rate \(\alpha\). ; Definition at line 81 of file DLMinimizers.h. ◆ fMinimumError. template<typename Architecture_t > . Scalar_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fMinimumError. private . The minimum loss achieved on the training set during the current training session. ; Definition at line 82 of file DLMinimizers.h. ◆ fStepCount. template<typename Architecture_t > . size_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fStepCount. private . Number of steps performed in the current training session. ; Definition at line 73 of file DLMinimizers.h. ◆ fTestError. template<typename Architecture_t > . Scalar_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fTestError. private . Holds the most recently computed test loss. ; Definition at line 80 of file DLMinimizers.h. ◆ fTestInterval. template<typename Architecture_t > . size_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fTestInterval. private . Interval for the computation of the test error. ; Definition at line 78 of file DLMinimizers.h. ◆ fTrainingError. template<typename Architecture_t > . Scalar_t TMVA::DNN::TDLGradientDescent< Architecture_t >::fTrainingError. private . Holds the most recently computed training loss. ; Definition at line 79 of file DLMinimizers.h. tmva/tmva/inc/TMVA/DNN/DLMinimizers.h. TMVADNNTDLGradientDescent. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:46 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html:12632,perform,performed,12632,doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,1,['perform'],['performed']
Performance,"vate . ◆ Cross() [2/3]. template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . template<class OtherCoords > . DisplacementVector3D ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::Cross ; (; const DisplacementVector3D< OtherCoords, Tag > & ; v); const. inline . Return vector (cross) product of two displacement vectors, as a vector in the coordinate system of this class. ; It is possible to perform the product for any type of vector coordinates, but they must have the same coordinate system tag ; Definition at line 423 of file DisplacementVector3D.h. ◆ Cross() [3/3]. template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . template<class OtherVector > . DisplacementVector3D ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::Cross ; (; const OtherVector & ; v); const. inline . Return vector (cross) product of two vectors, as a vector in the coordinate system of this class. ; It is possible to perform the product for any classes implementing X(), Y() and Z() member functions ; Definition at line 437 of file DisplacementVector3D.h. ◆ Dimension(). template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . unsigned int ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::Dimension ; (; ); const. inline . Dimension. ; Definition at line 273 of file DisplacementVector3D.h. ◆ Dot() [1/3]. template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . template<class OtherCoords , class OtherTag > . Scalar ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::Dot ; (; const DisplacementVector3D< OtherCoords, OtherTag > & ; ); const. private . ◆ Dot() [2/3]. template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . template<class OtherCoords > . Scalar ROOT::Math::DisplacementVector3D< CoordSystem, Tag >::Dot ; (; const DisplacementVector3D< OtherCoords, Tag > & ; v); const. inline . Return the scalar (dot) product of two displacement vectors. ; It is possible to perform the product for any type of vector c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1DisplacementVector3D.html:15059,perform,perform,15059,doc/master/classROOT_1_1Math_1_1DisplacementVector3D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1DisplacementVector3D.html,1,['perform'],['perform']
Performance,"vative(double x) const; return the function derivatives w.r.t. x. double DoParameterDerivative(double x, const double* p, unsigned int ipar) const; evaluate the derivative of the function with respect to the parameters; IMPORTANT NOTE: TF1::GradientPar returns 0 for fixed parameters to avoid computing useless derivatives; BUT the TLinearFitter wants to have the derivatives also for fixed parameters.; so in case of fLinear (or fPolynomial) a non-zero value will be returned for fixed parameters. void SetDerivPrecision(double eps); { fgEps = eps; }. double GetDerivPrecision(); { return fgEps; }. virtual ~WrappedTF1(). Destructor (no operations). TF1 Function pointer is not owned. {}. ROOT::Math::IGenFunction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cachen inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values (only the cached one in this class,leave unchanges those of TF1). unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter name (this is stored in TF1). void FdF(double x, double& f, double& deriv) const; calculate function and derivative at same time (required by IGradient interface). double DoEvalPar(double x, const double* p) const; evaluate function passing coordinates x and vector of parameters. double DoEval(double x) const; evaluate function using the cached parameter values of this class (not of TF1); re-implement for better efficiency. » Author: L. Moneta Wed Sep 6 09:52:26 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id$ » Last generated: 2015-06-30 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__WrappedTF1.html:5177,cache,cached,5177,root/html602/ROOT__Math__WrappedTF1.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__WrappedTF1.html,2,['cache'],['cached']
Performance,"vdata is an std::vector containing the data; TUnuranEmpDist dist(vdata.begin(),vdata.end());; unr.Init(dist);; // sample N times (generate N random numbers); for (int i = 0; i<N; ++i); double x = unr.Sample();. For some predefined distributions, like Poisson and Binomial, one can use directly a function in the TUnuran class. This is more convenient in passing distribution parameters than using directly the string interface. TUnuran unr;; // Initialize unuran to generate normal random numbers from the; // Poisson distribution with parameter mu; unr.InitPoisson(mu);; ...; // Sample distributions N times (generate N random numbers); for (int i = 0; i<N; ++i); int k = unr.SampleDiscr();; Functionality is also provided via the C++ classes for using a different random number generator by passing a TRandom pointer when constructing the TUnuran class (by default the ROOT gRandom is passed to UNURAN).; 13.4.9 Performances of Random Numbers; Here are the CPU times obtained using the four random classes on an lxplus machine with an Intel 64 bit architecture and compiled using gcc 3.4:. TRandom (ns/call); TRandom1 (ns/call); TRandom2 (ns/call); TRandom3 (ns/call). Rndm(). 6; 9. Gaus(); 31; 161; 35; 42. Rannor(); 116; 216; 126; 130. Poisson(m-10); 147; 1161; 162; 239. Poisson(m=10) UNURAN; 80; 294; 89; 99. 13.5 Mathematical Functions; The mathematical functions are present in both MathCore and MathMore libraries. All mathematical functions are implemented as free functions in the namespace ROOT::Math. The most used functions are in the MathCore library while the others are in the MathMore library. The functions in MathMore are all using the implementation of the GNU Scientific Library (GSL). The naming of the special functions is the same defined in the C++ Technical Report on Standard Library extensions. The special functions are defined in the header file Math/SpecFunc.h.; 13.5.1 Special Functions in MathCore. ROOT::Math::beta(double x,double y) -evaluates the beta function: \",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:675590,Perform,Performances,675590,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Perform'],['Performances']
Performance,"ve components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Attributes; bool _doFast = false;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOpt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVoigtian.html:71563,Cache,CacheMode,71563,doc/master/classRooVoigtian.html,https://root.cern,https://root.cern/doc/master/classRooVoigtian.html,1,['Cache'],['CacheMode']
Performance,"ve from the cache the binaries associated with the file TProof::kCpBin; must be set in cpopt; the default is copy everything.; Returns kTRUE in case file needs to be send, returns kFALSE in case; file is already on remote node. Int_t SendFile(const char* file, Int_t opt = (kBinary | kForward | kCp | kCpBin), const char* rfile = 0, TSlave* sl = 0); Send a file to master or slave servers. Returns number of slaves; the file was sent to, maybe 0 in case master and slaves have the same; file system image, -1 in case of error.; If defined, send to worker 'wrk' only.; If defined, the full path of the remote path will be rfile.; If rfile = ""cache"" the file is copied to the remote cache instead of the sandbox; (to copy to the cache on a different name use rfile = ""cache:newname"").; The mask 'opt' is an or of ESendFileOpt:. kAscii (0x0) if set true ascii file transfer is used; kBinary (0x1) if set true binary file transfer is used; kForce (0x2) if not set an attempt is done to find out; whether the file really needs to be downloaded; (a valid copy may already exist in the cache; from a previous run); the bit is set by; UploadPackage, since the check is done elsewhere.; kForward (0x4) if set, ask server to forward the file to slave; or submaster (meaningless for slave servers).; kCpBin (0x8) Retrieve from the cache the binaries associated; with the file; kCp (0x10) Retrieve the files from the cache. Int_t Echo(const TObject* obj); Sends an object to master and workers and expect them to send back a; message with the output of its TObject::Print(). Returns -1 on error, the; number of workers that received the objects on success. Int_t Echo(const char* str); Sends a string to master and workers and expect them to echo it back to; the client via a message. It is a special case of the generic Echo(); that works with TObjects. Returns -1 on error, the number of workers that; received the message on success. Int_t SendObject(const TObject* obj, TProof::ESlaves list = kActive); Send o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:67996,cache,cache,67996,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,2,['cache'],['cache']
Performance,"ve integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfIter! Iterator over PDF list; RooListProxy_pdfListList of component PDFs; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooObjCacheManager_projCacheMgrManager of cache with coefficient projections and transformations; Bool_t_projectCoefsIf true coefficients need to be projected for use in evaluate(); RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_t_recursiveFlag indicating is fractions are treated recursively; RooSetProxy_refCoefNormReference observable set for coefficient interpretation; TNamed*_refCoefRangeNameReference range name for coefficient interpreation; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooArgList*_snormList! List of supplemental normalization factors; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddPdf.html:44245,cache,cache,44245,root/html534/RooAddPdf.html,https://root.cern,https://root.cern/root/html534/RooAddPdf.html,1,['cache'],['cache']
Performance,"ve integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfIter! Iterator over PDF list; RooListProxy_pdfListList of component PDFs; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooObjCacheManager_projCacheMgrManager of cache with coefficient projections and transformations; Bool_t_projectCoefsIf true coefficients need to be projected for use in evaluate(); RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_t_recursiveFlag indicating is fractions are treated recursively; RooSetProxy_refCoefNormReference observable set for coefficient interpretation; TNamed*_refCoefRangeNameReference range name for coefficient interpreation; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooArgList*_snormList! List of supplemental normalization factors; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current va",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddPdf.html:45911,cache,cache,45911,root/html602/RooAddPdf.html,https://root.cern,https://root.cern/root/html602/RooAddPdf.html,2,['cache'],['cache']
Performance,"ve not been created they are created; automatically when the params pointer is not zero. bool FitFCN(const ROOT::Math::IMultiGradFunction & fcn, const double * params = 0, unsigned int dataSize = 0). Fit using the given FCN function representing a multi-dimensional gradient function; interface (ROOT::Math::IMultiGradFunction). In this case the minimizer will use the; gradient information provided by the function.; For the other arguments same consideration as in the previous method. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer(). return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only after",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Fit__Fitter.html:5675,perform,perform,5675,root/html526/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html526/ROOT__Fit__Fitter.html,1,['perform'],['perform']
Performance,"ve or load workspace with pdf; # -----------------------------------------------------------------------------------; ; # Make/load workspace, here in mode 1; w = getWorkspace(mode); if mode == 1:; # Show workspace that was created; w.Print(); ; # Show plot of cached integral values; hhcache = w.expensiveObjectCache().getObj(1); if hhcache:; ROOT.TCanvas(""rf903_numintcache"", ""rf903_numintcache"", 600, 600); hhcache.createHistogram(""a"").Draw(); else:; ROOT.RooFit.Error(""rf903_numintcache"", ""Cached histogram is not existing in workspace""); sys.exit(); ; # Use pdf from workspace for generation and fitting; # -----------------------------------------------------------------------------------; ; # ROOT.This is always slow (need to find maximum function value; # empirically in 3D space); model = w[""model""]; d = model.generate({w[""x""], w[""y""], w[""z""]}, 1000); ; # ROOT.This is slow in mode 0, fast in mode 1; model.fitTo(d, Verbose=True, Timer=True, PrintLevel=-1); ; # Projection on x (always slow as 2D integral over Y, at fitted value of a; # is not cached); framex = w[""x""].frame(Title=""Projection of 3D model on X""); d.plotOn(framex); model.plotOn(framex); ; # Draw x projection on canvas; c = ROOT.TCanvas(""rf903_numintcache"", ""rf903_numintcache"", 600, 600); framex.Draw(); ; c.SaveAs(""rf903_numintcache.png""); ; # Make workspace available on command line after macro finishes; ROOT.gDirectory.Add(w); Drawth1 Draw(); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y,z]) using numeric integrator RooAdaptiveIntegratorND to calculate Int(x,y,z); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_over_model_Int[x,y,z]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_over_model_Int[x,y,z]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf903__numintcache_8py.html:3203,cache,cached,3203,doc/master/rf903__numintcache_8py.html,https://root.cern,https://root.cern/doc/master/rf903__numintcache_8py.html,1,['cache'],['cached']
Performance,"ve the partial results; Bool_tTProofPlayer::fSaveResultsPerPacketWhether to save partial results after each packet; TStatus*TProofPlayer::fSelStatus! status of query in progress; TSelector*TProofPlayer::fSelector! the latest selector; TClass*TProofPlayer::fSelectorClass! class of the latest selector; TStringTProofPlayerRemote::fSelectorFileNameCurrent Selector's name, set by Process(); Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TTimer*TProofPlayer::fStopTimerTimer associated with a stop request; TMutex*TProofPlayer::fStopTimerMtxTo protect the stop timer; Long64_tTProofPlayer::fTotalEventsnumber of events requested; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static THashList*TProofPlayer::fgDrawInputParsList of input parameters to be kept on drawing actions. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t MakeSelector(const char* selfile); Create the selector object and save the relevant files and binary information; in the cache so that the worker can pick it up.; Returns 0 and fill fSelector in case of success. Returns -1 and sets; fSelector to 0 in case of failure. Long64_t Process(TDSet* set, TSelector* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF.; This method is called on client and on the PROOF master.; The return value is -1 in case of an error and TSelector::GetStatus() in; in case of success. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF.; This method is called on client and on the PROOF master.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); Finalize a query.; Returns -1 in case error, 0 otherwise. Bool_t HandleTimer(TTimer* timer); Send feedback objects ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerLite.html:18849,cache,cache,18849,root/html602/TProofPlayerLite.html,https://root.cern,https://root.cern/root/html602/TProofPlayerLite.html,2,['cache'],['cache']
Performance,"ve(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRFIOFile.html:12910,cache,cache,12910,root/html532/TRFIOFile.html,https://root.cern,https://root.cern/root/html532/TRFIOFile.html,1,['cache'],['cache']
Performance,"ve(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static voidSetOnError(TDCacheFile::OnErrorAction = kOnErrorDefault); static Bool_tTF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDCacheFile.html:12264,cache,cache,12264,root/html532/TDCacheFile.html,https://root.cern,https://root.cern/root/html532/TDCacheFile.html,1,['cache'],['cache']
Performance,"veAsMultiGraph() [1/2]. TMultiGraph * TMVA::Factory::GetROCCurveAsMultiGraph ; (; DataLoader * ; loader, . UInt_t ; iClass, . Types::ETreeType ; type = Types::kTesting . ). Generate a collection of graphs, for all methods for a given class. ; Suitable for comparing method performance.; Argument iClass specifies the class to generate the ROC curve in a multiclass setting. It is ignored for binary classification.; NOTE: The ROC curve is 1 vs. all where the given class is considered signal and the others considered background. This is ok in binary classification but in in multi class classification, the ROC surface is an N dimensional shape, where N is number of classes - 1. ; Definition at line 988 of file Factory.cxx. ◆ GetROCCurveAsMultiGraph() [2/2]. TMultiGraph * TMVA::Factory::GetROCCurveAsMultiGraph ; (; TString ; datasetname, . UInt_t ; iClass, . Types::ETreeType ; type = Types::kTesting . ). Generate a collection of graphs, for all methods for a given class. ; Suitable for comparing method performance.; Argument iClass specifies the class to generate the ROC curve in a multiclass setting. It is ignored for binary classification.; NOTE: The ROC curve is 1 vs. all where the given class is considered signal and the others considered background. This is ok in binary classification but in in multi class classification, the ROC surface is an N dimensional shape, where N is number of classes - 1. ; Definition at line 1005 of file Factory.cxx. ◆ GetROCIntegral() [1/2]. Double_t TMVA::Factory::GetROCIntegral ; (; TMVA::DataLoader * ; loader, . TString ; theMethodName, . UInt_t ; iClass = 0, . Types::ETreeType ; type = Types::kTesting . ). Calculate the integral of the ROC curve, also known as the area under curve (AUC), for a given method. ; Argument iClass specifies the class to generate the ROC curve in a multiclass setting. It is ignored for binary classification. ; Definition at line 849 of file Factory.cxx. ◆ GetROCIntegral() [2/2]. Double_t TMVA::Factory::GetROCIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory.html:30436,perform,performance,30436,doc/master/classTMVA_1_1Factory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory.html,1,['perform'],['performance']
Performance,"veCalo3DGL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tAlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidDrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* ps, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tSupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveCalo3DGL.html:1781,cache,cached,1781,root/html528/TEveCalo3DGL.html,https://root.cern,https://root.cern/root/html528/TEveCalo3DGL.html,3,['cache'],['cached']
Performance,"veElement; static const char * ToString (Bool_t b);  Convert Bool_t to string - kTRUE or kFALSE. ;  . #include <TEveEventManager.h>. Inheritance diagram for TEveEventManager:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TEveEventManager(). TEveEventManager::TEveEventManager ; (; const char * ; n = ""TEveEventManager"", . const char * ; t = """" . ). Constructor. ; Definition at line 26 of file TEveEventManager.cxx. ◆ ~TEveEventManager(). TEveEventManager::~TEveEventManager ; (; ). inlineoverride . Definition at line 26 of file TEveEventManager.h. Member Function Documentation. ◆ AddNewEventCommand(). void TEveEventManager::AddNewEventCommand ; (; const TString & ; cmd). virtual . Register a command to be executed on each new event. ; Definition at line 48 of file TEveEventManager.cxx. ◆ AfterNewEventLoaded(). void TEveEventManager::AfterNewEventLoaded ; (; ). virtual . Virtual function to be called after a new event is loaded. ; It iterates over the list of registered commands (fNewEventCommands) and executes them in given order. ; Definition at line 37 of file TEveEventManager.cxx. ◆ Class(). static TClass * TEveEventManager::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TEveEventManager::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TEveEventManager::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 42 of file TEveEventManager.h. ◆ ClearNewEventCommands(). void TEveEventManager::ClearNewEventCommands ; (; ). virtual . Clear the list of commands to be executed on each new event. ; Definition at line 70 of file TEveEventManager.cxx. ◆ Close(). virtual void TEveEventManager::Close ; (; ). inlinevirtual . Definition at line 34 of file TEveEventManager.h. ◆ DeclFileName(). static const char * TEveEventManager::DeclFileName ; (; ). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveEventManager.html:34400,load,loaded,34400,doc/master/classTEveEventManager.html,https://root.cern,https://root.cern/doc/master/classTEveEventManager.html,1,['load'],['loaded']
Performance,"veObjectCache::ExpensiveObjectExpensiveObject(const RooExpensiveObjectCache::ExpensiveObject&); RooExpensiveObjectCache::ExpensiveObjectExpensiveObject(Int_t uid, const RooExpensiveObjectCache::ExpensiveObject& other); RooExpensiveObjectCache::ExpensiveObjectExpensiveObject(Int_t uid, const char* ownerName, TObject& payload, TIterator* paramIter); virtual TClass*IsA() const; Bool_tmatches(TClass* tc, const RooArgSet& params); RooExpensiveObjectCache::ExpensiveObject&operator=(const RooExpensiveObjectCache::ExpensiveObject&); const char*ownerName() const; const TObject*payload() const; TObject*payload(); voidprint(); voidsetPayload(TObject* obj); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Int_tuid() const. Data Members; protected:. map<TString,Int_t>_catRefParamsNames and values of discrete-valued reference parameters; TString_ownerNameName of RooAbsArg object that is associated to cache contents; TObject*_payloadPayload; map<TString,Double_t>_realRefParamsNames and values of real-valued reference parameters; Int_t_uidUnique element ID ;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ExpensiveObject(Int_t uid, const char* ownerName, TObject& payload, TIterator* paramIter); Construct ExpensiveObject oject for inPayLoad and store reference values; for all RooAbsReal and RooAbsCategory parameters in params. ExpensiveObject(Int_t uid, const RooExpensiveObjectCache::ExpensiveObject& other). ~ExpensiveObject(). Bool_t matches(TClass* tc, const RooArgSet& params); Check object type ;. void print(). ExpensiveObject(); { _uid = 0 ; _payload = 0 ; }. ExpensiveObject(Int_t uid, const char* ownerName, TObject& payload, TIterator* paramIter). Int_t uid() const; { return _uid ; }. const TObject* payload() const; { return _payload ; }. TObject* payload(); { return _payload ; }. void setPayload(TObject* obj); { _payload = obj ; }. const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExpensiveObjectCache__ExpensiveObject.html:1846,cache,cache,1846,root/html602/RooExpensiveObjectCache__ExpensiveObject.html,https://root.cern,https://root.cern/root/html602/RooExpensiveObjectCache__ExpensiveObject.html,2,['cache'],['cache']
Performance,"veRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t, TFile::ERelativeTo = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); static voidTXMLSetup::SetNameSpaceBase(const char* namespacebase); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLFile.html:13849,cache,cache,13849,root/html528/TXMLFile.html,https://root.cern,https://root.cern/root/html528/TXMLFile.html,1,['cache'],['cache']
Performance,"veSnapshot(""reference_fit"", params, True); ; # Make another fit with the signal componentforced to zero; # and save those parameters too; ; bkgfrac.setVal(1); bkgfrac.setConstant(True); bkgfrac.removeError(); model.fitTo(refData, PrintLevel=-1); ; w.saveSnapshot(""reference_fit_bkgonly"", params, True); ; ; # Create model and dataset; # -----------------------------------------------; ; w = ROOT.RooWorkspace(""w""); fillWorkspace(w); ; # Exploit convention encoded in named set ""parameters"" and ""observables""; # to use workspace contents w/o need for introspected; model = w[""model""]; ; # Generate data from p.d.f. in given observables; data = model.generate(w.set(""observables""), 1000); ; # Fit model to data; model.fitTo(data, PrintLevel=-1); ; # Plot fitted model and data on frame of first (only) observable; frame = (w.set(""observables"").first()).frame(); data.plotOn(frame); model.plotOn(frame); ; # Overlay plot with model with reference parameters as stored in snapshots; w.loadSnapshot(""reference_fit""); model.plotOn(frame, LineColor=""r""); w.loadSnapshot(""reference_fit_bkgonly""); model.plotOn(frame, LineColor=""r"", LineStyle=""--""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf510_wsnamedsets"", ""rf503_wsnamedsets"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf510_wsnamedsets.png""); ; # Print workspace contents; w.Print(); ; # Workspace will remain in memory after macro finishes; ROOT.gDirectory.Add(w); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectH",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf510__wsnamedsets_8py.html:4292,load,loadSnapshot,4292,doc/master/rf510__wsnamedsets_8py.html,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html,1,['load'],['loadSnapshot']
Performance,"vector); virtual TClass*IsA() const; RooQuasiRandomGenerator&operator=(const RooQuasiRandomGenerator&); voidreset(); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. Int_tadd(Int_t x, Int_t y) const; voidcalculateCoefs(UInt_t dimension); voidcalculateV(const int* px, int px_degree, int* pb, int* pb_degree, int* v, int maxv); Int_tmul(Int_t x, Int_t y) const; voidpolyMultiply(const int* pa, int pa_degree, const int* pb, int pb_degree, int* pc, int* pc_degree); Int_tsub(Int_t x, Int_t y) const. Data Members; public:. enum { MaxDimension; NBits; MaxDegree; MaxPrimitiveDegree; };. private:. static Int_t_cj[31][12]; static Bool_t_coefsCalculated; Int_t*_nextq; static const Int_t_polyDegree[13]; static const Int_t_primitivePoly[13][6]; Int_t_sequenceCount. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooQuasiRandomGenerator(); Perform one-time initialization of our static coefficient array if necessary; and initialize our workspace. ~RooQuasiRandomGenerator(); Destructor. void reset(); Reset the workspace to its initial state. Bool_t generate(UInt_t dimension, Double_t* vector); Generate the next number in the sequence for the specified dimension.; The maximum dimension supported is 12. void calculateCoefs(UInt_t dimension); Calculate the coefficients for the given number of dimensions. void calculateV(const int* px, int px_degree, int* pb, int* pb_degree, int* v, int maxv); Internal function. void polyMultiply(const int* pa, int pa_degree, const int* pb, int pb_degree, int* pc, int* pc_degree); Internal function. RooQuasiRandomGenerator(). Int_t add(Int_t x, Int_t y) const; Z_2 field operations. { return (x+y)%2; }. Int_t mul(Int_t x, Int_t y) const; { return (x*y)%2; }. Int_t sub(Int_t x, Int_t y) const; { return add(x,y); }. » Last changed: Mon Dec 7 13:48:48 2009 » Last generated: 2009-12-07 13:48; This page has been automatically ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooQuasiRandomGenerator.html:1936,Perform,Perform,1936,root/html526/RooQuasiRandomGenerator.html,https://root.cern,https://root.cern/root/html526/RooQuasiRandomGenerator.html,1,['Perform'],['Perform']
Performance,"vector< RooNormSetCache > _nsetCache;  ! Normalization/Integration set manager ;  ; std::vector< RooAbsCacheElement * > _object;  ! Payload ;  ; Int_t _size;  ! Actual use ;  ; bool _wired;  ! In wired mode, there is a single payload which is returned always ;  ;  Protected Attributes inherited from RooAbsCache; RooAbsArg * _owner;  Pointer to owning RooAbsArg. ;  . Static Protected Attributes; static bool _clearObsList;  Clear obslist on sterilize? ;  . #include <RooObjCacheManager.h>. Inheritance diagram for RooObjCacheManager:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooObjCacheManager() [1/2]. RooObjCacheManager::RooObjCacheManager ; (; RooAbsArg * ; owner = nullptr, . Int_t ; maxSize = 2, . bool ; clearCacheOnServerRedirect = true, . bool ; allowOptimize = false . ). Constructor of object cache manager for given owner. ; If clearCacheOnServerRedirect is true all cache elements will be cleared when a server redirect is intercepted by the cache manager. This is the default strategy and should only be overridden when you really understand what you're doing as properly implementing server redirect in cache elements can get very complicated, especially if there are (cyclical) reference back to the owning object ; Definition at line 47 of file RooObjCacheManager.cxx. ◆ RooObjCacheManager() [2/2]. RooObjCacheManager::RooObjCacheManager ; (; const RooObjCacheManager & ; other, . RooAbsArg * ; owner = nullptr . ). Copy constructor. ; Definition at line 59 of file RooObjCacheManager.cxx. ◆ ~RooObjCacheManager(). RooObjCacheManager::~RooObjCacheManager ; (; ). override . Destructor. ; Definition at line 71 of file RooObjCacheManager.cxx. Member Function Documentation. ◆ Class(). static TClass * RooObjCacheManager::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooObjCacheManager::Class_Name ; (; ). static . ReturnsName of this ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:7169,cache,cache,7169,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,2,['cache'],['cache']
Performance,"vector< const Browsable::RItem * > fLastSortedItems;  ! sorted child items, used in requests ;  ; std::string fLastSortMethod;  ! last sort method ;  ; bool fLastSortReverse {false};  ! last request reverse order ;  ; std::shared_ptr< Browsable::RElement > fTopElement;  ! top element ;  ; Browsable::RElementPath_t fWorkingPath;  ! path showed in Breadcrumb ;  . Friends; class RBrowserDataCleanup;  . #include <ROOT/RBrowserData.hxx>; Constructor & Destructor Documentation. ◆ RBrowserData() [1/2]. RBrowserData::RBrowserData ; (; ). Default constructor. ; Definition at line 68 of file RBrowserData.cxx. ◆ RBrowserData() [2/2]. ROOT::RBrowserData::RBrowserData ; (; std::shared_ptr< Browsable::RElement > ; elem). inline . Definition at line 63 of file RBrowserData.hxx. ◆ ~RBrowserData(). RBrowserData::~RBrowserData ; (; ). virtual . Destructor. ; Definition at line 78 of file RBrowserData.cxx. Member Function Documentation. ◆ ClearCache(). void RBrowserData::ClearCache ; (; ). Clear internal objects cache. ; Definition at line 370 of file RBrowserData.cxx. ◆ CreateDefaultElements(). void RBrowserData::CreateDefaultElements ; (; ). Create default elements shown in the RBrowser. ; Definition at line 108 of file RBrowserData.cxx. ◆ DecomposePath(). Browsable::RElementPath_t RBrowserData::DecomposePath ; (; const std::string & ; path, . bool ; relative_to_work_element . ). Decompose path to elements Returns array of names for each element in the path, first element either ""/"" or ""."" If returned array empty - it is error. ; Definition at line 155 of file RBrowserData.cxx. ◆ GetElement(). std::shared_ptr< Browsable::RElement > RBrowserData::GetElement ; (; const std::string & ; str). Returns element with path, specified as string. ; Definition at line 290 of file RBrowserData.cxx. ◆ GetElementFromTop(). std::shared_ptr< Browsable::RElement > RBrowserData::GetElementFromTop ; (; const Browsable::RElementPath_t & ; path). Returns element with path, specified as Browsable::RElemen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RBrowserData.html:4017,cache,cache,4017,doc/v632/classROOT_1_1RBrowserData.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RBrowserData.html,2,['cache'],['cache']
Performance,"ved class object.; 1354 switch (O) {; 1355 ; 1356 case EOptimizer::kSGD:; 1357 optimizer = std::unique_ptr<DNN::TSGD<Architecture_t, Layer_t, DeepNet_t>>(; 1358 new DNN::TSGD<Architecture_t, Layer_t, DeepNet_t>(settings.learningRate, deepNet, settings.momentum));; 1359 break;; 1360 ; 1361 case EOptimizer::kAdam: {; 1362 optimizer = std::unique_ptr<DNN::TAdam<Architecture_t, Layer_t, DeepNet_t>>(; 1363 new DNN::TAdam<Architecture_t, Layer_t, DeepNet_t>(; 1364 deepNet, settings.learningRate, settings.optimizerParams[""ADAM_beta1""],; 1365 settings.optimizerParams[""ADAM_beta2""], settings.optimizerParams[""ADAM_eps""]));; 1366 break;; 1367 }; 1368 ; 1369 case EOptimizer::kAdagrad:; 1370 optimizer = std::unique_ptr<DNN::TAdagrad<Architecture_t, Layer_t, DeepNet_t>>(; 1371 new DNN::TAdagrad<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate,; 1372 settings.optimizerParams[""ADAGRAD_eps""]));; 1373 break;; 1374 ; 1375 case EOptimizer::kRMSProp:; 1376 optimizer = std::unique_ptr<DNN::TRMSProp<Architecture_t, Layer_t, DeepNet_t>>(; 1377 new DNN::TRMSProp<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate, settings.momentum,; 1378 settings.optimizerParams[""RMSPROP_rho""],; 1379 settings.optimizerParams[""RMSPROP_eps""]));; 1380 break;; 1381 ; 1382 case EOptimizer::kAdadelta:; 1383 optimizer = std::unique_ptr<DNN::TAdadelta<Architecture_t, Layer_t, DeepNet_t>>(; 1384 new DNN::TAdadelta<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate,; 1385 settings.optimizerParams[""ADADELTA_rho""],; 1386 settings.optimizerParams[""ADADELTA_eps""]));; 1387 break;; 1388 }; 1389 ; 1390 ; 1391 // Initialize the vector of batches, one batch for one slave network; 1392 std::vector<TTensorBatch<Architecture_t>> batches{};; 1393 ; 1394 bool converged = false;; 1395 size_t convergenceCount = 0;; 1396 size_t batchesInEpoch = nTrainingSamples / deepNet.GetBatchSize();; 1397 ; 1398 // start measuring; 1399 std::chrono::time_point<std::chrono::system_clock> tstart, ten",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:54404,optimiz,optimizerParams,54404,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,2,['optimiz'],"['optimizer', 'optimizerParams']"
Performance,"ved, all nodes will be unlinked from root node and kept in memory. ;  ; void StoreStreamerElement (XMLNodePointer_t node, TStreamerElement *elem);  store data of single TStreamerElement in streamer node ;  ; Int_t SysClose (Int_t) final;  Interface to system close. All arguments like in POSIX close(). ;  ; Int_t SysOpen (const char *, Int_t, UInt_t) final;  Interface to system open. All arguments like in POSIX open(). ;  ; Int_t SysRead (Int_t, void *, Int_t) final;  Interface to system read. All arguments like in POSIX read(). ;  ; Long64_t SysSeek (Int_t, Long64_t, Int_t) final;  Interface to system lseek. ;  ; Int_t SysStat (Int_t, Long_t *, Long64_t *, Long_t *, Long_t *) final;  Return file stat information. ;  ; Int_t SysSync (Int_t) final;  Interface to system fsync. All arguments like in POSIX fsync(). ;  ; Int_t SysWrite (Int_t, const void *, Int_t) final;  Interface to system write. All arguments like in POSIX write(). ;  ;  Protected Member Functions inherited from TFile; Bool_t FlushWriteCache ();  Flush the write cache if active. ;  ; virtual EAsyncOpenStatus GetAsyncOpenStatus ();  ; virtual void Init (Bool_t create);  Initialize a TFile object. ;  ; Int_t MakeProjectParMake (const char *packname, const char *filename);  Create makefile at 'filemake' for PAR package 'pack'. ;  ; Int_t MakeProjectParProofInf (const char *packname, const char *proofinfdir);  Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'. ;  ; Int_t ReadBufferViaCache (char *buf, Int_t len);  Read buffer via cache. ;  ; Int_t WriteBufferViaCache (const char *buf, Int_t len);  Write buffer via cache. ;  ;  Protected Member Functions inherited from TDirectoryFile; void BuildDirectoryFile (TFile *motherFile, TDirectory *motherDir);  Initialise directory to defaults. ;  ; void CleanTargets ();  Clean the pointers to this object (gDirectory, TContext, etc.) ;  ; void InitDirectoryFile (TClass *cl=nullptr);  Initialize the key associated with this directory (and the relate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:35023,cache,cache,35023,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['cache'],['cache']
Performance,"vel and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:31448,Load,Load,31448,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,12,['Load'],['Load']
Performance,"vel in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::AddNodeOverlap(same arguments);. When closing the geometry, overlapping nodes perform a check of possible; overlaps with their neighbours. These are stored and checked all the time; during navigation, therefore navigation is slower when embedding such nodes; into geometry. Node have visualization attributes as volume have. When undefined by users,; painting a node on a pad will take the corresponding volume attributes. /*. */. Function Members (Methods); public:. TGeoIterator(TGeoVolume* top); TGeoIterator(const TGeoIterator& iter); virtual~TGeoIterator(); static TClass*Class(); const TGeoMatrix*GetCurrentMatrix() const; Int_tGetIndex(Int_t i) const; Int_tGetLevel() const; TGeoNode*GetNode(Int_t level) const; voidGetPath(TString& path) const; TGeoVolume*GetTopVolume() const; Int_tGetType() const; TGeoIteratorPlugin*GetUserPlugin() const; virtual TClass*IsA() const; TGeoNode*Next(); TGeoNode*operator()(); TGeoIterator&operator=(const TGeoIterator& iter); voidReset(TGeoVolume* top = 0); voidSetPluginAutoexec(Bool_t mode); voidSetTopName(const char* name); voidSetType(Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoIterator.html:2874,perform,perform,2874,root/html528/TGeoIterator.html,https://root.cern,https://root.cern/root/html528/TGeoIterator.html,4,['perform'],['perform']
Performance,"vel in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::AddNodeOverlap(same arguments);. When closing the geometry, overlapping nodes perform a check of possible; overlaps with their neighbours. These are stored and checked all the time; during navigation, therefore navigation is slower when embedding such nodes; into geometry. Node have visualization attributes as volume have. When undefined by users,; painting a node on a pad will take the corresponding volume attributes. /*. */. Function Members (Methods); public:. TGeoNodeOffset(); TGeoNodeOffset(const TGeoVolume* vol, Int_t index, Double_t offset); virtual~TGeoNodeOffset(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGeoNode::Browse(TBrowser* b); virtual voidcd() const; voidTGeoNode::CheckOverlaps(Double_t ovlp = 0.1, Option_t* option = """")MENU ; voidTGeoNode::CheckShapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNodeOffset.html:2897,perform,perform,2897,root/html528/TGeoNodeOffset.html,https://root.cern,https://root.cern/root/html528/TGeoNodeOffset.html,4,['perform'],['perform']
Performance,"vel in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::AddNodeOverlap(same arguments);. When closing the geometry, overlapping nodes perform a check of possible; overlaps with their neighbours. These are stored and checked all the time; during navigation, therefore navigation is slower when embedding such nodes; into geometry. Node have visualization attributes as volume have. When undefined by users,; painting a node on a pad will take the corresponding volume attributes. /*. */. Function Members (Methods); public:. virtual~TGeoIterator(); static TClass*Class(); const TGeoMatrix*GetCurrentMatrix() const; Int_tGetIndex(Int_t i) const; Int_tGetLevel() const; TGeoNode*GetNode(Int_t level) const; voidGetPath(TString& path) const; TGeoVolume*GetTopVolume() const; Int_tGetType() const; TGeoIteratorPlugin*GetUserPlugin() const; virtual TClass*IsA() const; TGeoNode*Next(); TGeoNode*operator()(); TGeoIterator&operator=(const TGeoIterator& iter); voidReset(TGeoVolume* top = 0); voidSetPluginAutoexec(Bool_t mode); voidSetTopName(const char* name); voidSetType(Int_t type); voidSetUserPlugin(TGeoIteratorPlugin* plugin); virtual voidSh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoIterator.html:2874,perform,perform,2874,root/html602/TGeoIterator.html,https://root.cern,https://root.cern/root/html602/TGeoIterator.html,2,['perform'],['perform']
Performance,"vel in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::AddNodeOverlap(same arguments);. When closing the geometry, overlapping nodes perform a check of possible; overlaps with their neighbours. These are stored and checked all the time; during navigation, therefore navigation is slower when embedding such nodes; into geometry. Node have visualization attributes as volume have. When undefined by users,; painting a node on a pad will take the corresponding volume attributes. /*. */. Function Members (Methods); public:. virtual~TGeoNodeOffset(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGeoNode::Browse(TBrowser* b); virtual voidcd() const; voidTGeoNode::CheckOverlaps(Double_t ovlp = 0.10000000000000001, Option_t* option = """")MENU ; voidTGeoNode::CheckShapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoNodeOffset.html:2897,perform,perform,2897,root/html602/TGeoNodeOffset.html,https://root.cern,https://root.cern/root/html602/TGeoNodeOffset.html,2,['perform'],['perform']
Performance,"vel in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::AddNodeOverlap(same arguments);. When closing the geometry, overlapping nodes perform a check of possible; overlaps with their neighbours. These are stored and checked all the time; during navigation, therefore navigation is slower when embedding such nodes; into geometry. Node have visualization attributes as volume have. When undefined by users,; painting a node on a pad will take the corresponding volume attributes. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoNode(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual voidcd() const; voidCheckOverlaps(Double_t ovlp = 0.1, Option_t* option = """")MENU ; voidCheckShapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNode.html:2893,perform,perform,2893,root/html528/TGeoNode.html,https://root.cern,https://root.cern/root/html528/TGeoNode.html,4,['perform'],['perform']
Performance,"vel in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::AddNodeOverlap(same arguments);. When closing the geometry, overlapping nodes perform a check of possible; overlaps with their neighbours. These are stored and checked all the time; during navigation, therefore navigation is slower when embedding such nodes; into geometry. Node have visualization attributes as volume have. When undefined by users,; painting a node on a pad will take the corresponding volume attributes. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoNode(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual voidcd() const; voidCheckOverlaps(Double_t ovlp = 0.10000000000000001, Option_t* option = """")MENU ; voidCheckShapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoNode.html:2893,perform,perform,2893,root/html602/TGeoNode.html,https://root.cern,https://root.cern/root/html602/TGeoNode.html,2,['perform'],['perform']
Performance,"vels) {; 330 for (Int_t level=0; level<nlevels; level++) levels[level] = GetContourLevel(level);; 331 }; 332 return nlevels;; 333}; 334 ; 335////////////////////////////////////////////////////////////////////////////////; 336/// Return the number of contour levels; 337 ; 338Double_t TF2::GetContourLevel(Int_t level) const; 339{; 340 if (level <0 || level >= fContour.fN) return 0;; 341 if (fContour.fArray[0] != -9999) return fContour.fArray[level];; 342 if (fHistogram == nullptr) return 0;; 343 return fHistogram->GetContourLevel(level);; 344}; 345 ; 346////////////////////////////////////////////////////////////////////////////////; 347/// Return minimum/maximum value of the function; 348///; 349/// To find the minimum on a range, first set this range via the SetRange function.; 350/// If a vector x of coordinate is passed it will be used as starting point for the minimum.; 351/// In addition on exit x will contain the coordinate values at the minimuma; 352///; 353/// If x is NULL or x is infinity or NaN, first, a grid search is performed to find the initial estimate of the; 354/// minimum location. The range of the function is divided into fNpx and fNpy; 355/// sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; 356/// by SetNpx and SetNpy functions; 357///; 358/// Then, a minimization is used with starting values found by the grid search; 359/// The minimizer algorithm used (by default Minuit) can be changed by callinga; 360/// ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); 361/// Other option for the minimizer can be set using the static method of the MinimizerOptions class; 362 ; 363Double_t TF2::FindMinMax(Double_t *x, Bool_t findmax) const; 364{; 365 //First do a grid search with step size fNpx and fNpy; 366 ; 367 Double_t xx[2];; 368 Double_t rsign = (findmax) ? -1. : 1.;; 369 TF2 & function = const_cast<TF2&>(*this); // needed since EvalPar is not const; 370 Double_t xxmin = 0, yymin = 0, zzmin = 0;; 371 if (x == nullptr || (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF2_8cxx_source.html:11435,perform,performed,11435,doc/master/TF2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html,1,['perform'],['performed']
Performance,"ven class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : Layout: ""TANH|128,TANH|128,TANH|128,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,DropConfig=0.0+0.5+0.5+0.5"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : InputLayout: ""0|0|0"" [The Layout of the input]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DNN_CPU : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mSVM␛[0m; : ; SVM : [dataset] : Create Transformation ""Norm"" with events from all classes.; : ; : Transformation, Variable selec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:7844,perform,performance,7844,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['perform'],['performance']
Performance,"ven if the cache lookup succeeds, because it will try to prefetch the next block as soon as we start reading from the current block. ; Definition at line 1986 of file TTreeCache.cxx. ◆ ResetCache(). void TTreeCache::ResetCache ; (; ). virtual . This will simply clear the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2040 of file TTreeCache.cxx. ◆ ResetMissCache(). void TTreeCache::ResetMissCache ; (; ). Reset all the miss cache training. ; The contents of the miss cache will be emptied as well as the list of branches used. ; Definition at line 697 of file TTreeCache.cxx. ◆ SetAutoCreated(). void TTreeCache::SetAutoCreated ; (; bool ; val). inline . Definition at line 164 of file TTreeCache.h. ◆ SetBufferSize(). Int_t TTreeCache::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; If the change of size means some cache content is lost, or if the buffer is now larger, setup for a cache refill the next time there is a read Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 2072 of file TTreeCache.cxx. ◆ SetEntryRange(). void TTreeCache::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2105 of file TTreeCache.cxx. ◆ SetFile(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line 2127 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:48315,cache,cache,48315,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['cache'],['cache']
Performance,"ven source and raise dirty flag. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label);  Define a new state with given label. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label, value_type index);  Define new state with given name and index number. ;  ; void defineStateUnchecked (const std::string &label, value_type index);  Internal version of defineState() that does not check if type already exists. ;  ; void fillTreeBranch (TTree &t) override;  Fill tree branches associated with current object with current value. ;  ; bool isValid () const override;  WVE (08/21/01) Probably obsolete now. ;  ; value_type nextAvailableStateIndex () const;  ; RooCatType * retrieveLegacyState (value_type index) const;  Return the legacy RooCatType corresponding to index. If it doesn't exist, create one. ;  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)activate associate tree branch ;  ; std::map< std::string, value_type > & stateNames ();  Access the map of state names to index numbers. ;  ; const std::map< std::string, value_type > & stateNames () const;  Access the map of state names to index numbers. ;  ; void syncCache (const RooArgSet *set=nullptr) override;  Explicitly synchronize RooAbsCategory internal cache. ;  ; virtual bool isValid (const RooCatType &value) const;  Check if given state is defined for this object. ;  ; const RooCatType * defineType (const char *label);  ; const RooCatType * defineType (const char *label, int index);  ; const RooCatType * defineTypeUnchecked (const char *label, value_type index);  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinningCategory.html:36624,cache,cache,36624,doc/master/classRooBinningCategory.html,https://root.cern,https://root.cern/doc/master/classRooBinningCategory.html,4,['cache'],['cache']
Performance,"vent loop is started.; 2943 /// * `void Initialize()`: this method is called once before starting the event-loop. Useful for setup operations.; 2944 /// It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper,; 2945 /// or copies of it, might be used for multiple event loops (e.g. in the presence of systematic variations).; 2946 /// * `void InitTask(TTreeReader *, unsigned int slot)`: each working thread shall call this method during the event; 2947 /// loop, before processing a batch of entries. The pointer passed as argument, if not null, will point to the TTreeReader; 2948 /// that RDataFrame has set up to read the task's batch of entries. It is passed to the helper to allow certain advanced optimizations; 2949 /// it should not usually serve any purpose for the Helper. This method is often no-op for simple helpers.; 2950 /// * `void Exec(unsigned int slot, ColumnTypes...columnValues)`: each working thread shall call this method; 2951 /// during the event-loop, possibly concurrently. No two threads will ever call Exec with the same 'slot' value:; 2952 /// this parameter is there to facilitate writing thread-safe helpers. The other arguments will be the values of; 2953 /// the requested columns for the particular entry being processed.; 2954 /// * `void Finalize()`: this method is called at the end of the event loop. Commonly used to finalize the contents of the result.; 2955 /// * `std::string GetActionName()`: it returns a string identifier for this type of action that RDataFrame will use in; 2956 /// diagnostics, SaveGraph(), etc.; 2957 ///; 2958 /// ### Optional methods; 2959 ///; 2960 /// If these methods are implemented they enable extra functionality as per the description below.; 2961 ///; 2962 /// * `Result_t &PartialUpdate(unsigned int slot)`: if present, it must return the value of the partial result of this action for the given 'slot'.; 2963 /// Different threads might call this method concurrentl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:167048,concurren,concurrently,167048,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['concurren'],['concurrently']
Performance,"vent-wise weights); signalWeight = 1.0; backgroundWeight = 1.0; ; # You can add an arbitrary number of signal or background trees; loader.AddSignalTree(signalTree, signalWeight); loader.AddBackgroundTree(backgroundTree, backgroundWeight); ; ## add event variables (image); ## use new method (from ROOT 6.20 to add a variable array for all image data); loader.AddVariablesArray(""vars"", imgSize); ; # Set individual event weights (the variables must exist in the original TTree); # for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; # for background: factory->SetBackgroundWeightExpression(""weight1*weight2"");; # loader->SetBackgroundWeightExpression( ""weight"" );; ; # Apply additional cuts on the signal and background samples (can be different); mycuts = """" # for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; mycutb = """" # for example: TCut mycutb = ""abs(var1)<0.5"";; ; # Tell the factory how to use the training and testing events; # If no numbers of events are given, half of the events in the tree are used; # for training, and the other half for testing:; # loader.PrepareTrainingAndTestTree( mycut, ""SplitMode=random:!V"" );; # It is possible also to specify the number of training and testing events,; # note we disable the computation of the correlation matrix of the input variables; ; nTrainSig = 0.8 * nEventsSig; nTrainBkg = 0.8 * nEventsBkg; ; # build the string options for DataLoader::PrepareTrainingAndTestTree; ; loader.PrepareTrainingAndTestTree(; mycuts,; mycutb,; nTrain_Signal=nTrainSig,; nTrain_Background=nTrainBkg,; SplitMode=""Random"",; SplitSeed=100,; NormMode=""NumEvents"",; V=False,; CalcCorrelations=False,; ); ; ; # DataSetInfo : [dataset] : Added class ""Signal""; # : Add Tree sig_tree of type Signal with 10000 events; # DataSetInfo : [dataset] : Added class ""Background""; # : Add Tree bkg_tree of type Background with 10000 events; ; # signalTree.Print();; ; # Booking Methods; ; # Here we book the TMVA methods. We book a Boosted Decisio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html:8451,load,loader,8451,doc/master/TMVA__CNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html,1,['load'],['loader']
Performance,"vention applies:. 1 = left; 2 = centered; 3 = right. For vertical alignment, the following convention applies:. 1 = bottom; 2 = centered; 3 = top. For example, align: 11 = left adjusted and bottom adjusted; 32 = right adjusted and vertically centered.; 9.6.1.2 Setting Text Angle; Use TAttText::SetTextAngle to set the text angle. The angle is the degrees of the horizontal.; root[] la->SetTextAngle(angle); 9.6.1.3 Setting Text Color; Use TAttText::SetTextColor to set the text color. The color is the color index. The colors are described in “Color and Color Palettes”.; root[] la->SetTextColor(color); 9.6.1.4 Setting Text Font; Use TAttText::SetTextFont to set the font. The parameter font is the font code, combining the font and precision: font = 10 * fontID + precision; root[] la->SetTextFont(font); The table below lists the available fonts. The font IDs must be between 1 and 14. The precision can be:. Precision = 0 fast hardware fonts (steps in the size); Precision = 1 scalable and rotate-able hardware fonts (see below); Precision = 2 scalable and rotate-able hardware fonts. When precision 0 is used, only the original non-scaled system fonts are used. The fonts have a minimum (4) and maximum (37) size in pixels. These fonts are fast and are of good quality. Their size varies with large steps and they cannot be rotated. Precision 1 and 2 fonts have a different behavior depending if True Type Fonts (TTF) are used or not. If TTF are used, you always get very good quality scalable and rotate-able fonts. However, TTF are slow. Precision 1 and 2 fonts have a different behavior for PostScript in case of TLatex objects:. With precision 1, the PostScript text uses the old convention (see TPostScript) for some special characters to draw sub and superscripts or Greek text.; With precision 2, the “PostScript” special characters are drawn as such. To draw sub and superscripts it is highly recommended to use TLatex objects instead. For example: font = 62 is the font with ID 6 and pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:354600,scalab,scalable,354600,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['scalab'],['scalable']
Performance,"vents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique; ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:67670,perform,performed,67670,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,1,['perform'],['performed']
Performance,"vents, . std::function< void(unsigned int, T &)> ; callback . ). inline . Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's partial result. ; Parameters. [in]everyNEventsFrequency at which the callback will be called by each thread, as a number of events processed ; [in]callbackA callable with signature void(unsigned int, Value_t&) where Value_t is the type of the value contained in this RResultPtr . Returnsthis RResultPtr, to allow chaining of OnPartialResultSlot with other calls; See OnPartialResult for a generic explanation of the callback mechanism. Compared to OnPartialResult, this method has two major differences:; all worker threads invoke the callback once every specified number of events. The event count is per-thread, and callback invocation might happen concurrently (i.e. the callback must be thread-safe); the callable must take an extra unsigned int parameter corresponding to a multi-thread ""processing slot"": this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the callback concurrently but always with different slot numbers.; a value of 0 for everyNEvents indicates the callback must be executed once per slot. For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; std::string progress;; std::mutex bar_mutex;; c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; std::lock_guard<std::mutex> lg(bar_mutex);; progress.push_back('#');; std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; });; std::cout << ""Analysis running..."" << std::endl;; *c; // trigger the event loop by accessing an action's result; std::cout << ""\nDone!"" << std::endl;; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70. Definition at line 364 of file RResultPtr.hxx. ◆ o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html:12823,multi-thread,multi-thread,12823,doc/master/classROOT_1_1RDF_1_1RResultPtr.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html,2,"['concurren', 'multi-thread']","['concurrently', 'multi-thread']"
Performance,"ver range (-6,6) did not converge after 20 steps; [1] h = 1 , s = 0; [2] h = 0.25 , s = 6; [3] h = 0.0625 , s = 3; [4] h = 0.015625 , s = 4.5; [5] h = 0.00390625 , s = 3.75; [6] h = 0.000976562 , s = 4.125; [7] h = 0.000244141 , s = 3.9375; [8] h = 6.10352e-05 , s = 4.03125; [9] h = 1.52588e-05 , s = 3.98438; [10] h = 3.8147e-06 , s = 4.00781; [11] h = 9.53674e-07 , s = 3.99609; [12] h = 2.38419e-07 , s = 4.00195; [13] h = 5.96046e-08 , s = 3.99902; [14] h = 1.49012e-08 , s = 4.00049; [15] h = 3.72529e-09 , s = 3.99976; [16] h = 9.31323e-10 , s = 4.00012; [17] h = 2.32831e-10 , s = 3.99994; [18] h = 5.82077e-11 , s = 4.00003; [19] h = 1.45519e-11 , s = 3.99998; [20] h = 3.63798e-12 , s = 4.00001; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(model) creating new cache 0x56161c4fa860 with pdf gx_CONV_model_mean_CACHE_Obs[mean] for nset () with code 2; [#1] INFO:NumericIntegration -- RooRealIntegral::init(gx_Int[mean,x]) using numeric integrator RooIntegrator1D to calculate Int(mean); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_mean_Int[mean]) using numeric integrator RooIntegrator1D to calculate Int(mean); [#0] WARNING:Integration -- RooRombergIntegrator::integral: integral of model_mean over range (-6,6) did not converge after 20 steps; [1] h = 1 , s = 0; [2] h = 0.25 , s = 6; [3] h = 0.0625 , s = 3; [4] h = 0.015625 , s = 4.5; [5] h = 0.00390625 , s = 3.75; [6] h = 0.000976562 , s = 4.125; [7] h = 0.000244141 , s = 3.9375; [8] h = 6.10352e-05 , s = 4.03125; [9] h = 1.52588e-05 , s = 3.98438; [10] h = 3.8147e-06 , s = 4.00781; [11] h = 9.53674e-07 , s = 3.99609; [12] h = 2.38419e-07 , s = 4.00195; [13] h = 5.96046e-08 , s = 3.99902; [14] h = 1.49012e-08 , s = 4.00049; [15] h = 3.72529e-09 , s = 3.99976; [16] h = 9.31323e-10 , s = 4.00012; [17] h = 2.32831e-10 , s = 3.99994; [18] h = 5.82077e-11 , s = 4.00003; [19] h = 1.45519e-11 , s = 3.99998; [20] h = 3.63798e-12 , s = 4.00001; ; prevFCN = 2171.275755 a=2.017, ; prevFCN = 2171.275755 a=1.983, ; prev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf211__paramconv_8C.html:11494,cache,cache,11494,doc/master/rf211__paramconv_8C.html,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8C.html,1,['cache'],['cache']
Performance,"ver redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; map<string,string>RooAbsArg::_stringAttribString attributes; char*_value[_len] Value; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsString(); Default constructor. RooAbsString(const char* name, const char* title, Int_t size = 128); Constructor. RooAbsString(const RooAbsString& other, const char* name = 0); Copy constructor. ~RooAbsString(); Destructor. const char* getVal() const; Return value of object. Calculated if dirty, otherwise cached value is returned. Bool_t operator==(const char* ) const; Equality operator comparing with a TString. Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). Bool_t operator==(const RooAbsArg& other); Equality operator comparing to another RooAbsArg. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) const; Print value. Bool_t isValid() const; Check if current value is valid. Bool_t isValidString(const char* , Bool_t printError = kFALSE) const; Check if given string value is valid. Bool_t traceEvalHook(const char* value) const; Hook function for trace evaluation. const char* traceEval() const; Calculate current value of object, with error tracing wrapper. void syncCache(const RooArgSet* nset = 0); Forcibly bring internal cache up-to-date. void copyCac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsString.html:22629,cache,cached,22629,root/html602/RooAbsString.html,https://root.cern,https://root.cern/root/html602/RooAbsString.html,2,['cache'],['cached']
Performance,"ver redirects, operation; mode changes and constant term optimization management calls.; . Function Members (Methods); public:. RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void operModeHook(); Interface for operation mode changes. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for constant term node finding calls. void printCompactTreeHook(ostream& , const char* ); Interface for printing of cache guts in tree mode printing. » Last changed: Mon Jul 4 15:21:17 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCache.html:1563,cache,cache,1563,root/html530/RooAbsCache.html,https://root.cern,https://root.cern/root/html530/RooAbsCache.html,7,"['cache', 'optimiz']","['cache', 'optimization', 'optimizeCacheMode']"
Performance,"ver redirects, operation; mode changes and constant term optimization management calls.; . Function Members (Methods); public:. RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void operModeHook(); Interface for operation mode changes. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for constant term node finding calls. void printCompactTreeHook(ostream& , const char* ); Interface for printing of cache guts in tree mode printing. » Last changed: Thu Nov 3 20:06:36 2011 » Last generated: 2011-11-03 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCache.html:1563,cache,cache,1563,root/html532/RooAbsCache.html,https://root.cern,https://root.cern/root/html532/RooAbsCache.html,7,"['cache', 'optimiz']","['cache', 'optimization', 'optimizeCacheMode']"
Performance,"ver, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tsetData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsTestStatistic.html:23880,cache,cache,23880,root/html532/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsTestStatistic.html,2,['cache'],['cache']
Performance,"ver, if option =""B"" is specified, Binomial errors are computed. In this case c1 and c2 do not make real sense and they are ignored.; IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after TH1::Divide; Please note also that in the binomial case errors are calculated using standard binomial statistics, which means when b1 = b2, the error is zero. If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower error for the case b1=b2.; The function return kFALSE if the divide operation failed ; Reimplemented in TProfile, TProfile2D, and TProfile3D.; Definition at line 2966 of file TH1.cxx. ◆ Divide() [3/3]. Bool_t TH1::Divide ; (; TF1 * ; f1, . Double_t ; c1 = 1 . ). virtual . Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2), errors are also recalculated. ; Only bins inside the function range are recomputed. IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after TH1::Divide; The function return kFALSE if the divide operation failed ; Reimplemented in TH2Poly, TProfile, TProfile2D, and TProfile3D.; Definition at line 2840 of file TH1.cxx. ◆ DoFillN(). void TH1::DoFillN ; (; Int_t ; ntimes, . const Double_t * ; x, . const Double_t * ; w, . Int_t ; stride = 1 . ). protectedvirtual . Internal method to fill histogram content from a vector called directly by TH1::BufferEmpty. ; Definition at line 3473 of file TH1.cxx. ◆ DoIntegral(). Double_t TH1::DoIntegral ; (; Int_t ; ix1, . Int_t ; ix2, . Int_t ; iy1, . Int_t ; iy2, . Int_t ; iz1, . Int_t ; iz2, . Double_t & ; err, . Option_t * ; opt, . Bool_t ; doerr = kFALSE . ); const. protectedvirtual . Internal fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:107165,Perform,Performs,107165,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['Perform'],['Performs']
Performance,"ver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions;  TApplication ();  Default ctor. Can be used by classes deriving from TApplication. ;  ; virtual void Forum (const char *line);  The function ("".forum <type>"") submits a new post on the ROOT forum via web browser. ;  ; virtual void GitHub (const char *line);  The function ("".gh <type>"") submits a new issue on GitHub via web browser. ;  ; virtual void Help (const char *line);  The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxygen ("".help scope"" or "".help scope::member""). ;  ; virtual void LoadGraphicsLibs ();  Load shared libs necessary for graphics. ;  ; virtual void MakeBatch ();  Switch to batch mode. ;  ; virtual Longptr_t ProcessRemote (const char *line, Int_t *error=nullptr);  Process the content of a line starting with "".R"" (already stripped-off) The format is. ;  ; void SetSignalHandler (TSignalHandler *sh);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Static Protected Member Functions; static void Close (TApplication *app);  Static function used to close a remote application. ;  ; static TApplication * Open (const char *url, Int_t debug, const char *script);  Static function used to attach to an existing remote application or to start one. ;  ; static Int_t ParseRemoteLine (const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplication.html:18136,Load,LoadGraphicsLibs,18136,doc/master/classTApplication.html,https://root.cern,https://root.cern/doc/master/classTApplication.html,2,['Load'],"['Load', 'LoadGraphicsLibs']"
Performance,"ver. They could be add as additional URL parameters to the constructor arguments like:; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following URL parameters are supported:. Name; Description. thrds=N; number of threads used by the civetweb (default is 10). top=name; configure top name, visible in the web browser. auth_file=filename; authentication file name, created with htdigets utility. auth_domain=domain; authentication domain. loopback; bind specified port to loopback 127.0.0.1 address. debug; enable debug mode, server returns html page with request info. websocket_timeout=tm; set web sockets timeout in seconds (default 300). websocket_disable; disable web sockets handling (default enabled). cors=domain; define value for CORS header “Access-Control-Allow-Origin” in server response. log=filename; configure civetweb log file. max_age=value; configures “Cache-Control: max_age=value” http header for all file-related requests, default 3600. nocache; try to fully disable cache control for file requests. winsymlinks=no; do not resolve symbolic links on file system (Windows only), default true. dirlisting=no; enable/disable directory listing for browsing filesystem (default no). If necessary, one could bind http server to specific IP address like:; new THttpServer(""http:192.168.1.17:8080""); One also can provide extra arguments for THttpServer itself:. Name; Description. readonly, ro; use server in read-only mode (default). readwrite, rw; use server in read-write mode. global; let scan global directories for canvases and files (default). noglobal; disable scan of global directories. basic_sniffer; use basic TRootSniffer without support of hist, gpad, graph, tree classes. Example:; new THttpServer(""http:8080;ro;noglobal""); 1.2 Registering objects; At any time, one could register other objects with the command:; TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);; One should specify sub-folder name, where objects will b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:2541,cache,cache,2541,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,1,['cache'],['cache']
Performance,"verList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsOptTestStatistic.html:2651,cache,cacheUniqueSuffix,2651,root/html528/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html528/RooAbsOptTestStatistic.html,2,['cache'],['cacheUniqueSuffix']
Performance,"vergence of its training; : (at least 10k training cycles are required to achieve approximately; : competitive results).; : ; : ␛[1mOvertraining: ␛[0monly the TMlpANN performs an explicit separation of the; : full training sample into independent training and validation samples.; : We have found that in most high-energy physics applications the ; : available degrees of freedom (training events) are sufficient to ; : constrain the weights of the relatively simple architectures required; : to achieve good performance. Hence no overtraining should occur, and ; : the use of validation samples would only reduce the available training; : information. However, if the performance on the training sample is ; : found to be significantly better than the one found with the inde-; : pendent test sample, caution is needed. The results for these samples ; : are printed to standard output at the end of each training job.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The hidden layer architecture for all ANNs is defined by the option; : ""HiddenLayers=N+1,N,..."", where here the first hidden layer has N+1; : neurons and the second N neurons (and so on), and where N is the number ; : of input variables. Excessive numbers of hidden layers should be avoided,; : in favour of more neurons in the first hidden layer.; : ; : The number of cycles should be above 500. As said, if the number of; : adjustable weights is small compared to the training sample size,; : using a large number of training samples should not lead to overtraining.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; TFHandler_MLPBNN : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.089214 0.20183 [ -1.0000 1.0000 ]; : myvar2: -0.090751 0.29609 [ -1.0000 1.0000 ]; : var3: 0.059878 0.21436 [ -1.0000 1.0000 ]; : var4: 0.11587 0.24261 [ -1.0000 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:43685,Perform,Performance,43685,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['Perform'],['Performance']
Performance,"verlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCategory.html:10544,optimiz,optimizeCacheMode,10544,root/html530/RooAbsCategory.html,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html,3,['optimiz'],['optimizeCacheMode']
Performance,"verloads for this name, collecting all available ones. ; Can construct and insert new TFunction-s. ; Definition at line 233 of file TListOfFunctionTemplates.cxx. ◆ GetListForObject() [2/2]. TList * TListOfFunctionTemplates::GetListForObject ; (; const TObject * ; obj); const. virtual . Return the set of overloads for function obj, collecting all available ones. ; Can construct and insert new TFunction-s. ; Definition at line 242 of file TListOfFunctionTemplates.cxx. ◆ GetListForObjectNonConst(). TList * TListOfFunctionTemplates::GetListForObjectNonConst ; (; const char * ; name). private . Return the set of overloads for this name, collecting all available ones. ; Can construct and insert new TFunction-s. ; Definition at line 194 of file TListOfFunctionTemplates.cxx. ◆ IsA(). TClass * TListOfFunctionTemplates::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from THashList.; Definition at line 87 of file TListOfFunctionTemplates.h. ◆ Load(). void TListOfFunctionTemplates::Load ; (; ). Load all the functions known to the interpreter for the scope 'fClass' into this collection. ; Definition at line 356 of file TListOfFunctionTemplates.cxx. ◆ MapObject(). void TListOfFunctionTemplates::MapObject ; (; TObject * ; obj). private . Add pair<id, object> to the map of functions and their ids. ; Definition at line 53 of file TListOfFunctionTemplates.cxx. ◆ operator=(). TListOfFunctionTemplates & TListOfFunctionTemplates::operator= ; (; const TListOfFunctionTemplates & ; ). privatedelete . ◆ RecursiveRemove(). void TListOfFunctionTemplates::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Remove object from this collection and recursively remove the object from all other objects (and collections). ; This function overrides TCollection::RecursiveRemove that calls the Remove function. THashList::Remove cannot be called because it uses the hash value of the hash table. This hash value is not available anymore when Recursiv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctionTemplates.html:29804,Load,Load,29804,doc/master/classTListOfFunctionTemplates.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctionTemplates.html,1,['Load'],['Load']
Performance,"verride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxysigmaL; RooRealProxysigmaR; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooBifurGauss.html:39699,cache,cache,39699,root/html530/RooBifurGauss.html,https://root.cern,https://root.cern/root/html530/RooBifurGauss.html,2,['cache'],['cache']
Performance,"verride;  ; Long64_t LoadTree (Long64_t entry) override;  Setup the tree to the load the specified entry. ;  ; virtual Long64_t PrepEntry (Long64_t entry);  Make sure the server and result set are setup for the requested entry. ;  ; void Refresh () override;  Refresh contents of this Tree and its branches from the current Tree status in the database One can call this function in case the Tree on its file is being updated by another process. ;  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TTree;  TTree ();  Default constructor and I/O constructor. ;  ;  TTree (const char *name, const char *title, Int_t splitlevel=99, TDirectory *dir=(::ROOT::Internal::TDirectoryAtomicAdapter{}));  Normal tree constructor. ;  ;  TTree (const TTree &tt)=delete;  ;  ~TTree () override;  Destructor. ;  ; void AddAllocationCount (UInt_t count);  ; virtual Int_t AddBranchToCache (const char *bname, bool subbranches=false);  Add branch with name bname to the Tree cache. ;  ; virtual Int_t AddBranchToCache (TBranch *branch, bool subbranches=false);  Add branch b to the Tree cache. ;  ; void AddClone (TTree *);  Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ;  ; virtual TFriendElement * AddFriend (const char *treename, const char *filename="""");  Add a TFriendElement to the list of friends. ;  ; virtual TFriendElement * AddFriend (const char *treename, TFile *file);  Add a TFriendElement to the list of friends. ;  ; virtual TFriendElement * AddFriend (TTree *tree, const char *alias="""", bool warn=false);  Add a TFriendElement to the list of friends. ;  ; virtual void AddTotBytes (Int_t tot);  ; virtual void AddZipBytes (Int_t zip);  ; virtual Long64_t AutoSave (Option_t *option="""");  AutoSave tree header every fAutoSave bytes. ;  ; TBranch * Branch (const char *name, char *address, const char *leafli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeSQL.html:3435,cache,cache,3435,doc/master/classTTreeSQL.html,https://root.cern,https://root.cern/doc/master/classTTreeSQL.html,1,['cache'],['cache']
Performance,"verride;  Add entry #entry to the list. ;  ; TEntryList * GetCurrentList () const override;  ; virtual Long64_t GetEntries ();  Returns the total number of entries in the list. ;  ; virtual Long64_t GetEntriesFast () const;  ; Long64_t GetEntry (Long64_t index) override;  Returns entry #index See also Next() for a faster alternative. ;  ; Long64_t GetEntryAndTree (Long64_t index, Int_t &treenum) override;  Return the entry corresponding to the index parameter and the number of the tree, where this entry is. ;  ; TEntryList * GetEntryList (const char *, const char *, Option_t *) override;  Return the entry list, corresponding to treename and filename By default, the filename is first tried as is, and then, if the corresponding list is not found, the filename is expanded to the absolute path, and compared again. ;  ; const char * GetFileName () const override;  ; Long64_t GetN () const override;  ; const char * GetTreeName () const override;  ; Int_t GetTreeNumber () const override;  ; TClass * IsA () const override;  ; virtual Int_t LoadList (Int_t listnumber);  Loads the list #listnumber This is the only function that can modify fCurrent and fFile data members. ;  ; Int_t Merge (TCollection *) override;  Merge this list with the lists from the collection. ;  ; Long64_t Next () override;  Returns the next entry in the list. ;  ; void OptimizeStorage () override;  Checks if the array representation is more economical and if so, switches to it. ;  ; void Print (const Option_t *option="""") const override;  Print info about this list. ;  ; bool Remove (Long64_t, TTree *) override;  Remove entry #entry from the list. ;  ; virtual void SetFileNames (TObjArray *names);  ; virtual void SetNFiles (Int_t nfiles);  ; void SetTree (const char *, const char *) override;  If a list for a tree with such name and filename exists, sets it as the current sublist If not, creates this list and sets it as the current sublist. ;  ; void SetTree (const TTree *) override;  If a list for a tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryListFromFile.html:2702,Load,LoadList,2702,doc/master/classTEntryListFromFile.html,https://root.cern,https://root.cern/doc/master/classTEntryListFromFile.html,2,['Load'],"['LoadList', 'Loads']"
Performance,"verride;  Destructor. ;  ; void AddBinContent (Int_t bin) override;  Increment bin content by 1. ;  ; void AddBinContent (Int_t bin, Double_t w) override;  Increment bin content by a weight w. ;  ; void Copy (TObject &hnew) const override;  Copy this to newth1. ;  ; TClass * IsA () const override;  ; TH1F & operator= (const TH1F &h1);  Operator =. ;  ; void Reset (Option_t *option="""") override;  Reset. ;  ; void SetBinsLength (Int_t n=-1) override;  Set total number of bins including under/overflow Reallocate bin contents array. ;  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TH1;  ~TH1 () override;  Histogram default destructor. ;  ; virtual Bool_t Add (const TH1 *h, const TH1 *h2, Double_t c1=1, Double_t c2=1);  Replace contents of this histogram by the addition of h1 and h2. ;  ; virtual Bool_t Add (const TH1 *h1, Double_t c1=1);  Performs the operation: this = this + c1*h1 If errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual Bool_t Add (TF1 *h1, Double_t c1=1, Option_t *option="""");  Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Double_t &advalue) const;  Same function as above but returning also the test statistic value. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Option_t *option="""") const;  Statistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling 2 sample test. ;  ; void Browse (TBrowser *b) override;  Browse the Histogram object. ;  ; virtual Int_t BufferEmpty (Int_t action=0);  Fill histogram with all entries in the buffer. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1F.html:2210,Perform,Performs,2210,doc/master/classTH1F.html,https://root.cern,https://root.cern/doc/master/classTH1F.html,1,['Perform'],['Performs']
Performance,"verridevirtual . Map window on screen. ; Reimplemented from TVirtualX.; Definition at line 4609 of file TGWin32.cxx. ◆ MoveResizeWindow(). void TGWin32::MoveResizeWindow ; (; Window_t ; id, . Int_t ; x, . Int_t ; y, . UInt_t ; w, . UInt_t ; h . ). overridevirtual . Move and resize a window. ; Reimplemented from TVirtualX.; Definition at line 4736 of file TGWin32.cxx. ◆ MoveWindow() [1/2]. void TGWin32::MoveWindow ; (; Int_t ; wid, . Int_t ; x, . Int_t ; y . ). overridevirtual . Move the window wid. ; wid : GdkWindow identifier. x : x new window position y : y new window position ; Reimplemented from TVirtualX.; Definition at line 2085 of file TGWin32.cxx. ◆ MoveWindow() [2/2]. void TGWin32::MoveWindow ; (; Window_t ; id, . Int_t ; x, . Int_t ; y . ). overridevirtual . Move a window. ; Reimplemented from TVirtualX.; Definition at line 4726 of file TGWin32.cxx. ◆ NextEvent(). void TGWin32::NextEvent ; (; Event_t & ; event). overridevirtual . Copies first pending event from event queue to Event_t structure and removes event from queue. ; Not all of the event fields are valid for each event type, except fType and fWindow. ; Reimplemented from TVirtualX.; Definition at line 5870 of file TGWin32.cxx. ◆ OpenDisplay(). Int_t TGWin32::OpenDisplay ; (; const char * ; dpyName = 0). overridevirtual . Open the display. Return -1 if the opening fails, 0 when ok. ; Reimplemented from TVirtualX.; Definition at line 971 of file TGWin32.cxx. ◆ OpenPixmap(). Int_t TGWin32::OpenPixmap ; (; UInt_t ; w, . UInt_t ; h . ). overridevirtual . Open a new pixmap. ; w,h : Width and height of the pixmap. ; Reimplemented from TVirtualX.; Definition at line 2099 of file TGWin32.cxx. ◆ ParseColor(). Bool_t TGWin32::ParseColor ; (; Colormap_t ; cmap, . const char * ; cname, . ColorStruct_t & ; color . ). overridevirtual . Parse string cname containing color name, like ""green"" or ""#00FF00"". ; It returns a filled in ColorStruct_t. Returns kFALSE in case parsing failed, kTRUE in case of success. On succ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32.html:92954,queue,queue,92954,doc/master/classTGWin32.html,https://root.cern,https://root.cern/doc/master/classTGWin32.html,2,['queue'],['queue']
Performance,"verridevirtual . Read file event. ; Implements TVirtualPerfStats.; Definition at line 572 of file TPerfStats.cxx. ◆ GetBytesRead(). Long64_t TPerfStats::GetBytesRead ; (; ); const. overridevirtual . Get number of bytes read. ; Implements TVirtualPerfStats.; Definition at line 637 of file TPerfStats.cxx. ◆ GetMemValues(). void TPerfStats::GetMemValues ; (; Long_t & ; vmax, . Long_t & ; rmax . ). static . Get memory usage. ; Definition at line 790 of file TPerfStats.cxx. ◆ GetNumEvents(). Long64_t TPerfStats::GetNumEvents ; (; ); const. inlineoverridevirtual . Implements TVirtualPerfStats.; Definition at line 134 of file TPerfStats.h. ◆ IsA(). TClass * TPerfStats::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 153 of file TPerfStats.h. ◆ PacketEvent(). void TPerfStats::PacketEvent ; (; const char * ; slave, . const char * ; slavename, . const char * ; filename, . Long64_t ; eventsprocessed, . Double_t ; latency, . Double_t ; proctime, . Double_t ; cputime, . Long64_t ; bytesRead . ). overridevirtual . Packet event. ; See WriteQueryLog for the descripition of the structure sent for monitoring when fMonitorPerPacket is kTRUE. ; Implements TVirtualPerfStats.; Definition at line 413 of file TPerfStats.cxx. ◆ PrintBasketInfo(). void TPerfStats::PrintBasketInfo ; (; Option_t * ; = """"); const. inlineoverridevirtual . Implements TVirtualPerfStats.; Definition at line 136 of file TPerfStats.h. ◆ RateEvent(). void TPerfStats::RateEvent ; (; Double_t ; proctime, . Double_t ; deltatime, . Long64_t ; eventsprocessed, . Long64_t ; bytesRead . ). overridevirtual . Rate event. ; Implements TVirtualPerfStats.; Definition at line 607 of file TPerfStats.cxx. ◆ SetBytesRead(). void TPerfStats::SetBytesRead ; (; Long64_t ; num). overridevirtual . Set number of bytes read. ; Implements TVirtualPerfStats.; Definition at line 629 of file TPerfStats.cxx. ◆ SetFile(). void TPerfStats::SetFile ; (; TFile * ; )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPerfStats.html:17715,latency,latency,17715,doc/master/classTPerfStats.html,https://root.cern,https://root.cern/doc/master/classTPerfStats.html,1,['latency'],['latency']
Performance,"verridevirtual . Return the sizeof the collection object. ; Implements TVirtualCollectionProxy.; Definition at line 1014 of file TGenCollectionProxy.cxx. ◆ Streamer() [1/2]. void TGenCollectionProxy::Streamer ; (; TBuffer & ; refBuffer). virtual . Streamer Function. ; Reimplemented in TEmulatedCollectionProxy, TEmulatedMapProxy, and TGenCollectionStreamer.; Definition at line 1427 of file TGenCollectionProxy.cxx. ◆ Streamer() [2/2]. void TGenCollectionProxy::Streamer ; (; TBuffer & ; refBuffer, . void * ; pObject, . int ; siz . ). virtual . Streamer I/O overload. ; Reimplemented in TEmulatedCollectionProxy, TEmulatedMapProxy, and TGenCollectionStreamer.; Definition at line 1439 of file TGenCollectionProxy.cxx. Friends And Related Symbol Documentation. ◆ TCollectionProxyFactory. friend class TCollectionProxyFactory. friend . Definition at line 34 of file TGenCollectionProxy.h. Member Data Documentation. ◆ fClear. Method TGenCollectionProxy::fClear. protected . Method cache for container accessors: clear container. ; Definition at line 301 of file TGenCollectionProxy.h. ◆ fCollect. Collectfunc_t TGenCollectionProxy::fCollect. protected . Method to collect objects from container. ; Definition at line 309 of file TGenCollectionProxy.h. ◆ fConstruct. ArrIterfunc_t TGenCollectionProxy::fConstruct. protected . Container accessors: block construct. ; Definition at line 306 of file TGenCollectionProxy.h. ◆ fConversionReadMemberWise. std::map<std::string, TObjArray*>* TGenCollectionProxy::fConversionReadMemberWise. mutableprotected . Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ; Definition at line 292 of file TGenCollectionProxy.h. ◆ fCreateEnv. Method0 TGenCollectionProxy::fCreateEnv. protected . Method to allocate an Environment holder. ; Definition at line 310 of file TGenCollectionProxy.h. ◆ fDestruct. Sizing_t TGenCollectionProxy::fDestruct. protected . Container accessors: block destruct. ; Definition at line 307 of file TGenC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionProxy.html:27129,cache,cache,27129,doc/master/classTGenCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionProxy.html,1,['cache'],['cache']
Performance,"verridevirtual . Save TChain as a C++ statements on output stream out. ; With the option ""friend"" save the description of all the TChain's friend trees or chains as well. ; Reimplemented from TObject.; Definition at line 2360 of file TChain.cxx. ◆ Scan(). Long64_t TChain::Scan ; (; const char * ; varexp = """", . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). overridevirtual . Loop on tree and print entries passing selection. . If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"". See TTreePlayer::Scan for more information. . Reimplemented from TTree.; Definition at line 2417 of file TChain.cxx. ◆ SetAutoDelete(). void TChain::SetAutoDelete ; (; bool ; autodelete = true). virtual . Set the global branch kAutoDelete bit. ; When LoadTree loads a new Tree, the branches for which the address is set will have the option AutoDelete set For more details on AutoDelete, see TBranch::SetAutoDelete. ; Definition at line 2432 of file TChain.cxx. ◆ SetBranchAddress() [1/5]. template<class T > . Int_t TChain::SetBranchAddress ; (; const char * ; bname, . T ** ; add, . TBranch ** ; ptr = nullptr . ). inline . Definition at line 149 of file TChain.h. ◆ SetBranchAddress() [2/5]. template<class T > . Int_t TChain::SetBranchAddress ; (; const char * ; bname, . T * ; add, . TBranch ** ; ptr = nullptr . ). inline . Definition at line 155 of file TChain.h. ◆ SetBranchAddress() [3/5]. Int_t TChain::SetBranchAddress ; (; const char * ; bname, . void * ; add, . TBranch ** ; ptr, . TClass * ; realClass, . EDataType ; datatype, . bool ; isptr . ). overridevirtual . Check if bname is already in the status list, and if not, create a TChainElement object and set its address. ; See TTree::CheckBranchAddressType for the semantic of the return value.; Note: See the comments in TBranchElement::SetAddress() for a more ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:93575,Load,LoadTree,93575,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,2,"['Load', 'load']","['LoadTree', 'loads']"
Performance,"verridevirtual . Save TChain as a C++ statements on output stream out. ; With the option ""friend"" save the description of all the TChain's friend trees or chains as well. ; Reimplemented from TObject.; Definition at line 2386 of file TChain.cxx. ◆ Scan(). Long64_t TChain::Scan ; (; const char * ; varexp = """", . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). overridevirtual . Loop on tree and print entries passing selection. . If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"". See TTreePlayer::Scan for more information. . Reimplemented from TTree.; Definition at line 2443 of file TChain.cxx. ◆ SetAutoDelete(). void TChain::SetAutoDelete ; (; bool ; autodelete = true). virtual . Set the global branch kAutoDelete bit. ; When LoadTree loads a new Tree, the branches for which the address is set will have the option AutoDelete set For more details on AutoDelete, see TBranch::SetAutoDelete. ; Definition at line 2458 of file TChain.cxx. ◆ SetBranchAddress() [1/5]. template<class T > . Int_t TChain::SetBranchAddress ; (; const char * ; bname, . T ** ; add, . TBranch ** ; ptr = nullptr . ). inline . Definition at line 149 of file TChain.h. ◆ SetBranchAddress() [2/5]. template<class T > . Int_t TChain::SetBranchAddress ; (; const char * ; bname, . T * ; add, . TBranch ** ; ptr = nullptr . ). inline . Definition at line 155 of file TChain.h. ◆ SetBranchAddress() [3/5]. Int_t TChain::SetBranchAddress ; (; const char * ; bname, . void * ; add, . TBranch ** ; ptr, . TClass * ; realClass, . EDataType ; datatype, . bool ; isptr . ). overridevirtual . Check if bname is already in the status list, and if not, create a TChainElement object and set its address. ; See TTree::CheckBranchAddressType for the semantic of the return value.; Note: See the comments in TBranchElement::SetAddress() for a more ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain.html:94129,Load,LoadTree,94129,doc/master/classTChain.html,https://root.cern,https://root.cern/doc/master/classTChain.html,2,"['Load', 'load']","['LoadTree', 'loads']"
Performance,"version 6.07/03:**; 1181 ; 1182A second rendering technique is also available with the COL2 and COLZ2 options.; 1183 ; 1184These options provide potential performance improvements compared to the standard; 1185COL option. The performance comparison of the COL2 to the COL option depends on; 1186the histogram and the size of the rendering region in the current pad. In general,; 1187a small (approx. less than 100 bins per axis), sparsely populated TH2 will render; 1188faster with the COL option.; 1189 ; 1190However, for larger histograms (approx. more than 100 bins per axis); 1191that are not sparse, the COL2 option will provide up to 20 times performance improvements.; 1192For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude; 1193faster with the COL2 option.; 1194 ; 1195The COL2 option will also scale its performance based on the size of the; 1196pixmap the histogram image is being rendered into. It also is much better optimized for; 1197sessions where the user is forwarding X11 windows through an `ssh` connection.; 1198 ; 1199For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; 1200and COLZ options. There is one major difference and that concerns the treatment of; 1201bins with zero content. The COL2 and COLZ2 options color these bins the color of zero.; 1202 ; 1203COL2 option renders the histogram as a bitmap. Therefore it cannot be saved in vector; 1204graphics file format like PostScript or PDF (an empty image will be generated). It can; 1205be saved only in bitmap files like PNG format for instance.; 1206 ; 1207 ; 1208\anchor HP140; 1209### The CANDLE and VIOLIN options; 1210 ; 1211The mechanism behind Candle plots and Violin plots is very similar. Because of this they are; 1212implemented in the same class TCandle. The keywords CANDLE or VIOLIN will initiate the drawing of; 1213the corresponding plots. Followed by the keyword the user can select a plot direction (X or V for; 1214vertical projections,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:48451,optimiz,optimized,48451,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['optimiz'],['optimized']
Performance,"version Streamer member function.; 243 Int_t fSizeof; //Sizeof the class.; 244 ; 245 std::atomic<Char_t> fCanSplit; //!Indicates whether this class can be split or not. Values are -1, 0, 1, 2; 246 ; 247 // Bit field; 248 /// Indicates whether this class represents a pair and was not created from a dictionary nor interpreter info but has; 249 /// compiler compatible offset and size (and all the info is in the StreamerInfo per se); 250 Bool_t fIsSyntheticPair : 1; //!; 251 ; 252 /// @brief The class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based) automatic streamer.; 253 Bool_t fHasCustomStreamerMember : 1; //!; 254 ; 255 mutable std::atomic<Long_t> fProperty; //!Property See TClass::Property() for details; 256 mutable Long_t fClassProperty; //!C++ Property of the class (is abstract, has virtual table, etc.); 257 ; 258 // fHasRootPcmInfo needs to be atomic as long as GetListOfBases needs to modify it.; 259 std::atomic<Bool_t> fHasRootPcmInfo; //!Whether info was loaded from a root pcm.; 260 mutable std::atomic<Bool_t> fCanLoadClassInfo; //!Indicates whether the ClassInfo is supposed to be available.; 261 mutable std::atomic<Bool_t> fIsOffsetStreamerSet; //!saved remember if fOffsetStreamer has been set.; 262 mutable std::atomic<Bool_t> fVersionUsed; //!Indicates whether GetClassVersion has been called; 263 ; 264 enum class ERuntimeProperties : UChar_t {; 265 kNotInitialized = 0,; 266 kSet = BIT(0),; 267 // kInconsistent when kSet & !kConsistent.; 268 kConsistentHash = BIT(1); 269 };; 270 friend bool operator&(UChar_t l, ERuntimeProperties r) {; 271 return l & static_cast<UChar_t>(r);; 272 }; 273 mutable std::atomic<UChar_t> fRuntimeProperties; //! Properties that can only be evaluated at run-time; 274 ; 275 mutable Longptr_t fOffsetStreamer; //!saved info to call Streamer; 276 Int_t fStreamerType; //!cached of the streaming method to use; 277 EState fState; //!Current 'state' of the class (Emulated,Interpreted,Loaded); 278 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:11670,load,loaded,11670,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,2,['load'],['loaded']
Performance,"vers} { }; 4384 ; 4385 ~RestoreStateRAII() {; 4386 for (auto& serverData : _servers) {; 4387 serverData.server->setCachedValue(serverData.oldValue, true);; 4388 serverData.server->setOperMode(serverData.oldOperMode);; 4389 serverData.server->_valueDirty = serverData.oldValueDirty;; 4390 serverData.server->_shapeDirty = serverData.oldShapeDirty;; 4391 }; 4392 }; 4393 ; 4394 std::vector<ServerData>& _servers;; 4395 } restoreState{ourServers};; 4396 ; 4397 ; 4398 // Advising to implement the batch interface makes only sense if the batch was not a scalar.; 4399 // Otherwise, there would be no speedup benefit.; 4400 if(output.size() > 1 && RooMsgService::instance().isActive(this, RooFit::FastEvaluations, RooFit::INFO)) {; 4401 coutI(FastEvaluations) << ""The class "" << ClassName() << "" does not implement the faster batch evaluation interface.""; 4402 << "" Consider requesting or implementing it to benefit from a speed up."" << std::endl;; 4403 }; 4404 ; 4405 ; 4406 // For each event, write temporary values into our servers' caches, and run a single-value computation.; 4407 ; 4408 for (std::size_t i=0; i < output.size(); ++i) {; 4409 for (auto& serv : ourServers) {; 4410 serv.server->setCachedValue(serv.batch[std::min(i, serv.batch.size()-1)], false);; 4411 }; 4412 ; 4413 output[i] = evaluate();; 4414 }; 4415}; 4416 ; 4417////////////////////////////////////////////////////////////////////////////////; 4418/// This function defines the analytical integral translation for the class.; 4419///; 4420/// \param[in] code The code that decides the integrands.; 4421/// \param[in] rangeName Name of the normalization range.; 4422/// \param[in] ctx An object to manage auxiliary information for code-squashing.; 4423///; 4424/// \returns The representative code string of the integral for the given object.; 4425std::string RooAbsReal::buildCallToAnalyticIntegral(Int_t /* code */, const char * /* rangeName */,; 4426 RooFit::Detail::CodeSquashContext & /*ctx*/) const; 4427{; 4428 std::strings",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:194272,cache,caches,194272,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['cache'],['caches']
Performance,"verwrite; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kPacket; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kRate; static TObject::(anonymous)TObject::kSingleKey; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kStart; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kStop; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kUnDefined; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Long64_tfBytesReadNumber of bytes read; Long64_tfBytesReadExtraNumber of bytes (overhead) of the readahead cache; Double_tfCompressTree compression factor; Double_tfCpuTimeCpu time; Double_tfDiskTimeTime spent in pure raw disk IO; TFile*fFile!pointer to the file containing the Tree; TGraphErrors*fGraphIOpointer to the graph with IO data; TGraphErrors*fGraphTimepointer to the graph with timestamp info; TStringfHostInfoname of the host system, ROOT version and date; TText*fHostInfoTextGraphics Text object with the fHostInfo data; TStringfNamename of this TTreePerfStats; Int_tfNleavesNumber of leaves in the tree; TPaveText*fPavepointer to annotation pavetext; Int_tfReadCallsNumber of read calls; Int_tfReadaheadSizeReadahead cache size; Double_tfRealNormReal time scale factor for fGraphTime; Double_tfRealTimeReal time; TGaxis*fRealTimeAxispointer to TGaxis object showing real-time; TTree*fTree!pointer to the Tree being monitored; Int_tfTreeCacheSizeTTreeCache buffer size; Double_tfUnzipTimeTime spent uncompressing the data.; TStopwatch*fWatchTStopwatch pointer. Class Charts. Inheritance Chart:. TObject. ←; TVirtualPerfStats. ←; TTreePerfStats. Function documentation; TTreePerfStats(); default constructor (used when reading an object only). TTreePerfStats(const char* name, TTree* T); Create a TTree I/O perf stats object. ~TTreePerfStats(); Destructor. void Browse(TBrowser* b); Browse. Int_t DistancetoPrimitive(Int_t px, Int_t py); Return distance to one of the objects in the TTreePerfStats. void D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreePerfStats.html:10501,cache,cache,10501,root/html602/TTreePerfStats.html,https://root.cern,https://root.cern/root/html602/TTreePerfStats.html,4,['cache'],['cache']
Performance,"very specification document. Short overview:. If the BEARER_TOKEN environment variable is set, then the value is taken to be the token contents.; If the BEARER_TOKEN_FILE environment variable is set, then its value is interpreted as a filename. The contents of the specified file are taken to be the token contents.; If the XDG_RUNTIME_DIR environment variable is set, then take the token from the contents of $XDG_RUNTIME_DIR/bt_u$ID(this additional location is intended to provide improved security for shared login environments as $XDG_RUNTIME_DIR is defined to be user-specific as opposed to a system-wide directory.).; Otherwise, take the token from /tmp/bt_u$ID. Xrootd client support; ROOT can now be built with Xrootd 5 client libraries.; GUI Libraries; RBrowser improvements. central factory methods to handle browsing, editing and drawing of different classes; simple possibility to extend RBrowser on user-defined classes; support of web-based geometry viewer; better support of TTree drawing; server-side handling of code editor and image viewer widgets; rbrowser content is fully recovered when web-browser is reloaded; load of widgets code only when really required (shorter startup time for RBrowser). JavaScript ROOT; Major JSROOT update to version 6. update all used libraries d3.js, three.js, MathJax.js, openui5; change to Promise based interface for all async methods, remove call-back arguments; change scripts names, core scripts name now JSRoot.core.js; unify function/methods naming conventions, many changes in method names; provide central code loader via JSROOT.require, supporting 4 different loading engines; many nice features and many bug fixes; see JSROOT v6 release notes. Class Reference Guide; One can now select a class’s documentation for a specific version. If a class does not exist in a given version, that version is grayed out, see for instance the documentation for ROOT::Experimental::RNTupleReader.; Build, Configuration and Testing Infrastructure. a new ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:28488,load,load,28488,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['load'],['load']
Performance,"ves () const override;  ; void ClearCurrentOvlElm ();  Reset current overlay-element to zero, eventually notifying the old one that the mouse has left. ;  ; virtual void Clicked (TObject *obj);  Emit Clicked signal. ;  ; virtual void Clicked (TObject *obj, UInt_t button, UInt_t state);  Emit Clicked signal with button id and modifier state. ;  ; void CloseComposite () override;  ; TGLColorSet & ColorSet ();  ; virtual void CreateGLWidget ();  ; TGLCamera & CurrentCamera () const;  ; virtual void DestroyGLWidget ();  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Calculate and return pixel distance to nearest viewer object from window location px, py This is provided for use when embedding GL viewer into pad. ;  ; void DoDraw (Bool_t swap_buffers=kTRUE);  Draw out the viewer. ;  ; void DoDrawMono (Bool_t swap_buffers);  Draw out in monoscopic mode. ;  ; void DoDrawStereo (Bool_t swap_buffers);  Draw out in stereoscopic mode. ;  ; Bool_t DoOverlaySelect (Int_t x, Int_t y);  Perform GL selection, picking overlay objects only. ;  ; Bool_t DoSecondarySelect (Int_t x, Int_t y);  Secondary selection. ;  ; Bool_t DoSelect (Int_t x, Int_t y);  Perform GL selection, picking objects overlapping WINDOW area described by 'rect'. ;  ; virtual void DoubleClicked ();  ; void DrawDebugInfo ();  If in debug mode draw camera aids and overall bounding box. ;  ; void DrawGuides ();  Draw reference marker and coordinate axes. ;  ; void EndScene () override;  ; void ExecuteEvent (Int_t event, Int_t px, Int_t py) override;  Process event of type 'event' - one of EEventType types, occurring at window location px, py This is provided for use when embedding GL viewer into pad. ;  ; TGLAutoRotator * GetAutoRotator ();  Get the auto-rotator for this viewer. ;  ; TGLCameraOverlay * GetCameraOverlay () const;  ; Bool_t GetClipAutoUpdate () const;  ; TGLClipSet * GetClipSet () const;  ; TGLOverlayElement * GetCurrentOvlElm () const;  ; Int_t GetDev () const;  ; EDragAction GetDragActio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLViewer.html:4452,Perform,Perform,4452,doc/master/classTGLViewer.html,https://root.cern,https://root.cern/doc/master/classTGLViewer.html,1,['Perform'],['Perform']
Performance,"viceTDevice ;  CTGradientDescent;  CTLayerGeneric layer class ;  CTNetGeneric neural network class ;  CTReferenceThe reference architecture class ;  CTSharedLayerLayer class width shared weight and bias layers ;  ►NExperimental;  CClassification;  CClassificationResult;  ►NkNN;  CEvent;  CModulekNN;  CNodeThis file contains binary tree and global function template that searches tree for k-nearest neigbors ;  CAbsoluteDeviationLossFunctionAbsolute Deviation Loss Function ;  CAbsoluteDeviationLossFunctionBDTAbsolute Deviation BDT Loss Function ;  CAbsValue;  CBDTEventWrapper;  CBinarySearchTreeA simple Binary search tree including a volume search method ;  CBinarySearchTreeNodeNode for the BinarySearch or Decision Trees ;  CBinaryTreeBase class for BinarySearch and Decision Trees ;  CCCPrunerA helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) ;  ►CCCTreeWrapper;  CCCTreeNode;  CClassificationClass to perform two class classification ;  CClassificationResultClass to save the results of the classifier ;  CClassifierFactoryThis is the MVA factory ;  CClassInfoClass that contains all the information of a class ;  Ccompose_binary_t;  Ccompose_unary_t;  ►CConfigSingleton class for global configuration settings used by TMVA ;  CIONames;  CVariablePlotting;  CConfigurable;  CConvergenceTestCheck for convergence ;  CCostComplexityPruneToolA class to prune a decision tree using the Cost Complexity method ;  CCrossEntropyImplementation of the CrossEntropy as separation criterion ;  CCrossValidationClass to perform cross validation, splitting the dataloader into folds ;  CCrossValidationResultClass to save the results of cross validation, the metric for the classification ins ROC and you can ROC curves ROC integrals, ROC average and ROC standard deviation ;  CDataInputHandlerClass that contains all the data information ;  CDataLoader;  CDataSetClass that contains all the data information ;  ►CData",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:76618,perform,perform,76618,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,1,['perform'],['perform']
Performance,"vide special functor for gROOT, while ROOT::GetROOT() does not return reference; 1795 TGlobalMappedFunction::MakeFunctor(""gROOT"", ""TROOT*"", ROOT::GetROOT, [] {; 1796 ROOT::GetROOT();; 1797 return (void *)&ROOT::Internal::gROOTLocal;; 1798 });; 1799 ; 1800 TGlobalMappedFunction::MakeFunctor(""gPad"", ""TVirtualPad*"", TVirtualPad::Pad);; 1801 TGlobalMappedFunction::MakeFunctor(""gVirtualX"", ""TVirtualX*"", TVirtualX::Instance);; 1802 TGlobalMappedFunction::MakeFunctor(""gDirectory"", ""TDirectory*"", TDirectory::CurrentDirectory);; 1803 ; 1804 // Don't let TGlobalMappedFunction delete our globals, now that we take them.; 1805 fGlobals->AddAll(&TGlobalMappedFunction::GetEarlyRegisteredGlobals());; 1806 TGlobalMappedFunction::GetEarlyRegisteredGlobals().SetOwner(kFALSE);; 1807 TGlobalMappedFunction::GetEarlyRegisteredGlobals().Clear();; 1808 }; 1809 ; 1810 if (!fInterpreter); 1811 Fatal(""GetListOfGlobals"", ""fInterpreter not initialized"");; 1812 ; 1813 if (load) fGlobals->Load();; 1814 ; 1815 return fGlobals;; 1816}; 1817 ; 1818////////////////////////////////////////////////////////////////////////////////; 1819/// Return list containing the TFunctions currently defined.; 1820/// Since functions are created and deleted during execution of the; 1821/// program, we need to update the list of functions every time we; 1822/// execute this method. However, when calling this function in; 1823/// a (tight) loop where no interpreter symbols will be created; 1824/// you can set load=kFALSE (default).; 1825 ; 1826TCollection *TROOT::GetListOfGlobalFunctions(Bool_t load); 1827{; 1828 R__LOCKGUARD(gROOTMutex);; 1829 ; 1830 if (!fGlobalFunctions) {; 1831 fGlobalFunctions = new TListOfFunctions(nullptr);; 1832 }; 1833 ; 1834 if (!fInterpreter); 1835 Fatal(""GetListOfGlobalFunctions"", ""fInterpreter not initialized"");; 1836 ; 1837 // A thread that calls with load==true and a thread that calls with load==false; 1838 // will conflict here (the load==true will be updating the list while the; 1839 //",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:69875,load,load,69875,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,4,"['Load', 'load']","['Load', 'load']"
Performance,"vided, a Fatal error will be issued if the Buffer attempts to; expand. void Expand(Int_t newsize); Expand the I/O buffer to newsize bytes. TObject * GetParent() const; Return pointer to parent of this buffer. void SetParent(TObject* parent); Set parent owning this buffer. ReAllocCharFun_t GetReAllocFunc() const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass(). TClass * GetClass(const char* className); Forward to TROOT::GetClass(). TProcessID * ReadProcessID(UShort_t pidf); Return the current PRocessID. UShort_t WriteProcessID(TProcessID* pid); Always return 0 (current processID). void PushDataCache(TVirtualArray* ); Push a new data cache area onto the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PeekDataCache() const; Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. TVirtualArray * PopDataCache(); Pop and Return the 'current' data cache area from the list of area to be used for; temporarily store 'missing' data members. void operator=(const TBuffer& ). Int_t Read(const char* name); { return TObject::Read(name); }. Int_t Write(const char* name, Int_t opt, Int_t bufs); { return TObject::Write(name, opt, bufs); }. Int_t Write(const char* name, Int_t opt, Int_t bufs) const; { return TObject::Write(name, opt, bufs); }. Int_t GetBufferVersion() const; { return fVersion; }. Bool_t IsReading() const; { return (fMode & kWrite) == 0; }. Bool_t IsWriting() const; { return (fMode & kWrite) != 0; }. void SetBufferOffset(Int_t offset = 0); { fBufCur = fBuffer+offset; }. char * Buffer() const; { return fBuffer; }. Int_t BufferSize() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBuffer.html:17857,cache,cache,17857,root/html528/TBuffer.html,https://root.cern,https://root.cern/root/html528/TBuffer.html,1,['cache'],['cache']
Performance,"vidual packages need to do this work, and not every C++ developer has Python, let alone SWIG, experience.; Then there's PyPy. All existing binding generator tools (including PyROOT) rely on CPython internals, or at least on the Python C-API. That does not jive with PyPy as it has for example a garbage collector instead of reference counting. Through some heroics, it does expose a Python C-API, but it's slow as it interferes (blocks, really) the just-in-time compiler. Therefore, within PyPy, there are two new approaches: cffi for C and cppyy for C++. Both are part of the standard PyPy releases. There is also already a PyROOT version for the latter (see: http://root.cern.ch/drupal/content/pypyroot).; Cheers,; Wim. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:49 Permalink . Why? . I don't understand. You wish to maintain backwards compatibility. This implies maintaining the insanity that is the equivalence of ""."" and ""->"". Not only is this wrong, this egregiously ignores performance concerns that come with dereferencing. It also ensures that people using ROOT/Cling while learning C++ will have trouble compiling their programs using actual compilers. It implies that you intend to keep the (at best) insane class hierarchy TF1 <- TF2 <- TF3 and so on. This example shows some of the major design flaws in ROOT -- a 2-dimensional function IS a 1-dimensional function? There is no abstract base class? No templates? It implies that you plan to keep the pointless T in front of all the names of ROOT, even though you will have access to namespaces (finally) and thus can move past the 1970's C practice of avoiding name collisions by a sort of weird Hungarian notation. It implies that you plan to maintain the outdated interfaces which make no use of templates. Templates are one of the most powerful features of C++, are more relevant to performance critical tasks than inheritance, and help ensure the type-safety of code (thereby ensuring the accuracy of data by helpi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:8919,perform,performance,8919,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['perform'],['performance']
Performance,"viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooMinuit. class RooMinuit: public TObject. RooMinuit is a wrapper class around TFitter/TMinuit that; provides a seamless interface between the MINUIT functionality; and the native RooFit interface.; ; RooMinuit can minimize any RooAbsReal function with respect to; its parameters. Usual choices for minimization are RooNLLVar; and RooChi2Var; ; RooMinuit has methods corresponding to MINUIT functions like; hesse(), migrad(), minos() etc. In each of these function calls; the state of the MINUIT engine is synchronized with the state; of the RooFit variables: any change in variables, change; in the constant status etc is forwarded to MINUIT prior to; execution of the MINUIT call. Afterwards the RooFit objects; are resynchronized with the output state of MINUIT: changes; parameter values, errors are propagated.; ; Various methods are available to control verbosity, profiling,; automatic PDF optimization.; . Function Members (Methods); public:. RooMinuit(RooAbsReal& function); virtual~RooMinuit(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; RooPlot*contour(RooRealVar& var1, RooRealVar& var2, Double_t n1 = 1, Double_t n2 = 2, Double_t n3 = 0, Double_t n4 = 0, Double_t n5 = 0, Double_t n6 = 0); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::Draw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMinuit.html:1150,optimiz,optimization,1150,root/html526/RooMinuit.html,https://root.cern,https://root.cern/root/html526/RooMinuit.html,5,['optimiz'],['optimization']
Performance,"viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooMinuit. class RooMinuit: public TObject. RooMinuit is a wrapper class around TFitter/TMinuit that; provides a seamless interface between the MINUIT functionality; and the native RooFit interface.; ; RooMinuit can minimize any RooAbsReal function with respect to; its parameters. Usual choices for minimization are RooNLLVar; and RooChi2Var; ; RooMinuit has methods corresponding to MINUIT functions like; hesse(), migrad(), minos() etc. In each of these function calls; the state of the MINUIT engine is synchronized with the state; of the RooFit variables: any change in variables, change; in the constant status etc is forwarded to MINUIT prior to; execution of the MINUIT call. Afterwards the RooFit objects; are resynchronized with the output state of MINUIT: changes; parameter values, errors are propagated.; ; Various methods are available to control verbosity, profiling,; automatic PDF optimization.; . Function Members (Methods); public:. virtual~RooMinuit(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; RooPlot*contour(RooRealVar& var1, RooRealVar& var2, Double_t n1 = 1, Double_t n2 = 2, Double_t n3 = 0, Double_t n4 = 0, Double_t n5 = 0, Double_t n6 = 0); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMinuit.html:1150,optimiz,optimization,1150,root/html602/RooMinuit.html,https://root.cern,https://root.cern/root/html602/RooMinuit.html,2,['optimiz'],['optimization']
Performance,"virtual . Implemented in TCling. ◆ IsSameType(). virtual Bool_t TInterpreter::IsSameType ; (; const void * ; , . const void * ;  . ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 553 of file TInterpreter.h. ◆ IsSignedIntegerType(). virtual Bool_t TInterpreter::IsSignedIntegerType ; (; const void * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 555 of file TInterpreter.h. ◆ IsUnsignedIntegerType(). virtual Bool_t TInterpreter::IsUnsignedIntegerType ; (; const void * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 556 of file TInterpreter.h. ◆ IsVoidPointerType(). virtual Bool_t TInterpreter::IsVoidPointerType ; (; const void * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 559 of file TInterpreter.h. ◆ Load(). virtual Int_t TInterpreter::Load ; (; const char * ; filenam, . Bool_t ; system = kFALSE . ). pure virtual . Implemented in TCling. ◆ LoadEnums(). virtual void TInterpreter::LoadEnums ; (; TListOfEnums & ; cl); const. pure virtual . Implemented in TCling. ◆ LoadFile(). virtual int TInterpreter::LoadFile ; (; const char * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 259 of file TInterpreter.h. ◆ LoadFunctionTemplates(). virtual void TInterpreter::LoadFunctionTemplates ; (; TClass * ; cl); const. pure virtual . Implemented in TCling. ◆ LoadLibraryMap(). virtual Int_t TInterpreter::LoadLibraryMap ; (; const char * ; rootmapfile = nullptr). pure virtual . Implemented in TCling. ◆ LoadMacro(). virtual void TInterpreter::LoadMacro ; (; const char * ; filename, . EErrorCode * ; error = nullptr . ). pure virtual . Implemented in TCling. ◆ LoadText(). virtual Bool_t TInterpreter::LoadText ; (; const char * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 260 of file TInterpreter.h. ◆ MakeInterpreterValue(). virtual std::unique_ptr< TInterpreterValue > TInterpreter::MakeInterpreterValue ; (; ); const. inlinevirtual . Reimp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTInterpreter.html:78493,Load,LoadEnums,78493,doc/master/classTInterpreter.html,https://root.cern,https://root.cern/doc/master/classTInterpreter.html,1,['Load'],['LoadEnums']
Performance,"virtual . Set all the TNamed parameters (name and title). ; WARNING: if the name is changed and the object is a member of a THashTable or THashList container the container must be Rehash()'ed after SetName(). For example the list of objects in the current directory is a THashList. ; Reimplemented from TNamed.; Definition at line 2384 of file RooAbsArg.cxx. ◆ setOperMode(). void RooAbsArg::setOperMode ; (; OperMode ; mode, . bool ; recurseADirty = true . ). Set the operation mode of this node. ; Change cache operation mode to given mode.; If recurseAdirty is true, then a mode change to AlwaysDirty will automatically be propagated recursively to all client nodes ; Definition at line 1963 of file RooAbsArg.cxx. ◆ setProhibitServerRedirect(). void RooAbsArg::setProhibitServerRedirect ; (; bool ; flag). inline . Definition at line 521 of file RooAbsArg.h. ◆ setProxyNormSet(). void RooAbsArg::setProxyNormSet ; (; const RooArgSet * ; nset). protected . Forward a change in the cached normalization argset to all the registered proxies. ; Definition at line 1468 of file RooAbsArg.cxx. ◆ setShapeDirty() [1/2]. void RooAbsArg::setShapeDirty ; (; ). inline . Notify that a shape-like property (e.g. binning) has changed. ; Definition at line 467 of file RooAbsArg.h. ◆ setShapeDirty() [2/2]. void RooAbsArg::setShapeDirty ; (; const RooAbsArg * ; source). protected . Notify that a shape-like property (e.g. binning) has changed. ; Mark this object as having changed its shape, and propagate this status change to all of our clients. ; Definition at line 978 of file RooAbsArg.cxx. ◆ setStringAttribute(). void RooAbsArg::setStringAttribute ; (; const Text_t * ; key, . const Text_t * ; value . ). Associate string 'value' to this object under key 'key'. ; Definition at line 254 of file RooAbsArg.cxx. ◆ setTransientAttribute(). void RooAbsArg::setTransientAttribute ; (; const Text_t * ; name, . bool ; value = true . ). Set (default) or clear a named boolean attribute of this object. ; Defini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:98845,cache,cached,98845,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['cache'],['cached']
Performance,"virtual Bool_t TInterpreter::IsSignedIntegerType ; (; const void * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 555 of file TInterpreter.h. ◆ IsUnsignedIntegerType(). virtual Bool_t TInterpreter::IsUnsignedIntegerType ; (; const void * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 556 of file TInterpreter.h. ◆ IsVoidPointerType(). virtual Bool_t TInterpreter::IsVoidPointerType ; (; const void * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 559 of file TInterpreter.h. ◆ Load(). virtual Int_t TInterpreter::Load ; (; const char * ; filenam, . Bool_t ; system = kFALSE . ). pure virtual . Implemented in TCling. ◆ LoadEnums(). virtual void TInterpreter::LoadEnums ; (; TListOfEnums & ; cl); const. pure virtual . Implemented in TCling. ◆ LoadFile(). virtual int TInterpreter::LoadFile ; (; const char * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 259 of file TInterpreter.h. ◆ LoadFunctionTemplates(). virtual void TInterpreter::LoadFunctionTemplates ; (; TClass * ; cl); const. pure virtual . Implemented in TCling. ◆ LoadLibraryMap(). virtual Int_t TInterpreter::LoadLibraryMap ; (; const char * ; rootmapfile = nullptr). pure virtual . Implemented in TCling. ◆ LoadMacro(). virtual void TInterpreter::LoadMacro ; (; const char * ; filename, . EErrorCode * ; error = nullptr . ). pure virtual . Implemented in TCling. ◆ LoadText(). virtual Bool_t TInterpreter::LoadText ; (; const char * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 260 of file TInterpreter.h. ◆ MakeInterpreterValue(). virtual std::unique_ptr< TInterpreterValue > TInterpreter::MakeInterpreterValue ; (; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 278 of file TInterpreter.h. ◆ MapCppName(). virtual const char * TInterpreter::MapCppName ; (; const char * ; ); const. inlinevirtual . Reimplemented in TCling.; Definition at line 261 of file TInterpreter.h. ◆ Meth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTInterpreter.html:78745,Load,LoadFunctionTemplates,78745,doc/master/classTInterpreter.html,https://root.cern,https://root.cern/doc/master/classTInterpreter.html,1,['Load'],['LoadFunctionTemplates']
Performance,"virtual Bool_t ProcessBatchHolder (std::shared_ptr< THttpCallArg > &);  Method used to accept or reject root_batch_holder.js request. ;  ; virtual void VerifyDefaultPageContent (std::shared_ptr< THttpCallArg > &arg);  Method called when default page content is prepared for use By default no-cache header is provided. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions; Int_t CompleteSend (std::shared_ptr< THttpWSEngine > &engine);  Complete current send operation. ;  ; std::shared_ptr< THttpWSEngine > FindEngine (UInt_t id, Bool_t book_send=kFALSE);  Find websocket connection handle with given id If book_send parameter specified, have to book send operation under the mutex. ;  ; Bool_t HandleWS (std::shared_ptr< THttpCallArg > &arg);  Process request to websocket Different kind of requests coded into THttpCallArg::Method: ;  ; Int_t PerformSend (std::shared_ptr< THttpWSEngine > engine);  Perform send operation, stored in buffer. ;  ; void RemoveEngine (std::shared_ptr< THttpWSEngine > &engine, Bool_t terminate=kFALSE);  Remove and destroy WS connection. ;  ; Int_t RunSendingThrd (std::shared_ptr< THttpWSEngine > engine);  Send data stored in the buffer. ;  . Private Attributes; Bool_t fDisabled {kFALSE};  ! when true, all further operations will be ignored ;  ; std::vector< std::shared_ptr< THttpWSEngine > > fEngines;  ! list of active WS engines (connections) ;  ; std::mutex fMutex;  ! protect list of engines ;  ; Int_t fSendCnt {0};  ! counter for completed send operations ;  ; Bool_t fSyncMode {kTRUE};  ! is handler runs in synchronous mode (default, no multi-threading) ;  . Friends; class THttpServer;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpWSHandler.html:14889,Perform,PerformSend,14889,doc/master/classTHttpWSHandler.html,https://root.cern,https://root.cern/doc/master/classTHttpWSHandler.html,2,['Perform'],"['Perform', 'PerformSend']"
Performance,"virtual Int_t *GetIndex() { return &fIndex.fArray[0]; }; 522 virtual Double_t *GetIndexValues() { return &fIndexValues.fArray[0]; }; 523 ROOT::TIOFeatures GetIOFeatures() const;; 524 virtual TIterator *GetIteratorOnAllLeaves(bool dir = kIterForward);; 525 virtual TLeaf *GetLeaf(const char* branchname, const char* leafname);; 526 virtual TLeaf *GetLeaf(const char* name);; 527 virtual TList *GetListOfClones() { return fClones; }; 528 virtual TObjArray *GetListOfBranches() { return &fBranches; }; 529 virtual TObjArray *GetListOfLeaves() { return &fLeaves; }; 530 virtual TList *GetListOfFriends() const { return fFriends; }; 531 virtual TList *GetListOfAliases() const { return fAliases; }; 532 ; 533 // GetMakeClass is left non-virtual for efficiency reason.; 534 // Making it virtual affects the performance of the I/O; 535 Int_t GetMakeClass() const { return fMakeClass; }; 536 ; 537 virtual Long64_t GetMaxEntryLoop() const { return fMaxEntryLoop; }; 538 virtual Double_t GetMaximum(const char* columname);; 539 static Long64_t GetMaxTreeSize();; 540 virtual Long64_t GetMaxVirtualSize() const { return fMaxVirtualSize; }; 541 virtual Double_t GetMinimum(const char* columname);; 542 virtual Int_t GetNbranches() { return fBranches.GetEntriesFast(); }; 543 TObject *GetNotify() const { return fNotify; }; 544 TVirtualTreePlayer *GetPlayer();; 545 virtual Int_t GetPacketSize() const { return fPacketSize; }; 546 virtual TVirtualPerfStats *GetPerfStats() const { return fPerfStats; }; 547 TTreeCache *GetReadCache(TFile *file) const;; 548 TTreeCache *GetReadCache(TFile *file, bool create);; 549 virtual Long64_t GetReadEntry() const { return fReadEntry; }; 550 virtual Long64_t GetReadEvent() const { return fReadEntry; }; 551 virtual Int_t GetScanField() const { return fScanField; }; 552 TTreeFormula *GetSelect() { return GetPlayer()->GetSelect(); }; 553 virtual Long64_t GetSelectedRows() { return GetPlayer()->GetSelectedRows(); }; 554 virtual Int_t GetTimerInterval() const { return fTime",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:28964,perform,performance,28964,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['perform'],['performance']
Performance,"virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TNetFile.html:13287,cache,cacheDir,13287,root/html530/TNetFile.html,https://root.cern,https://root.cern/root/html530/TNetFile.html,2,['cache'],['cacheDir']
Performance,"virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* classname, Bool_t load); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load); virtual TClass*GetClass(const char* classname, Bool_t load, Bool_t silent); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClassGenerator.html:2016,load,load,2016,root/html526/TClassGenerator.html,https://root.cern,https://root.cern/root/html526/TClassGenerator.html,7,['load'],['load']
Performance,"virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; TClass * IsA () const override;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this infor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:14546,Perform,Perform,14546,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['Perform'],['Perform']
Performance,"virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; TClass * IsA () const override;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Long64_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:14547,Perform,Perform,14547,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['Perform'],['Perform']
Performance,"virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSetRooAbsData::_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TString_blindStringBlinding string (optionally read from ASCII files) ; TTree*_treeTTree holding the data points; RooArgSet_truthTruth variables . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Last changed: Thu Sep 23 20:01:26 2010 » Last generated: 2010-09-23 20:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooTreeData.html:14197,cache,cached,14197,root/html528/RooTreeData.html,https://root.cern,https://root.cern/root/html528/RooTreeData.html,2,['cache'],['cached']
Performance,"virtual TInetAddress GetHostByName(const char *server)Get Internet Protocol (IP) address of host.Definition TSystem.cxx:2291; TSystem::SetPrognamevirtual void SetProgname(const char *name)Set the application name (from command line, argv[0]) and copy it in gProgName.Definition TSystem.cxx:226; TSystem::SendRawvirtual int SendRaw(int sock, const void *buffer, int length, int flag)Send exactly length bytes from buffer.Definition TSystem.cxx:2409; TSystem::SetFPEMaskvirtual Int_t SetFPEMask(Int_t mask=kDefaultMask)Set which conditions trigger a floating point exception.Definition TSystem.cxx:642; TSystem::fLevelInt_t fLevelDefinition TSystem.h:292; TSystem::GetBuildCompilervirtual const char * GetBuildCompiler() constReturn the build compiler.Definition TSystem.cxx:3883; TSystem::CloseConnectionvirtual void CloseConnection(int sock, Bool_t force=kFALSE)Close socket connection.Definition TSystem.cxx:2390; TSystem::GetLibrariesvirtual const char * GetLibraries(const char *regexp="""", const char *option="""", Bool_t isRegexp=kTRUE)Return a space separated list of loaded shared libraries.Definition TSystem.cxx:2136; TSystem::GetListOfSignalHandlersvirtual TSeqCollection * GetListOfSignalHandlers() constDefinition TSystem.h:379; TSystem::fBuildDirTString fBuildDirDefinition TSystem.h:307; TSystem::SetErrorStrvoid SetErrorStr(const char *errstr)Set the system error string.Definition TSystem.cxx:245; TSystem::RemoveSignalHandlervirtual TSignalHandler * RemoveSignalHandler(TSignalHandler *sh)Remove a signal handler from list of signal handlers.Definition TSystem.cxx:542; TSystem::SetSoExtvirtual void SetSoExt(const char *soExt)Set shared library extension, should be either .so, .sl, .a, .dll, etc.Definition TSystem.cxx:4236; TSystem::Closelogvirtual void Closelog()Close connection to system log daemon.Definition TSystem.cxx:1694; TSystem::fBuildCompilerTString fBuildCompilerDefinition TSystem.h:303; TSystem::Setenvvirtual void Setenv(const char *name, const char *value)Set enviro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:59811,load,loaded,59811,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['load'],['loaded']
Performance,"virtual TInetAddress GetHostByName(const char *server)Get Internet Protocol (IP) address of host.Definition TSystem.cxx:2291; TSystem::SetPrognamevirtual void SetProgname(const char *name)Set the application name (from command line, argv[0]) and copy it in gProgName.Definition TSystem.cxx:226; TSystem::SendRawvirtual int SendRaw(int sock, const void *buffer, int length, int flag)Send exactly length bytes from buffer.Definition TSystem.cxx:2409; TSystem::SetFPEMaskvirtual Int_t SetFPEMask(Int_t mask=kDefaultMask)Set which conditions trigger a floating point exception.Definition TSystem.cxx:642; TSystem::fLevelInt_t fLevelDefinition TSystem.h:292; TSystem::GetBuildCompilervirtual const char * GetBuildCompiler() constReturn the build compiler.Definition TSystem.cxx:3883; TSystem::CloseConnectionvirtual void CloseConnection(int sock, Bool_t force=kFALSE)Close socket connection.Definition TSystem.cxx:2390; TSystem::GetLibrariesvirtual const char * GetLibraries(const char *regexp="""", const char *option="""", Bool_t isRegexp=kTRUE)Return a space separated list of loaded shared libraries.Definition TSystem.cxx:2136; TSystem::fBuildDirTString fBuildDirDefinition TSystem.h:307; TSystem::SetErrorStrvoid SetErrorStr(const char *errstr)Set the system error string.Definition TSystem.cxx:245; TSystem::RemoveSignalHandlervirtual TSignalHandler * RemoveSignalHandler(TSignalHandler *sh)Remove a signal handler from list of signal handlers.Definition TSystem.cxx:542; TSystem::SetSoExtvirtual void SetSoExt(const char *soExt)Set shared library extension, should be either .so, .sl, .a, .dll, etc.Definition TSystem.cxx:4236; TSystem::Closelogvirtual void Closelog()Close connection to system log daemon.Definition TSystem.cxx:1694; TSystem::fBuildCompilerTString fBuildCompilerDefinition TSystem.h:303; TSystem::Setenvvirtual void Setenv(const char *name, const char *value)Set environment variable.Definition TSystem.cxx:1649; TSystem::GetBuildArchvirtual const char * GetBuildArch() constReturn t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:191095,load,loaded,191095,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['loaded']
Performance,"virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); Bool_tRollback(); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t, TFile::ERelativeTo = kBeg); voidSetArrayLimit(Int_t limit = 20); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSQLFile.html:18407,cache,cache,18407,root/html530/TSQLFile.html,https://root.cern,https://root.cern/root/html530/TSQLFile.html,1,['cache'],['cache']
Performance,"virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGenCategory.html:16839,cache,cache,16839,root/html534/RooGenCategory.html,https://root.cern,https://root.cern/root/html534/RooGenCategory.html,4,['cache'],['cache']
Performance,"virtual voidRooAbsReal::attachToTree(TTree& t, Int_t bufSize = 32000); virtual voidRooAbsReal::attachToVStore(RooVectorDataStore& vstore); virtual const char*binningName() const; TStringcacheNameSuffix(const RooArgSet& nset) const; RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidclearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); virtual RooAbsCachedReal::FuncCacheElem*createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; voiddisableCache(Bool_t flag); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tRooAbsReal::evaluate() const; virtual voidfillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; RooAbsCachedReal::FuncCacheElem*getCache(const RooArgSet* nset) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual const char*inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedReal.html:27446,cache,cache,27446,root/html532/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedReal.html,1,['cache'],['cache']
Performance,"virtual voidSetValueClass(TClass* newcl); virtual UInt_tSize() const; virtual UInt_tSizeof() const; virtual voidStreamer(TBuffer& refBuffer); virtual voidStreamer(TBuffer& refBuffer, void* pObject, int siz). protected:. voidCheckFunctions() const; virtual voidDeleteItem(Bool_t force, void* ptr) const; TGenCollectionProxy*Initialize(Bool_t silent) const; virtual TGenCollectionProxy*InitializeEx(Bool_t silent). private:. TGenCollectionProxy(); TGenCollectionProxy&operator=(const TGenCollectionProxy&). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; void*fCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCopyIterator; void*fFunctionCreateIterators; void*fFunctionDeleteIterator; void*fFunctionDeleteTwoIterators; void*fFunctionNextIterator; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionPro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGenCollectionProxy.html:3964,cache,cache,3964,root/html534/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html,1,['cache'],['cache']
Performance,"virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t, TFile::ERelativeTo = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); static voidTXMLSetup::SetNameSpaceBase(const char* namespacebase); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlySt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXMLFile.html:14007,cache,cache,14007,root/html530/TXMLFile.html,https://root.cern,https://root.cern/root/html530/TXMLFile.html,1,['cache'],['cache']
Performance,"virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRFIOFile.html:12968,cache,cache,12968,root/html532/TRFIOFile.html,https://root.cern,https://root.cern/root/html532/TRFIOFile.html,1,['cache'],['cache']
Performance,"virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static voidSetOnError(TDCacheFile::OnErrorAction = kOnErrorDefault); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static voidSetOpenT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDCacheFile.html:12322,cache,cache,12322,root/html532/TDCacheFile.html,https://root.cern,https://root.cern/root/html532/TDCacheFile.html,1,['cache'],['cache']
Performance,"virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TNetFile.html:13761,cache,cache,13761,root/html532/TNetFile.html,https://root.cern,https://root.cern/root/html532/TNetFile.html,2,['cache'],['cache']
Performance,"virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TEntryList&operator=(const TEntryList&). Data Members; public:. enum { kBlockSize; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArray*fBlocksblocks with indices of passing events (TEntryListBlocks); TEntryList*fCurrent! currently filled entry list; TDirectory*fDirectory! Pointer to directory holding this tree; Long64_tfEntriesToProcessused on proof to set the number of entries to process in a packet; TStringfFileNamename of the file, where the tree is; Long64_tfLastIndexQueried! used to optimize GetEntry() function from a loop ; Long64_tfLastIndexReturned! used to optimize GetEntry() function from a loop; TList*fListsa list of underlying entry lists for each tree of a chain; Long64_tfNnumber of entries in the list; Int_tfNBlocksnumber of TEntryListBlocks; TStringTNamed::fNameobject identifier; Bool_tfReapplyIf true, TTree::Draw will 'reapply' the original cut; Bool_tfShift! true when some sub-lists don't correspond to trees; ULong_tfStringHash! Hash value of a string of treename and filename; TStringTNamed::fTitleobject title; TStringfTreeNamename of the tree; Int_tfTreeNumber! the index of the tree in the chain (used when the entry. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEntryList(); default c-tor. TEntryList(const char* name, const char* title); c-tor with name and title. TEntryList(const char* name, const char* title, const TTree* tree); constructor with name and title, which also sets the tree. TEntryList(const char* name, const char* title, const char* treename, const char* filename); c-tor with name and title, which also sets the treename and the filen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEntryList.html:15380,optimiz,optimize,15380,root/html528/TEntryList.html,https://root.cern,https://root.cern/root/html528/TEntryList.html,6,['optimiz'],['optimize']
Performance,"virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidseal(const char* notice = """"); const char*sealNotice() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); Bool_tsetData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsOptTestStatistic.html:23636,cache,cache,23636,root/html528/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html528/RooAbsOptTestStatistic.html,1,['cache'],['cache']
Performance,"virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); voidsetDataset(RooAbsData* data); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidsetPdf(RooAbsPdf* pdf); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__RooBarlowBeestonLL.html:24516,cache,cache,24516,root/html534/RooStats__HistFactory__RooBarlowBeestonLL.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__RooBarlowBeestonLL.html,3,['cache'],['cache']
Performance,"virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsCachedReal::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCacheSource(Bool_t flag); voidsetCdfBoundaries(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsCachedReal::setInterpolationOrder(Int_t order); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedReal.html:24542,cache,cache,24542,root/html534/RooCachedReal.html,https://root.cern,https://root.cern/root/html534/RooCachedReal.html,3,['cache'],['cache']
Performance,"virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidRooAbsOptTestStatistic::seal(const char* notice = """"); const char*RooAbsOptTestStatistic::sealNotice() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsTestStatistic::setData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooChi2Var.html:25117,cache,cache,25117,root/html532/RooChi2Var.html,https://root.cern,https://root.cern/root/html532/RooChi2Var.html,3,['cache'],['cache']
Performance,"virtual voidTObject::Warning(const char* method, const char* msgfmt) const; const char*TApplication::WorkingDirectory() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static voidTApplication::Close(TApplication* app); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static voidErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidHandleCheckFile(TMessage* mess); virtual voidTApplication::Help(const char* line); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh). private:. voidExecLogon(); Int_tSendCanvases(); Int_tSetup(). Data Members; public:. static TApplication::EExitOnExceptionTApplication::kAbort; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TApplication::EStatusBits",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TApplicationServer.html:11487,Load,LoadGraphicsLibs,11487,root/html602/TApplicationServer.html,https://root.cern,https://root.cern/root/html602/TApplicationServer.html,2,['Load'],['LoadGraphicsLibs']
Performance,"virtual void GetMappedObject (UInt_t tag, void *&ptr, TClass *&ClassPtr) const =0;  ; TObject * GetParent () const;  Return pointer to parent of this buffer. ;  ; virtual UShort_t GetPidOffset () const =0;  ; ReAllocCharFun_t GetReAllocFunc () const;  Return the reallocation method currently used. ;  ; virtual UInt_t GetTRefExecId ()=0;  ; virtual Int_t GetVersionOwner () const =0;  ; virtual void IncrementLevel (TVirtualStreamerInfo *info)=0;  ; virtual void InitMap ()=0;  ; TClass * IsA () const override;  ; Bool_t IsReading () const;  ; Bool_t IsWriting () const;  ; Int_t Length () const;  ; virtual void MapObject (const TObject *obj, UInt_t offset=1)=0;  ; virtual void MapObject (const void *obj, const TClass *cl, UInt_t offset=1)=0;  ; virtual TVirtualArray * PeekDataCache () const;  Return the 'current' data cache area from the list of area to be used for temporarily store 'missing' data members. ;  ; virtual TVirtualArray * PopDataCache ();  Pop and Return the 'current' data cache area from the list of area to be used for temporarily store 'missing' data members. ;  ; virtual void PushDataCache (TVirtualArray *);  Push a new data cache area onto the list of area to be used for temporarily store 'missing' data members. ;  ; virtual Int_t ReadArray (Bool_t *&b)=0;  ; virtual Int_t ReadArray (Char_t *&c)=0;  ; virtual Int_t ReadArray (Double_t *&d)=0;  ; virtual Int_t ReadArray (Float_t *&f)=0;  ; virtual Int_t ReadArray (Int_t *&i)=0;  ; virtual Int_t ReadArray (Long64_t *&l)=0;  ; virtual Int_t ReadArray (Long_t *&l)=0;  ; virtual Int_t ReadArray (Short_t *&h)=0;  ; virtual Int_t ReadArray (UChar_t *&c)=0;  ; virtual Int_t ReadArray (UInt_t *&i)=0;  ; virtual Int_t ReadArray (ULong64_t *&l)=0;  ; virtual Int_t ReadArray (ULong_t *&l)=0;  ; virtual Int_t ReadArray (UShort_t *&h)=0;  ; virtual Int_t ReadArrayDouble32 (Double_t *&d, TStreamerElement *ele=nullptr)=0;  ; virtual Int_t ReadArrayFloat16 (Float_t *&f, TStreamerElement *ele=nullptr)=0;  ; virtual void R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBuffer.html:4462,cache,cache,4462,doc/master/classTBuffer.html,https://root.cern,https://root.cern/doc/master/classTBuffer.html,1,['cache'],['cache']
Performance,"virtual; IsVoidPointerType(const void *) constTInterpreterinlinevirtual; IsZombie() constTObjectinline; kBitMask enum valueTObject; kCanDelete enum valueTObject; kCannotPick enum valueTObject; kDangerous enum valueTInterpreter; kFatal enum valueTInterpreter; kHasUUID enum valueTObject; kInconsistent enum valueTObject; kInvalidObject enum valueTObject; kIsOnHeap enum valueTObject; kIsReferenced enum valueTObject; kKnown enum valueTInterpreter; kMustCleanup enum valueTObject; kNoContextMenu enum valueTObject; kNoError enum valueTInterpreter; kNotDeleted enum valueTObject; kObjInCanvas enum valueTObject; kOnlyPrepStep enum valueTObjectprotected; kOverwrite enum valueTObject; kProcessing enum valueTInterpreter; kRecoverable enum valueTInterpreter; kSingleKey enum valueTObject; kUnknown enum valueTInterpreter; kWithClassDefInline enum valueTInterpreter; kWriteDelete enum valueTObject; kZombie enum valueTObject; Load(const char *filenam, Bool_t system=kFALSE)=0TInterpreterpure virtual; LoadEnums(TListOfEnums &cl) const =0TInterpreterpure virtual; LoadFile(const char *) constTInterpreterinlinevirtual; LoadFunctionTemplates(TClass *cl) const =0TInterpreterpure virtual; LoadLibraryMap(const char *rootmapfile=nullptr)=0TInterpreterpure virtual; LoadMacro(const char *filename, EErrorCode *error=nullptr)=0TInterpreterpure virtual; LoadText(const char *) constTInterpreterinlinevirtual; ls(Option_t *option="""") const overrideTNamedvirtual; MakeInterpreterValue() constTInterpreterinlinevirtual; MakeZombie()TObjectinlineprotected; MapCppName(const char *) constTInterpreterinlinevirtual; MayNotUse(const char *method) constTObject; MembersMap_t typedefTInterpreter; MethodArgInfo_DefaultValue(MethodArgInfo_t *) constTInterpreterinlinevirtual; MethodArgInfo_Delete(MethodArgInfo_t *) constTInterpreterinlinevirtual; MethodArgInfo_Factory() constTInterpreterinlinevirtual; MethodArgInfo_Factory(MethodInfo_t *) constTInterpreterinlinevirtual; MethodArgInfo_FactoryCopy(MethodArgInfo_t *) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTInterpreter-members.html:20747,Load,LoadEnums,20747,doc/master/classTInterpreter-members.html,https://root.cern,https://root.cern/doc/master/classTInterpreter-members.html,1,['Load'],['LoadEnums']
Performance,"visions according to shape types can be found inside; shape classes. TGeoVolume::Divide(N, Xmin, Xmax, ""X"");. The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping; volume is in fact a virtual container that does not represent a physical object.; It contains a list of nodes that are not his daughters but that must be checked; always before the container itself. This list must be defined by users and it; is checked and resolved in a priority order. Note that the feature is non-standard; to geometrical modelers and it was introduced just to support conversions of; GEANT3 geometries, therefore its extensive usage should be avoided. Volume assemblies (TGeoVolumeAssembly). Assemblies a volumes that have neither a shape or a material/medium. Assemblies; behave exactly like normal volumes grouping several daughters together, but; the daughters can never extrude the assembly since this has no shape. However,; a bounding box and a voxelization structure are built for assemblies as for; normal volumes, so that navigation is still optimized. Assemblies are useful; for grouping hierarchically volumes which are otherwise defined in a flat; manner, but also to avoid clashes between container shapes.; To define an assembly one should just input a name, then start adding other; volumes (or volume assemblies) as content. Function Members (Methods); public:. TGeoVolume(); TGeoVolume(const char* name, const TGeoShape* shape, const TGeoMedium* med = 0); virtual~TGeoVolume(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddNode(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat = 0, Option_t* option = """"); voidAddNodeOffset(TGeoVolume* vol, Int_t copy_no, Double_t offset = 0, Option_t* option = """"); virtual voidAddNodeOverlap(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat = 0, Option_t* option = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); Double_tCapacity() const; virtual voidcd(Int_t inode) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:17179,optimiz,optimized,17179,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,1,['optimiz'],['optimized']
Performance,"visions according to shape types can be found inside; shape classes. TGeoVolume::Divide(N, Xmin, Xmax, ""X"");. The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping; volume is in fact a virtual container that does not represent a physical object.; It contains a list of nodes that are not his daughters but that must be checked; always before the container itself. This list must be defined by users and it; is checked and resolved in a priority order. Note that the feature is non-standard; to geometrical modelers and it was introduced just to support conversions of; GEANT3 geometries, therefore its extensive usage should be avoided. Volume assemblies (TGeoVolumeAssembly). Assemblies a volumes that have neither a shape or a material/medium. Assemblies; behave exactly like normal volumes grouping several daughters together, but; the daughters can never extrude the assembly since this has no shape. However,; a bounding box and a voxelization structure are built for assemblies as for; normal volumes, so that navigation is still optimized. Assemblies are useful; for grouping hierarchically volumes which are otherwise defined in a flat; manner, but also to avoid clashes between container shapes.; To define an assembly one should just input a name, then start adding other; volumes (or volume assemblies) as content. Function Members (Methods); public:. TGeoVolumeAssembly(); TGeoVolumeAssembly(const char* name); TGeoVolumeAssembly(const TGeoVolumeAssembly&); virtual~TGeoVolumeAssembly(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddNode(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat = 0, Option_t* option = """"); voidTGeoVolume::AddNodeOffset(TGeoVolume* vol, Int_t copy_no, Double_t offset = 0, Option_t* option = """"); virtual voidAddNodeOverlap(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat, Option_t* option); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGeoVolume::Browse(TBrowser* b); Double_tTGeoVolume::C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolumeAssembly.html:17142,optimiz,optimized,17142,root/html534/TGeoVolumeAssembly.html,https://root.cern,https://root.cern/root/html534/TGeoVolumeAssembly.html,1,['optimiz'],['optimized']
Performance,"visions according to shape types can be found inside; shape classes. TGeoVolume::Divide(N, Xmin, Xmax, ""X"");. The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping; volume is in fact a virtual container that does not represent a physical object.; It contains a list of nodes that are not his daughters but that must be checked; always before the container itself. This list must be defined by users and it; is checked and resolved in a priority order. Note that the feature is non-standard; to geometrical modelers and it was introduced just to support conversions of; GEANT3 geometries, therefore its extensive usage should be avoided. Volume assemblies (TGeoVolumeAssembly). Assemblies a volumes that have neither a shape or a material/medium. Assemblies; behave exactly like normal volumes grouping several daughters together, but; the daughters can never extrude the assembly since this has no shape. However,; a bounding box and a voxelization structure are built for assemblies as for; normal volumes, so that navigation is still optimized. Assemblies are useful; for grouping hierarchically volumes which are otherwise defined in a flat; manner, but also to avoid clashes between container shapes.; To define an assembly one should just input a name, then start adding other; volumes (or volume assemblies) as content. Function Members (Methods); public:. TGeoVolumeMulti(); TGeoVolumeMulti(const char* name, TGeoMedium* med = 0); virtual~TGeoVolumeMulti(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddNode(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat, Option_t* option = """"); voidTGeoVolume::AddNodeOffset(TGeoVolume* vol, Int_t copy_no, Double_t offset = 0, Option_t* option = """"); virtual voidAddNodeOverlap(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat, Option_t* option = """"); voidAddVolume(TGeoVolume* vol); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGeoVolume::Browse(TBrowser* b); Double_tTGeoVolume::Cap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolumeMulti.html:17133,optimiz,optimized,17133,root/html534/TGeoVolumeMulti.html,https://root.cern,https://root.cern/root/html534/TGeoVolumeMulti.html,1,['optimiz'],['optimized']
Performance,"visions according to shape types can be found inside; shape classes. TGeoVolume::Divide(N, Xmin, Xmax, ""X"");. The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping; volume is in fact a virtual container that does not represent a physical object.; It contains a list of nodes that are not its daughters but that must be checked; always before the container itself. This list must be defined by users and it; is checked and resolved in a priority order. Note that the feature is non-standard; to geometrical modelers and it was introduced just to support conversions of; GEANT3 geometries, therefore its extensive usage should be avoided. Volume assemblies (TGeoVolumeAssembly). Assemblies a volumes that have neither a shape or a material/medium. Assemblies; behave exactly like normal volumes grouping several daughters together, but; the daughters can never extrude the assembly since this has no shape. However,; a bounding box and a voxelization structure are built for assemblies as for; normal volumes, so that navigation is still optimized. Assemblies are useful; for grouping hierarchically volumes which are otherwise defined in a flat; manner, but also to avoid clashes between container shapes.; To define an assembly one should just input a name, then start adding other; volumes (or volume assemblies) as content. Function Members (Methods); public:. virtual~TGeoVolume(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddNode(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat = 0, Option_t* option = """"); voidAddNodeOffset(TGeoVolume* vol, Int_t copy_no, Double_t offset = 0, Option_t* option = """"); virtual voidAddNodeOverlap(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat = 0, Option_t* option = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); Double_tCapacity() const; virtual voidcd(Int_t inode) const; voidCheckGeometry(Int_t nrays = 1, Double_t startx = 0, Double_t starty = 0, Double_t star",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoVolume.html:17179,optimiz,optimized,17179,root/html602/TGeoVolume.html,https://root.cern,https://root.cern/root/html602/TGeoVolume.html,2,['optimiz'],['optimized']
Performance,"visions according to shape types can be found inside; shape classes. TGeoVolume::Divide(N, Xmin, Xmax, ""X"");. The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping; volume is in fact a virtual container that does not represent a physical object.; It contains a list of nodes that are not its daughters but that must be checked; always before the container itself. This list must be defined by users and it; is checked and resolved in a priority order. Note that the feature is non-standard; to geometrical modelers and it was introduced just to support conversions of; GEANT3 geometries, therefore its extensive usage should be avoided. Volume assemblies (TGeoVolumeAssembly). Assemblies a volumes that have neither a shape or a material/medium. Assemblies; behave exactly like normal volumes grouping several daughters together, but; the daughters can never extrude the assembly since this has no shape. However,; a bounding box and a voxelization structure are built for assemblies as for; normal volumes, so that navigation is still optimized. Assemblies are useful; for grouping hierarchically volumes which are otherwise defined in a flat; manner, but also to avoid clashes between container shapes.; To define an assembly one should just input a name, then start adding other; volumes (or volume assemblies) as content. Function Members (Methods); public:. virtual~TGeoVolumeAssembly(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddNode(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat = 0, Option_t* option = """"); voidTGeoVolume::AddNodeOffset(TGeoVolume* vol, Int_t copy_no, Double_t offset = 0, Option_t* option = """"); virtual voidAddNodeOverlap(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat, Option_t* option); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGeoVolume::Browse(TBrowser* b); Double_tTGeoVolume::Capacity() const; virtual voidTGeoVolume::cd(Int_t inode) const; voidTGeoVolume::CheckGeometry(Int_t nrays =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoVolumeAssembly.html:17142,optimiz,optimized,17142,root/html602/TGeoVolumeAssembly.html,https://root.cern,https://root.cern/root/html602/TGeoVolumeAssembly.html,2,['optimiz'],['optimized']
Performance,"visions according to shape types can be found inside; shape classes. TGeoVolume::Divide(N, Xmin, Xmax, ""X"");. The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping; volume is in fact a virtual container that does not represent a physical object.; It contains a list of nodes that are not its daughters but that must be checked; always before the container itself. This list must be defined by users and it; is checked and resolved in a priority order. Note that the feature is non-standard; to geometrical modelers and it was introduced just to support conversions of; GEANT3 geometries, therefore its extensive usage should be avoided. Volume assemblies (TGeoVolumeAssembly). Assemblies a volumes that have neither a shape or a material/medium. Assemblies; behave exactly like normal volumes grouping several daughters together, but; the daughters can never extrude the assembly since this has no shape. However,; a bounding box and a voxelization structure are built for assemblies as for; normal volumes, so that navigation is still optimized. Assemblies are useful; for grouping hierarchically volumes which are otherwise defined in a flat; manner, but also to avoid clashes between container shapes.; To define an assembly one should just input a name, then start adding other; volumes (or volume assemblies) as content. Function Members (Methods); public:. virtual~TGeoVolumeMulti(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddNode(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat, Option_t* option = """"); voidTGeoVolume::AddNodeOffset(TGeoVolume* vol, Int_t copy_no, Double_t offset = 0, Option_t* option = """"); virtual voidAddNodeOverlap(TGeoVolume* vol, Int_t copy_no, TGeoMatrix* mat, Option_t* option = """"); voidAddVolume(TGeoVolume* vol); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGeoVolume::Browse(TBrowser* b); Double_tTGeoVolume::Capacity() const; virtual voidTGeoVolume::cd(Int_t inode) const; voidTGeoVolum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoVolumeMulti.html:17133,optimiz,optimized,17133,root/html602/TGeoVolumeMulti.html,https://root.cern,https://root.cern/root/html602/TGeoVolumeMulti.html,2,['optimiz'],['optimized']
Performance,"vm::StringRef ; lib). static . Definition at line 7252 of file TCling.cxx. ◆ hasPrecomputedLibraryDeps(). static bool hasPrecomputedLibraryDeps ; (; llvm::StringRef ; lib). static . Definition at line 7273 of file TCling.cxx. ◆ IsFromRootCling(). static bool IsFromRootCling ; (; ). static . Definition at line 1058 of file TCling.cxx. ◆ IsTupleAscending(). static ETupleOrdering IsTupleAscending ; (; ). static . Definition at line 3923 of file TCling.cxx. ◆ loadGlobalModuleIndex(). static GlobalModuleIndex * loadGlobalModuleIndex ; (; cling::Interpreter & ; interp). static . Definition at line 1080 of file TCling.cxx. ◆ LoadModule(). static bool LoadModule ; (; const std::string & ; ModuleName, . cling::Interpreter & ; interp . ). static . Returnstrue if the module was loaded. ; Definition at line 1030 of file TCling.cxx. ◆ LoadModules(). static void LoadModules ; (; const std::vector< std::string > & ; modules, . cling::Interpreter & ; interp . ). static . Loads the C++ modules that we require to run any ROOT program. ; This is just supposed to make a C++ module from a modulemap available to the interpreter. ; Definition at line 1052 of file TCling.cxx. ◆ PrintDlError(). static void PrintDlError ; (; const char * ; dyLibName, . const char * ; modulename . ). static . Definition at line 1964 of file TCling.cxx. ◆ R__InitStreamerInfoFactory(). static bool R__InitStreamerInfoFactory ; (; ). static . Helper to initialize TVirtualStreamerInfo's factor early. ; Use static initialization to insure only one TStreamerInfo is created. ; Definition at line 1664 of file TCling.cxx. ◆ RegisterCxxModules(). static void RegisterCxxModules ; (; cling::Interpreter & ; clingInterp). static . Definition at line 1183 of file TCling.cxx. ◆ RegisterPreIncludedHeaders(). static void RegisterPreIncludedHeaders ; (; cling::Interpreter & ; clingInterp). static . Definition at line 1299 of file TCling.cxx. ◆ requiresRootMap(). static bool requiresRootMap ; (; const char * ; rootmapfile). static",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx.html:15245,Load,Loads,15245,doc/master/TCling_8cxx.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx.html,1,['Load'],['Loads']
Performance,"void ResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); Reset dialog box preparing for new query. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. Float_t AdjustBytes(Float_t mbs, TString& sf); Transform MBs to GBs ot TBs and get the correct suffix. ~TProofProgressDialog(); Cleanup dialog. void CloseWindow(); Called when dialog is closed. void DisableAsyn(); Disable the asyn switch when an external request for going asynchronous is issued. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void DoClose(); Close dialog. void DoLog(); Ask proof session for logs. void DoKeep(Bool_t on); Handle keep toggle button. void DoSetLogQuery(Bool_t on); Handle log-current-query-only toggle button. void DoStop(); Handle Stop button. void DoAbort(); Handle Cancel button. void DoAsyn(); Handle Asyn button. void DoPlotRateGraph(); Handle Plot Rate Graph. void DoMemoryPlot(); Do a memory plot. void DoEnableSpeedo(); Enable/Disable speedometer. TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries). void Progress(Long64_t total, Long64_t processed). » Author: Fons Rademakers 21/03/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TProofProgressDialog.h 36073 2010-10-05 08:14:21Z ganis $ » Last generated: 2010-10-08 16:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofProgressDialog.html:4470,Load,Load,4470,root/html528/TProofProgressDialog.html,https://root.cern,https://root.cern/root/html528/TProofProgressDialog.html,1,['Load'],['Load']
Performance,"void ResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); Reset dialog box preparing for new query. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. Float_t AdjustBytes(Float_t mbs, TString& sf); Transform MBs to GBs ot TBs and get the correct suffix. ~TProofProgressDialog(); Cleanup dialog. void CloseWindow(); Called when dialog is closed. void DisableAsyn(); Disable the asyn switch when an external request for going asynchronous is issued. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void DoClose(); Close dialog. void DoLog(); Ask proof session for logs. void DoKeep(Bool_t on); Handle keep toggle button. void DoSetLogQuery(Bool_t on); Handle log-current-query-only toggle button. void DoStop(); Handle Stop button. void DoAbort(); Handle Cancel button. void DoAsyn(); Handle Asyn button. void DoPlotRateGraph(); Handle Plot Rate Graph. void DoMemoryPlot(); Do a memory plot. void DoEnableSpeedo(); Enable/Disable speedometer. TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries). void Progress(Long64_t total, Long64_t processed). » Author: Fons Rademakers 21/03/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TProofProgressDialog.h 36073 2010-10-05 08:14:21Z ganis $ » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofProgressDialog.html:4470,Load,Load,4470,root/html530/TProofProgressDialog.html,https://root.cern,https://root.cern/root/html530/TProofProgressDialog.html,1,['Load'],['Load']
Performance,"void ResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); Reset dialog box preparing for new query. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. Float_t AdjustBytes(Float_t mbs, TString& sf); Transform MBs to GBs ot TBs and get the correct suffix. ~TProofProgressDialog(); Cleanup dialog. void CloseWindow(); Called when dialog is closed. void DisableAsyn(); Disable the asyn switch when an external request for going asynchronous is issued. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void DoClose(); Close dialog. void DoLog(); Ask proof session for logs. void DoKeep(Bool_t on); Handle keep toggle button. void DoSetLogQuery(Bool_t on); Handle log-current-query-only toggle button. void DoStop(); Handle Stop button. void DoAbort(); Handle Cancel button. void DoAsyn(); Handle Asyn button. void DoPlotRateGraph(); Handle Plot Rate Graph. void DoMemoryPlot(); Do a memory plot. void DoEnableSpeedo(); Enable/Disable speedometer. TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries). void Progress(Long64_t total, Long64_t processed). » Author: Fons Rademakers 21/03/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TProofProgressDialog.h 36073 2010-10-05 08:14:21Z ganis $ » Last generated: 2011-11-03 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofProgressDialog.html:4470,Load,Load,4470,root/html532/TProofProgressDialog.html,https://root.cern,https://root.cern/root/html532/TProofProgressDialog.html,1,['Load'],['Load']
Performance,"void RooAbsData::add ; (; const RooArgSet & ; row, . double ; weight = 1 . ). pure virtual . Implemented in RooDataSet, and RooDataHist. ◆ addOwnedComponent(). void RooAbsData::addOwnedComponent ; (; const char * ; idxlabel, . RooAbsData & ; data . ). Definition at line 2366 of file RooAbsData.cxx. ◆ allClientsCached(). bool RooAbsData::allClientsCached ; (; RooAbsArg * ; var, . const RooArgSet & ; cacheList . ). protected . Utility function that determines if all clients of object 'var' appear in given list of cached nodes. ; Definition at line 2319 of file RooAbsData.cxx. ◆ attachBuffers(). void RooAbsData::attachBuffers ; (; const RooArgSet & ; extObs). Definition at line 2337 of file RooAbsData.cxx. ◆ attachCache(). void RooAbsData::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). protectedvirtual . Internal method – Attach dataset copied with cache contents to copied instances of functions. ; Definition at line 363 of file RooAbsData.cxx. ◆ cacheArgs(). void RooAbsData::cacheArgs ; (; const RooAbsArg * ; owner, . RooArgSet & ; varSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = false . ). protectedvirtual . Internal method – Cache given set of functions with data. ; Definition at line 346 of file RooAbsData.cxx. ◆ canSplitFast(). bool RooAbsData::canSplitFast ; (; ); const. Definition at line 2351 of file RooAbsData.cxx. ◆ changeObservableName(). bool RooAbsData::changeObservableName ; (; const char * ; from, . const char * ; to . ). virtual . Definition at line 303 of file RooAbsData.cxx. ◆ checkInit(). void RooAbsData::checkInit ; (; ); const. Definition at line 2392 of file RooAbsData.cxx. ◆ Class(). static TClass * RooAbsData::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsData::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsData::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVers",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:34674,cache,cacheArgs,34674,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['cache'],['cacheArgs']
Performance,"void SetInputTreesFromEventAssignTrees(); TMVA::Factory::~Factoryvirtual ~Factory()Destructor.Definition Factory.cxx:306; TMVA::Factory::MakeClassvirtual void MakeClass(const TString &datasetname, const TString &methodTitle="""") constDefinition Factory.cxx:1305; TMVA::Factory::BookMethodWeightfileMethodBase * BookMethodWeightfile(DataLoader *dataloader, TMVA::Types::EMVA methodType, const TString &weightfile)Adds an already constructed method to be managed by this factory.Definition Factory.cxx:501; TMVA::Factory::fModelPersistenceBool_t fModelPersistence! option to save the trained model in xml file or using serializationDefinition Factory.h:222; TMVA::Factory::OptimizeAllMethodsstd::map< TString, Double_t > OptimizeAllMethods(TString fomType=""ROCIntegral"", TString fitType=""FitGA"")Iterates through all booked methods and sees if they use parameter tuning and if so does just that,...Definition Factory.cxx:701; TMVA::Factory::OptimizeAllMethodsForClassificationvoid OptimizeAllMethodsForClassification(TString fomType=""ROCIntegral"", TString fitType=""FitGA"")Definition Factory.h:110; TMVA::Factory::GetROCROCCurve * GetROC(DataLoader *loader, TString theMethodName, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)Private method to generate a ROCCurve instance for a given method.Definition Factory.cxx:749; TMVA::Factory::IsSilentFileBool_t IsSilentFile() constDefinition Factory.h:151; TMVA::Factory::EvaluateImportanceShortTH1F * EvaluateImportanceShort(DataLoader *loader, Types::EMVA theMethod, TString methodTitle, const char *theOption="""")Definition Factory.cxx:2358; TMVA::Factory::fAnalysisTypeTypes::EAnalysisType fAnalysisType! the training typeDefinition Factory.h:221; TMVA::Factory::fJobNameTString fJobName! jobname, used as extension in weight file namesDefinition Factory.h:219; TMVA::Factory::HasMethodBool_t HasMethod(const TString &datasetname, const TString &title) constChecks whether a given method name is defined for a given dataset.Definition Factory.cxx:58",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html:16805,Optimiz,OptimizeAllMethodsForClassificationvoid,16805,doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,2,['Optimiz'],"['OptimizeAllMethodsForClassification', 'OptimizeAllMethodsForClassificationvoid']"
Performance,"void TGLAxis::SetLabelsOffset ; (; Double_t ; offset). inline . Definition at line 66 of file TGLAxis.h. ◆ SetLabelsSize(). void TGLAxis::SetLabelsSize ; (; Double_t ; size). inline . Definition at line 67 of file TGLAxis.h. ◆ SetTickMarksLength(). void TGLAxis::SetTickMarksLength ; (; Double_t ; length). inline . Definition at line 64 of file TGLAxis.h. ◆ SetTickMarksOrientation(). void TGLAxis::SetTickMarksOrientation ; (; Int_t ; tmo). inline . Definition at line 65 of file TGLAxis.h. ◆ Streamer(). void TGLAxis::Streamer ; (; TBuffer & ; ). overridevirtual . Reimplemented from TAttLine. ◆ StreamerNVirtual(). void TGLAxis::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 71 of file TGLAxis.h. ◆ TicksPositions(). void TGLAxis::TicksPositions ; (; Option_t * ; opt = """"). Compute ticks positions. ; Definition at line 298 of file TGLAxis.cxx. ◆ TicksPositionsNoOpt(). void TGLAxis::TicksPositionsNoOpt ; (; ). Compute ticks positions. Linear and not optimized. ; Definition at line 331 of file TGLAxis.cxx. ◆ TicksPositionsOpt(). void TGLAxis::TicksPositionsOpt ; (; ). Compute ticks positions. Linear and optimized. ; Definition at line 363 of file TGLAxis.cxx. Member Data Documentation. ◆ fAngle1. Double_t TGLAxis::fAngle1. private . Definition at line 45 of file TGLAxis.h. ◆ fAngle2. Double_t TGLAxis::fAngle2. private . Definition at line 46 of file TGLAxis.h. ◆ fAngle3. Double_t TGLAxis::fAngle3. private . Definition at line 47 of file TGLAxis.h. ◆ fAxisLength. Double_t TGLAxis::fAxisLength. private . Definition at line 36 of file TGLAxis.h. ◆ fGridLength. Double_t TGLAxis::fGridLength. private . Definition at line 43 of file TGLAxis.h. ◆ fLabels. TString* TGLAxis::fLabels. private . Definition at line 35 of file TGLAxis.h. ◆ fLabelsOffset. Double_t TGLAxis::fLabelsOffset. private . Definition at line 41 of file TGLAxis.h. ◆ fLabelsSize. Double_t TGLAxis::fLabelsSize. private . Definition at line 42 of file TGLAxis.h. ◆ fNDiv. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLAxis.html:10707,optimiz,optimized,10707,doc/master/classTGLAxis.html,https://root.cern,https://root.cern/doc/master/classTGLAxis.html,1,['optimiz'],['optimized']
Performance,"void TLinearFitter::ComputeTValues ; (; ). private . Computes parameters' t-values and significance. ; Definition at line 862 of file TLinearFitter.cxx. ◆ CreateSubset(). void TLinearFitter::CreateSubset ; (; Int_t ; ntotal, . Int_t ; h, . Int_t * ; index . ). private . Creates a p-subset to start ntotal - total number of points from which the subset is chosen. ; Definition at line 2291 of file TLinearFitter.cxx. ◆ CStep(). Double_t TLinearFitter::CStep ; (; Int_t ; step, . Int_t ; h, . Double_t * ; residuals, . Int_t * ; index, . Int_t * ; subdat, . Int_t ; start, . Int_t ; end . ). private . The CStep procedure, as described in the article. ; Definition at line 2354 of file TLinearFitter.cxx. ◆ DeclFileName(). static const char * TLinearFitter::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 277 of file TLinearFitter.h. ◆ Eval(). Int_t TLinearFitter::Eval ; (; ). virtual . Perform the fit and evaluate the parameters Returns 0 if the fit is ok, 1 if there are errors. ; Definition at line 874 of file TLinearFitter.cxx. ◆ EvalRobust(). Int_t TLinearFitter::EvalRobust ; (; Double_t ; h = -1). virtual . Finds the parameters of the fitted function in case data contains outliers. ; Parameter h stands for the minimal fraction of good points in the dataset (h < 1, i.e. for 70% of good points take h=0.7). The default value of h*Npoints is (Npoints + Nparameters+1)/2 If the user provides a value of h smaller than above, default is taken See class description for the algorithm details ; Definition at line 2095 of file TLinearFitter.cxx. ◆ ExecuteCommand(). Int_t TLinearFitter::ExecuteCommand ; (; const char * ; command, . Double_t * ; args, . Int_t ; nargs . ). overridevirtual . To use in TGraph::Fit and TH1::Fit(). ; Implements TVirtualFitter.; Definition at line 1724 of file TLinearFitter.cxx. ◆ FixParameter() [1/2]. void TLinearFitter::FixParameter ; (; Int_t ; ipar). overridevirtual . Fixes paramter #ipar at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLinearFitter.html:37444,Perform,Perform,37444,doc/master/classTLinearFitter.html,https://root.cern,https://root.cern/doc/master/classTLinearFitter.html,1,['Perform'],['Perform']
Performance,"void TrainOneEvent(Int_t ievt); train network over a single event; this uses the new event model. Double_t GetDesiredOutput(const TMVA::Event* ev); get the desired output of this event. void UpdateNetwork(Double_t desired, Double_t eventWeight = 1.0); update the network based on how closely; the output matched the desired output. void UpdateNetwork(vector<Float_t>& desired, Double_t eventWeight = 1.0); update the network based on how closely; the output matched the desired output. void CalculateNeuronDeltas(); have each neuron calculate its delta by backpropagation. void GeneticMinimize(); create genetics class similar to GeneticCut; give it vector of parameter ranges (parameters = weights); link fitness function of this class to ComputeEstimator; instantiate GA (see MethodCuts); run it; then this should exist for GA, Minuit and random sampling. Double_t EstimatorFunction(vector<Double_t>& parameters); interface to the estimate. Double_t ComputeEstimator(vector<Double_t>& parameters); this function is called by GeneticANN for GA optimization. void UpdateSynapses(); update synapse error fields and adjust the weights (if in sequential mode). void AdjustSynapseWeights(); just adjust the synapse weights (should be called in batch mode). void UpdatePriors(). void UpdateRegulators(). void GetApproxInvHessian(TMatrixD& InvHessian, bool regulate = true). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". void Train(); { Train(NumCycles()); }. bool HasInverseHessian(); { return fCalculateErrors; }. » Author: Krzysztof Danielowski, Andreas Hoecker, Matt Jachowski, Kamil Kraszewski, Maciej Kruk, Peter Speckmayer, Joerg Stelzer, Eckhard von Toerne, Jan Therhaag, Jiahang Zhong » Copyright (c) 2005-2011: *; » Last changed: roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodMLP.html:26329,optimiz,optimization,26329,root/html530/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodMLP.html,2,['optimiz'],['optimization']
Performance,"void TrainOneEvent(Int_t ievt); train network over a single event; this uses the new event model. Double_t GetDesiredOutput(const TMVA::Event* ev); get the desired output of this event. void UpdateNetwork(Double_t desired, Double_t eventWeight = 1.0); update the network based on how closely; the output matched the desired output. void UpdateNetwork(vector<Float_t>& desired, Double_t eventWeight = 1.0); update the network based on how closely; the output matched the desired output. void CalculateNeuronDeltas(); have each neuron calculate its delta by backpropagation. void GeneticMinimize(); create genetics class similar to GeneticCut; give it vector of parameter ranges (parameters = weights); link fitness function of this class to ComputeEstimator; instantiate GA (see MethodCuts); run it; then this should exist for GA, Minuit and random sampling. Double_t EstimatorFunction(vector<Double_t>& parameters); interface to the estimate. Double_t ComputeEstimator(vector<Double_t>& parameters); this function is called by GeneticANN for GA optimization. void UpdateSynapses(); update synapse error fields and adjust the weights (if in sequential mode). void AdjustSynapseWeights(); just adjust the synapse weights (should be called in batch mode). void UpdatePriors(). void UpdateRegulators(). void GetApproxInvHessian(TMatrixD& InvHessian, bool regulate = true). Double_t GetMvaValueAsymError(Double_t* errUpper, Double_t* errLower). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". void Train(); { Train(NumCycles()); }. bool HasInverseHessian(); { return fCalculateErrors; }. » Author: Andreas Hoecker, Peter Speckmayer, Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodMLP.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-11-26 14:27; This page has been autom",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodMLP.html:25632,optimiz,optimization,25632,root/html528/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodMLP.html,1,['optimiz'],['optimization']
Performance,"void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const. RooAbsDataStore* store(); { return _dstore ; }. const RooAbsDataStore* store() const; { return _dstore ; }. void add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); Add one ore more rows of data. const RooArgSet* get() const; Load a given row of data. Double_t weight() const. Bool_t valid() const; { return kTRUE ; }. Double_t sumEntries(const char* cutSpec = 0, const char* cutRange = 0) const. Bool_t isWeighted() const; Do events in dataset have weights?. Bool_t isNonPoissonWeighted() const; Do events in dataset have non-integer weights?. void Print(Option_t* options = 0) const; Printing interface (human readable). Double_t mean(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return moment(var,1,0,cutSpec,cutRange) ; }. Double_t sigma(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return sqrt(moment(var,2,cutSpec,cutRange)) ; }. Double_t skewness(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,3,cutSpec,cutRange) ; }. Double_t kurtosis(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,4,cutSpec,cutRange) ; }. Double_t covariance(RooRealVar& x, Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsData.html:35439,Load,Load,35439,root/html528/RooAbsData.html,https://root.cern,https://root.cern/root/html528/RooAbsData.html,1,['Load'],['Load']
Performance,"void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedPdf.html:48968,cache,cache,48968,root/html602/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html,2,['cache'],['cache']
Performance,"void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsCategory::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBinningCategory.html:15356,cache,cache,15356,root/html528/RooBinningCategory.html,https://root.cern,https://root.cern/root/html528/RooBinningCategory.html,2,['cache'],['cache']
Performance,"void*TDirectory::GetObjectChecked(const char* namecycle, const char* classname); virtual void*TDirectory::GetObjectChecked(const char* namecycle, const TClass* cl); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual void*TDirectory::GetObjectUnchecked(const char* namecycle); virtual Option_t*TObject::GetOption() const; virtual const char*TDirectory::GetPath() const; virtual const char*TDirectory::GetPathStatic() const; TPluginManager*GetPluginManager() const; TFolder*GetRootFolder() const; virtual Long64_tTDirectory::GetSeekDir() const; virtual Long64_tTDirectory::GetSeekKeys() const; virtual Long64_tTDirectory::GetSeekParent() const; TVirtualPad*GetSelectedPad() const; const TObject*GetSelectedPrimitive() const; TStyle*GetStyle(const char* name) const; const char*GetSvnBranch() const; const char*GetSvnDate(); Int_tGetSvnRevision() const; virtual const char*TNamed::GetTitle() const; TDataType*GetType(const char* name, Bool_t load = kFALSE) const; virtual UInt_tTObject::GetUniqueID() const; TUUIDTDirectory::GetUUID() const; TProcessUUID*GetUUIDs() const; const char*GetVersion() const; Int_tGetVersionCode() const; Int_tGetVersionDate() const; Int_tGetVersionInt() const; Int_tGetVersionTime() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; voidIdle(UInt_t idleTimeInSec, const char* command = 0); Int_tIgnoreInclude(const char* fname, const char* expandedfname); static Int_tIncreaseDirLevel(); static voidIndentLevel(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; static Bool_tInitialized(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsBatch() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; Bool_tIsEscaped() const; Bool_tIsExecutingM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:8721,load,load,8721,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,3,['load'],['load']
Performance,"void; 396 ; 397 /**; 398 Return the scalar (dot) product of two displacement vectors.; 399 It is possible to perform the product for any type of vector coordinates,; 400 but they must have the same coordinate system tag; 401 */; 402 template< class OtherCoords >; 403 Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v) const {; 404 return X()*v.X() + Y()*v.Y() + Z()*v.Z();; 405 }; 406 /**; 407 Return the scalar (dot) product of two vectors.; 408 It is possible to perform the product for any classes; 409 implementing x(), y() and z() member functions; 410 */; 411 template< class OtherVector >; 412 Scalar Dot( const OtherVector & v) const {; 413 return X()*v.x() + Y()*v.y() + Z()*v.z();; 414 }; 415 ; 416 /**; 417 Return vector (cross) product of two displacement vectors,; 418 as a vector in the coordinate system of this class.; 419 It is possible to perform the product for any type of vector coordinates,; 420 but they must have the same coordinate system tag; 421 */; 422 template <class OtherCoords>; 423 DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v) const {; 424 DisplacementVector3D result;; 425 result.SetXYZ ( Y()*v.Z() - v.Y()*Z(),; 426 Z()*v.X() - v.Z()*X(),; 427 X()*v.Y() - v.X()*Y() );; 428 return result;; 429 }; 430 /**; 431 Return vector (cross) product of two vectors,; 432 as a vector in the coordinate system of this class.; 433 It is possible to perform the product for any classes; 434 implementing X(), Y() and Z() member functions; 435 */; 436 template <class OtherVector>; 437 DisplacementVector3D Cross( const OtherVector & v) const {; 438 DisplacementVector3D result;; 439 result.SetXYZ ( Y()*v.z() - v.y()*Z(),; 440 Z()*v.x() - v.z()*X(),; 441 X()*v.y() - v.x()*Y() );; 442 return result;; 443 }; 444 ; 445 ; 446 ; 447 /**; 448 Self Addition with a displacement vector.; 449 */; 450 template <class OtherCoords>; 451 DisplacementVector3D & operator+=; 452 (const DisplacementVector3D<OtherCoords,Tag> & v) {; 453 SetXYZ( X() +",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html:13420,perform,perform,13420,doc/master/GenVector_2DisplacementVector3D_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html,1,['perform'],['perform']
Performance,"voidRooAbsArg::attachToStore(RooAbsDataStore& store); virtual voidRooAbsString::attachToTree(TTree& t, Int_t bufSize = 32000); virtual voidRooAbsString::attachToVStore(RooVectorDataStore&); TStringRooAbsArg::cleanBranchName() const; virtual voidRooAbsString::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDiry = kTRUE); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual TStringRooAbsString::evaluate() const; virtual voidRooAbsString::fillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual Bool_tRooAbsString::isValid() const; virtual Bool_tRooAbsString::isValidString(const char*, Bool_t printError = kFALSE) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsString::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsString::syncCache(const RooArgSet* nset = 0); const char*RooAbsString::traceEval() const; virtual Bool_tRooAbsString::traceEvalHook(const char* value) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStringVar.html:16298,optimiz,optimizeDirtyHook,16298,root/html532/RooStringVar.html,https://root.cern,https://root.cern/root/html532/RooStringVar.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum CatIdx { NoCatIdx; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMappedCategory.html:19492,Cache,CacheMode,19492,root/html534/RooMappedCategory.html,https://root.cern,https://root.cern/root/html534/RooMappedCategory.html,1,['Cache'],['CacheMode']
Performance,"voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); virtual voidsetVal(Double_t value); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual Double_tvolume(const char* rangeName) const; virtual Double_tvolume(const RooAbsBinning& binning) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsRealLValue.html:27754,cache,cache,27754,root/html526/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html526/RooAbsRealLValue.html,1,['cache'],['cache']
Performance,"voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ParamHistFunc.html:26828,cache,cache,26828,root/html602/ParamHistFunc.html,https://root.cern,https://root.cern/root/html602/ParamHistFunc.html,118,['cache'],['cache']
Performance,"voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); virtual Bool_tRooAbsPdf::syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Double_tRooAbsReal::traceEval(const RooArgSet* set) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy); voidupdateCoefficients(RooAddPdf::CacheElem& cache, const RooArgSet* nset) const. Data Members; public:. enum RooAbsPdf::ExtendMode { CanNotBeExtended; CanBeExtended; MustBeExtended; };; enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. Bool_t_allExtendableFlag indicating if all PDF components are extendable; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddPdf.html:39444,Cache,CacheMode,39444,root/html534/RooAddPdf.html,https://root.cern,https://root.cern/root/html534/RooAddPdf.html,1,['Cache'],['CacheMode']
Performance,"voidRooAbsReal::attachToVStore(RooVectorDataStore& vstore); virtual const char*RooAbsCachedPdf::binningName() const; TStringRooAbsCachedPdf::cacheNameSuffix(const RooArgSet& nset) const; RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidRooAbsCachedPdf::clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); virtual RooAbsCachedPdf::PdfCacheElem*RooAbsCachedPdf::createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; voidRooAbsCachedPdf::disableCache(Bool_t flag); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tRooAbsReal::evaluate() const; virtual voidfillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; static Bool_tRooAbsArg::flipAClean(); virtual RooAbsGenContext*RooAbsPdf::genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE) const; RooAbsCachedPdf::PdfCacheElem*RooAbsCachedPdf::getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsSelfCachedPdf.html:32750,cache,cache,32750,root/html532/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsSelfCachedPdf.html,1,['cache'],['cache']
Performance,"voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooAbsReal::traceEvalHook(Double_t) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum State { Initialize; Client; Server; Inline; };; enum Message { SendReal; SendCat; Calculate; Retrieve; ReturnValue; Terminate; ConstOpt; Verbose; LogEvalError; ApplyNLLW2; EnableOffset; CalculateNoOffset; };; enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. RooRealProxy_argFunction to calculate in parallel process; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealMPFE.html:32477,Cache,CacheMode,32477,root/html534/RooRealMPFE.html,https://root.cern,https://root.cern/root/html534/RooRealMPFE.html,1,['Cache'],['CacheMode']
Performance,"voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; TGLPolyMarker&operator=(const TGLPolyMarker&); TGLPolyMarker&operator=(TGLPolyMarker&&); virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TGLPolyMarker(const TBuffer3D& buffer); TGLPolyMarker(const TGLPolyMarker&); TGLPolyMarker(TGLPolyMarker&&); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLPolyMarker.html:1913,cache,cached,1913,root/html602/TGLPolyMarker.html,https://root.cern,https://root.cern/root/html602/TGLPolyMarker.html,2,['cache'],['cached']
Performance,"voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidTGLObject::SetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tTGLObject::SetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLPlot3D.html:2234,cache,cached,2234,root/html534/TGLPlot3D.html,https://root.cern,https://root.cern/root/html534/TGLPlot3D.html,1,['cache'],['cached']
Performance,"voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* classname, Bool_t load); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load); virtual TClass*GetClass(const char* classname, Bool_t load, Bool_t silent); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClassGenerator.html:2081,load,load,2081,root/html526/TClassGenerator.html,https://root.cern,https://root.cern/root/html526/TClassGenerator.html,7,['load'],['load']
Performance,"voidTObject::MakeZombie(); Int_tnumProxies() const; virtual voidoperModeHook(); virtual voidoptimizeDirtyHook(const RooArgSet*); voidprintAttribList(ostream& os) const; voidregisterProxy(RooArgProxy& proxy); voidregisterProxy(RooSetProxy& proxy); voidregisterProxy(RooListProxy& proxy); voidsetProxyNormSet(const RooArgSet* nset); voidsetShapeDirty(const RooAbsArg* source) const; virtual voidsetTreeBranchStatus(TTree& t, Bool_t active); voidsetValueDirty(const RooAbsArg* source) const; virtual voidsyncCache(const RooArgSet* nset = 0); voidunRegisterProxy(RooArgProxy& proxy); voidunRegisterProxy(RooSetProxy& proxy); voidunRegisterProxy(RooListProxy& proxy). Data Members; public:. enum ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum CacheMode { Always; NotAdvised; Never; };; enum OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>_ioReadStackreading stack ; static const UInt_tfnv1a32start; static const ULong64_tfnv1a64start. protected:. set<std::string>_boolAttribBoolean attributes; set<std::string>_boolAttribTransient! Transient boolean attributes (not copied in ctor); deque<RooAbsCache*>_cacheListlist of caches; RooRefCountList_clientListlist of client objects; RooRefCountList_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountList_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*_clien",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsArg.html:16417,Cache,CacheMode,16417,root/html534/RooAbsArg.html,https://root.cern,https://root.cern/root/html534/RooAbsArg.html,1,['Cache'],['CacheMode']
Performance,"voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidselectDefaultAlgorithm(); voidselectFastAlgorithm(); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniq",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooVoigtian.html:27098,cache,cache,27098,root/html526/RooVoigtian.html,https://root.cern,https://root.cern/root/html526/RooVoigtian.html,1,['cache'],['cache']
Performance,"voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsCachedReal::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsCachedReal::setInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsSelfCachedReal.html:23436,cache,cache,23436,root/html532/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html532/RooAbsSelfCachedReal.html,3,['cache'],['cache']
Performance,"voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); Double_tTestTreeQuality(TMVA::DecisionTree* dt); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodDT.html:14527,tune,tuneParameters,14527,root/html530/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodDT.html,2,['tune'],['tuneParameters']
Performance,"voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); static TMVA::MethodCFMlpANN*This(); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodCFMlpANN.html:12896,tune,tuneParameters,12896,root/html530/TMVA__MethodCFMlpANN.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodCFMlpANN.html,2,['tune'],['tuneParameters']
Performance,"voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); static TMVA::MethodPDERS*ThisPDERS(); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodPDERS.html:12913,tune,tuneParameters,12913,root/html530/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodPDERS.html,2,['tune'],['tuneParameters']
Performance,"voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); Bool_tUseBoost() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodRuleFit.html:12226,tune,tuneParameters,12226,root/html530/TMVA__MethodRuleFit.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodRuleFit.html,2,['tune'],['tuneParameters']
Performance,"voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodBayesClassifier.html:11484,tune,tuneParameters,11484,root/html530/TMVA__MethodBayesClassifier.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodBayesClassifier.html,22,['tune'],['tuneParameters']
Performance,"voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; UInt_tTargetSelectionToUInt(TMVA::ETargetSelection ts) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); voidTrainMonoTargetRegression(); voidTrainMultiClassification(); voidTrainMultiTargetRegression(); voidTrainSeparatedClassification(); voidTrainUnifiedClassification(); TMVA::MethodPDEFoam::EKern",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodPDEFoam.html:12314,tune,tuneParameters,12314,root/html530/TMVA__MethodPDEFoam.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodPDEFoam.html,2,['tune'],['tuneParameters']
Performance,"voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooExpensiveObjectCache&operator=(const RooExpensiveObjectCache&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); voidprint() const; virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tregisterObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Bool_tregisterObject(const char* ownerName, const char* objectName, TObject& cacheObject, const RooArgSet& params); voidTObject::ResetBit(UInt_t f); const TObject*retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); RooExpensiveObjectCache(); RooExpensiveObjectCache(const RooExpensiveObjectCache&); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); Bool_tsetObj(Int_t uniqueID, TObject* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; Int_tsize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExpensiveObjectCache.html:4279,cache,cacheObject,4279,root/html602/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html602/RooExpensiveObjectCache.html,2,['cache'],['cacheObject']
Performance,"void AddPreLinks (TNeuron *neuron, TObjArray *prevLayer);  add synapses connecting a neuron to its preceding layer ;  ; void BuildLayer (Int_t numNeurons, TObjArray *curLayer, TObjArray *prevLayer, Int_t layerIndex, Int_t numLayers, Bool_t from_file=false);  build a single layer with neurons and synapses connecting this layer to the previous layer ;  ; void BuildLayers (std::vector< Int_t > *layout, Bool_t from_file=false);  build the network layers ;  ; void DeleteNetwork ();  delete/clear network ;  ; void DeleteNetworkLayer (TObjArray *&layer);  delete a network layer ;  ; void ForceWeights (std::vector< Double_t > *weights);  force the synapse weights ;  ; void InitWeights ();  initialize the synapse weights randomly ;  ; void PrintLayer (TObjArray *layer) const;  print a single layer, for debugging ;  ; void PrintNeuron (TNeuron *neuron) const;  print a neuron, for debugging ;  . Private Attributes; TObjArray * fInputLayer;  cache this for fast access ;  ; TString fLayerSpec;  layout specification option ;  ; std::vector< TNeuron * > fOutputNeurons;  cache this for fast access ;  . Static Private Attributes; static const Bool_t fgDEBUG = kTRUE;  debug flag ;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TMVA/MethodANNBase.h>. Inheritance diagram for TMVA::MethodANNBase:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EEstimator. enum TMVA::MethodANNBase::EEstimator. EnumeratorkMSE ; kCE . Definition at line 137 of file MethodANNBase.h. Constructor & Destructor Documentation. ◆ MethodANNBase() [1/2]. TMVA::MethodANNBase::MethodANNBase ; (; const TString & ; jobName, . Types::EMVA ; methodType, . const TString & ; methodTitle, . DataSetInfo & ; theData, . const TString & ; theOption . ). standard constructor Note: Right now it is an option to choose the neuron input function, but only the input f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodANNBase.html:31572,cache,cache,31572,doc/master/classTMVA_1_1MethodANNBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodANNBase.html,2,['cache'],['cache']
Performance,"void ClassEnd (const TClass *)=0;  ; virtual void ClassMember (const char *, const char *=nullptr, Int_t=-1, Int_t=-1)=0;  ; virtual void DecrementLevel (TVirtualStreamerInfo *)=0;  ; void DetachBuffer ();  ; void Expand (Int_t newsize, Bool_t copy=kTRUE);  Expand (or shrink) the I/O buffer to newsize bytes. ;  ; Int_t GetBufferVersion () const;  ; char * GetCurrent () const;  ; virtual TVirtualStreamerInfo * GetInfo ()=0;  ; TObject * GetParent () const;  Return pointer to parent of this buffer. ;  ; ReAllocCharFun_t GetReAllocFunc () const;  Return the reallocation method currently used. ;  ; virtual void IncrementLevel (TVirtualStreamerInfo *info)=0;  ; Bool_t IsReading () const;  ; Bool_t IsWriting () const;  ; Int_t Length () const;  ; virtual TVirtualArray * PeekDataCache () const;  Return the 'current' data cache area from the list of area to be used for temporarily store 'missing' data members. ;  ; virtual TVirtualArray * PopDataCache ();  Pop and Return the 'current' data cache area from the list of area to be used for temporarily store 'missing' data members. ;  ; virtual void PushDataCache (TVirtualArray *);  Push a new data cache area onto the list of area to be used for temporarily store 'missing' data members. ;  ; virtual Int_t ReadArray (Bool_t *&b)=0;  ; virtual Int_t ReadArray (Char_t *&c)=0;  ; virtual Int_t ReadArray (Double_t *&d)=0;  ; virtual Int_t ReadArray (Float_t *&f)=0;  ; virtual Int_t ReadArray (Int_t *&i)=0;  ; virtual Int_t ReadArray (Long64_t *&l)=0;  ; virtual Int_t ReadArray (Long_t *&l)=0;  ; virtual Int_t ReadArray (Short_t *&h)=0;  ; virtual Int_t ReadArray (UChar_t *&c)=0;  ; virtual Int_t ReadArray (UInt_t *&i)=0;  ; virtual Int_t ReadArray (ULong64_t *&l)=0;  ; virtual Int_t ReadArray (ULong_t *&l)=0;  ; virtual Int_t ReadArray (UShort_t *&h)=0;  ; virtual Int_t ReadArrayDouble32 (Double_t *&d, TStreamerElement *ele=nullptr)=0;  ; virtual Int_t ReadArrayFloat16 (Float_t *&f, TStreamerElement *ele=nullptr)=0;  ; virtual void R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferIO.html:7495,cache,cache,7495,doc/master/classTBufferIO.html,https://root.cern,https://root.cern/doc/master/classTBufferIO.html,1,['cache'],['cache']
Performance,"void ClassEnd (const TClass *)=0;  ; virtual void ClassMember (const char *, const char *=nullptr, Int_t=-1, Int_t=-1)=0;  ; virtual void DecrementLevel (TVirtualStreamerInfo *)=0;  ; void DetachBuffer ();  ; void Expand (Int_t newsize, Bool_t copy=kTRUE);  Expand (or shrink) the I/O buffer to newsize bytes. ;  ; Int_t GetBufferVersion () const;  ; char * GetCurrent () const;  ; virtual TVirtualStreamerInfo * GetInfo ()=0;  ; TObject * GetParent () const;  Return pointer to parent of this buffer. ;  ; ReAllocCharFun_t GetReAllocFunc () const;  Return the reallocation method currently used. ;  ; virtual void IncrementLevel (TVirtualStreamerInfo *info)=0;  ; Bool_t IsReading () const;  ; Bool_t IsWriting () const;  ; Int_t Length () const;  ; virtual TVirtualArray * PeekDataCache () const;  Return the 'current' data cache area from the list of area to be used for temporarily store 'missing' data members. ;  ; virtual TVirtualArray * PopDataCache ();  Pop and Return the 'current' data cache area from the list of area to be used for temporarily store 'missing' data members. ;  ; virtual void PushDataCache (TVirtualArray *);  Push a new data cache area onto the list of area to be used for temporarily store 'missing' data members. ;  ; virtual Int_t ReadArray (Bool_t *&b)=0;  ; virtual Int_t ReadArray (Char_t *&c)=0;  ; virtual Int_t ReadArray (Double_t *&d)=0;  ; virtual Int_t ReadArray (Float_t *&f)=0;  ; virtual Int_t ReadArray (Int_t *&i)=0;  ; virtual Int_t ReadArray (Long64_t *&l)=0;  ; virtual Int_t ReadArray (Long_t *&l)=0;  ; virtual Int_t ReadArray (Short_t *&h)=0;  ; virtual Int_t ReadArray (UChar_t *&c)=0;  ; virtual Int_t ReadArray (UInt_t *&i)=0;  ; virtual Int_t ReadArray (ULong64_t *&l)=0;  ; virtual Int_t ReadArray (ULong_t *&l)=0;  ; virtual Int_t ReadArray (UShort_t *&h)=0;  ; virtual void ReadBool (Bool_t &b)=0;  ; virtual void ReadChar (Char_t &c)=0;  ; virtual void ReadCharP (Char_t *c)=0;  ; virtual void ReadCharStar (char *&s)=0;  ; virtual TClass *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferText.html:11917,cache,cache,11917,doc/master/classTBufferText.html,https://root.cern,https://root.cern/doc/master/classTBufferText.html,1,['cache'],['cache']
Performance,"void HandleIdleTimer ();  Handle idle timeout. ;  ; virtual void Hide ();  ; virtual void Iconify ();  ; virtual void Init ();  ; void InitializeGraphics (Bool_t only_web=kFALSE);  Initialize the graphics environment. ;  ; TObjArray * InputFiles () const;  ; virtual Bool_t IsCmdThread ();  ; Bool_t IsRunning () const;  ; virtual void KeyPressed (Int_t key);  Emit signal when console keyboard key was pressed. ;  ; virtual void LineProcessed (const char *line);  Emit signal when a line has been processed. ;  ; virtual void Lower ();  ; void ls (Option_t *option="""") const override;  Show available sessions. ;  ; Bool_t NoLogoOpt () const;  ; Bool_t NoLogOpt () const;  ; virtual void Open ();  ; void OpenForumTopic (const TString &type);  It opens a Forum topic in a web browser with prefilled ROOT version. ;  ; void OpenGitHubIssue (const TString &type);  It opens a GitHub issue in a web browser with prefilled ROOT version. ;  ; void OpenInBrowser (const TString &url);  The function generates and executes a command that loads the Doxygen URL in a browser. ;  ; void OpenReferenceGuideFor (const TString &strippedClass);  It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/struct) or member (method/function/ data member/enumeration/enumerator. ;  ; virtual Longptr_t ProcessFile (const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE);  Process a file containing a C++ macro. ;  ; virtual Longptr_t ProcessLine (const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr);  Process a single command line, either a C++ statement or an interpreter command starting with a ""."". ;  ; Bool_t QuitOpt () const;  ; virtual void Raise ();  ; virtual void RemoveIdleTimer ();  Remove idle timer. Normally called via TROOT::Idle(0). ;  ; Bool_t ReturnFromRun () const;  ; virtual void ReturnPressed (char *text);  Emit signal when return key was pressed. ;  ; virtual void SetIdleTimer (UInt_t idleTimeInSec, const char *command);  Set the comma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRint.html:3725,load,loads,3725,doc/master/classTRint.html,https://root.cern,https://root.cern/doc/master/classTRint.html,1,['load'],['loads']
Performance,"void InitBranches (Long64_t entry);  Initialize the branch addresses. ;  ; TClass * IsA () const override;  ; char * MakeX (Int_t nvars);  ; void Print (Option_t *option="""") const override;  Print an overview of the hbook ntuple. ;  ; Long64_t SetEntries (Long64_t n=-1) override;  Set the number of entries in the tree header and its branches. ;  ; virtual void SetHbookFile (THbookFile *file);  ; virtual void SetType (Int_t atype);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TTree;  TTree ();  Default constructor and I/O constructor. ;  ;  TTree (const char *name, const char *title, Int_t splitlevel=99, TDirectory *dir=(::ROOT::Internal::TDirectoryAtomicAdapter{}));  Normal tree constructor. ;  ;  TTree (const TTree &tt)=delete;  ;  ~TTree () override;  Destructor. ;  ; void AddAllocationCount (UInt_t count);  ; virtual Int_t AddBranchToCache (const char *bname, bool subbranches=false);  Add branch with name bname to the Tree cache. ;  ; virtual Int_t AddBranchToCache (TBranch *branch, bool subbranches=false);  Add branch b to the Tree cache. ;  ; void AddClone (TTree *);  Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ;  ; virtual TFriendElement * AddFriend (const char *treename, const char *filename="""");  Add a TFriendElement to the list of friends. ;  ; virtual TFriendElement * AddFriend (const char *treename, TFile *file);  Add a TFriendElement to the list of friends. ;  ; virtual TFriendElement * AddFriend (TTree *tree, const char *alias="""", bool warn=false);  Add a TFriendElement to the list of friends. ;  ; virtual void AddTotBytes (Int_t tot);  ; virtual void AddZipBytes (Int_t zip);  ; virtual Long64_t AutoSave (Option_t *option="""");  AutoSave tree header every fAutoSave bytes. ;  ; virtual Int_t Branch (const char *folder, Int_t bufsize=32000, Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHbookTree.html:2790,cache,cache,2790,doc/master/classTHbookTree.html,https://root.cern,https://root.cern/doc/master/classTHbookTree.html,1,['cache'],['cache']
Performance,"void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TEveElement;  TEveElement ();  Default constructor. ;  ;  TEveElement (Color_t &main_color);  Constructor. ;  ;  TEveElement (const TEveElement &e);  Copy constructor. ;  ; virtual ~TEveElement ();  Destructor. ;  ; virtual TGListTreeItem * AddIntoListTree (TGListTree *ltree, TEveElement *parent);  Add this render element into ltree to all items belonging to parent. ;  ; virtual TGListTreeItem * AddIntoListTree (TGListTree *ltree, TGListTreeItem *parent_lti);  Add this element into ltree to an already existing item parent_lti. ;  ; virtual TGListTreeItem * AddIntoListTrees (TEveElement *parent);  Add this render element into all list-trees and all items belonging to parent. ;  ; virtual void AddParent (TEveElement *re);  Add re into the list parents. ;  ; virtual void AddStamp (UChar_t bits);  Add (bitwise or) given stamps to fChangeBits. ;  ; virtual void Annihilate ();  Optimized destruction without check of reference-count. ;  ; virtual void AnnihilateElements ();  Annihilate elements. ;  ; Bool_t ApplyVizTag (const TString &tag, const TString &fallback_tag="""");  Set the VizTag, find model-element from the VizDB and copy visualization-parameters from it. ;  ; List_i BeginChildren ();  ; List_ci BeginChildren () const;  ; List_i BeginParents ();  ; List_ci BeginParents () const;  ; virtual Bool_t CanEditElement () const;  ; virtual Bool_t CanEditMainColor () const;  ; virtual Bool_t CanEditMainTrans () const;  ; virtual Bool_t CanEditMainTransparency () const;  ; virtual void CheckReferenceCount (const TEveException &eh=""TEveElement::CheckReferenceCount "");  Check external references to this and eventually auto-destruct the render-element. ;  ; virtual void ClearStamps ();  ; virtual void CloneChildrenRecurse (TEveElement *dest, Int_t level=0) const;  Clone children and attach them to the dest element. ;  ; virtual TEveElement * CloneElementRecurse (Int_t level",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveCompound.html:4084,Optimiz,Optimized,4084,doc/master/classTEveCompound.html,https://root.cern,https://root.cern/doc/master/classTEveCompound.html,4,['Optimiz'],['Optimized']
Performance,"void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TStreamerElement * GetCurrentElement ();  static function returning a pointer to the current TStreamerElement fgElement points to the current TStreamerElement being read in ReadBuffer ;  ;  Static Public Member Functions inherited from TVirtualStreamerInfo; static Bool_t CanDelete ();  static function returning true if ReadBuffer can delete object ;  ; static Bool_t CanOptimize ();  static function returning true if optimization can be on ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TVirtualStreamerInfo * Factory ();  Static function returning a pointer to a new TVirtualStreamerInfo object. ;  ; static TStreamerBasicType * GetElementCounter (const char *countName, TClass *cl);  Get pointer to a TStreamerBasicType in TClass *cl static function. ;  ; static const char * GetElementCounterStart (const char *dmTitle);  Given a comment/title declaring an array counter, for example: ;  ; static Bool_t GetStreamMemberWise ();  Return whether the TStreamerInfos will save the collections in ""member-wise"" order whenever possible. ;  ; static void Optimize (Bool_t opt=kTRUE);  This is a static function. ;  ; static void SetCanDelete (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerInfo.html:23463,optimiz,optimization,23463,doc/master/classTStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTStreamerInfo.html,1,['optimiz'],['optimization']
Performance,"void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  . Protected Attributes; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Private Member Functions; void addParameters (RooAbsCollection &params, const RooArgSet *nset=nullptr, bool stripDisconnected=true) const;  Add all parameters of the function and its daughters to params. ;  ; bool callRedirectServersHook (RooAbsCollection const &newSet, boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:37856,cache,cache,37856,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['cache'],['cache']
Performance,volution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealVar*RooAbsAnaConvPdf::_convVar! Convolution variable; RooRealProxy_delMistag; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; RooRealProxy_mu; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg:,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBCPGenDecay.html:38906,cache,cache,38906,root/html526/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html526/RooBCPGenDecay.html,1,['cache'],['cache']
Performance,volution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealVar*RooAbsAnaConvPdf::_convVar! Convolution variable; RooRealProxy_delMistag; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; RooRealProxy_mu; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBCPGenDecay.html:39480,cache,cache,39480,root/html528/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html528/RooBCPGenDecay.html,3,['cache'],['cache']
Performance,"vstore); virtual const char*RooAbsCachedPdf::binningName() const; TStringRooAbsCachedPdf::cacheNameSuffix(const RooArgSet& nset) const; voidcalcParams(); RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidRooAbsCachedPdf::clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); virtual RooAbsCachedPdf::PdfCacheElem*createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; voidRooAbsCachedPdf::disableCache(Bool_t flag); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tevaluate() const; virtual voidfillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; voidfillCacheSlice(RooFFTConvPdf::FFTCacheElem& cache, const RooArgSet& slicePosition) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; static Bool_tRooAbsArg::flipAClean(); virtual RooAbsGenContext*genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE) const; RooAbsCachedPdf::PdfCacheElem*RooAbsCachedPdf::getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFFTConvPdf.html:37086,cache,cache,37086,root/html532/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html532/RooFFTConvPdf.html,1,['cache'],['cache']
Performance,"vt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::fTimeUpdttime between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?. private:. TList*fActivenodes with unfinished files; TList*fFileNodesnodes with files; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Int_tfPacketAsAFractionused to calculate the packet size; Long64_tfPacketSizeglobal base packet size; TList*fPacketsall processed packets; TMap*fSlaveStatsslave status, keyed by correspondig TSlave; TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizer(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizer(); Destructor. void RemoveUnAllocNode(TPacketizer::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizer::TFileStat* file); Remove file from the list of actives. void RemoveActiveNode(TPacketizer::TFileNode* ); Remove node from the list of actives. void Reset(); Reset the internal datastructure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t maxent = -1, Bool_t byfile = kFALSE); Check existence of file/dir/tree an get number of entries.; Assumes the files have been setup. Long64_t GetEntrie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPacketizer.html:9829,perform,performance,9829,root/html528/TPacketizer.html,https://root.cern,https://root.cern/root/html528/TPacketizer.html,3,['perform'],['performance']
Performance,"vx and Y coord from vy The number of points in the graph is the minimum of number of points in vx and vy. ;  ;  TGraph (const TVectorF &vx, const TVectorF &vy);  Graph constructor with two vectors of floats in input A graph is build with the X coordinates taken from vx and Y coord from vy The number of points in the graph is the minimum of number of points in vx and vy. ;  ;  TGraph (Int_t n);  Constructor with only the number of points set the arrays x and y will be set later. ;  ;  TGraph (Int_t n, const Double_t *x, const Double_t *y);  Graph normal constructor with doubles. ;  ;  TGraph (Int_t n, const Double_t *y, Double_t start=0., Double_t step=1.);  Default X-Points constructor. ;  ;  TGraph (Int_t n, const Float_t *x, const Float_t *y);  Graph normal constructor with floats. ;  ;  TGraph (Int_t n, const Int_t *x, const Int_t *y);  Graph normal constructor with ints. ;  ;  ~TGraph () override;  Graph default destructor. ;  ; virtual void Add (TF1 *f, Double_t c1=1);  Performs the operation: y = y + c1*f(x,y) Errors are not recalculated. ;  ; virtual void AddPoint (Double_t x, Double_t y);  Append a new point to the graph. ;  ; virtual void Apply (TF1 *f);  Apply function f to all the data points f may be a 1-D function TF1 or 2-d function TF2 The Y values of the graph are replaced by the new values computed using the function. ;  ; void Browse (TBrowser *b) override;  Browse. ;  ; virtual Double_t Chisquare (TF1 *f1, Option_t *option="""") const;  Return the chisquare of this graph with respect to f1. ;  ; virtual void ComputeRange (Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const;  Compute the x/y range of the points in this graph. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to a graph. ;  ; void Draw (Option_t *chopt="""") override;  Draw this graph with its current attributes. ;  ; virtual void DrawGraph (Int_t n, const Double_t *x=nullptr, const Double_t *y=nullptr, Option_t *option="""")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCurve.html:8160,Perform,Performs,8160,doc/master/classRooCurve.html,https://root.cern,https://root.cern/doc/master/classRooCurve.html,5,['Perform'],['Performs']
Performance,"vx and Y coord from vy The number of points in the graph is the minimum of number of points in vx and vy. ;  ;  TGraph (const TVectorF &vx, const TVectorF &vy);  Graph constructor with two vectors of floats in input A graph is build with the X coordinates taken from vx and Y coord from vy The number of points in the graph is the minimum of number of points in vx and vy. ;  ;  TGraph (Int_t n);  Constructor with only the number of points set the arrays x and y will be set later. ;  ;  TGraph (Int_t n, const Double_t *x, const Double_t *y);  Graph normal constructor with doubles. ;  ;  TGraph (Int_t n, const Double_t *y, Double_t start=0., Double_t step=1.);  Default X-Points constructor. ;  ;  TGraph (Int_t n, const Float_t *x, const Float_t *y);  Graph normal constructor with floats. ;  ;  TGraph (Int_t n, const Int_t *x, const Int_t *y);  Graph normal constructor with ints. ;  ;  ~TGraph () override;  Graph default destructor. ;  ; virtual void Add (TF1 *f, Double_t c1=1);  Performs the operation: y = y + c1*f(x,y) Errors are not recalculated. ;  ; virtual void AddPoint (Double_t x, Double_t y);  Append a new point to the graph. ;  ; void Browse (TBrowser *b) override;  Browse. ;  ; virtual Double_t Chisquare (TF1 *f1, Option_t *option="""") const;  Return the chisquare of this graph with respect to f1. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to a graph. ;  ; virtual void DrawGraph (Int_t n, const Double_t *x=nullptr, const Double_t *y=nullptr, Option_t *option="""");  Draw this graph with new attributes. ;  ; virtual void DrawGraph (Int_t n, const Float_t *x, const Float_t *y, Option_t *option="""");  Draw this graph with new attributes. ;  ; virtual void DrawGraph (Int_t n, const Int_t *x, const Int_t *y, Option_t *option="""");  Draw this graph with new attributes. ;  ; virtual void DrawPanel ();  Display a panel with all graph drawing options. ;  ; virtual Double_t Eval (Double_t x, TSpline *spline=nullptr, Option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphPolar.html:8861,Perform,Performs,8861,doc/master/classTGraphPolar.html,https://root.cern,https://root.cern/doc/master/classTGraphPolar.html,1,['Perform'],['Performs']
Performance,"vx and Y coord from vy The number of points in the graph is the minimum of number of points in vx and vy. ;  ;  TGraph (const TVectorF &vx, const TVectorF &vy);  Graph constructor with two vectors of floats in input A graph is build with the X coordinates taken from vx and Y coord from vy The number of points in the graph is the minimum of number of points in vx and vy. ;  ;  TGraph (Int_t n);  Constructor with only the number of points set the arrays x and y will be set later. ;  ;  TGraph (Int_t n, const Double_t *x, const Double_t *y);  Graph normal constructor with doubles. ;  ;  TGraph (Int_t n, const Double_t *y, Double_t start=0., Double_t step=1.);  Default X-Points constructor. ;  ;  TGraph (Int_t n, const Float_t *x, const Float_t *y);  Graph normal constructor with floats. ;  ;  TGraph (Int_t n, const Int_t *x, const Int_t *y);  Graph normal constructor with ints. ;  ;  ~TGraph () override;  Graph default destructor. ;  ; virtual void Add (TF1 *f, Double_t c1=1);  Performs the operation: y = y + c1*f(x,y) Errors are not recalculated. ;  ; virtual void AddPoint (Double_t x, Double_t y);  Append a new point to the graph. ;  ; void Browse (TBrowser *b) override;  Browse. ;  ; virtual Double_t Chisquare (TF1 *f1, Option_t *option="""") const;  Return the chisquare of this graph with respect to f1. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to a graph. ;  ; void Draw (Option_t *chopt="""") override;  Draw this graph with its current attributes. ;  ; virtual void DrawGraph (Int_t n, const Double_t *x=nullptr, const Double_t *y=nullptr, Option_t *option="""");  Draw this graph with new attributes. ;  ; virtual void DrawGraph (Int_t n, const Float_t *x, const Float_t *y, Option_t *option="""");  Draw this graph with new attributes. ;  ; virtual void DrawGraph (Int_t n, const Int_t *x, const Int_t *y, Option_t *option="""");  Draw this graph with new attributes. ;  ; virtual void DrawPanel ();  Display a panel with all gr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHist.html:12068,Perform,Performs,12068,doc/master/classRooHist.html,https://root.cern,https://root.cern/doc/master/classRooHist.html,5,['Perform'],['Performs']
Performance,"w */; 642 && rules && !rules.HasRuleWithTarget( element->GetName(), kTRUE ) ); 643 {; 644 TStreamerElement *copy = (TStreamerElement*)element->Clone();; 645 fElements->Add(copy);; 646 copy->SetBit(TStreamerElement::kRepeat);; 647 cached = copy;; 648 ; 649 // Warning(""BuildOld"",""%s::%s is not set from the version %d of %s (You must add a rule for it)\n"",GetName(), element->GetName(), GetClassVersion(), GetName() );; 650 } else {; 651 // If the element is just cached and not repeat, we need to inject an element; 652 // to insure the writing.; 653 TStreamerElement *writecopy = (TStreamerElement*)element->Clone();; 654 fElements->Add(element);; 655 writecopy->SetBit(TStreamerElement::kWrite);; 656 writecopy->SetNewType( writecopy->GetType() );; 657 writecopy->SetOffset( element->GetOffset() );; 658 // Put the write element after the read element (that does caching).; 659 element = writecopy;; 660 }; 661 cached->SetBit(TStreamerElement::kCache);; 662 cached->SetNewType( cached->GetType() );; 663 }; 664 ; 665 fElements->Add(element);; 666 } // end of member loop; 667 ; 668 // Now add artificial TStreamerElement (i.e. rules that creates new members or set transient members).; 669 InsertArtificialElements(rules);; 670 ; 671 if (needAllocClass) {; 672 TStreamerInfo *infoalloc = (TStreamerInfo *)Clone(TString::Format(""%s@@%d"",GetName(),GetClassVersion()));; 673 if (!infoalloc) {; 674 if (!isTransient); 675 Error(""Build"",""Could you create a TStreamerInfo for %s\n"",TString::Format(""%s@@%d"",GetName(),GetClassVersion()).Data());; 676 } else {; 677 // Tell clone we should rerun BuildOld; 678 infoalloc->SetBit(kBuildOldUsed,false);; 679 // Temporarily mark it as built to avoid the BuildCheck from removing; 680 // Technically we only need to do this for the 'current' StreamerInfo; 681 fIsBuilt = kTRUE;; 682 infoalloc->BuildCheck();; 683 infoalloc->BuildOld();; 684 fIsBuilt = kFALSE;; 685 TClass *allocClass = infoalloc->GetClass();; 686 ; 687 {; 688 TIter next(fElements);; 689 TStrea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:24283,cache,cached,24283,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,3,['cache'],['cached']
Performance,"w are more fine control to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed.; To understand how these class work, let’s go through a simple example, such as fitting an histogram.; When fitting an histogram, instead of using TH1::Fit we will show in the following hot wo use the ROOT::Fit classes. We will show how to perform the following different type of fits with the histogram data: * a least square fit using the observed errors (Neyman chi-squared); * a least square fit using the expected errors from the function (Pearson chi-squared); * a binned likelihood fit; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it.; Let’s go through all the steps required for performing these fits using the ROOT::Fit::Fitter class. These steps are: 1. Create the input fit data object. 2. Create the input model function. 3. Configure the fit. 4. Perform the data fitting. 5. Examine the result.; 5.7.1 Creating the input fit data; We have two types of input data, binned data (class ROOT::Fit::BinData) used for least square (chi-square) fits of histograms or TGraph objects or un-binned data (class ROOT::Fit::UnBinData) used for fitting vectors of data points (e.g. from a TTree).; 5.7.1.1 Using Binned data; Let’s suppose we have an histogram, represented as a TH1 type object (it can be one or multi-dimensional). The following shows how to create and fill a ROOT:Fit::BinData object.; ROOT::Fit::DataOptions opt;; opt.fIntegral = true;; ROOT::Fit::BinData data(opt);; // fill the bin data using the histogram; // we can do this using the following helper function from the Hist library; TH1 * h1 = (TH1*) gDirectory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; In this code example, we have used the utility function of the Hist library, ROOT::Fit::FillData to fill the BinData object. The ROOT::Fit::FillData is defined in the headerfile HFitI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:191358,Perform,Perform,191358,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Perform'],['Perform']
Performance,"w render information provided. ; Definition at line 1757 of file RGeomData.cxx. ◆ ProduceIdShifts(). void RGeomDescription::ProduceIdShifts ; (; ). private . Count total number of visible childs under each node. ; Definition at line 629 of file RGeomData.cxx. ◆ ProduceJson(). std::string RGeomDescription::ProduceJson ; (; bool ; all_nodes = false). Produce JSON string which can be directly used with build function from JSROOT to create three.js model of configured geometry. ; Collect all information required to draw geometry on the client This includes list of each visible nodes, meshes and matrixes IfParameters. all_nodesis true, all existing nodes will be provided, which allows to create complete nodes hierarchy on client side. Example of usage:; void geom() { auto f = TFile::Open(""file_name.root""); auto vol = f->Get<TGeoVolume>(""object_name""); ROOT::RGeomDescription desc; desc.Build(vol); std::ofstream fout(""geom.json""); fout << desc.ProduceJson(); }; In JSROOT one loads data from JSON file and call build function to produce three.js model. Also see example in tutorials/webgui/geom/ folder ; Definition at line 1230 of file RGeomData.cxx. ◆ ProduceModifyReply(). std::string RGeomDescription::ProduceModifyReply ; (; int ; nodeid). Return string with only part of nodes description which were modified Checks also volume. ; Definition at line 1734 of file RGeomData.cxx. ◆ ProduceSearchData(). void RGeomDescription::ProduceSearchData ; (; ). Produces search data if necessary. ; Definition at line 1340 of file RGeomData.cxx. ◆ RemoveSignalHandler(). void RGeomDescription::RemoveSignalHandler ; (; const void * ; handler). Remove signal handler. ; Definition at line 321 of file RGeomData.cxx. ◆ ResetRndrInfos(). void RGeomDescription::ResetRndrInfos ; (; ). private . Reset shape info, which used to pack binary data. ; Definition at line 1201 of file RGeomData.cxx. ◆ SavePrimitive(). void RGeomDescription::SavePrimitive ; (; std::ostream & ; fs, . const std::string & ; name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html:23044,load,loads,23044,doc/v632/classROOT_1_1RGeomDescription.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html,2,['load'],['loads']
Performance,"w to leav...Definition RooGlobalFunc.cxx:773; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::NameRooCmdArg Name(const char *name)Definition RooGlobalFunc.cxx:272; xDouble_t x[n]Definition legend1.C:17; RooFit::Plotting@ PlottingDefinition RooGlobalFunc.h:62; rf612_recoverFromInvalidParametersDefinition rf612_recoverFromInvalidParameters.py:1; RooMsgService::StreamConfig::removeTopicvoid removeTopic(RooFit::MsgTopic oldTopic)Definition RooMsgService.h:122; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#0] ERROR:Eval -- RooAbsReal::logEvalError(pol3) evaluation error, ; origin : RooPolynomial::pol3[ x=x coefList=(a1,a2,a3) ]; message : p.d.f normalization integral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); ; ; ; -------------- Starting second fit ---------------; ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimizati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:9293,optimiz,optimization,9293,doc/master/rf612__recoverFromInvalidParameters_8C.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html,2,['optimiz'],['optimization']
Performance,"w() const; Returns handle to the default root window created when calling; XOpenDisplay(). Atom_t InternAtom(const char* atom_name, Bool_t only_if_exist); Returns the atom identifier associated with the specified ""atom_name""; string. If ""only_if_exists"" is False, the atom is created if it does; not exist. If the atom name is not in the Host Portable Character; Encoding, the result is implementation dependent. Uppercase and; lowercase matter; the strings ""thing"", ""Thing"", and ""thinG"" all; designate different atoms. Window_t GetParent(Window_t id) const; Returns the parent of the window ""id"". FontStruct_t LoadQueryFont(const char* font_name); Provides the most common way for accessing a font: opens (loads) the; specified font and returns a pointer to the appropriate FontStruct_t; structure. If the font does not exist, it returns NULL. FontH_t GetFontHandle(FontStruct_t fs); Returns the font handle of the specified font structure ""fs"". void DeleteFont(FontStruct_t fs); Explicitely deletes the font structure ""fs"" obtained via LoadQueryFont(). GContext_t CreateGC(Drawable_t id, GCValues_t* gval); Creates a graphics context using the provided GCValues_t *gval structure.; The mask data member of gval specifies which components in the GC are; to be set using the information in the specified values structure.; It returns a graphics context handle GContext_t that can be used with any; destination drawable or O if the creation falls. void ChangeGC(GContext_t gc, GCValues_t* gval); Changes the components specified by the mask in gval for the specified GC. GContext_t gc - specifies the GC to be changed; GCValues_t gval - specifies the mask and the values to be set; (see also the GCValues_t structure). void CopyGC(GContext_t org, GContext_t dest, Mask_t mask); Copies the specified components from the source GC ""org"" to the; destination GC ""dest"". The ""mask"" defines which component to copy; and it is a data member of GCValues_t. void DeleteGC(GContext_t gc); Deletes the specified ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualX.html:40490,Load,LoadQueryFont,40490,root/html528/TVirtualX.html,https://root.cern,https://root.cern/root/html528/TVirtualX.html,6,['Load'],['LoadQueryFont']
Performance,"w(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidTGLObject::SetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tTGLObject::SetModel(TObject* obj, const Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TGLPlot3D(); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLPlot3D.html:2246,cache,cached,2246,root/html602/TGLPlot3D.html,https://root.cern,https://root.cern/root/html602/TGLPlot3D.html,2,['cache'],['cached']
Performance,"w) because there are many possible configurations.; In some applications you know a priori the list of branches to read.; In other applications the analysis loop calls several layers of user functions; where it is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranch(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the dec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:4743,cache,cache,4743,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,4,['cache'],['cache']
Performance,"w) because there are many possible configurations.; In some applications you know a priori the list of branches to read.; In other applications the analysis loop calls several layers of user functions; where it is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:4743,cache,cache,4743,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,2,['cache'],['cache']
Performance,"w), filename must contain a valid class implementation derived from TSelector. ;  ; static bool IsStandardDraw (const char *selec);  Find out if this is a standard selection used for Draw actions (either TSelectorDraw, TProofDraw or deriving from them). ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions; void CheckCache (const char *fn);  Check the memory cache associated with file 'fn'. ;  ; void CopyFile (const char *fn);  Copy file 'fn' to fDestDir. ;  ; void ReleaseCache (const char *fn);  Release the memory cache associated with file 'fn'. ;  ; void RemoveFile (const char *fn);  Physically remove the file 'fn'. ;  . Private Attributes; TString fDestDir;  ; TPBHandleDSType * fType;  . Additional Inherited Members;  Public Types inherited from TSelector; enum  EAbort { kContinue; , kAbortProcess; , kAbortFile; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelHandleDataSet.html:11306,cache,cache,11306,doc/master/classTSelHandleDataSet.html,https://root.cern,https://root.cern/doc/master/classTSelHandleDataSet.html,1,['cache'],['cache']
Performance,"w, . Int_t & ; root_x, . Int_t & ; root_y, . Int_t & ; win_x, . Int_t & ; win_y, . UInt_t & ; mask . ). overridevirtual . Returns the root window the pointer is logically on and the pointer coordinates relative to the root window's origin. ; The pointer coordinates returned to win_x and win_y are relative to the origin of the specified window. In this case, QueryPointer returns the child that contains the pointer, if any, or else kNone to childw. QueryPointer returns the current logical state of the keyboard buttons and the modifier keys in mask. ; Reimplemented from TVirtualX.; Definition at line 2438 of file GX11Gui.cxx. ◆ RaiseWindow(). void TGX11::RaiseWindow ; (; Window_t ; id). overridevirtual . Put window on top of window stack. ; Reimplemented from TVirtualX.; Definition at line 277 of file GX11Gui.cxx. ◆ ReadGIF(). Pixmap_t TGX11::ReadGIF ; (; Int_t ; x0, . Int_t ; y0, . const char * ; file, . Window_t ; id = 0 . ). overridevirtual . If id is NULL - loads the specified gif file at position [x0,y0] in the current window. ; Otherwise creates pixmap from gif file ; Reimplemented from TVirtualX.; Definition at line 3515 of file TGX11.cxx. ◆ ReadPictureDataFromFile(). Bool_t TGX11::ReadPictureDataFromFile ; (; const char * ; filename, . char *** ; ret_data . ). overridevirtual . Read picture data from file and store in ret_data. ; Returns kTRUE in case of success, kFALSE otherwise. ; Reimplemented from TVirtualX.; Definition at line 1278 of file GX11Gui.cxx. ◆ RemovePixmap(). void TGX11::RemovePixmap ; (; Drawable * ; pix). private . Remove the pixmap pix. ; Definition at line 1472 of file TGX11.cxx. ◆ RemoveWindow(). void TGX11::RemoveWindow ; (; ULong_t ; qwid). overridevirtual . Remove a window created by Qt (like CloseWindow1()). ; Reimplemented from TVirtualX.; Definition at line 1422 of file TGX11.cxx. ◆ ReparentWindow(). void TGX11::ReparentWindow ; (; Window_t ; id, . Window_t ; pid, . Int_t ; x, . Int_t ; y . ). overridevirtual . Reparent window to new ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGX11.html:99698,load,loads,99698,doc/master/classTGX11.html,https://root.cern,https://root.cern/doc/master/classTGX11.html,1,['load'],['loads']
Performance,"w, Double_t xup, Int_t nY, Double_t ylow, Double_t yup); Constructor with specified name and boundaries and partition cell number. ~TH2Poly(); Destructor. Int_t AddBin(TObject* poly); Adds a new bin to the histogram. It can be any object having the method; IsInside(). It returns the bin number in the histogram. It returns 0 if; it failed to add. To allow the histogram limits to expand when a bin; outside the limits is added, call SetFloat() before adding the bin. Int_t AddBin(Int_t n, const Double_t* x, const Double_t* y); Adds a new bin to the histogram. The number of vertices and their (x,y); coordinates are required as input. It returns the bin number in the; histogram. Int_t AddBin(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Add a new bin to the histogram. The bin shape is a rectangle.; It returns the bin number of the bin in the histogram. void Add(const TH1* h1, Double_t c1); Performs the operation: this = this + c1*h1. void Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1. void Add(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1); Replace contents of this histogram by the addition of h1 and h2. void AddBinToPartition(TH2PolyBin* bin); Adds the input bin into the partition cell matrix. This method is called; in AddBin() and ChangePartition(). void ChangePartition(Int_t n, Int_t m); Changes the number of partition cells in the histogram.; Deletes the old partition and constructs a new one. void ClearBinContents(); Clears the contents of all bins in the histogram. void Reset(Option_t* option); Reset this histogram: contents, errors, etc. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Int_t FindBin(Double_t x, Double_t y, Double_t z = 0); Returns the bin number of the bin at the given coordinate. -1 to -9 are; the overflow and underflow bins. overflow bin -5 is the unbinned areas in; the histogram (also called ""the sea""). The third parameter can be left; blank.; The overflow/underfl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TH2Poly.html:32086,Perform,Performs,32086,root/html530/TH2Poly.html,https://root.cern,https://root.cern/root/html530/TH2Poly.html,2,['Perform'],['Performs']
Performance,"w, TVectorD& icupp); Constructor. TQpResidual(const TQpResidual& another); Copy constructor. void CalcResids(TQpDataBase* problem, TQpVar* vars); Calculate residuals, their norms, and duality complementarity gap,; given a problem and variable set. void Add_r3_xz_alpha(TQpVar* vars, Double_t alpha); Modify the ""complementarity"" component of the residuals, by adding the pairwise; products of the complementary variables plus a constant alpha to this term. void Set_r3_xz_alpha(TQpVar* vars, Double_t alpha); Set the ""complementarity"" component of the residuals to the pairwise products of; the complementary variables plus a constant alpha . void Clear_r3(); set the complementarity component of the residuals to 0. void Clear_r1r2(); set the noncomplementarity components of the residual (the terms arising from; the linear equalities in the KKT conditions) to 0. void Project_r3(Double_t rmin, Double_t rmax); Perform the projection operation required by Gondzio algorithm: replace each; component r3_i of the complementarity component of the residuals by r3p_i-r3_i,; where r3p_i is the projection of r3_i onto the box [rmin, rmax]. Then if the; resulting value is less than -rmax, replace it by -rmax. Bool_t ValidNonZeroPattern(); Check if vector elements as selected through array indices are non-zero. void GondzioProjection(TVectorD& v, Double_t rmin, Double_t rmax); Replace each component r3_i of the complementarity component of the residuals; by r3p_i-r3_i, where r3p_i is the projection of r3_i onto the box [rmin, rmax].; Then if the resulting value is less than -rmax, replace it by -rmax. TQpResidual & operator=(const TQpResidual& source); Assignment operator. virtual ~TQpResidual(); {}. Double_t GetResidualNorm(); { return fResidualNorm; }. Double_t GetDualityGap(); { return fDualityGap; }. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id$ » Last generated: 2015-03-14 16:48; This page has been automa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TQpResidual.html:7625,Perform,Perform,7625,root/html534/TQpResidual.html,https://root.cern,https://root.cern/root/html534/TQpResidual.html,1,['Perform'],['Perform']
Performance,"w, TVectorD& icupp); Constructor. TQpResidual(const TQpResidual& another); Copy constructor. void CalcResids(TQpDataBase* problem, TQpVar* vars); Calculate residuals, their norms, and duality complementarity gap,; given a problem and variable set. void Add_r3_xz_alpha(TQpVar* vars, Double_t alpha); Modify the ""complementarity"" component of the residuals, by adding the pairwise; products of the complementary variables plus a constant alpha to this term. void Set_r3_xz_alpha(TQpVar* vars, Double_t alpha); Set the ""complementarity"" component of the residuals to the pairwise products of; the complementary variables plus a constant alpha . void Clear_r3(); set the complementarity component of the residuals to 0. void Clear_r1r2(); set the noncomplementarity components of the residual (the terms arising from; the linear equalities in the KKT conditions) to 0. void Project_r3(Double_t rmin, Double_t rmax); Perform the projection operation required by Gondzio algorithm: replace each; component r3_i of the complementarity component of the residuals by r3p_i-r3_i,; where r3p_i is the projection of r3_i onto the box [rmin, rmax]. Then if the; resulting value is less than -rmax, replace it by -rmax. Bool_t ValidNonZeroPattern(); Check if vector elements as selected through array indices are non-zero. void GondzioProjection(TVectorD& v, Double_t rmin, Double_t rmax); Replace each component r3_i of the complementarity component of the residuals; by r3p_i-r3_i, where r3p_i is the projection of r3_i onto the box [rmin, rmax].; Then if the resulting value is less than -rmax, replace it by -rmax. TQpResidual & operator=(const TQpResidual& source); Assignment operator. virtual ~TQpResidual(); {}. Double_t GetResidualNorm(); { return fResidualNorm; }. Double_t GetDualityGap(); { return fDualityGap; }. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id$ » Last generated: 2015-06-02 16:31; This page has been automa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TQpResidual.html:8093,Perform,Perform,8093,root/html604/TQpResidual.html,https://root.cern,https://root.cern/root/html604/TQpResidual.html,1,['Perform'],['Perform']
Performance,"w, TVectorD& icupp); Constructor. TQpResidual(const TQpResidual& another); Copy constructor. void CalcResids(TQpDataBase* problem, TQpVar* vars); Calculate residuals, their norms, and duality complementarity gap,; given a problem and variable set. void Add_r3_xz_alpha(TQpVar* vars, Double_t alpha); Modify the ""complementarity"" component of the residuals, by adding the pairwise; products of the complementary variables plus a constant alpha to this term. void Set_r3_xz_alpha(TQpVar* vars, Double_t alpha); Set the ""complementarity"" component of the residuals to the pairwise products of; the complementary variables plus a constant alpha . void Clear_r3(); set the complementarity component of the residuals to 0. void Clear_r1r2(); set the noncomplementarity components of the residual (the terms arising from; the linear equalities in the KKT conditions) to 0. void Project_r3(Double_t rmin, Double_t rmax); Perform the projection operation required by Gondzio algorithm: replace each; component r3_i of the complementarity component of the residuals by r3p_i-r3_i,; where r3p_i is the projection of r3_i onto the box [rmin, rmax]. Then if the; resulting value is less than -rmax, replace it by -rmax. Bool_t ValidNonZeroPattern(); Check if vector elements as selected through array indices are non-zero. void GondzioProjection(TVectorD& v, Double_t rmin, Double_t rmax); Replace each component r3_i of the complementarity component of the residuals; by r3p_i-r3_i, where r3p_i is the projection of r3_i onto the box [rmin, rmax].; Then if the resulting value is less than -rmax, replace it by -rmax. TQpResidual & operator=(const TQpResidual& source); Assignment operator. virtual ~TQpResidual(); {}. Double_t GetResidualNorm(); { return fResidualNorm; }. Double_t GetDualityGap(); { return fDualityGap; }. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id$ » Last generated: 2015-06-30 15:29; This page has been automa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQpResidual.html:8093,Perform,Perform,8093,root/html602/TQpResidual.html,https://root.cern,https://root.cern/root/html602/TQpResidual.html,1,['Perform'],['Perform']
Performance,"w, TVectorD& icupp); Constructor. TQpResidual(const TQpResidual& another); Copy constructor. void CalcResids(TQpDataBase* problem, TQpVar* vars); Calculate residuals, their norms, and duality complementarity gap,; given a problem and variable set. void Add_r3_xz_alpha(TQpVar* vars, Double_t alpha); Modify the ""complementarity"" component of the residuals, by adding the pairwise; products of the complementary variables plus a constant alpha to this term. void Set_r3_xz_alpha(TQpVar* vars, Double_t alpha); Set the ""complementarity"" component of the residuals to the pairwise products of; the complementary variables plus a constant alpha . void Clear_r3(); set the complementarity component of the residuals to 0. void Clear_r1r2(); set the noncomplementarity components of the residual (the terms arising from; the linear equalities in the KKT conditions) to 0. void Project_r3(Double_t rmin, Double_t rmax); Perform the projection operation required by Gondzio algorithm: replace each; component r3_i of the complementarity component of the residuals by r3p_i-r3_i,; where r3p_i is the projection of r3_i onto the box [rmin, rmax]. Then if the; resulting value is less than -rmax, replace it by -rmax. Bool_t ValidNonZeroPattern(); Check if vector elements as selected through array indices are non-zero. void GondzioProjection(TVectorD& v, Double_t rmin, Double_t rmax); Replace each component r3_i of the complementarity component of the residuals; by r3p_i-r3_i, where r3p_i is the projection of r3_i onto the box [rmin, rmax].; Then if the resulting value is less than -rmax, replace it by -rmax. TQpResidual & operator=(const TQpResidual& source); Assignment operator. virtual ~TQpResidual(); {}. Double_t GetResidualNorm(); { return fResidualNorm; }. Double_t GetDualityGap(); { return fDualityGap; }. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TQpResidual.h 20882 2007-11-19 11:31:26Z rdm $ » Last generat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQpResidual.html:7537,Perform,Perform,7537,root/html528/TQpResidual.html,https://root.cern,https://root.cern/root/html528/TQpResidual.html,3,['Perform'],['Perform']
Performance,"w,zc,zw; 1808 ; 1809void TFumili::FitChisquareI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimizat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:52758,cache,cache,52758,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,2,['cache'],['cache']
Performance,"w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. Int_t setObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Setter function without integration set. Int_t lastIndex() const; Return index of slot used in last get or set operation. Int_t cacheSize() const; Return size of cache. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface function to intercept server redirects. void operModeHook(); Interface function to intercept cache operation mode changes. void printCompactTreeHook(ostream& , const char* ); Interface function to cache add contents to output in tree printing mode. void insertObjectHook(RooAbsCacheElement& ); Interface function to perform post-insert operations on cached object. » Last changed: Mon Jul 4 15:22:21 2011 » Last generated: 2011-07-04 15:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCacheManager_RooAbsCacheElement_.html:4621,cache,cacheSize,4621,root/html530/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html530/RooCacheManager_RooAbsCacheElement_.html,6,"['cache', 'perform']","['cache', 'cacheSize', 'cached', 'perform']"
Performance,"w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. Int_t setObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Setter function without integration set. Int_t lastIndex() const; Return index of slot used in last get or set operation. Int_t cacheSize() const; Return size of cache. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface function to intercept server redirects. void operModeHook(); Interface function to intercept cache operation mode changes. void printCompactTreeHook(ostream& , const char* ); Interface function to cache add contents to output in tree printing mode. void insertObjectHook(RooAbsCacheElement& ); Interface function to perform post-insert operations on cached object. » Last changed: Thu Nov 3 20:07:39 2011 » Last generated: 2011-11-03 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCacheManager_RooAbsCacheElement_.html:4621,cache,cacheSize,4621,root/html532/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html532/RooCacheManager_RooAbsCacheElement_.html,6,"['cache', 'perform']","['cache', 'cacheSize', 'cached', 'perform']"
Performance,"w::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPconEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for polycone editor. ~TGeoPconEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a given pcon. void CreateSections(Int_t inew); Change dynamically the number of sections. Bool_t CheckSections(Bool_t change = kFALSE); Check validity of sections. void UpdateSections(); Update sections according fShape. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoSectionChange(Int_t i); Change parameters of section isect;. void DoNz(); Change number of sections. void DoPhi(); Change phi range. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void CreateEdges(); {;}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoPconEditor.h 21425 2007-12-17 15:59:27Z brun $ » Last generated: 2010-11-08 19:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPconEditor.html:21686,Perform,Perform,21686,root/html528/TGeoPconEditor.html,https://root.cern,https://root.cern/root/html528/TGeoPconEditor.html,1,['Perform'],['Perform']
Performance,"w::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPconEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for polycone editor. ~TGeoPconEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a given pcon. void CreateSections(Int_t inew); Change dynamically the number of sections. Bool_t CheckSections(Bool_t change = kFALSE); Check validity of sections. void UpdateSections(); Update sections according fShape. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoSectionChange(Int_t i); Change parameters of section isect;. void DoNz(); Change number of sections. void DoPhi(); Change phi range. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void CreateEdges(); {;}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoPconEditor.h 21425 2007-12-17 15:59:27Z brun $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoPconEditor.html:21786,Perform,Perform,21786,root/html530/TGeoPconEditor.html,https://root.cern,https://root.cern/root/html530/TGeoPconEditor.html,1,['Perform'],['Perform']
Performance,"w::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPconEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for polycone editor. ~TGeoPconEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a given pcon. void CreateSections(Int_t inew); Change dynamically the number of sections. Bool_t CheckSections(Bool_t change = kFALSE); Check validity of sections. void UpdateSections(); Update sections according fShape. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoSectionChange(Int_t i); Change parameters of section isect;. void DoNz(); Change number of sections. void DoPhi(); Change phi range. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void CreateEdges(); {;}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoPconEditor.h 21425 2007-12-17 15:59:27Z brun $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPconEditor.html:21786,Perform,Perform,21786,root/html532/TGeoPconEditor.html,https://root.cern,https://root.cern/root/html532/TGeoPconEditor.html,1,['Perform'],['Perform']
Performance,"w< T > GetDirectAccessView (DescriptorId_t fieldId);  ; template<typename T > ; RNTupleDirectAccessView< T > GetDirectAccessView (std::string_view fieldName);  ; RNTupleGlobalRange GetEntryRange ();  Returns an iterator over the entry indices of the RNTuple. ;  ; const Detail::RNTupleMetrics & GetMetrics () const;  ; const RNTupleModel & GetModel ();  ; NTupleSize_t GetNEntries () const;  ; template<typename T > ; RNTupleView< T > GetView (DescriptorId_t fieldId);  ; template<typename T > ; RNTupleView< T > GetView (DescriptorId_t fieldId, std::shared_ptr< T > objPtr);  ; template<typename T > ; RNTupleView< T > GetView (DescriptorId_t fieldId, T *rawPtr);  ; template<typename T > ; RNTupleView< T > GetView (std::string_view fieldName);  Provides access to an individual field that can contain either a scalar value or a collection, e.g. ;  ; template<typename T > ; RNTupleView< T > GetView (std::string_view fieldName, std::shared_ptr< T > objPtr);  ; template<typename T > ; RNTupleView< T > GetView (std::string_view fieldName, T *rawPtr);  ; void LoadEntry (NTupleSize_t index);  Analogous to Fill(), fills the default entry of the model. ;  ; void LoadEntry (NTupleSize_t index, REntry &entry);  Fills a user provided entry after checking that the entry has been instantiated from the ntuple model. ;  ; void PrintInfo (const ENTupleInfo what=ENTupleInfo::kSummary, std::ostream &output=std::cout) const;  Prints a detailed summary of the ntuple, including a list of fields. ;  ; void Show (NTupleSize_t index, std::ostream &output=std::cout);  Shows the values of the i-th entry/row, starting with 0 for the first entry. ;  . Static Public Member Functions; static std::unique_ptr< RNTupleReader > Open (const RNTuple &ntuple, const RNTupleReadOptions &options=RNTupleReadOptions());  ; static std::unique_ptr< RNTupleReader > Open (std::string_view ntupleName, std::string_view storage, const RNTupleReadOptions &options=RNTupleReadOptions());  Open an RNTuple for reading. ;  ; sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html:3174,Load,LoadEntry,3174,doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,1,['Load'],['LoadEntry']
Performance,"wEnd = std::remove_if(ranges.begin(), ranges.end(),; 1826 [](const std::pair<double,double>& input){; 1827 return input.first == input.second;; 1828 });; 1829 ranges.erase(newEnd, ranges.end());; 1830}; 1831}; 1832 ; 1833 ; 1834////////////////////////////////////////////////////////////////////////////////; 1835/// Plot (project) PDF on specified frame.; 1836/// - If a PDF is plotted in an empty frame, it; 1837/// will show a unit-normalized curve in the frame variable. When projecting a multi-; 1838/// dimensional PDF onto the frame axis, hidden parameters are taken are taken at; 1839/// their current value.; 1840/// - If a PDF is plotted in a frame in which a dataset has already been plotted, it will; 1841/// show a projection integrated over all variables that were present in the shown; 1842/// dataset (except for the one on the x-axis). The normalization of the curve will; 1843/// be adjusted to the event count of the plotted dataset. An informational message; 1844/// will be printed for each projection step that is performed.; 1845/// - If a PDF is plotted in a frame showing a dataset *after* a fit, the above happens,; 1846/// but the PDF will be drawn and normalised only in the fit range. If this is not desired,; 1847/// plotting and normalisation range can be overridden using Range() and NormRange() as; 1848/// documented in the table below.; 1849///; 1850/// This function takes the following named arguments (for more arguments, see also; 1851/// RooAbsReal::plotOn(RooPlot*,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,; 1852/// const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,; 1853/// const RooCmdArg&) const ); 1854///; 1855///; 1856/// <table>; 1857/// <tr><th> Type of argument <th> Controlling normalisation; 1858/// <tr><td> `NormRange(const char* name)` <td> Calculate curve normalization w.r.t. specified range[s].; 1859/// See the tutorial rf212_plottingInRanges_blinding.C; 1860/// \note Setting ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:88175,perform,performed,88175,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['perform'],['performed']
Performance,"wLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedReal.html:18297,optimiz,optimizeCacheMode,18297,root/html526/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedReal.html,89,['optimiz'],['optimizeCacheMode']
Performance,"wLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHistFunc.html:17961,optimiz,optimizeCacheMode,17961,root/html526/RooHistFunc.html,https://root.cern,https://root.cern/root/html526/RooHistFunc.html,3,['optimiz'],['optimizeCacheMode']
Performance,"wMembers(TMemberInspector& insp) const; virtual voidTEventIter::StopProcess(Bool_t abort); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TEventIterTree(); TEventIterTree(const TEventIterTree&); TEventIterTree(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Int_tTEventIter::LoadDir(); voidTObject::MakeZombie(). private:. TTree*GetTrees(TDSetElement* elem); TTree*Load(TDSetElement* elem, Bool_t& localfile, const char* objname = 0). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TEventIter::EIterTypeTEventIter::kData; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Long64_tTEventIter::fCurcurrent entry; TDSet*TEventIter::fDSetdata set over which to iterate; TDirectory*TEventIter::fDirdirectory",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEventIterTree.html:5555,Load,Load,5555,root/html602/TEventIterTree.html,https://root.cern,https://root.cern/root/html602/TEventIterTree.html,2,['Load'],['Load']
Performance,"wVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOSTATS; » RooStats::HypoTestInverter. class RooStats::HypoTestInverter: public RooStats::IntervalCalculator, public TNamed. HypoTestInverter class for performing an hypothesis test inversion by scanning the hypothesis test results of the; HybridCalculator for various values of the parameter of interest. By looking at the confidence level curve of; the result an upper limit, where it intersects the desired confidence level, can be derived.; The class implements the RooStats::IntervalCalculator interface and returns an RooStats::HypoTestInverterResult class.; The result is a SimpleInterval, which via the method UpperLimit returns to the user the upper limit value. The HypoTestInverter implements various option for performing the scan. HypoTestInverter::RunFixedScan will scan using a fixed grid the parameter of interest. HypoTestInverter::RunAutoScan will perform an automatic scan to find optimally the curve and it will stop until the desired precision is obtained.; The confidence level value at a given point can be done via HypoTestInverter::RunOnePoint.; The class can scan the CLs+b values or alternativly CLs (if the method HypoTestInverter::UseCLs has been called). New contributions to this class have been written by Matthias Wolf (advanced AutoRun algorithm). Function Members (Methods); public:. virtual~HypoTestInverter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tConfidenceLevel() const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__HypoTestInverter.html:1112,perform,perform,1112,root/html528/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html528/RooStats__HypoTestInverter.html,1,['perform'],['perform']
Performance,"w_t id);  ; TGWindow & operator= (const TGWindow &tgw);  ;  Protected Member Functions inherited from TGObject; TGObject & operator= (const TGObject &tgo);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual const char * GetSenderClassName () const;  ;  Protected Member Functions inherited from TGWidget;  TGWidget (const TGWidget &tgw);  ; Int_t ClearFlags (Int_t flags);  ; TGWidget & operator= (const TGWidget &tgw);  ; Int_t SetFlags (Int_t flags);  . Protected Attributes; Bool_t fAllData;  Is the data bigger than the table. ;  ; TGCanvas * fCanvas;  Canvas that will contains the cells. ;  ; UInt_t fCellHeight;  Default cell width. ;  ; UInt_t fCellWidth;  Default cell width. ;  ; TObjArray * fColumnHeaders;  Array of column headers. ;  ; TTableRange * fCurrentRange;  Range of data currently loaded. ;  ; TTableRange * fDataRange;  Full range of the data set. ;  ; TTableRange * fGotoRange;  Range used by Goto frame. ;  ; TVirtualTableInterface * fInterface;  ; Bool_t fReadOnly;  Table readonly state. ;  ; TObjArray * fRowHeaders;  Array of row headers. ;  ; TObjArray * fRows;  Array of rows. ;  ; Pixel_t fSelectColor;  Select Color. ;  ; TGTableFrame * fTableFrame;  Container for the frames. ;  ; TGTableHeader * fTableHeader;  Top left element of the table. ;  ; Int_t fTMode;  Text justify mode. ;  ; Frames used for layout; TGTableHeaderFrame * fCHdrFrame;  Frame that contains the row headers. ;  ; TGTableHeaderFrame * fRHdrFrame;  Frame that contains the row headers. ;  ; TGHorizontalFrame * fRangeFrame;  Frame that contains the top part. ;  ; TGHorizontalFrame * fTopFrame;  Frame that contains the top part. ;  ; TGHorizontalFrame * fTopExtraFrame;  Dev idea. ;  ; TGHorizontalFrame * fBottomFrame;  Frame that contains the bottom part. ;  ; TGHoriz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTable.html:37860,load,loaded,37860,doc/master/classTGTable.html,https://root.cern,https://root.cern/doc/master/classTGTable.html,1,['load'],['loaded']
Performance,"wable_t id, const char *filename, Pixmap_t &pict, Pixmap_t &pict_mask, PictureAttributes_t &attr) override;  Create a picture pixmap from data on file. ;  ; Pixmap_t CreatePixmap (Drawable_t id, const char *bitmap, UInt_t width, UInt_t height, ULong_t forecolor, ULong_t backcolor, Int_t depth) override;  Create a pixmap from bitmap data. ;  ; Pixmap_t CreatePixmap (Drawable_t id, UInt_t w, UInt_t h) override;  Creates a pixmap of the width and height you specified and returns a pixmap ID that identifies it. ;  ; Pixmap_t CreatePixmapFromData (unsigned char *bits, UInt_t width, UInt_t height) override;  create an image from RGB data. ;  ; Region_t CreateRegion () override;  Create a new empty region. ;  ; Window_t CreateWindow (Window_t parent, Int_t x, Int_t y, UInt_t w, UInt_t h, UInt_t border, Int_t depth, UInt_t clss, void *visual, SetWindowAttributes_t *attr, UInt_t wtype) override;  Return handle to newly created gdk window. ;  ; void DeleteFont (FontStruct_t fs) override;  Explicitely delete font structure obtained with LoadQueryFont(). ;  ; void DeleteGC (GContext_t gc) override;  Explicitely delete a graphics context. ;  ; void DeleteImage (Drawable_t img) override;  Deallocates the memory associated with the image img. ;  ; void DeletePictureData (void *data) override;  Delete picture data created by the function ReadPictureDataFromFile. ;  ; void DeletePixmap (Pixmap_t pmap) override;  Explicitely delete pixmap resource. ;  ; void DeleteProperty (Window_t, Atom_t &) override;  Deletes the specified property on the specified window. ;  ; void DestroyRegion (Region_t reg) override;  Destroy region. ;  ; void DestroySubwindows (Window_t id) override;  Destroy all internal subwindows. ;  ; void DestroyWindow (Window_t id) override;  Destroy window. ;  ; const char * DisplayName (const char *dpyName=0) override;  Return hostname on which the display is opened. ;  ; void DrawBox (Int_t x1, Int_t y1, Int_t x2, Int_t y2, EBoxMode mode) override;  Draw a box. ;  ; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32.html:5306,Load,LoadQueryFont,5306,doc/master/classTGWin32.html,https://root.cern,https://root.cern/doc/master/classTGWin32.html,1,['Load'],['LoadQueryFont']
Performance,"wall clock consumption of fit steps, off by default . PrintLevel(Int_t level) Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational messages are suppressed as well . Warnings(bool flag) Enable or disable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . PyROOT; The RooAbsReal::chi2FitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 4236 of file RooAbsReal.cxx. ◆ chi2FitTo() [4/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataSet & ; xydata, . const RooLinkedList & ; cmdList . ). virtual . Perform a 2-D \( \chi^2 \) fit using a series of x and y values stored in the dataset xydata. ; The y values can either be the event weights, or can be another column designated by the YVar() argument. The y value must have errors defined for the \( \chi^2 \) to be well defined. Options to control construction of the chi-square . YVar(RooRealVar& yvar) Designate given column in dataset as Y value . Integrate(bool flag) Integrate function over range specified by X errors rather than take value at bin center. Options to control flow of fit procedure . InitialHesse(bool flag) Flag controls if HESSE before MIGRAD as well, off by default . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, on by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 through 2, default is 1). Options to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:75647,Perform,Perform,75647,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['Perform'],['Perform']
Performance,"wall clock consumption of fit steps, off by default . PrintLevel(Int_t level) Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational messages are suppressed as well . Warnings(bool flag) Enable or disable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . PyROOT; The RooAbsReal::chi2FitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 4312 of file RooAbsReal.cxx. ◆ chi2FitTo() [4/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataSet & ; xydata, . const RooLinkedList & ; cmdList . ). virtual . Perform a 2-D \( \chi^2 \) fit using a series of x and y values stored in the dataset xydata. ; The y values can either be the event weights, or can be another column designated by the YVar() argument. The y value must have errors defined for the \( \chi^2 \) to be well defined. Options to control construction of the chi-square . YVar(RooRealVar& yvar) Designate given column in dataset as Y value . Integrate(bool flag) Integrate function over range specified by X errors rather than take value at bin center. Options to control flow of fit procedure . InitialHesse(bool flag) Flag controls if HESSE before MIGRAD as well, off by default . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, on by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 through 2, default is 1). Options to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:76915,Perform,Perform,76915,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['Perform'],['Perform']
Performance,"ware Foundation.; ; 14. If you wish to incorporate parts of the Library into other free; programs whose distribution conditions are incompatible with these,; write to the author to ask for permission. For software which is; copyrighted by the Free Software Foundation, write to the Free; Software Foundation; we sometimes make exceptions for this. Our; decision will be guided by the two goals of preserving the free status; of all derivatives of our free software and of promoting the sharing; and reuse of software generally. NO WARRANTY. 15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO; WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.; EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR; OTHER PARTIES PROVIDE THE LIBRARY ""AS IS"" WITHOUT WARRANTY OF ANY; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR; PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE; LIBRARY IS WITH YOU. SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME; THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. 16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN; WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY; AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU; FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR; CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE; LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING; RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A; FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF; SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH; DAMAGES. END OF TERMS AND CONDITIONS; ; How to Apply These Terms to Your New Libraries. If you develop a new library, and you want it to be of the greatest; possible use to the public, we recommend making it free software that; everyone c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/license.html:25832,PERFORM,PERFORMANCE,25832,d/license.html,https://root.cern,https://root.cern/d/license.html,1,['PERFORM'],['PERFORMANCE']
Performance,"way. This is correct & desirable behavior for cyclical observables such as angles,; but it may not be for other observables. The effect that is observed is that if; p.d.f is zero at xMin and non-zero at xMax some spillover occurs and; a rising tail may appear at xMin. This effect can be reduced or eliminated by; introducing a buffer zone in the FFT calculation. If this feature is activated; input the sampling array for the FFT calculation is extended in both directions; and filled with repetitions of the lowest bin value and highest bin value; respectively. The buffer bins are stripped again when the FFT output values; are transferred to the p.d.f cache. The default buffer size is 10% of the; observable domain size and can be changed with setBufferFraction() member function. This class is a caching p.d.f inheriting from RooAbsCachedPdf. If this p.d.f; is evaluated for a particular value of x, the FFT calculate the values for the; p.d.f at all points in observables space for the given choice of parameters,; which are stored in the cache. Subsequent evaluations of RooFFTConvPdf with; identical parameters will retrieve results from the cache. If one or more; of the parameters change, the cache will be updated. The sampling density of the cache is controlled by the binning of the; the convolution observable, which can be changed from RooRealVar::setBins(N); For good results N should be large (>1000). Additional interpolation of; cache values may improve the result if courser binning are chosen. These can be; set in the constructor or through the setInterpolationOrder() member function.; For N>1000 interpolation will not substantially improve the performance. Additionial information on caching activities can be displayed by monitoring; the message stream with topic ""Caching"" at the INFO level, i.e.; do RooMsgService::instance().addStream(RooMsgService::INFO,Topic(""Caching"")); to see these message on stdout. Multi-dimensional convolutions are not supported yet, but will b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:2182,cache,cache,2182,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,7,['cache'],['cache']
Performance,"waysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLPolyMarker.html:1857,cache,cached,1857,root/html534/TGLPolyMarker.html,https://root.cern,https://root.cern/root/html534/TGLPolyMarker.html,1,['cache'],['cached']
Performance,"wd(const char* passwd); Set global passwd to be used for authentication to rootd or proofd. void SetGlobalPwHash(Bool_t pwhash); Set global passwd hash flag to be used for authentication to rootd or proofd. void SetGlobalSRPPwd(Bool_t srppwd); Set global SRP passwd flag to be used for authentication to rootd or proofd. void SetReadHomeAuthrc(Bool_t readhomeauthrc); Set flag controlling the reading of $HOME/.rootauthrc.; In PROOF the administrator may want to switch off private settings.; Always true, may only be set false via option to proofd. void SetGlobalExpDate(TDatime expdate); Set default expiring date for new validity contexts. void SetDefaultUser(const char* defaultuser); Set default user name. void SetTimeOut(Int_t to); Set timeout (active if > 0). void SetAuthReUse(Bool_t authreuse); Set global AuthReUse flag. void SetPromptUser(Bool_t promptuser); Set global PromptUser flag. void SetSecureAuthHook(SecureAuth_t func); Set secure authorization function. Automatically called when libSRPAuth; is loaded. void SetKrb5AuthHook(Krb5Auth_t func); Set kerberos5 authorization function. Automatically called when; libKrb5Auth is loaded. void SetGlobusAuthHook(GlobusAuth_t func); Set Globus authorization function. Automatically called when; libGlobusAuth is loaded. Int_t SshError(const char* errfile); SSH error parsing: returns; 0 : no error or fatal; 1 : should retry (eg 'connection closed by remote host'). Int_t SshAuth(TString& user); SSH client authentication code. const char * GetSshUser(TString user) const; Method returning the user to be used for the ssh login.; Looks first at SSH.Login and finally at env USER.; If SSH.LoginPrompt is set to 'yes' it prompts for the 'login name'. Bool_t CheckHost(const char* Host, const char* host); Check if 'host' matches 'href':; this means either equal or ""containing"" it, even with wild cards *; in the first field (in the case 'href' is a name, ie not IP address); Returns kTRUE if the two matches. Int_t RfioAuth(TString& user);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:16383,load,loaded,16383,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['load'],['loaded']
Performance,"we found it, we need to make sure it is initialize (Find does not initialize the StreamerInfo).; 2190 info = (TStreamerInfo*)cl->GetStreamerInfo(info->GetClassVersion());; 2191 }; 2192 }; 2193 if( info ) {; 2194 fInfo = info;; 2195 // We no longer reset the class version so that in case the user is passing us later; 2196 // the address of a class that require (another) Conversion we can find the proper; 2197 // StreamerInfo.; 2198 // fClassVersion = fInfo->GetClassVersion();; 2199 }; 2200 }; 2201 }; 2202}; 2203 ; 2204 ; 2205////////////////////////////////////////////////////////////////////////////////; 2206/// Init the streamer info for the branch class, try to compensate for class; 2207/// code unload/reload and schema evolution.; 2208 ; 2209void TBranchElement::InitInfo(); 2210{; 2211 if (!fInfo); 2212 SetupInfo();; 2213 ; 2214 //; 2215 // Fixup cached streamer info if necessary.; 2216 //; 2217 // FIXME: What if the class code was unloaded/reloaded since we were cached?; 2218 ; 2219 if (fInfo) {; 2220 ; 2221 if (!fInfo->IsCompiled()) {; 2222 // Streamer info has not yet been compiled.; 2223 ; 2224 Error(""InitInfo"",""StreamerInfo is not compiled."");; 2225 }; 2226 // return immediately if we are called recursively.; 2227 if (fInInitInfo); 2228 return;; 2229 fInInitInfo = true;; 2230 if (!fInit) {; 2231 // We were read in from a file, figure out what our fID should be,; 2232 // schema evolution must be considered.; 2233 //; 2234 // Force our fID to be the id of the first streamer element that matches our name.; 2235 //; 2236 auto SetOnfileObject = [this](TStreamerInfo *info) {; 2237 Int_t arrlen = 1;; 2238 if (fType==31 || fType==41) {; 2239 TLeaf *leaf = (TLeaf*)fLeaves.At(0);; 2240 if (leaf) {; 2241 arrlen = leaf->GetMaximum();; 2242 }; 2243 }; 2244 bool toplevel = (fType == 3 || fType == 4 || (fType == 0 && fID == -2));; 2245 bool seenExisting = false;; 2246 ; 2247 fOnfileObject = new TVirtualArray( info->GetElement(0)->GetClassPointer(), arrlen );; 2248 // Propag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:79301,cache,cached,79301,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['cache'],['cached']
Performance,"ween [] in the option.; For example, with a TCutG named ""cutg"", one can call:; myhist->ProfileY("" "",firstybin,lastybin,""[cutg]"");; To invert the cut, it is enough to put a ""-"" in front of its name:; myhist->ProfileY("" "",firstybin,lastybin,""[-cutg]"");; It is possible to apply several cuts:; myhist->ProfileY("" "",firstybin,lastybin,""[cutg1,cutg2]"");. NOTE that if a TProfile named ""name"" exists in the current directory or pad with; a compatible axis the profile is reset and filled again with the projected contents of the TH2.; In the case of axis incompatibility an error is reported and a NULL pointer is returned. NOTE that the Y axis attributes of the TH2 are copied to the X axis of the profile. NOTE that the default under- / overflow behavior differs from what ProjectionX; does! Profiles take the bin center into account, so here the under- and overflow; bins are ignored by default. TH1D * DoProjection(bool onX, const char* name, Int_t firstbin, Int_t lastbin, Option_t* option) const; Internal (protected) method for performing projection on the X or Y axis; called by ProjectionX or ProjectionY. TH1D * ProjectionX(const char* name = ""_px"", Int_t firstybin = 0, Int_t lastybin = -1, Option_t* option = """") const; Project a 2-D histogram into a 1-D histogram along X. The projection is always of the type TH1D.; The projection is made from the channels along the Y axis; ranging from firstybin to lastybin included.; By default, all bins including under- and overflow are included.; The number of entries in the projection is estimated from the; number of effective entries for all the cells included in the projection. To exclude the underflow bins in Y, use firstybin=1.; To exclude the overflow bins in Y, use lastybin=nx. if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the taget axes will be; kept, but only bins inside the selected range will be filled. Using a TCut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2.html:51122,perform,performing,51122,root/html602/TH2.html,https://root.cern,https://root.cern/root/html602/TH2.html,2,['perform'],['performing']
Performance,"weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_PyKeras_LSTM.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVAClassification_BDTG.weights.xml␛[0m; nthreads = 4; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: TMVA_LSTM for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0529 sec ; Factory : Test method: TMVA_DNN for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 800; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.0218 sec ; Factory : Test method: PyKeras_LSTM for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_LSTM.h5; PyKeras_LSTM : [dataset] : Evaluation of PyKeras_LSTM on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.249 sec ; Factory : Test method: BDTG for Classification performance; : ; BDTG : [dataset] : Evaluation of BDTG on testing sample (800 events); : Elapsed time for evaluation of 800 events: 0.00679 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: TMVA_LSTM; : ; TMVA_LSTM : [dataset] : Loop over test events and fill histograms with classifier response...; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; : Dataset[dataset] : variable plots are not produces ! The number of variables is 300 , it",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:53230,perform,performance,53230,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['perform'],['performance']
Performance,"weights (the variables must exist in the original TTree); # for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; # for background: factory->SetBackgroundWeightExpression(""weight1*weight2"");; # loader->SetBackgroundWeightExpression( ""weight"" );; ; # Apply additional cuts on the signal and background samples (can be different); mycuts = """" # for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; mycutb = """" # for example: TCut mycutb = ""abs(var1)<0.5"";; ; # Tell the factory how to use the training and testing events; # If no numbers of events are given, half of the events in the tree are used; # for training, and the other half for testing:; # loader.PrepareTrainingAndTestTree( mycut, ""SplitMode=random:!V"" );; # It is possible also to specify the number of training and testing events,; # note we disable the computation of the correlation matrix of the input variables; ; nTrainSig = 0.8 * nEventsSig; nTrainBkg = 0.8 * nEventsBkg; ; # build the string options for DataLoader::PrepareTrainingAndTestTree; ; loader.PrepareTrainingAndTestTree(; mycuts,; mycutb,; nTrain_Signal=nTrainSig,; nTrain_Background=nTrainBkg,; SplitMode=""Random"",; SplitSeed=100,; NormMode=""NumEvents"",; V=False,; CalcCorrelations=False,; ); ; ; # DataSetInfo : [dataset] : Added class ""Signal""; # : Add Tree sig_tree of type Signal with 10000 events; # DataSetInfo : [dataset] : Added class ""Background""; # : Add Tree bkg_tree of type Background with 10000 events; ; # signalTree.Print();; ; # Booking Methods; ; # Here we book the TMVA methods. We book a Boosted Decision Tree method (BDT); ; ; # Boosted Decision Trees; if useTMVABDT:; factory.BookMethod(; loader,; TMVA.Types.kBDT,; ""BDT"",; V=False,; NTrees=400,; MinNodeSize=""2.5%"",; MaxDepth=2,; BoostType=""AdaBoost"",; AdaBoostBeta=0.5,; UseBaggedBoost=True,; BaggedSampleFraction=0.5,; SeparationType=""GiniIndex"",; nCuts=20,; ); ; ; #### Booking Deep Neural Network; ; # Here we book the DNN of TMVA. See the example TMVA_Higgs_Classif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html:8817,load,loader,8817,doc/master/TMVA__CNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html,1,['load'],['loader']
Performance,"weights of the events in the range [first, first+len). ; This implementation will fill a vector with every event retrieved one by one (even if the weight is constant). Then, it returns a span. ; Implements RooAbsDataStore.; Definition at line 473 of file RooCompositeDataStore.cxx. ◆ hasFilledCache(). bool RooCompositeDataStore::hasFilledCache ; (; ); const. overridevirtual . Reimplemented from RooAbsDataStore.; Definition at line 159 of file RooCompositeDataStore.cxx. ◆ index(). RooCategory * RooCompositeDataStore::index ; (; ). inline . Definition at line 79 of file RooCompositeDataStore.h. ◆ IsA(). TClass * RooCompositeDataStore::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsDataStore.; Definition at line 127 of file RooCompositeDataStore.h. ◆ isWeighted(). bool RooCompositeDataStore::isWeighted ; (; ); const. overridevirtual . Implements RooAbsDataStore.; Definition at line 269 of file RooCompositeDataStore.cxx. ◆ loadValues(). void RooCompositeDataStore::loadValues ; (; const RooAbsDataStore * ; tds, . const RooFormulaVar * ; select = nullptr, . const char * ; rangeName = nullptr, . std::size_t ; nStart = 0, . std::size_t ; nStop = std::numeric_limits<std::size_t>::max() . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 280 of file RooCompositeDataStore.cxx. ◆ merge(). RooAbsDataStore * RooCompositeDataStore::merge ; (; const RooArgSet & ; allvars, . std::list< RooAbsDataStore * > ; dstoreList . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 335 of file RooCompositeDataStore.cxx. ◆ numEntries(). Int_t RooCompositeDataStore::numEntries ; (; ); const. overridevirtual . Implements RooAbsDataStore.; Definition at line 359 of file RooCompositeDataStore.cxx. ◆ recalculateCache(). void RooCompositeDataStore::recalculateCache ; (; const RooArgSet * ; proj, . Int_t ; firstEvent, . Int_t ; lastEvent, . Int_t ; stepSize, . bool ; skipZeroWeights . ). overridevirtual .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCompositeDataStore.html:26904,load,loadValues,26904,doc/master/classRooCompositeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooCompositeDataStore.html,1,['load'],['loadValues']
Performance,weights/TMVA_CNN_Classification_TMVA_DNN_CPU.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_TMVA_CNN_CPU.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_PyKeras.weights.xml␛[0m; : Reading weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_PyTorch.weights.xml␛[0m; Factory : ␛[1mTest all methods␛[0m; Factory : Test method: BDT for Classification performance; : ; BDT : [dataset] : Evaluation of BDT on testing sample (400 events); : Elapsed time for evaluation of 400 events: 0.00573 sec ; Factory : Test method: TMVA_DNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 400; : ; TMVA_DNN_CPU : [dataset] : Evaluation of TMVA_DNN_CPU on testing sample (400 events); : Elapsed time for evaluation of 400 events: 0.023 sec ; Factory : Test method: TMVA_CNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 400; : ; TMVA_CNN_CPU : [dataset] : Evaluation of TMVA_CNN_CPU on testing sample (400 events); : Elapsed time for evaluation of 400 events: 0.149 sec ; Factory : Test method: PyKeras for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_cnn.h5; PyKeras : [dataset] : Evaluation of PyKeras on testing sample (400 events); : Elapsed time for evaluation of 400 events: 0.175 sec ; Factory : Test method: PyTorch for Classification performance; : ; : Setup PyTorch Model for training; : Executing user initialization code from /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/tmva/PyTorch_Generate_CNN_Model.py; RecursiveScriptModule(; original_name=Sequential; (0): RecursiveScriptModule(original_name=Re,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:38368,perform,performance,38368,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['perform'],['performance']
Performance,"wer, Double_t & upper); 1405{; 1406 if (a <= 0 || b <= 0) {; 1407 lower = 0; upper = 1;; 1408 gROOT->Error(""TEfficiency::BayesianShortest"",""Invalid input parameters - return [0,1]"");; 1409 return kFALSE;; 1410 }; 1411 ; 1412 // treat here special cases when mode == 0 or 1; 1413 double mode = BetaMode(a,b);; 1414 if (mode == 0.0) {; 1415 lower = 0;; 1416 upper = ROOT::Math::beta_quantile(level, a, b);; 1417 return kTRUE;; 1418 }; 1419 if (mode == 1.0) {; 1420 lower = ROOT::Math::beta_quantile_c(level, a, b);; 1421 upper = 1.0;; 1422 return kTRUE;; 1423 }; 1424 // special case when the shortest interval is undefined return the central interval; 1425 // can happen for a posterior when passed=total=0; 1426 //; 1427 if ( a==b && a<=1.0) {; 1428 lower = BetaCentralInterval(level,a,b,kFALSE);; 1429 upper = BetaCentralInterval(level,a,b,kTRUE);; 1430 return kTRUE;; 1431 }; 1432 ; 1433 // for the other case perform a minimization; 1434 // make a function of the length of the posterior interval as a function of lower bound; 1435 Beta_interval_length intervalLength(level,a,b);; 1436 // minimize the interval length; 1437 ROOT::Math::WrappedFunction<const Beta_interval_length &> func(intervalLength);; 1438 ROOT::Math::BrentMinimizer1D minim;; 1439 minim.SetFunction(func, 0, intervalLength.LowerMax() );; 1440 minim.SetNpx(2); // no need to bracket with many iterations. Just do few times to estimate some better points; 1441 bool ret = minim.Minimize(100, 1.E-10,1.E-10);; 1442 if (!ret) {; 1443 gROOT->Error(""TEfficiency::BayesianShortes"",""Error finding the shortest interval"");; 1444 return kFALSE;; 1445 }; 1446 lower = minim.XMinimum();; 1447 upper = lower + minim.FValMinimum();; 1448 return kTRUE;; 1449}; 1450 ; 1451////////////////////////////////////////////////////////////////////////////////; 1452/// Compute the mean (average) of the beta distribution; 1453///; 1454/// \param[in] a parameter > 0 for the beta distribution (for a posterior is passed + prior_alpha; 1455/// \param",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEfficiency_8cxx_source.html:59559,perform,perform,59559,doc/master/TEfficiency_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html,1,['perform'],['perform']
Performance,"what) const;  ; TClass & operator= (const TClass &)=delete;  ; void RegisterAddressInRepository (const char *where, void *location, const TClass *what) const;  ; void SetClassSize (Int_t sizof);  ; void SetClassVersion (Version_t version);  Private function. ;  ; void SetRuntimeProperties ();  Internal routine to set calculate the class properties that can only be known at run-time, for example whether the Hash member function and the destructor are consistent. ;  ; void SetStreamerImpl ();  Internal routine to set fStreamerImpl based on the value of fStreamerType. ;  ; void UnregisterAddressInRepository (const char *where, void *location, const TClass *what) const;  . Static Private Member Functions; static void ConvStreamerInstrumented (const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class);  Case of instrumented class with a library. ;  ; static DeclIdMap_t * GetDeclIdMap ();  ; static IdMap_t * GetIdMap ();  ; static Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl (const char *);  ; static TClass * LoadClassCustom (const char *requestedname, Bool_t silent);  Helper function used by TClass::GetClass(). ;  ; static TClass * LoadClassDefault (const char *requestedname, Bool_t silent);  Helper function used by TClass::GetClass(). ;  ; static void StreamerDefault (const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class);  Default streaming in cases where either we have no way to know what to do or if Property() has not yet been called. ;  ; static void StreamerExternal (const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class);  There is special streamer for the class. ;  ; static void StreamerInstrumented (const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class);  Case of instrumented class with a library. ;  ; static void StreamerStreamerInfo (const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class);  Case of where we should directly use the StreamerInfo. ;  ; static void StreamerTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:41768,Load,LoadClassCustom,41768,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,2,['Load'],['LoadClassCustom']
Performance,"whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); voidinitialize() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvPdf.html:34967,optimiz,optimizeDirtyHook,34967,root/html526/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html526/RooNumConvPdf.html,3,['optimiz'],['optimizeDirtyHook']
Performance,"when entry does not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Need to return the equivalent of LD_LIBRARY_PATH. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int OpenConne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:34444,load,loaded,34444,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,3,['load'],['loaded']
Performance,"which can be conveniently invoked through a GUI that will appear at the end of the run of this macro. Launch the GUI via the command: root -l ./TMVAGui.C; You can also compile and run the example with the following commands make; ./TMVAClassification <Methods>; where: <Methods> = ""method1 method2"" are the TMVA classifier names example: ./TMVAClassification Fisher LikelihoodPCA BDT; If no method given, a default set is of classifiers is used. Project : TMVA - a ROOT-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVAClassification. ; ; ==> Start TMVAClassification; --- TMVAClassification : Using input file: ./files/tmva_class_example.root; DataSetInfo : [dataset] : Added class ""Signal""; : Add Tree TreeS of type Signal with 6000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 6000 events; Factory : Booking method: ␛[1mCuts␛[0m; : ; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mCutsD␛[0m; : ; CutsD : [dataset] : Create Transformation ""Decorrelate"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mLikelihood␛[0m; : ; Factory : Booking method: ␛[1mLikelihoodPCA␛[0m; : ; LikelihoodPCA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:1745,optimiz,optimization,1745,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['optimiz'],['optimization']
Performance,"which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLearnPrefill() const; {return fPrefillType;}. TTree * GetTree() const; {return fTree;}. Bool_t IsAutoCreated() const; {return fAutoCreated;}. Bool_t IsEnabled() const; {return fEnabled;}. Bool_t IsLearning() const; {return fIsLearning;}. void SetAutoCreated(Bool_t val); {fAutoCreated = val;}. » Author: Rene Brun 04/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:26395,Perform,Perform,26395,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,1,['Perform'],['Perform']
Performance,"while the number of input (output); : nodes is determined by the input variables (output classes, i.e., ; : signal and one background). ; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Neural networks are stable and performing for a large variety of ; : linear and non-linear classification problems. However, in contrast; : to (e.g.) boosted decision trees, the user is advised to reduce the ; : number of input variables that have only little discrimination power. ; : ; : In the tests we have carried out so far, the MLP and ROOT networks; : (TMlpANN, interfaced via TMVA) performed equally well, with however; : a clear speed advantage for the MLP. The Clermont-Ferrand neural ; : net (CFMlpANN) exhibited worse classification performance in these; : tests, which is partly due to the slow convergence of its training; : (at least 10k training cycles are required to achieve approximately; : competitive results).; : ; : ␛[1mOvertraining: ␛[0monly the TMlpANN performs an explicit separation of the; : full training sample into independent training and validation samples.; : We have found that in most high-energy physics applications the ; : available degrees of freedom (training events) are sufficient to ; : constrain the weights of the relatively simple architectures required; : to achieve good performance. Hence no overtraining should occur, and ; : the use of validation samples would only reduce the available training; : information. However, if the performance on the training sample is ; : found to be significantly better than the one found with the inde-; : pendent test sample, caution is needed. The results for these samples ; : are printed to standard output at the end of each training job.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The hidden layer architecture for all ANNs is defined by the option; : ""HiddenLayers=N+1,N,..."", where here the first hidden layer has N+1; : neurons and the second N neurons (and so on), and where N is the nu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:42918,perform,performs,42918,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['perform'],['performs']
Performance,"will have medium number NUMED.; If NUMED=0 they will get the medium number of the divided volume (this). If NDIV<=0,; all range of IAXIS will be divided and the resulting number of divisions will be centered on; IAXIS. If STEP<=0, the real STEP will be computed as the full range of IAXIS divided by NDIV.; Options (case insensitive):; N - divide all range in NDIV cells (same effect as STEP<=0) (GSDVN in G3); NX - divide range starting with START in NDIV cells (GSDVN2 in G3); S - divide all range with given STEP. NDIV is computed and divisions will be centered; in full range (same effect as NDIV<=0) (GSDVS, GSDVT in G3); SX - same as DVS, but from START position. (GSDVS2, GSDVT2 in G3). Int_t DistancetoPrimitive(Int_t px, Int_t py); compute the closest distance of approach from point px,py to this volume. void Draw(Option_t* option = """"); draw top volume according to option. void DrawOnly(Option_t* option = """"); draw only this volume. Bool_t OptimizeVoxels(); Perform an exensive sampling to find which type of voxelization is; most efficient. void Paint(Option_t* option = """"); paint volume. void PrintVoxels() const; Print the voxels for this volume. void ReplayCreation(const TGeoVolume* other); Recreate the content of the other volume without pointer copying. Voxels are; ignored and supposed to be created in a later step via Voxelize. void PrintNodes() const; print nodes. TH2F * LegoPlot(Int_t ntheta = 20, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 60, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RegisterYourself(Option_t* option = """"); Register the volume and all materials/media/matrices/shapes to the manager. void RandomPoints(Int_t npoints = 1000000, Option_t* option = """"); Draw random points in the bounding box of this volume. void RandomRays(Int_t nrays = 10000, Double_t startx = 0, Double_t starty = 0, Double_t st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoVolume.html:26438,Optimiz,OptimizeVoxels,26438,root/html528/TGeoVolume.html,https://root.cern,https://root.cern/root/html528/TGeoVolume.html,6,"['Optimiz', 'Perform']","['OptimizeVoxels', 'Perform']"
Performance,"will have medium number NUMED.; If NUMED=0 they will get the medium number of the divided volume (this). If NDIV<=0,; all range of IAXIS will be divided and the resulting number of divisions will be centered on; IAXIS. If STEP<=0, the real STEP will be computed as the full range of IAXIS divided by NDIV.; Options (case insensitive):; N - divide all range in NDIV cells (same effect as STEP<=0) (GSDVN in G3); NX - divide range starting with START in NDIV cells (GSDVN2 in G3); S - divide all range with given STEP. NDIV is computed and divisions will be centered; in full range (same effect as NDIV<=0) (GSDVS, GSDVT in G3); SX - same as DVS, but from START position. (GSDVS2, GSDVT2 in G3). Int_t DistancetoPrimitive(Int_t px, Int_t py); compute the closest distance of approach from point px,py to this volume. void Draw(Option_t* option = """"); draw top volume according to option. void DrawOnly(Option_t* option = """"); draw only this volume. Bool_t OptimizeVoxels(); Perform an exensive sampling to find which type of voxelization is; most efficient. void Print(Option_t* option = """") const; Print volume info. void Paint(Option_t* option = """"); paint volume. void PrintVoxels() const; Print the voxels for this volume. void ReplayCreation(const TGeoVolume* other); Recreate the content of the other volume without pointer copying. Voxels are; ignored and supposed to be created in a later step via Voxelize. void PrintNodes() const; print nodes. TH2F * LegoPlot(Int_t ntheta = 20, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 60, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RegisterYourself(Option_t* option = """"); Register the volume and all materials/media/matrices/shapes to the manager. void RandomPoints(Int_t npoints = 1000000, Option_t* option = """"); Draw random points in the bounding box of this volume. void RandomRays(Int_t nrays = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:37060,Optimiz,OptimizeVoxels,37060,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,6,"['Optimiz', 'Perform']","['OptimizeVoxels', 'Perform']"
Performance,"wing a functional-chain like approach.; ; // ## Preparation; ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *treeName, const char *fileName); {; ROOT::RDataFrame d(10);; d.Define(""b1"", [](ULong64_t entry) -> double { return entry; }, {""rdfentry_""}); .Define(""b2"", [](ULong64_t entry) -> int { return entry * entry; }, {""rdfentry_""}); .Snapshot(treeName, fileName);; }; ; int df001_introduction(); {; ; // We prepare an input tree to run on; auto fileName = ""df001_introduction.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame, a class that; // allows us to interact with the data contained in the tree.; // We select a default column, a *branch* to adopt ROOT jargon, which will; // be looked at if none is specified by the user when dealing with filters; // and actions.; ROOT::RDataFrame d(treeName, fileName, {""b1""});; ; // ## Operations on the dataframe; // We now review some *actions* which can be performed on the data frame.; // Actions can be divided into instant actions (e. g. Foreach()) and lazy; // actions (e. g. Count()), depending on whether they trigger the event; // loop immediately or only when one of the results is accessed for the; // first time. Actions that return ""something"" either return their result; // wrapped in a RResultPtr or in a RDataFrame.; // But first of all, let us define our cut-flow with two lambda; // functions. We can use free functions too.; auto cutb1 = [](double b1) { return b1 < 5.; };; auto cutb1b2 = [](int b2, double b1) { return b2 % 2 && b1 < 4.; };; ; // ### `Count` action; // The `Count` allows to retrieve the number of the entries that passed the; // filters. Here, we show how the automatic selection of the column kicks; // in in case the user specifies none.; auto entries1 = d.Filter(cutb1) // <- no column name specified here!; .Filter(cutb1b2, {""b2"", ""b1""}); .Count();; ; std::cout << ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df001__introduction_8C.html:1452,perform,performed,1452,doc/master/df001__introduction_8C.html,https://root.cern,https://root.cern/doc/master/df001__introduction_8C.html,1,['perform'],['performed']
Performance,"wing line lists all the libraries currently loaded: gSystem->ListLibraries(); TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; The following line lists all the libraries currently loaded having ""RIO"" in their names: gSystem->ListLibraries("".*RIO.*""). Reimplemented in TUnixSystem.; Definition at line 2085 of file TSystem.cxx. ◆ ListSymbols(). void TSystem::ListSymbols ; (; const char * ; module, . const char * ; re = """" . ). virtual . List symbols in a shared library. ; Reimplemented in TUnixSystem.; Definition at line 2064 of file TSystem.cxx. ◆ Load(). int TSystem::Load ; (; const char * ; module, . const char * ; entry = """", . Bool_t ; system = kFALSE . ). virtual . Load a shared library. ; Returns 0 on successful loading, 1 in case lib was already loaded, -1 in case lib does not exist or in case of error and -2 in case of version mismatch. When entry is specified the loaded lib is searched for this entry point (return -1 when entry does not exist, 0 otherwise). When the system flag is kTRUE, the library is considered a permanent system library that should not be unloaded during the course of the session. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1857 of file TSystem.cxx. ◆ LoadAllLibraries(). UInt_t TSystem::LoadAllLibraries ; (; ). virtual . Load all libraries known to ROOT via the rootmap system. ; Returns the number of top level libraries successfully loaded. ; Definition at line 1970 of file TSystem.cxx. ◆ MakeDirectory(). int TSystem::MakeDirectory ; (; const char * ; name). virtual . Make a directory. ; Returns 0 in case of success and -1 if the directory could not be created (either already exists or illegal path name). ; Reimplemented in TDavixSystem, TNetXNGSystem, TUnixSystem, TWinNTSystem, TDCacheSystem, TNetSystem, and TWebSystem.; Definition at line 827 of file TSystem.cxx. ◆ mkdir(). int TSystem::mkdir ; (; const char * ; name, . Bool_t ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:73285,load,loaded,73285,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['load'],['loaded']
Performance,"witch ON/OFF the real-time logging facility. When this option is; ON, log messages from processing are sent back as they come, instead of; being sent back at the end in one go. This may help debugging or monitoring; in some cases, but, depending on the amount of log, it may have significant; consequencies on the load over the network, so it must be used with care. Int_t SetParallelSilent(Int_t nodes, Bool_t random = kFALSE); Tell PROOF how many slaves to use in parallel. If random is TRUE a random; selection is done (if nodes is less than the available nodes).; Returns the number of parallel slaves. Returns -1 in case of error. Int_t SetParallel(Int_t nodes = 9999, Bool_t random = kFALSE); Tell PROOF how many slaves to use in parallel. Returns the number of; parallel slaves. Returns -1 in case of error. Int_t GoParallel(Int_t nodes, Bool_t accept = kFALSE, Bool_t random = kFALSE); Go in parallel mode with at most ""nodes"" slaves. Since the fSlaves; list is sorted by slave performace the active list will contain first; the most performant nodes. Returns the number of active slaves.; If random is TRUE, and nodes is less than the number of available workers,; a random selection is done.; Returns -1 in case of error. void ShowData(); List contents of the data directory in the sandbox.; This is the place where files produced by the client queries are kept. void ClearData(UInt_t what = kUnregistered, const char* dsname = 0); Remove files for the data directory.; The option 'what' can take the values:; kPurge remove all files and directories under '~/data'; kUnregistered remove only files not in registered datasets (default); kDataset remove files belonging to dataset 'dsname'; User is prompt for confirmation, unless kForceClear is ORed with the option. Bool_t Prompt(const char* p); Prompt the question 'p' requiring an answer y,Y,n,N; Return kTRUE is the answer was y or Y, kFALSE in all other cases. void ClearDataProgress(Int_t r, Int_t t); Progress bar for clear data. void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:58651,perform,performace,58651,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,6,['perform'],"['performace', 'performant']"
Performance,"with a C structure.; tree3.C: in this example, we will show how to extend a tree with a branch from another tree with the Friends feature. These trees have branches with variable length arrays. Each entry has a variable number of tracks, and each track has several variables.; tree4.C: a tree with a class (Event). The class Event is defined in $ROOTSYS/test. In this example we first encounter the impact of splitting a branch. Each script contains the main function, with the same name as the file (i.e. tree1), the function to write - tree1w, and the function to read - tree1r. If the script is not run in batch mode, it displays the tree in the browser and tree viewer. To study the example scripts, you can either execute the main script, or load the script and execute a specific function. For example:; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); 12.14 Example 1: A Tree with Simple Variables; This example shows how to write, view, and read a tree with several simple (integers and floating-point) variables.; 12.14.1 Writing the Tree; Below is the function that writes the tree (tree1w). First, the variables are defined (px, py, pz, random and ev). Then we add a branch for each of the variables to the tree, by calling the TTree::Branch method for each variable.; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; /",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:552268,Load,Load,552268,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Load'],['Load']
Performance,"with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,bool>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction4PdfBinding_double_double_double_double_bool_.html:42948,cache,cache,42948,root/html534/RooCFunction4PdfBinding_double_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html534/RooCFunction4PdfBinding_double_double_double_double_bool_.html,1,['cache'],['cache']
Performance,"with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned befo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:24937,optimiz,optimize,24937,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,1,['optimiz'],['optimize']
Performance,"with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); Update pointer to current Tree and recompute pointers to the branches in the cache. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). const TObjArray * GetCachedBranche",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:23046,optimiz,optimize,23046,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,1,['optimiz'],['optimize']
Performance,"with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parameters. ;  ; RooFit::OwningPtr< RooAbsFunc > bindVars (const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) const;  Create an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order). ;  ; virtual std::string buildCallToAnalyticIntegral (Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) const;  This function defines the analytical integral translation for the class. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a \( \chi^2 \) fit to given histogram. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooLinkedList &cmdList);  Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataSet &xydata, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a 2-D \( \chi^2 \) fit using a series of x and y values stored in the dataset xydata. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataSet &xydata, const RooLinkedList &cmdList);  Perform a 2-D \( \chi^2 \) fit using a series of x and y values stored in the dataset xydata. ;  ; virtual RooFit::OwningPtr< RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:19766,Perform,Perform,19766,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,2,['Perform'],['Perform']
Performance,"with reading old files - as you correctly pointed out this is one of the most crucial ingredients of this project.; Cheers, Axel. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:50 Permalink . Thank you for clarifying a . Thank you for clarifying a transition plan, it is quite a reasonable approach. I just want to add a personal request to your wish list. Would it be possible to improve IO speed for reading? Very often analysis code is constrained by CPU/disk access limits when reading ntuples. The speed varies from ~100kHz for a tree with few float branches to ~200 Hz for complex data structure. A factor of few improvement for complex data can be a difference between requiring just one machine or a small farm. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:51 Permalink . Re: I/O Performance . Hi ROOT User,; We have dramatically improved the I/O performance over the last two years. If you use the latest production release also for writing data you might be able to see a performance improvement of an order of magnitude compared to e.g. 5.26, both in real and CPU time! See e.g. this blog entry.; We have been comparing the performance of ROOT I/O with competitors like Google ProtoBuf; we know exactly where we spend extra time and why, e.g. for schema evolution, proper C++ type support, introspection, pointers.; On the other hand, are you sure you make use of all the performance features ROOT offers? Did you enable the tree cache (on by default for PROOF and one tree per file, off - for now, still - otherwise)? Do you only read the branches you need? I am working on a new TTree read access class that should simplify all of that considerably (and is type safe - no more void*&!); maybe I should take your comment as an invitation to speed up :-); Cheers, Axel. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:51 Permalink . Re: Interpreters . Hi ROOT user,; Thanks for your comments - they are excellent!; Your scenario would probably",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:15376,perform,performance,15376,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['perform'],['performance']
Performance,"with respect to the parameters, that is, find those values of the coefficients which give the lowest value of chisquare.; The user must therefore supply, in addition to the function to be analyzed, via a set or sequence of M applications the instructions which analysis is wanted. The instructions are coded in in the calling program (main.cpp), which allows looping, conditional execution, and all the other possibilities of , but not interactivity, since it must be compiled before execution.; 2.2 Design aspects of M in; What M is:. platform independent; written in an object-oriented way using standard; independent of any external package. The maintainability should be guaranteed with the choice of a modern computer language. Choosing object-oriented technology M should profit from an increased flexibility and functionality and make it also extendable (recursiveness, new algorithms, new functionality).; What M does not:. histogramming; data handling; graphics. M is kept as a low-level package with optimal performance.; The main usages of M are. from a user’s program (such as int main()…); from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. its numerical accuracy (equivalent to its Fortran version); its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a two-way strategy was imposed:. a minimal required interface with minimum interaction with M objects and with appropriate usage of the standard library (STL): the user’s implementation of the FCNBase class, initial parameter values and uncertainties are provided by the to M user via std::vectors.; a rich interface which provides the user with more functionality such as interaction with parameters. The core of the minimization functionality and related tools (the kernel of M ) should be clearly separated from the user, who is interfacing via defined user interfaces (the API).; 2.3 Internal ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:5487,perform,performance,5487,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,1,['perform'],['performance']
Performance,"with the ""pt"" of selected particles for each event, Define() can be used to create a column that contains the desired array elements as follows:; // h is filled with all the elements of `good_pts`, for each event; auto h = df.Define(""good_pts"", [](const ROOT::RVecF &pt) { return pt[pt > 0]; }); .Histo1D(""good_pts"");; ROOT::VecOps::RVec< float >; ptTPaveText * ptDefinition entrylist_figure1.C:7; And in Python:; h = df.Define(""good_pts"", ""pt[pt > 0]"").Histo1D(""good_pts""); Learn more at ROOT::VecOps::RVec. Transformations: manipulating data. Filters; A filter is created through a call to Filter(f, columnList) or Filter(filterString). In the first overload, f can be a function, a lambda expression, a functor class, or any other callable object. It must return a bool signalling whether the event has passed the selection (true) or not (false). It should perform ""read-only"" operations on the columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column names are used as variable names (e.g. Filter(""x[0] + x[1] > 0"")). This is a convenience feature that comes with a certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event loop. See the paragraph about ""Just-in-time compilation"" below for more information.; RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed in order and the first one returning false causes the event to be discarded and triggers the processing of the next entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for each entry: after the first access it simply serves a cached result.; Named filters and cutflow reports; An optional string parameter name can be passed to the Filter() method to create a named",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:27554,multi-thread,multi-threading,27554,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['multi-thread'],['multi-threading']
Performance,"with the aim to provide to the LHC experiments a stand-alone and high performant matrix package for reconstruction. The API of the current package differs from the original one, in order to be compliant to the ROOT coding conventions.; SMatrix contains generic Matrix and Vector classes to describe matrix and vector of arbitrary dimensions and of arbitrary type. The classes are templated on the scalar type and on the size of the matrix (number of rows and columns) or the vector. Therefore, the size has to be known at compile time. Since the release 5.10, SMatrix supports symmetric matrices using a storage class (ROOT::Math::MatRepSym) which contains only the N*(N+1)/2 independent element of a NxN symmetric matrix. It is not in the mandate of this package to provide a complete linear algebra functionality for these classes. What is provided are basic Matrix Template Functions and Vector Template Functions, such as the matrix-matrix, matrix-vector, vector-vector operations, plus some extra functionality for square matrices, like inversion, which is based on the optimized Cramer method for squared matrices of size up to 6x6, and determinant calculation. For a more detailed descriptions and usage examples see:. SVector Class Properties; SMatrix Class Properties; Matrix and Vector Operators and Functions. The SMatrix package contains only header files. Normally one does not need to build any library. In the ROOT distribution a library, libSmatrix is produced with the C++ dictionary information for vectors, symmetric and squared matrices for double, float types up to dimension 7. The current version of SMatrix can be downloaded from here. If you want to install the header files or run the test configure script and then make install or make check to build the tests. No dictionary library is built in this case. References. T. Veldhuizen, Expression Templates, C++ Report, 1995.; T. Glebe, SMatrix - A high performance library for Vector/Matrix calculation and Vertexing, HERA-B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__SMatrixGroup.html:2010,optimiz,optimized,2010,doc/master/group__SMatrixGroup.html,https://root.cern,https://root.cern/doc/master/group__SMatrixGroup.html,1,['optimiz'],['optimized']
Performance,"wmat contains the number of atoms; of a given kind into the molecule of the compound.; In this case, wmat in output is changed to relative; weights. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf); The same as previous but in double precision; Define a medium.; kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field:; - ifield = 0 if no magnetic field;; - ifield = -1 if user decision in guswim;; - ifield = 1 if tracking performed with g3rkuta;; - ifield = 2 if tracking; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm); ubuf pointer to an array of user words; nbuf number of user words; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ); The same as previous but in double precision; Define a rotation matrix; krot rotation matrix number assigned; thetaX polar angle for axis X; phiX azimuthal angle for axis X; thetaY polar angle for axis Y; phiY azimuthal angle for axis Y; thetaZ polar angle for axis Z; phiZ azimuthal angle for axis Z. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t np). functions from GGEOM. Create a new volume; name Volume name; shape Volume type; nmed Tracking medium number; np Number of shape parameters; upar Vector containing shape parameters; The same as previous but in double precision. void Gsdvn2(const char* name, const char* mother, Int_t ndiv, Int_t iaxis, Double_t c0i, Int_t numed); Create a new volume by dividing an existing one.; It divides a previ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMCGeometry.html:10978,perform,performed,10978,root/html528/TVirtualMCGeometry.html,https://root.cern,https://root.cern/root/html528/TVirtualMCGeometry.html,12,['perform'],['performed']
Performance,"wnExtObj! External object is a fake; UInt_tfRef! physical instance ref counting; Bool_tfRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*fScene! scene where object is stored (can be zero!). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLLogicalShape(); Destroy logical shape. void AddRef(TGLPhysicalShape* phys) const; Add reference to given physical shape. void SubRef(TGLPhysicalShape* phys) const; Remove reference to given physical shape, potentially deleting; *this* object when hitting zero ref-count (if fRefStrong is; true). void DestroyPhysicals(); Destroy all physicals attached to this logical. UInt_t UnrefFirstPhysical(); Unreference first physical in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);; b) secondary selection is not in progress as different; render-path is usually taken in this case. Otherwise we return internal bool. Override this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids from GL context. void DLCacheDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLLogicalShape.html:5261,cache,cached,5261,root/html528/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html,6,['cache'],"['cache', 'cached']"
Performance,"wname=nullptr) const =0;  ; virtual RooAbsDataStore * clone (const RooArgSet &vars, const char *newname=nullptr) const =0;  ; int defaultPrintContents (Option_t *) const override;  Define default print options, for a given print style. ;  ; bool dirtyProp () const;  ; virtual void dump ();  ; virtual Int_t fill ()=0;  ; virtual void forceCacheUpdate ();  ; virtual const RooArgSet * get () const;  ; virtual const RooArgSet * get (Int_t index) const =0;  ; virtual RooAbsData::RealSpans getBatches (std::size_t first, std::size_t len) const =0;  Retrieve batches for all observables in this data store. ;  ; virtual RooAbsData::CategorySpans getCategoryBatches (std::size_t, std::size_t) const;  ; virtual std::span< const double > getWeightBatch (std::size_t first, std::size_t len) const =0;  ; virtual bool hasFilledCache () const;  ; TClass * IsA () const override;  ; virtual bool isWeighted () const =0;  ; virtual void loadValues (const RooAbsDataStore *tds, const RooFormulaVar *select=nullptr, const char *rangeName=nullptr, std::size_t nStart=0, std::size_t nStop=std::numeric_limits< std::size_t >::max())=0;  ; virtual RooAbsDataStore * merge (const RooArgSet &allvars, std::list< RooAbsDataStore * > dstoreList)=0;  ; virtual Int_t numEntries () const =0;  ; void Print (Option_t *options=nullptr) const override;  This method must be overridden when a class wants to print itself. ;  ; void printArgs (std::ostream &os) const override;  Print argument of dataset, i.e. the observable names. ;  ; void printClassName (std::ostream &os) const override;  Print class name of dataset. ;  ; void printMultiline (std::ostream &os, Int_t content, bool verbose, TString indent) const override;  Detailed printing interface. ;  ; void printName (std::ostream &os) const override;  Print name of dataset. ;  ; void printTitle (std::ostream &os) const override;  Print title of dataset. ;  ; void printValue (std::ostream &os) const override;  Print value of the dataset, i.e. the sum of weights",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsDataStore.html:2369,load,loadValues,2369,doc/master/classRooAbsDataStore.html,https://root.cern,https://root.cern/doc/master/classRooAbsDataStore.html,1,['load'],['loadValues']
Performance,"wname=nullptr);  Convert map by label to map by index for more efficient internal use. ;  ;  RooCompositeDataStore (const RooCompositeDataStore &other, const RooArgSet &vars, const char *newname=nullptr);  Update index category pointer, if it is contained in input argument vars. ;  ;  RooCompositeDataStore (RooStringView name, RooStringView title, const RooArgSet &vars, RooCategory &indexCat, std::map< std::string, RooAbsDataStore * > const &inputData);  Convert map by label to map by index for more efficient internal use. ;  ;  ~RooCompositeDataStore () override;  Destructor. ;  ; RooAbsArg * addColumn (RooAbsArg &var, bool adjustRange=true) override;  WVE ownership issue here!! Caller (a RooAbsData) should take ownership of all arguments, but only does for the first one here... ;  ; void append (RooAbsDataStore &other) override;  ; void attachBuffers (const RooArgSet &extObs) override;  ; void cacheArgs (const RooAbsArg *owner, RooArgSet &varSet, const RooArgSet *nset=nullptr, bool skipZeroWeights=false) override;  ; const RooAbsArg * cacheOwner () override;  ; bool changeObservableName (const char *from, const char *to) override;  Change name of internal observable named 'from' into 'to'. ;  ; RooAbsDataStore * clone (const char *newname=nullptr) const override;  ; RooAbsDataStore * clone (const RooArgSet &vars, const char *newname=nullptr) const override;  ; void dump () override;  ; Int_t fill () override;  Forward fill request to appropriate subset. ;  ; void forceCacheUpdate () override;  ; virtual const RooArgSet * get () const;  ; const RooArgSet * get (Int_t index) const override;  Load the n-th data point (n='idx') in memory and return a pointer to the internal RooArgSet holding its coordinates. ;  ; virtual const RooArgSet * get (Int_t index) const=0;  ; RooAbsData::RealSpans getBatches (std::size_t first, std::size_t len) const override;  Retrieve batches for all observables in this data store. ;  ; std::span< const double > getWeightBatch (std::size_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCompositeDataStore.html:1955,cache,cacheArgs,1955,doc/master/classRooCompositeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooCompositeDataStore.html,2,['cache'],"['cacheArgs', 'cacheOwner']"
Performance,"wned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyxDependent/convolution variable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooResolutionModel.html:40942,cache,cache,40942,root/html526/RooResolutionModel.html,https://root.cern,https://root.cern/root/html526/RooResolutionModel.html,2,['cache'],['cache']
Performance,"wo main passes:; - render opaque objects from all scenes; - render transparent objects from all scenes. void RenderNonSelected(); Render non-selected objects from all scenes. void RenderSelected(); Render selected objects from all scenes. void RenderSelectedForHighlight(); Render selected objects from all scenes for highlight. void RenderOpaque(Bool_t rnr_non_selected = kTRUE, Bool_t rnr_selected = kTRUE); Render opaque objects from all scenes. void RenderTransparent(Bool_t rnr_non_selected = kTRUE, Bool_t rnr_selected = kTRUE); Render transparent objects from all scenes. void RenderOverlay(Int_t state, Bool_t selection); Render overlay objects. void PostRender(); Function called after rendering is finished.; Here we just unlock the scenes. void PreRenderOverlaySelection(); Perform minimal initialization for overlay selection.; Here we assume that scene has already been drawn and that; camera and overall bounding box are ok.; Scenes are not locked. void PostRenderOverlaySelection(); Perform cleanup after overlay selection. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t recIdx); Process selection record on buffer-position 'recIdx' and; fill the data into 'rec'. Returns TRUE if scene was demangled and an object identified.; When FALSE is returned it is still possible that scene has been; identified. Check for this if interested in scene-selection. The select-buffer is taken form fRnrCtx. Bool_t FindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); Find next select record that can be resolved, starting from; position 'recIdx'.; 'recIdx' is passed as reference and points to found record in the buffer. Bool_t FindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Find next select record that can be resolved and whose result is; not transparent, starting from position 'recIdx'.; 'recIdx' is passed as reference and points to found record in the buffer. Bool_t FindClosestOverlayRecord(TGLOvlSelectRecord& rec, Int_t& recIdx); Find next overlay-select record ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLViewerBase.html:7064,Perform,Perform,7064,root/html534/TGLViewerBase.html,https://root.cern,https://root.cern/root/html534/TGLViewerBase.html,3,['Perform'],['Perform']
Performance,"wo modules containing a definition.; 1164 // FIXME: What do we do if no definition is found.; 1165 DefinitionIDs[ND->getName()].push_back(OwningModule->getASTFile());; 1166 }; 1167 };; 1168 DefinitionFinder defFinder(IDs, CI.getASTContext().getTranslationUnitDecl());; 1169 ; 1170 llvm::cantFail(GlobalModuleIndex::writeIndex(CI.getFileManager(),; 1171 CI.getPCHContainerReader(),; 1172 ModuleIndexPath,; 1173 &IDs));; 1174 ModuleManager->resetForReload();; 1175 ModuleManager->loadGlobalIndex();; 1176 GlobalIndex = ModuleManager->getGlobalIndex();; 1177 }; 1178 HaveFullGlobalModuleIndex = true;; 1179 }; 1180 return GlobalIndex;; 1181}; 1182 ; 1183static void RegisterCxxModules(cling::Interpreter &clingInterp); 1184{; 1185 if (!clingInterp.getCI()->getLangOpts().Modules); 1186 return;; 1187 ; 1188 // Loading of a module might deserialize.; 1189 cling::Interpreter::PushTransactionRAII deserRAII(&clingInterp);; 1190 ; 1191 // Setup core C++ modules if we have any to setup.; 1192 ; 1193 // Load libc and stl first.; 1194 // Load vcruntime module for windows; 1195#ifdef R__WIN32; 1196 LoadModule(""vcruntime"", clingInterp);; 1197 LoadModule(""services"", clingInterp);; 1198#endif; 1199 ; 1200#ifdef R__MACOSX; 1201 LoadModule(""Darwin"", clingInterp);; 1202#else; 1203 LoadModule(""libc"", clingInterp);; 1204#endif; 1205 LoadModule(""std"", clingInterp);; 1206 ; 1207 LoadModule(""_Builtin_intrinsics"", clingInterp);; 1208 ; 1209 // Load core modules; 1210 // This should be vector in order to be able to pass it to LoadModules; 1211 std::vector<std::string> CoreModules = {""ROOT_Foundation_C"",; 1212 ""ROOT_Config"",; 1213 ""ROOT_Rtypes"",; 1214 ""ROOT_Foundation_Stage1_NoRTTI"",; 1215 ""Core"",; 1216 ""Rint"",; 1217 ""RIO""};; 1218 ; 1219 LoadModules(CoreModules, clingInterp);; 1220 ; 1221 // Take this branch only from ROOT because we don't need to preload modules in rootcling; 1222 if (!IsFromRootCling()) {; 1223 std::vector<std::string> CommonModules = {""MathCore""};; 1224 LoadModules(CommonModules, clin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:43194,Load,Load,43194,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['Load']
Performance,"word 'fast' and nentries is -1, the; cloning will be done without unzipping or unstreaming the baskets; (i.e., a direct copy of the raw bytes on disk). When 'fast' is specified, 'option' can also contain a sorting; order for the baskets in the output file. There are currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in the; output file in the same order as in the original file (i.e. the; baskets are sorted by their offset in the original file; Usually; this also means that the baskets are sorted by the index/number of; the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each individual; branches are stored contiguously. This tends to optimize reading; speed when reading a small number (1->5) of branches, since all; their baskets will be clustered together instead of being spread; across the file. However it might decrease the performance when; reading more branches (or the full entry). When using SortBasketsByEntry the baskets with the lowest starting; entry are written first. (i.e. the baskets are sorted by the; index/number of the first entry they contain). This means that on; the file the baskets will be in the order in which they will be; needed when reading the whole tree sequentially. For examples of CloneTree, see tutorials:. -- copytree. A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. -- copytree2. A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. void CopyAddresses(TTree* , Bool_t undo = kFALSE); Set branch addresses of passed tree equal to ours.; If undo is true, reset the branch address instead of copying them.; This insures 'separation' of a cloned tree fro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:62270,perform,performance,62270,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['perform'],['performance']
Performance,"works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:22753,cache,cache,22753,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,2,['cache'],['cache']
Performance,"workspace PDF as prototype and ""split"" a parameter of that PDF into two specialized parameters depending on a category in the dataset.; For example, given a Gaussian PDF \( G(x \,|\, m,s) \) we want to construct a \( G_a(x \,|\, m_a,s) \) and a \( G_b(x \,|\, m_b,s) \) with different mean parameters to be fit to a dataset with observables \( (x,c) \) where \( c \) is a category with states 'a' and 'b'.; Using RooSimWSTool, one can create a simultaneous PDF from \( G_a \) and \( G_b \) from \( G \) with the following commands: RooSimWSTool wst(wspace);; wst.build(""G_sim"", ""G"", SplitParam(""m"",""c""));; RooSimWSToolThe RooSimWSTool is a tool operating on RooWorkspace objects that can clone PDFs into a series of var...Definition RooSimWSTool.h:38; Splitting using a product category; From this simple example one can go to builds of arbitrary complexity by specifying multiple SplitParam arguments on multiple parameters involving multiple splitting categories. Splits can also be performed in the product of multiple categories, i.e., wst.build(""G_sim"", ""G"", SplitParam(""m"",""c,d""));; splits the parameter \( m \) in the product of the states of \( c \) and \( d \).; Constrained split; Another possibility is the ""constrained"" split, which clones the parameter for all but one state and inserts a formula specialization in a chosen state that evaluates to \( 1 - \sum_i(a_i) \) where \( a_i \) are all other specializations. For example, given a category \( c \) with the states ""A"",""B"",""C"",""D"", the specification SplitParamConstrained(""m"",""c"",""D""); will create the parameters \( m_A,m_B,m_C \) and a formula expression \( m_D \) that evaluates to \( (1-(m_A+m_B+m_C)) \). Constrained splits can also be specified in the product of categories. In that case, the name of the remainder state follows the syntax ""{State1;State2}"", where State1 and State2 are the state names of the two spitting categories. Splitting multiple PDFs; The examples so far deal with a single prototype PDF. It is also po",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimWSTool.html:1496,perform,performed,1496,doc/master/classRooSimWSTool.html,https://root.cern,https://root.cern/doc/master/classRooSimWSTool.html,1,['perform'],['performed']
Performance,"ws).\n""; 1347 "" Press Ctrl+R (Ctrl+S) repeateadly to navigate matches in reverse (forward) order"");; 1348 Printf("" Arrow_Right : after Ctrl+R (Ctrl+S), select current match of the history search\n""; 1349 "" [Ctrl+O] [Enter] [Ctrl+J] [Ctrl+M] [Arrow_Left] [Esc,Esc].\n""; 1350 "" Use Ctrl+F or Ctrl+G to cancel search and revert original line"");; 1351 ; 1352 return;; 1353 }; 1354 // We call the function what handles the extended "".help scopeName"" command.; 1355 OpenReferenceGuideFor(strippedCommand);; 1356 }; 1357}; 1358 ; 1359/// Load shared libs necessary for graphics. These libraries are only; 1360/// loaded when gROOT->IsBatch() is kFALSE.; 1361 ; 1362void TApplication::LoadGraphicsLibs(); 1363{; 1364 if (gROOT->IsBatch()); 1365 return;; 1366 ; 1367 if (auto h = gROOT->GetPluginManager()->FindHandler(""TVirtualPad"")); 1368 if (h->LoadPlugin() == -1); 1369 return;; 1370 ; 1371 TString name;; 1372 TString title1 = ""ROOT interface to "";; 1373 TString nativex, title;; 1374 ; 1375#ifdef R__WIN32; 1376 nativex = ""win32gdk"";; 1377 name = ""Win32gdk"";; 1378 title = title1 + ""Win32gdk"";; 1379#elif defined(R__HAS_COCOA); 1380 nativex = ""quartz"";; 1381 name = ""quartz"";; 1382 title = title1 + ""Quartz"";; 1383#else; 1384 nativex = ""x11"";; 1385 name = ""X11"";; 1386 title = title1 + ""X11"";; 1387#endif; 1388 ; 1389 TString guiBackend = gEnv->GetValue(""Gui.Backend"", ""native"");; 1390 guiBackend.ToLower();; 1391 if (guiBackend == ""native"") {; 1392 guiBackend = nativex;; 1393 } else {; 1394 name = guiBackend;; 1395 title = title1 + guiBackend;; 1396 }; 1397 ; 1398 if (auto h = gROOT->GetPluginManager()->FindHandler(""TVirtualX"", guiBackend)) {; 1399 if (h->LoadPlugin() == -1) {; 1400 gROOT->SetBatch(kTRUE);; 1401 return;; 1402 }; 1403 gVirtualX = (TVirtualX *) h->ExecPlugin(2, name.Data(), title.Data());; 1404 fgGraphInit = kTRUE;; 1405 }; 1406 ; 1407 TString guiFactory = gEnv->GetValue(""Gui.Factory"", ""native"");; 1408 guiFactory.ToLower();; 1409 if (guiFactory == ""native""); 1410 guiFactory = """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:55153,Load,LoadGraphicsLibs,55153,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,2,['Load'],"['LoadGraphicsLibs', 'LoadPlugin']"
Performance,"wser)Browse external object inherited from TObject.Definition TClass.cxx:1966; TClass::GetNewROOT::NewFunc_t GetNew() constReturn the wrapper around new ThisClass().Definition TClass.cxx:7447; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2655; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3477; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4554; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7017; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:5959; TClass::LoadClassInfovoid LoadClassInfo() constTry to load the ClassInfo if available.Definition TClass.cxx:5824; TClass::SetResetAfterMergevoid SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc)Install a new wrapper around 'ResetAfterMerge'.Definition TClass.cxx:6977; TClass::GetStreamerInfoImplTVirtualStreamerInfo * GetStreamerInfoImpl(Int_t version, Bool_t silent) constDefinition TClass.cxx:4634; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6494; TClass::fAllPubMethodTViewPubFunctions * fAllPubMethodDefinition TClass.h:210; TClass::ERuntimeProperties::kSet@ kSet; TClass::ERuntimeProperties::kConsistentHash@ kConsistentHash; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::AddClassstatic void AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TClass.cxx:494; TClass::GetMissingDictionarie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:321270,Load,LoadClassInfovoid,321270,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,3,"['Load', 'load']","['LoadClassInfo', 'LoadClassInfovoid', 'load']"
Performance,"wser)Browse external object inherited from TObject.Definition TClass.cxx:1966; TClass::GetNewROOT::NewFunc_t GetNew() constReturn the wrapper around new ThisClass().Definition TClass.cxx:7447; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2655; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3477; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4554; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7017; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:5959; TClass::LoadClassInfovoid LoadClassInfo() constTry to load the ClassInfo if available.Definition TClass.cxx:5824; TClass::SetResetAfterMergevoid SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc)Install a new wrapper around 'ResetAfterMerge'.Definition TClass.cxx:6977; TClass::GetStreamerInfoImplTVirtualStreamerInfo * GetStreamerInfoImpl(Int_t version, Bool_t silent) constDefinition TClass.cxx:4634; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6494; TClass::fAllPubMethodTViewPubFunctions * fAllPubMethodDefinition TClass.h:210; TClass::ERuntimePropertiesERuntimePropertiesIndicates whether GetClassVersion has been called.Definition TClass.h:264; TClass::ERuntimeProperties::kSet@ kSet; TClass::ERuntimeProperties::kConsistentHash@ kConsistentHash; TClass::ERuntimeProperties::kNotInitialized@ kNotInitialized; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:55528,Load,LoadClassInfovoid,55528,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,3,"['Load', 'load']","['LoadClassInfo', 'LoadClassInfovoid', 'load']"
Performance,"wser)Browse external object inherited from TObject.Definition TClass.cxx:2033; TClass::GetNewROOT::NewFunc_t GetNew() constReturn the wrapper around new ThisClass().Definition TClass.cxx:7514; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2722; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3544; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4621; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7084; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:6026; TClass::LoadClassInfovoid LoadClassInfo() constTry to load the ClassInfo if available.Definition TClass.cxx:5891; TClass::SetResetAfterMergevoid SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc)Install a new wrapper around 'ResetAfterMerge'.Definition TClass.cxx:7044; TClass::GetStreamerInfoImplTVirtualStreamerInfo * GetStreamerInfoImpl(Int_t version, Bool_t silent) constDefinition TClass.cxx:4701; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6561; TClass::fAllPubMethodTViewPubFunctions * fAllPubMethodDefinition TClass.h:210; TClass::ERuntimeProperties::kSet@ kSet; TClass::ERuntimeProperties::kConsistentHash@ kConsistentHash; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::AddClassstatic void AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TClass.cxx:555; TClass::GetMissingDictionarie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:323908,Load,LoadClassInfovoid,323908,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,3,"['Load', 'load']","['LoadClassInfo', 'LoadClassInfovoid', 'load']"
Performance,"wser)Browse external object inherited from TObject.Definition TClass.cxx:2033; TClass::GetNewROOT::NewFunc_t GetNew() constReturn the wrapper around new ThisClass().Definition TClass.cxx:7514; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2722; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3544; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4621; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7084; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:6026; TClass::LoadClassInfovoid LoadClassInfo() constTry to load the ClassInfo if available.Definition TClass.cxx:5891; TClass::SetResetAfterMergevoid SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc)Install a new wrapper around 'ResetAfterMerge'.Definition TClass.cxx:7044; TClass::GetStreamerInfoImplTVirtualStreamerInfo * GetStreamerInfoImpl(Int_t version, Bool_t silent) constDefinition TClass.cxx:4701; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6561; TClass::fAllPubMethodTViewPubFunctions * fAllPubMethodDefinition TClass.h:210; TClass::ERuntimePropertiesERuntimePropertiesIndicates whether GetClassVersion has been called.Definition TClass.h:264; TClass::ERuntimeProperties::kSet@ kSet; TClass::ERuntimeProperties::kConsistentHash@ kConsistentHash; TClass::ERuntimeProperties::kNotInitialized@ kNotInitialized; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:55356,Load,LoadClassInfovoid,55356,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,3,"['Load', 'load']","['LoadClassInfo', 'LoadClassInfovoid', 'load']"
Performance,"wsid, . const void * ; buf, . int ; len . ). Send binary data via given websocket id. ; Returns:. -1 - in case of error; 0 - when operation was executed immediately; 1 - when send operation will be performed in different thread . Definition at line 386 of file THttpWSHandler.cxx. ◆ SetDisabled(). void THttpWSHandler::SetDisabled ; (; ). inline . Disable all processing of websockets, normally called shortly before destructor. ; Definition at line 94 of file THttpWSHandler.h. ◆ Streamer(). void THttpWSHandler::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void THttpWSHandler::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 114 of file THttpWSHandler.h. ◆ VerifyDefaultPageContent(). virtual void THttpWSHandler::VerifyDefaultPageContent ; (; std::shared_ptr< THttpCallArg > & ; arg). inlineprotectedvirtual . Method called when default page content is prepared for use By default no-cache header is provided. ; Reimplemented in ROOT::RWebWindowWSHandler.; Definition at line 60 of file THttpWSHandler.h. Friends And Related Symbol Documentation. ◆ THttpServer. friend class THttpServer. friend . Definition at line 27 of file THttpWSHandler.h. Member Data Documentation. ◆ fDisabled. Bool_t THttpWSHandler::fDisabled {kFALSE}. private . ! when true, all further operations will be ignored ; Definition at line 31 of file THttpWSHandler.h. ◆ fEngines. std::vector<std::shared_ptr<THttpWSEngine> > THttpWSHandler::fEngines. private . ! list of active WS engines (connections) ; Definition at line 34 of file THttpWSHandler.h. ◆ fMutex. std::mutex THttpWSHandler::fMutex. private . ! protect list of engines ; Definition at line 33 of file THttpWSHandler.h. ◆ fSendCnt. Int_t THttpWSHandler::fSendCnt {0}. private . ! counter for completed send operations ; Definition at line 32 of file THttpWSHandler.h. ◆ fSyncMode. Bool_t THttpWSHandler::fSyncMode {kTRUE}. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpWSHandler.html:25056,cache,cache,25056,doc/master/classTHttpWSHandler.html,https://root.cern,https://root.cern/doc/master/classTHttpWSHandler.html,1,['cache'],['cache']
Performance,"wvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TMatrixTBase::Printvoid Print(Option_t *name="""") const overridePrint the matrix as a table of elements.Definition TMatrixTBase.cxx:636; TMatrixTSym< Double_t >; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf607_fitresultDefinition rf607_fitresult.py:1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1885.34, estimated distance to minimum: 0.000381082; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 7.2873e-01 +/- 1.13e-01; bkgfrac 4.3445e-01 +/- 8.57e-02; mean 5.0345e+00 +/- 3.36e-02; sig1frac 7.7758e-01 +/- 9.71e-02; sigma1 5.2318e-01 +/- 4.55e-02; sigma2 1.7671e+00 +/- 1.18e+00; ; ; RooFitResult: minimized FCN value: 1885.34, estimated distance to minimum: 0.000381082; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Constant Parameter Value ; -------------------- ------------; a1 -2.0000e-01; ; Floating Parameter InitialValue",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf607__fitresult_8C.html:7778,optimiz,optimization,7778,doc/master/rf607__fitresult_8C.html,https://root.cern,https://root.cern/doc/master/rf607__fitresult_8C.html,2,['optimiz'],['optimization']
Performance,"ww.fftw.org) and requires that your ROOT installation is; compiled with the --enable-fftw3 option (instructions for Linux follow). Note that the performance in terms of speed and stability of RooFFTConvPdf is; vastly superior to that of RooNumConvPdf. An important feature of FFT convolutions is that the observable is treated in a; cyclical way. This is correct & desirable behavior for cyclical observables such as angles,; but it may not be for other observables. The effect that is observed is that if; p.d.f is zero at xMin and non-zero at xMax some spillover occurs and; a rising tail may appear at xMin. This effect can be reduced or eliminated by; introducing a buffer zone in the FFT calculation. If this feature is activated; input the sampling array for the FFT calculation is extended in both directions; and filled with repetitions of the lowest bin value and highest bin value; respectively. The buffer bins are stripped again when the FFT output values; are transferred to the p.d.f cache. The default buffer size is 10% of the; observable domain size and can be changed with setBufferFraction() member function. This class is a caching p.d.f inheriting from RooAbsCachedPdf. If this p.d.f; is evaluated for a particular value of x, the FFT calculate the values for the; p.d.f at all points in observables space for the given choice of parameters,; which are stored in the cache. Subsequent evaluations of RooFFTConvPdf with; identical parameters will retrieve results from the cache. If one or more; of the parameters change, the cache will be updated. The sampling density of the cache is controlled by the binning of the; the convolution observable, which can be changed from RooRealVar::setBins(N); For good results N should be large (>1000). Additional interpolation of; cache values may improve the result if courser binning are chosen. These can be; set in the constructor or through the setInterpolationOrder() member function.; For N>1000 interpolation will not substantially ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:1792,cache,cache,1792,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,7,['cache'],['cache']
Performance,"x 'idx'; 50 void* At(UInt_t idx) override; 51 {; 52 if ( fEnv && fEnv->fObject ) {; 53 fEnv->fIdx = idx;; 54 switch( idx ) {; 55 case 0:; 56 return fEnv->fStart = fFirst.invoke(fEnv);; 57 default:; 58 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 59 return ((char*)fEnv->fStart) + fValDiff*idx;; 60 }; 61 }; 62 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 63 return nullptr;; 64 }; 65 // Call to delete/destruct individual item; 66 void DeleteItem(Bool_t force, void* ptr) const override; 67 {; 68 if ( force && ptr ) {; 69 if ( fVal->fProperties&kNeedDelete) {; 70 TVirtualCollectionProxy *proxy = fVal->fType->GetCollectionProxy();; 71 TPushPop helper(proxy,ptr);; 72 proxy->Clear(""force"");; 73 }; 74 fVal->DeleteItem(ptr);; 75 }; 76 }; 77};; 78 ; 79/**; 80\class TGenVectorBoolProxy; 81\ingroup IO; 82Local optimization class.; 83 ; 84Collection proxies get copied. On copy we switch the type of the; 85proxy to the concrete STL type. The concrete types are optimized; 86for element access.; 87*/; 88class TGenVectorBoolProxy : public TGenCollectionProxy {; 89 Bool_t fLastValue;; 90 ; 91public:; 92 TGenVectorBoolProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c), fLastValue(false); 93 {; 94 // Standard Constructor.; 95 }; 96 ~TGenVectorBoolProxy() override; 97 {; 98 // Standard Destructor.; 99 }; 100 void* At(UInt_t idx) override; 101 {; 102 // Return the address of the value at index 'idx'; 103 ; 104 // However we can 'take' the address of the content of std::vector<bool>.; 105 if ( fEnv && fEnv->fObject ) {; 106 auto vec = (std::vector<bool> *)(fEnv->fObject);; 107 fLastValue = (*vec)[idx];; 108 fEnv->fIdx = idx;; 109 return &fLastValue;; 110 }; 111 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 112 return nullptr;; 113 }; 114 ; 115 void DeleteItem(Bool_t force, void* ptr) const override; 116 {; 117 // Call to delete/destruct individual item; 118 if ( force && ptr ) {; 119 fVal->DeleteItem(ptr);; 120 }; 121 }; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:2642,optimiz,optimized,2642,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['optimiz'],['optimized']
Performance,"x ( this method changes the current matrix). ; Return true if inversion is successful. The method used for general square matrices is the LU factorization taken from Dinv routine from the CERNLIB (written in C++ from CLHEP authors) In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used (The implementation is the one written by the CLHEP authors) ; Definition at line 412 of file SMatrix.icc. ◆ InvertChol(). template<class T , unsigned int D1, unsigned int D2, class R > . bool ROOT::Math::SMatrix< T, D1, D2, R >::InvertChol. inline . Inversion of a symmetric positive defined Matrix using Choleski decomposition. ; ( this method changes the current matrix). Return true if inversion is successful. The method used is based on Choleski decomposition A compile error is given if the matrix is not of type symmetric and a run-time failure if the matrix is not positive defined. For solving a linear system, it is possible to use also the function ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion ; Definition at line 446 of file SMatrix.icc. ◆ InvertFast(). template<class T , unsigned int D1, unsigned int D2, class R > . bool ROOT::Math::SMatrix< T, D1, D2, R >::InvertFast. inline . Fast inversion of a square Matrix ( this method changes the current matrix). ; Return true if inversion is successful. The method used is based on direct inversion using the Cramer rule for matrices upto 5x5. Afterwards the same default algorithm of Invert() is used. Note that this method is faster but can suffer from much larger numerical accuracy when the condition of the matrix is large ; Definition at line 429 of file SMatrix.icc. ◆ IsInUse(). template<class T , unsigned int D1, unsigned int D2, class R > . bool ROOT::Math::SMatrix< T, D1, D2, R >::IsInUse ; (; const T * ; p); const. Function to check if a matrix is sharing same memory location of the passed pointer This function is used by the expression templates to avoid the alias pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html:24600,perform,performing,24600,doc/master/classROOT_1_1Math_1_1SMatrix.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html,1,['perform'],['performing']
Performance,"x (8 vertices/6; faces). If face is non-null it indicates a box face, and the; rect contains the single face (4 vertices). Note use other; version of ViewportRect() if you wish to just pass a static; EFace enum member (e.g. kFaceLowX). Note:; i) Rectangle is NOT clipped by viewport limits - so can result; in rect with corners outside viewport - negative etc; ii) TGLRect provides int (pixel based) values - not subpxiel accurate; iii) Camera must have valid frustum cache - call Apply() after last; modifcation, before calling. TGLVertex3 WorldToViewport(const TGLVertex3& worldVertex, TGLMatrix* modviewMat = 0) const; Convert a 3D world vertex to '3D' viewport (screen) one. The X()/Y(); components of the viewport vertex are the horizontal/vertical pixel; positions. The Z() component is the viewport depth value - for a; default depth range this is 0.0 (at near clip plane) to 1.0 (at far; clip plane). See OpenGL gluProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 WorldDeltaToViewport(const TGLVertex3& worldRef, const TGLVector3& worldDelta) const; Convert a 3D vector worldDelta (shift) about vertex worldRef to a viewport; (screen) '3D' vector. The X()/Y() components of the vector are the horizontal; vertical pixel deltas. The Z() component is the viewport depth delta - for a; default depth range between 0.0 (at near clip plane) to 1.0 (at far clip plane); See OpenGL gluProject & glDepth documentation. Camera must have valid frustum cache - call Apply(). TGLVertex3 ViewportToWorld(const TGLVertex3& viewportVertex, TGLMatrix* modviewMat = 0) const; Convert a '3D' viewport vertex to 3D world one. The X()/Y() components; of viewportVertex are the horizontal/vertical pixel position. TGLLine3 ViewportToWorld(Double_t viewportX, Double_t viewportY) const; Convert a 2D viewport position to 3D world line - the projection of the; viewport point into 3D space. Line runs from near to far camera clip ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLCamera.html:10059,cache,cache,10059,root/html528/TGLCamera.html,https://root.cern,https://root.cern/root/html528/TGLCamera.html,6,['cache'],['cache']
Performance,"x = fTree->GetMaximum(columname);; 1176 if (curmax > theMax) {; 1177 theMax = curmax;; 1178 }; 1179 }; 1180 return theMax;; 1181}; 1182 ; 1183////////////////////////////////////////////////////////////////////////////////; 1184/// Return minimum of column with name columname.; 1185 ; 1186Double_t TChain::GetMinimum(const char* columname); 1187{; 1188 Double_t theMin = DBL_MAX;; 1189 for (Int_t file = 0; file < fNtrees; file++) {; 1190 Long64_t first = fTreeOffset[file];; 1191 LoadTree(first);; 1192 Double_t curmin = fTree->GetMinimum(columname);; 1193 if (curmin < theMin) {; 1194 theMin = curmin;; 1195 }; 1196 }; 1197 return theMin;; 1198}; 1199 ; 1200////////////////////////////////////////////////////////////////////////////////; 1201/// Return the number of branches of the current tree.; 1202///; 1203/// Warning: May set the current tree!; 1204 ; 1205Int_t TChain::GetNbranches(); 1206{; 1207 if (fTree) {; 1208 return fTree->GetNbranches();; 1209 }; 1210 LoadTree(0);; 1211 if (fTree) {; 1212 return fTree->GetNbranches();; 1213 }; 1214 return 0;; 1215}; 1216 ; 1217////////////////////////////////////////////////////////////////////////////////; 1218/// See TTree::GetReadEntry().; 1219 ; 1220Long64_t TChain::GetReadEntry() const; 1221{; 1222 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 1223 // Make sure the element list is up to date; 1224 if (!TestBit(kProofUptodate)); 1225 Warning(""GetBranchStatus"", ""PROOF proxy not up-to-date:""; 1226 "" run TChain::SetProof(true, true) first"");; 1227 return fProofChain->GetReadEntry();; 1228 }; 1229 return TTree::GetReadEntry();; 1230}; 1231 ; 1232////////////////////////////////////////////////////////////////////////////////; 1233/// Return the chain weight.; 1234///; 1235/// By default the weight is the weight of the current tree.; 1236/// However, if the weight has been set in TChain::SetWeight(); 1237/// with the option ""global"", then that weight will be returned.; 1238///; 1239/// Warning: May set the current ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:44305,Load,LoadTree,44305,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['Load'],['LoadTree']
Performance,"x and vector of parameters; 158 T DoEvalPar(const T *x, const double *p) const override; 159 {; 160 return fFunc->EvalPar(x, p);; 161 }; 162 ; 163 /// evaluate function using the cached parameter values (of TF1); 164 /// re-implement for better efficiency; 165 T DoEvalVec(const T *x) const; 166 {; 167 return fFunc->EvalPar(x, 0);; 168 }; 169 ; 170 /// evaluate function using the cached parameter values (of TF1); 171 /// re-implement for better efficiency; 172 T DoEval(const T *x) const override; 173 {; 174 // no need to call InitArg for interpreted functions (done in ctor); 175 ; 176 //const double * p = (fParams.size() > 0) ? &fParams.front() : 0;; 177 ; 178 return fFunc->EvalPar(x, nullptr);; 179 }; 180 ; 181 /// evaluate the partial derivative with respect to the parameter; 182 T DoParameterDerivative(const T *x, const double *p, unsigned int ipar) const override;; 183 ; 184 bool fLinear; // flag for linear functions; 185 bool fPolynomial; // flag for polynomial functions; 186 bool fOwnFunc; // flag to indicate we own the TF1 function pointer; 187 TF1 *fFunc; // pointer to ROOT function; 188 unsigned int fDim; // cached value of dimension; 189 //std::vector<double> fParams; // cached vector with parameter values; 190 ; 191 };; 192 ; 193 /**; 194 * Auxiliar class to bypass the (provisional) lack of vectorization in TFormula::EvalPar.; 195 *; 196 * WrappedMultiTF1Templ::DoParameterDerivation calls TFormula::EvalPar in the case of a general linear function; 197 * built with TFormula using ++; as EvalPar is not vectorized, in order to generalize DoParameterDerivative with; 198 * a general type T, we use this auxiliar class to branch the code in compile time with the double; 199 * specialization (that can call EvalPar) and the general implementation (that throws an error in the case of; 200 * general linear function).; 201 */; 202 template <class T>; 203 struct GeneralLinearFunctionDerivation {; 204 static T DoParameterDerivative(const WrappedMultiTF1Templ<T> *, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:6340,cache,cached,6340,doc/master/WrappedMultiTF1_8h_source.html,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html,2,['cache'],['cached']
Performance,"x size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase ; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode ; Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); Long64_tfTotalUnzipBytes! The total sum of the currently unzipped blks; TTree*TTreeCache::fTree! pointer to the current Tree; Long64_tfUnzipBufferSize! Max Size for the ready unzipped blocks (default is 2*fBufferSize); char**fUnzipChunks! [fNseek] Individual unzipped chunks. Their summed size is kept under control.; TCondition*fUnzipDoneConditionUsed to wait for an unzip tour to finish. Gives the Async feel.; Int_t*fUnzipLen! [fNseek] Length of the unzipped buffers; TCondition*fUnzipStartConditionUsed to signal the threads to start.; Byte_t*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; static Int_tTTreeCache::fgLearnEntriesnumber of entries used fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCacheUnzip.html:14350,cache,cache,14350,root/html534/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html,1,['cache'],['cache']
Performance,"x"");; 941auto histo2 = df2.Histo1D(""y"");; 942 ; 943// just accessing result pointers, the event loops of separate RDataFrames run one after the other; 944histo1->Draw(); // runs first multi-thread event loop; 945histo2->Draw(); // runs second multi-thread event loop; 946 ; 947// alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; 948ROOT::RDF::RunGraphs({histo1, histo2});; 949histo1->Draw(); // results can then be used as usual; 950~~~; 951 ; 952### Performance considerations; 953 ; 954To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; 955For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; 956Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; 957should be preferred for performance-critical applications.; 958 ; 959Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; 960See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case.; 961 ; 962Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; 963before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs.; 964 ; 965Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging fea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:55144,perform,performance-critical,55144,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['perform'],['performance-critical']
Performance,"x"");; 981auto histo2 = df2.Histo1D(""y"");; 982 ; 983// just accessing result pointers, the event loops of separate RDataFrames run one after the other; 984histo1->Draw(); // runs first multi-thread event loop; 985histo2->Draw(); // runs second multi-thread event loop; 986 ; 987// alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; 988ROOT::RDF::RunGraphs({histo1, histo2});; 989histo1->Draw(); // results can then be used as usual; 990~~~; 991 ; 992### Performance considerations; 993 ; 994To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; 995For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; 996Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; 997should be preferred for performance-critical applications.; 998 ; 999Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; 1000See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case.; 1001 ; 1002Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; 1003before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs.; 1004 ; 1005Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental loggi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:56784,perform,performance-critical,56784,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['perform'],['performance-critical']
Performance,"x) is invalid.; NOTE: The projection lines is extended for the plane intersection test hence the intersection vertex can lie outside the near/far clip regions (not visible); Camera must have valid frustum cache - call Apply() after last modification, before using ; Definition at line 517 of file TGLCamera.cxx. ◆ ViewportRect() [1/2]. TGLRect TGLCamera::ViewportRect ; (; const TGLBoundingBox & ; box, . const TGLBoundingBox::EFace * ; face = nullptr . ); const. Calculate viewport rectangle which just contains projection of world frame bounding box 'box' onto the viewport. ; If face is null the rect contains the whole bounding box (8 vertices/6 faces). If face is non-null it indicates a box face, and the rect contains the single face (4 vertices). Note use other version of ViewportRect() if you wish to just pass a static EFace enum member (e.g. kFaceLowX); Note:; Rectangle is NOT clipped by viewport limits - so can result in rect with corners outside viewport - negative etc; TGLRect provides int (pixel based) values - not subpixel accurate; Camera must have valid frustum cache - call Apply() after last modification, before calling . Definition at line 351 of file TGLCamera.cxx. ◆ ViewportRect() [2/2]. TGLRect TGLCamera::ViewportRect ; (; const TGLBoundingBox & ; box, . TGLBoundingBox::EFace ; face . ); const. Calculate viewport rectangle which just contains projection of single 'face' of world frame bounding box 'box' onto the viewport. ; Note use other version of ViewportRect() if you want whole 'box' contained ; Definition at line 329 of file TGLCamera.cxx. ◆ ViewportToWorld() [1/3]. TGLVertex3 TGLCamera::ViewportToWorld ; (; const TGLVertex3 & ; viewportVertex, . TGLMatrix * ; modviewMat = nullptr . ); const. Convert a '3D' viewport vertex to 3D world one. ; The X()/Y() components of viewportVertex are the horizontal/vertical pixel position. ; Definition at line 442 of file TGLCamera.cxx. ◆ ViewportToWorld() [2/3]. TGLLine3 TGLCamera::ViewportToWorld ; (; const TPoi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLCamera.html:37046,cache,cache,37046,doc/master/classTGLCamera.html,https://root.cern,https://root.cern/doc/master/classTGLCamera.html,1,['cache'],['cache']
Performance,"x) override;  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetUnzipBufferSize (Long64_t bufferSize);  Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ;  ; void SetUnzipGroupSize (Int_t groupSize);  ; void StopLearningPhase () override;  It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t UnzipBuffer (char **dest, char *src);  Unzips a ROOT specific buffer... by reading the header at the beginning. ;  ; Int_t UnzipCache (Int_t index);  This inflates a basket in the cache. ;  ; void UpdateBranches (TTree *tree) override;  update pointer to current Tree and recompute pointers to the branches in the cache ;  ;  Public Member Functions inherited from TTreeCache;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCacheUnzip.html:4300,cache,cache,4300,doc/master/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/master/classTTreeCacheUnzip.html,2,['cache'],['cache']
Performance,"x); Perform basic pre-render initialization:; - calculate LOD, Style, Clipping,; - build draw lists. This is called in the beginning of the GL-viewer draw cycle. void PreRender(TGLRnrCtx& rnrCtx); Perform pre-render initialization - fill rnrCtx with; values stored during PreDraw(). This is called each time before RenderXyzz(). void Render(TGLRnrCtx& rnrCtx); This function does rendering of all stages, the shapes are; rendered in the following order: opaque, transparent,; selected-opaque, selected-transparent. GL-depth buffer is cleared after transparent shapes have been; rendered. This is never called from ROOT GL directly. Use it if you know; you are rendering a single scene. void RenderOpaque(TGLRnrCtx& rnrCtx); Render opaque elements. void RenderTransp(TGLRnrCtx& rnrCtx); Render transparent elements. void RenderSelOpaque(TGLRnrCtx& rnrCtx); Render selected opaque elements. void RenderSelTransp(TGLRnrCtx& rnrCtx); Render selected transparent elements. void PostRender(TGLRnrCtx& rnrCtx); Perform post-render clean-up. void PostDraw(TGLRnrCtx& rnrCtx); Finalize drawing. This is called at the end of the GL-viewer draw cycle. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. See implementation in sub-class TGLScene, here we just return FALSE. TGLSceneBase& operator=(const TGLSceneBase& ). const char * GetName() const; { return fName; }. const char * GetTitle() const; { return fTitle; }. void SetName(const char* name); { fName = name; }. void SetTitle(const char* title); { fTitle = title; }. void SetNameTitle(const char* name, const char* title); { SetName(name); SetTitle(title); }. TGLLogicalShape* FindLogical(TObject* ) const; { return 0; }. UInt_t GetTimeStamp() const; Getters & setters. { return fTimeStamp; }. void I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLSceneBase.html:6701,Perform,Perform,6701,root/html528/TGLSceneBase.html,https://root.cern,https://root.cern/root/html528/TGLSceneBase.html,3,['Perform'],['Perform']
Performance,"x, const RooArgSet* varList = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooConvCoefVar.html:24318,cache,cache,24318,root/html602/RooConvCoefVar.html,https://root.cern,https://root.cern/root/html602/RooConvCoefVar.html,2,['cache'],['cache']
Performance,x. ◆ CdDown() [1/2]. void TGeoNavigator::CdDown ; (; Int_t ; index). Make a daughter of current node current. ; Can be called only with a valid daughter index (no check). Updates cache accordingly. ; Definition at line 313 of file TGeoNavigator.cxx. ◆ CdDown() [2/2]. void TGeoNavigator::CdDown ; (; TGeoNode * ; node). Make a daughter of current node current. ; Can be called only with a valid daughter node (no check). Updates cache accordingly. ; Definition at line 333 of file TGeoNavigator.cxx. ◆ CdNext(). void TGeoNavigator::CdNext ; (; ). Do a cd to the node found next by FindNextBoundary. ; Definition at line 405 of file TGeoNavigator.cxx. ◆ CdNode(). void TGeoNavigator::CdNode ; (; Int_t ; nodeid). Change current path to point to the node having this id. ; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons) ; Definition at line 301 of file TGeoNavigator.cxx. ◆ CdTop(). void TGeoNavigator::CdTop ; (; ). Make top level node the current node. ; Updates the cache accordingly. Determine the overlapping state of current node. ; Definition at line 386 of file TGeoNavigator.cxx. ◆ CdUp(). void TGeoNavigator::CdUp ; (; ). Go one level up in geometry. ; Updates cache accordingly. Determine the overlapping state of current node. ; Definition at line 352 of file TGeoNavigator.cxx. ◆ CheckPath(). Bool_t TGeoNavigator::CheckPath ; (; const char * ; path); const. Check if a geometry path is valid without changing the state of the navigator. ; Definition at line 256 of file TGeoNavigator.cxx. ◆ Class(). static TClass * TGeoNavigator::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGeoNavigator::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGeoNavigator::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 282 of file TGeoNavigator.h. ◆ CrossBoundaryAndLocate(). TGeoNode * TGeoNavigator::CrossBoundaryAndLo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:24496,cache,cache,24496,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['cache'],['cache']
Performance,x. ◆ GetCachedBranches(). const TObjArray * TTreeCache::GetCachedBranches ; (; ); const. inline . Definition at line 139 of file TTreeCache.h. ◆ GetConfiguredPrefillType(). TTreeCache::EPrefillType TTreeCache::GetConfiguredPrefillType ; (; ); const. Return the desired prefill type from the environment or resource variable. . 0 - No prefill; 1 - All branches . Definition at line 1802 of file TTreeCache.cxx. ◆ GetEfficiency(). Double_t TTreeCache::GetEfficiency ; (; ); const. Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ; the number of blocks prefetched ( it could be more than 1 if we read the same block from the cache more than once ); Note: This should eb used at the end of the processing or we will get incomplete stats ; Definition at line 1825 of file TTreeCache.cxx. ◆ GetEfficiencyRel(). Double_t TTreeCache::GetEfficiencyRel ; (; ); const. This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ; Definition at line 1849 of file TTreeCache.cxx. ◆ GetEntryMax(). virtual Int_t TTreeCache::GetEntryMax ; (; ); const. inlinevirtual . Definition at line 144 of file TTreeCache.h. ◆ GetEntryMin(). virtual Int_t TTreeCache::GetEntryMin ; (; ); const. inlinevirtual . Definition at line 143 of file TTreeCache.h. ◆ GetLearnEntries(). Int_t TTreeCache::GetLearnEntries ; (; ). static . Static function returning the number of entries used to train the cache see SetLearnEntries. ; Definition at line 1874 of file TTreeCache.cxx. ◆ GetLearnPrefill(). virtual EPrefillType TTreeCache::GetLearnPrefill ; (; ); const. inlinevirtual . Definition at line 146 of file TTreeCache.h. ◆ GetMissEfficiency(). Double_t TTreeCache::GetMissEfficiency ; (; ); const. The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ; Definition at line 1837 of file TTreeCache.cxx. ◆ GetMissEfficiencyRel(). Doubl,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:40981,cache,cache,40981,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,2,['cache'],['cache']
Performance,"x. ◆ GetWarning(). const char * TTreeCloner::GetWarning ; (; ); const. inline . Definition at line 117 of file TTreeCloner.h. ◆ ImportClusterRanges(). void TTreeCloner::ImportClusterRanges ; (; ). private . Set the entries and import the cluster range of the. ; Definition at line 626 of file TTreeCloner.cxx. ◆ IsInPlace(). bool TTreeCloner::IsInPlace ; (; ); const. inline . Definition at line 118 of file TTreeCloner.h. ◆ IsValid(). bool TTreeCloner::IsValid ; (; ). inline . Definition at line 120 of file TTreeCloner.h. ◆ NeedConversion(). bool TTreeCloner::NeedConversion ; (; ). inline . Definition at line 121 of file TTreeCloner.h. ◆ operator=(). TTreeCloner & TTreeCloner::operator= ; (; const TTreeCloner & ; ). privatedelete . ◆ RestoreCache(). void TTreeCloner::RestoreCache ; (; ). private . Restore the TFileCacheRead to its previous value. ; Definition at line 615 of file TTreeCloner.cxx. ◆ SetCacheSize(). void TTreeCloner::SetCacheSize ; (; Long64_t ; size). Set the cache size used by the matching TFile. ; Note that the default is to use the same size as the default TTreeCache for the input tree. Parameters. sizeSize of the cache. . NoteIf size=0, or if it does not match the fileCache buffer size, the fileCache will be deleted so that it be created later with the right size (or not created if the size is 0) at the beginning of Exec. ; Definition at line 656 of file TTreeCloner.cxx. ◆ SortBaskets(). void TTreeCloner::SortBaskets ; (; ). Sort the basket according to the user request. ; Definition at line 674 of file TTreeCloner.cxx. ◆ WriteBaskets(). void TTreeCloner::WriteBaskets ; (; ). Transfer the basket from the input file to the output file. ; Definition at line 729 of file TTreeCloner.cxx. Friends And Related Symbol Documentation. ◆ CompareEntry. friend class CompareEntry. friend . Definition at line 84 of file TTreeCloner.h. ◆ CompareSeek. friend class CompareSeek. friend . Definition at line 83 of file TTreeCloner.h. Member Data Documentation. ◆ fBasketBr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCloner.html:11427,cache,cache,11427,doc/master/classTTreeCloner.html,https://root.cern,https://root.cern/doc/master/classTTreeCloner.html,1,['cache'],['cache']
Performance,"x.h. ◆ GetSize(). virtual Int_t TFFTRealComplex::GetSize ; (; ); const. inlinevirtual . Definition at line 40 of file TFFTRealComplex.h. ◆ GetTransformFlag(). Option_t * TFFTRealComplex::GetTransformFlag ; (; ); const. inlineoverridevirtual . Implements TVirtualFFT.; Definition at line 45 of file TFFTRealComplex.h. ◆ GetType(). Option_t * TFFTRealComplex::GetType ; (; ); const. inlineoverridevirtual . Implements TVirtualFFT.; Definition at line 43 of file TFFTRealComplex.h. ◆ Init(). void TFFTRealComplex::Init ; (; Option_t * ; flags, . Int_t ; , . const Int_t * ;  . ). overridevirtual . Creates the fftw-plan. ; NOTE: input and output arrays are overwritten during initialisation, so don't set any points, before running this function!!!!!; Arguments sign and kind are dummy and not need to be specified Possible flag_options:. ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal performance; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found. This option should be chosen depending on how many transforms of the same size and type are going to be done. Planning is only done once, for the first transform of this size and type. ; Implements TVirtualFFT.; Definition at line 152 of file TFFTRealComplex.cxx. ◆ IsA(). TClass * TFFTRealComplex::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 64 of file TFFTRealComplex.h. ◆ IsInplace(). Bool_t TFFTRealComplex::IsInplace ; (; ); const. inlineoverridevirtual . Implements TVirtualFFT.; Definition at line 46 of file TFFTRealComplex.h. ◆ MapFlag(). UInt_t TFFTRealComplex::MapFlag ; (; Option_t * ; flag). protected . allowed options: ""ES"" ""M"" ""P"" ""EX"" ; Definition at line 489 of file TFFTRealComplex.cxx. ◆ SetPoint() [1/2]. void TFFTRealComple",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFFTRealComplex.html:21801,perform,performance,21801,doc/master/classTFFTRealComplex.html,https://root.cern,https://root.cern/doc/master/classTFFTRealComplex.html,1,['perform'],['performance']
Performance,"x:101; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Double_tdouble Double_tDefinition RtypesCore.h:59; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::DataLoader::AddSpectatorvoid AddSpectator(const TString &expression, const TString &title="""", const TString &unit="""", Double_t min=0, Double_t max=0)user inserts target in data set infoDefinition DataLoader.cxx:524; TMVA::DataLoader::SetBackgroundWeightExpressionvoid SetBackgroundWeightExpression(const TString &variable)Definition DataLoader.cxx:556; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::Envelope::BookMethodvirtual void BookMethod(TString methodname, TString methodtitle, TString options="""")Method to book the machine learning method to perform the algorithm.Definition Envelope.cxx:163; TMVA::Exper",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Classification.html:4298,cache,cacheDir,4298,doc/master/classTMVA_1_1Classification.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Classification.html,2,['cache'],"['cache', 'cacheDir']"
Performance,"x:1025; TROOT::RootVersionCodestatic Int_t RootVersionCode()Return ROOT version code as defined in RVersion.h.Definition TROOT.cxx:2941; TROOT::FindSpecialObjectTObject * FindSpecialObject(const char *name, void *&where)Returns address and folder of a ROOT object if it exists.Definition TROOT.cxx:1367; TROOT::RemoveTObject * Remove(TObject *) overrideRemove an object from the in-memory list.Definition TROOT.cxx:2618; TROOT::InitSystemvoid InitSystem()Operating System interface.Definition TROOT.cxx:1978; TROOT::ProcessLineFastLongptr_t ProcessLineFast(const char *line, Int_t *error=nullptr)Process interpreter command directly via CINT interpreter.Definition TROOT.cxx:2407; TROOT::ClassSavedBool_t ClassSaved(TClass *cl)return class status 'ClassSaved' for class cl This function is called by the SavePrimitive functions ...Definition TROOT.cxx:1083; TROOT::fGitBranchTString fGitBranchGit branch.Definition TROOT.h:121; TROOT::GetListOfTypesTCollection * GetListOfTypes(Bool_t load=kFALSE)Return a dynamic list giving access to all TDataTypes (typedefs) currently defined.Definition TROOT.cxx:1865; TROOT::fgDirLevelstatic Int_t fgDirLevelIndentation level for ls()Definition TROOT.h:102; TROOT::IsRootFileBool_t IsRootFile(const char *filename) constReturn true if the file is local and is (likely) to be a ROOT file.Definition TROOT.cxx:2230; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2891; TROOT::GetDocDirstatic const TString & GetDocDir()Get the documentation directory in the installation. Static utility function.Definition TROOT.cxx:3078; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3052; TROOT::GetNclassesInt_t GetNclasses() constGet number of classes.Definition TROOT.cxx:1876; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject inter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:159415,load,load,159415,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,1,['load'],['load']
Performance,"x:1025; TROOT::RootVersionCodestatic Int_t RootVersionCode()Return ROOT version code as defined in RVersion.h.Definition TROOT.cxx:2945; TROOT::FindSpecialObjectTObject * FindSpecialObject(const char *name, void *&where)Returns address and folder of a ROOT object if it exists.Definition TROOT.cxx:1367; TROOT::RemoveTObject * Remove(TObject *) overrideRemove an object from the in-memory list.Definition TROOT.cxx:2618; TROOT::InitSystemvoid InitSystem()Operating System interface.Definition TROOT.cxx:1978; TROOT::ProcessLineFastLongptr_t ProcessLineFast(const char *line, Int_t *error=nullptr)Process interpreter command directly via CINT interpreter.Definition TROOT.cxx:2407; TROOT::ClassSavedBool_t ClassSaved(TClass *cl)return class status 'ClassSaved' for class cl This function is called by the SavePrimitive functions ...Definition TROOT.cxx:1083; TROOT::fGitBranchTString fGitBranchGit branch.Definition TROOT.h:121; TROOT::GetListOfTypesTCollection * GetListOfTypes(Bool_t load=kFALSE)Return a dynamic list giving access to all TDataTypes (typedefs) currently defined.Definition TROOT.cxx:1865; TROOT::fgDirLevelstatic Int_t fgDirLevelIndentation level for ls()Definition TROOT.h:102; TROOT::IsRootFileBool_t IsRootFile(const char *filename) constReturn true if the file is local and is (likely) to be a ROOT file.Definition TROOT.cxx:2230; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TROOT::GetDocDirstatic const TString & GetDocDir()Get the documentation directory in the installation. Static utility function.Definition TROOT.cxx:3082; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetNclassesInt_t GetNclasses() constGet number of classes.Definition TROOT.cxx:1876; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject inter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:159591,load,load,159591,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['load'],['load']
Performance,"x:1313; TROOT::fClassesTCollection * fClassesList of classes definition.Definition TROOT.h:140; TROOT::SetInterruptvoid SetInterrupt(Bool_t flag=kTRUE)Definition TROOT.h:326; TROOT::fEditHistogramsBool_t fEditHistogramsTrue if histograms can be edited with the mouse.Definition TROOT.h:130; TROOT::fGlobalsTListOfDataMembers * fGlobalsList of global variables.Definition TROOT.h:143; TROOT::fFuncTemplateTListOfFunctionTemplates * fFuncTemplateList of global function templates.Definition TROOT.h:142; TROOT::GetClipboardTSeqCollection * GetClipboard() constDefinition TROOT.h:254; TROOT::fTimerInt_t fTimerTimer flag.Definition TROOT.h:123; TROOT::fDataSetsTSeqCollection * fDataSetsList of data sets (TDSet or TChain)Definition TROOT.h:164; TROOT::fConfigOptionsTString fConfigOptionsROOT ./configure set build options.Definition TROOT.h:111; TROOT::GetStyleTStyle * GetStyle(const char *name) constReturn pointer to style with name.Definition TROOT.cxx:1579; TROOT::GetListOfEnumsTCollection * GetListOfEnums(Bool_t load=kFALSE)Definition TROOT.cxx:1754; TROOT::ProcessLineSyncLongptr_t ProcessLineSync(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2390; TROOT::InitInterpretervoid InitInterpreter()Initialize interpreter (cling)Definition TROOT.cxx:2064; TROOT::GetListOfGlobalsTCollection * GetListOfGlobals(Bool_t load=kFALSE)Return list containing the TGlobals currently defined.Definition TROOT.cxx:1788; TROOT::GetSelectedPadTVirtualPad * GetSelectedPad() constDefinition TROOT.h:271; TROOT::SetDirLevelstatic void SetDirLevel(Int_t level=0)Return Indentation level for ls().Definition TROOT.cxx:2914; TROOT::fSecContextsTSeqCollection * fSecContextsList of security contexts (TSecContext)Definition TROOT.h:161; TROOT::fWebDisplayTString fWebDisplayIf not empty it defines where web graphics should be rendered (cef, qt5, browser.....Definition TROOT.h:127; TROOT::GetTutorialsDirstatic const char * GetTutorialsDir(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8h_source.html:36962,load,load,36962,doc/v632/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8h_source.html,1,['load'],['load']
Performance,"x:1313; TROOT::fClassesTCollection * fClassesList of classes definition.Definition TROOT.h:140; TROOT::SetInterruptvoid SetInterrupt(Bool_t flag=kTRUE)Definition TROOT.h:326; TROOT::fEditHistogramsBool_t fEditHistogramsTrue if histograms can be edited with the mouse.Definition TROOT.h:130; TROOT::fGlobalsTListOfDataMembers * fGlobalsList of global variables.Definition TROOT.h:143; TROOT::fFuncTemplateTListOfFunctionTemplates * fFuncTemplateList of global function templates.Definition TROOT.h:142; TROOT::GetClipboardTSeqCollection * GetClipboard() constDefinition TROOT.h:254; TROOT::fTimerInt_t fTimerTimer flag.Definition TROOT.h:123; TROOT::fDataSetsTSeqCollection * fDataSetsList of data sets (TDSet or TChain)Definition TROOT.h:164; TROOT::fConfigOptionsTString fConfigOptionsROOT ./configure set build options.Definition TROOT.h:111; TROOT::GetStyleTStyle * GetStyle(const char *name) constReturn pointer to style with name.Definition TROOT.cxx:1579; TROOT::GetListOfEnumsTCollection * GetListOfEnums(Bool_t load=kFALSE)Definition TROOT.cxx:1754; TROOT::ProcessLineSyncLongptr_t ProcessLineSync(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2390; TROOT::InitInterpretervoid InitInterpreter()Initialize interpreter (cling)Definition TROOT.cxx:2064; TROOT::GetListOfGlobalsTCollection * GetListOfGlobals(Bool_t load=kFALSE)Return list containing the TGlobals currently defined.Definition TROOT.cxx:1788; TROOT::GetSelectedPadTVirtualPad * GetSelectedPad() constDefinition TROOT.h:271; TROOT::SetDirLevelstatic void SetDirLevel(Int_t level=0)Return Indentation level for ls().Definition TROOT.cxx:2918; TROOT::fSecContextsTSeqCollection * fSecContextsList of security contexts (TSecContext)Definition TROOT.h:161; TROOT::fWebDisplayTString fWebDisplayIf not empty it defines where web graphics should be rendered (cef, qt5, browser.....Definition TROOT.h:127; TROOT::GetTutorialsDirstatic const char * GetTutorialsDir(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:36961,load,load,36961,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,1,['load'],['load']
Performance,"x:2217; TMVA::Factory::GetROCIntegralDouble_t GetROCIntegral(DataLoader *loader, TString theMethodName, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)Calculate the integral of the ROC curve, also known as the area under curve (AUC),...Definition Factory.cxx:849; TMVA::Factory::~Factoryvirtual ~Factory()Destructor.Definition Factory.cxx:306; TMVA::Factory::MakeClassvirtual void MakeClass(const TString &datasetname, const TString &methodTitle="""") constDefinition Factory.cxx:1305; TMVA::Factory::BookMethodWeightfileMethodBase * BookMethodWeightfile(DataLoader *dataloader, TMVA::Types::EMVA methodType, const TString &weightfile)Adds an already constructed method to be managed by this factory.Definition Factory.cxx:501; TMVA::Factory::fModelPersistenceBool_t fModelPersistence! option to save the trained model in xml file or using serializationDefinition Factory.h:222; TMVA::Factory::OptimizeAllMethodsstd::map< TString, Double_t > OptimizeAllMethods(TString fomType=""ROCIntegral"", TString fitType=""FitGA"")Iterates through all booked methods and sees if they use parameter tuning and if so does just that,...Definition Factory.cxx:701; TMVA::Factory::GetROCROCCurve * GetROC(DataLoader *loader, TString theMethodName, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)Private method to generate a ROCCurve instance for a given method.Definition Factory.cxx:749; TMVA::Factory::EvaluateImportanceShortTH1F * EvaluateImportanceShort(DataLoader *loader, Types::EMVA theMethod, TString methodTitle, const char *theOption="""")Definition Factory.cxx:2358; TMVA::Factory::fAnalysisTypeTypes::EAnalysisType fAnalysisType! the training typeDefinition Factory.h:221; TMVA::Factory::HasMethodBool_t HasMethod(const TString &datasetname, const TString &title) constChecks whether a given method name is defined for a given dataset.Definition Factory.cxx:586; TMVA::Factory::GetROCCurveTGraph * GetROCCurve(DataLoader *loader, TString theMethodName, Bool_t setTitles=kTRUE, UInt_t iClass=0, Ty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:123646,Optimiz,OptimizeAllMethodsstd,123646,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,2,['Optimiz'],"['OptimizeAllMethods', 'OptimizeAllMethodsstd']"
Performance,"x:36; ROOT::Internal::RConcurrentHashCollThis class is a thread-safe associative collection connecting a 256 bits digest/hash to a collection ...Definition RConcurrentHashColl.hxx:30; TArchiveFileClass describing an archive file containing multiple sub-files, like a ZIP or TAR archive.Definition TArchiveFile.h:24; TArrayCArray of chars or bytes (8 bits per element).Definition TArrayC.h:27; TBasketManages buffers for branches of a Tree.Definition TBasket.h:34; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDirectoryFileA ROOT file is structured in Directories (like a file system).Definition TDirectoryFile.h:32; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileCacheReadA cache when reading files over the network.Definition TFileCacheRead.h:22; TFileCacheWriteA cache when writing files over the network.Definition TFileCacheWrite.h:19; TFileOpenHandleClass holding info about the file being opened.Definition TFile.h:354; TFileOpenHandle::fFileTFile * fFileTFile instance of the file being opened.Definition TFile.h:362; TFileOpenHandle::fNetOptInt_t fNetOptNetwork options.Definition TFile.h:361; TFileOpenHandle::TFileOpenHandleTFileOpenHandle(TFile *f)Definition TFile.h:364; TFileOpenHandle::fOptTString fOptOptions.Definition TFile.h:359; TFileOpenHandle::TFileOpenHandleTFileOpenHandle(const char *n, const char *o, const char *t, Int_t cmp, Int_t no)Definition TFile.h:366; TFileOpenHandle::GetNetOptInt_t GetNetOpt() constDefinition TFile.h:381; TFileOpenHandle::operator=TFileOpenHandle & operator=(const TFileOpenHandle &)=delete; TFileOpenHandle::GetFileTFile * GetFile() constDefinition TFile.h:372; TFileOpenHandle::fCompressInt_t fCompressCompression level and algorithm.Definition TFile.h:360; TFileOpenHandle::GetOptconst char * GetOpt() constDefinition T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:24527,cache,cache,24527,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['cache'],['cache']
Performance,"x:789; TGeoManager::GetTrackOfIdTVirtualGeoTrack * GetTrackOfId(Int_t id) constGet track with a given ID.Definition TGeoManager.cxx:2200; TGeoManager::FindDuplicateMaterialTGeoMaterial * FindDuplicateMaterial(const TGeoMaterial *mat) constFind if a given material duplicates an existing one.Definition TGeoManager.cxx:2992; TGeoManager::DivisionTGeoVolume * Division(const char *name, const char *mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed=0, Option_t *option="""")Create a new volume by dividing an existing one (GEANT3 like)Definition TGeoManager.cxx:1258; TGeoManager::VolumeTGeoVolume * Volume(const char *name, const char *shape, Int_t nmed, Float_t *upar, Int_t npar=0)Create a volume in GEANT3 style.Definition TGeoManager.cxx:1388; TGeoManager::ReplaceVolumeInt_t ReplaceVolume(TGeoVolume *vorig, TGeoVolume *vnew)Replaces all occurrences of VORIG with VNEW in the geometry tree.Definition TGeoManager.cxx:1125; TGeoManager::DoRestoreStatevoid DoRestoreState()Restore a backed-up state without affecting the cache stack.Definition TGeoManager.cxx:1106; TGeoManager::GetCurrentNodeIdInt_t GetCurrentNodeId() constGet the unique ID of the current node.Definition TGeoManager.cxx:1663; TGeoManager::GetAlignableEntryTGeoPNEntry * GetAlignableEntry(const char *name) constRetrieves an existing alignable object.Definition TGeoManager.cxx:3370; TGeoManager::fMasterVolumeTGeoVolume * fMasterVolumetop physical nodeDefinition TGeoManager.h:127; TGeoManager::FindTrackWithIdTVirtualGeoTrack * FindTrackWithId(Int_t id) constSearch the track hierarchy to find the track with the given id.Definition TGeoManager.cxx:2180; TGeoManager::fArrayPNETObjArray * fArrayPNEDefinition TGeoManager.h:139; TGeoManager::TestOverlapsvoid TestOverlaps(const char *path="""")Geometry overlap checker based on sampling.Definition TGeoManager.cxx:1950; TGeoManager::GetDefaultUnitsstatic EDefaultUnits GetDefaultUnits()Definition TGeoManager.cxx:4314; TGeoManager::RemoveMaterialvoid Remov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:178910,cache,cache,178910,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['cache'],['cache']
Performance,x::PrivateClass ; Reflex::PrivateEnum ; Reflex::PrivateStruct ; Reflex::PrivateUnion ; Reflex::ProtectedClass ; Reflex::ProtectedEnum ; Reflex::ProtectedStruct ; Reflex::ProtectedUnion ; Reflex::RuntimeError ; Reflex::Scope ; Reflex::Selection::AUTOSELECT ; Reflex::Selection::NODEFAULT ; Reflex::Selection::NO_SELF_AUTOSELECT ; Reflex::Selection::TRANSIENT ; Reflex::Tools ; Reflex::Type ; Reflex::TypeTemplate ; Reflex::TypedefBuilderImpl ; Reflex::UnionBuilderImpl ; Reflex::UnknownType ; Reflex::UnnamedClass ; Reflex::UnnamedEnum ; Reflex::UnnamedNamespace ; Reflex::UnnamedStruct ; Reflex::UnnamedUnion ; Reflex::VariableBuilder ; Reflex::VariableBuilderImpl ; Rgl ; Roo1DMomentMorphFunction Your description goes here...; Roo1DTable 1-dimensional table; Roo2DKeysPdf Two-dimensional kernel estimation p.d.f.; Roo2DMomentMorphFunction ; RooAICRegistry Registry for analytical integration codes; RooAbsAnaConvPdf Abstract Composite Convoluted PDF; RooAbsArg Abstract variable; RooAbsBinning Abstract base class for binning specification; RooAbsCache Base class for cache managers ; RooAbsCacheElement Base class for cache elements; RooAbsCachedPdf Abstract base class for cached p.d.f.s; RooAbsCachedReal Abstract base class for cached p.d.f.s; RooAbsCategory Abstract discrete variable; RooAbsCategoryLValue Abstract modifiable index variable ; RooAbsCollection Collection of RooAbsArg objects; RooAbsData Abstract data collection; RooAbsDataStore Abstract Data Storage class; RooAbsFunc Abstract real-valued function interface; RooAbsGenContext Abstract context for generating a dataset from a PDF; RooAbsHiddenReal Abstract hidden real-valued variable; RooAbsIntegrator Abstract interface for real-valued function integrators; RooAbsLValue Abstract variable; RooAbsMCStudyModule Monte Carlo study manager add-on module; RooAbsMoment Abstract representation of moment in a RooAbsReal in a given RooRealVar; RooAbsNumGenerator Abstract base class for numeric event generator algorithms; RooAbsO,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:25206,cache,cache,25206,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,3,['cache'],"['cache', 'cached']"
Performance,x::PrivateClass ; Reflex::PrivateEnum ; Reflex::PrivateStruct ; Reflex::PrivateUnion ; Reflex::ProtectedClass ; Reflex::ProtectedEnum ; Reflex::ProtectedStruct ; Reflex::ProtectedUnion ; Reflex::RuntimeError ; Reflex::Scope ; Reflex::Selection::AUTOSELECT ; Reflex::Selection::NODEFAULT ; Reflex::Selection::NO_SELF_AUTOSELECT ; Reflex::Selection::TRANSIENT ; Reflex::Tools ; Reflex::Type ; Reflex::TypeTemplate ; Reflex::TypedefBuilderImpl ; Reflex::UnionBuilderImpl ; Reflex::UnknownType ; Reflex::UnnamedClass ; Reflex::UnnamedEnum ; Reflex::UnnamedNamespace ; Reflex::UnnamedStruct ; Reflex::UnnamedUnion ; Reflex::VariableBuilder ; Reflex::VariableBuilderImpl ; Rgl ; Roo1DMomentMorphFunction Your description goes here...; Roo1DTable 1-dimensional table; Roo2DKeysPdf Two-dimensional kernel estimation p.d.f.; Roo2DMomentMorphFunction ; RooAICRegistry Registry for analytical integration codes; RooAbsAnaConvPdf Abstract Composite Convoluted PDF; RooAbsArg Abstract variable; RooAbsBinning Abstract base class for binning specification; RooAbsCache Base class for cache managers ; RooAbsCacheElement Base class for cache elements; RooAbsCachedPdf Abstract base class for cached p.d.f.s; RooAbsCachedReal Abstract base class for cached p.d.f.s; RooAbsCategory Abstract discrete variable; RooAbsCategoryLValue Abstract modifiable index variable ; RooAbsCollection Collection of RooAbsArg objects; RooAbsData Abstract data collection; RooAbsDataStore Abstract Data Storage class; RooAbsFunc Abstract real-valued function interface; RooAbsGenContext Abstract context for generating a dataset from a PDF; RooAbsHiddenReal Abstract hidden real-valued variable; RooAbsIntegrator Abstract interface for real-valued function integrators; RooAbsLValue Abstract variable; RooAbsMCStudyModule Monte Carlo study manager add-on module; RooAbsNumGenerator Abstract base class for numeric event generator algorithms; RooAbsOptTestStatistic Abstract base class for optimized test statistics; RooAbsPdf Abstract ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:24874,cache,cache,24874,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,3,['cache'],"['cache', 'cached']"
Performance,"x; TUrl.h; ROOT::Internal::RConcurrentHashColl::HashValueDefinition RConcurrentHashColl.hxx:36; ROOT::Internal::RConcurrentHashCollThis class is a thread-safe associative collection connecting a 256 bits digest/hash to a collection ...Definition RConcurrentHashColl.hxx:30; TArchiveFileClass describing an archive file containing multiple sub-files, like a ZIP or TAR archive.Definition TArchiveFile.h:24; TArrayCArray of chars or bytes (8 bits per element).Definition TArrayC.h:27; TBasketManages buffers for branches of a Tree.Definition TBasket.h:34; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDirectoryFileA ROOT file is structured in Directories (like a file system).Definition TDirectoryFile.h:32; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileCacheReadA cache when reading files over the network.Definition TFileCacheRead.h:22; TFileCacheWriteA cache when writing files over the network.Definition TFileCacheWrite.h:19; TFileOpenHandleClass holding info about the file being opened.Definition TFile.h:354; TFileOpenHandle::fFileTFile * fFileTFile instance of the file being opened.Definition TFile.h:362; TFileOpenHandle::fNetOptInt_t fNetOptNetwork options.Definition TFile.h:361; TFileOpenHandle::TFileOpenHandleTFileOpenHandle(TFile *f)Definition TFile.h:364; TFileOpenHandle::fOptTString fOptOptions.Definition TFile.h:359; TFileOpenHandle::TFileOpenHandleTFileOpenHandle(const char *n, const char *o, const char *t, Int_t cmp, Int_t no)Definition TFile.h:366; TFileOpenHandle::GetNetOptInt_t GetNetOpt() constDefinition TFile.h:381; TFileOpenHandle::operator=TFileOpenHandle & operator=(const TFileOpenHandle &)=delete; TFileOpenHandle::GetFileTFile * GetFile() constDefinition TFile.h:372; TFileOpenHandle::fCompressInt_t fCompressCompression level and algor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:24436,cache,cache,24436,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['cache'],['cache']
Performance,"x<Double_t> z = faddeeva(std::complex<Double_t>(zz.re(), zz.im())); return RooComplex(z.real(), z.imag()); }. RooComplex ComplexErrFuncFast(const RooComplex& zz); deprecated function. { warn(__my_func__, ""RooMath::faddeeva_fast""); std::complex<Double_t> z = faddeeva_fast(std::complex<Double_t>(zz.re(), zz.im())); return RooComplex(z.real(), z.imag()); }. Double_t ComplexErrFuncFastRe(const RooComplex& zz); deprecated function. { warn(__my_func__, ""RooMath::faddeeva_fast""); std::complex<Double_t> z = faddeeva_fast(std::complex<Double_t>(zz.re(), zz.im())); return z.real(); }. Double_t ComplexErrFuncFastIm(const RooComplex& zz); deprecated function. { warn(__my_func__, ""RooMath::faddeeva_fast""); std::complex<Double_t> z = faddeeva_fast(std::complex<Double_t>(zz.re(), zz.im())); return z.imag(); }. RooComplex ITPComplexErrFuncFast(const RooComplex& zz, Int_t ); deprecated function. { warn(__my_func__, ""RooMath::faddeeva_fast""); std::complex<Double_t> z = faddeeva_fast(std::complex<Double_t>(zz.re(), zz.im())); return RooComplex(z.real(), z.imag()); }. Double_t ITPComplexErrFuncFastRe(const RooComplex& zz, Int_t ); deprecated function. { warn(__my_func__, ""RooMath::faddeeva_fast""); std::complex<Double_t> z = faddeeva_fast(std::complex<Double_t>(zz.re(), zz.im())); return z.real(); }. Double_t ITPComplexErrFuncFastIm(const RooComplex& zz, Int_t ); deprecated function. { warn(__my_func__, ""RooMath::faddeeva_fast""); std::complex<Double_t> z = faddeeva_fast(std::complex<Double_t>(zz.re(), zz.im())); return z.imag(); }. void cacheCERF(Bool_t ); deprecated function. { warn(__my_func__); }. void cleanup(); deprecated function. { warn(__my_func__); }. void initFastCERF(Int_t , Double_t , Double_t , Int_t , Double_t , Double_t ); deprecated function. » Last changed: Tue Mar 10 17:17:49 2015 » Last generated: 2015-03-10 17:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMath.html:4891,cache,cacheCERF,4891,root/html534/RooMath.html,https://root.cern,https://root.cern/root/html534/RooMath.html,1,['cache'],['cacheCERF']
Performance,"xEntryLoop = 1000000000;; 898 fMaxEntryLoop *= 1000;; 899 ; 900 // Insert ourself into the current directory.; 901 // FIXME: This is very annoying behaviour, we should; 902 // be able to choose to not do this like we; 903 // can with a histogram.; 904 if (fDirectory) fDirectory->Append(this);; 905 ; 906 fBranches.SetOwner(true);; 907 ; 908 // If title starts with ""/"" and is a valid folder name, a superbranch; 909 // is created.; 910 // FIXME: Why?; 911 if (strlen(title) > 2) {; 912 if (title[0] == '/') {; 913 Branch(title+1,32000,splitlevel);; 914 }; 915 }; 916}; 917 ; 918////////////////////////////////////////////////////////////////////////////////; 919/// Destructor.; 920 ; 921TTree::~TTree(); 922{; 923 if (auto link = dynamic_cast<TNotifyLinkBase*>(fNotify)) {; 924 link->Clear();; 925 }; 926 if (fAllocationCount && (gDebug > 0)) {; 927 Info(""TTree::~TTree"", ""For tree %s, allocation count is %u."", GetName(), fAllocationCount.load());; 928#ifdef R__TRACK_BASKET_ALLOC_TIME; 929 Info(""TTree::~TTree"", ""For tree %s, allocation time is %lluus."", GetName(), fAllocationTime.load());; 930#endif; 931 }; 932 ; 933 if (fDirectory) {; 934 // We are in a directory, which may possibly be a file.; 935 if (fDirectory->GetList()) {; 936 // Remove us from the directory listing.; 937 fDirectory->Remove(this);; 938 }; 939 //delete the file cache if it points to this Tree; 940 TFile *file = fDirectory->GetFile();; 941 MoveReadCache(file,nullptr);; 942 }; 943 ; 944 // Remove the TTree from any list (linked to to the list of Cleanups) to avoid the unnecessary call to; 945 // this RecursiveRemove while we delete our content.; 946 ROOT::CallRecursiveRemoveIfNeeded(*this);; 947 ResetBit(kMustCleanup); // Don't redo it.; 948 ; 949 // We don't own the leaves in fLeaves, the branches do.; 950 fLeaves.Clear();; 951 // I'm ready to destroy any objects allocated by; 952 // SetAddress() by my branches. If I have clones,; 953 // tell them to zero their pointers to this shared; 954 // memory.; 955",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:33483,load,load,33483,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['load'],['load']
Performance,"xample,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. NOTE: the action specifies how to behave when detaching a cache from the; the TFile. If set to (default) kDisconnect, the contents of the cache; will be flushed when it is removed from the file, and it will disconnect; the cache object from the file. In almost all cases, this is what you want.; If you want to disconnect the cache temporarily from this tree and re-attach; later to the same fil, you can set action to kDoNotDisconnect. This will allow; things like prefetching to continue in the background while it is no longer the; default cache for the TTree. Except for a few expert use cases, kDisconnect is; likely the correct setting. WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& ); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFile.html:40928,cache,cache,40928,root/html602/TFile.html,https://root.cern,https://root.cern/root/html602/TFile.html,4,['cache'],['cache']
Performance,"xample,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. NOTE: the action specifies how to behave when detaching a cache from the; the TFile. If set to (default) kDisconnect, the contents of the cache; will be flushed when it is removed from the file, and it will disconnect; the cache object from the file. In almost all cases, this is what you want.; If you want to disconnect the cache temporarily from this tree and re-attach; later to the same fil, you can set action to kDoNotDisconnect. This will allow; things like prefetching to continue in the background while it is no longer the; default cache for the TTree. Except for a few expert use cases, kDisconnect is; likely the correct setting. WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& ); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibilit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFile.html:40099,cache,cache,40099,root/html534/TFile.html,https://root.cern,https://root.cern/root/html534/TFile.html,2,['cache'],['cache']
Performance,"xec(), ExecScript(), and Eval(),; 221 // which should not be called after __main__ is garbage collected anyway.; 222 }; 223 }; 224 ; 225 // python side class construction, managed by ROOT; 226 gROOT->AddClassGenerator(new TPyClassGenerator);; 227 ; 228 // declare success ...; 229 isInitialized = kTRUE;; 230 return kTRUE;; 231}; 232 ; 233////////////////////////////////////////////////////////////////////////////////; 234/// Import the named python module and create Cling equivalents for its classes; 235/// and methods.; 236 ; 237Bool_t TPython::Import(const char *mod_name); 238{; 239 // setup; 240 if (!Initialize()); 241 return false;; 242 ; 243 PyGILRAII gilRaii;; 244 ; 245 if (!CPyCppyy::Import(mod_name)) {; 246 return false;; 247 }; 248 ; 249 // force creation of the module as a namespace; 250 TClass::GetClass(mod_name, kTRUE);; 251 ; 252 PyObject *modNameObj = PyUnicode_FromString(mod_name);; 253 PyObject *mod = PyImport_GetModule(modNameObj);; 254 PyObject *dct = PyModule_GetDict(mod);; 255 ; 256 CachedPyString basesStr{""__bases__""};; 257 CachedPyString cppNameStr{""__cpp_name__""};; 258 CachedPyString nameStr{""__name__""};; 259 ; 260 // create Cling classes for all new python classes; 261 PyObject *values = PyDict_Values(dct);; 262 for (int i = 0; i < PyList_GET_SIZE(values); ++i) {; 263 PyObject *value = PyList_GET_ITEM(values, i);; 264 Py_INCREF(value);; 265 ; 266 // collect classes; 267 if (PyType_Check(value) || PyObject_HasAttr(value, basesStr.obj())) {; 268 // get full class name (including module); 269 PyObject *pyClName = PyObject_GetAttr(value, cppNameStr.obj());; 270 if (!pyClName) {; 271 pyClName = PyObject_GetAttr(value, nameStr.obj());; 272 }; 273 ; 274 if (PyErr_Occurred()); 275 PyErr_Clear();; 276 ; 277 // build full, qualified name; 278 std::string fullname = mod_name;; 279 fullname += ""."";; 280 fullname += PyUnicode_AsUTF8(pyClName);; 281 ; 282 // force class creation (this will eventually call TPyClassGenerator); 283 TClass::GetClass(fullname.c_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPython_8cxx_source.html:8637,Cache,CachedPyString,8637,doc/master/TPython_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html,3,['Cache'],['CachedPyString']
Performance,"xecuteCommand(command.Data());; 2005 ExecuteCommand(""tv__tree_file->ls();"");; 2006 std::cout << ""Use SetTreeName() from context menu and supply a tree name"" << std::endl;; 2007 std::cout << ""The context menu is activated by right-clicking the panel from right"" << std::endl;; 2008 }; 2009 break;; 2010 case kFileLoadLibrary:; 2011 fBarCommand->SetText(""gSystem->Load(\""\"");"");; 2012 if (true) {; 2013 Event_t event;; 2014 event.fType = kButtonPress;; 2015 event.fCode = kButton1;; 2016 event.fX = event.fY = 1;; 2017 fBarCommand->HandleButton(&event);; 2018 }; 2019 fBarCommand->SetCursorPosition(15);; 2020 break;; 2021 case kFileOpenSession:; 2022 if (true) {; 2023 static TString dir(""."");; 2024 TGFileInfo info;; 2025 info.fFileTypes = gMacroTypes;; 2026 info.SetIniDir(dir);; 2027 new TGFileDialog(fClient->GetRoot(), this, kFDOpen, &info);; 2028 if (!info.fFilename) return true;; 2029 dir = info.fIniDir;; 2030 gInterpreter->Reset();; 2031 if (!gInterpreter->IsLoaded(info.fFilename)) gInterpreter->LoadMacro(info.fFilename);; 2032 char command[1024];; 2033 command[0] = 0;; 2034 snprintf(command,1024,""open_session((void*)0x%zx);"", (size_t)this);; 2035 ExecuteCommand(command);; 2036 }; 2037 break;; 2038 case kFileSaveMacro:; 2039 fContextMenu->Action(this,(TMethod*)IsA()->GetListOfMethods()->FindObject(""SaveSource""));; 2040 break;; 2041 case kFilePrint:; 2042 break;; 2043 case kFileClose:; 2044 SendCloseMessage();; 2045 break;; 2046 case kFileQuit:; 2047 gApplication->Terminate(0);; 2048 break;; 2049 case kEditExpression:; 2050 EditExpression();; 2051 break;; 2052 case kEditCut:; 2053 EditExpression();; 2054 break;; 2055 case kEditMacro:; 2056 break;; 2057 case kEditEvent:; 2058 break;; 2059 case kRunMacro:; 2060 break;; 2061 case kHelpAbout:; 2062 {; 2063#ifdef R__UNIX; 2064 TString rootx = TROOT::GetBinDir() + ""/root -a &"";; 2065 gSystem->Exec(rootx);; 2066#else; 2067#ifdef WIN32; 2068 new TWin32SplashThread(true);; 2069#else; 2070 char str[32];; 2071 snprintf(str,32, ""About",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeViewer_8cxx_source.html:73329,Load,LoadMacro,73329,doc/master/TTreeViewer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html,1,['Load'],['LoadMacro']
Performance,"xes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this formula.; TObjArrayROOT::v5::TFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_t*fLookupType[fNindex] array indicating how each leaf should be looked-up; TTreeFormulaManager*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tROOT::v5::TFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*ROOT::v5::TFormula::fNames[fNpar] Array of parameter names; Int_tfNcodesNumber of leaves referenced in formula; Int_tROOT::v5::TFormula::fNconstNumber of constants; Int_tfNdata[500]! This caches the physical number of element in the leaf or datamember.; Int_tROOT::v5::TFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNdimensions[500]Number of array dimensions in each leaf; Bool_tfNeedLoading! If true, the current entry has not been loaded yet.; Int_tfNindexSize of fIndex; Int_tROOT::v5::TFormula::fNoperNumber of operators; Int_tROOT::v5::TFormula::fNparNumber of parameters; Int_tROOT::v5::TFormula::fNstringNumber of different constants character strings; Int_tROOT::v5::TFormula::fNumberformula number identifier; Int_tROOT::v5::TFormula::fNvalNumber of different variables in expression; ROOT::v5::TOperOffset*ROOT::v5::TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*ROOT::v5::TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); ROOT::v5::TFormula::TFuncGROOT::v5::TFormula::fOptimal!pointer to optimal function; Double_t*ROOT::v5::TFormula::fParams[fNpar] Array of fNpar parameters; ROOT::v5::TFormulaPrimitive**ROOT::v5::TFormula::fPredefined![fNPar] predefined function; Bool_tfQuickLoad! If true, branch GetEntry is only called when the entry num",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeFormula.html:17722,load,loaded,17722,root/html604/TTreeFormula.html,https://root.cern,https://root.cern/root/html604/TTreeFormula.html,1,['load'],['loaded']
Performance,"ximum complexity of the rules is defined by the size of; : the trees. Large trees will yield many complex rules and capture; : higher order correlations. On the other hand, small trees will; : lead to a smaller ensemble with simple rules, only capable of; : modeling simple structures.; : Several parameters exists for controlling the complexity of the; : rule ensemble.; : ; : The fitting procedure searches for a minimum using a gradient; : directed path. Apart from step size and number of steps, the; : evolution of the path is defined by a cut-off parameter, tau.; : This parameter is unknown and depends on the training data.; : A large value will tend to give large weights to a few rules.; : Similarly, a small value will lead to a large set of rules; : with similar weights.; : ; : A final point is the model used; rules and/or linear terms.; : For a given training sample, the result may improve by adding; : linear terms. If best performance is obtained using only linear; : terms, it is very likely that the Fisher discriminant would be; : a better choice. Ideally the fitting procedure should be able to; : make this choice by giving appropriate weights for either terms.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : I. TUNING OF RULE ENSEMBLE:; : ; : ␛[1mForestType ␛[0m: Recommended is to use the default ""AdaBoost"".; : ␛[1mnTrees ␛[0m: More trees leads to more rules but also slow; : performance. With too few trees the risk is; : that the rule ensemble becomes too simple.; : ␛[1mfEventsMin ␛[0m; : ␛[1mfEventsMax ␛[0m: With a lower min, more large trees will be generated; : leading to more complex rules.; : With a higher max, more small trees will be; : generated leading to more simple rules.; : By changing this range, the average complexity; : of the rule ensemble can be controlled.; : ␛[1mRuleMinDist ␛[0m: By increasing the minimum distance between; : rules, fewer and more diverse rules will remain.; : Initially it is a good idea to keep this sm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:53859,perform,performance,53859,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['perform'],['performance']
Performance,"xisting content.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_CONV_Rpsi_CACHE_Obs[cpsi]_NORM_cpsi_Int[cpsi]) using numeric integrator RooIntegrator1D to calculate Int(cpsi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x80caf20 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[cpsi]_NORM_cpsi for nset (cpsi) with code 0 from preexisting content.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_CONV_Rpsi_CACHE_Obs[cpsi]_NORM_cpsi_Int[cpsi]) using numeric integrator RooIntegrator1D to calculate Int(cpsi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7f337a0 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[cpsi]_NORM_cpsi for nset (cpsi) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(Mf_over_Mf_Int[cpsi]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_Mf_over_Mf_Int[cpsi]_MfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7e9d680 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[cpsi] for nset () with code 1 from preexisting content.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Mf_Int[cpsi]) using numeric integrator RooIntegrator1D to calculate Int(cpsi); [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7e9d680 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[cpsi]_NORM_cpsi for nset (cpsi) with code 0; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_CONV_Rpsi_CA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf210__angularconv_8py.html:7266,optimiz,optimization,7266,doc/master/rf210__angularconv_8py.html,https://root.cern,https://root.cern/doc/master/rf210__angularconv_8py.html,2,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"xisting one.; Divide mother into ndiv divisions called name; along axis iaxis starting at coordinate value c0i.; The new volume created will be medium number numed.; Create a new volume by dividing an existing one; Divide mother into divisions called name along; axis iaxis in steps of step. If not exactly divisible; will make as many as possible and will center them; with respect to the mother. Divisions will have medium; number numed. If numed is 0, numed of mother is taken.; ndvmx is the expected maximum number of divisions; (If 0, no protection tests are performed in Geant3). void Gsord(const char* name, Int_t iax); Create a new volume by dividing an existing one; Divides mother into divisions called name along; axis iaxis starting at coordinate value c0 with step; size step.; The new volume created will have medium number numed.; If numed is 0, numed of mother is taken.; ndvmx is the expected maximum number of divisions; (If 0, no protection tests are performed in Geant3); Flag volume name whose contents will have to be ordered; along axis iax, by setting the search flag to -iax; (Geant3 only). void Gspos(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly = ""ONLY""); Position a volume into an existing one.; It positions a previously defined volume in the mother.; name Volume name; nr Copy number of the volume; mother Mother volume name; x X coord. of the volume in mother ref. sys.; y Y coord. of the volume in mother ref. sys.; z Z coord. of the volume in mother ref. sys.; irot Rotation matrix number w.r.t. mother ref. sys.; konly ONLY/MANY flag. void Gsposp(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly, Double_t* upar, Int_t np); Place a copy of generic volume name with user number; nr inside mother, with its parameters upar(1..np); The same as previous but in double precision. void SetCerenkov(Int_t itmed, Int_t npckov, Float_t* ppcko",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMC.html:21909,perform,performed,21909,root/html528/TVirtualMC.html,https://root.cern,https://root.cern/root/html528/TVirtualMC.html,6,['perform'],['performed']
Performance,"xisting ones; 2036 if (fgApplications) {; 2037 TIter nxa(fgApplications);; 2038 while ((ap = (TApplication *) nxa())) {; 2039 TString apn(ap->ApplicationName());; 2040 if (apn == url) {; 2041 // Found matching application; 2042 return ap;; 2043 } else {; 2044 // Check if same machine and user; 2045 TUrl au(apn);; 2046 if (strlen(au.GetUser()) > 0 && strlen(nu.GetUser()) > 0 &&; 2047 !strcmp(au.GetUser(), nu.GetUser())) {; 2048 if (!strncmp(au.GetHost(), nu.GetHost(), strlen(nu.GetHost()))); 2049 // New session on a known machine; 2050 nnew++;; 2051 }; 2052 }; 2053 }; 2054 } else {; 2055 ::Error(""TApplication::Open"", ""list of applications undefined - protocol error"");; 2056 return ap;; 2057 }; 2058 ; 2059 // If new session on a known machine pass the number as option; 2060 if (nnew > 0) {; 2061 nnew++;; 2062 nu.SetOptions(TString::Format(""%d"", nnew).Data());; 2063 }; 2064 ; 2065 // Instantiate the TApplication object to be run; 2066 TPluginHandler *h = nullptr;; 2067 if ((h = gROOT->GetPluginManager()->FindHandler(""TApplication"",""remote""))) {; 2068 if (h->LoadPlugin() == 0) {; 2069 ap = (TApplication *) h->ExecPlugin(3, nu.GetUrl(), debug, script);; 2070 } else {; 2071 ::Error(""TApplication::Open"", ""failed to load plugin for TApplicationRemote"");; 2072 }; 2073 } else {; 2074 ::Error(""TApplication::Open"", ""failed to find plugin for TApplicationRemote"");; 2075 }; 2076 ; 2077 // Add to the list; 2078 if (ap && !(ap->TestBit(kInvalidObject))) {; 2079 fgApplications->Add(ap);; 2080 gROOT->GetListOfBrowsables()->Add(ap, ap->ApplicationName());; 2081 TIter next(gROOT->GetListOfBrowsers());; 2082 TBrowser *b;; 2083 while ((b = (TBrowser*) next())); 2084 b->Add(ap, ap->ApplicationName());; 2085 gROOT->RefreshBrowsers();; 2086 } else {; 2087 SafeDelete(ap);; 2088 ::Error(""TApplication::Open"",; 2089 ""TApplicationRemote for %s could not be instantiated"", url);; 2090 }; 2091 ; 2092 // Done; 2093 return ap;; 2094}; 2095 ; 2096////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:77968,Load,LoadPlugin,77968,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['Load'],['LoadPlugin']
Performance,"xisting variable; parameter must exist or return false. bool SetVariableLowerLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableUpperLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an existing variable; parameter must exist or return false. bool FixVariable(unsigned int ); Fix an existing variable. bool ReleaseVariable(unsigned int ); Fix an existing variable. bool IsFixedVariable(unsigned int ) const; query if variable is fixed. bool GetVariableSettings(unsigned int , ROOT::Fit::ParameterSettings& ) const; retrieve variable settings (all set info on the variable). std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of covariance matrix; just invert it; but need to get the compact form to avoid the zero for the f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMinuitMinimizer.html:10187,perform,perform,10187,root/html534/TMinuitMinimizer.html,https://root.cern,https://root.cern/root/html534/TMinuitMinimizer.html,3,['perform'],['perform']
Performance,"xmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t targetDefinition TGWin32VirtualXProxy.cxx:247; where target is a pointer or array to the type stored on this branch.; When count_buf points to a valid TBuffer and the branch has a branch count, count_buf will be filled (via a call to GetEntriesSerialized()) with the data from the branchCount. After deserialization those value can be used to calculate the number of elements corresponding to each entries.; For each entry the number of elements is the multiplication of; TLeaf *leaf = dynamic_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; auto len = leaf->GetLen();; and the value in the BranchCount corresponding to that entry (can be obtained from branch->GetBranchCount()).; NoteThis interface is not meant to be exposed to end users, but rather it should be wrapped by higher-level interfaces. See TBranch::GetBulkEntries() for an alternative that also performs byte swapping. ; Definition at line 1586 of file TBranch.cxx. ◆ GetEntry(). Int_t TBranch::GetEntry ; (; Long64_t ; entry = 0, . Int_t ; getall = 0 . ). virtual . Read all leaves of entry and return total number of bytes read. ; The input argument ""entry"" is the entry number in the current tree. In case of a TChain, the entry number in the current Tree must be found before calling this function. For example:; TChain* chain = ...;; Long64_t localEntry = chain->LoadTree(entry);; branch->GetEntry(localEntry);; Long64_tlong long Long64_tDefinition RtypesCore.h:69; TChainA chain is a collection of files containing TTree objects.Definition TChain.h:33; TChain::LoadTreeLong64_t LoadTree(Long64_t entry) overrideFind the tree which contains entry, and set it as the current tree.Definition TChain.cxx:1324; The function returns the number of bytes read from the input buffer. If entry does not exist, the function returns 0. If an I/O error occurs, the function returns -1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranch.html:48519,perform,performs,48519,doc/master/classTBranch.html,https://root.cern,https://root.cern/doc/master/classTBranch.html,1,['perform'],['performs']
Performance,"xmin, xmax);; 5973 ; 5974 //std::cout << ""New re-computed axis : [ "" << xmin << "" , "" << xmax << "" ] width = "" << width << "" nbins "" << destAxis.GetNbins() << std::endl;; 5975 ; 5976 return kTRUE;; 5977}; 5978 ; 5979////////////////////////////////////////////////////////////////////////////////; 5980/// Add all histograms in the collection to this histogram.; 5981/// This function computes the min/max for the x axis,; 5982/// compute a new number of bins, if necessary,; 5983/// add bin contents, errors and statistics.; 5984/// If all histograms have bin labels, bins with identical labels; 5985/// will be merged, no matter what their order is.; 5986/// If overflows are present and limits are different the function will fail.; 5987/// The function returns the total number of entries in the result histogram; 5988/// if the merge is successful, -1 otherwise.; 5989///; 5990/// Possible option:; 5991/// -NOL : the merger will ignore the labels and merge the histograms bin by bin using bin center values to match bins; 5992/// -NOCHECK: the histogram will not perform a check for duplicate labels in case of axes with labels. The check; 5993/// (enabled by default) slows down the merging; 5994///; 5995/// IMPORTANT remark. The axis x may have different number; 5996/// of bins and different limits, BUT the largest bin width must be; 5997/// a multiple of the smallest bin width and the upper limit must also; 5998/// be a multiple of the bin width.; 5999/// Example:; 6000///; 6001/// ~~~ {.cpp}; 6002/// void atest() {; 6003/// TH1F *h1 = new TH1F(""h1"",""h1"",110,-110,0);; 6004/// TH1F *h2 = new TH1F(""h2"",""h2"",220,0,110);; 6005/// TH1F *h3 = new TH1F(""h3"",""h3"",330,-55,55);; 6006/// TRandom r;; 6007/// for (Int_t i=0;i<10000;i++) {; 6008/// h1->Fill(r.Gaus(-55,10));; 6009/// h2->Fill(r.Gaus(55,10));; 6010/// h3->Fill(r.Gaus(0,10));; 6011/// }; 6012///; 6013/// TList *list = new TList;; 6014/// list->Add(h1);; 6015/// list->Add(h2);; 6016/// list->Add(h3);; 6017/// TH1F *h = (TH1F*)h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:237308,perform,perform,237308,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['perform'],['perform']
Performance,"xml file ;  ; XMLNodePointer_t fStreamerInfoNode {nullptr};  ; std::unique_ptr< TXMLEngine > fXML;  pointer of node with streamer info data ;  ;  Protected Attributes inherited from TFile; TArchiveFile * fArchive {nullptr};  !Archive file from which we read this file ;  ; Long64_t fArchiveOffset {0};  !Offset at which file starts in archive ;  ; TFileOpenHandle * fAsyncHandle {nullptr};  !For proper automatic cleanup ;  ; EAsyncOpenStatus fAsyncOpenStatus {kAOSNotAsync};  !Status of an asynchronous open request ;  ; Long64_t fBEGIN {0};  First used byte in file. ;  ; Long64_t fBytesRead {0};  Number of bytes read from this file. ;  ; Long64_t fBytesReadExtra {0};  Number of extra bytes (overhead) read by the readahead buffer. ;  ; Long64_t fBytesWrite {0};  Number of bytes written to this file. ;  ; TFileCacheRead * fCacheRead {nullptr};  !Pointer to the read cache (if any) ;  ; TMap * fCacheReadMap {nullptr};  !Pointer to the read cache (if any) ;  ; TFileCacheWrite * fCacheWrite {nullptr};  !Pointer to the write cache (if any) ;  ; TArrayC * fClassIndex {nullptr};  !Index of TStreamerInfo classes written to this file ;  ; Int_t fCompress {0};  Compression level and algorithm. ;  ; Int_t fD {-1};  File descriptor. ;  ; Long64_t fEND {0};  Last used byte in file. ;  ; TList * fFree {nullptr};  Free segments linked list table. ;  ; bool fGlobalRegistration = true;  ! if true, bypass use of global lists ;  ; TList * fInfoCache {nullptr};  !Cached list of the streamer infos in this file ;  ; Bool_t fInitDone {kFALSE};  !True if the file has been initialized ;  ; Bool_t fIsArchive {kFALSE};  !True if this is a pure archive file ;  ; Bool_t fIsPcmFile {kFALSE};  !True if the file is a ROOT pcm file. ;  ; Bool_t fIsRootFile {kTRUE};  !True is this is a ROOT file, raw file otherwise ;  ; Bool_t fMustFlush {kTRUE};  !True if the file buffers must be flushed ;  ; Int_t fNbytesFree {0};  Number of bytes for free segments structure. ;  ; Int_t fNbytesInfo {0};  Number of bytes ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:39233,cache,cache,39233,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,3,['cache'],['cache']
Performance,"xpectedEvents(const RooArgSet* nset) const; virtual Double_texpectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeextendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddModel.html:12130,cache,cacheList,12130,root/html532/RooAddModel.html,https://root.cern,https://root.cern/root/html532/RooAddModel.html,21,['cache'],['cacheList']
Performance,"xpectedEvents(const RooArgSet* nset) const; virtual Double_texpectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeextendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooArgSet*findPdfNSet(RooAbsPdf& pdf) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProdPdf.html:12915,cache,cacheList,12915,root/html534/RooProdPdf.html,https://root.cern,https://root.cern/root/html534/RooProdPdf.html,3,['cache'],['cacheList']
Performance,"xpensiveObjectCache Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; List of all members ; RooExpensiveObjectCache Class ReferenceRooFit » RooFit Core. ; Singleton class that serves as repository for objects that are expensive to calculate. ; Owners of such objects can registers these here with associated parameter values for which the object is valid, so that other instances can, at a later moment retrieve these precalculated objects. ; Definition at line 24 of file RooExpensiveObjectCache.h. Classes; class  ExpensiveObject;  . Public Member Functions;  RooExpensiveObjectCache ();  ;  RooExpensiveObjectCache (const RooExpensiveObjectCache &other);  ;  ~RooExpensiveObjectCache () override;  Destructor. ;  ; void clearAll ();  Clear all cache elements. ;  ; bool clearObj (Int_t uniqueID);  Clear cache element with given unique ID Retrieve payload object of cache element with given unique ID. ;  ; bool empty () const;  ; const TObject * getObj (Int_t uniqueID);  Retrieve payload object of cache element with given unique ID. ;  ; void importCacheObjects (RooExpensiveObjectCache &other, const char *ownerName, bool verbose=false);  ; TClass * IsA () const override;  ; void print () const;  ; bool registerObject (const char *ownerName, const char *objectName, TObject &cacheObject, const RooArgSet &params);  Register object associated with given name and given associated parameters with given values in cache. ;  ; const TObject * retrieveObject (const char *name, TClass *tclass, const RooArgSet &params);  Retrieve object from cache that was registered under given name with given parameters, if current parameter values match those that were stored in the registry for this object. ;  ; bool setObj (Int_t uniqueID, TObject *obj);  Place new payload object in cache element with given unique ID. ;  ; Int_t size (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExpensiveObjectCache.html:986,cache,cache,986,doc/master/classRooExpensiveObjectCache.html,https://root.cern,https://root.cern/doc/master/classRooExpensiveObjectCache.html,2,['cache'],['cache']
Performance,"xplanation of the other parameters. The created object is named ""principal"" and a reference to it; is added to the list of specials Root objects.; you can retrieve a pointer to the created object via:; TPrincipal *principal =; (TPrincipal*)gROOT->GetListOfSpecials()->FindObject(""principal"");. void Print(Option_t* option = """") const; Print a summary of the tree contents. If option contains ""all"" friend trees are also printed.; If option contains ""toponly"" only the top level branches are printed.; If option contains ""clusters"" information about the cluster of baskets is printed. Wildcarding can be used to print only a subset of the branches, e.g.,; T.Print(""Elec*"") will print all branches with name starting with ""Elec"". void PrintCacheStats(Option_t* option = """") const; print statistics about the TreeCache for this tree, like; ******TreeCache statistics for file: cms2.root ******; Reading 73921562 bytes in 716 transactions; Average transaction = 103.242405 Kbytes; Number of blocks in current cache: 202, total size : 6001193. if option = ""a"" the list of blocks in the cache is printed. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): cal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:116686,cache,cache,116686,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['cache'],['cache']
Performance,"xplanation of the other parameters. The created object is named ""principal"" and a reference to it; is added to the list of specials Root objects.; you can retrieve a pointer to the created object via:; TPrincipal *principal =; (TPrincipal*)gROOT->GetListOfSpecials()->FindObject(""principal"");. void Print(Option_t* option = """") const; Print a summary of the tree contents. If option contains ""all"" friend trees are also printed.; If option contains ""toponly"" only the top level branches are printed.; If option contains ""clusters"" information about the cluster of baskets is printed. Wildcarding can be used to print only a subset of the branches, e.g.,; T.Print(""Elec*"") will print all branches with name starting with ""Elec"". void PrintCacheStats(Option_t* option = """") const; print statistics about the TreeCache for this tree, like; ******TreeCache statistics for file: cms2.root ******; Reading 73921562 bytes in 716 transactions; Average transaction = 103.242405 Kbytes; Number of blocks in current cache: 202, total size : 6001193. if option = ""a"" the list of blocks in the cache is printed. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called everytime a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): call",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:110338,cache,cache,110338,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,2,['cache'],['cache']
Performance,"xport ROOT geometries (TGeo geometry trees) as GDML files. The writer module writes a GDML file out of the 'in-memory' representation of the geometry. The actual application-specific (ROOT) binding is implemented in ROOTwriter module. It contains 'binding methods' for TGeo geometry classes which can be exported in GDML format. Please refere to the comment part of the ROOTwriter.py file for the list of presently supported TGeo classes. The ROOTwriter class contains also three methods, dumpMaterials, dumpSolids and examineVol which need to be called in order to export materials, solids and geometry tree respectively.; The TGeo to GDML converter is now interfaced to the TGeoManager::Export method which automatically calls the appropriate Python scripts whenever the geometry output file has the .gdml extension.; Alternatively, one can also use the ROOT->GDML converter directly from the Python prompt (assuming the TGeo geometry has already been loaded into memory in one or another way), for example:; from math import *; ; import ROOT; import writer; import ROOTwriter; ; # get TGeoManager and; # get the top volume of the existing (in-memory) geometry tree; geomgr = ROOT.gGeoManager; topV = geomgr.GetTopVolume(); ; # instanciate writer; gdmlwriter = writer.writer('mygeo.gdml'); binding = ROOTwriter.ROOTwriter(gdmlwriter); ; # dump materials; matlist = geomgr.GetListOfMaterials(); binding.dumpMaterials(matlist); ; # dump solids; shapelist = geomgr.GetListOfShapes(); binding.dumpSolids(shapelist); ; # dump geo tree; print 'Traversing geometry tree'; gdmlwriter.addSetup('default', '1.0', topV.GetName()); binding.examineVol(topV); ; # write file; gdmlwriter.writeFile(); ROOTwriter.ROOTwriterDefinition ROOTwriter.py:58; ROOTwriter.ROOTwriter.dumpMaterialsdumpMaterials(self, matlist)Definition ROOTwriter.py:279; writer.writerDefinition writer.py:16; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry__gdml.html:3323,load,loaded,3323,doc/master/group__Geometry__gdml.html,https://root.cern,https://root.cern/doc/master/group__Geometry__gdml.html,1,['load'],['loaded']
Performance,"xsize = 100000000000LL). static . Set the maximum size in bytes of a Tree file (static function). ; The default size is 100000000000LL, ie 100 Gigabytes.; In TTree::Fill, when the file has a size > fgMaxTreeSize, the function closes the current file and starts writing into a new file with a name of the style ""file_1.root"" if the original requested file name was ""file.root"". ; Definition at line 9187 of file TTree.cxx. ◆ SetMaxVirtualSize(). virtual void TTree::SetMaxVirtualSize ; (; Long64_t ; size = 0). inlinevirtual . Definition at line 625 of file TTree.h. ◆ SetName(). void TTree::SetName ; (; const char * ; name). overridevirtual . Change the name of this tree. ; Reimplemented from TNamed.; Definition at line 9195 of file TTree.cxx. ◆ SetNotify(). void TTree::SetNotify ; (; TObject * ; obj). virtual . Sets the address of the object to be notified when the tree is loaded. ; The method TObject::Notify is called for the given object when the tree is loaded. Specifically this occurs in the TTree::LoadTree method. To remove the notification call this method with nullptr: tree->SetNotify(nullptr); ; If this is a TChain, obj is most often going to be a TNotifyLink.; Parameters. [in]objPointer to a TObject to be notified. . Definition at line 9221 of file TTree.cxx. ◆ SetObject(). void TTree::SetObject ; (; const char * ; name, . const char * ; title . ). virtual . Change the name and title of this tree. ; Definition at line 9250 of file TTree.cxx. ◆ SetParallelUnzip(). void TTree::SetParallelUnzip ; (; bool ; opt = true, . Float_t ; RelSize = -1 . ). virtual . Enable or disable parallel unzipping of Tree buffers. ; Definition at line 9281 of file TTree.cxx. ◆ SetPerfStats(). void TTree::SetPerfStats ; (; TVirtualPerfStats * ; perf). virtual . Set perf stats. ; Definition at line 9319 of file TTree.cxx. ◆ SetScanField(). virtual void TTree::SetScanField ; (; Int_t ; n = 50). inlinevirtual . Definition at line 645 of file TTree.h. ◆ SetTargetMemoryRatio(). void TTree::Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:215472,Load,LoadTree,215472,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['Load'],['LoadTree']
Performance,"xsize = 100000000000LL). static . Set the maximum size in bytes of a Tree file (static function). ; The default size is 100000000000LL, ie 100 Gigabytes.; In TTree::Fill, when the file has a size > fgMaxTreeSize, the function closes the current file and starts writing into a new file with a name of the style ""file_1.root"" if the original requested file name was ""file.root"". ; Definition at line 9197 of file TTree.cxx. ◆ SetMaxVirtualSize(). virtual void TTree::SetMaxVirtualSize ; (; Long64_t ; size = 0). inlinevirtual . Definition at line 665 of file TTree.h. ◆ SetName(). void TTree::SetName ; (; const char * ; name). overridevirtual . Change the name of this tree. ; Reimplemented from TNamed.; Definition at line 9205 of file TTree.cxx. ◆ SetNotify(). void TTree::SetNotify ; (; TObject * ; obj). virtual . Sets the address of the object to be notified when the tree is loaded. ; The method TObject::Notify is called for the given object when the tree is loaded. Specifically this occurs in the TTree::LoadTree method. To remove the notification call this method with nullptr: tree->SetNotify(nullptr); ; If this is a TChain, obj is most often going to be a TNotifyLink.; Parameters. [in]objPointer to a TObject to be notified. . Definition at line 9231 of file TTree.cxx. ◆ SetObject(). void TTree::SetObject ; (; const char * ; name, . const char * ; title . ). virtual . Change the name and title of this tree. ; Definition at line 9260 of file TTree.cxx. ◆ SetParallelUnzip(). void TTree::SetParallelUnzip ; (; bool ; opt = true, . Float_t ; RelSize = -1 . ). virtual . Enable or disable parallel unzipping of Tree buffers. ; Definition at line 9291 of file TTree.cxx. ◆ SetPerfStats(). void TTree::SetPerfStats ; (; TVirtualPerfStats * ; perf). virtual . Set perf stats. ; Definition at line 9329 of file TTree.cxx. ◆ SetScanField(). virtual void TTree::SetScanField ; (; Int_t ; n = 50). inlinevirtual . Sets the default maximum number of lines to be shown before <CR> when calling Sc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:218097,Load,LoadTree,218097,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['Load'],['LoadTree']
Performance,"xt {nullptr};  Buffer for GetPath() function. ;  ; std::atomic< size_t > fContextPeg {0};  thread local gDirectory pointing to this object. ;  ; std::vector< SharedGDirectory_t > fGDirectories;  ; TList * fList {nullptr};  ; TObject * fMother {nullptr};  ; TString fPathBuffer;  ; std::atomic_flag fSpinLock;  Counter delaying the TDirectory destructor from finishing. ;  ; TUUID fUUID;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static TList * fgAsyncOpenRequests = nullptr;  ; static std::atomic< Long64_t > fgBytesRead {0};  Number of bytes read by all TFile objects. ;  ; static std::atomic< Long64_t > fgBytesWrite {0};  Number of bytes written by all TFile objects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . Private Member Functions;  TFile (const TFile &)=delete;  ; void operator= (con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:43581,CACHE,CACHEREAD,43581,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['CACHE'],['CACHEREAD']
Performance,"xt(GetListOfMethods(), kIterBackward);; 3889 while ((method = (TMethod*)next())) {; 3890 m = (TMethod*)list->FindObject(method->GetName());; 3891 if (method->IsMenuItem() != kMenuNoMenu) {; 3892 if (!m); 3893 list->AddFirst(method);; 3894 } else {; 3895 if (m && m->GetNargs() == method->GetNargs()); 3896 list->Remove(m);; 3897 }; 3898 }; 3899}; 3900 ; 3901////////////////////////////////////////////////////////////////////////////////; 3902/// Check whether a class has a dictionary or not.; 3903/// This is equivalent to ask if a class is coming from a bootstrapping; 3904/// procedure initiated during the loading of a library.; 3905 ; 3906Bool_t TClass::HasDictionary() const; 3907{; 3908 return IsLoaded();; 3909}; 3910 ; 3911////////////////////////////////////////////////////////////////////////////////; 3912/// Check whether a class has a dictionary or ROOT can load one.; 3913/// This is equivalent to ask HasDictionary() or whether a library is known; 3914/// where it can be loaded from, or whether a Dictionary function is; 3915/// available because the class's dictionary library was already loaded.; 3916 ; 3917Bool_t TClass::HasDictionarySelection(const char* clname); 3918{; 3919 if (TClass* cl = (TClass*)gROOT->GetListOfClasses()->FindObject(clname)); 3920 return cl->IsLoaded();; 3921 return gClassTable->GetDict(clname) || gInterpreter->GetClassSharedLibs(clname);; 3922}; 3923 ; 3924////////////////////////////////////////////////////////////////////////////////; 3925/// Verify the base classes always.; 3926 ; 3927void TClass::GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); 3928{; 3929 TList* lb = GetListOfBases();; 3930 if (!lb) return;; 3931 TIter nextBase(lb);; 3932 TBaseClass* base = nullptr;; 3933 while ((base = (TBaseClass*)nextBase())) {; 3934 TClass* baseCl = base->GetClassPointer();; 3935 if (baseCl) {; 3936 baseCl->GetMissingDictionariesWithRecursionCheck(result, visited, recurse);; 3937 }; 3938 }; 3939}; 39",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:148234,load,loaded,148234,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,['load'],['loaded']
Performance,"xt(GetListOfMethods(), kIterBackward);; 3956 while ((method = (TMethod*)next())) {; 3957 m = (TMethod*)list->FindObject(method->GetName());; 3958 if (method->IsMenuItem() != kMenuNoMenu) {; 3959 if (!m); 3960 list->AddFirst(method);; 3961 } else {; 3962 if (m && m->GetNargs() == method->GetNargs()); 3963 list->Remove(m);; 3964 }; 3965 }; 3966}; 3967 ; 3968////////////////////////////////////////////////////////////////////////////////; 3969/// Check whether a class has a dictionary or not.; 3970/// This is equivalent to ask if a class is coming from a bootstrapping; 3971/// procedure initiated during the loading of a library.; 3972 ; 3973Bool_t TClass::HasDictionary() const; 3974{; 3975 return IsLoaded();; 3976}; 3977 ; 3978////////////////////////////////////////////////////////////////////////////////; 3979/// Check whether a class has a dictionary or ROOT can load one.; 3980/// This is equivalent to ask HasDictionary() or whether a library is known; 3981/// where it can be loaded from, or whether a Dictionary function is; 3982/// available because the class's dictionary library was already loaded.; 3983 ; 3984Bool_t TClass::HasDictionarySelection(const char* clname); 3985{; 3986 if (TClass* cl = (TClass*)gROOT->GetListOfClasses()->FindObject(clname)); 3987 return cl->IsLoaded();; 3988 return gClassTable->GetDict(clname) || gInterpreter->GetClassSharedLibs(clname);; 3989}; 3990 ; 3991////////////////////////////////////////////////////////////////////////////////; 3992/// Verify the base classes always.; 3993 ; 3994void TClass::GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); 3995{; 3996 TList* lb = GetListOfBases();; 3997 if (!lb) return;; 3998 TIter nextBase(lb);; 3999 TBaseClass* base = nullptr;; 4000 while ((base = (TBaseClass*)nextBase())) {; 4001 TClass* baseCl = base->GetClassPointer();; 4002 if (baseCl) {; 4003 baseCl->GetMissingDictionariesWithRecursionCheck(result, visited, recurse);; 4004 }; 4005 }; 4006}; 40",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:150985,load,loaded,150985,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['load'],['loaded']
Performance,"xtMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Int_tfDebugLocal verbosity level; TStringfDirNameThe name of the subdir with the perfomance tree; TH1F*fEventsEvent distribution per worker; TH1F*fEvtRateEvent processing rate vs query time; Double_tfEvtRateAvgAverage event processing rate; Double_tfEvtRateAvgMaxMax running event processing rate; Double_tfEvtRateMaxMax event processing rate per packet; TH1F*fEvtRateRunEvent processing rate running avg vs query time; TFile*fFileThe open performance file; TSortedListfFilesInfoSorted list of files info; Float_tfInitTimeEnd of initialization time for this query; Double_tfLatencyMaxMax retrieval latency per packet; TH1F*fMBRateByte processing rate vs query time; Double_tfMBRateAvgAverage MB processing rate; Double_tfMBRateAvgMaxMax running MB processing rate; Double_tfMBRateMaxMax MB processing rate per packet; TH1F*fMBRateRunByte processing rate running avg vs query time; Float_tfMaxTimeMax time for this query (slowest worker); Float_tfMergeTimeBegin of merging time for this query; TH1F*fPacketsPacket distribution per worker; TTree*fTreeThe performance tree; TStringfTreeNameThe name of the performance tree; TSortedListfWrksInfoSorted list of workers info; static Bool_tfgDebugGlobal verbosity on/off. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofPerfAnalysis(const char* perffile, const char* title = """", const char* treename = ""PROOF_PerfStats""); Constructor: open the file and attach to the tree. TProofPerfAnalysis(TTree* tree, const char* title = """"); Constructor: open the file and attach to the tree. ~TProofPerfAnalysis(); Destructor:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPerfAnalysis.html:7869,perform,performance,7869,root/html602/TProofPerfAnalysis.html,https://root.cern,https://root.cern/root/html602/TProofPerfAnalysis.html,4,"['latency', 'perform']","['latency', 'performance']"
Performance,"xtstd::unique_ptr< RooAbsGenContext > _genContextDefinition RooAbsPdf.h:83; RooAbsPdf::GenSpec::~GenSpecvirtual ~GenSpec(); RooAbsPdf::GenSpec::_whatVarsRooArgSet _whatVarsDefinition RooAbsPdf.h:84; RooAbsPdf::GenSpec::_initbool _initDefinition RooAbsPdf.h:91; RooAbsPdf::GenSpec::_extendedbool _extendedDefinition RooAbsPdf.h:87; RooAbsPdf::GenSpec::GenSpecGenSpec(const GenSpec &other); RooAbsPdf::GenSpec::_nGenInt_t _nGenDefinition RooAbsPdf.h:86; RooAbsPdf::GenSpec::GenSpecGenSpec()=default; RooAbsPdf::GenSpec::_randProtobool _randProtoDefinition RooAbsPdf.h:88; RooAbsPdf::GenSpec::_resampleProtobool _resampleProtoDefinition RooAbsPdf.h:89; RooAbsPdf::GenSpec::_dsetNameTString _dsetNameDefinition RooAbsPdf.h:90; RooAbsPdf::GenSpec::_protoDataRooDataSet * _protoDataDefinition RooAbsPdf.h:85; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::syncNormalizationvirtual bool syncNormalization(const RooArgSet *dset, bool adjustProxies=true) constVerify that the normalization integral cached with this PDF is valid for given set of normalization o...Definition RooAbsPdf.cxx:481; RooAbsPdf::getNormdouble getNorm(const RooArgSet &nset) constGet normalisation term needed to normalise the raw values returned by getVal().Definition RooAbsPdf.h:195; RooAbsPdf::compileForNormSetstd::unique_ptr< RooAbsArg > compileForNormSet(RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const overrideDefinition RooAbsPdf.cxx:2788; RooAbsPdf::_normMgrRooObjCacheManager _normMgrDefinition RooAbsPdf.h:329; RooAbsPdf::_normSetIdRooFit::UniqueId< RooArgSet >::Value_t _normSetId! Unique ID of the currently-active normalization setDefinition RooAbsPdf.h:346; RooAbsPdf::_specGeneratorConfigstd::unique_ptr< RooNumGenConfig > _specGeneratorConfig! MC generator configuration specific for this objectDefinition RooAbsPdf.h:340; RooAbsPdf::createNLLRooFit::OwningPtr< RooAbsReal > createNLL(RooAbsData &data, CmdArgs_t const &... cmdArgs)Constr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8h_source.html:20264,cache,cached,20264,doc/master/RooAbsPdf_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8h_source.html,1,['cache'],['cached']
Performance,"xx. ◆ Filter() [1/4]. template<typename Proxied , typename DataSource = void> . template<typename F , std::enable_if_t<!std::is_convertible< F, std::string >::value, int > = 0> . RInterface< RDFDetail::RFilter< F, Proxied >, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::Filter ; (; F ; f, . const ColumnNames_t & ; columns = {}, . std::string_view ; name = """" . ). inline . Append a filter to the call graph. ; Parameters. [in]fFunction, lambda expression, functor class or any other callable object. It must return a bool signalling whether the event has passed the selection (true) or not (false). ; [in]columnsNames of the columns/branches in input to the filter function. ; [in]nameOptional name of this filter. See Report. . Returnsthe filter node of the computation graph.; Append a filter node at the point of the call graph corresponding to the object this method is called on. The callable f should not have side-effects (e.g. modification of an external or static variable) to ensure correct results when implicit multi-threading is active.; RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed in order and the first one returning false causes the event to be discarded. Even if multiple actions or transformations depend on the same filter, it is executed once per entry. If its result is requested more than once, the cached result is served. Example usage:; // C++ callable (function, functor class, lambda...) that takes two parameters of the types of ""x"" and ""y""; auto filtered = df.Filter(myCut, {""x"", ""y""});; ; // String: it must contain valid C++ except that column names can be used instead of variable names; auto filtered = df.Filter(""x*y > 0"");; NoteIf the body of the string expression contains an explicit return statement (even if it is in a nested scope), RDataFrame will not add another one in front of the expression. So this will not work: df.Filter(""Sum(Map(vec, [](float e) { return e*e > 0.5; }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:68674,multi-thread,multi-threading,68674,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['multi-thread'],['multi-threading']
Performance,xx. ◆ GetSubBranchPrefix(). const char * TBranchProxyClassDescriptor::GetSubBranchPrefix ; (; ); const. Get the prefix from the branch name. ; Definition at line 135 of file TBranchProxyClassDescriptor.cxx. ◆ IsA(). TClass * ROOT::Internal::TBranchProxyClassDescriptor::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 81 of file TBranchProxyClassDescriptor.h. ◆ IsClones(). bool TBranchProxyClassDescriptor::IsClones ; (; ); const. Return true if this proxy is for a TClonesArray. ; Definition at line 245 of file TBranchProxyClassDescriptor.cxx. ◆ IsEquivalent(). bool TBranchProxyClassDescriptor::IsEquivalent ; (; const TBranchProxyClassDescriptor * ; other). virtual . Return true if this description is the 'same' as the other decription. ; Definition at line 158 of file TBranchProxyClassDescriptor.cxx. ◆ IsLoaded() [1/2]. bool TBranchProxyClassDescriptor::IsLoaded ; (; ); const. Return true if the class needed by the branch is loaded. ; Definition at line 222 of file TBranchProxyClassDescriptor.cxx. ◆ IsLoaded() [2/2]. bool TBranchProxyClassDescriptor::IsLoaded ; (; const char * ; classname). static . Return true if the class needed by the branch is loaded. ; Definition at line 230 of file TBranchProxyClassDescriptor.cxx. ◆ IsSTL(). bool TBranchProxyClassDescriptor::IsSTL ; (; ); const. Return true if this proxy is for a TClonesArray. ; Definition at line 253 of file TBranchProxyClassDescriptor.cxx. ◆ NameToSymbol(). void TBranchProxyClassDescriptor::NameToSymbol ; (; ). private . Make the typename a proper class name without having the really deal with namespace and templates. ; Definition at line 37 of file TBranchProxyClassDescriptor.cxx. ◆ operator=(). TBranchProxyClassDescriptor & ROOT::Internal::TBranchProxyClassDescriptor::operator= ; (; const TBranchProxyClassDescriptor & ; ). inlineprivate . Definition at line 48 of file TBranchProxyClassDescriptor.h. ◆ OutputDecl(). void TBranc,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1TBranchProxyClassDescriptor.html:18524,load,loaded,18524,doc/master/classROOT_1_1Internal_1_1TBranchProxyClassDescriptor.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1TBranchProxyClassDescriptor.html,1,['load'],['loaded']
Performance,"xx. ◆ ~TProfile(). TProfile::~TProfile ; (; ). override . Default destructor for Profile histograms. ; Definition at line 100 of file TProfile.cxx. Member Function Documentation. ◆ Add() [1/3]. Bool_t TProfile::Add ; (; const TH1 * ; h1, . const TH1 * ; h2, . Double_t ; c1 = 1, . Double_t ; c2 = 1 . ). overridevirtual . Replace contents of this profile by the addition of h1 and h2. ; this = c1*h1 + c2*h2; c1 and c2 are considered as weights applied to the two summed profiles. The operation acts therefore like merging the two profiles with a weight c1 and c2 ; Reimplemented from TH1.; Definition at line 291 of file TProfile.cxx. ◆ Add() [2/3]. Bool_t TProfile::Add ; (; const TH1 * ; h1, . Double_t ; c1 = 1 . ). overridevirtual . Performs the operation: this = this + c1*h1. ; Reimplemented from TH1.; Definition at line 269 of file TProfile.cxx. ◆ Add() [3/3]. Bool_t TProfile::Add ; (; TF1 * ; h1, . Double_t ; c1 = 1, . Option_t * ; option = """" . ). overridevirtual . Performs the operation: this = this + c1*f1. ; Reimplemented from TH1.; Definition at line 259 of file TProfile.cxx. ◆ Approximate(). void TProfile::Approximate ; (; Bool_t ; approx = kTRUE). static . Static function to set the fgApproximate flag. ; When the flag is true, the function GetBinError will approximate the bin error with the average profile error on all bins in the following situation only. the number of bins in the profile is less than 1002; the bin number of entries is small ( <5); the estimated bin error is extremely small compared to the bin content (see TProfile::GetBinError) . Definition at line 324 of file TProfile.cxx. ◆ BufferEmpty(). Int_t TProfile::BufferEmpty ; (; Int_t ; action = 0). overridevirtual . Fill histogram with all entries in the buffer. . action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint); action = 0 histogram is filled from the buffer; action = 1 histogram is filled and buffer is deleted The buffer is automatically deleted when the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile.html:62008,Perform,Performs,62008,doc/master/classTProfile.html,https://root.cern,https://root.cern/doc/master/classTProfile.html,1,['Perform'],['Performs']
Performance,"xx:1840; ROOT::RDF::RInterface::VaryRInterface< Proxied, DS_t > Vary(const std::vector< std::string > &colNames, F &&expression, const ColumnNames_t &inputColumns, const std::vector< std::string > &variationTags, std::string_view variationName)Register systematic variations for multiple existing columns using custom variation tags.Definition RInterface.hxx:950; ROOT::RDF::RInterface::RedefineSlotEntryRInterface< Proxied, DS_t > RedefineSlotEntry(std::string_view name, F expression, const ColumnNames_t &columns={})Overwrite the value and/or type of an existing column.Definition RInterface.hxx:598; ROOT::RDF::RInterface::Histo1DRResultPtr<::TH1D > Histo1D(const TH1DModel &model, std::string_view vName, std::string_view wName)Fill and return a one-dimensional histogram with the weighted values of a column (lazy action).Definition RInterface.hxx:1866; ROOT::RDF::RInterface::CacheImplRInterface< RLoopManager > CacheImpl(const ColumnNames_t &columnList, std::index_sequence< S... >)Implementation of cache.Definition RInterface.hxx:3200; ROOT::RDF::RInterface::RangeRInterface< RDFDetail::RRange< Proxied >, DS_t > Range(unsigned int end)Creates a node that filters entries based on range.Definition RInterface.hxx:1591; ROOT::RDF::RInterface::FilterMissingRInterface< RDFDetail::RFilterWithMissingValues< Proxied >, DS_t > FilterMissing(std::string_view column)Keep only the entries that have missing values.Definition RInterface.hxx:388; ROOT::RDF::RInterface::TakeRResultPtr< COLL > Take(std::string_view column="""")Return a collection of values of a column (lazy action, returns a std::vector by default).Definition RInterface.hxx:1761; ROOT::RDF::RInterface::CacheRInterface< RLoopManager > Cache(std::initializer_list< std::string > columnList)Save selected columns in memory.Definition RInterface.hxx:1546; ROOT::RDF::RInterface::Profile2DRResultPtr<::TProfile2D > Profile2D(const TProfile2DModel &model, std::string_view v1Name="""", std::string_view v2Name="""", std::string_view v3Name=""""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:208565,cache,cache,208565,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['cache'],['cache']
Performance,"xx:270; TBuffer::GetParentTObject * GetParent() constReturn pointer to parent of this buffer.Definition TBuffer.cxx:262; TBuffer::GetCurrentchar * GetCurrent() constDefinition TBuffer.h:97; TBuffer::Expandvoid Expand(Int_t newsize, Bool_t copy=kTRUE)Expand (or shrink) the I/O buffer to newsize bytes.Definition TBuffer.cxx:223; TBuffer::kIsOwner@ kIsOwnerDefinition TBuffer.h:75; TBuffer::SetBuffervoid SetBuffer(void *buf, UInt_t bufsiz=0, Bool_t adopt=kTRUE, ReAllocCharFun_t reallocfunc=nullptr)Sets a new buffer in an existing TBuffer object.Definition TBuffer.cxx:187; TBuffer::PushDataCachevirtual void PushDataCache(TVirtualArray *)Push a new data cache area onto the list of area to be used for temporarily store 'missing' data memb...Definition TBuffer.cxx:362; TBuffer::SetReAllocFuncvoid SetReAllocFunc(ReAllocCharFun_t reallocfunc=nullptr)Set which memory reallocation method to use.Definition TBuffer.cxx:286; TBuffer::PopDataCachevirtual TVirtualArray * PopDataCache()Pop and Return the 'current' data cache area from the list of area to be used for temporarily store '...Definition TBuffer.cxx:381; TBuffer::EModeEModeDefinition TBuffer.h:73; TBuffer::kWrite@ kWriteDefinition TBuffer.h:73; TBuffer::kRead@ kReadDefinition TBuffer.h:73; TBuffer::fBufMaxchar * fBufMaxDefinition TBuffer.h:53; TBuffer::fBufCurchar * fBufCurDefinition TBuffer.h:52; TBuffer::AutoExpandvoid AutoExpand(Int_t size_needed)Automatically calculate a new size and expand the buffer to fit at least size_needed.Definition TBuffer.cxx:158; TBuffer::PeekDataCachevirtual TVirtualArray * PeekDataCache() constReturn the 'current' data cache area from the list of area to be used for temporarily store 'missing'...Definition TBuffer.cxx:371; TBuffer::ReadClassBuffervirtual Int_t ReadClassBuffer(const TClass *cl, void *pointer, const TClass *onfile_class=nullptr)=0; TBuffer::kMinimalSize@ kMinimalSizeDefinition TBuffer.h:78; TBuffer::kInitialSize@ kInitialSizeDefinition TBuffer.h:78; TBuffer::~TBuffervirtual ~",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBuffer_8cxx_source.html:18732,cache,cache,18732,doc/master/TBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html,1,['cache'],['cache']
Performance,"xx:3699; "" xxxx"" is viewer type: OpenGL ""ogl"", X3D ""x3d"" or Pad ""pad"" (default). The viewer is created via the plugin manager, attached to pad, and the interface returned. Begin / End Scene; Objects must be added to viewer between BeginScene/EndScene calls e.g. v->BeginScene();; .....; v->AddObject(....);; v->AddObject(....);; .....; v->EndScene();; The BeginScene call will cause the viewer to suspend redraws etc, and after the EndScene the viewer will reset the camera to frame the new scene and redraw. [x3d viewer does not support changing of scenes - objects added after the first Open/CloseScene pair will be ignored.]. Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some need the 3D object positions in the global frame, others can cope with local frames + a translation matrix - which can give considerable performance benefits. To cope with these situations the object buffer is filled out in negotiation with the viewer. TBuffer3D classes are conceptually divided into enumerated sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw) are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section in derived shape specific classes allows a more abstract shape description (""a sphere of inner radius x, outer radius y""). This enables a viewer which knows how to draw (tessellate) the shape itself to do so, which can bring considerable performance and quality benefits, while providing a generic fallback suitable for all viewers.; The rules for client negotiation with the view",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualViewer3D.html:2991,perform,performance,2991,doc/master/classTVirtualViewer3D.html,https://root.cern,https://root.cern/doc/master/classTVirtualViewer3D.html,1,['perform'],['performance']
Performance,"xx:547; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::NumCPURooCmdArg NumCPU(Int_t nCPU, Int_t interleave=0)Definition RooGlobalFunc.cxx:474; RooFit::ProjWDataRooCmdArg ProjWData(const RooAbsData &projData, bool binData=false)Definition RooGlobalFunc.cxx:179; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf603_multicpuDefinition rf603_multicpu.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; TimerDefinition histspeedtest.cxx:54; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.140; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.140; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.010; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.150, 2 slices; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y,z); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) only the following components of the projection data will be used: (y,z); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf603_multicpu.C. tutorialsroofitrf603_multicpu.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf603__multicpu_8C.html:7007,optimiz,optimization,7007,doc/master/rf603__multicpu_8C.html,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8C.html,1,['optimiz'],['optimization']
Performance,"xx:950; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::DataLoader::PrepareTrainingAndTestTreevoid PrepareTrainingAndTestTree(const TCut &cut, const TString &splitOpt)prepare the training and test trees -> same cuts for signal and backgroundDefinition DataLoader.cxx:632; TMVA::DataLoader::AddTreevoid AddTree(TTree *tree, const TString &className, Double_t weight=1.0, const TCut &cut="""", Types::ETreeType tt=Types::kMaxTreeType)Definition DataLoader.cxx:351; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; TMVA::Factory::TrainAllMethodsvoid TrainAllMethods()Iterates through all booked methods and calls training.Definition Factory.cxx:1114; TMVA::Factory::BookMethodMethodBase * BookMethod(DataLoader *loader, TString theMethodName, TString methodTitle, TString theOption="""")Book a classifier or regression method.Definition Factory.cxx:352; TMVA::Factory::TestAllMethodsvoid TestAllMethods()Evaluates all booked methods on the testing data and adds the output to the Results in the corresponi...Definition Factory.cxx:1271; TMVA::Factory::EvaluateAllMethodsvoid EvaluateAllMethods(void)Iterates over all MVAs that have been booked, and calls their evaluation methods.Definition Factory.cxx:1376; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TMVA::Types::kFDA@ kFDADefinition Types.h:92; TMVA::Types::kBDT@ kBDTDefinition Types.h:86; TMVA::Types::kDL@ kDLDefinition Types.h:99; TMVA::Types::kPDEFoam@ kPDEFoamDefinition Types.h:94; TMVA::Types::kMLP@ kMLPDefinition T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:40130,load,loader,40130,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,2,['load'],['loader']
Performance,"xxx"" is viewer type: OpenGL ""ogl"", X3D ""x3d"" or; Pad ""pad"" (default). The viewer is created via the plugin manager,; attached to pad, and the interface returned.; Begin / End Scene; Objects must be added to viewer between BeginScene/EndScene calls e.g.; v->BeginScene();; .....; v->AddObject(....);; v->AddObject(....);; .....; v->EndScene();>; The BeginScene call will cause the viewer to suspend redraws etc, and after; the EndScene the viewer will reset the camera to frame the new scene and redraw.; [x3d viewer does not support changing of scenes - objects added after the; first Open/CloseScene pair will be ignored.]; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualViewer3D.html:2872,perform,performance,2872,root/html528/TVirtualViewer3D.html,https://root.cern,https://root.cern/root/html528/TVirtualViewer3D.html,6,['perform'],['performance']
Performance,"xxxInfo_t' to nullptr.; 593 if (O && O->IsValid()); 594 L.Unload(O), O->Update(nullptr);; 595 }; 596 ; 597 void InvalidateCachedDecl(const std::tuple<TListOfDataMembers*,; 598 TListOfFunctions*,; 599 TListOfFunctionTemplates*,; 600 TListOfEnums*> &Lists, const clang::Decl *D);; 601 ; 602 class SuspendAutoLoadingRAII {; 603 TCling *fTCling = nullptr;; 604 bool fOldValue;; 605 ; 606 public:; 607 SuspendAutoLoadingRAII(TCling *tcling) : fTCling(tcling) { fOldValue = fTCling->SetClassAutoLoading(false); }; 608 ~SuspendAutoLoadingRAII() { fTCling->SetClassAutoLoading(fOldValue); }; 609 };; 610 ; 611 class TUniqueString {; 612 public:; 613 TUniqueString() = delete;; 614 TUniqueString(const TUniqueString &) = delete;; 615 TUniqueString(Long64_t size);; 616 const char *Data();; 617 bool Append(const std::string &str);; 618 private:; 619 std::string fContent;; 620 std::set<size_t> fLinesHashSet;; 621 std::hash<std::string> fHashFunc;; 622 };; 623 ; 624 TCling();; 625 TCling(const TCling&) = delete;; 626 TCling& operator=(const TCling&) = delete;; 627 ; 628 void Execute(TMethod*, TObjArray*, int* /*error*/ = nullptr) final {}; 629 ; 630 void UpdateListOfLoadedSharedLibraries();; 631 void RegisterLoadedSharedLibrary(const char* name);; 632 void AddFriendToClass(clang::FunctionDecl*, clang::CXXRecordDecl*) const;; 633 ; 634 std::map<std::string, llvm::StringRef> fPendingRdicts;; 635 void RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent);; 636 void LoadPCM(std::string pcmFileNameFullPath);; 637 void LoadPCMImpl(TFile &pcmFile);; 638 ; 639 void InitRootmapFile(const char *name);; 640 int ReadRootmapFile(const char *rootmapfile, TUniqueString* uniqueString = nullptr);; 641 Bool_t HandleNewTransaction(const cling::Transaction &T);; 642 bool IsClassAutoLoadingEnabled() const;; 643 void ProcessClassesToUpdate();; 644 cling::Interpreter *GetInterpreterImpl() const { return fInterpreter.get(); }; 645 cling::MetaProcessor *GetMetaProcessorImpl()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:35009,Load,LoadPCM,35009,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,2,['Load'],"['LoadPCM', 'LoadPCMImpl']"
Performance,"xy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; std::map< Int_t, AnaIntConfig > _anaIntMap;  ! Map for analytical integration codes ;  ; RooAICRegistry _anaReg;  ! Registry for analytical integration codes ;  ; RooObjCacheManager _cacheMgr;  ; Int_t _ipOrder;  The cache manager. ;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedPdf.html:72211,cache,cache,72211,doc/master/classRooAbsCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedPdf.html,1,['cache'],['cache']
Performance,"xy > p)Definition TTreeReader.h:281; TTreeReader::EEntryStatusEEntryStatusDefinition TTreeReader.h:152; TTreeReader::kEntryNotFound@ kEntryNotFoundthe tree entry number does not existDefinition TTreeReader.h:156; TTreeReader::kIndexedFriendNoMatch@ kIndexedFriendNoMatchA friend with TTreeIndex doesn't have an entry for this index.Definition TTreeReader.h:162; TTreeReader::kEntryUnknownError@ kEntryUnknownErrorLoadTree return less than -6, likely a 'newer' error code.Definition TTreeReader.h:164; TTreeReader::kEntryDictionaryError@ kEntryDictionaryErrorproblem reading dictionary info from treeDefinition TTreeReader.h:159; TTreeReader::kEntryChainSetupError@ kEntryChainSetupErrorproblem in accessing a chain element, e.g. file without the treeDefinition TTreeReader.h:157; TTreeReader::kMissingBranchWhenSwitchingTree@ kMissingBranchWhenSwitchingTreeA branch was not found when switching to the next TTree in the chain.Definition TTreeReader.h:163; TTreeReader::kEntryNotLoaded@ kEntryNotLoadedno entry has been loaded yetDefinition TTreeReader.h:154; TTreeReader::kEntryBeyondEnd@ kEntryBeyondEndlast entry loop has reached its endDefinition TTreeReader.h:160; TTreeReader::kEntryChainFileError@ kEntryChainFileErrorproblem in opening a chain's fileDefinition TTreeReader.h:158; TTreeReader::kEntryNoTree@ kEntryNoTreethe tree does not existDefinition TTreeReader.h:155; TTreeReader::kEntryBadReader@ kEntryBadReaderOne of the readers was not successfully initialized.Definition TTreeReader.h:161; TTreeReader::kEntryValid@ kEntryValiddata read okayDefinition TTreeReader.h:153; TTreeReader::fSetEntryBaseCallingLoadTreebool fSetEntryBaseCallingLoadTreeTrue if during the LoadTree execution triggered by SetEntryBase.Definition TTreeReader.h:338; TTreeReader::fValuesstd::deque< ROOT::Internal::TTreeReaderValueBase * > fValuesreaders that use our directorDefinition TTreeReader.h:327; TTreeReader::RegisterValueReaderbool RegisterValueReader(ROOT::Internal::TTreeReaderValueBase *reader)Add a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReader_8h_source.html:21866,load,loaded,21866,doc/master/TTreeReader_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html,1,['load'],['loaded']
Performance,"xyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooNumCdf.h>. Inheritance diagram for RooNumCdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooNumCdf() [1/2]. RooNumCdf::RooNumCdf ; (; const char * ; name, . const char * ; title, . RooAbsPdf & ; _pdf, . RooRealVar & ; _x, . const char * ; bname = ""cache"" . ). Construct a cumulative distribution function from given input p.d.f over observable x. ; using a numeric sampling algorithm. Use binning named 'bname' to control sampling granularity ; Definition at line 44 of file RooNumCdf.cxx. ◆ RooNumCdf() [2/2]. RooNumCdf::RooNumCdf ; (; const RooNumCdf & ; other, . const char * ; name = nullptr . ). inline . Definition at line 20 of file RooNumCdf.h. Member Function Documentation. ◆ Class(). static TClass * RooNumCdf::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooNumCdf::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooNumCdf::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 29 of file RooNumCdf.h. ◆ clone(). TObject * RooNumCdf::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 21 of file RooNumCdf.h. ◆ DeclFileNa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumCdf.html:64076,cache,cache,64076,doc/master/classRooNumCdf.html,https://root.cern,https://root.cern/doc/master/classRooNumCdf.html,1,['cache'],['cache']
Performance,"xyxIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumRunningInt(const char* name, const char* title, RooAbsReal& _func, RooRealVar& _x, const char* binningName = ""cache""); Construct running integral of function '_func' over x_print from; the lower bound on _x to the present value of _x using a numeric; sampling technique. The sampling frequency is controlled by the; binning named 'bname' and a default second order interpolation; is applied to smooth the histogram-based c.d.f. RooNumRunningInt(const RooNumRunningInt& other, const char* name = 0); Copy constructor. ~RooNumRunningInt(); Destructor. const char* inputBaseName() const; Return unique name for RooAbsCachedPdf cache components; constructed from input function name. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill the cache object by calling its calculate() method. RooArgSet* actualObservables(const RooArgSet& nset) const; Return observable in nset to be cached by RooAbsCachedPdf; this is always the x observable that is integrated. RooArgSet* actualParameters(const RooArgSet& nset) const; Return the parameters of the cache created by RooAbsCachedPdf.; These are always the input functions parameter, but never the; integrated variable x. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Create custom cache element for running integral calculations. Double_t evaluate() const; Dummy function that is never called. TObject* clone(const char* newname) const; { return new RooNumRunningInt(*this,newname); }. const char* binningName() const; { return _binningName.c_str() ; }. const char* payloadUniqueSuffix() const; { return func.arg().aggregateCacheUniqueSuffix() ; }. » Last changed: Thu Sep 23 20:00:25 2010 » Last generated: 2010-09-23 20:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNumRunningInt.html:35265,cache,cached,35265,root/html528/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html528/RooNumRunningInt.html,3,['cache'],"['cache', 'cached']"
Performance,"xyxIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumRunningInt(const char* name, const char* title, RooAbsReal& _func, RooRealVar& _x, const char* binningName = ""cache""); Construct running integral of function '_func' over x_print from; the lower bound on _x to the present value of _x using a numeric; sampling technique. The sampling frequency is controlled by the; binning named 'bname' and a default second order interpolation; is applied to smooth the histogram-based c.d.f. RooNumRunningInt(const RooNumRunningInt& other, const char* name = 0); Copy constructor. ~RooNumRunningInt(); Destructor. const char* inputBaseName() const; Return unique name for RooAbsCachedPdf cache components; constructed from input function name. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill the cache object by calling its calculate() method. RooArgSet* actualObservables(const RooArgSet& nset) const; Return observable in nset to be cached by RooAbsCachedPdf; this is always the x observable that is integrated. RooArgSet* actualParameters(const RooArgSet& nset) const; Return the parameters of the cache created by RooAbsCachedPdf.; These are always the input functions parameter, but never the; integrated variable x. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Create custom cache element for running integral calculations. Double_t evaluate() const; Dummy function that is never called. TObject* clone(const char* newname) const; { return new RooNumRunningInt(*this,newname); }. const char* binningName() const; { return _binningName.c_str() ; }. const char* payloadUniqueSuffix() const; { return func.arg().aggregateCacheUniqueSuffix() ; }. » Last changed: Tue Jun 30 14:34:41 2015 » Last generated: 2015-06-30 14:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumRunningInt.html:39896,cache,cached,39896,root/html602/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html602/RooNumRunningInt.html,3,['cache'],"['cache', 'cached']"
Performance,"xyxIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumRunningInt(const char* name, const char* title, RooAbsReal& _func, RooRealVar& _x, const char* binningName = ""cache""); Construct running integral of function '_func' over x_print from; the lower bound on _x to the present value of _x using a numeric; sampling technique. The sampling frequency is controlled by the; binning named 'bname' and a default second order interpolation; is applied to smooth the histogram-based c.d.f. RooNumRunningInt(const RooNumRunningInt& other, const char* name = 0); Copy constructor. ~RooNumRunningInt(); Destructor. const char* inputBaseName() const; Return unique name for RooAbsCachedPdf cache components; constructed from input function name. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill the cache object by calling its calculate() method. RooArgSet* actualObservables(const RooArgSet& nset) const; Return observable in nset to be cached by RooAbsCachedPdf; this is always the x observable that is integrated. RooArgSet* actualParameters(const RooArgSet& nset) const; Return the parameters of the cache created by RooAbsCachedPdf.; These are always the input functions parameter, but never the; integrated variable x. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Create custom cache element for running integral calculations. Double_t evaluate() const; Dummy function that is never called. TObject* clone(const char* newname) const; { return new RooNumRunningInt(*this,newname); }. const char* binningName() const; { return _binningName.c_str() ; }. const char* payloadUniqueSuffix() const; { return func.arg().aggregateCacheUniqueSuffix() ; }. » Last changed: Tue Mar 10 17:18:18 2015 » Last generated: 2015-03-10 17:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumRunningInt.html:38392,cache,cached,38392,root/html534/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html534/RooNumRunningInt.html,3,['cache'],"['cache', 'cached']"
Performance,"x . ). private . Build histograms, profiles and graphs needed for this run. ; Definition at line 102 of file TProofBenchRunCPU.cxx. ◆ Class(). static TClass * TProofBenchRunCPU::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TProofBenchRunCPU::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TProofBenchRunCPU::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 133 of file TProofBenchRunCPU.h. ◆ DeclFileName(). static const char * TProofBenchRunCPU::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 133 of file TProofBenchRunCPU.h. ◆ DeleteParameters(). Int_t TProofBenchRunCPU::DeleteParameters ; (; ). protected . Delete parameters set for this run. ; Definition at line 704 of file TProofBenchRunCPU.cxx. ◆ DrawPerfPlots(). void TProofBenchRunCPU::DrawPerfPlots ; (; ). Draw Performance plots. ; Definition at line 620 of file TProofBenchRunCPU.cxx. ◆ FillPerfStatPerfPlots(). void TProofBenchRunCPU::FillPerfStatPerfPlots ; (; TTree * ; t, . Int_t ; nactive . ). protected . Definition at line 542 of file TProofBenchRunCPU.cxx. ◆ GetCanvas(). TCanvas * TProofBenchRunCPU::GetCanvas ; (; ); const. inline . Definition at line 128 of file TProofBenchRunCPU.h. ◆ GetDebug(). Int_t TProofBenchRunCPU::GetDebug ; (; ); const. inline . Definition at line 125 of file TProofBenchRunCPU.h. ◆ GetDirProofBench(). TDirectory * TProofBenchRunCPU::GetDirProofBench ; (; ); const. inline . Definition at line 126 of file TProofBenchRunCPU.h. ◆ GetDraw(). Int_t TProofBenchRunCPU::GetDraw ; (; ); const. inline . Definition at line 124 of file TProofBenchRunCPU.h. ◆ GetHistType(). TPBHistType * TProofBenchRunCPU::GetHistType ; (; ); const. inline . Definition at line 117 of file TProofBenchRunCPU.h. ◆ GetListPerfPlots(). TList * TProofBenchRunCPU::GetListPerfPlots ; (; ); const. inline . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofBenchRunCPU.html:15169,Perform,Performance,15169,doc/master/classTProofBenchRunCPU.html,https://root.cern,https://root.cern/doc/master/classTProofBenchRunCPU.html,1,['Perform'],['Performance']
Performance,"y &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static Int_t GetNumBins (const RooArgSet &vars);  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  . Protected Attributes; RooDataHist _dataSet;  ; RooListProxy _dataVars;  The RooRealVars. ;  ; RooObjCacheManager _normIntMgr;  ! The integration cache manager ;  ; Int_t _numBins = 0;  ; NumBins _numBinsPerDim;  ; RooListProxy _paramSet;  interpolation parameters ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classParamHistFunc.html:57832,cache,cache,57832,doc/master/classParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html,1,['cache'],['cache']
Performance,"y (including subdirectories). A new key is created in the KEYS linked list for each object. The list of keys is then saved on the file (via WriteKeys) as a single data record. For values of opt see TObject::Write(). The directory header info is rewritten on the directory header record. The linked list of FREE segments is written. The file header is written (bytes 1->fBEGIN). ; Reimplemented from TDirectoryFile.; Reimplemented in TSQLFile, TXMLFile, and TParallelMergingFile.; Definition at line 2436 of file TFile.cxx. ◆ WriteBuffer(). Bool_t TFile::WriteBuffer ; (; const char * ; buf, . Int_t ; len . ). virtual . Write a buffer to the file. ; This is the basic low level write operation. Returns kTRUE in case of failure. ; Reimplemented in TSQLFile, TXMLFile, TDCacheFile, TNetFile, TDavixFile, TXNetFile, and TNetXNGFile.; Definition at line 2476 of file TFile.cxx. ◆ WriteBufferViaCache(). Int_t TFile::WriteBufferViaCache ; (; const char * ; buf, . Int_t ; len . ). protected . Write buffer via cache. ; Returns 0 if cache is not active, 1 in case write via cache was successful, 2 in case write via cache failed. ; Definition at line 2519 of file TFile.cxx. ◆ WriteFree(). void TFile::WriteFree ; (; ). virtual . Write FREE linked list on the file. ; The linked list of FREE segments (fFree) is written as a single data record. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 2543 of file TFile.cxx. ◆ WriteHeader(). void TFile::WriteHeader ; (; ). virtual . Write File Header. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 2615 of file TFile.cxx. ◆ WriteProcessID(). UShort_t TFile::WriteProcessID ; (; TProcessID * ; pid). virtual . Check if the ProcessID pidd is already in the file, if not, add it and return the index number in the local file list. ; Definition at line 3763 of file TFile.cxx. ◆ WriteStreamerInfo(). void TFile::WriteStreamerInfo ; (; ). virtual . Write the list of TStreamerInfo as a single object in this file The class Streamer des",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:101326,cache,cache,101326,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,1,['cache'],['cache']
Performance,"y *fTracks;; fTracks->BypassStreamer(kFALSE); // use the member Streamer; When the kBypassStreamer bit is set, the automatically generated Streamercan call directly the method TClass::WriteBuffer. Bypassing the Streamer improves the performance when writing/reading the objects in the TClonesArray. However, the drawback is when a TClonesArray is written with split=0 bypassing the Streamer, the StreamerInfoof the class in the array being optimized, one cannot later use the TClonesArray with split > 0. For example, there is a problem with the following scenario: a class Foo has a TClonesArray of Bar objects the Foo object is written with split=0 to Tree T1. In this case the StreamerInfo for the class Bar is created in optimized mode in such a way that data members of the same type are written as an array improving the I/O performance. In a new program, T1 is read and a new Tree T2 is created with the object Foo in split > 1.; When the T2branch is created, the StreamerInfo for the class Bar is created with no optimization (mandatory for the split mode). The optimized Bar StreamerInfo is going to be used to read the TClonesArray in T1. The result will be Bar objects with data member values not in the right sequence. The solution to this problem is to call BypassStreamer(kFALSE) for the TClonesArray. In this case, the normal Bar::Streamer function will be called. The Bar::Streamer function works OK independently if the Bar StreamerInfohad been generated in optimized mode or not.; 11.4 Pointers and References in Persistency; An object pointer as a data member presents a challenge to the streaming software. If the object pointed to is saved every time, it could create circular dependencies and consume a large amount of disk space. The network of references must be preserved on disk and recreated upon reading the file.; If you use independent I/O operations for pointers and their referenced objects you can use the TRef class. Later in this section is an example that compares",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:477730,optimiz,optimization,477730,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['optimiz'],['optimization']
Performance,"y = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static RooArgSet _emptySet;  Supports named argument constructor. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Private Member Functions;  RooChi2Var (const char *name, const char *title, RooAbsReal &func, RooDataHist &data, const RooArgSet &projDeps, FuncMode funcMode, RooAbsTestStatistic::Configuration const &cfg, RooDataHist::ErrorType etype);  . Additional Inherited Members;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:65528,cache,cache,65528,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['cache'],['cache']
Performance,"y = kFALSE) const; Bool_tisSelectedComp() const; virtual Bool_tisValid() const; virtual Bool_tisValidReal(Double_t value, Bool_t printError = kFALSE) const; voidmakeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tmatchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tmatchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tmatchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tmatchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tmatchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidplotOnCompSelect(RooArgSet* selNodes) const; RooPlot*plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tplotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidselectComp(Bool_t flag); virtual voidselectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidselectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidsetTreeB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsReal.html:28126,optimiz,optimizeDirtyHook,28126,root/html534/RooAbsReal.html,https://root.cern,https://root.cern/root/html534/RooAbsReal.html,3,['optimiz'],['optimizeDirtyHook']
Performance,"y = kFALSE) const; Bool_tisSelectedComp() const; virtual Bool_tisValid() const; virtual Bool_tisValidReal(Double_t value, Bool_t printError = kFALSE) const; voidmakeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tmatchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tmatchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tmatchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tmatchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tmatchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; RooPlot*plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tplotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidselectComp(Bool_t flag); virtual voidselectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidselectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:25832,optimiz,optimizeDirtyHook,25832,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,4,['optimiz'],['optimizeDirtyHook']
Performance,"y GetListOfMethods(). TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Stre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClass.html:34503,load,loaded,34503,root/html534/TClass.html,https://root.cern,https://root.cern/root/html534/TClass.html,1,['load'],['loaded']
Performance,"y a weight w. ;  ; void Copy (TObject &hnew) const override;  Copy this to newth1. ;  ; TClass * IsA () const override;  ; TH1F & operator= (const TH1F &h1);  Operator =. ;  ; void Reset (Option_t *option="""") override;  Reset. ;  ; void SetBinsLength (Int_t n=-1) override;  Set total number of bins including under/overflow Reallocate bin contents array. ;  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TH1;  ~TH1 () override;  Histogram default destructor. ;  ; virtual Bool_t Add (const TH1 *h, const TH1 *h2, Double_t c1=1, Double_t c2=1);  Replace contents of this histogram by the addition of h1 and h2. ;  ; virtual Bool_t Add (const TH1 *h1, Double_t c1=1);  Performs the operation: this = this + c1*h1 If errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual Bool_t Add (TF1 *h1, Double_t c1=1, Option_t *option="""");  Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Double_t &advalue) const;  Same function as above but returning also the test statistic value. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Option_t *option="""") const;  Statistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling 2 sample test. ;  ; void Browse (TBrowser *b) override;  Browse the Histogram object. ;  ; virtual Int_t BufferEmpty (Int_t action=0);  Fill histogram with all entries in the buffer. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for comparing weighted and unweighted histograms. ;  ; virtual Double_t Chi2TestX (const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1F.html:2396,Perform,Performs,2396,doc/master/classTH1F.html,https://root.cern,https://root.cern/doc/master/classTH1F.html,1,['Perform'],['Performs']
Performance,"y accurate, because our Dyld implementation might find; 7237 // a match in location a/b/c.so and if we return just c.so ROOT might; 7238 // resolve it to y/z/c.so and there we might not be ABI compatible.; 7239 // FIXME: Teach the users of GetSharedLibDeps to work with full paths.; 7240 if (!found.empty()) {; 7241 std::string cand = llvm::sys::path::filename(found).str();; 7242 if (!DedupSet.insert(cand).second); 7243 continue;; 7244 ; 7245 Result += cand + ' ';; 7246 }; 7247 }; 7248 ; 7249 return Result;; 7250}; 7251 ; 7252static bool hasParsedRootmapForLibrary(llvm::StringRef lib); 7253{; 7254 // Check if we have parsed a rootmap file.; 7255 llvm::SmallString<256> rootmapName;; 7256 if (!lib.startswith(""lib"")); 7257 rootmapName.append(""lib"");; 7258 ; 7259 rootmapName.append(llvm::sys::path::filename(lib));; 7260 llvm::sys::path::replace_extension(rootmapName, ""rootmap"");; 7261 ; 7262 if (gCling->GetRootMapFiles()->FindObject(rootmapName.c_str())); 7263 return true;; 7264 ; 7265 // Perform a last resort by dropping the lib prefix.; 7266 llvm::StringRef rootmapNameNoLib = rootmapName.str();; 7267 if (rootmapNameNoLib.consume_front(""lib"")); 7268 return gCling->GetRootMapFiles()->FindObject(rootmapNameNoLib.data());; 7269 ; 7270 return false;; 7271}; 7272 ; 7273static bool hasPrecomputedLibraryDeps(llvm::StringRef lib); 7274{; 7275 if (gCling->HasPCMForLibrary(lib.data())); 7276 return true;; 7277 ; 7278 return hasParsedRootmapForLibrary(lib);; 7279}; 7280 ; 7281////////////////////////////////////////////////////////////////////////////////; 7282/// Get the list a libraries on which the specified lib depends. The; 7283/// returned string contains as first element the lib itself.; 7284/// Returns 0 in case the lib does not exist or does not have; 7285/// any dependencies. If useDyld is true, we iterate through all available; 7286/// libraries and try to construct the dependency chain by resolving each; 7287/// symbol.; 7288 ; 7289const char* TCling::GetSharedLibDeps(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:284274,Perform,Perform,284274,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Perform'],['Perform']
Performance,"y arrays A,Z and WMAT, having an unique id. ;  ; TGeoMaterial * Mixture (const char *name, Float_t *a, Float_t *z, Double_t dens, Int_t nelem, Float_t *wmat, Int_t uid);  Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem materials defined by arrays A,Z and WMAT, having an unique id. ;  ; void ModifiedPad () const;  Send ""Modified"" signal to painter. ;  ; void Node (const char *name, Int_t nr, const char *mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Double_t *upar, Int_t npar=0);  Create a node called <name_nr> pointing to the volume called <name> as daughter of the volume called <mother> (gspos). ;  ; void Node (const char *name, Int_t nr, const char *mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t *upar, Int_t npar=0);  Create a node called <name_nr> pointing to the volume called <name> as daughter of the volume called <mother> (gspos). ;  ; void OptimizeVoxels (const char *filename=""tgeovox.C"");  Optimize voxelization type for all volumes. Save best choice in a macro. ;  ; void PopDummy (Int_t ipop=9999);  ; Bool_t PopPath ();  ; Bool_t PopPath (Int_t index);  ; Bool_t PopPoint ();  ; Bool_t PopPoint (Int_t index);  ; void PrintOverlaps () const;  Prints the current list of overlaps. ;  ; Int_t PushPath (Int_t startlevel=0);  ; Int_t PushPoint (Int_t startlevel=0);  ; void RandomPoints (const TGeoVolume *vol, Int_t npoints=10000, Option_t *option="""");  Draw random points in the bounding box of a volume. ;  ; void RandomRays (Int_t nrays=1000, Double_t startx=0, Double_t starty=0, Double_t startz=0, const char *target_vol=nullptr, Bool_t check_norm=kFALSE);  Randomly shoot nrays and plot intersections with surfaces for current top node. ;  ; void RefreshPhysicalNodes (Bool_t lock=kTRUE);  Refresh physical nodes to reflect the actual geometry paths after alignment was applied. ;  ; void RegisterMatrix (const TGeoMatrix *matrix);  Register a matrix to the list of matrices. ;  ; void RemoveMaterial (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:43805,Optimiz,Optimize,43805,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['Optimiz'],['Optimize']
Performance,"y axis range for it ;  ratioplot4.C Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot4.py Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot5.C Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot5.py Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot6.C Example showing a fit residual plot, where the separation margin has been set to 0 ;  ratioplot6.py Example showing a fit residual plot, where the separation margin has been set to 0 ;  ratioplotOld.CExample displaying two histograms and their ratio ;  rebin.C Rebin a variable bin-width histogram ;  reverseaxis.C Example showing an histogram with reverse axis ;  sparsehist.CEvaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension ;  statsEditing.C Edit statistics box ;  testSmooth.C Histogram smoothing ;  th2polyBoxes.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly) ;  th2polyEurope.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it ;  th2polyHoneycomb.C This tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly) ;  th2polyUSA.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option ;  thstack2palettecolor.C Palette coloring for 2D histograms' stack is activated thanks to the option PFC (Palette Fill Color) ;  thstackpalettecolor.C Palette coloring for histograms' stack is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  tprofile2polyRealistic.C Different charges depending on region ;  tprofile2polyRealisticModuleErr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:124582,perform,performance,124582,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,3,['perform'],['performance']
Performance,"y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. TH1(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins); Normal constructor for variable bin size histograms. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. TH1(const TH1& ); Copy constructor.; The list of functions is not copied. (Use Clone if needed). Bool_t AddDirectoryStatus(); static function: cannot be inlined on Windows/NT. void Browse(TBrowser* b); Browe the Histogram object. void Build(); Creates histogram basic data structure. Bool_t Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1; if errors are defined (see TH1::Sumw2), errors are also recalculated. By default, the function is computed at the centre of the bin.; if option ""I"" is specified (1-d histogram only), the integral of the; function in each bin is used instead of the value of the function at; the centre of the bin.; Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Add. The function return kFALSE if the Add operation failed. Bool_t Add(const TH1* h1, Double_t c1 = 1); Performs the operation: this = this + c1*h1; if errors are defined (see TH1::Sumw2), errors are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set.; Note also that adding histogram with labels is not supported, histogram will be; added merging them by bin number independen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:42093,Perform,Performs,42093,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,2,['Perform'],['Performs']
Performance,"y cheap to copy and it's possible to both pass them to (or move them into) functions and to return them from functions. However, in general each dataframe node will have a different C++ type, which includes all available compile-time information about what that node does. One way to cope with this complication is to use template functions and/or C++14 auto return types: template <typename RDF>; auto ApplySomeFilters(RDF df); {; return df.Filter(""x > 0"").Filter([](int y) { return y < 0; }, {""y""});; }; A possibly simpler, C++11-compatible alternative is to take advantage of the fact that any dataframe node can be converted (implicitly or via an explicit cast) to the common type ROOT::RDF::RNode: // a function that conditionally adds a Range to an RDataFrame node.; RNode MaybeAddRange(RNode df, bool mustAddRange); {; return mustAddRange ? df.Range(1) : df;; }; // use as :; ROOT::RDataFrame df(10);; auto maybeRangedDF = MaybeAddRange(df, true);; The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function ROOT.RDF.AsRNode. Storing RDataFrame objects in collections; ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a std::vector<RNode> or a std::map<std::string, RNode>:; std::vector<ROOT::RDF::RNode> dfs;; dfs.emplace_back(ROOT::RDataFrame(10));; dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));. Executing callbacks every N events; It's possible to schedule execution of arbitrary functions (callbacks) during the event loop. Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running, drawing a partially-filled histogram every time a certain number of new entries is processed, or displaying a progress bar while the event loop runs.; For example one can draw an up-to-date version of a result histogram every",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:59335,perform,performance,59335,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['perform'],['performance']
Performance,"y corresponding to major and minor number.Definition TTree.cxx:5927; TTree::MergeTreesstatic TTree * MergeTrees(TList *list, Option_t *option="""")Static function merging the trees in the TList into a new tree.Definition TTree.cxx:6851; TTree::MemoryFullbool MemoryFull(Int_t nbytes)Check if adding nbytes to memory we are still below MaxVirtualsize.Definition TTree.cxx:6837; TTree::GetReadEntryvirtual Long64_t GetReadEntry() constDefinition TTree.h:549; TTree::GetListOfBranchesvirtual TObjArray * GetListOfBranches()Definition TTree.h:528; TTree::fZipBytesLong64_t fZipBytesTotal number of bytes in all branches after compression.Definition TTree.h:87; TTree::GetTreevirtual TTree * GetTree() constDefinition TTree.h:557; TTree::fTransientBufferTBuffer * fTransientBuffer! Pointer to the current transient buffer.Definition TTree.h:138; TTree::SetEntryListvirtual void SetEntryList(TEntryList *list, Option_t *opt="""")Set an EntryList.Definition TTree.cxx:9046; TTree::Notifybool Notify() overrideFunction called when loading a new class library.Definition TTree.cxx:7033; TTree::AddZipBytesvirtual void AddZipBytes(Int_t zip)Definition TTree.h:332; TTree::LoadTreevirtual Long64_t LoadTree(Long64_t entry)Set current entry.Definition TTree.cxx:6473; TTree::ReadFilevirtual Long64_t ReadFile(const char *filename, const char *branchDescriptor="""", char delimiter=' ')Create or simply read branches from filename.Definition TTree.cxx:7564; TTree::GetAliasvirtual const char * GetAlias(const char *aliasName) constReturns the expanded value of the alias. Search in the friends if any.Definition TTree.cxx:5226; TTree::SetIOFeaturesROOT::TIOFeatures SetIOFeatures(const ROOT::TIOFeatures &)Provide the end-user with the ability to enable/disable various experimental IO features for this TTr...Definition TTree.cxx:9130; TTree::CreateBasketvirtual TBasket * CreateBasket(TBranch *)Create a basket for this tree and given branch.Definition TTree.cxx:3731; TTree::fUserInfoTList * fUserInfopointer to a li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:454190,load,loading,454190,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['load'],['loading']
Performance,"y entries: An event from the same category as in the proto data is created for each event in the proto data. See RooAbsPdf::generate(const RooArgSet&,const RooDataSet&,Int_t,bool,bool,bool) const.; No proto data: A category is chosen randomly. NoteThis requires that the PDFs building the simultaneous are extended. In this way, the relative probability of each category can be calculated from the number of events in each category. PyROOT; Some member functions of RooSimultaneous that take a RooCmdArg as argument also support keyword arguments. So far, this applies to RooSimultaneous::plotOn. For example, the following code is equivalent in PyROOT: # Directly passing a RooCmdArg:; pdfSim.plotOn(frame, ROOT.RooFit.Slice(sample,""control""), ROOT.RooFit.ProjWData(sampleSet, combData)); ; # With keyword arguments:; simPdf.plotOn(frame, Slice=(sample, ""control""), ProjWData=(sampleSet, combData)). Definition at line 41 of file RooSimultaneous.h. Classes; class  CacheElem;  ; struct  InitializationOutput;  Internal struct used for initialization. More...;  . Public Member Functions;  RooSimultaneous ();  ;  RooSimultaneous (const char *name, const char *title, const RooArgList &pdfList, RooAbsCategoryLValue &indexCat);  Constructor from index category and full list of PDFs. ;  ;  RooSimultaneous (const char *name, const char *title, RooAbsCategoryLValue &indexCat);  Constructor with index category. ;  ;  RooSimultaneous (const char *name, const char *title, RooFit::Detail::FlatMap< std::string, RooAbsPdf * > const &pdfMap, RooAbsCategoryLValue &inIndexCat);  For internal use in RooFit. ;  ;  RooSimultaneous (const char *name, const char *title, std::map< std::string, RooAbsPdf * > pdfMap, RooAbsCategoryLValue &inIndexCat);  ;  RooSimultaneous (const RooSimultaneous &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooSimultaneous () override;  Destructor. ;  ; bool addPdf (const RooAbsPdf &pdf, const char *catLabel);  Associate given PDF with index category state la",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimultaneous.html:2340,Cache,CacheElem,2340,doc/master/classRooSimultaneous.html,https://root.cern,https://root.cern/doc/master/classRooSimultaneous.html,1,['Cache'],['CacheElem']
Performance,"y expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class RooAddGenContext;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOpt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:76045,Cache,CacheMode,76045,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['Cache'],['CacheMode']
Performance,"y from the file to memory.Definition TChain.cxx:1002; TChain::SetPacketSizevirtual void SetPacketSize(Int_t size=100)Set number of entries per packet for parallel root.Definition TChain.cxx:2991; TChain::fTreeNumberInt_t fTreeNumber! Current Tree number in fTreeOffset tableDefinition TChain.h:38; TChain::Lookupvoid Lookup(bool force=false)Check / locate the files in the chain.Definition TChain.cxx:1760; TChain::GetLeafTLeaf * GetLeaf(const char *branchname, const char *leafname) overrideReturn a pointer to the leaf name in the current tree.Definition TChain.cxx:1078; TChain::kProofLite@ kProofLiteDefinition TChain.h:64; TChain::kAutoDelete@ kAutoDeleteDefinition TChain.h:62; TChain::kProofUptodate@ kProofUptodateDefinition TChain.h:63; TChain::kGlobalWeight@ kGlobalWeightDefinition TChain.h:61; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollectionCollection abstract base class.Definition TCollection.h:65; TCutA specialized string object used for TTree selections.Definition TCut.h:25; TDirectoryFile::GetTObject * Get(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TDirectory::TContextTDirectory::TContext keeps track and restore the current directory.Definition TDirectory.h:89; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::GetListvirtual TList * GetList() constDefinition TDirectory.h:222; TDirectory::Appendvirtual void Append(TObject *obj, Bool_t replace=kFALSE)Append object to this directory.Definition TDirectory.cxx:199; TDirectory::GetFilevirtual TFile * GetFile() constDefinition TDirectory.h:220; TDirectory::Removevirtual TObject * Remove(TObject *)Remove an object from the in-memory list.Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:131641,load,load,131641,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['load'],['load']
Performance,"y indices of the RNTuple. ;  ; const Detail::RNTupleMetrics & GetMetrics () const;  ; const RNTupleModel & GetModel ();  ; NTupleSize_t GetNEntries () const;  ; template<typename T > ; RNTupleView< T > GetView (DescriptorId_t fieldId);  ; template<typename T > ; RNTupleView< T > GetView (DescriptorId_t fieldId, std::shared_ptr< T > objPtr);  ; template<typename T > ; RNTupleView< T > GetView (DescriptorId_t fieldId, T *rawPtr);  ; template<typename T > ; RNTupleView< T > GetView (std::string_view fieldName);  Provides access to an individual field that can contain either a scalar value or a collection, e.g. ;  ; template<typename T > ; RNTupleView< T > GetView (std::string_view fieldName, std::shared_ptr< T > objPtr);  ; template<typename T > ; RNTupleView< T > GetView (std::string_view fieldName, T *rawPtr);  ; void LoadEntry (NTupleSize_t index);  Analogous to Fill(), fills the default entry of the model. ;  ; void LoadEntry (NTupleSize_t index, REntry &entry);  Fills a user provided entry after checking that the entry has been instantiated from the ntuple model. ;  ; void PrintInfo (const ENTupleInfo what=ENTupleInfo::kSummary, std::ostream &output=std::cout) const;  Prints a detailed summary of the ntuple, including a list of fields. ;  ; void Show (NTupleSize_t index, std::ostream &output=std::cout);  Shows the values of the i-th entry/row, starting with 0 for the first entry. ;  . Static Public Member Functions; static std::unique_ptr< RNTupleReader > Open (const RNTuple &ntuple, const RNTupleReadOptions &options=RNTupleReadOptions());  ; static std::unique_ptr< RNTupleReader > Open (std::string_view ntupleName, std::string_view storage, const RNTupleReadOptions &options=RNTupleReadOptions());  Open an RNTuple for reading. ;  ; static std::unique_ptr< RNTupleReader > Open (std::unique_ptr< RNTupleModel > model, const RNTuple &ntuple, const RNTupleReadOptions &options=RNTupleReadOptions());  ; static std::unique_ptr< RNTupleReader > Open (std::unique_ptr< RNTupl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html:3276,Load,LoadEntry,3276,doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,1,['Load'],['LoadEntry']
Performance,"y loaded; 1487 if (fState <= kEmulated); 1488 fState = kInterpreted;; 1489 }; 1490 }; 1491 ; 1492 // We need to check if the class it is not fwd declared for the cases where we; 1493 // created a TClass directly in the kForwardDeclared state. Indeed in those cases; 1494 // fClassInfo will always be nullptr.; 1495 if (fState!=kForwardDeclared && !fClassInfo && !TClassEdit::IsArtificial(fName)) {; 1496 ; 1497 if (fState == kHasTClassInit) {; 1498 // If the TClass is being generated from a ROOT dictionary,; 1499 // even though we do not seem to have a CINT dictionary for; 1500 // the class, we will will try to load it anyway UNLESS; 1501 // the class is an STL container (or string).; 1502 // This is because we do not expect the CINT dictionary; 1503 // to be present for all STL classes (and we can handle; 1504 // the lack of CINT dictionary in that cases).; 1505 // However, the cling the dictionary no longer carries; 1506 // an instantiation with it, unless we request the loading; 1507 // here *or* the user explicitly instantiate the template; 1508 // we would not have a ClassInfo for the template; 1509 // instantiation.; 1510 fCanLoadClassInfo = kTRUE;; 1511 // Here we check and grab the info from the rootpcm.; 1512 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 1513 if (proto); 1514 proto->FillTClass(this);; 1515 }; 1516 if (!fHasRootPcmInfo && gInterpreter->CheckClassInfo(fName, /* autoload = */ kTRUE)) {; 1517 gInterpreter->SetClassInfo(this, kFALSE, silent); // sets fClassInfo pointer; 1518 if (fClassInfo) {; 1519 // This should be moved out of GetCheckSum itself however the last time; 1520 // we tried this cause problem, in particular in the end-of-process operation.; 1521 // fCheckSum = GetCheckSum(kLatestCheckSum);; 1522 } else {; 1523 if (!fClassInfo) {; 1524 if (IsZombie()) {; 1525 TClass::RemoveClass(this);; 1526 return;; 1527 }; 1528 }; 1529 }; 1530 }; 1531 }; 1532 if (!silent && (!fClassInfo && !fCanLoadClassInfo) && !isStl && !TClassEdit::IsA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:58205,load,loading,58205,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loading']
Performance,"y loaded; 1554 if (fState <= kEmulated); 1555 fState = kInterpreted;; 1556 }; 1557 }; 1558 ; 1559 // We need to check if the class it is not fwd declared for the cases where we; 1560 // created a TClass directly in the kForwardDeclared state. Indeed in those cases; 1561 // fClassInfo will always be nullptr.; 1562 if (fState!=kForwardDeclared && !fClassInfo && !TClassEdit::IsArtificial(fName)) {; 1563 ; 1564 if (fState == kHasTClassInit) {; 1565 // If the TClass is being generated from a ROOT dictionary,; 1566 // even though we do not seem to have a CINT dictionary for; 1567 // the class, we will will try to load it anyway UNLESS; 1568 // the class is an STL container (or string).; 1569 // This is because we do not expect the CINT dictionary; 1570 // to be present for all STL classes (and we can handle; 1571 // the lack of CINT dictionary in that cases).; 1572 // However, the cling the dictionary no longer carries; 1573 // an instantiation with it, unless we request the loading; 1574 // here *or* the user explicitly instantiate the template; 1575 // we would not have a ClassInfo for the template; 1576 // instantiation.; 1577 fCanLoadClassInfo = kTRUE;; 1578 // Here we check and grab the info from the rootpcm.; 1579 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 1580 if (proto); 1581 proto->FillTClass(this);; 1582 }; 1583 if (!fHasRootPcmInfo && gInterpreter->CheckClassInfo(fName, /* autoload = */ kTRUE)) {; 1584 gInterpreter->SetClassInfo(this, kFALSE, silent); // sets fClassInfo pointer; 1585 if (fClassInfo) {; 1586 // This should be moved out of GetCheckSum itself however the last time; 1587 // we tried this cause problem, in particular in the end-of-process operation.; 1588 // fCheckSum = GetCheckSum(kLatestCheckSum);; 1589 } else {; 1590 if (!fClassInfo) {; 1591 if (IsZombie()) {; 1592 TClass::RemoveClass(this);; 1593 return;; 1594 }; 1595 }; 1596 }; 1597 }; 1598 }; 1599 if (!silent && (!fClassInfo && !fCanLoadClassInfo) && !isStl && !TClassEdit::IsA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:60956,load,loading,60956,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loading']
Performance,"y locked by another thread, and that other thread is trying to access a resource that has already been locked by the first thread. In this situation, neither thread is able to progress; they are deadlocked.; A multiprocessor is a hardware system with multiple processors or multiple, simultaneous execution units. Examples can be found at http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html (the thread authors’ web site - Jörn Adamczewski and Marc Hemberger). 24 PROOF: Parallel Processing; ; The Parallel ROOT Facility, PROOF, is an extension of ROOT allowing transparent analysis of large sets of ROOT files in parallel on remote computer clusters or multi-core computers. The main design goals for the PROOF system are:; Transparency : there should be as little difference as possible between a local ROOT based analysis session and a remote parallel PROOF session, both being interactive and giving the same results.; Scalability : the basic architecture should not put any implicit limitations on the number of computers that can be used in parallel.; Adaptability : the system should be able to adapt itself to variations in the remote environment (changing load on the cluster nodes, network interruptions, etc.).; Being an extension of the ROOT system, PROOF is designed to work on objects in ROOT data stores, though, for the time being, it mainly addresses the case of TTree based object collections.; PROOF is primarily meant as an interactive alternative to batch systems for Central Analysis Facilities and departmental workgroups (Tier-2’s). However, thanks to a multi-tier architecture allowing multiple levels of masters, it can be easily adapted to wide range virtual clusters distributed over geographically separated domains and heterogeneous machines (GRIDs).; While pure interactivity might not always be possible when performing a complicated analysis on a very large data set, PROOF still tries to give the user the interactive experience with something we call “in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1125458,Scalab,Scalability,1125458,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Scalab'],['Scalability']
Performance,"y must be dimensioned to the size of the existing parameters) ;  ; const ROOT::Minuit2::MnUserParameterState & State ();  return the minimizer state (containing values, step size , etc..) ;  ; int VariableIndex (const std::string &name) const override;  get index of variable given a variable given a name return -1 if variable is not found ;  ; std::string VariableName (unsigned int ivar) const override;  get name of variables (override if minimizer support storing of variable names) ;  ; const double * X () const override;  return pointer to X values at the minimum ;  ;  Public Member Functions inherited from ROOT::Math::Minimizer;  Minimizer ();  Default constructor. ;  ;  Minimizer (Minimizer &&)=delete;  ;  Minimizer (Minimizer const &)=delete;  ; virtual ~Minimizer ();  Destructor (no operations). ;  ; double ErrorDef () const;  return the statistical scale used for calculate the error is typically 1 for Chi2 and 0.5 for likelihood minimization ;  ; bool IsValidError () const;  return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit) ;  ; unsigned int MaxFunctionCalls () const;  max number of function calls ;  ; unsigned int MaxIterations () const;  max iterations ;  ; virtual unsigned int NIterations () const;  number of iterations to reach the minimum ;  ; Minimizer & operator= (Minimizer &&)=delete;  ; Minimizer & operator= (Minimizer const &)=delete;  ; virtual MinimizerOptions Options () const;  retrieve the minimizer options (implement derived class if needed) ;  ; double Precision () const;  precision of minimizer in the evaluation of the objective function ( a value <=0 corresponds to the let the minimizer choose its default one) ;  ; int PrintLevel () const;  minimizer configuration parameters ;  ; void SetDefaultOptions ();  reset the default options (defined in MinimizerOptions) ;  ; void SetErrorDef (double up);  set scale for calculating the errors ;  ; void SetExtraOptions (const IOptions &extraOptions);  set o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html:8686,perform,performed,8686,doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,1,['perform'],['performed']
Performance,"y nentries.Definition TTree.cxx:3139; TTree::GetTreevirtual TTree * GetTree() constDefinition TTree.h:557. Definition at line 1278 of file TChain.cxx. ◆ IsA(). TClass * TChain::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TProofChain.; Definition at line 173 of file TChain.h. ◆ LoadBaskets(). Int_t TChain::LoadBaskets ; (; Long64_t ; maxmemory). overridevirtual . Dummy function. ; It could be implemented and load all baskets of all trees in the chain. For the time being use TChain::Merge and TTree::LoadBasket on the resulting tree. ; Reimplemented from TTree.; Definition at line 1296 of file TChain.cxx. ◆ LoadTree(). Long64_t TChain::LoadTree ; (; Long64_t ; entry). overridevirtual . Find the tree which contains entry, and set it as the current tree. ; Returns the entry number in that tree.; The input argument entry is the entry serial number in the whole chain.; In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number is less than zero or too large for the chain.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or the TTree is missing from the file.; -5: Internal error, please report the circumstance when this happen as a ROOT issue.; -6: An error occurred within the notify callback. Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new sub-tree. See TNotifyLink for more information on the notification mechanism.; NoteThis is the only routine which sets the value of fTree to a non-zero pointer. ; Reimplemented from TTree.; Definition at line 1324 of file TChain.cxx. ◆ Lookup(). void TChain::Lookup ; (; bool ; force = false). Check / locate the files in the chain. ; By default only the files not yet looked up are checked. Use force = true to check / re-check every file. ; Definition at line 1760 of file TChain.cxx. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain.html:81488,Load,LoadTree,81488,doc/master/classTChain.html,https://root.cern,https://root.cern/doc/master/classTChain.html,1,['Load'],['LoadTree']
Performance,"y of simultaneous PDF; ConditionalObservables() -- Define projected observables; Verbose() -- Verbose output of GOF framework. RooChi2Var(const char* name, const char* title, RooAbsPdf& pdf, RooDataHist& data, Bool_t extended = kFALSE, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE, RooAbsData::ErrorType = RooDataHist::SumW2); Constructor of a chi2 for given p.d.f. with respect given binned; dataset. If cutRange is specified the calculation of the chi2 is; restricted to that named range. If addCoefRange is specified, the; interpretation of fractions for all component RooAddPdfs that do; not have a frozen range interpretation is set to chosen range; name. If nCPU is greater than one the chi^2 calculation is; paralellized over the specified number of processors. If; interleave is true the partitioning of event over processors; follows a (i % n == i_set) strategy rather than a bulk; partitioning strategy which may result in unequal load balancing; in binned datasets with many (adjacent) zero bins. If; splitCutRange is true the cutRange is used to construct an; individual cutRange for each RooSimultaneous index category state; name cutRange_{indexStateName}. RooChi2Var(const char *name, const char *title, RooAbsReal& func, RooDataHist& hdata,		 const RooArgSet& projDeps, RooChi2Var::FuncMode fmode, const char* cutRange, const char* addCoefRange, 		 Int_t nCPU, Bool_t interleave, Bool_t verbose, Bool_t splitCutRange, RooDataHist::ErrorType etype); Constructor of a chi2 for given p.d.f. with respect given binned; dataset taking the observables specified in projDeps as projected; observables. If cutRange is specified the calculation of the chi2; is restricted to that named range. If addCoefRange is specified,; the interpretation of fractions for all component RooAddPdfs that; do not have a frozen range interpretation is set to chosen range; name. If nCPU is greater",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChi2Var.html:39360,load,load,39360,root/html526/RooChi2Var.html,https://root.cern,https://root.cern/root/html526/RooChi2Var.html,1,['load'],['load']
Performance,"y of simultaneous PDF; ConditionalObservables() -- Define projected observables; Verbose() -- Verbose output of GOF framework. RooChi2Var(const char* name, const char* title, RooAbsPdf& pdf, RooDataHist& data, Bool_t extended = kFALSE, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE, RooAbsData::ErrorType = RooDataHist::SumW2); Constructor of a chi2 for given p.d.f. with respect given binned; dataset. If cutRange is specified the calculation of the chi2 is; restricted to that named range. If addCoefRange is specified, the; interpretation of fractions for all component RooAddPdfs that do; not have a frozen range interpretation is set to chosen range; name. If nCPU is greater than one the chi^2 calculation is; paralellized over the specified number of processors. If; interleave is true the partitioning of event over processors; follows a (i % n == i_set) strategy rather than a bulk; partitioning strategy which may result in unequal load balancing; in binned datasets with many (adjacent) zero bins. If; splitCutRange is true the cutRange is used to construct an; individual cutRange for each RooSimultaneous index category state; name cutRange_{indexStateName}. RooChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataHist& data, const RooArgSet& projDeps, RooChi2Var::FuncMode funcMode, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE, RooAbsData::ErrorType = RooDataHist::SumW2); Constructor of a chi2 for given p.d.f. with respect given binned; dataset taking the observables specified in projDeps as projected; observables. If cutRange is specified the calculation of the chi2; is restricted to that named range. If addCoefRange is specified,; the interpretation of fractions for all component RooAddPdfs that; do not have a frozen range interpreta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooChi2Var.html:39944,load,load,39944,root/html528/RooChi2Var.html,https://root.cern,https://root.cern/root/html528/RooChi2Var.html,3,['load'],['load']
Performance,"y owned proxies upon creation. After registration, this arg will forward pointer changes from serverRedirects and updates in cached normalization sets to the proxies immediately after they occur. The proxied argument is also added as value and/or shape server ; Definition at line 1329 of file RooAbsArg.cxx. ◆ registerProxy() [2/3]. void RooAbsArg::registerProxy ; (; RooListProxy & ; proxy). protected . Register an RooListProxy in the proxy list. ; This function is called by owned proxies upon creation. After registration, this arg will forward pointer changes from serverRedirects and updates in cached normalization sets to the proxies immediately after they occur. ; Definition at line 1408 of file RooAbsArg.cxx. ◆ registerProxy() [3/3]. void RooAbsArg::registerProxy ; (; RooSetProxy & ; proxy). protected . Register an RooSetProxy in the proxy list. ; This function is called by owned proxies upon creation. After registration, this arg will forward pointer changes from serverRedirects and updates in cached normalization sets to the proxies immediately after they occur. ; Definition at line 1373 of file RooAbsArg.cxx. ◆ removeServer(). void RooAbsArg::removeServer ; (; RooAbsArg & ; server, . bool ; force = false . ). Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ; Definition at line 378 of file RooAbsArg.cxx. ◆ removeStringAttribute(). void RooAbsArg::removeStringAttribute ; (; const Text_t * ; key). Delete a string attribute with a given key. ; Definition at line 266 of file RooAbsArg.cxx. ◆ replaceServer(). void RooAbsArg::replaceServer ; (; RooAbsArg & ; oldServer, . RooAbsArg & ; newServer, . bool ; propValue, . bool ; propShape . ). Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ; WarningThis function should not be used! This method is quite unsafe for many reasons. For once, the new server will be put at the end of the server list, no matt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:93516,cache,cached,93516,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['cache'],['cached']
Performance,"y represented by an integer. RooAbsCategory::lookupName() can be used to retrieve the corresponding state name. There is no limit for the length of the state name.; To not break old code, the old RooCatType interfaces are still available. Whenever possible, the following replacements should be used:; lookupType() \( \rightarrow \) lookupName() / lookupIndex(); typeIterator() \( \rightarrow \) range-based for loop / begin() / end(); isValidIndex(Int_t index) \( \rightarrow \) hasIndex(); isValid(const RooCatType&) \( \rightarrow \) hasIndex() / hasLabel() . Definition at line 33 of file RooAbsCategory.h. Public Types; using value_type = int;  The type used to denote a specific category state. ;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSing",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategory.html:2214,Cache,CacheMode,2214,doc/master/classRooAbsCategory.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategory.html,1,['Cache'],['CacheMode']
Performance,"y this TTree. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Resets the state of this chain. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this chain after a merge (keep the customization but; forget the data). Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. void SetAutoDelete(Bool_t autodel = kTRUE); -- Set the global branch kAutoDelete bit. When LoadTree loads a new Tree, the branches for which; the address is set will have the option AutoDelete set; For more details on AutoDelete, see TBranch::SetAutoDelete. void SetCacheSize(Long64_t cacheSize); Set the cache size of the underlying TTree,; See TTree::SetCacheSize. void ResetBranchAddress(TBranch* ); -- Reset the addresses of the branch. void ResetBranchAddresses(); Reset the addresses of the branches. Int_t SetBranchAddress(const char *bname, void* add, TBranch** ptr); Set branch address. bname is the name of a branch.; add is the address of the branch. Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the add parameter. IMPORTANT REMARK:; In case TChain::SetBranchStatus is called, it must be called; BEFORE calling this function. See TTree::CheckBranchAddressType for the semantic of the return value. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Check if bname is already in the status list, and if not, create a TChainElement object and set its address.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TChain.html:50756,cache,cacheSize,50756,root/html534/TChain.html,https://root.cern,https://root.cern/root/html534/TChain.html,2,['cache'],"['cache', 'cacheSize']"
Performance,"y to instantiate numeric integrators from a given function binding and a given configuration ;  CRooNumIntConfigRooNumIntConfig holds the configuration parameters of the various numeric integrators used by RooRealIntegral ;  CRooNumIntFactoryRooNumIntFactory is a factory to instantiate numeric integrators from a given function binding and a given configuration ;  ►CRooNumRunningIntClass RooNumRunningInt is an implementation of RooAbsCachedReal that represents a running integral ; \[ RI(f(x)) = \int_{xlow}^{x} f(x') dx' \]. that is calculated internally with a numeric technique: The input function is first sampled into a histogram, which is then numerically integrated ;  CRICacheElem;  CRooObjCacheManagerClass RooObjCacheManager is an implementation of class RooCacheManager<RooAbsCacheElement> and specializes in the storage of cache elements that contain RooAbsArg objects ;  CRooParamBinningClass RooParamBinning is an implementation of RooAbsBinning that constructs a binning with a range definition that depends on external RooAbsReal objects ;  CRooParametricStepFunction;  CRooParamHistFunc;  ►CRooPlotA RooPlot is a plot frame and a container for graphics objects within that frame ;  CDrawOpt;  CRooPlotableClass RooPotable is a base class for objects that can be inserted into RooPlots and take advantage of its internal normalization and axis range adjustment features ;  CRooPoissonPoisson pdf ;  CRooPolynomialRooPolynomial implements a polynomial p.d.f of the form ; \[ f(x) = \sum_{i} a_{i} * x^i \]. By default coefficient a_0 is chosen to be 1, as polynomial probability density functions have one degree of freedome less than polynomial functions due to the normalization condition ;  CRooPolyVarClass RooPolyVar is a RooAbsReal implementing a polynomial in terms of a list of RooAbsReal coefficients ; \[f(x) = \sum_{i} a_{i}x \]. Class RooPolyvar implements analytical integrals of all polynomials it can define ;  CRooPrintableRooPlotable is a 'mix-in' base class that d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:98966,cache,cache,98966,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['cache'],['cache']
Performance,"y used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); Read Float16 value. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); Read Double32 value. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferXML does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferXML does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); Write Float16 value. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); Write Double32 value. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h); Read array of Short_t from buffer. Int_t ReadArray(UShort_t*& h); Read array of UShort_t from buffer. Int_t ReadArray(Int_t*& i); Read array of Int_t from buffer. Int_t ReadArray(UInt_t*& i); Read array of UInt_t from buffer. Int_t ReadArray(Long_t*& l); Read array of Long_t from buffer. Int_t ReadArray(ULong_t*& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBufferSQL2.html:30294,optimiz,optimize,30294,root/html530/TBufferSQL2.html,https://root.cern,https://root.cern/root/html530/TBufferSQL2.html,5,['optimiz'],['optimize']
Performance,"y with FCN only fits, when fFitFunc=0); vector<double>fParamsparameter values. Size is total number of parameters; intfStatusminimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const ROOT::Fit::FitResult& ). Copy constructor. ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created. const std::string & MinimizerType() const; minimization quantities ; minimizer type. { return fMinimType; }. bool IsValid() const; True if fit successful, otherwise false. { return fValid; }. bool IsEmpty() const; True if a fit result does not exist (even invalid) with parameter values. { return (fParams.size() == 0); }. double MinFcnValue() const; Return value of the objective function (chi2 or likelihood) used in the fit. { return fVal; }. unsigned int NCalls() const; Number of function calls to find minimum. { return fNCalls; }. double Edm() const; Expected distance from minimum. { return fEdm; }. unsigned int NTotalParameters() const; get total number of parameters. { return fParams.size(); }. unsigned int NPar() const; total number of parameters (abbreviation). { return NTotalParameters(); }. unsigned int NFreeParameters() const; get total",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__FitResult.html:5315,perform,performed,5315,root/html528/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__FitResult.html,1,['perform'],['performed']
Performance,"y(""TClass::Move"",arenaFrom,arenaTo,this);; 4335 }; 4336}; 4337 ; 4338////////////////////////////////////////////////////////////////////////////////; 4339/// Return the list of menu items associated with the class.; 4340 ; 4341TList *TClass::GetMenuList() const {; 4342 if (!fClassMenuList) {; 4343 fClassMenuList = new TList();; 4344 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, const_cast<TClass*>(this)));; 4345 }; 4346 return fClassMenuList;; 4347}; 4348 ; 4349////////////////////////////////////////////////////////////////////////////////; 4350/// Return (create an empty one if needed) the list of functions.; 4351/// The major difference with GetListOfMethod is that this returns; 4352/// the internal type of fMethod and thus can not be made public.; 4353/// It also never 'loads' the content of the list.; 4354 ; 4355TListOfFunctions *TClass::GetMethodList(); 4356{; 4357 if (!fMethod.load()) {; 4358 std::unique_ptr<TListOfFunctions> temp{ new TListOfFunctions(this) };; 4359 TListOfFunctions* expected = nullptr;; 4360 if(fMethod.compare_exchange_strong(expected, temp.get()) ) {; 4361 temp.release();; 4362 }; 4363 }; 4364 return fMethod;; 4365}; 4366 ; 4367 ; 4368////////////////////////////////////////////////////////////////////////////////; 4369/// Return pointer to method without looking at parameters.; 4370/// Does not look in (possible) base classes.; 4371/// Has the side effect of loading all the TMethod object in the list; 4372/// of the class.; 4373 ; 4374TMethod *TClass::GetMethodAny(const char *method); 4375{; 4376 if (!HasInterpreterInfo()) return nullptr;; 4377 return (TMethod*) GetMethodList()->FindObject(method);; 4378}; 4379 ; 4380////////////////////////////////////////////////////////////////////////////////; 4381/// Return pointer to method without looking at parameters.; 4382/// Does look in all base classes.; 4383 ; 4384TMethod *TClass::GetMethodAllAny(const char *method); 4385{; 4386 if (!HasInterpreterInfo()) return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:164840,load,load,164840,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"y(""TClass::Move"",arenaFrom,arenaTo,this);; 4402 }; 4403}; 4404 ; 4405////////////////////////////////////////////////////////////////////////////////; 4406/// Return the list of menu items associated with the class.; 4407 ; 4408TList *TClass::GetMenuList() const {; 4409 if (!fClassMenuList) {; 4410 fClassMenuList = new TList();; 4411 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, const_cast<TClass*>(this)));; 4412 }; 4413 return fClassMenuList;; 4414}; 4415 ; 4416////////////////////////////////////////////////////////////////////////////////; 4417/// Return (create an empty one if needed) the list of functions.; 4418/// The major difference with GetListOfMethod is that this returns; 4419/// the internal type of fMethod and thus can not be made public.; 4420/// It also never 'loads' the content of the list.; 4421 ; 4422TListOfFunctions *TClass::GetMethodList(); 4423{; 4424 if (!fMethod.load()) {; 4425 std::unique_ptr<TListOfFunctions> temp{ new TListOfFunctions(this) };; 4426 TListOfFunctions* expected = nullptr;; 4427 if(fMethod.compare_exchange_strong(expected, temp.get()) ) {; 4428 temp.release();; 4429 }; 4430 }; 4431 return fMethod;; 4432}; 4433 ; 4434 ; 4435////////////////////////////////////////////////////////////////////////////////; 4436/// Return pointer to method without looking at parameters.; 4437/// Does not look in (possible) base classes.; 4438/// Has the side effect of loading all the TMethod object in the list; 4439/// of the class.; 4440 ; 4441TMethod *TClass::GetMethodAny(const char *method); 4442{; 4443 if (!HasInterpreterInfo()) return nullptr;; 4444 return (TMethod*) GetMethodList()->FindObject(method);; 4445}; 4446 ; 4447////////////////////////////////////////////////////////////////////////////////; 4448/// Return pointer to method without looking at parameters.; 4449/// Does look in all base classes.; 4450 ; 4451TMethod *TClass::GetMethodAllAny(const char *method); 4452{; 4453 if (!HasInterpreterInfo()) return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:167591,load,load,167591,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"y(""tmva003"",; output, ""!V:!DrawProgressBar:AnalysisType=Classification"");; ; // Open trees with signal and background events; auto data = TFile::Open(filename.c_str());; auto signal = (TTree *)data->Get(""TreeS"");; auto background = (TTree *)data->Get(""TreeB"");; ; // Add variables and register the trees with the dataloader; auto dataloader = new TMVA::DataLoader(""tmva003_BDT"");; const std::vector<std::string> variables = {""var1"", ""var2"", ""var3"", ""var4""};; for (const auto &var : variables) {; dataloader->AddVariable(var);; }; dataloader->AddSignalTree(signal, 1.0);; dataloader->AddBackgroundTree(background, 1.0);; dataloader->PrepareTrainingAndTestTree("""", """");; ; // Train a TMVA method; factory->BookMethod(dataloader, TMVA::Types::kBDT, ""BDT"", ""!V:!H:NTrees=300:MaxDepth=2"");; factory->TrainAllMethods();; }; ; void tmva003_RReader(); {; // First, let's train a model with TMVA.; const std::string filename = ""http://root.cern/files/tmva_class_example.root"";; train(filename);; ; // Next, we load the model from the TMVA XML file.; RReader model(""tmva003_BDT/weights/tmva003_BDT.weights.xml"");; ; // In case you need a reminder of the names and order of the variables during; // training, you can ask the model for it.; auto variables = model.GetVariableNames();; ; // The model can now be applied in different scenarios:; // 1) Event-by-event inference; // 2) Batch inference on data of multiple events; // 3) Inference as part of an RDataFrame graph; ; // 1) Event-by-event inference; // The event-by-event inference takes the values of the variables as a std::vector<float>.; // Note that the return value is as well a std::vector<float> since the reader; // is also capable to process models with multiple outputs.; auto prediction = model.Compute({0.5, 1.0, -0.2, 1.5});; std::cout << ""Single-event inference: "" << prediction[0] << ""\n\n"";; ; // 2) Batch inference on data of multiple events; // For batch inference, the data needs to be structured as a matrix. For this; // purpose, TM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva003__RReader_8C.html:1505,load,load,1505,doc/master/tmva003__RReader_8C.html,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html,1,['load'],['load']
Performance,"y() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const; const RooAbsReal&xF().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFirstMoment.html:26493,cache,cache,26493,root/html534/RooFirstMoment.html,https://root.cern,https://root.cern/root/html534/RooFirstMoment.html,3,['cache'],['cache']
Performance,"y(). Int_t TBufferIO::WriteObjectAny ; (; const void * ; obj, . const TClass * ; ptrClass, . Bool_t ; cacheReuse = kTRUE . ). overridevirtual . Write object to I/O buffer. ; This function assumes that the value in 'obj' is the value stored in a pointer to a ""ptrClass"". The actual type of the object pointed to can be any class derived from ""ptrClass"". Return:; 0: failure; 1: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). If 'cacheReuse' is true (default) upon seeing an object address a second time, we record the offset where its was written the first time rather than streaming the object a second time. If 'cacheReuse' is false, we always stream the object. This allows the (re)use of temporary object to store different data in the same buffer. ; Implements TBuffer.; Definition at line 492 of file TBufferIO.cxx. ◆ WriteObjectClass(). virtual void TBufferIO::WriteObjectClass ; (; const void * ; actualObjStart, . const TClass * ; actualClass, . Bool_t ; cacheReuse . ). protectedpure virtual . Implemented in TBufferJSON, TBufferSQL2, TBufferXML, and TBufferFile. ◆ WriteProcessID(). UShort_t TBufferIO::WriteProcessID ; (; TProcessID * ; pid). overridevirtual . Check if the ProcessID pid is already in the file. ; If not, add it and return the index number in the local file list. ; Implements TBuffer.; Reimplemented in TMessage.; Definition at line 456 of file TBufferIO.cxx. Member Data Documentation. ◆ fClassMap. TExMap* TBufferIO::fClassMap {nullptr}. protected . Map containing object,class pairs for reading. ; Definition at line 40 of file TBufferIO.h. ◆ fDisplacement. Int_t TBufferIO::fDisplacement {0}. protected . Value to be added to the map offsets. ; Definition at line 37 of file TBufferIO.h. ◆ fgMapSize. Int_t TBufferIO::fgMapSize = kMapSize. staticprotected . Default map size for all TBuffer objects. ; Definition at line 42 of file TBufferIO.h. ◆ fMap. TExMap* TBufferIO::fMap {nullptr}. protected . Map containing object,offset pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferIO.html:43762,cache,cacheReuse,43762,doc/master/classTBufferIO.html,https://root.cern,https://root.cern/doc/master/classTBufferIO.html,1,['cache'],['cacheReuse']
Performance,"y(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9498; TCling::RegisterRdictForLoadPCMvoid RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent)Register Rdict data for future loading by LoadPCM;.Definition TCling.cxx:1678; TCling::ProcessLineSynchLongptr_t ProcessLineSynch(const char *line, EErrorCode *error=nullptr) finalLet cling process a command line synchronously, i.e we are waiting it will be finished.Definition TCling.cxx:3569; TCling::GetMangledNameWithPrototypeTString GetMangledNameWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) finalReturn the cling mangled name for a method of a class with a certain prototype, i....Definition TCling.cxx:4989; TCling::UpdateAllCanvasesstatic void UpdateAllCanvases()Update all canvases at end the terminal input command.Definition TCling.cxx:6754; TCling::LoadLibraryMapInt_t LoadLibraryMap(const char *rootmapfile=nullptr) finalLoad map between class and library.Definition TCling.cxx:5741; TCling::BaseClassInfo_TagnumLongptr_t BaseClassInfo_Tagnum(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8545; TCling::LibraryUnloadedvoid LibraryUnloaded(const void *dyLibHandle, const char *canonicalName)Definition TCling.cxx:6981; TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::GetEntriesvirtual Int_t GetEntries() constDefinition TCollection.h:179; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TCollection::Addvirtual void Add(TObject *obj)=0; TCollection::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TCollection.cxx:312; TCollection::ContainsBool_t Contains(const char *name) constDefinition TCollection.h:171; TDataMemberAll ROOT classes may have RTTI (r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:464049,Load,LoadLibraryMap,464049,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['Load'],['LoadLibraryMap']
Performance,"y(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9498; TCling::RegisterRdictForLoadPCMvoid RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent)Register Rdict data for future loading by LoadPCM;.Definition TCling.cxx:1678; TCling::ProcessLineSynchLongptr_t ProcessLineSynch(const char *line, EErrorCode *error=nullptr) finalLet cling process a command line synchronously, i.e we are waiting it will be finished.Definition TCling.cxx:3569; TCling::GetMangledNameWithPrototypeTString GetMangledNameWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) finalReturn the cling mangled name for a method of a class with a certain prototype, i....Definition TCling.cxx:4989; TCling::UpdateAllCanvasesstatic void UpdateAllCanvases()Update all canvases at end the terminal input command.Definition TCling.cxx:6754; TCling::LoadLibraryMapInt_t LoadLibraryMap(const char *rootmapfile=nullptr) finalLoad map between class and library.Definition TCling.cxx:5741; TCling::BaseClassInfo_TagnumLongptr_t BaseClassInfo_Tagnum(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8545; TCling::LibraryUnloadedvoid LibraryUnloaded(const void *dyLibHandle, const char *canonicalName)Definition TCling.cxx:6981; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TEnumThe TEnum class implements the enum type.Definition TEnum.h:33; TEnvThe TEnv class reads config files, by default named .rootrc.Definition TEnv.h:124; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TInterpreterValueDefinition TInterpre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:91520,Load,LoadLibraryMap,91520,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['Load'],['LoadLibraryMap']
Performance,"y(void *dirp); 1405{; 1406 TSystem *helper = FindHelper(nullptr, dirp);; 1407 if (helper) {; 1408 helper->FreeDirectory(dirp);; 1409 return;; 1410 }; 1411 ; 1412 if (dirp); 1413 ::closedir((DIR*)dirp);; 1414}; 1415 ; 1416////////////////////////////////////////////////////////////////////////////////; 1417/// Get next Unix file system directory entry. Returns 0 if no more entries.; 1418 ; 1419const char *TUnixSystem::GetDirEntry(void *dirp); 1420{; 1421 TSystem *helper = FindHelper(nullptr, dirp);; 1422 if (helper); 1423 return helper->GetDirEntry(dirp);; 1424 ; 1425 if (dirp); 1426 return UnixGetdirentry(dirp);; 1427 ; 1428 return nullptr;; 1429}; 1430 ; 1431////////////////////////////////////////////////////////////////////////////////; 1432/// Change directory. Returns kTRUE in case of success, kFALSE otherwise.; 1433 ; 1434Bool_t TUnixSystem::ChangeDirectory(const char *path); 1435{; 1436 Bool_t ret = (Bool_t) (::chdir(path) == 0);; 1437 if (fWdpath != """"); 1438 fWdpath = """"; // invalidate path cache; 1439 return ret;; 1440}; 1441 ; 1442////////////////////////////////////////////////////////////////////////////////; 1443/// Return working directory.; 1444 ; 1445const char *TUnixSystem::WorkingDirectory(); 1446{; 1447 // don't use cache as user can call chdir() directly somewhere else; 1448 //if (fWdpath != """"); 1449 // return fWdpath.Data();; 1450 ; 1451 R__LOCKGUARD2(gSystemMutex);; 1452 ; 1453 static char cwd[kMAXPATHLEN];; 1454 FillWithCwd(cwd);; 1455 fWdpath = cwd;; 1456 ; 1457 return fWdpath.Data();; 1458}; 1459 ; 1460//////////////////////////////////////////////////////////////////////////////; 1461/// Return working directory.; 1462 ; 1463std::string TUnixSystem::GetWorkingDirectory() const; 1464{; 1465 char cwd[kMAXPATHLEN];; 1466 FillWithCwd(cwd);; 1467 return std::string(cwd);; 1468}; 1469 ; 1470//////////////////////////////////////////////////////////////////////////////; 1471/// Fill buffer with current working directory.; 1472 ; 1473void TUnixSy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:43653,cache,cache,43653,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['cache'],['cache']
Performance,"y(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGenCategory.html:15583,cache,cache,15583,root/html526/RooGenCategory.html,https://root.cern,https://root.cern/root/html526/RooGenCategory.html,4,['cache'],['cache']
Performance,"y, RooLognormal, RooMomentMorph, RooNDKeysPdf, RooNonCPEigenDecay, RooNovosibirsk, RooParametricStepFunction, RooPoisson, RooPolynomial, RooPowerSum, RooTFnPdfBinding, RooUniform, RooVoigtian, RooAddModel, RooAddPdf, RooBinSamplingPdf, RooCachedPdf, RooEfficiency, RooEffProd, RooExtendedTerm, RooExtendPdf, RooFFTConvPdf, RooGenericPdf, RooHistPdf, RooMultiVarGaussian, RooNumConvPdf, RooProdPdf, RooProjectedPdf, RooRealSumPdf, RooResolutionModel, RooSimultaneous, RooTruthModel, RooWrapperPdf, and RooNonCentralChiSquare. ◆ StreamerNVirtual(). void RooAbsPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 351 of file RooAbsPdf.h. ◆ syncNormalization(). bool RooAbsPdf::syncNormalization ; (; const RooArgSet * ; nset, . bool ; adjustProxies = true . ); const. protectedvirtual . Verify that the normalization integral cached with this PDF is valid for given set of normalization observables. ; If not, the cached normalization integral (if any) is deleted and a new integral is constructed for use with 'nset'. Elements in 'nset' can be discrete and real, but must be lvalues.; For functions that declare to be self-normalized by overloading the selfNormalized() function, a unit normalization is always constructed. ; Definition at line 481 of file RooAbsPdf.cxx. ◆ traceEvalPdf(). bool RooAbsPdf::traceEvalPdf ; (; double ; value); const. private . Check that passed value is positive and not 'not-a-number'. ; If not, print an error, until the error counter reaches its set maximum. ; Definition at line 384 of file RooAbsPdf.cxx. ◆ verboseEval() [1/2]. Int_t RooAbsPdf::verboseEval ; (; ). static . Return global level of verbosity for p.d.f. evaluations. ; Definition at line 2418 of file RooAbsPdf.cxx. ◆ verboseEval() [2/2]. void RooAbsPdf::verboseEval ; (; Int_t ; stat). static . Change global level of verbosity for p.d.f. evaluations. ; Definition at line 2408 of file RooAbsPdf.cxx. Friends And Related Symbol Documentation. ◆ RooAbsReal. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:156214,cache,cached,156214,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['cache'],['cached']
Performance,"y, individual calls to ROOT are typically faster from PyROOT, whereas loops are typically slower.; When programming in Python, the modus operandi is to consider performance generally “good enough” on the outset, and when it turns out that, it is not good enough; the performance critical part is converted into C/C++ in an extension module. The school of thought where pre-mature optimization is the root of all evil should find this way of working very satisfying. In addition, if you look at their history, you will see that many of the standard Python modules have followed this path.; Your code should always make maximum use of ROOT facilities; such that most of the time is spending in compiled code. This goes even for very simple things: e.g. do not compute invariant masses in Python, use TLorentzVector instead. Moreover, before you start optimizing, make sure that you have run a profiler to find out where the bottlenecks are. Some performance, without cost in terms of programmer effort, may be gained by using psyco, see the next link: http://psyco.sourceforge.net, a Python just in time compiler (JIT). Note, however, that psyco is limited to Intel i386 CPUs. Since psyco optimizes Python, not PyROOT calls; it generally does not improve performance that much if most of your code consists of ROOT API calls. Mathematical computations in Python, on the other hand, benefit a lot.; Every call to a Python member function results in a lookup of that member function and an association of this method with 'self'. Furthermore, a temporary object is created during this process that is discarded after the method call. In inner loops, it may be worth your while (up to 30%), to short-cut this process by looking up and binding the method before the loop, and discarding it afterwards. Here is an example:; hpx = TH1F('hpx','px',100,-4,4); hpxFill = hpx.Fill # cache bound method; for i in xrange(25000):; px = gRandom.Gaus(); hpxFill(px) # use bound method: no lookup needed; del hpxFill # ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1063961,perform,performance,1063961,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performance']
Performance,"y, or you just try to access a class that is defined in a library.; 1.6.2.2 Linktime Library Dependencies; When building your own executable you will have to link against the libraries that contain the classes you use. The ROOT reference guide states the library a class is reference guide defined in. Almost all relevant classes can be found in libraries returned by root-config -glibs; the graphics libraries are retuned by root-config --libs. These commands are commonly used in Makefiles. Using root-config instead of enumerating the libraries by hand allows you to link them in a platform independent way. Also, if ROOT library names change you will not need to change your Makefile.; A batch program that does not have a graphic display, which creates, fills, and saves histograms and trees, only needs to link the core libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, libTreePlayer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:22462,load,loaded,22462,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loaded']
Performance,"y->Remove(this);; 3803 //delete the file cache if it points to this Tree; 3804 MoveReadCache(file,nullptr);; 3805 fDirectory = nullptr;; 3806 ResetBit(kMustCleanup);; 3807 }; 3808 ; 3809 // Delete object from CINT symbol table so it can not be used anymore.; 3810 gCling->DeleteGlobal(this);; 3811 ; 3812 // Warning: We have intentional invalidated this object while inside a member function!; 3813 delete this;; 3814}; 3815 ; 3816 ///////////////////////////////////////////////////////////////////////////////; 3817 /// Called by TKey and TObject::Clone to automatically add us to a directory; 3818 /// when we are read from a file.; 3819 ; 3820void TTree::DirectoryAutoAdd(TDirectory* dir); 3821{; 3822 if (fDirectory == dir) return;; 3823 if (fDirectory) {; 3824 fDirectory->Remove(this);; 3825 // Delete or move the file cache if it points to this Tree; 3826 TFile *file = fDirectory->GetFile();; 3827 MoveReadCache(file,dir);; 3828 }; 3829 fDirectory = dir;; 3830 TBranch* b = nullptr;; 3831 TIter next(GetListOfBranches());; 3832 while((b = (TBranch*) next())) {; 3833 b->UpdateFile();; 3834 }; 3835 if (fBranchRef) {; 3836 fBranchRef->UpdateFile();; 3837 }; 3838 if (fDirectory) fDirectory->Append(this);; 3839}; 3840 ; 3841////////////////////////////////////////////////////////////////////////////////; 3842/// Draw expression varexp for specified entries.; 3843///; 3844/// \return -1 in case of error or number of selected events in case of success.; 3845///; 3846/// This function accepts TCut objects as arguments.; 3847/// Useful to use the string operator +; 3848///; 3849/// Example:; 3850///; 3851/// ~~~ {.cpp}; 3852/// ntuple.Draw(""x"",cut1+cut2+cut3);; 3853/// ~~~; 3854 ; 3855 ; 3856Long64_t TTree::Draw(const char* varexp, const TCut& selection, Option_t* option, Long64_t nentries, Long64_t firstentry); 3857{; 3858 return TTree::Draw(varexp, selection.GetTitle(), option, nentries, firstentry);; 3859}; 3860 ; 3861//////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:150444,cache,cache,150444,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"y. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TFunctionTemplate * GetFunctionTemplate(const char* name). TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. TListOfFunctions * GetGlobalFunctions(); Internal routine returning, and creating if necessary, the list; of global function. TCollection * GetListOfFunctionOverloads(const char* name) const; Return the collection of functions named ""name"". TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name.; If params != 0 it will also resolve overloading other it returns the first; name match.; If params == 0 and load is true force reading of all currently defined; global functions from Cling.; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The prot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:26966,load,load,26966,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,2,['load'],['load']
Performance,"y.cxx:249; namechar name[80]Definition TGX11.cxx:110; Naming shape primitive is mandatory only for the primitives used in Boolean composites (see ""Composite Shapes""). For the sake of simplicity, we will describe only the constructors in the second form. Primitive Shapes. Boxes: TGeoBBox class; Parallelepiped: TGeoPara class; Trapezoids: TGeoTrd1, TGeoTrd2 classes; General Trapezoid: TGeoTrap class; Twisted Trapezoid: TGeoGtra class; Arbitrary 8 vertices shapes: TGeoArb8 class; Tubes: TGeoTube class; Tube Segments: TGeoTubeSeg class; Cut Tubes: TGeoCtub class; Elliptical Tubes: TGeoEltu class; Hyperboloids: TGeoHype class; Cones: TGeoCone class; Cone Segments: TGeoConeSeg class; Sphere: TGeoSphere class; Torus: TGeoTorus class; Paraboloid: TGeoParaboloid class; Polycone: TGeoPcon class; Polygon: TGeoPgon class; Polygonal extrusion: TGeoXtru class; Half Spaces: TGeoHalfSpace class; Composite Shapes: TGeoCompositeShape class. Navigation Methods Performed By Shapes; Shapes are named objects and register themselves to the manager class at creation time. This is responsible for their final deletion. Shapes can be created without name if their retrieval by name is no needed. Generally shapes are objects that are useful only at geometry creation stage. The pointer to a shape is in fact needed only when referring to a given volume and it is always accessible at that level. Several volumes may reference a single shape; therefore its deletion is not possible once volumes were defined based on it.; The navigation features related for instance to tracking particles are performed in the following way: Each shape implement its specific algorithms for all required tasks in its local reference system. Note that the manager class handles global queries related to geometry. However, shape-related queries might be sometimes useful:; Bool_t TGeoShape::Contains(Double_t *point[3]);; Bool_tbool Bool_tDefinition RtypesCore.h:63; Double_tdouble Double_tDefinition RtypesCore.h:59; TGeoShape:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Shapes__classes.html:3843,Perform,Performed,3843,doc/master/group__Shapes__classes.html,https://root.cern,https://root.cern/doc/master/group__Shapes__classes.html,1,['Perform'],['Performed']
Performance,"y::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TNetFile.html:13703,cache,cache,13703,root/html532/TNetFile.html,https://root.cern,https://root.cern/root/html532/TNetFile.html,2,['cache'],['cache']
Performance,"y::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetFile.html:13782,cache,cache,13782,root/html534/TNetFile.html,https://root.cern,https://root.cern/root/html534/TNetFile.html,6,['cache'],['cache']
Performance,"y;  ; class  TWrkInfo;  ; class  TWrkInfoFile;  . Public Member Functions;  TProofPerfAnalysis (const char *perffile, const char *title="""", const char *treename=""PROOF_PerfStats"");  Constructor: open the file and attach to the tree. ;  ;  TProofPerfAnalysis (TTree *tree, const char *title="""");  Constructor: open the file and attach to the tree. ;  ;  ~TProofPerfAnalysis () override;  Destructor: detach the tree and close the file. ;  ; void EventDist ();  Display event and packet distribution. ;  ; void FileDist (Bool_t writedet=kFALSE);  Analyse the file distribution. ;  ; void FileProcPlot (const char *fn, const char *out=0);  Show event processing or MB processing rate plot vs time. ;  ; void FileRatePlot (const char *fns=0);  Show MB processing rate plot per file vs time. ;  ; void GetAverages (Double_t &evtmax, Double_t &mbmax, Double_t &evt, Double_t &mb) const;  ; Double_t GetEvtRateAvg () const;  ; Double_t GetEvtRateAvgMax () const;  ; Double_t GetMBRateAvg () const;  ; Double_t GetMBRateAvgMax () const;  ; TClass * IsA () const override;  ; Bool_t IsValid () const;  ; void LatencyPlot (const char *wrks=0);  Show event processing or MB processing rate plot vs time Create the histograms. ;  ; void PrintFileInfo (const char *fn, const char *opt=""P"", const char *out=0);  Print information for file 'fn' (path including directory) or server 'fn'. ;  ; void PrintFileInfo (Int_t showlast=10, const char *opt="""", const char *out=0);  Print information for all or the slowest showlast workers. ;  ; void PrintWrkInfo (const char *wrk);  Print information for worker 'wn' (ordinal) or on the machine whose ordinal or fqdn matches 'wn'. ;  ; void PrintWrkInfo (Int_t showlast=10);  Print information for all or the slowest showlast workers. ;  ; void RatePlot (const char *wrks=0);  Show event processing or MB processing rate plot vs time. ;  ; void SetDebug (Int_t d=0);  Static setter for the verbosity level. ;  ; Int_t SetSaveResult (const char *file=""results.root"", Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPerfAnalysis.html:1658,Latency,LatencyPlot,1658,doc/master/classTProofPerfAnalysis.html,https://root.cern,https://root.cern/doc/master/classTProofPerfAnalysis.html,1,['Latency'],['LatencyPlot']
Performance,"yBase. ;  ; std::vector< std::string > fSuppressErrorsForMissingBranches {};  ; TTree * fTree = nullptr;  tree that's read ;  ; std::deque< ROOT::Internal::TTreeReaderValueBase * > fValues;  readers that use our director ;  ; bool fWarnAboutLongerFriends {true};  . Friends; class ROOT::Internal::TTreeReaderArrayBase;  ; class ROOT::Internal::TTreeReaderValueBase;  . #include <TTreeReader.h>. Inheritance diagram for TTreeReader:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ iterator. typedef Iterator_t TTreeReader::iterator. Definition at line 150 of file TTreeReader.h. ◆ NamedProxies_t. using TTreeReader::NamedProxies_t = std::unordered_map<std::string, std::unique_ptr<ROOT::Internal::TNamedBranchProxy> >. protected . Definition at line 273 of file TTreeReader.h. Member Enumeration Documentation. ◆ EEntryStatus. enum TTreeReader::EEntryStatus. EnumeratorkEntryValid data read okay . kEntryNotLoaded no entry has been loaded yet . kEntryNoTree the tree does not exist . kEntryNotFound the tree entry number does not exist . kEntryChainSetupError problem in accessing a chain element, e.g. file without the tree . kEntryChainFileError problem in opening a chain's file . kEntryDictionaryError problem reading dictionary info from tree . kEntryBeyondEnd last entry loop has reached its end . kEntryBadReader One of the readers was not successfully initialized. . kIndexedFriendNoMatch A friend with TTreeIndex doesn't have an entry for this index. . kMissingBranchWhenSwitchingTree A branch was not found when switching to the next TTree in the chain. . kEntryUnknownError LoadTree return less than -6, likely a 'newer' error code. . Definition at line 152 of file TTreeReader.h. ◆ ELoadTreeStatus. enum TTreeReader::ELoadTreeStatus. EnumeratorkNoTree default state, no TTree is connected (formerly 'Zombie' state) . kLoadTreeNone Notify has not been called yet. . kInternalLoadTree Notify/LoadTree was last c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReader.html:22265,load,loaded,22265,doc/master/classTTreeReader.html,https://root.cern,https://root.cern/doc/master/classTTreeReader.html,1,['load'],['loaded']
Performance,"yContainer, then compiles the code so generated, effectively doing the same we could do by hand, but with a lot less effort.; This produces code that is type safe, but does have different drawbacks:. Templates make code harder to read.; At the time of writing this documentation, some compilers can be very slow when dealing with templates.; It does not solve the problem when a container has to hold a heterogeneous set of objects.; The system can end up generating a great deal of code; each container/object combination has its own code, a phenomenon that is sometimes referred to as code bloat.; The Standard Template Library (STL) is part on ANSI C++, and includes a set of template containers. 17 Physics Vectors; The physics vector classes describe vectors in three and four dimensions and their rotation algorithms. The classes were ported to root from CLHEP see:; http://www.cern.ch/clhep/manual/UserGuide/Vector/vector.html; 17.1 The Physics Vector Classes; In order to use the physics vector classes you will have to load the Physics library:; gSystem.Load(""libPhysics.so"");; There are four classes in this package. They are:; TVector3 is a general three-vector. A TVector3 may be expressed in Cartesian, polar, or cylindrical coordinates. Methods include dot and cross products, unit vectors and magnitudes, angles between vectors, and rotations and boosts. There are also functions of particular use to HEP, like pseudo-rapidity, projections, and transverse part of a TVector3, and kinetic methods on 4-vectors such as Invariant Mass of pairs or containers of particles.; TLorentzVector is a general four-vector class, which can be used either for the description of position and time (x, y, z, t) or momentum and energy (px, py, pz, E). TRotation is a class describing a rotation of a TVector3 object. TLorentzRotation is a class to describe the Lorentz transformations including Lorentz boosts and rotations. In addition, a TVector2 is a basic implementation of a vector in two dimensio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:857884,load,load,857884,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['load']
Performance,"yCutvirtual bool GetReapplyCut() constDefinition TEventList.h:57; TEventList::GetNvirtual Int_t GetN() constDefinition TEventList.h:56; TFileInfoClass describing a generic file including meta information.Definition TFileInfo.h:39; TFileInfo::GetCurrentUrlTUrl * GetCurrentUrl() constReturn the current url.Definition TFileInfo.cxx:249; TFileMergeInfoDefinition TFileMergeInfo.h:42; TFileStagerDefinition TFileStager.h:36; TFileStager::Matchesvirtual Bool_t Matches(const char *s)Definition TFileStager.h:46; TFileStager::Openstatic TFileStager * Open(const char *stager)Open a stager, after having loaded the relevant plug-in.Definition TFileStager.cxx:101; TFileStager::Locatevirtual Int_t Locate(const char *u, TString &f)Just check if the file exists locally.Definition TFileStager.cxx:146; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::SetCacheReadvirtual void SetCacheRead(TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect)Set a pointer to the read cache.Definition TFile.cxx:2365; TFile::GetCompressionSettingsInt_t GetCompressionSettings() constDefinition TFile.h:397; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TFriendElementA TFriendElement TF describes a TTree object TF in a file.Definition TFriendElement.h:33; TFriendElement::kFromChain@ kFromChainDefinition TFriendElement.h:49; TFriendElement::GetTreevirtual TTree * GetTree()Return pointer to friend TTree.Definition TFriendElement.cxx:217; TIterDefinition TCollection.h:235; TIter::Resetvoid Reset()Definition TCollection.h:254; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:135969,cache,cache,135969,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,2,['cache'],['cache']
Performance,"yDataSource.C This tutorial illustrates how to take advantage of a lazy data source creating a data frame from columns of one or multiple parent dataframe(s), delaying the creation of the columns to the actual usage of the daughter data frame ;  df016_vecOps.C This tutorial shows the potential of the VecOps approach for treating collections stored in datasets, a situation very common in HEP data analysis ;  df016_vecOps.py This tutorial shows the potential of the VecOps approach for treating collections stored in datasets, a situation very common in HEP data analysis ;  df017_vecOpsHEP.C This tutorial shows how VecOps can be used to slim down the programming model typically adopted in HEP for analysis ;  df017_vecOpsHEP.py This tutorial shows how VecOps can be used to slim down the programming model typically adopted in HEP for analysis ;  df018_customActions.C This tutorial shows how to implement a custom action ;  df019_Cache.C This tutorial shows how the content of a data frame can be cached in memory in form of a data frame ;  df019_Cache.py This tutorial shows how the content of a data frame can be cached in memory in form of a data frame ;  df020_helpers.C This tutorial shows usage of the RDF helper tools, contained in ROOT/RDFHelpers.hxx ;  df021_createTGraph.C This tutorial shows how to fill a TGraph using the Dataframe ;  df021_createTGraph.py This tutorial shows how to fill a TGraph using the Dataframe ;  df022_useKahan.C This tutorial shows how to implement a Kahan summation custom action ;  df023_aggregate.C This tutorial shows how to use the Aggregate action to evaluate the product of all the elements of a column ;  df024_Display.C This tutorial shows how to use the Display action ;  df024_Display.py This tutorial shows how to use the Display action ;  df025_RNode.C RNode is a generic type which represents any transformation node in the computation graph ;  df101_h1Analysis.C This tutorial illustrates how to express the H1 analysis with a RDataFrame ;  d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:101563,cache,cached,101563,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['cache'],['cached']
Performance,"yI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of available instances in the formulas; *-* ====================================================. Bool_t Sync(); Synchronize all the formulae. void UpdateFormulaLeaves(); this function could be called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void UpdateUsedSize(Int_t& virt_dim, Int_t vsize); Reload the array sizes. TTreeFormulaManager(const TTreeFormulaManager& ); Not implemented yet. TTreeFormulaManager& operator=(const TTreeFormulaManager& ). Int_t GetMultiplicity() const; {return fMultiplicity;}. Bool_t Notify(); { UpdateFormulaLeaves(); return kTRUE; }. » Author: Philippe Canal 20/03/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeFormulaManager.html:7436,Load,LoadTree,7436,root/html534/TTreeFormulaManager.html,https://root.cern,https://root.cern/root/html534/TTreeFormulaManager.html,2,"['Load', 'load']","['LoadTree', 'loaded']"
Performance,"yL, const Double_t *eyH)Set ey values for point i.Definition TGraphMultiErrors.cxx:1885; TGraphMultiErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exL)Set exL value for point i.Definition TGraphMultiErrors.cxx:1853; TGraphMultiErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH)Set eyH values for point i.Definition TGraphMultiErrors.cxx:1907; TGraphMultiErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphMultiErrors.cxx:1379; TGraphMultiErrors::fNYErrorsInt_t fNYErrorsThe amount of different y-errors.Definition TGraphMultiErrors.h:32; TGraphMultiErrors::fEyLstd::vector< TArrayD > fEyLTwo dimensional array of Y low errors.Definition TGraphMultiErrors.h:37; TGraphMultiErrors::GetErrorYDouble_t GetErrorY(Int_t i) const overrideGet error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1454; TGraphMultiErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphMultiErrors.cxx:933; TGraphMultiErrors::DoMergeBool_t DoMerge(const TGraph *tg) overrideProtected function to perform the merge operation of a graph with multiple asymmetric errors.Definition TGraphMultiErrors.cxx:838; TGraphMultiErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1530; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TVectorTTVectorT.Definition TVectorT.h:27; bool; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; mTMarker mDefinition textangle.C:8. histhistincTGraphMultiErrors.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:25631,perform,perform,25631,doc/master/TGraphMultiErrors_8h_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html,1,['perform'],['perform']
Performance,"yLine(const TBuffer3D& buffer); ~TGLPolyLine(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLPolyLine.html:1796,cache,cached,1796,root/html528/TGLPolyLine.html,https://root.cern,https://root.cern/root/html528/TGLPolyLine.html,3,['cache'],['cached']
Performance,"yListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; RooArgSet_rrvArgsSet of real-valued observables; TIterator*_rrvIter! Iterator over set of real-valued observables; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealVar*_yvarY variable if so designated; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooXYChi2Var(). RooXYChi2Var(const char *name, const char* title, RooAbsReal& func, RooDataSet& xydata, Bool_t integrate). RooXYChi2Var constructor with function and X-Y values dataset. An X-Y dataset is a weighted dataset with one or more observables X where the weight is interpreted; as the Y value and the weight error is interpreted as the Y value error. The weight must have an; non-zero error defined at each point for the chi^2 calcul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooXYChi2Var.html:35706,cache,cache,35706,root/html526/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html526/RooXYChi2Var.html,1,['cache'],['cache']
Performance,"yListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; RooArgSet_rrvArgsSet of real-valued observables; TIterator*_rrvIter! Iterator over set of real-valued observables; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealVar*_yvarY variable if so designated; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooXYChi2Var(); coverity[UNINIT_CTOR]. RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, Bool_t integrate = kFALSE). RooXYChi2Var constructor with function and X-Y values dataset. An X-Y dataset is a weighted dataset with one or more observables X where the weight is interpreted; as the Y value and the weight error is interpreted as the Y value error. The weight must have an; non-zero error defined at e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooXYChi2Var.html:35972,cache,cache,35972,root/html528/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html528/RooXYChi2Var.html,1,['cache'],['cache']
Performance,"yMethodCategory(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = NULL); TMVA::MethodCategoryMethodCategory(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = NULL); virtual Bool_tTMVA::MethodBase::MonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidTMVA::MethodCompositeBase::ReadWeightsFromStream(istream& istr); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::MethodBase::RerouteTransformation",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodCategory.html:9505,Optimiz,OptimizeTuningParameters,9505,root/html530/TMVA__MethodCategory.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodCategory.html,2,['Optimiz'],['OptimizeTuningParameters']
Performance,"ySearchTreeA simple Binary search tree including a volume search method ;  CBinarySearchTreeNodeNode for the BinarySearch or Decision Trees ;  CBinaryTreeBase class for BinarySearch and Decision Trees ;  CCCPrunerA helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) ;  ►CCCTreeWrapper;  CCCTreeNode;  CClassificationClass to perform two class classification ;  CClassificationResultClass to save the results of the classifier ;  CClassifierFactoryThis is the MVA factory ;  CClassInfoClass that contains all the information of a class ;  Ccompose_binary_t;  Ccompose_unary_t;  ►CConfigSingleton class for global configuration settings used by TMVA ;  CIONames;  CVariablePlotting;  CConfigurable;  CConvergenceTestCheck for convergence ;  CCostComplexityPruneToolA class to prune a decision tree using the Cost Complexity method ;  CCrossEntropyImplementation of the CrossEntropy as separation criterion ;  CCrossValidationClass to perform cross validation, splitting the dataloader into folds ;  CCrossValidationFoldResult;  CCrossValidationResultClass to save the results of cross validation, the metric for the classification ins ROC and you can ROC curves ROC integrals, ROC average and ROC standard deviation ;  CCvSplit;  CCvSplitKFolds;  CCvSplitKFoldsExpr;  CDataInputHandlerClass that contains all the data information ;  CDataLoader;  CDataSetClass that contains all the data information ;  ►CDataSetFactoryClass that contains all the data information ;  CEventStats;  CDataSetInfoClass that contains all the data information ;  CDataSetManagerClass that contains all the data information ;  CDecisionTreeImplementation of a Decision Tree ;  CDecisionTreeNode;  CDeleteFunctor_t;  CDTNodeTrainingInfo;  CEnvelopeAbstract base class for all high level ml algorithms, you can book ml methods like BDT, MLP ;  CEvent;  CExpectedErrorPruneToolA helper class to prune a decision tree using the expected error (C4.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:80281,perform,perform,80281,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,1,['perform'],['perform']
Performance,"y_pdfListList of PDF components; RooLinkedList_pdfNSetListList of PDF component normalization sets; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; TNamed*_refRangeNameReference range name for interpretation of conditional products; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; Bool_t_selfNormIs self-normalized; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useDefaultGenUse default or distributed event generator; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProdPdf.html:45016,cache,cache,45016,root/html532/RooProdPdf.html,https://root.cern,https://root.cern/root/html532/RooProdPdf.html,2,['cache'],['cache']
Performance,"ybridCalculator: public RooStats::HypoTestCalculator, public TNamed. HybridCalculator class: this class is a fresh rewrite in RooStats of; 	RooStatsCms/LimitCalculator developped by D. Piparo and G. Schott; Authors: D. Piparo, G. Schott - Universitaet Karlsruhe. The class is born from the need to have an implementation of the CLs; method that could take advantage from the RooFit Package.; The basic idea is the following:; - Instantiate an object specifying a signal+background model, a background model and a dataset.; - Perform toy MC experiments to know the distributions of -2lnQ; - Calculate the CLsb and CLs values as ""integrals"" of these distributions. The class allows the user to input models as RooAbsPdf ( TH1 object could be used; by using the RooHistPdf class); The pdfs must be ""extended"": for more information please refer to; http://roofit.sourceforge.net). The dataset can be entered as a; RooAbsData objects. Unlike the TLimit Class a complete MC generation is performed at each step; and not a simple Poisson fluctuation of the contents of the bins.; Another innovation is the treatment of the nuisance parameters. The user; can input in the constructor nuisance parameters.; To include the information that we have about the nuisance parameters a prior; PDF (RooAbsPdf) should be specified. Different test statistic can be used (likelihood ratio, number of events or; profile likelihood ratio. The default is the likelihood ratio.; See the method SetTestStatistic. The number of toys to be generated is controlled by SetNumberOfToys(n). The result of the calculations is returned as a HybridResult object pointer. see also the following interesting references:; - Alex Read, ""Presentation of search results: the CLs technique"",; Journal of Physics G: Nucl. Part. Phys. 28 2693-2704 (2002).; see http://www.iop.org/EJ/abstract/0954-3899/28/10/313/. - Alex Read, ""Modified Frequentist Analysis of Search Results (The CLs Method)"" CERN 2000-005 (30 May 2000). - V. Bartsch, G.Quas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__HybridCalculator.html:1294,perform,performed,1294,root/html526/RooStats__HybridCalculator.html,https://root.cern,https://root.cern/root/html526/RooStats__HybridCalculator.html,1,['perform'],['performed']
Performance,"yer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On start-up, ROOT parses all files ending on .rootmap rootmap that are in one of the $LD_LIBRARY_PATH (or $DYLD_LIBRARY_PATH for MacOS, or $PATH for Windows). They contain clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:23490,load,loaded,23490,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loaded']
Performance,"ygroup=2, Int_t nzgroup=2, const char *newname="""")Rebin this histogram grouping nxgroup/nygroup/nzgroup bins along the xaxis/yaxis/zaxis together.Definition TH3.cxx:2957; TH3::BufferEmptyInt_t BufferEmpty(Int_t action=0) overrideFill histogram with all entries in the buffer.Definition TH3.cxx:264; TH3::fTsumwyDouble_t fTsumwyTotal Sum of weight*Y.Definition TH3.h:34; TH3::fTsumwy2Double_t fTsumwy2Total Sum of weight*Y*Y.Definition TH3.h:35; TH3::GetCovariancevirtual Double_t GetCovariance(Int_t axis1=1, Int_t axis2=2) constReturn covariance between axis1 and axis2.Definition TH3.cxx:1209; TH3::GetStatsvoid GetStats(Double_t *stats) const overrideFill the array stats from the contents of this histogram The array stats must be correctly dimensione...Definition TH3.cxx:1307; TH3::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH3.cxx:208; TH3::DoProject2Dvirtual TH2D * DoProject2D(const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF) constinternal method performing the projection to a 2D histogram called from TH3::Project3DDefinition TH3.cxx:2103; TH3::fTsumwxzDouble_t fTsumwxzTotal Sum of weight*X*Z.Definition TH3.h:39; TH3::FillRandomvoid FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr) overrideFill histogram following distribution in function fname.Definition TH3.cxx:833; TH3::KolmogorovTestDouble_t KolmogorovTest(const TH1 *h2, Option_t *option="""") const overrideStatistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test.Definition TH3.cxx:1532; TH3::ProjectionYvirtual TH1D * ProjectionY(const char *name=""_py"", Int_t ixmin=0, Int_t ixmax=-1, Int_t izmin=0, Int_t izmax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D histogram along Y.Definition TH3.cxx:1780; TH3::InterpolateDouble_t Interpolate(Double_t x, Double_t y) const overrideNot yet implemented.Definition TH3.cxx:1441; TH3::GetRandom3virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:205854,perform,performing,205854,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['perform'],['performing']
Performance,"yle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8665 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8831 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8865 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8683 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8711 of file TTree.cxx. ◆ SetChainOffset(). virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:210330,cache,cacheSize,210330,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,2,['cache'],"['cache', 'cacheSize']"
Performance,"yle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; UnBinData.h; ROOT::Fit::BasicFCNBasicFCN class: base class for the objective functions used in the fits It has a reference to the dat...Definition BasicFCN.h:40; ROOT::Fit::Chi2FCNChi2FCN class for binned fits using the least square methods.Definition Chi2FCN.h:46; ROOT::Fit::FcnAdapterDefinition FcnAdapter.h:27; ROOT::Fit::FitConfig::MinosParamsconst std::vector< unsigned int > & MinosParams() constreturn vector of parameter indices for which the Minos Error will be computedDefinition FitConfig.h:218; ROOT::Fit::FitConfig::UpdateAfterFitbool UpdateAfterFit() constUpdate configuration after a fit using the FitResult.Definition FitConfig.h:211; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::SetMinosErrorsvoid SetMinosErrors(bool on=true)set Minos errors computation to be performed after fittingDefinition FitConfig.h:229; ROOT::Fit::FitConfig::NormalizeErrorsbool NormalizeErrors() constflag to check if resulting errors are be normalized according to chi2/ndfDefinition FitConfig.h:202; ROOT::Fit::FitConfig::ParabErrorsbool ParabErrors() constdo analysis for parabolic errorsDefinition FitConfig.h:205; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(unsigned int npar, const double *params, const double *vstep=nullptr)set the parameter settings from number of parameters and a vector of values and optionally step value...Definition FitConfig.cxx:135; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::UseWeightCorrectionbool UseWeightCorrection() constApply Weight correction for error matrix comp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8cxx_source.html:41608,perform,performed,41608,doc/master/Fitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html,1,['perform'],['performed']
Performance,"yleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from RooLegendre; void doEval (RooFit::EvalContext &) const override;  Base function for computing multiple values of a RooAbsReal. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSpHarmonic.html:52193,cache,cached,52193,doc/master/classRooSpHarmonic.html,https://root.cern,https://root.cern/doc/master/classRooSpHarmonic.html,2,['cache'],"['cache', 'cached']"
Performance,"yleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tTChain::fNtreesNumber of trees; Int_tTTree::fPacketSize! Number of entries in one packet for parallel root; TVirtualTreePlayer*TTree::fPlayer! Pointer to current Tree player; TChain*TChain::fProofChain! chain proxy when going to be processed by PROOF; Long64_tTTree::fReadEntry! Number of the entry being processed; Long64_tTTree::fSavedBytesNumber of autosaved bytes; Int_tTTree::fScanFieldNumber of runs before prompting in Scan; TDSet*fSetTDSet; TList*TChain::fStatus-> List of active/inactive branches (TChainElement, owned); Int_tTTree::fTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TBuffer*TTree::fTransientBuffer! Pointer to the current transient buffer.; TTree*TChain::fTree! Pointer to current tree (Note: We do *not* own this tree.); TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tTChain::fTreeNumber! Current Tree number in fTreeOffset table; Long64_t*TChain::fTreeOffset[fTreeOffsetLen] Array of variables; Int_tTChain::fTreeOffsetLenCurrent size of fTreeOffset a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofChain.html:25119,load,loading,25119,root/html530/TProofChain.html,https://root.cern,https://root.cern/root/html530/TProofChain.html,2,['load'],['loading']
Performance,"ym< Element > & ; b . ). Symmetric matrix summation. Replace this matrix with C such that C = A + B. ; Definition at line 312 of file TMatrixTSym.cxx. ◆ Randomize(). template<class Element > . TMatrixTBase< Element > & TMatrixTSym< Element >::Randomize ; (; Element ; alpha, . Element ; beta, . Double_t & ; seed . ). overridevirtual . randomize matrix element values but keep matrix symmetric ; Reimplemented from TMatrixTBase< Element >.; Definition at line 1608 of file TMatrixTSym.cxx. ◆ RandomizePD(). template<class Element > . TMatrixTSym< Element > & TMatrixTSym< Element >::RandomizePD ; (; Element ; alpha, . Element ; beta, . Double_t & ; seed . ). virtual . randomize matrix element values but keep matrix symmetric positive definite ; Definition at line 1639 of file TMatrixTSym.cxx. ◆ Rank1Update(). template<class Element > . TMatrixTSym< Element > & TMatrixTSym< Element >::Rank1Update ; (; const TVectorT< Element > & ; v, . Element ; alpha = 1.0 . ). Perform a rank 1 operation on the matrix: A += alpha * v * v^T. ; Definition at line 1063 of file TMatrixTSym.cxx. ◆ ResizeTo() [1/3]. template<class Element > . TMatrixTBase< Element > & TMatrixTSym< Element >::ResizeTo ; (; const TMatrixTSym< Element > & ; m). inline . Definition at line 122 of file TMatrixTSym.h. ◆ ResizeTo() [2/3]. template<class Element > . TMatrixTBase< Element > & TMatrixTSym< Element >::ResizeTo ; (; Int_t ; nrows, . Int_t ; ncols, . Int_t ; = -1 . ). overridevirtual . Set size of the matrix to nrows x ncols New dynamic elements are created, the overlapping part of the old ones are copied to the new structures, then the old elements are deleted. ; Implements TMatrixTBase< Element >.; Definition at line 771 of file TMatrixTSym.cxx. ◆ ResizeTo() [3/3]. template<class Element > . TMatrixTBase< Element > & TMatrixTSym< Element >::ResizeTo ; (; Int_t ; row_lwb, . Int_t ; row_upb, . Int_t ; col_lwb, . Int_t ; col_upb, . Int_t ; = -1 . ). overridevirtual . Set size of the matrix to [row_lwb:row_upb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixTSym.html:39178,Perform,Perform,39178,doc/master/classTMatrixTSym.html,https://root.cern,https://root.cern/doc/master/classTMatrixTSym.html,1,['Perform'],['Perform']
Performance,ymError(RooAbsReal* real); Bool_thasError(RooAbsReal* real); virtual Bool_thasFilledCache() const; Bool_tisFullReal(RooAbsReal* real); voidTObject::MakeZombie(); vector<RealFullVector*>&realfStoreList(); vector<RealVector*>&realStoreList(). private:. voidsetAllBuffersNative(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; RooArgSetRooAbsDataStore::_cachedVars; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSetRooAbsDataStore::_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooVectorDataStore*_cache! Optimization cache; RooAbsArg*_cacheOwner! Cache owner; vector<CatVector*>_catStoreList; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; RooVectorDataStore::CatVector**_firstCat! do not persist; RooVectorDataStore::RealVector**_firstReal! do not persist; RooVectorDataStore::RealFullVector**_firstRealF! do not persist; Bool_t_forcedUpdate! Request for forced cache update ; Int_t_nCat; In,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooVectorDataStore.html:10256,cache,cached,10256,root/html534/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html534/RooVectorDataStore.html,2,"['cache', 'load']","['cached', 'loading']"
Performance,"ymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFileCacheWrite.html:6906,cache,cache,6906,root/html602/TFileCacheWrite.html,https://root.cern,https://root.cern/root/html602/TFileCacheWrite.html,2,['cache'],['cache']
Performance,"ymous)TObject::kSingleKey; static TFile::(anonymous)kStartBigFile; static TFile::EFileTypekWeb; static TObject::(anonymous)TObject::kWriteDelete; static TFile::EStatusBitskWriteError; static TObject::(anonymous)TObject::kZombie. protected:. TArchiveFile*fArchive!Archive file from which we read this file; Long64_tfArchiveOffset!Offset at which file starts in archive; TFileOpenHandle*fAsyncHandle!For proper automatic cleanup; TFile::EAsyncOpenStatusfAsyncOpenStatus!Status of an asynchronous open request; Long64_tfBEGINFirst used byte in file; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tfBytesReadNumber of bytes read from this file; Long64_tfBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tfBytesWriteNumber of bytes written to this file; TFileCacheRead*fCacheRead!Pointer to the read cache (if any); TMap*fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*fCacheWrite!Pointer to the write cache (if any); TArrayC*fClassIndex!Index of TStreamerInfo classes written to this file; Int_tfCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tfDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tfENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*fFreeFree segments linked list table; TList*fInfoCache!Cached list of the streamer infos in this file; Bool_tfInitDone!True if the file has been initialized; Bool_tfIsArchive!True if this is a pure archive file; Bool_tfIsPcmFile!True if the file is a ROOT pcm file.; Bool_tfIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFile.html:20200,cache,cache,20200,root/html602/TFile.html,https://root.cern,https://root.cern/root/html602/TFile.html,8,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"ymous)TObject::kZombie. protected:. TString_convVarNameName of convolution variable; RooRealVar*_cvModelConvolution variable in resModel event; RooRealVar*_cvOutConvolution variable in output event; RooRealVar*_cvPdfConvolution variable in PDFxTruth event; UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; RooDataSet*RooAbsGenContext::_genData! Data being generated; Bool_tRooAbsGenContext::_isValidIs context in valid state?; RooArgSet*_modelCloneSetOwner of resModel clone; RooAbsGenContext*_modelGenResolution model generator context; RooArgSet*_modelVarsHolder of resModel event; RooArgSet*_modelVarsOwnedOwning version of modelVars ;; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; TStringRooAbsGenContext::_normRangeNormalization range of pdf; RooArgSet*_pdfCloneSetOwner of PDF clone; RooAbsGenContext*_pdfGenPhysics model generator context; RooArgSet*_pdfVarsHolder of PDF x truth event; RooArgSet*_pdfVarsOwnedOwning version of pdfVars ;; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooConvGenContext(const RooAbsAnaConvPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE); Constructor for specialized generator context for analytical convolutions. Builds a generator for the physics PDF convoluted with the truth model; and a generator for the res",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooConvGenContext.html:10041,load,load,10041,root/html602/RooConvGenContext.html,https://root.cern,https://root.cern/root/html602/RooConvGenContext.html,2,['load'],['load']
Performance,"yname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDCacheFile.html:12137,cache,cacheDir,12137,root/html532/TDCacheFile.html,https://root.cern,https://root.cern/root/html532/TDCacheFile.html,2,['cache'],['cacheDir']
Performance,"you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occured while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton analysis class for this tree. The following files are produced: classname.h and classname.C.; If classname is 0, classname will be called ""nameoftree"". The generated code in classname.h includes the following:; - Identification of the original tree and the input file name.; - Definition of an analysis class (data members and member functions).; - The following member functions:; - constructor (by default opening the tree file),; - GetEntry(Long64_t entry),; - Init(TTree* tree) to initialize a ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:95695,Load,LoadTreeFriend,95695,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['Load'],"['Load', 'LoadTreeFriend']"
Performance,"yout=DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,DENSE|1|LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.9,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,MaxEpochs=10,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0.:Architecture=CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIER:Layout=DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,DENSE|1|LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.9,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,MaxEpochs=10,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0.:Architecture=CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""None"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : Layout: ""DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,DENSE|1|LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.9,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,MaxEpochs=10,WeightDecay=1e-4,Regularization=None,Optimizer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:2802,perform,performed,2802,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['perform'],['performed']
Performance,"ype STL container; TStreamerSTLstring Streamer element of type C++ string; TStreamerString Streamer element of type TString; TString Basic string class; TStringLong Long string class (more than 255 chars); TStringRef ; TStringToken String tokenizer using PCRE for finding next tokens.; TStructNode Node with information about class; TStructNodeEditor GUI fo editing TStructNode; TStructNodeProperty Class with nodes color property; TStructViewer A 3D struct viewer; TStructViewerGUI A GUI fo 3D struct viewer ; TStyle A collection of all graphics attributes; TStyleDialog Dialog box used by the TStyleManager class; TStyleManager Graphical User Interface for managing styles; TStylePreview Preview window used by the TStyleManager class; TSubString ; TSynapse simple weighted bidirectionnal connection between 2 neurons; TSysEvtHandler ABC for handling system events; TSystem ABC defining a generic interface to the OS; TSystemDirectory A system directory; TSystemFile A system file; TTF Interface to TTF font handling; TTRAP TRAP shape; TTRD1 TRD1 shape; TTRD2 TRD2 shape; TTUBE TUBE shape; TTUBS TUBS shape; TTVLVContainer A dragging-capable LVContainer; TTVLVEntry Item that goes into the tree list view widget; TTVRecord A draw record for TTreeViewer; TTVSession A tree viewer session; TTabCom Perform comand line completion when hitting <TAB>; TTable vector of the C structures; TTable3Points A 3-D Points; TTable::iterator ; TTableDescriptor descrpitor defining the internal layout of TTable objects; TTableIter Iterator over ""sorted"" TTable objects; TTableMap ""Map"" array for TTable object; TTablePadView3D ; TTablePoints Defines the TTable as an element of ""event"" geometry; TTableRange Range used in TGTable.; TTableSorter Is an ""observer"" class to sort the TTable objects; TTask Base class for tasks; TText Text; TThread Thread class; TThreadFactory Thread factory ABC; TThreadImp ThreadImp class; TTime Basic time type with milli second precision; TTimeStamp Encapsulates seconds and ns sin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:122377,Perform,Perform,122377,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,1,['Perform'],['Perform']
Performance,"ype or value (as is used here, “int”), or a string representation of the parameters (e.g. “‘double’”), or a mixture of both (e.g. “‘TCanvas, 0’” or “‘double’, 0” ). The “std::vector<int>” class is one of the classes builtin by default into the Cling extension dlls. You will get a non-functional class (instances of which can still be passed around to C++) if the corresponding dictionary doesn’t exist.; 19.1.5.3 Access to ROOT Globals; Most globals and global functions can be imported directly from the ROOT.py module, but some common ones (most notably gMinuit, although that variable now exists at startup from release 5.08 onward) do not exist yet at program startup, as they exist in modules that are loaded later (e.g. through the auto-loading mechanism). An example session should make this clear:; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; It is also possible to create globals interactively, either by executing a Cling macro, or by a call to gROOT.ProcessLine(). These globals are made available in the same way: either use them directly after creation in ‘from ROOT import *’ more, or get them from the ROOT namespace after an ‘import ROOT’.; As of 5.08, the behaviour of ROOT globals is the same as python globals, which is sometimes counterintuitive: since they are references, they can be changed only if done so directly through their containing module. The following session shows that in detail:; >>> from ROOT import *; >>> print(gDebug); 0; >>> gROOT.ProcessLine( 'gDebug = 7;' ); >>> print(gDe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1054094,load,loaded,1054094,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['load'],"['loaded', 'loading']"
Performance,"ype with the string representation of sequence information including 'cached','repeat','write' or 'nodelete'. ;  ; TMemberStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; virtual Bool_t HasCounter () const;  ; virtual Bool_t IsaPointer () const;  ; virtual Bool_t IsBase () const;  Return kTRUE if the element represent a base class. ;  ; virtual Bool_t IsOldFormat (const char *newTypeName);  The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeName instead of dm->GetFullTypename if this case is detected, the element type name is modified. ;  ; virtual Bool_t IsTransient () const;  Return kTRUE if the element represent an entity that is not written to the disk (transient members, cache allocator/deallocator, etc.) ;  ; void ls (Option_t *option="""") const override;  Print the content of the element. ;  ; virtual void SetArrayDim (Int_t dim);  Set number of array dimensions. ;  ; virtual void SetMaxIndex (Int_t dim, Int_t max);  set maximum index for array with dimension dim ;  ; virtual void SetNewClass (TClass *cl);  ; virtual void SetNewType (Int_t dtype);  ; virtual void SetOffset (Int_t offset);  ; virtual void SetSize (Int_t dsize);  ; virtual void SetStreamer (TMemberStreamer *streamer);  set pointer to Streamer function for this element ;  ; virtual void SetTObjectOffset (Int_t tobjoffset);  ; virtual void SetType (Int_t dtype);  ; virtual void SetTypeName (const char *name);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Update (const TClass *oldClass, TClass *newClass);  function called by the TClass constructor when replacing an emulated class by the real class ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerObject.html:3238,cache,cache,3238,doc/master/classTStreamerObject.html,https://root.cern,https://root.cern/doc/master/classTStreamerObject.html,2,['cache'],['cache']
Performance,"ype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsAnaConvPdf::makeCoefVarList(RooArgList&) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBCPEffDecay.html:33499,optimiz,optimizeDirtyHook,33499,root/html526/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html526/RooBCPEffDecay.html,18,['optimiz'],['optimizeDirtyHook']
Performance,"ype;  ; typedef IBaseFunctionMultiDimTempl< T > BaseFunc;  . Public Member Functions;  WrappedMultiTF1Templ (const WrappedMultiTF1Templ< T > &rhs);  Copy constructor. ;  ;  WrappedMultiTF1Templ (TF1 &f, unsigned int dim=0);  constructor from a function pointer to a TF1 If dim = 0 dimension is taken from TF1::GetNdim(). ;  ;  ~WrappedMultiTF1Templ () override;  Destructor (no operations). ;  ; WrappedMultiTF1Templ & operator= (const WrappedMultiTF1Templ< T > &rhs);  Assignment operator. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricGradFunctionMultiDimTempl< T >;  ~IParametricGradFunctionMultiDimTempl () override;  Virtual Destructor (no operations) ;  ; T operator() (const T *x) const;  ; T operator() (const T *x, const double *p) const;  ; T ParameterDerivative (const T *x, const double *p, unsigned int ipar=0) const;  Evaluate the partial derivative w.r.t a parameter ipar from values and parameters. ;  ; T ParameterDerivative (const T *x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values. ;  ; void ParameterGradient (const T *x, T *grad) const;  Evaluate all derivatives using cached parameter values. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricFunctionMultiDimTempl< T >; T operator() (const T *x) const;  ; T operator() (const T *x, const double *p) const;  Evaluate function at a point x and for given parameters p. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionMultiDimTempl< T >; virtual ~IBaseFunctionMultiDimTempl ()=default;  ; virtual bool HasGradient () const;  ; T operator() (const T *x) const;  Evaluate the function at a point x[]. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseParam; virtual ~IBaseParam ();  Virtual Destructor (no operations) ;  . interface inherited from IParamFunction; bool fLinear;  ; bool fPolynomial;  ; bool fOwnFunc;  ; TF1 * fFunc;  ; unsigned int fDim;  ; IMultiGenFunctionTempl< T > * Clone () const override;  Clo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedMultiTF1Templ.html:2634,cache,cached,2634,doc/master/classROOT_1_1Math_1_1WrappedMultiTF1Templ.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedMultiTF1Templ.html,1,['cache'],['cached']
Performance,"ype==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1710 return fFunctionDeleteIterator = TGenCollectionProxy__VectorDeleteSingleIterators;; 1711 else if ( (fProperties & kIsAssociative) && read); 1712 return TGenCollectionProxy__StagingDeleteSingleIterators;; 1713 else; 1714 return fFunctionDeleteIterator = TGenCollectionProxy__SlowDeleteSingleIterators;; 1715}; 1716 ; 1717////////////////////////////////////////////////////////////////////////////////; 1718/// See typedef void (*DeleteTwoIterators_t)(void *begin, void *end);; 1719/// If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,; 1720/// Otherwise just call the iterator's destructor.; 1721 ; 1722TVirtualCollectionProxy::DeleteTwoIterators_t TGenCollectionProxy::GetFunctionDeleteTwoIterators(Bool_t read); 1723{; 1724 if (read) {; 1725 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1726 if ( (fProperties & kIsAssociative) && read); 1727 return TGenCollectionProxy__StagingDeleteTwoIterators;; 1728 }; 1729 ; 1730 if ( fFunctionDeleteTwoIterators ) return fFunctionDeleteTwoIterators;; 1731 ; 1732 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1733 ; 1734 // TODO could RVec use something faster than SlowCopyIterator?; 1735 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1736 return fFunctionDeleteTwoIterators = TGenCollectionProxy__VectorDeleteTwoIterators;; 1737 else if ( (fProperties & kIsAssociative) && read); 1738 return TGenCollectionProxy__StagingDeleteTwoIterators;; 1739 else; 1740 return fFunctionDeleteTwoIterators = TGenCollectionProxy__SlowDeleteTwoIterators;; 1741}; 1742 ; 1743////////////////////////////////////////////////////////////////////////////////; 1744/// Return the set of action necessary to stream in this collection member-wise coming from; 1745/// the old value class layout refered to by 'version'.; 1746 ; 1747TStreamerInfoActions::TActionSequence *TGenCollectionProxy::GetConversionReadMe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:57883,load,load,57883,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['load'],['load']
Performance,"ypeNameconst char * MethodArgInfo_TypeName(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9312; TCling::GetInterpreterImplcling::Interpreter * GetInterpreterImpl() constDefinition TCling.h:644; TCling::ExecuteMacroLongptr_t ExecuteMacro(const char *filename, EErrorCode *error=nullptr) finalExecute a cling macro.Definition TCling.cxx:5403; TCling::fClassesToUpdatestd::vector< std::pair< TClass *, DictFuncPtr_t > > fClassesToUpdateDefinition TCling.h:146; TCling::DataMemberInfo_Nextint DataMemberInfo_Next(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8642; TCling::TypedefInfo_Nameconst char * TypedefInfo_Name(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9522; TCling::BaseClassInfo_Deletevoid BaseClassInfo_Delete(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8465; TCling::MethodInfo_ExtraPropertyLong_t MethodInfo_ExtraProperty(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9100; TCling::LoadMacrovoid LoadMacro(const char *filename, EErrorCode *error=nullptr) finalLoad a macro file in cling's memory.Definition TCling.cxx:3552; TCling::FuncTempInfo_FactoryCopyFuncTempInfo_t * FuncTempInfo_FactoryCopy(FuncTempInfo_t *) const finalConstruct a FuncTempInfo_t.Definition TCling.cxx:8826; TCling::DataMemberInfo_MaxIndexint DataMemberInfo_MaxIndex(DataMemberInfo_t *dminfo, Int_t dim) const finalDefinition TCling.cxx:8634; TCling::FuncTempInfo_IsValidBool_t FuncTempInfo_IsValid(FuncTempInfo_t *) const finalCheck validity of a FuncTempInfo_t.Definition TCling.cxx:8837; TCling::AddIncludePathvoid AddIncludePath(const char *path) finalAdd a directory to the list of directories in which the interpreter looks for include files.Definition TCling.cxx:2662; TCling::ClassInfo_IsBasebool ClassInfo_IsBase(ClassInfo_t *info, const char *name) const finalDefinition TCling.cxx:8287; TCling::RecursiveRemovevoid RecursiveRemove(TObject *obj) finalDelete object from cling symbol table so it can not be used anymore.Definition TCling.cxx:3683;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:431679,Load,LoadMacrovoid,431679,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,4,['Load'],"['LoadMacro', 'LoadMacrovoid']"
Performance,"yped column from a table HDU given its name. ; Definition at line 1296 of file TFITS.cxx. ◆ GetTabStringColumn() [2/2]. TObjArray * TFITSHDU::GetTabStringColumn ; (; Int_t ; colnum). Get a string-typed column from a table HDU given its column index (>=0). ; Definition at line 1266 of file TFITS.cxx. ◆ GetTabVarLengthVectorCell() [1/2]. TArrayD * TFITSHDU::GetTabVarLengthVectorCell ; (; Int_t ; rownum, . const char * ; colname . ). Get the variable-length array contained in a cell given by (row>=0, column name) ; Definition at line 1606 of file TFITS.cxx. ◆ GetTabVarLengthVectorCell() [2/2]. TArrayD * TFITSHDU::GetTabVarLengthVectorCell ; (; Int_t ; rownum, . Int_t ; colnum . ). Get the variable-length array contained in a cell given by (row>=0, column name) ; Definition at line 1583 of file TFITS.cxx. ◆ IsA(). TClass * TFITSHDU::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 145 of file TFITS.h. ◆ LoadHDU(). Bool_t TFITSHDU::LoadHDU ; (; TString & ; filepath_filter). protected . Load HDU from fits file satisfying the specified filter. ; Returns kTRUE if success. Otherwise kFALSE. If filter == """" then the primary array is selected ; Definition at line 237 of file TFITS.cxx. ◆ Print(). void TFITSHDU::Print ; (; const Option_t * ; opt = """"); const. override . Print metadata. ; Currently supported options:. """" : print HDU record data; ""F"" : print FITS file's extension names, numbers and types; ""F+"": print FITS file's extension names and types and their record data; ""T"" : print column information when HDU is a table; ""T+"" : print full table (columns header and rows) . Definition at line 858 of file TFITS.cxx. ◆ PrintColumnInfo(). void TFITSHDU::PrintColumnInfo ; (; const Option_t * ; ); const. protected . Print column information. ; Definition at line 766 of file TFITS.cxx. ◆ PrintFileMetadata(). void TFITSHDU::PrintFileMetadata ; (; const Option_t * ; opt = """"); const. protected . Print",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFITSHDU.html:23730,Load,LoadHDU,23730,doc/master/classTFITSHDU.html,https://root.cern,https://root.cern/doc/master/classTFITSHDU.html,1,['Load'],['LoadHDU']
Performance,"ypeinfo)Forward to TROOT::GetClass().Definition TBuffer.cxx:328; TBuffer::IsReadingBool_t IsReading() constDefinition TBuffer.h:86; TBuffer::fModeBool_t fModeDefinition TBuffer.h:48; TBuffer::GetReAllocFuncReAllocCharFun_t GetReAllocFunc() constReturn the reallocation method currently used.Definition TBuffer.cxx:277; TBuffer::fReAllocFuncReAllocCharFun_t fReAllocFuncDefinition TBuffer.h:55; TBuffer::fBufferchar * fBufferDefinition TBuffer.h:51; TBuffer::fParentTObject * fParentDefinition TBuffer.h:54; TBuffer::SetReadModevoid SetReadMode()Set buffer in read mode.Definition TBuffer.cxx:302; TBuffer::WriteClassBuffervirtual Int_t WriteClassBuffer(const TClass *cl, void *pointer)=0; TBuffer::fVersionInt_t fVersionDefinition TBuffer.h:49; TBuffer::LengthInt_t Length() constDefinition TBuffer.h:100; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TProcessIDA TProcessID identifies a ROOT job in a unique way in time and space.Definition TProcessID.h:74; TProcessID::GetPIDstatic TProcessID * GetPID()static: returns pointer to current TProcessIDDefinition TProcessID.cxx:343; TStorage::ReAllocCharstatic char * ReAllocChar(char *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:228; TVirtualArrayWrapper around an object and givin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBuffer_8cxx_source.html:20830,load,load,20830,doc/master/TBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html,1,['load'],['load']
Performance,"ypename AReal = Float_t> . void TMVA::DNN::TCuda< AFloat >::ConstMult ; (; Matrix_t & ; A, . Scalar_t ; beta . ). static . Multiply the constant beta to all the elements of matrix A and write the result into A. ; Definition at line 371 of file Arithmetic.cu. ◆ ConvLayerBackward(). template<typename AReal = Float_t> . void TMVA::DNN::TCuda< AFloat >::ConvLayerBackward ; (; Tensor_t & ; activationGradientsBackward, . Matrix_t & ; weightGradients, . Matrix_t & ; biasGradients, . Tensor_t & ; df, . Tensor_t & ; activationGradients, . const Matrix_t & ; weights, . const Tensor_t & ; activationBackward, . const Tensor_t & ; outputTensor, . EActivationFunction ; activFunc, . const ConvDescriptors_t & ; , . ConvWorkspace_t & ; , . size_t ; batchSize, . size_t ; inputHeight, . size_t ; inputWidth, . size_t ; depth, . size_t ; height, . size_t ; width, . size_t ; filterDepth, . size_t ; filterHeight, . size_t ; filterWidth, . size_t ; nLocalViews . ). static . Perform the complete backward propagation step in a Convolutional Layer. ; If the provided activationGradientsBackward matrix is not empty, compute the gradients of the objective function with respect to the activations of the previous layer (backward direction). Also compute the weight and the bias gradients. Modifies the values in df and thus produces only a valid result, if it is applied the first time after the corresponding forward propagation has been per- formed. ; Definition at line 276 of file Propagation.cu. ◆ ConvLayerForward(). template<typename AReal = Float_t> . void TMVA::DNN::TCuda< AFloat >::ConvLayerForward ; (; Tensor_t & ; output, . Tensor_t & ; inputActivationFunc, . const Tensor_t & ; input, . const Matrix_t & ; weights, . const Matrix_t & ; biases, . const DNN::CNN::TConvParams & ; params, . EActivationFunction ; activFunc, . Tensor_t & ; , . const ConvDescriptors_t & ; , . ConvWorkspace_t & ;  . ). static . Forward propagation in the Convolutional layer. ; Definition at line 236 of file Propagatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCuda.html:38303,Perform,Perform,38303,doc/master/classTMVA_1_1DNN_1_1TCuda.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCuda.html,1,['Perform'],['Perform']
Performance,"ypename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::fPastSquaredWeightGradients. protected . The sum of the square of the past weight gradients associated with the deep net. ; Definition at line 55 of file RMSProp.h. ◆ fRho. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Scalar_t TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::fRho. protected . The Rho constant used by the optimizer. ; Definition at line 52 of file RMSProp.h. ◆ fWeightUpdates. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::fWeightUpdates. protected . The accumulation of the past Weights for performing updates. ; Definition at line 59 of file RMSProp.h. ◆ fWorkBiasTensor1. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::fWorkBiasTensor1. protected . working tensor used to keep a temporary copy of bias or bias gradients ; Definition at line 64 of file RMSProp.h. ◆ fWorkBiasTensor2. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::fWorkBiasTensor2. protected . working tensor used to keep a temporary copy of bias or bias gradients ; Definition at line 68 of file RMSProp.h. ◆ fWorkWeightTensor1. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html:13331,perform,performing,13331,doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,1,['perform'],['performing']
Performance,"ypename R = typename TTraits::CallableTraits<AccFun>::ret_type, typename ArgTypes = typename TTraits::CallableTraits<AccFun>::arg_types, typename U = TTraits::TakeFirstParameter_t<ArgTypes>, typename T = TTraits::TakeFirstParameter_t<TTraits::RemoveFirstParameter_t<ArgTypes>>> ; RResultPtr< U > Aggregate (AccFun aggregator, MergeFun merger, std::string_view columnName="""");  Execute a user-defined accumulation operation on the processed column values in each processing slot. ;  ; RInterface< Proxied, DS_t > Alias (std::string_view alias, std::string_view columnName);  Allow to refer to a column with a different name. ;  ; template<typename FirstColumn = RDFDetail::RInferredType, typename... OtherColumns, typename Helper > ; RResultPtr< typename std::decay_t< Helper >::Result_t > Book (Helper &&helper, const ColumnNames_t &columns={});  Book execution of a custom action using a user-defined helper object. ;  ; template<typename... ColumnTypes> ; RInterface< RLoopManager > Cache (const ColumnNames_t &columnList);  Save selected columns in memory. ;  ; RInterface< RLoopManager > Cache (const ColumnNames_t &columnList);  Save selected columns in memory. ;  ; RInterface< RLoopManager > Cache (std::initializer_list< std::string > columnList);  Save selected columns in memory. ;  ; RInterface< RLoopManager > Cache (std::string_view columnNameRegexp="""");  Save selected columns in memory. ;  ; RResultPtr< ULong64_t > Count ();  Return the number of entries processed (lazy action). ;  ; template<typename T > ; RInterface< Proxied, DS_t > DefaultValueFor (std::string_view column, const T &defaultValue);  In case the value in the given column is missing, provide a default value. ;  ; template<typename F , typename std::enable_if_t<!std::is_convertible< F, std::string >::value, int > = 0> ; RInterface< Proxied, DS_t > Define (std::string_view name, F expression, const ColumnNames_t &columns={});  Define a new column. ;  ; RInterface< Proxied, DS_t > Define (std::string_view name, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:3176,Cache,Cache,3176,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['Cache'],['Cache']
Performance,"ypes defined (in range named rangeName if rangeName!=nullptr) ;  ; Int_t getIndex () const;  Retrieve the current index. Use getCurrentIndex() for more clarity. ;  ; const char * getLabel () const;  Retrieve current label. Use getCurrentLabel() for more clarity. ;  ; virtual bool isValid (const RooCatType &value) const;  Check if given state is defined for this object. ;  ; const RooCatType * defineType (const char *label);  ; const RooCatType * defineType (const char *label, int index);  ; const RooCatType * defineTypeUnchecked (const char *label, value_type index);  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooAbsCategory.h>. Inheritance diagram for RooAbsCategory:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ value_type. using RooAbsCategory::value_type = int. The type used to denote a specific category state. ; Definition at line 36 of file RooAbsCategory.h. Constructor & Destructor Documentation. ◆ RooAbsCategory() [1/3]. RooAbsCategory::RooAbsCategory ; (; ). Definition at line 76 of file RooAbsCategory.cxx. ◆ RooAbsCategory() [2/3]. RooAbsCategory::RooAbsCategory ; (; const char * ; name, . const char * ; title . ). Constructor. ; Definition at line 82 of file RooAbsCategory.cxx. ◆ Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategory.html:45367,cache,cache,45367,doc/master/classRooAbsCategory.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategory.html,1,['cache'],['cache']
Performance,"ypes::EMVA theMethod, TString methodTitle,; 2359 const char *theOption); 2360{; 2361 uint64_t x = 0;; 2362 uint64_t y = 0;; 2363 ; 2364 // getting number of variables and variable names from loader; 2365 const int nbits = loader->GetDataSetInfo().GetNVariables();; 2366 std::vector<TString> varNames = loader->GetDataSetInfo().GetListOfVariables();; 2367 ; 2368 if (nbits > 60) {; 2369 Log() << kERROR << ""Number of combinations is too large , is 2^"" << nbits << Endl;; 2370 return nullptr;; 2371 }; 2372 long int range = sum(nbits);; 2373 // std::cout<<range<<std::endl;; 2374 // vector to save importances; 2375 std::vector<Double_t> importances(nbits);; 2376 for (int i = 0; i < nbits; i++); 2377 importances[i] = 0;; 2378 ; 2379 Double_t SROC, SSROC; // computed ROC value; 2380 ; 2381 x = range;; 2382 ; 2383 std::bitset<VIBITS> xbitset(x);; 2384 if (x == 0); 2385 Log() << kFATAL << ""Error: need at least one variable.""; // data loader need at least one variable; 2386 ; 2387 // creating loader for seed; 2388 TMVA::DataLoader *seedloader = new TMVA::DataLoader(xbitset.to_string());; 2389 ; 2390 // adding variables from seed; 2391 for (int index = 0; index < nbits; index++) {; 2392 if (xbitset[index]); 2393 seedloader->AddVariable(varNames[index], 'F');; 2394 }; 2395 ; 2396 // Loading Dataset; 2397 DataLoaderCopy(seedloader, loader);; 2398 ; 2399 // Booking Seed; 2400 BookMethod(seedloader, theMethod, methodTitle, theOption);; 2401 ; 2402 // Train/Test/Evaluation; 2403 TrainAllMethods();; 2404 TestAllMethods();; 2405 EvaluateAllMethods();; 2406 ; 2407 // getting ROC; 2408 SROC = GetROCIntegral(xbitset.to_string(), methodTitle);; 2409 ; 2410 // cleaning information to process sub-seeds; 2411 TMVA::MethodBase *smethod = dynamic_cast<TMVA::MethodBase *>(fMethodsMap[xbitset.to_string().c_str()][0][0]);; 2412 TMVA::ResultsClassification *sresults = (TMVA::ResultsClassification *)smethod->Data()->GetResults(; 2413 smethod->GetMethodName(), Types::kTesting, Types::kClassification);;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:99619,load,loader,99619,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,2,['load'],['loader']
Performance,"ypesCore.h:69; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; x1Option_t Option_t TPoint TPoint const char x1Definition TGWin32VirtualXProxy.cxx:70; y2Option_t Option_t TPoint TPoint const char y2Definition TGWin32VirtualXProxy.cxx:70; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; namechar name[80]Definition TGX11.cxx:110; TH2.h; TCollectionCollection abstract base class.Definition TCollection.h:65; TF11-Dim function classDefinition TF1.h:233; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::Multiplyvirtual Bool_t Multiply(TF1 *f1, Double_t c1=1)Performs the operation:Definition TH1.cxx:6049; TH1::Dividevirtual Bool_t Divide(TF1 *f1, Double_t c1=1)Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:2840; TH2PolyBinHelper class to represent a bin in the TH2Poly histogram.Definition TH2Poly.h:25; TH2PolyBin::GetXMinDouble_t GetXMin()Returns the minimum value for the x coordinates of the bin.Definition TH2Poly.cxx:1565; TH2PolyBin::GetChangedBool_t GetChanged() constDefinition TH2Poly.h:36; TH2PolyBin::~TH2PolyBin~TH2PolyBin() overrideDestructor.Definition TH2Poly.cxx:1491; TH2PolyBin::GetYMaxDouble_t GetYMax()Returns the maximum value for the y coordinates of the bin.Definition TH2Poly.cxx:1601; TH2PolyBin::GetAreaDouble_t GetArea()Returns the area of the bin.Definition TH2Poly.cxx:1499; TH2PolyBin::ClearContentvoid ClearContent()Definition TH2Poly.h:32; TH2PolyBin::Fillvoid Fill(Double_t w)Definition TH2Poly.h:33; TH2PolyBin::GetYMinDouble_t GetYMin()Returns the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2Poly_8h_source.html:10750,Perform,Performs,10750,doc/master/TH2Poly_8h_source.html,https://root.cern,https://root.cern/doc/master/TH2Poly_8h_source.html,1,['Perform'],['Performs']
Performance,"ypesTCollection * fTypesList of data types definition.Definition TROOT.h:141; TROOT::GetColorTColor * GetColor(Int_t color) constReturn address of color with index color.Definition TROOT.cxx:1536; TROOT::GetGlobalTGlobal * GetGlobal(const char *name, Bool_t load=kFALSE) constReturn pointer to global variable by name.Definition TROOT.cxx:1631; TROOT::FindSTLClassTClass * FindSTLClass(const char *name, Bool_t load, Bool_t silent=kFALSE) constreturn a TClass object corresponding to 'name' assuming it is an STL container.Definition TROOT.cxx:1484; TROOT::fStreamerInfoTSeqCollection * fStreamerInfoList of active StreamerInfo classes.Definition TROOT.h:159; TROOT::Appendvoid Append(TObject *obj, Bool_t replace=kFALSE) overrideAppend object to this directory.Definition TROOT.cxx:1047; TROOT::GetIconPathstatic const TString & GetIconPath()Get the icon path in the installation. Static utility function.Definition TROOT.cxx:3168; TROOT::GetListOfGlobalFunctionsTCollection * GetListOfGlobalFunctions(Bool_t load=kFALSE)Return list containing the TFunctions currently defined.Definition TROOT.cxx:1826; TROOT::fGitDateTString fGitDateDate and time when make was run.Definition TROOT.h:122; TROOT::fSpecialsTSeqCollection * fSpecialsList of special objects.Definition TROOT.h:156; TROOT::GetListOfFunctionTemplatesTCollection * GetListOfFunctionTemplates()Definition TROOT.cxx:1771; TROOT::RegisterModulestatic void RegisterModule(const char *modulename, const char **headers, const char **includePaths, const char *payLoadCode, const char *fwdDeclCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, bool hasCxxModule=false)Called by static dictionary initialization to register clang modules for headers.Definition TROOT.cxx:2535; TROOT::FindObjectTObject * FindObject(const char *name) const overrideReturns address of a ROOT object if it exists.Definition TROOT.cxx:1313; TROOT::fClassesTCollection * fClassesList of classes definition.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:150885,load,load,150885,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,1,['load'],['load']
Performance,"ypesTCollection * fTypesList of data types definition.Definition TROOT.h:141; TROOT::GetColorTColor * GetColor(Int_t color) constReturn address of color with index color.Definition TROOT.cxx:1536; TROOT::GetGlobalTGlobal * GetGlobal(const char *name, Bool_t load=kFALSE) constReturn pointer to global variable by name.Definition TROOT.cxx:1631; TROOT::FindSTLClassTClass * FindSTLClass(const char *name, Bool_t load, Bool_t silent=kFALSE) constreturn a TClass object corresponding to 'name' assuming it is an STL container.Definition TROOT.cxx:1484; TROOT::fStreamerInfoTSeqCollection * fStreamerInfoList of active StreamerInfo classes.Definition TROOT.h:159; TROOT::Appendvoid Append(TObject *obj, Bool_t replace=kFALSE) overrideAppend object to this directory.Definition TROOT.cxx:1047; TROOT::GetIconPathstatic const TString & GetIconPath()Get the icon path in the installation. Static utility function.Definition TROOT.cxx:3172; TROOT::GetListOfGlobalFunctionsTCollection * GetListOfGlobalFunctions(Bool_t load=kFALSE)Return list containing the TFunctions currently defined.Definition TROOT.cxx:1826; TROOT::fGitDateTString fGitDateDate and time when make was run.Definition TROOT.h:122; TROOT::fSpecialsTSeqCollection * fSpecialsList of special objects.Definition TROOT.h:156; TROOT::GetListOfFunctionTemplatesTCollection * GetListOfFunctionTemplates()Definition TROOT.cxx:1771; TROOT::RegisterModulestatic void RegisterModule(const char *modulename, const char **headers, const char **includePaths, const char *payLoadCode, const char *fwdDeclCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, bool hasCxxModule=false)Called by static dictionary initialization to register clang modules for headers.Definition TROOT.cxx:2535; TROOT::FindObjectTObject * FindObject(const char *name) const overrideReturns address of a ROOT object if it exists.Definition TROOT.cxx:1313; TROOT::fClassesTCollection * fClassesList of classes definition.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:151061,load,load,151061,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['load'],['load']
Performance,"ypewhat', e.g. 'std:max:'; type = 'std:' draw standard evt/s plot; 'stdx:' draw standard evt/s plot, 1 worker per node; 'norm:' draw normalized plot; 'normx:' draw normalized plot, 1 worker per node; what = 'max:' draw max rate; 'avg:' draw average rate; 'all:' draw max and average rate on same plot (default); dofit = 0 no fit; 1 fit with the relevant '1st degree related' function; 2 fit with the relevant '2nd degree related' function; 3 fit with varying rcpu function; n0 = for dofit == 3, number of real cores; n1 = for dofit == 3, number of total cores (real + hyperthreaded). TGraphErrors * GetGraph(TDirectory* d, const char* pfn, Int_t& nb, Double_t& xmi, Double_t& xmx, Double_t& ymi, Double_t& ymx, Int_t& kmx, TProfile*& pf); Get from TDirectory 'd' the TProfile named 'pfn' and create the graph.; Return also the max y in mx. void AssertFittingFun(Double_t mi, Double_t mx); Make sure that the fitting functions are defined. void GetPerfSpecs(const char* path = ""."", Int_t degfit = 1); Get performance specs. Check file 'path', or files in directory 'path'; (default current directory).; The degree of the polynomial used for the fit is 'degfit' (default 1). Int_t RunDataSet(const char* dset = ""BenchDataSet"", Int_t start = 1, Int_t stop = -1, Int_t step = 1); Perform a test using dataset 'dset'; Return 0 on success, -1 on error; Open the file for the results. Int_t RunDataSetx(const char* dset = ""BenchDataSet"", Int_t start = 1, Int_t stop = -1); Perform a test using dataset 'dset' scanning over the number of workers; per node.; Return 0 on success, -1 on error; Open the file for the results. void DrawDataSet(const char* outfile, const char* opt = ""std:"", const char* type = ""mbs"", Bool_t verbose = kFALSE, Int_t dofit = 0, Int_t n0 = -1, Int_t n1 = -1); Draw the CPU speedup plot.; opt = 'typewhat', e.g. 'std:max:'; type = 'std:' draw standard plot; 'stdx:' draw standard plot, 1 worker per node; 'norm:' draw normalized plot; 'normx:' draw normalized plot, 1 worker per node",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofBench.html:11063,perform,performance,11063,root/html534/TProofBench.html,https://root.cern,https://root.cern/root/html534/TProofBench.html,3,['perform'],['performance']
Performance,"ys =1. The max length of second step is SLAMBG. The max size of subsequent steps is the maximum previous successful step multiplied by ALPHA + the size of most recent successful step, but cannot be smaller than SLAMBG. ; Definition at line 4736 of file TMinuit.cxx. ◆ mnmatu(). void TMinuit::mnmatu ; (; Int_t ; kode). virtual . Prints the covariance matrix v when KODE=1. ; always prints the global correlations, and calculates and prints the individual correlation coefficients ; Definition at line 4968 of file TMinuit.cxx. ◆ mnmigr(). void TMinuit::mnmigr ; (; ). virtual . Performs a local function minimization. ; Performs a local function minimization using basically the method of Davidon-Fletcher-Powell as modified by Fletcher; ref. – Fletcher, Comp.J. 13,317 (1970) ""switching method"" ; Definition at line 5048 of file TMinuit.cxx. ◆ mnmnos(). void TMinuit::mnmnos ; (; ). virtual . Performs a MINOS error analysis. ; Performs a MINOS error analysis on those parameters for which it is requested on the MINOS command by calling MNMNOT for each parameter requested. ; Definition at line 5388 of file TMinuit.cxx. ◆ mnmnot(). void TMinuit::mnmnot ; (; Int_t ; ilax, . Int_t ; ilax2, . Double_t & ; val2pl, . Double_t & ; val2mi . ). virtual . Performs a MINOS error analysis on one parameter. ; The parameter ILAX is varied, and the minimum of the function with respect to the other parameters is followed until it crosses the value FMIN+UP. ; Definition at line 5463 of file TMinuit.cxx. ◆ mnparm(). void TMinuit::mnparm ; (; Int_t ; k1, . TString ; cnamj, . Double_t ; uk, . Double_t ; wk, . Double_t ; a, . Double_t ; b, . Int_t & ; ierflg . ). virtual . Implements one parameter definition. ; Called from MNPARS and user-callable Implements one parameter definition, that is:; K (external) parameter number; CNAMK parameter name; UK starting value; WK starting step size or uncertainty; A, B lower and upper physical parameter limits and sets up (updates) the parameter lists. Output:; IE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:56549,Perform,Performs,56549,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,1,['Perform'],['Performs']
Performance,ys validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooArgSetRooAbsOptTestStatistic::_cachedNodes! List of nodes that are cached as constant expressions; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**RooAbsTestStatistic::_gofArray! Array of sub-contexts r,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataWeightedAverage.html:36592,cache,cache,36592,root/html534/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html534/RooDataWeightedAverage.html,1,['cache'],['cache']
Performance,"ys with the sorted values.Definition TGraph.cxx:2592; TGraph::GetNInt_t GetN() constDefinition TGraph.h:132; TGraph::fYDouble_t * fY[fNpoints] array of Y pointsDefinition TGraph.h:48; TGraph::SaveArrayTString SaveArray(std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr)Save array as C++ code Returns name of created array.Definition TGraph.cxx:2175; TGraph::ComputeRangevirtual void ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) constCompute the x/y range of the points in this graph.Definition TGraph.cxx:731; TGraph::Scalevirtual void Scale(Double_t c1=1., Option_t *option=""y"")Multiply the values of a TGraph by a constant c1.Definition TGraph.cxx:2259; TGraph::SwapValuesstatic void SwapValues(Double_t *arr, Int_t pos1, Int_t pos2)Swap values.Definition TGraph.cxx:2611; TGraph::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraph.Definition TGraph.cxx:2516; TGraph::DoMergevirtual Bool_t DoMerge(const TGraph *g)protected function to perform the merge operation of a graphDefinition TGraph.cxx:2676; TGraph::SwapPointsvirtual void SwapPoints(Int_t pos1, Int_t pos2)Swap points.Definition TGraph.cxx:2583; TGraph::FillZerovirtual void FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE)Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes.Definition TGraph.cxx:1102; TGraph::fXDouble_t * fX[fNpoints] array of X pointsDefinition TGraph.h:47; TGraph::Setvirtual void Set(Int_t n)Set number of points in the graph Existing coordinates are preserved New coordinates above fNpoints a...Definition TGraph.cxx:2277; TGraph::GetPointvirtual Int_t GetPoint(Int_t i, Double_t &x, Double_t &y) constGet x and y values for point number i.Definition TGraph.cxx:1533; TGraph::CopyPointsvirtual Bool_t CopyPoints(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin)Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin !...Definit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:38716,perform,perform,38716,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['perform'],['perform']
Performance,"ys written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the ex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:3609,cache,cache,3609,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,3,['cache'],['cache']
Performance,"ys written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. It is not simple to activate the cache; by default (except case1 below) because there are many possible configurations.; In some applications you know a priori the list of branches to read.; In other applications the analysis loop calls several layers of user functions; where it is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:3568,cache,cache,3568,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,3,['cache'],['cache']
Performance,"ys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTEveJetConeGL::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveJetConeProjectedGL.html:1879,cache,cached,1879,root/html528/TEveJetConeProjectedGL.html,https://root.cern,https://root.cern/root/html528/TEveJetConeProjectedGL.html,3,['cache'],['cached']
Performance,"ys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTPointSet3DGL::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTPointSet3DGL::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidTPointSet3DGL::SetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTPointSet3DGL::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tSupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveTrackGL.html:1819,cache,cached,1819,root/html528/TEveTrackGL.html,https://root.cern,https://root.cern/root/html528/TEveTrackGL.html,3,['cache'],['cached']
Performance,"ysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidDLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveJetConeGL.html:1806,cache,cached,1806,root/html528/TEveJetConeGL.html,https://root.cern,https://root.cern/root/html528/TEveJetConeGL.html,3,['cache'],['cached']
Performance,"ysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveProjectionAxesGL.html:1848,cache,cached,1848,root/html528/TEveProjectionAxesGL.html,https://root.cern,https://root.cern/root/html528/TEveProjectionAxesGL.html,7,['cache'],['cached']
Performance,"ysics with mixing and/or CP violation ;  ; file  rf709_BarlowBeeston.C;   Implementing the Barlow-Beeston method for taking into account the statistical uncertainty of a Monte-Carlo fit template. ;  ; file  rf709_BarlowBeeston.py;   Implementing the Barlow-Beeston method for taking into account the statistical uncertainty of a Monte-Carlo fit template. ;  ; file  rf710_roopoly.C;   Taylor expansion of RooFit functions using the taylorExpand function with RooPolyFunc ;  ; file  rf710_roopoly.py;   Taylor expansion of RooFit functions using the taylorExpand function ;  ; file  rf711_lagrangianmorph.C;   Morphing effective field theory distributions with RooLagrangianMorphFunc A morphing function as a function of one coefficient is setup and can be used to obtain the distribution for any value of the coefficient. ;  ; file  rf711_lagrangianmorph.py;   Morphing effective field theory distributions with RooLagrangianMorphFunc. ;  ; file  rf712_lagrangianmorphfit.C;   Performing a simple fit with RooLagrangianMorphFunc. ;  ; file  rf712_lagrangianmorphfit.py;   Performing a simple fit with RooLagrangianMorphFunc ;  ; file  rf801_mcstudy.C;   Validation and MC studies: toy Monte Carlo study that perform cycles of event generation and fitting ;  ; file  rf801_mcstudy.py;   Validation and MC studies: toy Monte Carlo study that perform cycles of event generation and fitting ;  ; file  rf802_mcstudy_addons.C;   Validation and MC studies: RooMCStudy - using separate fit and generator models, using the chi^2 calculator model Running a biased fit model against an optimal fit. ;  ; file  rf803_mcstudy_addons2.C;   Validation and MC studies: RooMCStudy - Using the randomizer and profile likelihood add-on models ;  ; file  rf804_mcstudy_constr.C;   Validation and MC studies: using RooMCStudy on models with constrains ;  ; file  rf901_numintconfig.C;   Numeric algorithm tuning: configuration and customization of how numeric (partial) integrals are executed ;  ; file  rf901_numintconfi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__roofit.html:22660,Perform,Performing,22660,doc/master/group__tutorial__roofit.html,https://root.cern,https://root.cern/doc/master/group__tutorial__roofit.html,1,['Perform'],['Performing']
Performance,"ystem.; Definition at line 3786 of file TWinNTSystem.cxx. ◆ GetGUIThreadHandle(). void * TWinNTSystem::GetGUIThreadHandle ; (; ); const. inline . Definition at line 114 of file TWinNTSystem.h. ◆ GetGUIThreadId(). ULong_t TWinNTSystem::GetGUIThreadId ; (; ); const. inline . Definition at line 115 of file TWinNTSystem.h. ◆ GetHomeDirectory(). std::string TWinNTSystem::GetHomeDirectory ; (; const char * ; userName = nullptr); const. overridevirtual . Return the user's home directory. ; Reimplemented from TSystem.; Definition at line 2214 of file TWinNTSystem.cxx. ◆ GetHostByName(). TInetAddress TWinNTSystem::GetHostByName ; (; const char * ; server). overridevirtual . Get Internet Protocol (IP) address of host. ; Reimplemented from TSystem.; Definition at line 4688 of file TWinNTSystem.cxx. ◆ GetLibraries(). const char * TWinNTSystem::GetLibraries ; (; const char * ; regexp = """", . const char * ; options = """", . Bool_t ; isRegexp = kTRUE . ). overridevirtual . Return a space separated list of loaded shared libraries. ; This list is of a format suitable for a linker, i.e it may contain -Lpathname and/or -lNameOfLib. Option can be any of: S: shared libraries loaded at the start of the executable, because they were specified on the link line. D: shared libraries dynamically loaded after the start of the program. L: list the .LIB rather than the .DLL (this is intended for linking) [This options is not the default] ; Reimplemented from TSystem.; Definition at line 4307 of file TWinNTSystem.cxx. ◆ GetLinkedLibraries(). const char * TWinNTSystem::GetLinkedLibraries ; (; ). overrideprivatevirtual . Get list of shared libraries loaded at the start of the executable. ; Returns 0 in case list cannot be obtained or in case of error. ; Reimplemented from TSystem.; Definition at line 4153 of file TWinNTSystem.cxx. ◆ GetMemInfo(). Int_t TWinNTSystem::GetMemInfo ; (; MemInfo_t * ; info); const. overridevirtual . Returns ram and swap memory usage info into the MemInfo_t structure. ; Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:53674,load,loaded,53674,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['load'],['loaded']
Performance,"ystem::FindFilevirtual const char * FindFile(const char *search, TString &file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1538; TSystem::mkdirvirtual int mkdir(const char *name, Bool_t recursive=kFALSE)Make a file system directory.Definition TSystem.cxx:906; TSystem::MakeDirectoryvirtual int MakeDirectory(const char *name)Make a directory.Definition TSystem.cxx:827; TSystem::ExpandFileNamevirtual const char * ExpandFileName(const char *fname)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1098; TSystem::RemoveFileHandlervirtual TFileHandler * RemoveFileHandler(TFileHandler *fh)Remove a file handler from the list of file handlers.Definition TSystem.cxx:564; TSystem::fSigcntInt_t fSigcntDefinition TSystem.h:283; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::OpenPipevirtual FILE * OpenPipe(const char *command, const char *mode)Open a pipe.Definition TSystem.cxx:662; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::GetDirEntryvirtual const char * GetDirEntry(void *dirp)Get a directory entry. Returns 0 if no more entries.Definition TSystem.cxx:853; TSystem::Initvirtual Bool_t Init()Initialize the OS interface.Definition TSystem.cxx:183; TS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:197276,load,loaded,197276,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['load'],['loaded']
Performance,"ystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::GetFPEMaskvirtual Int_t GetFPEMask()Return the bitmap of conditions that trigger a floating point exception.Definition TSystem.cxx:632; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; TSystem::StackTracevirtual void StackTrace()Print a stack trace.Definition TSystem.cxx:734; TSystem::GetUserInfovirtual UserGroup_t * GetUserInfo(Int_t uid)Returns all user info in the UserGroup_t structure.Definition TSystem.cxx:1601; TSystem::ResetSignalsvirtual void ResetSignals()Reset signals handlers to previous behaviour.Definition TSystem.cxx:584; TSystem::fBuildNodeTString fBuildNodeDefinition TSystem.h:306; TSystem::TempDirectoryvirtual const char * TempDirectory() constReturn a user configured or systemwide directory to create temporary files in.Definition TSystem.cxx:1482; TSystem::GetFlagsOptvirtual const char * GetFlagsOpt() constReturn the optimization flags.Definition TSystem.cxx:3935; TSystem::ConsistentWithvirtual Bool_t ConsistentWith(const char *path, void *dirptr=nullptr)Check consistency of this helper with the one required by 'path' or 'dirptr'.Definition TSystem.cxx:804; TSystem::DynamicPathNamechar * DynamicPathName(const char *lib, Bool_t quiet=kFALSE)Find a dynamic library called lib using the system search paths.Definition TSystem.cxx:2020; TTimeBasic time type with millisecond precision.Definition TTime.h:27; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::GetAbsTimeTTime GetAbsTime() constDefinition TTimer.h:78; TTimer::TurnOnvirtual void TurnOn()Add the timer to the system timer list.Definition TTimer.cxx:243; TTimer::IsAsyncBool_t IsAsync() constDefinition TTimer.h:81; TTimer::Resetvoid Reset()Reset the timer.Definition TTimer.cxx:159; TTimer::IsInterruptingSyscallsBool_t IsInterruptingSyscalls() constDefinition TTimer.h:82; TTimer::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:194959,optimiz,optimization,194959,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['optimiz'],['optimization']
Performance,"ystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::GetFPEMaskvirtual Int_t GetFPEMask()Return the bitmap of conditions that trigger a floating point exception.Definition TSystem.cxx:632; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; TSystem::StackTracevirtual void StackTrace()Print a stack trace.Definition TSystem.cxx:734; TSystem::GetUserInfovirtual UserGroup_t * GetUserInfo(Int_t uid)Returns all user info in the UserGroup_t structure.Definition TSystem.cxx:1601; TSystem::ResetSignalsvirtual void ResetSignals()Reset signals handlers to previous behaviour.Definition TSystem.cxx:584; TSystem::fBuildNodeTString fBuildNodeDefinition TSystem.h:306; TSystem::TempDirectoryvirtual const char * TempDirectory() constReturn a user configured or systemwide directory to create temporary files in.Definition TSystem.cxx:1482; TSystem::GetFlagsOptvirtual const char * GetFlagsOpt() constReturn the optimization flags.Definition TSystem.cxx:3935; TSystem::ConsistentWithvirtual Bool_t ConsistentWith(const char *path, void *dirptr=nullptr)Check consistency of this helper with the one required by 'path' or 'dirptr'.Definition TSystem.cxx:804; TSystem::DynamicPathNamechar * DynamicPathName(const char *lib, Bool_t quiet=kFALSE)Find a dynamic library called lib using the system search paths.Definition TSystem.cxx:2020; TTimeBasic time type with millisecond precision.Definition TTime.h:27; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; int; nconst Int_t nDefinition legend1.C:16; CpuInfo_tDefinition TSystem.h:163; CpuInfo_t::~CpuInfo_tvirtual ~CpuInfo_t()Definition TSystem.h:173; CpuInfo_t::fIdleFloat_t fIdleDefinition TSystem.h:170; CpuInfo_t::fLoad15mFloat_t fLoad15mDefinition TSystem.h:166; CpuInfo_t::fUserFloat_t fUserDefinition TSy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:63867,optimiz,optimization,63867,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['optimiz'],['optimization']
Performance,"ytes read.Definition TBranch.cxx:1706; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented in TChain.; Definition at line 8529 of file TTree.cxx. ◆ SetBranchStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8660 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8821 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:207604,cache,cacheSize,207604,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['cache'],['cacheSize']
Performance,"ytes read.Definition TBranch.cxx:1706; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented in TChain.; Definition at line 8534 of file TTree.cxx. ◆ SetBranchStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8665 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8831 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8865 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8683 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:210095,cache,cacheSize,210095,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['cache'],['cacheSize']
Performance,"ytes=0)Definition TFile.cxx:4611; TFile::fgCacheFileForcestatic Bool_t fgCacheFileForceIndicates, to force all READ to CACHEREAD.Definition TFile.h:126; TFile::fBytesReadLong64_t fBytesReadNumber of bytes read from this file.Definition TFile.h:76; TFile::GetSeekFreevirtual Long64_t GetSeekFree() constDefinition TFile.h:252; TFile::ReadProcessIDvirtual TProcessID * ReadProcessID(UShort_t pidf)The TProcessID with number pidf is read from this file.Definition TFile.cxx:1951; TFile::lsvoid ls(Option_t *option="""") const overrideList file contents.Definition TFile.cxx:1457; TFile::Seekvirtual void Seek(Long64_t offset, ERelativeTo pos=kBeg)Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd.Definition TFile.cxx:2274; TFile::GetOnlyStagedstatic Bool_t GetOnlyStaged()Returns staged only flag.Definition TFile.cxx:4754; TFile::IncrementFileCounterstatic void IncrementFileCounter()Definition TFile.cxx:4620; TFile::ShrinkCacheFileDirstatic Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval=0)Try to shrink the cache to the desired size.Definition TFile.cxx:4666; TFile::fSeekFreeLong64_t fSeekFreeLocation on disk of free segments structure.Definition TFile.h:80; TFile::fgReadaheadSizestatic Int_t fgReadaheadSizeReadahead buffer size.Definition TFile.h:134; TFile::FillBuffervoid FillBuffer(char *&buffer) overrideEncode file output buffer.Definition TFile.cxx:1170; TFile::fSum2BufferDouble_t fSum2BufferSum of squares of buffer sizes of objects written so far.Definition TFile.h:74; TFile::SetReadaheadSizestatic void SetReadaheadSize(Int_t bufsize=256000)Definition TFile.cxx:4605; TFile::fgCacheFileDisconnectedstatic Bool_t fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file.Definition TFile.h:125; TFile::GetStreamerInfoCacheconst TList * GetStreamerInfoCache()Returns the cached list of StreamerInfos used in this file.Definition TFile.cxx:1366; TFile::GetVersionInt_t GetVersion() constDefiniti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:27589,cache,cache,27589,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['cache'],['cache']
Performance,"ytesReadNumber of bytes read from this file; Long64_tTFile::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TMap*TFile::fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMemFile.html:19393,Cache,Cached,19393,root/html534/TMemFile.html,https://root.cern,https://root.cern/root/html534/TMemFile.html,3,['Cache'],['Cached']
Performance,"yticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsSelfCachedReal.html:2711,Cache,CacheModeRooAbsArg,2711,root/html602/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html602/RooAbsSelfCachedReal.html,6,['Cache'],['CacheModeRooAbsArg']
Performance,"yticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; doublebinVolume() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ParamHistFunc.html:2205,Cache,CacheModeRooAbsArg,2205,root/html534/ParamHistFunc.html,https://root.cern,https://root.cern/root/html534/ParamHistFunc.html,1,['Cache'],['CacheModeRooAbsArg']
Performance,"yz; stats[11]= sumwt; stats[12]= sumwt2. If no axis-subrange is specified (via TAxis::SetRange), the array stats; is simply a copy of the statistics quantities computed at filling time.; If a sub-range is specified, the function recomputes these quantities; from the bin contents in the current axis range. Long64_t Merge(TCollection* list); Merge all histograms in the collection in this histogram.; This function computes the min/max for the axes,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The 2 axis x and y may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple of the bin width. void Multiply(TF1* h1, Double_t c1 = 1); Performs the operation: this = this*c1*f1. void Multiply(const TH1* h1); Multiply this profile2D by h1*-; *-* =============================. this = this*h1. void Multiply(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this profile2D by multiplication of h1 by h2; *-* ================================================================. this = (c1*h1)*(c2*h2). TH3D * ProjectionXYZ(const char* name = ""_pxyz"", Option_t* option = ""e"") const; Project this profile3D into a 3-D histogram along X,Y,Z*-*-; *-* =====================================================. The projection is always of the type TH3D. if option ""E"" is specified, the errors are computed. (default); if option ""B"" is specified, the content of bin of the returned histogram; will be equal to the GetBinEntries(bin) of the profile,; if option ""C=E"" the bin contents of the projection are set to the; bin errors of the profile. void PutStats(Double_t* stats); Replace cur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProfile3D.html:37682,Perform,Performs,37682,root/html528/TProfile3D.html,https://root.cern,https://root.cern/root/html528/TProfile3D.html,3,['Perform'],['Performs']
Performance,"z; stats[11]= sumwt; stats[12]= sumwt2. If no axis-subrange is specified (via TAxis::SetRange), the array stats; is simply a copy of the statistics quantities computed at filling time.; If a sub-range is specified, the function recomputes these quantities; from the bin contents in the current axis range. Long64_t Merge(TCollection* list); Merge all histograms in the collection in this histogram.; This function computes the min/max for the axes,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The 2 axis x and y may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple of the bin width. Bool_t Multiply(TF1* h1, Double_t c1 = 1); Performs the operation: this = this*c1*f1. Bool_t Multiply(const TH1* h1); Multiply this profile2D by h1*-; *-* =============================. this = this*h1. Bool_t Multiply(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this profile2D by multiplication of h1 by h2; *-* ================================================================. this = (c1*h1)*(c2*h2). TH3D * ProjectionXYZ(const char* name = ""_pxyz"", Option_t* option = ""e"") const; Project this profile3D into a 3-D histogram along X,Y,Z*-*-; *-* =====================================================. The projection is always of the type TH3D. if option ""E"" is specified, the errors are computed. (default); if option ""B"" is specified, the content of bin of the returned histogram; will be equal to the GetBinEntries(bin) of the profile,; if option ""C=E"" the bin contents of the projection are set to the; bin errors of the profile; if option ""E"" is specified the errors ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile3D.html:38784,Perform,Performs,38784,root/html534/TProfile3D.html,https://root.cern,https://root.cern/root/html534/TProfile3D.html,3,['Perform'],['Performs']
Performance,"z<=zlast;binz++) {; 8692 for (biny=yfirst;biny<=ylast;biny++) {; 8693 for (binx=xfirst;binx<=xlast;binx++) {; 8694 bin = GetBin(binx,biny,binz);; 8695 value = RetrieveBinContent(bin);; 8696 if (value < minimum) {; 8697 minimum = value;; 8698 locm = bin;; 8699 locmix = binx;; 8700 locmiy = biny;; 8701 locmiz = binz;; 8702 }; 8703 }; 8704 }; 8705 }; 8706 return locm;; 8707}; 8708 ; 8709///////////////////////////////////////////////////////////////////////////////; 8710/// Retrieve the minimum and maximum values in the histogram; 8711///; 8712/// This will not return a cached value and will always search the; 8713/// histogram for the min and max values. The user can condition whether; 8714/// or not to call this with the GetMinimumStored() and GetMaximumStored(); 8715/// methods. If the cache is empty, then the value will be -1111. Users; 8716/// can then use the SetMinimum() or SetMaximum() methods to cache the results.; 8717/// For example, the following recipe will make efficient use of this method; 8718/// and the cached minimum and maximum values.; 8719//; 8720/// \code{.cpp}; 8721/// Double_t currentMin = pHist->GetMinimumStored();; 8722/// Double_t currentMax = pHist->GetMaximumStored();; 8723/// if ((currentMin == -1111) || (currentMax == -1111)) {; 8724/// pHist->GetMinimumAndMaximum(currentMin, currentMax);; 8725/// pHist->SetMinimum(currentMin);; 8726/// pHist->SetMaximum(currentMax);; 8727/// }; 8728/// \endcode; 8729///; 8730/// \param min reference to variable that will hold found minimum value; 8731/// \param max reference to variable that will hold found maximum value; 8732 ; 8733void TH1::GetMinimumAndMaximum(Double_t& min, Double_t& max) const; 8734{; 8735 // empty the buffer; 8736 if (fBuffer) ((TH1*)this)->BufferEmpty();; 8737 ; 8738 Int_t bin, binx, biny, binz;; 8739 Int_t xfirst = fXaxis.GetFirst();; 8740 Int_t xlast = fXaxis.GetLast();; 8741 Int_t yfirst = fYaxis.GetFirst();; 8742 Int_t ylast = fYaxis.GetLast();; 8743 Int_t zfirst = fZaxis.GetF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:341269,cache,cached,341269,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['cache'],['cached']
Performance,"zation argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooDataHist::ErrorType _etype;  Error type store in associated RooDataHist. ;  ; FuncMode _funcMode;  Function, P.d.f. or extended p.d.f? ;  ;  Protected Attributes inherited from RooAbsOptTestStatistic; RooArgSet _cachedNodes;  ! List of nodes that are cached as constant expressions ;  ; RooAbsData * _dataClone = nullptr;  Pointer to internal clone if input data. ;  ; RooAbsReal * _funcClone = nullptr;  Pointer to internal clone of input function. ;  ; RooArgSet * _funcCloneSet = nullptr;  Set owning all components of internal clone of input function. ;  ; RooArgSet * _funcObsSet = nullptr;  List of observables in the pdf expression. ;  ; double _integrateBinsPrecision {-1.};  ; RooArgSet * _normSet = nullptr;  Pointer to set with observables used for normalization. ;  ; bool _optimized = false;  ! ;  ; RooAbsData * _origData = nullptr;  Original data. ;  ; RooAbsReal * _origFunc = nullptr;  Original function. ;  ; bool _ownData = false;  Do we own the dataset. ;  ; RooArgSet * _projDeps = nullptr;  Set of projected observable. ;  ; bool _sealed = false;  Is test statistic sealed – i.e. no access to data. ;  ; TString _sealNotice;  User-defined notice shown when reading a sealed likelihood. ;  ; bool _skipZeroWeights = false;  ! W",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:59876,cache,cached,59876,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['cache'],['cached']
Performance,"ze ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooStringVar.h>. Inheritance diagram for RooStringVar:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooStringVar() [1/3]. RooStringVar::RooStrin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStringVar.html:37204,cache,cache,37204,doc/master/classRooStringVar.html,https://root.cern,https://root.cern/doc/master/classRooStringVar.html,1,['cache'],['cache']
Performance,"ze and fNElements member of the sealedPage parameters are always set. If sealedPage.fBuffer is nullptr, no data will be copied but the returned size information can be used by the caller to allocate a large enough buffer and call LoadSealedPage again. ; Implemented in ROOT::Experimental::Internal::RPageSourceFriends, ROOT::Experimental::Internal::RPageSourceDaos, and ROOT::Experimental::Internal::RPageSourceFile. ◆ LoadStructure(). void ROOT::Experimental::Internal::RPageSource::LoadStructure ; (; ). Loads header and footer without decompressing or deserializing them. ; This can be used to asynchronously open a file in the background. The method is idempotent and it is called as a first step in Attach(). Pages sources may or may not make use of splitting loading and processing meta-data. Therefore, LoadStructure() may do nothing and defer loading the meta-data to Attach(). ; Definition at line 188 of file RPageStorage.cxx. ◆ LoadStructureImpl(). virtual void ROOT::Experimental::Internal::RPageSource::LoadStructureImpl ; (; ). protectedpure virtual . Implemented in ROOT::Experimental::Internal::RPageSourceFriends, ROOT::Experimental::Internal::RPageSourceDaos, and ROOT::Experimental::Internal::RPageSourceFile. ◆ operator=() [1/2]. RPageSource & ROOT::Experimental::Internal::RPageSource::operator= ; (; const RPageSource & ; ). delete . ◆ operator=() [2/2]. RPageSource & ROOT::Experimental::Internal::RPageSource::operator= ; (; RPageSource && ; ). delete . ◆ PrepareLoadCluster(). void ROOT::Experimental::Internal::RPageSource::PrepareLoadCluster ; (; const RCluster::RKey & ; clusterKey, . ROnDiskPageMap & ; pageZeroMap, . std::function< void(DescriptorId_t, NTupleSize_t, const RClusterDescriptor::RPageRange::RPageInfo &)> ; perPageFunc . ). protected . Prepare a page range read for the column set in clusterKey. ; Specifically, pages referencing the kTypePageZero locator are filled in pageZeroMap; otherwise, perPageFunc is called for each page. This is commonly used as ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html:17646,Load,LoadStructureImpl,17646,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,1,['Load'],['LoadStructureImpl']
Performance,"ze can not be zero as there is at least one leaf; 7153 memFactor = Double_t(maxMemory)/Double_t(newMemsize);; 7154 if (memFactor > 100) memFactor = 100;; 7155 Double_t bmin_new = bmin*memFactor;; 7156 Double_t bmax_new = bmax*memFactor;; 7157 static const UInt_t hardmax = 1*1024*1024*1024; // Really, really never give more than 1Gb to a single buffer.; 7158 ; 7159 // Really, really never go lower than 8 bytes (we use this number; 7160 // so that the calculation of the number of basket is consistent; 7161 // but in fact SetBasketSize will not let the size go below; 7162 // TBranch::fEntryOffsetLen + (100 + strlen(branch->GetName()); 7163 // (The 2nd part being a slight over estimate of the key length.; 7164 static const UInt_t hardmin = 8;; 7165 bmin = (bmin_new > hardmax) ? hardmax : ( bmin_new < hardmin ? hardmin : (UInt_t)bmin_new );; 7166 bmax = (bmax_new > hardmax) ? bmin : (UInt_t)bmax_new;; 7167 }; 7168 if (pDebug) {; 7169 Info(""OptimizeBaskets"", ""oldMemsize = %d, newMemsize = %d\n"",oldMemsize, newMemsize);; 7170 Info(""OptimizeBaskets"", ""oldBaskets = %d, newBaskets = %d\n"",oldBaskets, newBaskets);; 7171 }; 7172}; 7173 ; 7174////////////////////////////////////////////////////////////////////////////////; 7175/// Interface to the Principal Components Analysis class.; 7176///; 7177/// Create an instance of TPrincipal; 7178///; 7179/// Fill it with the selected variables; 7180///; 7181/// - if option ""n"" is specified, the TPrincipal object is filled with; 7182/// normalized variables.; 7183/// - If option ""p"" is specified, compute the principal components; 7184/// - If option ""p"" and ""d"" print results of analysis; 7185/// - If option ""p"" and ""h"" generate standard histograms; 7186/// - If option ""p"" and ""c"" generate code of conversion functions; 7187/// - return a pointer to the TPrincipal object. It is the user responsibility; 7188/// - to delete this object.; 7189/// - The option default value is ""np""; 7190///; 7191/// see TTree::Draw for explanation of the othe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:281954,Optimiz,OptimizeBaskets,281954,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,2,['Optimiz'],['OptimizeBaskets']
Performance,"ze is not known, better using the default of zero or the next constructor later on.; The defult interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The defult interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id: Interpolator.h 24403 2008-06-20 08:31:10Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__Interpolator.html:3314,perform,performed,3314,root/html526/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__Interpolator.html,1,['perform'],['performed']
Performance,"ze is not known, better using the default of zero or the next constructor later on.; The defult interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The defult interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id: Interpolator.h 24403 2008-06-20 08:31:10Z moneta $ » Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__Interpolator.html:3314,perform,performed,3314,root/html528/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__Interpolator.html,1,['perform'],['performed']
Performance,"ze is not known, better using the default of zero or the next constructor later on.; The defult interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The defult interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id: Interpolator.h 24403 2008-06-20 08:31:10Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__Interpolator.html:3316,perform,performed,3316,root/html530/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__Interpolator.html,1,['perform'],['performed']
Performance,"ze is not known, better using the default of zero or the next constructor later on.; The defult interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The defult interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id: Interpolator.h 24403 2008-06-20 08:31:10Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__Interpolator.html:3316,perform,performed,3316,root/html532/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__Interpolator.html,1,['perform'],['performed']
Performance,"ze of an already existing variable. bool SetVariableLowerLimit(unsigned int ivar, double lower); set the lower-limit of an already existing variable. bool SetVariableUpperLimit(unsigned int ivar, double upper); set the upper-limit of an already existing variable. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an already existing variable. bool FixVariable(unsigned int ivar); fix an existing variable. bool ReleaseVariable(unsigned int ivar); release an existing variable. bool IsFixedVariable(unsigned int ivar) const; query if an existing variable is fixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& pars) const; get variable settings in a variable object (like ROOT::Fit::ParamsSettings). bool SetVariableInitialRange(unsigned int , double , double ); set the initial range of an existing variable. bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. const double * X() const; return pointer to X values at the minimum. double Edm() const; return expected distance reached from the minimum (re-implement if minimizer provides it. { return -1; }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return NULL; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NIterations() const; number of iterations to reach the minimum. { return NCalls(); }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total; (re-implement if minimizer supports bounded parameters). { return NDim(); }. bool ProvidesError() const; minimizer provides error and error matrix. { return false; }. cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__Minimizer.html:7779,perform,perform,7779,root/html602/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__Minimizer.html,2,['perform'],['perform']
Performance,"ze() + treeBranchNames.size() + dsColumns.size());; 1533 columnNames.insert(columnNames.end(), definedColumns.begin(), definedColumns.end());; 1534 columnNames.insert(columnNames.end(), treeBranchNames.begin(), treeBranchNames.end());; 1535 columnNames.insert(columnNames.end(), dsColumns.begin(), dsColumns.end());; 1536 const auto selectedColumns = RDFInternal::ConvertRegexToColumns(columnNames, columnNameRegexp, ""Cache"");; 1537 return Cache(selectedColumns);; 1538 }; 1539 ; 1540 ////////////////////////////////////////////////////////////////////////////; 1541 /// \brief Save selected columns in memory.; 1542 /// \param[in] columnList columns to be cached in memory.; 1543 /// \return a `RDataFrame` that wraps the cached dataset.; 1544 ///; 1545 /// See the previous overloads for more information.; 1546 RInterface<RLoopManager> Cache(std::initializer_list<std::string> columnList); 1547 {; 1548 ColumnNames_t selectedColumns(columnList);; 1549 return Cache(selectedColumns);; 1550 }; 1551 ; 1552 // clang-format off; 1553 ////////////////////////////////////////////////////////////////////////////; 1554 /// \brief Creates a node that filters entries based on range: [begin, end).; 1555 /// \param[in] begin Initial entry number considered for this range.; 1556 /// \param[in] end Final entry number (excluded) considered for this range. 0 means that the range goes until the end of the dataset.; 1557 /// \param[in] stride Process one entry of the [begin, end) range every `stride` entries. Must be strictly greater than 0.; 1558 /// \return the first node of the computation graph for which the event loop is limited to a certain range of entries.; 1559 ///; 1560 /// Note that in case of previous Ranges and Filters the selected range refers to the transformed dataset.; 1561 /// Ranges are only available if EnableImplicitMT has _not_ been called. Multi-thread ranges are not supported.; 1562 ///; 1563 /// ### Example usage:; 1564 /// ~~~{.cpp}; 1565 /// auto d_0_30 = d.Range(0, 30)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:86521,Cache,Cache,86521,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,2,['Cache'],['Cache']
Performance,"ze)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeStr.String().Data(),m,munit);; 3570 }; 3571 }; 3572 if (gDebug > 0 && cacheSize != -1) Info(""CopyEntries"",""Using Cache size: %lld\n"",cacheSize);; 3573 ; 3574 Long64_t nbytes = 0;; 3575 Long64_t treeEntries = tree->GetEntriesFast();; 3576 if (nentries < 0) {; 3577 nentries = treeEntries;; 3578 } else if (nentries > treeEntries) {; 3579 nentries = treeEntries;; 3580 }; 3581 ; 3582 if (fastClone && (nentries < 0 || nentries == tree->GetEntriesFast())) {; 3583 // Quickly copy the basket without decompression and streaming.; 3584 Long64_t totbytes = GetTotBytes();; 3585 for (Long64_t i = 0; i < nentries; i += tree->GetTree()->GetEntries()) {; 3586 if (tree->LoadTree(i) < 0) {; 3587 break;; 3588 }; 3589 if ( withIndex ) {; 3590 withIndex = R__HandleIndex( onIndexError, this, tree );; 3591 }; 3592 if (this->GetDirectory()) {; 3593 TFile* file2 = this->GetDirectory()->GetFile();; 3594 if (file2 && (file2->GetEND() > TTree::GetMaxTreeSize())) {; 3595 if (this->GetDirectory() == (TDirectory*) file2) {; 3596 this->ChangeFile(file2);; 3597 }; 3598 }; 3599 }; 3600 TTreeCloner cloner(tree->GetTree(), this, option, TTreeCloner::kNoWarnings);; 3601 if (cloner.IsValid()) {; 3602 this->SetEntries(this->GetEntries() + tree->GetTree()->GetEntries());; 3603 if (cacheSize != -1) cloner.SetCacheSize(cacheSize);; 3604 cloner.Exec();; 3605 } else {; 3606 if (i == 0) {; 3607 Warning(""CopyEntries"",""%s"",cloner.GetWarning());; 3608 // If the first cloning does not work, something is really wrong; 3609 // (since apriori the source and target are exactly the same structure!); 3610 return -1;; 3611 } else {; 3612 if (cloner.NeedConversion()) {; 3613 TTree *localtree = tree->GetTree();; 3614 Long64_t tentries = localtree->GetEntries();; 3615 if (needCopyAddresses) {; 3616 // Copy MakeClass status.; 3617 tree->SetMakeClass(fMakeClass);; 3618 // ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:142179,Load,LoadTree,142179,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['Load'],['LoadTree']
Performance,"zeConfigParameters.cxx. ◆ GetBkgRejAtSigEff(). Double_t TMVA::OptimizeConfigParameters::GetBkgRejAtSigEff ; (; Double_t ; sigEff = 0.5). private . calculate the background rejection for a given signal efficiency ; adapted by marc-.nosp@m.oliv.nosp@m.ier.b.nosp@m.ettl.nosp@m.er@ce.nosp@m.rn.c.nosp@m.h ; Definition at line 583 of file OptimizeConfigParameters.cxx. ◆ GetFOM(). Double_t TMVA::OptimizeConfigParameters::GetFOM ; (; ). private . Return the Figure of Merit (FOM) used in the parameter optimization process. ; Definition at line 350 of file OptimizeConfigParameters.cxx. ◆ GetMethod(). MethodBase * TMVA::OptimizeConfigParameters::GetMethod ; (; ). inlineprivate . Definition at line 72 of file OptimizeConfigParameters.h. ◆ GetMVADists(). void TMVA::OptimizeConfigParameters::GetMVADists ; (; ). private . fill the private histograms with the mva distributions for sig/bkg ; Definition at line 393 of file OptimizeConfigParameters.cxx. ◆ GetROCIntegral(). Double_t TMVA::OptimizeConfigParameters::GetROCIntegral ; (; ). private . calculate the area (integral) under the ROC curve as a overall quality measure of the classification ; making pdfs out of the MVA-output distributions doesn't work reliably for cases where the MVA-output isn't a smooth distribution. this happens ""frequently"" in BDTs for example when the number of trees is small resulting in only some discrete possible MVA output values. (I still leave the code here, but use this with care!!! The default however is to use the distributions!!! ; Definition at line 458 of file OptimizeConfigParameters.cxx. ◆ GetScanIndices(). std::vector< int > TMVA::OptimizeConfigParameters::GetScanIndices ; (; int ; val, . std::vector< int > ; base . ). private . helper function to scan through the all the combinations in the parameter space ; Definition at line 149 of file OptimizeConfigParameters.cxx. ◆ GetSeparation(). Double_t TMVA::OptimizeConfigParameters::GetSeparation ; (; ). private . return the separation between the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:7419,Optimiz,OptimizeConfigParameters,7419,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['Optimiz'],['OptimizeConfigParameters']
Performance,"ze_t > > > BasketList_tDefinition TTreePerfStats.h:48; TTreePerfStats::fPaveTPaveText * fPavePointer to annotation pavetext.Definition TTreePerfStats.h:71; TTreePerfStats::fTreeCacheSizeInt_t fTreeCacheSizeTTreeCache buffer size.Definition TTreePerfStats.h:51; TTreePerfStats::fGraphTimeTGraphErrors * fGraphTimePointer to the graph with timestamp info.Definition TTreePerfStats.h:70; TTreePerfStats::fHostInfoTextTText * fHostInfoTextGraphics Text object with the fHostInfo data.Definition TTreePerfStats.h:74; TTreePerfStats::fBytesReadExtraLong64_t fBytesReadExtraNumber of bytes (overhead) of the read-ahead cache.Definition TTreePerfStats.h:56; TTreePerfStats::UnzipEventvoid UnzipEvent(TObject *tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen) overrideRecord TTree unzip event.Definition TTreePerfStats.cxx:312; TTreePerfStats::TTreePerfStatsTTreePerfStats()default constructor (used when reading an object only)Definition TTreePerfStats.cxx:107; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetCurrentFileTFile * GetCurrentFile() constReturn pointer to the current file.Definition TTree.cxx:5479; TTree::GetDirectoryTDirectory * GetDirectory() constDefinition TTree.h:462; TTree::GetReadEntryvirtual Long64_t GetReadEntry() constDefinition TTree.h:549; TTree::GetTreevirtual TTree * GetTree() constDefinition TTree.h:557; TTree::IsATClass * IsA() const overrideDefinition TTree.h:705; TTree::GetCacheSizevirtual Long64_t GetCacheSize() constDefinition TTree.h:453; TVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing.Definition TVirtualPerfStats.h:32; double; int; TMath::MaxElementT MaxElement(Long64_t n, const T *a)Returns maximum of array a of length n.Definition TMath.h:968; TTreePerfStats::BasketInfoDefinition TTreePerfStats.h:41; Drawth1 Draw(). treetreeplayersrcTTreePerfStats.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:06 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:45568,perform,performance,45568,doc/master/TTreePerfStats_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html,1,['perform'],['performance']
Performance,"zed function has error status.; Returning maximum FCN so far (-775.389) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.72761 a1=-0.375581 mean=5.04879 nbkg=141.143 nsig=137.402 sig1frac=0.495257; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 60; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 50; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 40; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 30; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 20; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 10; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 0; [#0] WARNING:Generation -- Fit parameter 'sigma1' does not have an error. A pull distribution cannot be generated. This might be caused by the parameter being constant or because the fits were not run.; [#0] WARNING:Generation -- Fit parameter 'sigma2' does not have an error. A pull distribution cannot be generated. This might be caused by the parameter being constant or because the fits were not run.; [#1] INFO:ObjectHandling -- RooWorkspace::import() importing RooRealVar::meanpull; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pullGauss_over_pullGauss_Int[meanpull]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pullGauss_over_pullGauss_Int[meanpull]_fitParData_model) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateFebruary 2018 ; AuthorWouter Verkerke ; Definition in file rf801_mcstudy.C. tutorialsroofitrf801_mcstudy.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf801__mcstudy_8C.html:29688,optimiz,optimization,29688,doc/master/rf801__mcstudy_8C.html,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html,2,['optimiz'],['optimization']
Performance,"zed value; 311/// is returned. All elements of `nset` must be lvalues.; 312///; 313/// Unnormalized values are not cached.; 314/// Doing so would be complicated as `_norm->getVal()` could; 315/// spoil the cache and interfere with returning the cached; 316/// return value. Since unnormalized calls are typically; 317/// done in integration calls, there is no performance hit.; 318 ; 319double RooAbsPdf::getValV(const RooArgSet* nset) const; 320{; 321 ; 322 // Special handling of case without normalization set (used in numeric integration of pdfs); 323 if (!nset) {; 324 RooArgSet const* tmp = _normSet ;; 325 _normSet = nullptr ;; 326 double val = evaluate() ;; 327 _normSet = tmp ;; 328 ; 329 return TMath::IsNaN(val) ? 0. : val;; 330 }; 331 ; 332 ; 333 // Process change in last data set used; 334 bool nintChanged(false) ;; 335 if (!isActiveNormSet(nset) || _norm==nullptr) {; 336 nintChanged = syncNormalization(nset) ;; 337 }; 338 ; 339 // Return value of object. Calculated if dirty, otherwise cached value is returned.; 340 if (isValueDirty() || nintChanged || _norm->isValueDirty()) {; 341 ; 342 // Evaluate numerator; 343 const double rawVal = evaluate();; 344 ; 345 // Evaluate denominator; 346 const double normVal = _norm->getVal();; 347 ; 348 _value = normalizeWithNaNPacking(rawVal, normVal);; 349 ; 350 clearValueAndShapeDirty();; 351 }; 352 ; 353 return _value ;; 354}; 355 ; 356 ; 357////////////////////////////////////////////////////////////////////////////////; 358/// Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information).; 359///; 360/// This function applies the normalization specified by `normSet` to the integral returned; 361/// by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; 362/// to return a normalized answer.; 363 ; 364double RooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName) const; 365{; 366 cxcoutD(Eval) << ""RooAbsPdf::analytic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:12738,cache,cached,12738,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['cache'],['cached']
Performance,"zero, the result parameter will be swapped with a std::any variable on the Python side. You need to define this variable yourself, and it needs to be of type std::any and its name needs to be ""_anyresult"" by default. Like this, you can pass information from Python back to C++.; Parameters. cmdThe Python command to be executed as a string. ; resultOptional pointer to a std::any object that can be used to transfer results from Python to C++. ; resultNameName of the Python variable that is swapped over to the std::any result. The default value is ""_anyresult"". . Returnsbool Returns true if the command was successfully executed, otherwise returns false. ; Definition at line 425 of file TPython.cxx. ◆ ExecScript(). void TPython::ExecScript ; (; const char * ; name, . int ; argc = 0, . const char ** ; argv = nullptr . ). static . Execute a python stand-alone script, with argv CLI arguments. ; example of use: const char* argv[] = { ""1"", ""2"", ""3"" }; TPython::ExecScript( ""test.py"", sizeof(argv)/sizeof(argv[0]), argv ); ; Definition at line 381 of file TPython.cxx. ◆ Import(). Bool_t TPython::Import ; (; const char * ; name). static . Import the named python module and create Cling equivalents for its classes and methods. ; Definition at line 237 of file TPython.cxx. ◆ Initialize(). Bool_t TPython::Initialize ; (; ). staticprivate . Initialization method: setup the python interpreter and load the ROOT module. ; Definition at line 137 of file TPython.cxx. ◆ LoadMacro(). void TPython::LoadMacro ; (; const char * ; name). static . Execute the give python script as if it were a macro (effectively an execfile in main), and create Cling equivalents for any newly available python classes. ; Definition at line 305 of file TPython.cxx. The documentation for this class was generated from the following files:; bindings/tpython/inc/TPython.h; bindings/tpython/src/TPython.cxx. TPython. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:18 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPython.html:6410,load,load,6410,doc/master/classTPython.html,https://root.cern,https://root.cern/doc/master/classTPython.html,3,"['Load', 'load']","['LoadMacro', 'load']"
Performance,"zipBuffer (char **buf, Long64_t pos, Int_t len, bool *free) override;  We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ;  ; Int_t GetUnzipGroupSize ();  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBufferExt (char *buf, Long64_t pos, Int_t len, Int_t &loc) override;  ; void ResetCache () override;  This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ;  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; void SetEntryRange (Long64_t emin, Long64_t emax) override;  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetUnzipBufferSize (Long64_t bufferSize);  Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ;  ; void SetUnzipGroupSize (Int_t groupSize);  ; void StopLearningPhase () override;  It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t UnzipBuffer (char **dest, char *src);  Unzips a ROOT specific buffer... by reading the header at the beginning. ;  ; Int_t UnzipCache (Int_t index);  This inflates a basket in the cache. ;  ; void UpdateBranches (TTree *tree) override;  update pointer to current Tree and recompute pointers to the branches in the cache ;  ;  Public Member Functions inherited from TTreeCache;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:3540,cache,cache,3540,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,1,['cache'],['cache']
Performance,zjh ; Definition at line 186 of file MethodANNBase.h. ◆ fLayerSpec. TString TMVA::MethodANNBase::fLayerSpec. private . layout specification option ; Definition at line 221 of file MethodANNBase.h. ◆ fNcycles. Int_t TMVA::MethodANNBase::fNcycles. protected . number of epochs to train ; Definition at line 192 of file MethodANNBase.h. ◆ fNetwork. TObjArray* TMVA::MethodANNBase::fNetwork. Definition at line 139 of file MethodANNBase.h. ◆ fNeuronInputType. TString TMVA::MethodANNBase::fNeuronInputType. protected . name of neuron input calculator class ; Definition at line 195 of file MethodANNBase.h. ◆ fNeuronType. TString TMVA::MethodANNBase::fNeuronType. protected . name of neuron activation function class ; Definition at line 194 of file MethodANNBase.h. ◆ fOutput. TActivation* TMVA::MethodANNBase::fOutput. protected . Definition at line 164 of file MethodANNBase.h. ◆ fOutputNeurons. std::vector<TNeuron*> TMVA::MethodANNBase::fOutputNeurons. private . cache this for fast access ; Definition at line 220 of file MethodANNBase.h. ◆ fRandomSeed. Int_t TMVA::MethodANNBase::fRandomSeed. protected . random seed for initial synapse weights ; Definition at line 190 of file MethodANNBase.h. ◆ fRegulatorIdx. std::vector<Int_t> TMVA::MethodANNBase::fRegulatorIdx. protected . Definition at line 169 of file MethodANNBase.h. ◆ fRegulators. std::vector<Double_t> TMVA::MethodANNBase::fRegulators. protected . Definition at line 170 of file MethodANNBase.h. ◆ frgen. TRandom3* TMVA::MethodANNBase::frgen. protected . Definition at line 166 of file MethodANNBase.h. ◆ fSynapses. TObjArray* TMVA::MethodANNBase::fSynapses. protected . Definition at line 162 of file MethodANNBase.h. ◆ fUseRegulator. bool TMVA::MethodANNBase::fUseRegulator. protected . zjh ; Definition at line 187 of file MethodANNBase.h. Libraries for TMVA::MethodANNBase:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/MethodANNBase.h; tmva/tmva/src/MethodANNBase.cxx. TMVA,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodANNBase.html:45921,cache,cache,45921,doc/master/classTMVA_1_1MethodANNBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodANNBase.html,1,['cache'],['cache']
Performance,"{ fCoordinates.SetEta(etaval); return *this;}. Scalar Dot(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v) const; ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*( Scalar(-1) ). DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. Division of a vector with a real number. Scalar x() const; Methods providing limited backward name compatibility with CLHEP. { return fCoordinates.X(); }. Scalar y() const; { return fCoordinates.Y(); }. Scalar z() const; { return fCoordinates.Z(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar eta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:21949,perform,perform,21949,root/html528/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,3,['perform'],['perform']
Performance,"{ kInvalid; kActive; kInactive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTSlave::fArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tTSlave::fBytesReadbytes read by slave (info is obtained from slave); Float_tTSlave::fCpuTimeCPU time spent executing commands (info obtained from slave); TStringTSlave::fGroupslave's group id; TStringTSlave::fImageslave's image name; TFileHandler*TSlave::fInputinput handler related to this slave; TStringTSlave::fMsdmass storage domain of slave; TStringTSlave::fNameslave's hostname; TStringTSlave::fOrdinalslave's ordinal number; Int_tTSlave::fParallelnumber of active slaves; Int_tTSlave::fPerfIdxrelative CPU performance index; Int_tTSlave::fPortslave's port number; TProof*TSlave::fProofproof cluster to which slave belongs; TStringTSlave::fProofWorkDirbase proofserv working directory (info obtained from slave); Int_tTSlave::fProtocolslave's protocol level; TStringTSlave::fROOTVersROOT version run by worker; Float_tTSlave::fRealTimereal time spent executing commands (info obtained from slave); TStringTSlave::fSessionTagunique tag for ths worker process; TSlave::ESlaveTypeTSlave::fSlaveTypetype of slave (either kMaster or kSlave); TSocket*TSlave::fSocketsocket to slave; Int_tTSlave::fStatusremote return status; TStringTSlave::fUserslave's user id; TStringTSlave::fWorkDirslave's working directory (info obtained from slave). private:. TSignalHandler*fIntHandlerinterrupt signal handler (ctrl-c); Bool_tfValid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). TSlaveLite(const char* ord, Int_t perf, const char* image, TProof* proo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSlaveLite.html:7676,perform,performance,7676,root/html530/TSlaveLite.html,https://root.cern,https://root.cern/root/html530/TSlaveLite.html,2,['perform'],['performance']
Performance,"{ kInvalid; kActive; kInactive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTSlave::fArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tTSlave::fBytesReadbytes read by slave (info is obtained from slave); Float_tTSlave::fCpuTimeCPU time spent executing commands (info obtained from slave); TStringTSlave::fGroupslave's group id; TStringTSlave::fImageslave's image name; TFileHandler*TSlave::fInputinput handler related to this slave; TStringTSlave::fMsdmass storage domain of slave; TStringTSlave::fNameslave's hostname; TStringTSlave::fOrdinalslave's ordinal number; Int_tTSlave::fParallelnumber of active slaves; Int_tTSlave::fPerfIdxrelative CPU performance index; Int_tTSlave::fPortslave's port number; TProof*TSlave::fProofproof cluster to which slave belongs; TStringTSlave::fProofWorkDirbase proofserv working directory (info obtained from slave); Int_tTSlave::fProtocolslave's protocol level; TStringTSlave::fROOTVersROOT version run by worker; Float_tTSlave::fRealTimereal time spent executing commands (info obtained from slave); TStringTSlave::fSessionTagunique tag for ths worker process; TSlave::ESlaveTypeTSlave::fSlaveTypetype of slave (either kMaster or kSlave); TSocket*TSlave::fSocketsocket to slave; Int_tTSlave::fStatusremote return status; TStringTSlave::fUserslave's user id; TStringTSlave::fWorkDirslave's working directory (info obtained from slave). private:. TSignalHandler*fIntHandlerinterrupt signal handler (ctrl-c); Bool_tfValid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). TXSlave(const char* url, const char* ord, Int_t perf, const char* image",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXSlave.html:7845,perform,performance,7845,root/html530/TXSlave.html,https://root.cern,https://root.cern/root/html530/TXSlave.html,2,['perform'],['performance']
Performance,"{ kUseBoundingBox; kUseVoxels; kUseGsord; };; enum EGeoSavePrimitiveAtt { kSavePrimitiveAtt; kSaveNodesAtt; };. protected:. UInt_tfGeoAttoption flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoAtt(); Default constructor. TGeoAtt(Option_t* vis_opt, Option_t* activity_opt = """", Option_t* optimization_opt = """"); Constructor. ~TGeoAtt(); Destructor. void SetVisBranch(); Set branch type visibility. void SetVisContainers(Bool_t flag = kTRUE); Set branch type visibility. void SetVisLeaves(Bool_t flag = kTRUE); Set branch type visibility. void SetVisOnly(Bool_t flag = kTRUE); Set branch type visibility. void SetVisibility(Bool_t vis = kTRUE); Set visibility for this object. void SetVisDaughters(Bool_t vis = kTRUE); Set visibility for the daughters. void SetVisStreamed(Bool_t vis = kTRUE); Mark attributes as ""streamed to file"". void SetVisTouched(Bool_t vis = kTRUE); Mark visualization attributes as ""modified"". void SetOptimization(Option_t* option); Set optimization flags. TGeoAtt(); constructors. void SetAttBit(UInt_t f); methods. {fGeoAtt |= f & kBitMask;}. void SetAttBit(UInt_t f, Bool_t set); {(set)?SetAttBit(f):ResetAttBit(f);}. void ResetAttBit(UInt_t f); {fGeoAtt &= ~(f & kBitMask);}. Bool_t TestAttBit(UInt_t f) const; {return (Bool_t)((fGeoAtt & f) != 0);}. void SetVisRaytrace(Bool_t flag = kTRUE); {SetAttBit(kVisRaytrace, flag);}. void SetActivity(Bool_t flag = kTRUE); {SetAttBit(kActThis, flag);}. void SetActiveDaughters(Bool_t flag = kTRUE); {SetAttBit(kActDaughters,flag);}. Bool_t IsActive() const; {return TestAttBit(kActThis);}. Bool_t IsActiveDaughters() const; {return TestAttBit(kActDaughters);}. Bool_t IsVisRaytrace() const; {return TestAttBit(kVisRaytrace);}. Bool_t IsVisible() const; {return TestAttBit(kVisThis);}. Bool_t IsVisDaughters() const; {return TestAttBit(kVisDaughters);}. Bool_t IsVisBranch() const; {return TestAttBit(kVisBranch);}. Bool_t IsVisContainers() const; {return TestAttBit(kVisContain",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoAtt.html:3124,optimiz,optimization,3124,root/html528/TGeoAtt.html,https://root.cern,https://root.cern/root/html528/TGeoAtt.html,4,['optimiz'],['optimization']
Performance,"{ return fClassGenerators; }; 252 TSeqCollection *GetListOfSecContexts() const { return fSecContexts; }; 253 TSeqCollection *GetListOfProofs() const { return fProofs; }; 254 TSeqCollection *GetClipboard() const { return fClipboard; }; 255 TSeqCollection *GetListOfDataSets() const { return fDataSets; }; 256 TCollection *GetListOfEnums(Bool_t load = kFALSE);; 257 TCollection *GetListOfFunctionTemplates();; 258 TList *GetListOfBrowsables() const { return fBrowsables; }; 259 TDataType *GetType(const char *name, Bool_t load = kFALSE) const;; 260 TFile *GetFile() const override { if (gDirectory && gDirectory != this) return gDirectory->GetFile(); else return nullptr;}; 261 TFile *GetFile(const char *name) const;; 262 TFunctionTemplate*GetFunctionTemplate(const char *name);; 263 TStyle *GetStyle(const char *name) const;; 264 TObject *GetFunction(const char *name) const;; 265 TGlobal *GetGlobal(const char *name, Bool_t load = kFALSE) const;; 266 TGlobal *GetGlobal(const TObject *obj, Bool_t load = kFALSE) const;; 267 TFunction *GetGlobalFunction(const char *name, const char *params = nullptr, Bool_t load = kFALSE);; 268 TFunction *GetGlobalFunctionWithPrototype(const char *name, const char *proto = nullptr, Bool_t load = kFALSE);; 269 TObject *GetGeometry(const char *name) const;; 270 const TObject *GetSelectedPrimitive() const { return fPrimitive; }; 271 TVirtualPad *GetSelectedPad() const { return fSelectPad; }; 272 Int_t GetNclasses() const;; 273 Int_t GetNtypes() const;; 274 TFolder *GetRootFolder() const { return fRootFolder; }; 275 TProcessUUID *GetUUIDs() const { return fUUIDs; }; 276 const TString &GetWebDisplay() const { return fWebDisplay; }; 277 void Idle(UInt_t idleTimeInSec, const char *command = nullptr);; 278 Int_t IgnoreInclude(const char *fname, const char *expandedfname);; 279 Bool_t IsBatch() const { return fBatch; }; 280 Bool_t IsExecutingMacro() const { return fExecutingMacro; }; 281 Bool_t IsFolder() const override { return kTRUE; }; 282 Bool_t IsInterr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:13111,load,load,13111,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,2,['load'],['load']
Performance,"{-1}; \]. where H is the weighted Hessian matrix and D is given by ; \[; D_{kl} = \sum_{e=1}^{N} w_e^2 \frac{\partial \log(P)}{\partial \lambda_k}\frac{\partial \log(P)}{\partial; \lambda_l}; \]. with the event weight \(w_e\). The example performs the fit of a second order polynomial in the angle cos(theta) [-1,1] to a weighted data set. The polynomial is given by ; \[; P = \frac{ 1 + c_0 \cdot \cos(\theta) + c_1 \cdot \cos(\theta) \cdot \cos(\theta) }{\mathrm{Norm}}; \]. The two coefficients \( c_0 \) and \( c_1 \) and their uncertainties are to be determined in the fit.; The per-event weight is used to correct for an acceptance effect, two different acceptance models can be studied:; acceptancemodel==1: eff = \( 0.3 + 0.7 \cdot \cos(\theta) \cdot \cos(\theta) \); acceptancemodel==2: eff = \( 1.0 - 0.7 \cdot \cos(\theta) \cdot \cos(\theta) \) The data is generated to be flat before the acceptance effect. The performance of the different approaches to determine parameter uncertainties is compared using the pull distributions from a large number of pseudoexperiments. The pull is defined as \( (\lambda_i -; \lambda_{gen})/\sigma(\lambda_i) \), where \( \lambda_i \) is the fitted parameter and \( \sigma(\lambda_i) \) its uncertainty for pseudoexperiment number i. If the fit is unbiased and the parameter uncertainties are estimated correctly, the pull distribution should be a Gaussian centered around zero with a width of one. ; #include ""TH1D.h""; #include ""TCanvas.h""; #include ""TROOT.h""; #include ""TStyle.h""; #include ""TRandom3.h""; #include ""TLegend.h""; #include ""RooRealVar.h""; #include ""RooFitResult.h""; #include ""RooDataSet.h""; #include ""RooPolynomial.h""; ; using namespace RooFit;; ; void rf611_weightedfits(int acceptancemodel = 2); {; // I n i t i a l i s a t i o n a n d S e t u p; //------------------------------------------------; ; // plotting options; gStyle->SetPaintTextFormat("".1f"");; gStyle->SetEndErrorSize(6.0);; gStyle->SetTitleSize(0.05, ""XY"");; gStyle->SetLa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf611__weightedfits_8C.html:2300,perform,performance,2300,doc/master/rf611__weightedfits_8C.html,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html,1,['perform'],['performance']
Performance,"{; 1838 if (s->sa.sa_family == AF_INET); 1839 return s->sin.sin_port;; 1840#if defined(USE_IPV6); 1841 if (s->sa.sa_family == AF_INET6); 1842 return s->sin6.sin6_port;; 1843#endif; 1844 return 0;; 1845}; 1846#endif; 1847#if defined(USE_IPV6); 1848#define USA_IN_PORT_UNSAFE(s) \; 1849 (((s)->sa.sa_family == AF_INET6) ? (s)->sin6.sin6_port : (s)->sin.sin_port); 1850#else; 1851#define USA_IN_PORT_UNSAFE(s) ((s)->sin.sin_port); 1852#endif; 1853 ; 1854/* Describes a string (chunk of memory). */; 1855struct vec {; 1856 const char *ptr;; 1857 size_t len;; 1858};; 1859 ; 1860struct mg_file_stat {; 1861 /* File properties filled by mg_stat: */; 1862 uint64_t size;; 1863 time_t last_modified;; 1864 int is_directory; /* Set to 1 if mg_stat is called for a directory */; 1865 int is_gzipped; /* Set to 1 if the content is gzipped, in which; 1866 * case we need a ""Content-Eencoding: gzip"" header */; 1867 int location; /* 0 = nowhere, 1 = on disk, 2 = in memory */; 1868};; 1869 ; 1870 ; 1871struct mg_file_access {; 1872 /* File properties filled by mg_fopen: */; 1873 FILE *fp;; 1874};; 1875 ; 1876struct mg_file {; 1877 struct mg_file_stat stat;; 1878 struct mg_file_access access;; 1879};; 1880 ; 1881 ; 1882#define STRUCT_FILE_INITIALIZER \; 1883 { \; 1884 {(uint64_t)0, (time_t)0, 0, 0, 0}, \; 1885 { \; 1886 (FILE *)NULL \; 1887 } \; 1888 }; 1889 ; 1890 ; 1891/* Describes listening socket, or socket which was accept()-ed by the master; 1892 * thread and queued for future handling by the worker thread. */; 1893struct socket {; 1894 SOCKET sock; /* Listening socket */; 1895 union usa lsa; /* Local socket address */; 1896 union usa rsa; /* Remote socket address */; 1897 unsigned char is_ssl; /* Is port SSL-ed */; 1898 unsigned char ssl_redir; /* Is port supposed to redirect everything to SSL; 1899 * port */; 1900 unsigned char in_use; /* 0: invalid, 1: valid, 2: free */; 1901};; 1902 ; 1903 ; 1904/* Enum const for all options must be in sync with; 1905 * static struct mg_option config_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:57514,queue,queued,57514,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['queue'],['queued']
Performance,"{; 1839 if (s->sa.sa_family == AF_INET); 1840 return s->sin.sin_port;; 1841#if defined(USE_IPV6); 1842 if (s->sa.sa_family == AF_INET6); 1843 return s->sin6.sin6_port;; 1844#endif; 1845 return 0;; 1846}; 1847#endif; 1848#if defined(USE_IPV6); 1849#define USA_IN_PORT_UNSAFE(s) \; 1850 (((s)->sa.sa_family == AF_INET6) ? (s)->sin6.sin6_port : (s)->sin.sin_port); 1851#else; 1852#define USA_IN_PORT_UNSAFE(s) ((s)->sin.sin_port); 1853#endif; 1854 ; 1855/* Describes a string (chunk of memory). */; 1856struct vec {; 1857 const char *ptr;; 1858 size_t len;; 1859};; 1860 ; 1861struct mg_file_stat {; 1862 /* File properties filled by mg_stat: */; 1863 uint64_t size;; 1864 time_t last_modified;; 1865 int is_directory; /* Set to 1 if mg_stat is called for a directory */; 1866 int is_gzipped; /* Set to 1 if the content is gzipped, in which; 1867 * case we need a ""Content-Eencoding: gzip"" header */; 1868 int location; /* 0 = nowhere, 1 = on disk, 2 = in memory */; 1869};; 1870 ; 1871 ; 1872struct mg_file_access {; 1873 /* File properties filled by mg_fopen: */; 1874 FILE *fp;; 1875};; 1876 ; 1877struct mg_file {; 1878 struct mg_file_stat stat;; 1879 struct mg_file_access access;; 1880};; 1881 ; 1882 ; 1883#define STRUCT_FILE_INITIALIZER \; 1884 { \; 1885 {(uint64_t)0, (time_t)0, 0, 0, 0}, \; 1886 { \; 1887 (FILE *)NULL \; 1888 } \; 1889 }; 1890 ; 1891 ; 1892/* Describes listening socket, or socket which was accept()-ed by the master; 1893 * thread and queued for future handling by the worker thread. */; 1894struct socket {; 1895 SOCKET sock; /* Listening socket */; 1896 union usa lsa; /* Local socket address */; 1897 union usa rsa; /* Remote socket address */; 1898 unsigned char is_ssl; /* Is port SSL-ed */; 1899 unsigned char ssl_redir; /* Is port supposed to redirect everything to SSL; 1900 * port */; 1901 unsigned char in_use; /* 0: invalid, 1: valid, 2: free */; 1902};; 1903 ; 1904 ; 1905/* Enum const for all options must be in sync with; 1906 * static struct mg_option config_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:57546,queue,queued,57546,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['queue'],['queued']
Performance,"{; 258public:; 259 TProcessEventTimer(Long_t delay);; 260 Bool_t Notify() override { return kTRUE; }; 261 Bool_t ProcessEvents();; 262 ClassDefOverride(TProcessEventTimer,0) // Process pending events at fixed time intervals; 263};; 264 ; 265 ; 266class TSystem : public TNamed {; 267 ; 268public:; 269 enum EAclicMode { kDefault, kDebug, kOpt };; 270 enum EAclicProperties {; 271 kFlatBuildDir = BIT(0) // If set and a BuildDir is selected, then do not created sub-directories; 272 };; 273 ; 274protected:; 275 TFdSet *fReadmask{nullptr}; //!Files that should be checked for read events; 276 TFdSet *fWritemask{nullptr}; //!Files that should be checked for write events; 277 TFdSet *fReadready{nullptr}; //!Files with reads waiting; 278 TFdSet *fWriteready{nullptr}; //!Files with writes waiting; 279 TFdSet *fSignals{nullptr}; //!Signals that were trapped; 280 Int_t fNfd{0}; //Number of fd's in masks; 281 Int_t fMaxrfd{-1}; //Largest fd in read mask; 282 Int_t fMaxwfd{-1}; //Largest fd in write mask; 283 Int_t fSigcnt{0}; //Number of pending signals; 284 TString fWdpath; //Working directory; 285 TString fHostname; //Hostname; 286 std::atomic<Bool_t> fInsideNotify{kFALSE}; //Used by DispatchTimers(); 287 Int_t fBeepFreq{0}; //Used by Beep(); 288 Int_t fBeepDuration{0}; //Used by Beep(); 289 ; 290 Bool_t fInControl{kFALSE}; //True if in eventloop; 291 Bool_t fDone{kFALSE}; //True if eventloop should be finished; 292 Int_t fLevel{0}; //Level of nested eventloops; 293 ; 294 TList *fTimers{nullptr}; //List of timers; 295 TSeqCollection *fSignalHandler{nullptr}; //List of signal handlers; 296 TSeqCollection *fFileHandler{nullptr}; //List of file handlers; 297 TSeqCollection *fStdExceptionHandler{nullptr}; //List of std::exception handlers; 298 TSeqCollection *fOnExitList{nullptr}; //List of items to be cleaned-up on exit; 299 ; 300 TString fListLibs; //List shared libraries, cache used by GetLibraries; 301 ; 302 TString fBuildArch; //Architecture for which ROOT was built (passed to .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:11587,cache,cache,11587,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['cache'],['cache']
Performance,"{; 4026 Long_t increment = proxy.GetIncrement();; 4027 sequence->fLoopConfig = new TVectorLoopConfig(increment);; 4028 // sequence->fLoopConfig = new TAssocLoopConfig(proxy); */; 4029 } else {; 4030 sequence->fLoopConfig = new TGenericLoopConfig(&proxy, /* read */ kFALSE);; 4031 }; 4032 for (UInt_t i = 0; i < ndata; ++i) {; 4033 TStreamerElement *element = (TStreamerElement*) info->GetElements()->At(i);; 4034 if (!element) {; 4035 break;; 4036 }; 4037 if (element->GetType() < 0) {; 4038 // -- Skip an ignored TObject base class.; 4039 // Note: The only allowed negative value here is -1, and signifies that Build() has found a TObject; 4040 // base class and TClass::IgnoreTObjectStreamer() was called. In this case the compiled version of the; 4041 // elements omits the TObject base class element, which has to be compensated for by TTree::Bronch(); 4042 // when it is making branches for a split object.; 4043 continue;; 4044 }; 4045 if (element->TestBit(TStreamerElement::kCache) && !element->TestBit(TStreamerElement::kWrite)) {; 4046 // Skip element cached for reading purposes.; 4047 continue;; 4048 }; 4049 if (element->GetType() >= TVirtualStreamerInfo::kArtificial && !element->TestBit(TStreamerElement::kWrite)) {; 4050 // Skip artificial element used for reading purposes.; 4051 continue;; 4052 }; 4053 TStreamerInfo::TCompInfo *compinfo = sinfo->fCompFull[i];; 4054 Int_t oldType = element->GetType();; 4055 Int_t offset = element->GetOffset();; 4056#if defined(CDJ_NO_COMPILE); 4057 Int_t newType = element->GetNewType();; 4058 ; 4059 if (newType != oldType) {; 4060 if (newType > 0) {; 4061 if (oldType != TVirtualStreamerInfo::kCounter) {; 4062 oldType += TVirtualStreamerInfo::kConv;; 4063 }; 4064 } else {; 4065 oldType += TVirtualStreamerInfo::kSkip;; 4066 }; 4067 }; 4068 if ( IsDefaultVector(proxy); 4069 /*|| (proxy.GetCollectionType() == ROOT::kSTLset || proxy.GetCollectionType() == ROOT::kSTLmultiset; 4070 || proxy.GetCollectionType() == ROOT::kSTLmap || proxy.GetColle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:188658,cache,cached,188658,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['cache'],['cached']
Performance,"{; 707 clearVector(fProxyList);; 708 clearVector(fProxyKept);; 709 clearVector(fStaged);; 710 ; 711 if ( fValue.load() ) delete fValue.load();; 712 if ( fVal ) delete fVal;; 713 if ( fKey ) delete fKey;; 714 ; 715 delete fReadMemberWise;; 716 if (fConversionReadMemberWise) {; 717 std::map<std::string, TObjArray*>::iterator it;; 718 std::map<std::string, TObjArray*>::iterator end = fConversionReadMemberWise->end();; 719 for( it = fConversionReadMemberWise->begin(); it != end; ++it ) {; 720 delete it->second;; 721 }; 722 delete fConversionReadMemberWise;; 723 fConversionReadMemberWise = 0;; 724 }; 725 delete fWriteMemberWise;; 726}; 727 ; 728////////////////////////////////////////////////////////////////////////////////; 729/// Virtual copy constructor; 730 ; 731TVirtualCollectionProxy* TGenCollectionProxy::Generate() const; 732{; 733 if ( !fValue.load(std::memory_order_relaxed) ) Initialize(kFALSE);; 734 ; 735 if( fPointers ); 736 return new TGenCollectionProxy(*this);; 737 ; 738 switch(fSTL_type) {; 739 case ROOT::kSTLbitset: {; 740 return new TGenBitsetProxy(*this);; 741 }; 742 case ROOT::kSTLvector: {; 743 if ((*fValue).fKind == kBool_t) {; 744 return new TGenVectorBoolProxy(*this);; 745 } else {; 746 return new TGenVectorProxy(*this);; 747 }; 748 }; 749 case ROOT::kSTLlist:; 750 case ROOT::kSTLforwardlist:; 751 return new TGenListProxy(*this);; 752 case ROOT::kSTLmap:; 753 case ROOT::kSTLunorderedmap:; 754 case ROOT::kSTLmultimap:; 755 case ROOT::kSTLunorderedmultimap:; 756 return new TGenMapProxy(*this);; 757 case ROOT::kSTLset:; 758 case ROOT::kSTLunorderedset:; 759 case ROOT::kSTLmultiset:; 760 case ROOT::kSTLunorderedmultiset:; 761 return new TGenSetProxy(*this);; 762 default:; 763 return new TGenCollectionProxy(*this);; 764 }; 765}; 766 ; 767////////////////////////////////////////////////////////////////////////////////; 768/// Proxy initializer; 769 ; 770TGenCollectionProxy *TGenCollectionProxy::Initialize(Bool_t silent) const; 771{; 772 TGenCollectionPro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:22409,load,load,22409,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['load'],['load']
Performance,"{i=1}^{N}; \frac{y_i-f(i,a^{(t)})}{y_i}; \frac{\partial f(i,a^t)}{\partial a_k}=; \sum_{j=1}^{M}\sum_{i=1}^{N}; \frac{\partial f(i,a^{(t)})}{\partial a_j}; \frac{\partial f(i,a^{(t)})}{\partial a_k}; \Delta a_j^{(t)} \]. in \(\gamma\)-ray spectra we have to fit together tens, hundreds of peaks simultaneously that represent sometimes thousands of parameters.; the calculation of the inversion matrix of such a size is practically impossible.; the awmi method is based on the assumption that off-diagonal terms in the matrix A are equal to zero. \[; \Delta a_{k}^{(t+1)} = \alpha^{(t)}; \frac{; \sum_{i=1}^{N} \frac{e_{i}^{(t)}}{y_i}\frac{\partial f(i,a^{(t)})}{\partial a_k}; }{; \sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}; }; \]; where the error in the channel \(i\) is \(e_{i}^{(t)} = y_i-f(i,a^{(t)}); k=1,2,...,M\) and \(\alpha^{(t)}=1\) if the process is convergent or \(\alpha^{(t)}=0.5 \alpha^{(t-1)}\) if it is divergent. Another possibility is to optimize this coefficient.; the error of \(k\)-th parameter estimate is; \[; \Delta a_k^{(e)}=; \sqrt{\frac; {\sum_{i=1}^{N}\frac{e_i^2}{y_i}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}}; }; \]; algorithm with higher powers w=1,2,3…; \[; \Delta a_{k,w}^{(t+1)}=; \alpha^{(t)}; \frac; {\sum_{i=1}^{N} \frac{e_i}{y_i}\left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w-1}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w}\frac{1}{y_i}}; \]; we have implemented the nonsymmetrical semiempirical peak shape function.; it contains the symmetrical Gaussian as well as nonsymmetrical terms.; \[; f(i,a) =; \sum_{i=1}^{M} A(j); \left\{; exp\left[\frac{-(i-p(j))^2}{2\sigma^2}\right]; +\frac{1}{2}T.exp\left[\frac{(i-p(j))}{B\sigma}\right]; .erfc\left[\frac{(i-p(j))}{\sigma}+\frac{1}{2B}\right]; +\frac{1}{2}S.erfc\left[\frac{(i-p(j))}{\sigma}\right]; \right\}; \]; where \(T,S\) are relative amplitudes and \(B\) is a slop",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:36747,optimiz,optimize,36747,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,1,['optimiz'],['optimize']
Performance,"{kFALSE};  True if directory is writable. ;  ;  Protected Attributes inherited from TDirectory; TContext * fContext {nullptr};  Buffer for GetPath() function. ;  ; std::atomic< size_t > fContextPeg {0};  thread local gDirectory pointing to this object. ;  ; std::vector< SharedGDirectory_t > fGDirectories;  ; TList * fList {nullptr};  ; TObject * fMother {nullptr};  ; TString fPathBuffer;  ; std::atomic_flag fSpinLock;  Counter delaying the TDirectory destructor from finishing. ;  ; TUUID fUUID;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static TList * fgAsyncOpenRequests = nullptr;  ; static std::atomic< Long64_t > fgBytesRead {0};  Number of bytes read by all TFile objects. ;  ; static std::atomic< Long64_t > fgBytesWrite {0};  Number of bytes written by all TFile objects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:43459,cache,cache,43459,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,4,['cache'],"['cache', 'cached']"
Performance,"{}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const;  Plot (project) PDF on specified frame. ;  ; virtual RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const;  Internal back-end function of plotOn() with named arguments. ;  ; virtual std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const;  Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooErrorVar.html:25537,cache,cache,25537,doc/master/classRooErrorVar.html,https://root.cern,https://root.cern/doc/master/classRooErrorVar.html,3,['cache'],['cache']
Performance,"| (kGetLeaf & fFriendLockStatus)); 6221 return nullptr;; 6222 ; 6223 std::string path(name);; 6224 const auto sep = path.find_last_of('/');; 6225 if (sep != std::string::npos); 6226 return GetLeafImpl(path.substr(0, sep).c_str(), name+sep+1);; 6227 ; 6228 return GetLeafImpl(nullptr, name);; 6229}; 6230 ; 6231////////////////////////////////////////////////////////////////////////////////; 6232/// Return maximum of column with name columname.; 6233/// if the Tree has an associated TEventList or TEntryList, the maximum; 6234/// is computed for the entries in this list.; 6235 ; 6236Double_t TTree::GetMaximum(const char* columname); 6237{; 6238 TLeaf* leaf = this->GetLeaf(columname);; 6239 if (!leaf) {; 6240 return 0;; 6241 }; 6242 ; 6243 // create cache if wanted; 6244 if (fCacheDoAutoInit); 6245 SetCacheSizeAux();; 6246 ; 6247 TBranch* branch = leaf->GetBranch();; 6248 Double_t cmax = -DBL_MAX;; 6249 for (Long64_t i = 0; i < fEntries; ++i) {; 6250 Long64_t entryNumber = this->GetEntryNumber(i);; 6251 if (entryNumber < 0) break;; 6252 branch->GetEntry(entryNumber);; 6253 for (Int_t j = 0; j < leaf->GetLen(); ++j) {; 6254 Double_t val = leaf->GetValue(j);; 6255 if (val > cmax) {; 6256 cmax = val;; 6257 }; 6258 }; 6259 }; 6260 return cmax;; 6261}; 6262 ; 6263////////////////////////////////////////////////////////////////////////////////; 6264/// Static function which returns the tree file size limit in bytes.; 6265 ; 6266Long64_t TTree::GetMaxTreeSize(); 6267{; 6268 return fgMaxTreeSize;; 6269}; 6270 ; 6271////////////////////////////////////////////////////////////////////////////////; 6272/// Return minimum of column with name columname.; 6273/// if the Tree has an associated TEventList or TEntryList, the minimum; 6274/// is computed for the entries in this list.; 6275 ; 6276Double_t TTree::GetMinimum(const char* columname); 6277{; 6278 TLeaf* leaf = this->GetLeaf(columname);; 6279 if (!leaf) {; 6280 return 0;; 6281 }; 6282 ; 6283 // create cache if wanted; 6284 if (fC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:244910,cache,cache,244910,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"| *sIt == '>' ||; 718 *sIt == ' ' || *sIt == '*' ||; 719 *sIt == ',' || *sIt == '&' ||; 720 *sIt == ':') {; 721 fileName += '_';; 722 }; 723 else {; 724 fileName += *sIt;; 725 }; 726 }; 727 if (classes.size() > 1) {; 728 Int_t chk = 0;; 729 std::vector<std::string>::const_iterator it = classes.begin();; 730 while ((++it) != classes.end()) {; 731 for (UInt_t cursor = 0; cursor != it->length(); ++cursor) {; 732 chk = chk * 3 + it->at(cursor);; 733 }; 734 }; 735 fileName += TString::Format(""_%u"", chk);; 736 }; 737 fileName += "".cxx"";; 738 if (gSystem->AccessPathName(fileName) != 0) {; 739 //file does not exist; 740 //(1) prepare file data; 741 // If STL, also request iterators' operators.; 742 // vector is special: we need to check whether; 743 // vector::iterator is a typedef to pointer or a; 744 // class.; 745 static const std::set<std::string> sSTLTypes {; 746 ""vector"",""list"",""forward_list"",""deque"",""map"",""unordered_map"",""multimap"",; 747 ""unordered_multimap"",""set"",""unordered_set"",""multiset"",""unordered_multiset"",; 748 ""queue"",""priority_queue"",""stack"",""iterator""};; 749 std::vector<std::string>::const_iterator it;; 750 std::string fileContent("""");; 751 for (it = headers.begin(); it != headers.end(); ++it) {; 752 fileContent += ""#include \"""" + *it + ""\""\n"";; 753 }; 754 for (it = unknown.begin(); it != unknown.end(); ++it) {; 755 TClass* cl = TClass::GetClass(it->c_str());; 756 if (cl && cl->GetDeclFileName()) {; 757 TString header = gSystem->BaseName(cl->GetDeclFileName());; 758 TString dir = gSystem->GetDirName(cl->GetDeclFileName());; 759 TString dirbase(gSystem->BaseName(dir));; 760 while (dirbase.Length() && dirbase != "".""; 761 && dirbase != ""include"" && dirbase != ""inc""; 762 && dirbase != ""prec_stl"") {; 763 gSystem->PrependPathName(dirbase, header);; 764 dir = gSystem->GetDirName(dir);; 765 }; 766 fileContent += TString(""#include \"""") + header + ""\""\n"";; 767 }; 768 }; 769 for (it = fwdDecls.begin(); it != fwdDecls.end(); ++it) {; 770 fileContent += ""class "" + *it + ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:26526,queue,queue,26526,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['queue'],['queue']
Performance,"|10,LINEAR"");; 151 TString trainingStrategyString(""TrainingStrategy=Optimizer=ADAM,LearningRate=1e-3,""; 152 ""TestRepetitions=1,ConvergenceSteps=10,BatchSize=100,MaxEpochs=20"");; 153 TString nnOptions(""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:""; 154 ""WeightInitialization=XAVIERUNIFORM:Architecture=GPU"");; 155 nnOptions.Append("":"");; 156 nnOptions.Append(layoutString);; 157 nnOptions.Append("":"");; 158 nnOptions.Append(trainingStrategyString);; 159 factory->BookMethod(dataloader, TMVA::Types::kDL, ""DL_GPU"", nnOptions);; 160 }; 161 ; 162 ; 163 // Train MVAs using the set of training events; 164 factory->TrainAllMethods();; 165 ; 166 // Evaluate all MVAs using the set of test events; 167 factory->TestAllMethods();; 168 ; 169 // Evaluate and compare performance of all configured MVAs; 170 factory->EvaluateAllMethods();; 171 ; 172 // --------------------------------------------------------------; 173 ; 174 // Save the output; 175 outputFile->Close();; 176 ; 177 std::cout << ""==> Wrote root file: "" << outputFile->GetName() << std::endl;; 178 std::cout << ""==> TMVAMulticlass is done!"" << std::endl;; 179 ; 180 delete factory;; 181 delete dataloader;; 182 ; 183 // Launch the GUI for the root macros; 184 if (!gROOT->IsBatch()) TMVAMultiClassGui( outfileName );; 185 ; 186 ; 187}; 188 ; 189int main( int argc, char** argv ); 190{; 191 // Select methods (don't look at this code - not of interest); 192 TString methodList;; 193 for (int i=1; i<argc; i++) {; 194 TString regMethod(argv[i]);; 195 if(regMethod==""-b"" || regMethod==""--batch"") continue;; 196 if (!methodList.IsNull()) methodList += TString("","");; 197 methodList += regMethod;; 198 }; 199 TMVAMulticlass(methodList);; 200 return 0;; 201}; 202 ; DataLoader.h; mainint main()Definition Prototype.cxx:12; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; TFile.h; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C_source.html:6863,perform,performance,6863,doc/master/TMVAMulticlass_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C_source.html,1,['perform'],['performance']
Performance,"|; Classes |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; List of all members ; RooExpensiveObjectCache Class ReferenceRooFit » RooFit Core. ; Singleton class that serves as repository for objects that are expensive to calculate. ; Owners of such objects can registers these here with associated parameter values for which the object is valid, so that other instances can, at a later moment retrieve these precalculated objects. ; Definition at line 24 of file RooExpensiveObjectCache.h. Classes; class  ExpensiveObject;  . Public Member Functions;  RooExpensiveObjectCache ();  ;  RooExpensiveObjectCache (const RooExpensiveObjectCache &other);  ;  ~RooExpensiveObjectCache () override;  Destructor. ;  ; void clearAll ();  Clear all cache elements. ;  ; bool clearObj (Int_t uniqueID);  Clear cache element with given unique ID Retrieve payload object of cache element with given unique ID. ;  ; bool empty () const;  ; const TObject * getObj (Int_t uniqueID);  Retrieve payload object of cache element with given unique ID. ;  ; void importCacheObjects (RooExpensiveObjectCache &other, const char *ownerName, bool verbose=false);  ; TClass * IsA () const override;  ; void print () const;  ; bool registerObject (const char *ownerName, const char *objectName, TObject &cacheObject, const RooArgSet &params);  Register object associated with given name and given associated parameters with given values in cache. ;  ; const TObject * retrieveObject (const char *name, TClass *tclass, const RooArgSet &params);  Retrieve object from cache that was registered under given name with given parameters, if current parameter values match those that were stored in the registry for this object. ;  ; bool setObj (Int_t uniqueID, TObject *obj);  Place new payload object in cache element with given unique ID. ;  ; Int_t size () const;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_Streamer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExpensiveObjectCache.html:1182,cache,cache,1182,doc/master/classRooExpensiveObjectCache.html,https://root.cern,https://root.cern/doc/master/classRooExpensiveObjectCache.html,1,['cache'],['cache']
Performance,"|; Private Attributes |; Friends |; List of all members ; RooMinimizer Class ReferenceRooFit » RooFit Core. ; Wrapper class around ROOT::Math::Minimizer that provides a seamless interface between the minimizer functionality and the native RooFit interface. ; By default the Minimizer is Minuit 2. RooMinimizer can minimize any RooAbsReal function with respect to its parameters. Usual choices for minimization are the object returned by RooAbsPdf::createNLL() or RooAbsReal::createChi2(). RooMinimizer has methods corresponding to MINUIT functions like hesse(), migrad(), minos() etc. In each of these function calls the state of the MINUIT engine is synchronized with the state of the RooFit variables: any change in variables, change in the constant status etc is forwarded to MINUIT prior to execution of the MINUIT call. Afterwards the RooFit objects are resynchronized with the output state of MINUIT: changes parameter values, errors are propagated. Various methods are available to control verbosity, profiling, automatic PDF optimization. ; Definition at line 48 of file RooMinimizer.h. Classes; struct  Config;  Config argument to RooMinimizer constructor. More...;  ; struct  FitResult;  ; class  FitterInterface;  . Public Types; enum  PrintLevel { ;   None = -1; , Reduced = 0; , Normal = 1; , ExtraForProblem = 2; , ;   Maximum = 3. };  ; enum  Strategy { Speed = 0; , Balance = 1; , Robustness = 2; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1UL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMinimizer.html:1288,optimiz,optimization,1288,doc/master/classRooMinimizer.html,https://root.cern,https://root.cern/doc/master/classRooMinimizer.html,1,['optimiz'],['optimization']
Performance,"}""); hcorr.GetXaxis().SetBinLabel(3, ""c_{HDD}""); hcorr.GetXaxis().SetBinLabel(2, ""c_{Hl^{(3)}}""); hcorr.GetXaxis().SetBinLabel(1, ""c_{Hq^{(3)}}""); hcorr.GetYaxis().SetTitleOffset(1.4); hcorr.Draw(""colz text""); ; c1.SaveAs(""rf712_lagrangianmorphfit.png""); [#0] PROGRESS:InputArguments -- initializing physics inputs from file /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/roofit/input_histos_rf_lagrangianmorph.root with object name(s) 'pTV'; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x85555e0; [#0] PROGRESS:Caching -- current storage has size 10; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; [#1] INFO:DataHandling -- RooDataHist::adjustBinning(pseudo_dh): fit range of variable pTV expanded to nearest bin boundaries: [10,600] --> [0,600]; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x915c650; [#0] PROGRESS:Caching -- current storage has size 10; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(wrap_pdf_over_wrap_pdf_Int[pTV]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_wrap_pdf_over_wrap_pdf_Int[pTV]_pseudo_dh) Summation contains a RooNLLVar, using its error level; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0 cHl3=0 cHq3=-0.0202918; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, deno",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8py.html:5082,cache,cache,5082,doc/master/rf712__lagrangianmorphfit_8py.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8py.html,2,['cache'],['cache']
Performance,"});; auto min = d2.Filter([](double b2) { return b2 > 0; }, {""b2""}) // we can still specify non-default column lists; .Min(); // returns the minimum value of ""b1"" for the filtered entries; ROOT::RDF::RInterface< RDFDetail::RLoopManager >::MinRResultPtr< RDFDetail::MinReturnType_t< T > > Min(std::string_view columnName="""")Return the minimum of processed column values (lazy action).Definition RInterface.hxx:2471. Special helper columns: rdfentry_ and rdfslot_; Every instance of RDataFrame is created with two special columns called rdfentry_ and rdfslot_. The rdfentry_ column is of type ULong64_t and it holds the current entry number while rdfslot_ is an unsigned int holding the index of the current data processing slot. For backwards compatibility reasons, the names tdfentry_ and tdfslot_ are also accepted. These columns are ignored by operations such as Cache or Snapshot.; WarningNote that in multi-thread event loops the values of rdfentry_ do not correspond to what would be the entry numbers of a TChain constructed over the same set of ROOT files, as the entries are processed in an unspecified order. Just-in-time compilation: column type inference and explicit declaration of column types; C++ is a statically typed language: all types must be known at compile-time. This includes the types of the TTree branches we want to work on. For filters, defined columns and some of the actions, column types are deduced from the signature of the relevant filter function/temporary column expression/action function: // here b1 is deduced to be `int` and b2 to be `double`; df.Filter([](int x, double y) { return x > 0 && y < 0.; }, {""b1"", ""b2""});; If we specify an incorrect type for one of the columns, an exception with an informative message will be thrown at runtime, when the column value is actually read from the dataset: RDataFrame detects type mismatches. The same would happen if we swapped the order of ""b1"" and ""b2"" in the column list passed to Filter().; Certain actions, on th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:62654,multi-thread,multi-thread,62654,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['multi-thread'],['multi-thread']
Performance,"});; auto min = d2.Filter([](double b2) { return b2 > 0; }, {""b2""}) // we can still specify non-default column lists; .Min(); // returns the minimum value of ""b1"" for the filtered entries; ROOT::RDF::RInterface< RDFDetail::RLoopManager >::MinRResultPtr< RDFDetail::MinReturnType_t< T > > Min(std::string_view columnName="""")Return the minimum of processed column values (lazy action).Definition RInterface.hxx:2640. Special helper columns: rdfentry_ and rdfslot_; Every instance of RDataFrame is created with two special columns called rdfentry_ and rdfslot_. The rdfentry_ column is of type ULong64_t and it holds the current entry number while rdfslot_ is an unsigned int holding the index of the current data processing slot. For backwards compatibility reasons, the names tdfentry_ and tdfslot_ are also accepted. These columns are ignored by operations such as Cache or Snapshot.; WarningNote that in multi-thread event loops the values of rdfentry_ do not correspond to what would be the entry numbers of a TChain constructed over the same set of ROOT files, as the entries are processed in an unspecified order. Just-in-time compilation: column type inference and explicit declaration of column types; C++ is a statically typed language: all types must be known at compile-time. This includes the types of the TTree branches we want to work on. For filters, defined columns and some of the actions, column types are deduced from the signature of the relevant filter function/temporary column expression/action function: // here b1 is deduced to be `int` and b2 to be `double`; df.Filter([](int x, double y) { return x > 0 && y < 0.; }, {""b1"", ""b2""});; If we specify an incorrect type for one of the columns, an exception with an informative message will be thrown at runtime, when the column value is actually read from the dataset: RDataFrame detects type mismatches. The same would happen if we swapped the order of ""b1"" and ""b2"" in the column list passed to Filter().; Certain actions, on th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:64076,multi-thread,multi-thread,64076,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['multi-thread'],['multi-thread']
Performance,"})]; }); ]; }).placeAt(""content"");; </script>; JSROOT uses https://openui5.hana.ondemand.com/1.128.0/ when no other source is specified.; There are small details when using OpenUI5 with THttpServer. First of all, location of JSROOT modules should be specified as /jsrootsys/modules/main.mjs. And then trying to access files from local disk, one should specify /currentdir/ folder:; jQuery.sap.registerModulePath(""NavExample"", ""/currentdir/"");; JSROOT provides example showing usage of JSROOT drawing in the OpenUI5, source code can be found in repository.; 1.11.10 Migration v6 -> v7. Core functionality should be imported from main.mjs module like:. import { create, parse, createHistogram, redraw } from 'https://root.cern/js/7.0.0/modules/main.mjs';. It is still possible to use JSRoot.core.js script, which provides very similar (but not identical!) functionality as with v6 via global JSROOT object; JSROOT.define() and JSROOT.require() functions only available after JSRoot.core.js loading; Support of require.js and openui5 loaders was removed; Global hierarchy painter JSROOT.hpainter no longer existing, one can use getHPainter function:. import { getHPainter } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let hpainter = getHPainter();. All math functions previously available via JSROOT.Math should be imported from base/math.mjs module:. import * as math from 'https://root.cern/js/7.0.0/modules/base/math.mjs';. Indication of batch mode JSROOT.batch_mode should be accessed via functions:. import { isBatchMode, setBatchMode } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let was_batch = isBatchMode();; if (!was_batch) setBatchMode(true);. JSROOT.extend() function was removed, use Object.assign() instead. 1.11.11 Migration v5 -> v6. Main script was renamed to JSRoot.core.js. Old JSRootCore.js was deprecated and removed in v6.2. All URL parameters for main script ignored now, to load JSROOT functionality one should use JSROOT.require function. To create standard GUI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:34883,load,loading,34883,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['load'],['loading']
Performance,"}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const;  Plot (project) PDF on specified frame. ;  ; virtual RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const;  Internal back-end function of plotOn() with named arguments. ;  ; virtual std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const;  Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:27335,cache,cache,27335,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['cache'],['cache']
Performance,"},; {(char*)""__reshape__"", (PyCFunction)op_reshape, METH_O,; (char*)""cast pointer to 1D array type""},; {(char*)nullptr, nullptr, 0, nullptr}; }; CPyCppyy::op_reshapestatic PyObject * op_reshape(CPPInstance *self, PyObject *shape)Definition CPPInstance.cxx:330; CPyCppyy::op_dispatchstatic PyObject * op_dispatch(PyObject *self, PyObject *args, PyObject *)Definition CPPInstance.cxx:277; CPyCppyy::op_destructstatic PyObject * op_destruct(CPPInstance *self)Definition CPPInstance.cxx:266. Definition at line 405 of file CPPInstance.cxx. ◆ RefFloat_Type. PyTypeObject CPyCppyy::RefFloat_Type. Initial value:= { ; PyObject_HEAD_INIT( &PyType_Type ) 0 ,; (char*)""cppyy.Double"", ; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,; Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES |; Py_TPFLAGS_BASETYPE, ; (char*)""CPyCppyy float object for pass by reference"", ; 0, 0, 0, 0, 0, 0, 0, 0, 0,; &PyFloat_Type, ; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0; ; ; ; ; ; ; ; ; ; }. Custom ""builtins,"" detectable by type, for pass by ref and improved performance. ; Definition at line 27 of file CustomPyTypes.cxx. ◆ RefInt_Type. PyTypeObject CPyCppyy::RefInt_Type. Initial value:= { ; PyObject_HEAD_INIT( &PyType_Type ) 0 ,; (char*)""cppyy.Long"", ; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,; Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES |; Py_TPFLAGS_BASETYPE; ; ; ; , ; (char*)""CPyCppyy long object for pass by reference"", ; 0, 0, 0, 0, 0, 0, 0, 0, 0,; &PyInt_Type, ; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0; ; ; ; ; ; ; ; ; ; }. Definition at line 49 of file CustomPyTypes.cxx. ◆ SMALL_ARGS_N. const int CPyCppyy::SMALL_ARGS_N = 8. Definition at line 13 of file CallContext.h. ◆ TemplateProxy_Type. PyTypeObject CPyCppyy::TemplateProxy_Type. Definition at line 890 of file TemplateProxy.cxx. ◆ tpp_as_mapping. PyMappingMethods CPyCppyy::tpp_as_mapping. static . Initial value:= {; nullptr, (binaryfunc)tpp_subscript, nullptr; }. Definition at line 754 of file TemplateProxy.cxx. ◆ tpp_getset. PyGetSetDef CPyCppyy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceCPyCppyy.html:68385,perform,performance,68385,doc/master/namespaceCPyCppyy.html,https://root.cern,https://root.cern/doc/master/namespaceCPyCppyy.html,1,['perform'],['performance']
Performance,"}; 1130 return tc->AddBranch(b,subbranches);; 1131}; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Remove the branch with name 'bname' from the Tree cache.; 1135/// If bname=""*"" all branches are removed from the cache.; 1136/// if subbranches is true all the branches of the subbranches are; 1137/// also removed from the cache.; 1138///; 1139/// Returns:; 1140/// - 0 branch dropped or not in cache; 1141/// - -1 on error; 1142 ; 1143Int_t TTree::DropBranchFromCache(const char*bname, bool subbranches); 1144{; 1145 if (!GetTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return -1;; 1149 }; 1150 }; 1151 if (GetTree()) {; 1152 if (GetTree() != this) {; 1153 return GetTree()->DropBranchFromCache(bname, subbranches);; 1154 }; 1155 } else {; 1156 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFile *f = GetCurrentFile();; 1161 if (!f) {; 1162 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1163 return -1;; 1164 }; 1165 TTreeCache *tc = GetReadCache(f,true);; 1166 if (!tc) {; 1167 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1168 return -1;; 1169 }; 1170 return tc->DropBranch(bname,subbranches);; 1171}; 1172 ; 1173////////////////////////////////////////////////////////////////////////////////; 1174/// Remove the branch b from the Tree cache.; 1175/// if subbranches is true all the branches of the subbranches are; 1176/// also removed from the cache.; 1177///; 1178/// Returns:; 1179/// - 0 branch dropped or not in cache; 1180/// - -1 on error; 1181 ; 1182Int_t TTree::DropBranchFromCache(TBranch *b, bool subbranches); 1183{; 1184 if (!GetTree()) {; 1185 if (LoadTree(0)<0) {; 1186 Error(""DropBranchFromCache"",""Could not load a tree"");; 1187 return -1;; 1188 }; 1189 }; 1190 if (GetTree()) {; 1191 if (GetTree() != ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:41108,cache,cache,41108,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,}; 5372 return nullptr;; 5373}; 5374 ; 5375////////////////////////////////////////////////////////////////////////////////; 5376/// Return status of branch with name branchname.; 5377///; 5378/// - 0 if branch is not activated; 5379/// - 1 if branch is activated; 5380 ; 5381bool TTree::GetBranchStatus(const char* branchname) const; 5382{; 5383 TBranch* br = const_cast<TTree*>(this)->GetBranch(branchname);; 5384 if (br) {; 5385 return br->TestBit(kDoNotProcess) == 0;; 5386 }; 5387 return false;; 5388}; 5389 ; 5390////////////////////////////////////////////////////////////////////////////////; 5391/// Static function returning the current branch style.; 5392///; 5393/// - style = 0 old Branch; 5394/// - style = 1 new Bronch; 5395 ; 5396Int_t TTree::GetBranchStyle(); 5397{; 5398 return fgBranchStyle;; 5399}; 5400 ; 5401////////////////////////////////////////////////////////////////////////////////; 5402/// Used for automatic sizing of the cache.; 5403///; 5404/// Estimates a suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:214172,cache,cache,214172,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"};; 1168 nets.reserve(nThreads);; 1169 for (size_t i = 0; i < nThreads; i++) {; 1170 nets.push_back(net);; 1171 for (size_t j = 0; j < net.GetDepth(); j++); 1172 {; 1173 auto &masterLayer = net.GetLayer(j);; 1174 auto &layer = nets.back().GetLayer(j);; 1175 TCpu<>::Copy(layer.GetWeights(),; 1176 masterLayer.GetWeights());; 1177 TCpu<>::Copy(layer.GetBiases(),; 1178 masterLayer.GetBiases());; 1179 }; 1180 }; 1181 ; 1182 bool converged = false;; 1183 size_t stepCount = 0;; 1184 size_t batchesInEpoch = nTrainingSamples / net.GetBatchSize();; 1185 ; 1186 std::chrono::time_point<std::chrono::system_clock> start, end;; 1187 start = std::chrono::system_clock::now();; 1188 ; 1189 if (!fInteractive) {; 1190 Log() << std::setw(10) << ""Epoch"" << "" | ""; 1191 << std::setw(12) << ""Train Err.""; 1192 << std::setw(12) << ""Test Err.""; 1193 << std::setw(12) << ""GFLOP/s""; 1194 << std::setw(12) << ""Conv. Steps"" << Endl;; 1195 std::string separator(62, '-');; 1196 Log() << separator << Endl;; 1197 }; 1198 ; 1199 while (!converged); 1200 {; 1201 stepCount++;; 1202 // Perform minimization steps for a full epoch.; 1203 trainingData.Shuffle();; 1204 for (size_t i = 0; i < batchesInEpoch; i += nThreads) {; 1205 batches.clear();; 1206 for (size_t j = 0; j < nThreads; j++) {; 1207 batches.reserve(nThreads);; 1208 batches.push_back(trainingData.GetBatch());; 1209 }; 1210 if (settings.momentum > 0.0) {; 1211 minimizer.StepMomentum(net, nets, batches, settings.momentum);; 1212 } else {; 1213 minimizer.Step(net, nets, batches);; 1214 }; 1215 }; 1216 ; 1217 if ((stepCount % minimizer.GetTestInterval()) == 0) {; 1218 ; 1219 // Compute test error.; 1220 Double_t testError = 0.0;; 1221 for (auto batch : testData) {; 1222 auto inputMatrix = batch.GetInput();; 1223 auto outputMatrix = batch.GetOutput();; 1224 auto weightMatrix = batch.GetWeights();; 1225 testError += testNet.Loss(inputMatrix, outputMatrix, weightMatrix);; 1226 }; 1227 testError /= (Double_t) (nTestSamples / settings.batchSize);; 1228 ; 12",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:43301,Perform,Perform,43301,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['Perform'],['Perform']
Performance,"};; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TList*fClaimslist of claims we manage; TStringfPoolthe condor pool to be accessed; TCondor::EStatefStateour claim state; Bool_tfValidaccess to Condor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondor(const char *pool); Create Condor interface object. Uses Condor apps since there is no; API yet. ~TCondor(); Cleanup Condor interface. void Print(Option_t* option = """") const; Print master status. TCondorSlave * ClaimVM(const char* vm, const char* cmd); Claim a VirtualMachine for PROOF usage. TList * GetVirtualMachines() const; Get the names of the virtual machines in the pool.; Return a TList of TObjString or 0 in case of failure. TList * Claim(Int_t n, const char *cmd); Claim n virtual machines; This function figures out the image and performance index before returning; the list of condor slaves. TCondorSlave * Claim(const char *vmname, const char *cmd); Claim virtual machine with name vmname; This function does not figure out the image and performance index before; returning the condor slave. Bool_t SetState(TCondor::EState state); Set the state of workers. Bool_t Suspend(); Suspend worker. Bool_t Resume(); Resume worker. Bool_t Release(); Release worker. Bool_t GetVmInfo(const char* vm, TString& image, Int_t& perfidx) const; Get info about worker status. TString GetImage(const char* host) const; Get image of the worker. TCondor(const char *pool = """"). Bool_t IsValid() const; { return fValid; }. EState GetState() const; {return fState;}. » Author: Maarten Ballintijn 06/12/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TCondor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2009-12-07 15:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCondor.html:6675,perform,performance,6675,root/html526/TCondor.html,https://root.cern,https://root.cern/root/html526/TCondor.html,1,['perform'],['performance']
Performance,"};; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfCPUParList of par files to be loaded for CPU benchmarks; TStringfCPUSelSelector to be used for CPU benchmarks; TProofBenchDataSet*fDSInstance to handle datasets operations; TStringfDataGenParList of par files to be loaded to generate data for benchmarks; TStringfDataGenSelSelector to be used for generate data for benchmarks; TStringfDataParList of par files to be loaded for data benchmarks; TStringfDataSelSelector to be used for data benchmarks; TStringfDataSetName of the dataset; Bool_tfDebugDebug switch; TNamed*fDescriptionStrings describing the cluster for this test (saved in the output file); TPBHistType*fHistTypeType of histograms for CPU runs; Int_tfNFilesWrkNumber of files generated files per worker; Int_tfNHistNumber of histograms to be created in default CPU runs; Int_tfNtriesNumber of times a measurement is repeated; Int_tfNumWrkMaxMax number of workers (required for dynamic setups); TFile*fOutFileOutput file; TStringfOutFileNameName of the output file; TProof*fProofProof; TProof*fProofDSProof to be used for dataset actions; TPBReadType*fReadTypeType of read (partial, full); Bool_tfReleaseCacheRelease cache for data reads between runs ; TProofBenchRunCPU*fRunCPUInstance to run CPU scans; TProofBenchRunDataRead*fRunDSInstance to run data-read scans; static TF1*fgFioFunction used for I/O rate fits; static TF1*fgFioVFunction used for I/O rate fits with non-constant Rcpu; static TF1*fgFp1Simple 1st degree polynomial; static TF1*fgFp1nNormalized 1st degree; static TF1*fgFp2Simple 2nd degree polynomial; static TF1*fgFp2nNormalized 2nd degree; static TF1*fgFp3Function with varying Rcpu; static TF1*fgFp3nNormalized Function with varying Rcpu; static TList*fgGraphsList of TGraphErrors created by Draw actions. private:. Bool_tfUnlinkOutfileWhether to remove empty output files. Class Charts. Inheritance; Inherited Members; Includes; L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofBench.html:7259,load,loaded,7259,root/html534/TProofBench.html,https://root.cern,https://root.cern/root/html534/TProofBench.html,4,"['cache', 'load']","['cache', 'loaded']"
Performance,"~RooMappedCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMappedCategory.html:1604,Cache,CacheModeRooAbsArg,1604,root/html534/RooMappedCategory.html,https://root.cern,https://root.cern/root/html534/RooMappedCategory.html,1,['Cache'],['CacheModeRooAbsArg']
Performance,"~TF1Convolution ; (; ). inlineoverride . Definition at line 56 of file TF1Convolution.h. Member Function Documentation. ◆ Class(). static TClass * TF1Convolution::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TF1Convolution::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TF1Convolution::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 80 of file TF1Convolution.h. ◆ Copy(). void TF1Convolution::Copy ; (; TObject & ; object); const. overridevirtual . Copy this to obj. ; Implements TF1AbsComposition.; Definition at line 504 of file TF1Convolution.cxx. ◆ DeclFileName(). static const char * TF1Convolution::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 80 of file TF1Convolution.h. ◆ EvalFFTConv(). Double_t TF1Convolution::EvalFFTConv ; (; Double_t ; t). private . Perform FFT convolution. ; Definition at line 330 of file TF1Convolution.cxx. ◆ EvalNumConv(). Double_t TF1Convolution::EvalNumConv ; (; Double_t ; t). private . Perform numerical convolution. ; Definition at line 345 of file TF1Convolution.cxx. ◆ GetNpar(). Int_t TF1Convolution::GetNpar ; (; ); const. inline . Definition at line 68 of file TF1Convolution.h. ◆ GetParName(). const char * TF1Convolution::GetParName ; (; Int_t ; ipar); const. inline . Definition at line 71 of file TF1Convolution.h. ◆ GetRange(). void TF1Convolution::GetRange ; (; Double_t & ; a, . Double_t & ; b . ); const. Get the range used for the convolution. ; Definition at line 487 of file TF1Convolution.cxx. ◆ GetXmax(). Double_t TF1Convolution::GetXmax ; (; ); const. inline . Definition at line 70 of file TF1Convolution.h. ◆ GetXmin(). Double_t TF1Convolution::GetXmin ; (; ); const. inline . Definition at line 69 of file TF1Convolution.h. ◆ InitializeDataMembers(). void TF1Convolution::InitializeDataMembers ; (; TF1 * ; funct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1Convolution.html:17480,Perform,Perform,17480,doc/master/classTF1Convolution.html,https://root.cern,https://root.cern/doc/master/classTF1Convolution.html,1,['Perform'],['Perform']
Performance,"~~{.cpp}; 1201df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; 1202df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; 1203~~~; 1204 ; 1205Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime; 1206overhead, so specifying the type of the columns as template parameters to the action is good practice when performance is a goal.; 1207 ; 1208When strings are passed as expressions to Filter() or Define(), fundamental types are passed as constants. This avoids certaincommon mistakes such as typing `x = 0` rather than `x == 0`:; 1209 ; 1210~~~{.cpp}; 1211// this throws an error (note the typo); 1212df.Define(""x"", ""0"").Filter(""x = 0"");; 1213~~~; 1214 ; 1215\anchor generic-actions; 1216### User-defined custom actions; 1217RDataFrame strives to offer a comprehensive set of standard actions that can be performed on each event. At the same; 1218time, it allows users to inject their own action code to perform arbitrarily complex data reductions.; 1219 ; 1220#### Implementing custom actions with Book(); 1221 ; 1222Through the Book() method, users can implement a custom action and have access to the same features; 1223that built-in RDataFrame actions have, e.g. hooks to events related to the start, end and execution of the; 1224event loop, or the possibility to return a lazy RResultPtr to an arbitrary type of result:; 1225 ; 1226~~~{.cpp}; 1227#include <ROOT/RDataFrame.hxx>; 1228#include <memory>; 1229 ; 1230class MyCounter : public ROOT::Detail::RDF::RActionImpl<MyCounter> {; 1231 std::shared_ptr<int> fFinalResult = std::make_shared<int>(0);; 1232 std::vector<int> fPerThreadResults;; 1233 ; 1234public:; 1235 // We use a public type alias to advertise the type of the result of this action; 1236 using Result_t = int;; 1237 ; 1238 MyCounter(unsigned int nSlots) : fPerThreadResults(nSlots) {}; 1239 ; 1240 // Called before the event loop to retrieve the address of the resul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:71657,perform,perform,71657,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['perform'],['perform']
Performance,"~~{.cpp}; 1241df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; 1242df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; 1243~~~; 1244 ; 1245Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime; 1246overhead, so specifying the type of the columns as template parameters to the action is good practice when performance is a goal.; 1247 ; 1248When strings are passed as expressions to Filter() or Define(), fundamental types are passed as constants. This avoids certaincommon mistakes such as typing `x = 0` rather than `x == 0`:; 1249 ; 1250~~~{.cpp}; 1251// this throws an error (note the typo); 1252df.Define(""x"", ""0"").Filter(""x = 0"");; 1253~~~; 1254 ; 1255\anchor generic-actions; 1256### User-defined custom actions; 1257RDataFrame strives to offer a comprehensive set of standard actions that can be performed on each event. At the same; 1258time, it allows users to inject their own action code to perform arbitrarily complex data reductions.; 1259 ; 1260#### Implementing custom actions with Book(); 1261 ; 1262Through the Book() method, users can implement a custom action and have access to the same features; 1263that built-in RDataFrame actions have, e.g. hooks to events related to the start, end and execution of the; 1264event loop, or the possibility to return a lazy RResultPtr to an arbitrary type of result:; 1265 ; 1266~~~{.cpp}; 1267#include <ROOT/RDataFrame.hxx>; 1268#include <memory>; 1269 ; 1270class MyCounter : public ROOT::Detail::RDF::RActionImpl<MyCounter> {; 1271 std::shared_ptr<int> fFinalResult = std::make_shared<int>(0);; 1272 std::vector<int> fPerThreadResults;; 1273 ; 1274public:; 1275 // We use a public type alias to advertise the type of the result of this action; 1276 using Result_t = int;; 1277 ; 1278 MyCounter(unsigned int nSlots) : fPerThreadResults(nSlots) {}; 1279 ; 1280 // Called before the event loop to retrieve the address of the resul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:73337,perform,perform,73337,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['perform'],['perform']
Performance," . ). Default constructor. ; Definition at line 61 of file TGeoParallelWorld.cxx. ◆ ~TGeoParallelWorld(). TGeoParallelWorld::~TGeoParallelWorld ; (; ). override . Destructor. ; Definition at line 76 of file TGeoParallelWorld.cxx. Member Function Documentation. ◆ AddNode(). void TGeoParallelWorld::AddNode ; (; const char * ; path). Add a node normally to this world. Overlapping nodes not allowed. ; Definition at line 92 of file TGeoParallelWorld.cxx. ◆ AddOverlap() [1/2]. void TGeoParallelWorld::AddOverlap ; (; const char * ; volname, . Bool_t ; activate = kTRUE . ). To use this optimization, the user should declare the full list of volumes which may overlap with any of the physical nodes of the parallel world. ; Better be done before misalignment ; Definition at line 120 of file TGeoParallelWorld.cxx. ◆ AddOverlap() [2/2]. void TGeoParallelWorld::AddOverlap ; (; TGeoVolume * ; vol, . Bool_t ; activate = kTRUE . ). To use this optimization, the user should declare the full list of volumes which may overlap with any of the physical nodes of the parallel world. ; Better be done before misalignment ; Definition at line 108 of file TGeoParallelWorld.cxx. ◆ BuildBVH(). void TGeoParallelWorld::BuildBVH ; (; ). Build the BVH acceleration structure. ; Definition at line 1315 of file TGeoParallelWorld.cxx. ◆ CheckBVH(). bool TGeoParallelWorld::CheckBVH ; (; void * ; bvh, . size_t ; expected_leaf_count . ); const. Check/validate the BVH acceleration structure. ; Definition at line 1261 of file TGeoParallelWorld.cxx. ◆ CheckOverlaps(). void TGeoParallelWorld::CheckOverlaps ; (; Double_t ; ovlp = 0.001). Check overlaps within a tolerance value. ; Definition at line 1245 of file TGeoParallelWorld.cxx. ◆ Class(). static TClass * TGeoParallelWorld::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGeoParallelWorld::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGeoParallelWorld::C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:18791,optimiz,optimization,18791,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['optimiz'],['optimization']
Performance," . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TProofDrawListOfPolyMarkers3D Class Reference. . Definition at line 281 of file TProofDraw.h. Classes; struct  Point4D_t;  . Public Member Functions;  TProofDrawListOfPolyMarkers3D ();  ; TClass * IsA () const override;  ; void SlaveBegin (TTree *) override;  See TProofDraw::SlaveBegin(). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Terminate () override;  See TProofDraw::Terminate(). ;  ;  Public Member Functions inherited from TProofDraw;  TProofDraw ();  Constructor. ;  ;  ~TProofDraw () override;  Destructor. ;  ; void Begin (TTree *) override;  Executed by the client before processing. ;  ; void Init (TTree *) override;  Init the tree. ;  ; Bool_t Notify () override;  Called when a new tree is loaded. ;  ; Bool_t Process (Long64_t) override;  Executed for each entry. ;  ; void SlaveTerminate () override;  Executed by each slave after the processing has finished, before returning the results to the client. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; int Version () const override;  ;  Public Member Functions inherited from TSelector;  TSelector ();  Default selector ctor. ;  ;  ~TSelector () override;  Selector destructor. ;  ; virtual void Abort (const char *why, EAbort what=kAbortProcess);  Abort processing. ;  ; virtual EAbort GetAbort () const;  ; virtual Int_t GetEntry (Long64_t, Int_t=0);  ; virtual TList * GetInputList () const;  ; const char * GetOption () const override;  ; virtual TList * GetOutputList () const;  ; virtual Long64_t GetStatus () const;  ; virtual void ImportOutput (TList *output);  Imports the content of 'output' in the internal output list. ;  ; TClass * IsA () const override;  ; bool Notify () over",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDrawListOfPolyMarkers3D.html:1122,load,loaded,1122,doc/master/classTProofDrawListOfPolyMarkers3D.html,https://root.cern,https://root.cern/doc/master/classTProofDrawListOfPolyMarkers3D.html,1,['load'],['loaded']
Performance," . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Types |; Private Attributes |; List of all members ; ROOT::Detail::RDF::RFilter< FilterF, PrevNodeRaw > Class Template Referencefinal. ; template<typename FilterF, typename PrevNodeRaw>; class ROOT::Detail::RDF::RFilter< FilterF, PrevNodeRaw >; Definition at line 57 of file RFilter.hxx. Public Member Functions;  RFilter (const RFilter &)=delete;  ;  RFilter (FilterF f, const ROOT::RDF::ColumnNames_t &columns, std::shared_ptr< PrevNode_t > pd, const RDFInternal::RColumnRegister &colRegister, std::string_view name="""", const std::string &variationName=""nominal"");  ;  ~RFilter ();  ; void AddFilterName (std::vector< std::string > &filters) final;  ; template<typename... ColTypes, std::size_t... S> ; bool CheckFilterHelper (unsigned int slot, Long64_t entry, TypeList< ColTypes... >, std::index_sequence< S... >);  ; bool CheckFilters (unsigned int slot, Long64_t entry) final;  ; void FinalizeSlot (unsigned int slot) final;  Clean-up operations to be performed at the end of a task. ;  ; std::shared_ptr< RDFGraphDrawing::GraphNode > GetGraph (std::unordered_map< void *, std::shared_ptr< RDFGraphDrawing::GraphNode > > &visitedMap) final;  ; template<typename ColType > ; auto GetValueChecked (unsigned int slot, std::size_t readerIdx, Long64_t entry) -> ColType &;  ; std::shared_ptr< RNodeBase > GetVariedFilter (const std::string &variationName) final;  Return a clone of this Filter that works with values in the variationName ""universe"". ;  ; void IncrChildrenCount () final;  ; void InitSlot (TTreeReader *r, unsigned int slot) final;  ; RFilter & operator= (const RFilter &)=delete;  ; void PartialReport (ROOT::RDF::RCutFlowReport &rep) const final;  ; void Report (ROOT::RDF::RCutFlowReport &rep) const final;  ; void StopProcessing () final;  ; void TriggerChildrenCount () final;  ;  Public Member Functions inherited from ROOT::Detail::RDF::RFilterBase;  RFilterBase (RLoopManager *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RFilter.html:1182,perform,performed,1182,doc/master/classROOT_1_1Detail_1_1RDF_1_1RFilter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RFilter.html,1,['perform'],['performed']
Performance," . Protected Types; typedef void *(* ArrIterfunc_t) (void *from, size_t size);  ; typedef void *(* Collectfunc_t) (void *from, void *to);  ; typedef ROOT::Detail::TCollectionProxyInfo::Environ< char[64]> Env_t;  ; typedef ROOT::Detail::TCollectionProxyInfo::EnvironBase EnvironBase_t;  ; typedef void *(* Feedfunc_t) (void *from, void *to, size_t size);  ; typedef std::vector< EnvironBase_t * > Proxies_t;  ; typedef void(* Sizing_t) (void *obj, size_t size);  ; typedef std::vector< TStaging * > Staged_t;  Collection of pre-allocated staged array for associative containers. ;  . Protected Member Functions; void CheckFunctions () const;  Check existence of function pointers. ;  ; virtual void DeleteItem (Bool_t force, void *ptr) const;  Call to delete/destruct individual item. ;  ; TGenCollectionProxy * Initialize (Bool_t silent) const;  Proxy initializer. ;  ; virtual TGenCollectionProxy * InitializeEx (Bool_t silent);  Proxy initializer. ;  . Protected Attributes; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionProxy.html:9947,cache,cache,9947,doc/master/classTGenCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionProxy.html,1,['cache'],['cache']
Performance," ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TTree.cxx. Go to the documentation of this file. 1// @(#)root/tree:$Id$; 2// Author: Rene Brun 12/01/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11/**; 12 \defgroup tree Tree Library; 13 ; 14 In order to store columnar datasets, ROOT provides the TTree, TChain,; 15 TNtuple and TNtupleD classes.; 16 The TTree class represents a columnar dataset. Any C++ type can be stored in the; 17 columns. The TTree has allowed to store about **1 EB** of data coming from the LHC alone:; 18 it is demonstrated to scale and it's battle tested. It has been optimized during the years; 19 to reduce dataset sizes on disk and to deliver excellent runtime performance.; 20 It allows to access only part of the columns of the datasets, too.; 21 The TNtuple and TNtupleD classes are specialisations of the TTree class which can; 22 only hold single precision and double precision floating-point numbers respectively;; 23 The TChain is a collection of TTrees, which can be located also in different files.; 24 ; 25*/; 26 ; 27/** \class TTree; 28\ingroup tree; 29 ; 30A TTree represents a columnar dataset. Any C++ type can be stored in its columns.; 31 ; 32A TTree, often called in jargon *tree*, consists of a list of independent columns or *branches*,; 33represented by the TBranch class.; 34Behind each branch, buffers are allocated automatically by ROOT.; 35Such buffers are automatically written to disk or kept in memory until the size stored in the; 36attribute fMaxVirtualSize is reached.; 37Variables of one branch are written to the same buffer. A branch buffer is; 38automatically compressed if the f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:1005,optimiz,optimized,1005,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,2,"['optimiz', 'perform']","['optimized', 'performance']"
Performance," ; Bool_t InControl () const;  ; virtual Bool_t Init ();  Initialize the OS interface. ;  ; virtual void InnerLoop ();  Inner event loop. ;  ; virtual Bool_t IsAbsoluteFileName (const char *dir);  Return true if dir is an absolute pathname. ;  ; virtual Bool_t IsFileInIncludePath (const char *name, char **fullpath=nullptr);  Return true if 'name' is a file that can be found in the ROOT include path or the current directory. ;  ; virtual Bool_t IsPathLocal (const char *path);  Returns TRUE if the url in 'path' points to the local file system. ;  ; virtual int Link (const char *from, const char *to);  Create a link from file1 to file2. ;  ; virtual void ListLibraries (const char *regexp="""");  List the loaded shared libraries. ;  ; virtual void ListSymbols (const char *module, const char *re="""");  List symbols in a shared library. ;  ; virtual int Load (const char *module, const char *entry="""", Bool_t system=kFALSE);  Load a shared library. ;  ; virtual UInt_t LoadAllLibraries ();  Load all libraries known to ROOT via the rootmap system. ;  ; virtual int mkdir (const char *name, Bool_t recursive=kFALSE);  Make a file system directory. ;  ; virtual Long_t NextTimeOut (Bool_t mode);  Time when next timer of mode (synchronous=kTRUE or asynchronous=kFALSE) will time-out (in ms). ;  ; virtual void NotifyApplicationCreated ();  Hook to tell TSystem that the TApplication object has been created. ;  ; virtual TTime Now ();  Get current time in milliseconds since 0:00 Jan 1 1995. ;  ; virtual int OpenConnection (const char *server, int port, int tcpwindowsize=-1, const char *protocol=""tcp"");  Open a connection to another host. ;  ; virtual void Openlog (const char *name, Int_t options, ELogFacility facility);  Open connection to system log daemon. ;  ; virtual FILE * OpenPipe (const char *command, const char *mode);  Open a pipe. ;  ; virtual const char * PrependPathName (const char *dir, TString &name);  Concatenate a directory and a file name. ;  ; virtual Bool_t ProcessEvents",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebSystem.html:12433,Load,LoadAllLibraries,12433,doc/master/classTWebSystem.html,https://root.cern,https://root.cern/doc/master/classTWebSystem.html,2,['Load'],"['Load', 'LoadAllLibraries']"
Performance," ; Bool_t fIsGeomReading;  ; Bool_t fIsNodeSelectable;  switch ON/OFF volume activity (default OFF - all volumes active)) ;  ; Int_t * fKeyPNEId;  ; Bool_t fLoopVolumes;  flag that geometry is closed ;  ; TGeoVolume * fMasterVolume;  top physical node ;  ; TList * fMaterials;  ; TObjArray * fMatrices;  current painter ;  ; Bool_t fMatrixReflection;  flag for using GL matrix ;  ; Bool_t fMatrixTransform;  flag that the list of physical nodes has to be drawn ;  ; Int_t fMaxThreads;  ; Int_t fMaxVisNodes;  ; TList * fMedia;  ; Bool_t fMultiThread;  Max number of threads. ;  ; NavigatorsMap_t fNavigators;  ; Int_t fNLevel;  table of elements ;  ; Int_t fNNodes;  upper time limit for tracks drawing ;  ; TObjArray * fNodes;  ; Int_t fNpdg;  current track ;  ; Int_t fNPNEId;  ; Int_t fNsegments;  ; Int_t fNtracks;  ; TObjArray * fOpticalSurfaces;  ; TObjArray * fOverlaps;  ; TVirtualGeoPainter * fPainter;  flag that nodes are the selected objects in pad rather than volumes ;  ; TGeoVolume * fPaintVolume;  ; TGeoParallelWorld * fParallelWorld;  ; TString fParticleName;  path to current node ;  ; TString fPath;  ; Int_t fPdgId [1024];  ; TObjArray * fPdgNames;  ; Bool_t fPhiCut;  flag to notify that the manager is being destructed ;  ; Double_t fPhimax;  lowest range for phi cut ;  ; Double_t fPhimin;  ; TObjArray * fPhysicalNodes;  ; ConstPropMap_t fProperties;  ; Int_t fRaytraceMode;  Flag for multi-threading. ;  ; TObjArray * fRegions;  ; TObjArray * fShapes;  ; Int_t fSizePNEId;  array of physical node entries ;  ; TObjArray * fSkinSurfaces;  ; Bool_t fStreamVoxels;  flag volume lists loop ;  ; Bool_t fTimeCut;  ; Double_t fTmax;  lower time limit for tracks drawing ;  ; Double_t fTmin;  highest range for phi cut ;  ; TGeoNode * fTopNode;  top level volume in geometry ;  ; TGeoVolume * fTopVolume;  current volume ;  ; TObjArray * fTracks;  list of runtime volumes ;  ; TObjArray * fUniqueVolumes;  ; Bool_t fUsePWNav;  Raytrace mode: 0=normal, 1=pass through, 2=transparent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:65745,multi-thread,multi-threading,65745,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['multi-thread'],['multi-threading']
Performance," ; Int_t CopyDataSet (const char *dset, const char *dsetdst, const char *destdir);  Copy the files of dataset 'dset' to 'destdir' and create a new dataset named 'dsetdst' decribing them. ;  ; Bool_t GetDebug ();  ; const char * GetOutFileName () const;  ; TClass * IsA () const override;  ; Int_t MakeDataSet (const char *dset=0, Long64_t nevt=-1, const char *fnroot=""event"", Bool_t regenerate=kFALSE);  Create the largest dataset for the run. ;  ; Int_t OpenOutFile (Bool_t wrt=kFALSE, Bool_t verbose=kTRUE);  Set the otuput file Return 0 on success, -1 on error. ;  ; Int_t ReleaseCache (const char *dset);  Release memory cache for dataset 'dset' Return 0 on success, -1 on error. ;  ; Int_t RemoveDataSet (const char *dset);  Physically remove the dataset 'dset', i.e. ;  ; Int_t RunCPU (Long64_t nevents=-1, Int_t start=-1, Int_t stop=-1, Int_t step=-1);  Perform the CPU run Return 0 on success, -1 on error. ;  ; Int_t RunCPUx (Long64_t nevents=-1, Int_t start=-1, Int_t stop=-1);  Perform the CPU run scanning over the number of workers per node Return 0 on success, -1 on error. ;  ; Int_t RunDataSet (const char *dset=""BenchDataSet"", Int_t start=1, Int_t stop=-1, Int_t step=1);  Perform a test using dataset 'dset' Return 0 on success, -1 on error Open the file for the results. ;  ; Int_t RunDataSetx (const char *dset=""BenchDataSet"", Int_t start=1, Int_t stop=-1);  Perform a test using dataset 'dset' scanning over the number of workers per node. ;  ; void SetCPUPar (const char *par);  ; void SetCPUSel (const char *sel);  ; void SetDataGenPar (const char *par);  ; void SetDataGenSel (const char *sel);  ; void SetDataPar (const char *par);  ; void SetDataSel (const char *sel);  ; void SetDebug (Bool_t debug=kTRUE);  ; void SetHistType (TPBHistType *histtype);  ; void SetNFilesWrk (Int_t nf=0);  ; void SetNHist (Int_t nh);  ; void SetNTries (Int_t nt);  ; Int_t SetOutFile (const char *outfile, Bool_t verbose=kTRUE);  Set the output file Return 0 on success, -1 on error. ;  ; voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofBench.html:1733,Perform,Perform,1733,doc/master/classTProofBench.html,https://root.cern,https://root.cern/doc/master/classTProofBench.html,1,['Perform'],['Perform']
Performance," ; Int_t GetIndex (const TGeoNode *node) const;  get index number for a given daughter ;  ; TGeoMaterial * GetMaterial () const;  ; TGeoMedium * GetMedium () const;  ; Int_t GetNdaughters () const;  ; TGeoNode * GetNode (const char *name) const;  get the pointer to a daughter node ;  ; TGeoNode * GetNode (Int_t i) const;  ; Int_t GetNodeIndex (const TGeoNode *node, Int_t *check_list, Int_t ncheck) const;  Get the index of a daughter within check_list by providing the node pointer. ;  ; TObjArray * GetNodes ();  ; Int_t GetNtotal () const;  ; Int_t GetNumber () const;  ; char * GetObjectInfo (Int_t px, Int_t py) const override;  Get volume info for the browser. ;  ; Bool_t GetOptimalVoxels () const;  Returns true if cylindrical voxelization is optimal. ;  ; Option_t * GetOption () const override;  ; const char * GetPointerName () const;  Provide a pointer name containing uid. ;  ; Int_t GetRefCount () const;  ; TGeoShape * GetShape () const;  ; Char_t GetTransparency () const;  ; TGeoExtension * GetUserExtension () const;  ; TGeoVoxelFinder * GetVoxels () const;  Getter for optimization structure. ;  ; void Grab ();  ; void GrabFocus ();  Move perspective view focus to this volume. ;  ; TGeoExtension * GrabFWExtension () const;  Get a copy of the framework extension pointer. ;  ; TGeoExtension * GrabUserExtension () const;  Get a copy of the user extension pointer. ;  ; void Gsord (Int_t);  ; void InspectMaterial () const;  Inspect the material for this volume. ;  ; void InspectShape () const;  ; void InvisibleAll (Bool_t flag=kTRUE);  Make volume and each of it daughters (in)visible. ;  ; Bool_t IsActive () const;  ; Bool_t IsActiveDaughters () const;  ; Bool_t IsAdded () const;  ; Bool_t IsAllInvisible () const;  Return TRUE if volume and all daughters are invisible. ;  ; Bool_t IsCylVoxels () const;  ; Bool_t IsFolder () const override;  Return TRUE if volume contains nodes. ;  ; Bool_t IsOverlappingCandidate () const;  ; Bool_t IsRaytracing () const;  Check if th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolumeAssembly.html:6660,optimiz,optimization,6660,doc/master/classTGeoVolumeAssembly.html,https://root.cern,https://root.cern/doc/master/classTGeoVolumeAssembly.html,1,['optimiz'],['optimization']
Performance, ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGraphDelaunay::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 100 of file TGraphDelaunay.h. Member Data Documentation. ◆ fAllTri. Bool_t TGraphDelaunay::fAllTri. protected . ! True if FindAllTriangles() has been performed on fGraph2D ; Definition at line 64 of file TGraphDelaunay.h. ◆ fDist. Double_t* TGraphDelaunay::fDist. protected . ! Array used to order mass points by distance ; Definition at line 56 of file TGraphDelaunay.h. ◆ fGraph2D. TGraph2D* TGraphDelaunay::fGraph2D. protected . ! 2D graph containing the user data ; Definition at line 66 of file TGraphDelaunay.h. ◆ fHullPoints. Int_t* TGraphDelaunay::fHullPoints. protected . ! Hull points of size fNhull ; Definition at line 62 of file TGraphDelaunay.h. ◆ fInit. Bool_t TGraphDelaunay::fInit. protected . ! True if CreateTrianglesDataStructure() and FindHull() have been performed ; Definition at line 65 of file TGraphDelaunay.h. ◆ fMaxIter. Int_t TGraphDelaunay::fMaxIter. protected . ! Maximum number of iterations to find Delaunay triangles ; Definition at line 57 of file TGraphDelaunay.h. ◆ fMTried. Int_t* TGraphDelaunay::fMTried. protected . ! ; Definition at line 61 of file TGraphDelaunay.h. ◆ fNdt. Int_t TGraphDelaunay::fNdt. protected . ! Number of Delaunay triangles found ; Definition at line 39 of file TGraphDelaunay.h. ◆ fNhull. Int_t TGraphDelaunay::fNhull. protected . ! Number of points in the hull ; Definition at line 41 of file TGraphDelaunay.h. ◆ fNpoints. Int_t TGraphDelaunay::fNpoints. protected . ! Number of data points in fGraph2D ; Definition at line 40 of file TGraphDelaunay.h. ◆ fNTried. Int_t* TGraphDelaunay::fNTried. protected . ! Delaunay triangles storage of size fNdt ; Definition at line 60 of file TGraphDelaunay.h. ◆ fOrder. Int_t* TGraphDelaunay::fOrder. protected . ! Array used to order mass points by distance ; Defini,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphDelaunay.html:23722,perform,performed,23722,doc/master/classTGraphDelaunay.html,https://root.cern,https://root.cern/doc/master/classTGraphDelaunay.html,1,['perform'],['performed']
Performance," ; RooAbsData * _data = nullptr;  ; RooRealProxy _nll;  Input -log(L) function. ;  ; std::map< std::string, bool > _paramFixed;  Parameter constant status at last time of use. ;  ; RooAbsPdf * _pdf = nullptr;  ; std::set< std::string > _statUncertParams;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1RooBarlowBeestonLL.html:56232,Cache,Cache,56232,doc/master/classRooStats_1_1HistFactory_1_1RooBarlowBeestonLL.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1RooBarlowBeestonLL.html,1,['Cache'],['Cache']
Performance," ; RooRealProxy _mean;  Mean (if calculated for central moment) ;  ; RooSetProxy _nset;  Normalization set (optional) ;  ; Int_t _order = 1;  Moment order. ;  ; Int_t _takeRoot = false;  Return n-order root of moment. ;  ; RooRealProxy _x;  Observable. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFirstMoment.html:56432,Cache,Cache,56432,doc/master/classRooFirstMoment.html,https://root.cern,https://root.cern/doc/master/classRooFirstMoment.html,4,['Cache'],['Cache']
Performance," ; bool IsChain () const;  ; bool IsInvalid () const;  ; bool Notify () override;  Notify director and values of a change in tree. ;  ; void SetTree (const char *keyname, TDirectory *dir, TEntryList *entryList=nullptr);  Set (or update) the which tree to read from, passing the name of a tree in a directory. ;  ; void SetTree (const char *keyname, TEntryList *entryList=nullptr);  ; void SetTree (TTree *tree, TEntryList *entryList=nullptr);  Set (or update) the which tree to read from. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Entry setters; bool Next ();  Move to the next entry (or index of the TEntryList if that is set). ;  ; EEntryStatus SetEntry (Long64_t entry);  Set the next entry (or index of the TEntryList if that is set). ;  ; EEntryStatus SetLocalEntry (Long64_t entry);  Set the next local tree entry. ;  ; EEntryStatus SetEntriesRange (Long64_t beginEntry, Long64_t endEntry);  Set the range of entries to be loaded by Next(); end will not be loaded. ;  ; std::pair< Long64_t, Long64_t > GetEntriesRange () const;  Get the begin and end entry numbers. ;  ; void Restart ();  Restart a Next() loop from entry 0 (of TEntryList index 0 of fEntryList is set). ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReader.html:10035,load,loaded,10035,doc/master/classTTreeReader.html,https://root.cern,https://root.cern/doc/master/classTTreeReader.html,2,['load'],['loaded']
Performance," ; bool _splitRange = false;  Split rangeName in RooSimultaneous index labels if true. ;  ; const bool _takeGlobalObservablesFromData = false;  If the global observable values are taken from data. ;  ; bool _verbose = false;  Verbose messaging if true. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:63761,Cache,Cache,63761,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['Cache'],['Cache']
Performance," ; distribution = nullptr, . const char * ; axisSteering = nullptr, . TGraph ** ; lCurvePlot = nullptr, . TSpline ** ; logTauXPlot = nullptr, . TSpline ** ; logTauYPlot = nullptr . ). virtual . scan a function wrt tau and determine the minimum ; Parameters. [in]nPointnumber of points to be scanned ; [in]tauMinsmallest tau value to study ; [in]tauMaxlargest tau value to study ; [out]scanResultthe scanned function wrt log(tau) ; [in]mode1st parameter for the scan function ; [in]distribution2nd parameter for the scan function ; [in]projectionMode3rd parameter for the scan function ; [out]lCurvePlotfor monitoring, shows the L-curve ; [out]logTauXPlotfor monitoring, L-curve(X) as a function of log(tau) ; [out]logTauYPlotfor monitoring, L-curve(Y) as a function of log(tau). Return value: the coordinate number on the curve scanResult which corresponds to the minimum ; The function is scanned by repeating the following steps nPoint times . Choose a value of tau . Perform the unfolding for this choice of tau, DoUnfold(tau) . Determinethe scan variable GetScanVariable() . The method GetScanVariable() defines scans of correlation coefficients, where mode is chosen from the enum EScanTauMode. In addition one may set distribution and/or projectionMode to refine the calculation of correlations (e.g. restrict the calcuation to the signal distribution and/or exclude underflow and overflow bins). See the documentation of GetScanVariable() for details. Alternative scan variables may be defined by overriding the GetScanVariable() method. ; Automatic choice of scan range: if (tauMin,tauMax) do not correspond to a valid tau range (e.g. tauMin=tauMax=0.0) then the tau range is determined automatically. Use with care! ; Definition at line 1354 of file TUnfoldDensity.cxx. ◆ Streamer(). void TUnfoldDensity::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TUnfold. ◆ StreamerNVirtual(). void TUnfoldDensity::StreamerNVirtual ; (; TBuff",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldDensity.html:69531,Perform,Perform,69531,doc/master/classTUnfoldDensity.html,https://root.cern,https://root.cern/doc/master/classTUnfoldDensity.html,1,['Perform'],['Perform']
Performance," ; epsabs, . Double_t & ; relerr, . Int_t & ; nfnevl, . Int_t & ; ifail . ). virtual . This function computes, to an attempted specified accuracy, the value of the integral. ; Parameters. [in]nNumber of dimensions [2,15] ; [in]a,bOne-dimensional arrays of length >= N . On entry A[i], and B[i], contain the lower and upper limits of integration, respectively. ; [in]maxptsMaximum number of function evaluations to be allowed. maxpts >= 2^n +2*n*(n+1) +1 if maxpts<minpts, maxpts is set to 10*minpts ; [in]epsrelSpecified relative accuracy. ; [in]epsabsSpecified absolute accuracy. The integration algorithm will attempt to reach either the relative or the absolute accuracy. In case the maximum function called is reached the algorithm will stop earlier without having reached the desired accuracy; [out]relerrContains, on exit, an estimation of the relative accuracy of the result. ; [out]nfnevlnumber of function evaluations performed. ; [out]ifail0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the specified value of maxpts.; 3 n<2 or n>15 . Method:; The default method used is the Genz-Mallik adaptive multidimensional algorithm using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator() to different integrators. Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class Possible methods are : Vegas, Miser or Plain IN case of MC integration the accuracy is determined by the number of function calls, one should be careful not to use a too large value of maxpts ; Definition at line 2851 of file TF1.cxx. ◆ IntegralMultiple() [3/3]. virtual Double_t TF1::IntegralMultiple ; (; Int_t ; n, . const Double_t * ; a, . const Double_t * ; b, . Int_t ; , . Int_t ; maxpts,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:100153,perform,performed,100153,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['perform'],['performed']
Performance," ; mangled_name). Autoload a library based on a missing symbol. ; Definition at line 6591 of file TCling.cxx. ◆ LibraryLoaded(). void TCling::LibraryLoaded ; (; const void * ; dyLibHandle, . const char * ; canonicalName . ). Definition at line 6974 of file TCling.cxx. ◆ LibraryLoadingFailed(). bool TCling::LibraryLoadingFailed ; (; const std::string & ; errmessage, . const std::string & ; libStem, . bool ; permanent, . bool ; resolved . ). Definition at line 6568 of file TCling.cxx. ◆ LibraryUnloaded(). void TCling::LibraryUnloaded ; (; const void * ; dyLibHandle, . const char * ; canonicalName . ). Definition at line 6981 of file TCling.cxx. ◆ Load(). Int_t TCling::Load ; (; const char * ; filename, . Bool_t ; system = kFALSE . ). finalvirtual . Load a library file in cling's memory. ; if 'system' is true, the library is never unloaded. Return 0 on success, -1 on failure. ; Implements TInterpreter.; Definition at line 3515 of file TCling.cxx. ◆ LoadEnums(). void TCling::LoadEnums ; (; TListOfEnums & ; cl); const. finalvirtual . Create list of pointers to enums for TClass cl. ; Implements TInterpreter.; Definition at line 4395 of file TCling.cxx. ◆ LoadFile(). int TCling::LoadFile ; (; const char * ; path); const. finalvirtual . Load a source file or library called path into the interpreter. ; Reimplemented from TInterpreter.; Definition at line 7500 of file TCling.cxx. ◆ LoadFunctionTemplates(). void TCling::LoadFunctionTemplates ; (; TClass * ; cl); const. finalvirtual . Create list of pointers to function templates for TClass cl. ; Implements TInterpreter.; Definition at line 4442 of file TCling.cxx. ◆ LoadLibraryMap(). Int_t TCling::LoadLibraryMap ; (; const char * ; rootmapfile = nullptr). finalvirtual . Load map between class and library. ; If rootmapfile is specified a specific rootmap file can be added (typically used by ACLiC). In case of error -1 is returned, 0 otherwise. The interpreter uses this information to automatically load the shared library for a c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:112934,Load,LoadEnums,112934,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['Load'],['LoadEnums']
Performance," ; nbinsx, . const Double_t * ; xbins, . Int_t ; nbinsy, . const Double_t * ; ybins, . Option_t * ; option = """" . ). Create a 2-D Profile with variable bins in X and variable bins in Y. ; Definition at line 153 of file TProfile2D.cxx. ◆ TProfile2D() [7/7]. TProfile2D::TProfile2D ; (; const TProfile2D & ; profile). Copy constructor. ; Definition at line 206 of file TProfile2D.cxx. ◆ ~TProfile2D(). TProfile2D::~TProfile2D ; (; ). override . Default destructor for Profile2D histograms. ; Definition at line 98 of file TProfile2D.cxx. Member Function Documentation. ◆ Add() [1/3]. Bool_t TProfile2D::Add ; (; const TH1 * ; h1, . const TH1 * ; h2, . Double_t ; c1 = 1, . Double_t ; c2 = 1 . ). overridevirtual . Replace contents of this profile2D by the addition of h1 and h2. ; this = c1*h1 + c2*h2 ; Reimplemented from TH1.; Definition at line 249 of file TProfile2D.cxx. ◆ Add() [2/3]. Bool_t TProfile2D::Add ; (; const TH1 * ; h1, . Double_t ; c1 = 1 . ). overridevirtual . Performs the operation: this = this + c1*h1 . ; Reimplemented from TH1.; Definition at line 230 of file TProfile2D.cxx. ◆ Add() [3/3]. Bool_t TProfile2D::Add ; (; TF1 * ; h1, . Double_t ; c1 = 1, . Option_t * ; option = """" . ). overridevirtual . Performs the operation: this = this + c1*f1 . ; Reimplemented from TH1.; Definition at line 221 of file TProfile2D.cxx. ◆ Approximate(). void TProfile2D::Approximate ; (; Bool_t ; approx = kTRUE). static . Static function, set the fgApproximate flag. ; When the flag is true, the function GetBinError will approximate the bin error with the average profile error on all bins in the following situation only; the number of bins in the profile2D is less than 10404 (eg 100x100); the bin number of entries is small ( <5); the estimated bin error is extremely small compared to the bin content (see TProfile2D::GetBinError) . Definition at line 277 of file TProfile2D.cxx. ◆ BufferEmpty(). Int_t TProfile2D::BufferEmpty ; (; Int_t ; action = 0). overridevirtual . Fill histogram w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile2D.html:71136,Perform,Performs,71136,doc/master/classTProfile2D.html,https://root.cern,https://root.cern/doc/master/classTProfile2D.html,1,['Perform'],['Performs']
Performance," ; nentries, . const char * ; opt, . TList * ; inl, . Long64_t ; first, . TDSet * ; dset, . const char * ; selec, . TObject * ; elist . ). private . Create a TProofQueryResult instance for this query. ; Definition at line 3530 of file TProofServ.cxx. ◆ NextQuery(). TProofQueryResult * TProofServ::NextQuery ; (; ). private . Get the next query from the waiting list. ; The query is removed from the list. ; Definition at line 6867 of file TProofServ.cxx. ◆ OldAuthSetup(). Int_t TProofServ::OldAuthSetup ; (; TString & ; conf). private . Setup authentication related stuff for old versions. ; Provided for backward compatibility. ; Definition at line 3492 of file TProofServ.cxx. ◆ Print(). void TProofServ::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print status of slave server. ; Reimplemented from TObject.; Definition at line 2506 of file TProofServ.cxx. ◆ ProcessNext(). void TProofServ::ProcessNext ; (; TString * ; slb = 0). protectedvirtual . process the next query from the queue of submitted jobs. ; to be called on the top master only. ; Definition at line 4416 of file TProofServ.cxx. ◆ QueueQuery(). Int_t TProofServ::QueueQuery ; (; TProofQueryResult * ; pq). private . Add a query to the waiting list Returns the number of queries in the list. ; Definition at line 6856 of file TProofServ.cxx. ◆ ReceiveFile(). Int_t TProofServ::ReceiveFile ; (; const char * ; file, . Bool_t ; bin, . Long64_t ; size . ). Receive a file, either sent by a client or a master server. ; If bin is true it is a binary file, other wise it is an ASCII file and we need to check for Windows \r tokens. Returns -1 in case of error, 0 otherwise. ; Definition at line 2578 of file TProofServ.cxx. ◆ RedirectOutput(). void TProofServ::RedirectOutput ; (; const char * ; dir = 0, . const char * ; mode = ""w"" . ). private . Redirect stdout to a log file. ; This log file will be flushed to the client or master after each command. ; Definition at line 2518 of file TProofServ.cxx. ◆ RegisterDa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:50359,queue,queue,50359,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,1,['queue'],['queue']
Performance," ; params = nullptr, . Int_t * ; error = nullptr . ). virtual . Execute this macro with params, if params is 0, default parameters (set via SetParams) are used. ; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine(). Returns the result of the macro (return value or value of the last expression), cast to a Long_t. ; Reimplemented in TEveMacro.; Definition at line 262 of file TMacro.cxx. ◆ GetLineWith(). TObjString * TMacro::GetLineWith ; (; const char * ; text); const. virtual . Search the first line containing text. ; Definition at line 297 of file TMacro.cxx. ◆ GetListOfLines(). TList * TMacro::GetListOfLines ; (; ); const. inline . Definition at line 51 of file TMacro.h. ◆ IsA(). TClass * TMacro::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 59 of file TMacro.h. ◆ Load(). Bool_t TMacro::Load ; (; ); const. virtual . Load the macro into the interpreter. ; Return true in case the loading was successful. ; Definition at line 244 of file TMacro.cxx. ◆ operator=(). TMacro & TMacro::operator= ; (; const TMacro & ; macro). Copy constructor. ; Definition at line 120 of file TMacro.cxx. ◆ Paint(). void TMacro::Paint ; (; Option_t * ; option = """"). overridevirtual . Execute this macro (called by TPad::Paint). ; Reimplemented from TObject.; Definition at line 311 of file TMacro.cxx. ◆ Print(). void TMacro::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print contents of this macro. ; Reimplemented from TObject.; Definition at line 319 of file TMacro.cxx. ◆ ReadFile(). Int_t TMacro::ReadFile ; (; const char * ; filename). virtual . Read lines in filename in this macro. ; Definition at line 329 of file TMacro.cxx. ◆ SavePrimitive(). void TMacro::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save macro source on stream out. ; Reimplemented from TObject.; Definition at line 382 of file TMacro.cxx. ◆ SaveSource()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacro.html:18536,load,loading,18536,doc/master/classTMacro.html,https://root.cern,https://root.cern/doc/master/classTMacro.html,1,['load'],['loading']
Performance," ; static Bool_t Connect (const char *sender_class, const char *signal, const char *receiver_class, void *receiver, const char *slot);  This method allows to make a connection from any object of the same class to a single slot. ;  ; static Bool_t Connect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; Bool_t HandleTimer (TTimer *timer) override;  Send feedback objects to client. ;  ; Int_t MakeSelector (const char *selfile);  Create the selector object and save the relevant files and binary information in the cache so that the worker can pick it up. ;  ; void SetupFeedback () override;  Setup reporting of feedback objects. ;  ;  Protected Member Functions inherited from TProofPlayerRemote; TProof * GetProof () const;  ; Bool_t HandleTimer (TTimer *timer) override;  Send feedback objects to client. ;  ; Int_t InitPacketizer (TDSet *dset, Long64_t nentries, Long64_t first, const char *defpackunit, const char *defpackdata);  Init the packetizer Return 0 on success (fPacketizer is correctly initialized), -1 on failure. ;  ; TList * MergeFeedback ();  Merge feedback lists. ;  ; Bool_t MergeOutputFiles ();  Merge output in files. ;  ; void NotifyMemory (TObject *obj);  Printout the memory record after merging object 'obj' This record is used by the memory monitor. ;  ; virtual Bool_t SendSelector (const char *selector_file);  Send the selector file(s) to master or worker nodes. ;  ; void SetLastMergingMsg (TObject *obj);  Set the message to be notifi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:20843,cache,cache,20843,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,1,['cache'],['cache']
Performance," ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Width_t GetMarkerLineWidth (Style_t style);  Internal helper function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  . Protected Member Functions; Double_t ** Allocate (Int_t size) override;  Allocate internal data structures for size points. ;  ; void CopyAndRelease (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy and release. ;  ; Bool_t CopyPoints (Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy errors from fE*** to arrays[***] or to f*** Copy points. ;  ; Bool_t CtorAllocate ();  Should be called from ctors after fNpoints has been set. ;  ; Bool_t DoMerge (const TGraph *g) override;  Protected function to perform the merge operation of a graph with asymmetric errors. ;  ; void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) override;  Set zero values for point arrays in the range [begin, end] ;  ; void SwapPoints (Int_t pos1, Int_t pos2) override;  Swap points. ;  ; void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) override;  Update the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values. ;  ;  Protected Member Functions inherited from TGraph; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void Sa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphAsymmErrors.html:31452,perform,perform,31452,doc/master/classTGraphAsymmErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphAsymmErrors.html,1,['perform'],['perform']
Performance," ; static const char * DeclFileName ();  ; static Int_t GetErrno ();  Static function returning system error number. ;  ; static void ResetErrno ();  Static function resetting system error number. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; const char * GetLinkedLibraries () override;  Get list of shared libraries loaded at the start of the executable. ;  ;  Protected Member Functions inherited from TSystem; virtual Bool_t ConsistentWith (const char *path, void *dirptr=nullptr);  Check consistency of this helper with the one required by 'path' or 'dirptr'. ;  ; virtual void DoBeep (Int_t=-1, Int_t=-1) const;  ; virtual const char * ExpandFileName (const char *fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; virtual Bool_t ExpandFileName (TString &fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; TSystem * FindHelper (const char *path, void *dirptr=nullptr);  Create helper TSystem to handle file and directory operations that might be special for remote file access. ;  ; TString & GetLastErrorString ();  Return the thread local storage for the custom last error message. ;  ; const TString & GetLastErrorString () const;  Return the thread local storage for the custom last error message. ;  ;  Protected Mem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:30428,load,loaded,30428,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['load'],['loaded']
Performance," ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; TFile * fFile;  currently open file fCurrent points to the currently open list ;  ; TObjArray * fFileNames;  ! points to the fFiles data member of the corresponding chain ;  ; TString fListFileName;  from this string names of all files can be found ;  ; TString fListName;  name of the list ;  ; Long64_t * fListOffset;  [fNFiles] numbers of entries in ind. lists ;  ; Int_t fNFiles;  total number of files ;  ;  Protected Attributes inherited from TEntryList; TObjArray * fBlocks;  blocks with indices of passing events (TEntryListBlocks) ;  ; TEntryList * fCurrent;  ! currently filled entry list ;  ; TDirectory * fDirectory;  ! Pointer to directory holding this tree ;  ; Long64_t fEntriesToProcess;  used on proof to set the number of entries to process in a packet ;  ; TString fFileName;  name of the file, where the tree is ;  ; Long64_t fLastIndexQueried;  ! used to optimize GetEntry() function from a loop ;  ; Long64_t fLastIndexReturned;  ! used to optimize GetEntry() function from a loop ;  ; TList * fLists;  a list of underlying entry lists for each tree of a chain ;  ; Long64_t fN;  number of entries in the list ;  ; Int_t fNBlocks;  number of TEntryListBlocks ;  ; bool fReapply;  If true, TTree::Draw will 'reapply' the original cut. ;  ; bool fShift;  ! true when some sub-lists don't correspond to trees (when the entry list is used as input in TChain) ;  ; ULong_t fStringHash;  ! Hash value of a string of treename and filename ;  ; TString fTreeName;  name of the tree ;  ; Int_t fTreeNumber;  ! the index of the tree in the chain (used when the entry list is used as input (TTree::SetEntryList()) ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static constexpr auto kBigNumber = std::numeric_limits<Long64_t>:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryListFromFile.html:17169,optimiz,optimize,17169,doc/master/classTEntryListFromFile.html,https://root.cern,https://root.cern/doc/master/classTEntryListFromFile.html,2,['optimiz'],['optimize']
Performance," ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Static Public Attributes; static constexpr value_type NoCatIdx = std::numeric_limits<value_type>::min();  . Protected Member Functions; value_type evaluate () const override;  Evaluate the category state and return. ;  ; const RooMappedCategoryCache * getOrCreateCache () const;  ; void recomputeShape () override;  When the input category changes states, the cached state mappings are invalidated. ;  ;  Protected Member Functions inherited from RooAbsCategory; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach the category index and label as branches to the given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  Attach the category index and label to as branches to the given vector store. ;  ; void clearTypes ();  Delete all currently defined states. ;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValueDirty=true) override;  Copy the cached value from given source and raise dirty flag. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label);  Define a new state with given label. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label, value_type index);  Define new state with given name and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMappedCategory.html:35242,cache,cached,35242,doc/master/classRooMappedCategory.html,https://root.cern,https://root.cern/doc/master/classRooMappedCategory.html,1,['cache'],['cached']
Performance," ; static void printMetaArgs (RooArgList const &funcList, RooArgList const &coefList, std::ostream &os);  ; static void setCacheAndTrackHints (RooArgList const &funcList, RooArgSet &trackNodes);  ; static std::string translateImpl (RooFit::Detail::CodeSquashContext &ctx, RooAbsArg const *klass, RooArgList const &funcList, RooArgList const &coefList, bool normalize=false);  . Friends; class RooAddition;  ; class RooAddPdf;  ; class RooRealSumFunc;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; typedef std::map< constRooAbsArg *, std::pair< std::string, std::list< EvalError > > >::const_iterator EvalErrorIter;  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumPdf.html:68799,Cache,CacheMode,68799,doc/v632/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumPdf.html,1,['Cache'],['CacheMode']
Performance," ; std::map< TString, double > optimizerParams;  ; DNN::ERegularization regularization;  ; size_t testInterval;  ; Double_t weightDecay;  . #include <TMVA/MethodDL.h>; Member Data Documentation. ◆ batchSize. size_t TMVA::TTrainingSettings::batchSize. Definition at line 73 of file MethodDL.h. ◆ convergenceSteps. size_t TMVA::TTrainingSettings::convergenceSteps. Definition at line 75 of file MethodDL.h. ◆ dropoutProbabilities. std::vector<Double_t> TMVA::TTrainingSettings::dropoutProbabilities. Definition at line 83 of file MethodDL.h. ◆ learningRate. Double_t TMVA::TTrainingSettings::learningRate. Definition at line 80 of file MethodDL.h. ◆ maxEpochs. size_t TMVA::TTrainingSettings::maxEpochs. Definition at line 76 of file MethodDL.h. ◆ momentum. Double_t TMVA::TTrainingSettings::momentum. Definition at line 81 of file MethodDL.h. ◆ multithreading. bool TMVA::TTrainingSettings::multithreading. Definition at line 85 of file MethodDL.h. ◆ optimizer. DNN::EOptimizer TMVA::TTrainingSettings::optimizer. Definition at line 78 of file MethodDL.h. ◆ optimizerName. TString TMVA::TTrainingSettings::optimizerName. Definition at line 79 of file MethodDL.h. ◆ optimizerParams. std::map<TString,double> TMVA::TTrainingSettings::optimizerParams. Definition at line 84 of file MethodDL.h. ◆ regularization. DNN::ERegularization TMVA::TTrainingSettings::regularization. Definition at line 77 of file MethodDL.h. ◆ testInterval. size_t TMVA::TTrainingSettings::testInterval. Definition at line 74 of file MethodDL.h. ◆ weightDecay. Double_t TMVA::TTrainingSettings::weightDecay. Definition at line 82 of file MethodDL.h. Collaboration diagram for TMVA::TTrainingSettings:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; tmva/tmva/inc/TMVA/MethodDL.h. TMVATTrainingSettings. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:44 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html:1670,optimiz,optimizerName,1670,doc/master/structTMVA_1_1TTrainingSettings.html,https://root.cern,https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html,4,['optimiz'],"['optimizerName', 'optimizerParams']"
Performance," ; using RVecC = ROOT::VecOps::RVec< char >;  ; using RVecD = ROOT::VecOps::RVec< double >;  ; using RVecF = ROOT::VecOps::RVec< float >;  ; using RVecI = ROOT::VecOps::RVec< int >;  ; using RVecL = ROOT::VecOps::RVec< long int >;  ; using RVecLL = ROOT::VecOps::RVec< long long int >;  ; using RVecU = ROOT::VecOps::RVec< unsigned int >;  ; using RVecUL = ROOT::VecOps::RVec< unsigned long int >;  ; using RVecULL = ROOT::VecOps::RVec< unsigned long long int >;  ; typedef std::map< std::string, std::list< SchemaRuleMap_t > > SchemaRuleClassMap_t;  ; typedef std::map< std::string, std::string > SchemaRuleMap_t;  ; typedef std::list< std::pair< ROOT::Internal::TSchemaType, std::string > > SourceTypeList_t;  ; using TDataFrame = ROOT::RDataFrame;  ; using TSeqI = TSeq< int >;  ; using TSeqL = TSeq< long >;  ; using TSeqU = TSeq< unsigned int >;  ; using TSeqUL = TSeq< unsigned long >;  ; using UInt32_v = UInt_t;  ; using UInt_v = UInt_t;  ; using WebWindowConnectCallback_t = std::function< void(unsigned)>;  function signature for connect/disconnect call-backs argument is connection id ;  ; using WebWindowDataCallback_t = std::function< void(unsigned, const std::string &)>;  function signature for call-backs from the window clients first argument is connection id, second is received data ;  ; using WebWindowDeleteCallback_t = std::function< void(RWebWindow &)>;  function signature for callback when RWebWindow destroyed ;  ; using WebWindowShowCallback_t = std::function< bool(RWebWindow &, const RWebDisplayArgs &)>;  function signature for catching show calls of arbitrary RWebWindow if returns true, normal show procedure will not be invoked ;  ; using WebWindowWaitFunc_t = std::function< int(double)>;  function signature for waiting call-backs Such callback used when calling thread need to waits for some special data, but wants to run application event loop As argument, spent time in second will be provided Waiting will be performed until function returns non-zero value ;  .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:10655,perform,performed,10655,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,1,['perform'],['performed']
Performance," ; virtual void SetEstimate (Long64_t nentries=1000000);  Set number of entries to estimate variable limits. ;  ; virtual void SetEventList (TEventList *list);  This function transfroms the given TEventList into a TEntryList The new TEntryList is owned by the TTree and gets deleted when the tree is deleted. ;  ; virtual void SetFileNumber (Int_t number=0);  Set fFileNumber to number. ;  ; virtual void SetImplicitMT (bool enabled);  ; ROOT::TIOFeatures SetIOFeatures (const ROOT::TIOFeatures &);  Provide the end-user with the ability to enable/disable various experimental IO features for this TTree. ;  ; virtual void SetMakeClass (Int_t make);  Set all the branches in this TTree to be in decomposed object mode (also known as MakeClass mode). ;  ; virtual void SetMaxEntryLoop (Long64_t maxev=kMaxEntries);  ; virtual void SetMaxVirtualSize (Long64_t size=0);  ; void SetName (const char *name) override;  Change the name of this tree. ;  ; virtual void SetNotify (TObject *obj);  Sets the address of the object to be notified when the tree is loaded. ;  ; virtual void SetObject (const char *name, const char *title);  Change the name and title of this tree. ;  ; virtual void SetParallelUnzip (bool opt=true, Float_t RelSize=-1);  Enable or disable parallel unzipping of Tree buffers. ;  ; virtual void SetPerfStats (TVirtualPerfStats *perf);  Set perf stats. ;  ; virtual void SetScanField (Int_t n=50);  ; void SetTargetMemoryRatio (Float_t ratio);  ; virtual void SetTimerInterval (Int_t msec=333);  ; virtual void SetTreeIndex (TVirtualIndex *index);  The current TreeIndex is replaced by the new index. ;  ; virtual void SetUpdate (Int_t freq=0);  ; virtual void SetWeight (Double_t w=1, Option_t *option="""");  Set tree weight. ;  ; virtual void Show (Long64_t entry=-1, Int_t lenmax=20);  Print values of all active leaves for entry. ;  ; virtual void StartViewer ();  Start the TTreeViewer on this tree. ;  ; virtual Int_t StopCacheLearningPhase ();  Stop the cache learning phase. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:40705,load,loaded,40705,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['load'],['loaded']
Performance," ; virtual void SetEstimate (Long64_t nentries=1000000);  Set number of entries to estimate variable limits. ;  ; virtual void SetEventList (TEventList *list);  This function transfroms the given TEventList into a TEntryList The new TEntryList is owned by the TTree and gets deleted when the tree is deleted. ;  ; virtual void SetFileNumber (Int_t number=0);  Set fFileNumber to number. ;  ; virtual void SetImplicitMT (bool enabled);  ; ROOT::TIOFeatures SetIOFeatures (const ROOT::TIOFeatures &);  Provide the end-user with the ability to enable/disable various experimental IO features for this TTree. ;  ; virtual void SetMakeClass (Int_t make);  Set all the branches in this TTree to be in decomposed object mode (also known as MakeClass mode). ;  ; virtual void SetMaxEntryLoop (Long64_t maxev=kMaxEntries);  ; virtual void SetMaxVirtualSize (Long64_t size=0);  ; void SetName (const char *name) override;  Change the name of this tree. ;  ; virtual void SetNotify (TObject *obj);  Sets the address of the object to be notified when the tree is loaded. ;  ; virtual void SetObject (const char *name, const char *title);  Change the name and title of this tree. ;  ; virtual void SetParallelUnzip (bool opt=true, Float_t RelSize=-1);  Enable or disable parallel unzipping of Tree buffers. ;  ; virtual void SetPerfStats (TVirtualPerfStats *perf);  Set perf stats. ;  ; virtual void SetScanField (Int_t n=50);  Sets the default maximum number of lines to be shown before <CR> when calling Scan(). ;  ; void SetTargetMemoryRatio (Float_t ratio);  ; virtual void SetTimerInterval (Int_t msec=333);  ; virtual void SetTreeIndex (TVirtualIndex *index);  The current TreeIndex is replaced by the new index. ;  ; virtual void SetUpdate (Int_t freq=0);  ; virtual void SetWeight (Double_t w=1, Option_t *option="""");  Set tree weight. ;  ; virtual void Show (Long64_t entry=-1, Int_t lenmax=20);  Print values of all active leaves for entry. ;  ; virtual void StartViewer ();  Start the TTreeViewer on th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHbookTree.html:23219,load,loaded,23219,doc/master/classTHbookTree.html,https://root.cern,https://root.cern/doc/master/classTHbookTree.html,5,['load'],['loaded']
Performance," ; void DrawRectangleAux (Drawable_t wid, const GCValues_t &gcVals, Int_t x, Int_t y, UInt_t w, UInt_t h);  ; void DrawSegments (Drawable_t wid, GContext_t gc, Segment_t *segments, Int_t nSegments) override;  Draws multiple line segments. ;  ; void DrawSegmentsAux (Drawable_t wid, const GCValues_t &gcVals, const Segment_t *segments, Int_t nSegments);  ; void DrawString (Drawable_t wid, GContext_t gc, Int_t x, Int_t y, const char *s, Int_t len) override;  Each character image, as defined by the font in the GC, is treated as an additional mask for a fill operation on the drawable. ;  ; void DrawStringAux (Drawable_t wid, const GCValues_t &gc, Int_t x, Int_t y, const char *s, Int_t len);  ; Bool_t EmptyRegion (Region_t reg) override;  Returns kTRUE if the region reg is empty. ;  ; Bool_t EqualRegion (Region_t rega, Region_t regb) override;  Returns kTRUE if the two regions have the same offset, size, and shape. ;  ; Int_t EventsPending () override;  Returns the number of events that have been received from the X server but have not been removed from the event queue. ;  ; UInt_t ExecCommand (TGWin32Command *code) override;  Executes the command ""code"" coming from the other threads (Win32) ;  ; void FillPolygon (Window_t wid, GContext_t gc, Point_t *polygon, Int_t nPoints) override;  Fills the region closed by the specified path. ;  ; void FillPolygonAux (Window_t wid, const GCValues_t &gcVals, const Point_t *polygon, Int_t nPoints);  ; void FillRectangle (Drawable_t wid, GContext_t gc, Int_t x, Int_t y, UInt_t w, UInt_t h) override;  Fills the specified rectangle defined by [x,y] [x+w,y] [x+w,y+h] [x,y+h]. ;  ; void FillRectangleAux (Drawable_t wid, const GCValues_t &gcVals, Int_t x, Int_t y, UInt_t w, UInt_t h);  ; Window_t FindRWindow (Window_t win, Window_t dragwin, Window_t input, int x, int y, int maxd) override;  Recursively search in the children of Window for a Window which is at location x, y and is DND aware, with a maximum depth of maxd. ;  ; void FlushOpenGL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:9749,queue,queue,9749,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,2,['queue'],['queue']
Performance," ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Attributes; double eval_carry = 0;  ; std::shared_ptr< RooAbsL > likelihood_;  ; RooArgSet vars_obs_;  list of observables ;  ; RooSetProxy vars_proxy_;  sets up client-server connections ;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFit_1_1TestStatistics_1_1RooRealL.html:55498,Cache,CacheMode,55498,doc/master/classRooFit_1_1TestStatistics_1_1RooRealL.html,https://root.cern,https://root.cern/doc/master/classRooFit_1_1TestStatistics_1_1RooRealL.html,1,['Cache'],['CacheMode']
Performance," ;  R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependentOverlaps(const RooArgSet *depList;  ;  R__DEPRECATED (6, 36, ""Use checkObservables()."") inline bool checkDependents(const RooArgSet *nset) const;  ;  R__DEPRECATED (6, 36, ""Use recursiveCheckObservables()."") inline bool recursiveCheckDependents(const RooArgSet *nset) const;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <RooAbsArg.h>. Inheritance diagram for RooAbsArg:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ RefCountList_t. using RooAbsArg::RefCountList_t = RooSTLRefCountList<RooAbsArg>. Definition at line 81 of file RooAbsArg.h. ◆ RefCountListLegacyIterator_t. using RooAbsArg::RefCountListLegacyIterator_t = TIteratorToSTLInterface<RefCountList_t::Container_t>. Definition at line 82 of file RooAbsArg.h. Member Enumeration Documentation. ◆ CacheMode. enum RooAbsArg::CacheMode. EnumeratorAlways ; NotAdvised ; Never . Definition at line 361 of file RooAbsArg.h. ◆ ConstOpCode. enum RooAbsArg::ConstOpCode. EnumeratorActivate ; DeActivate ; ConfigChange ; ValueChange . Definition at line 360 of file RooAbsArg.h. ◆ OperMode. enum RooAbsArg::OperMode. EnumeratorAuto ; AClean ; ADirty . Definition at line 362 of file RooAbsArg.h. Constructor & Destructor Documentation. ◆ RooAbsArg() [1/3]. RooAbsArg::RooAbsArg ; (; ). Default constructor. ; Definition at line 114 of file RooAbsArg.cxx. ◆ ~RooAbsArg(). RooAbsArg::~RooAbsArg ; (; ). override . Destructor. ; Definition at line 163 of file RooAbsArg.cxx. ◆ RooAbsArg() [2/3]. RooAbsArg::RooAbsArg ; (; const char * ; name, . const char * ; title . ). Create an object with the specified name and descriptive title. ; The newly created object has no clients or servers and has its dirty flags set. ; Definition at line 121 of file RooAbsArg.cxx. ◆ RooAbsArg() [3/3]. RooAbsArg::RooAbsArg ; (; c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:41708,Cache,CacheMode,41708,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['Cache'],['CacheMode']
Performance," ;  TLinearFitter (TFormula *function, Option_t *opt=""D"");  This constructor uses a linear function. ;  ;  ~TLinearFitter () override;  Linear fitter cleanup. ;  ; virtual void Add (TLinearFitter *tlf);  Add another linear fitter to this linear fitter. ;  ; virtual void AddPoint (Double_t *x, Double_t y, Double_t e=1);  Adds 1 point to the fitter. ;  ; virtual void AddTempMatrices ();  ; virtual void AssignData (Int_t npoints, Int_t xncols, Double_t *x, Double_t *y, Double_t *e=nullptr);  This function is to use when you already have all the data in arrays and don't want to copy them into the fitter. ;  ; virtual void Chisquare ();  Calculates the chisquare. ;  ; Double_t Chisquare (Int_t, Double_t *) const override;  ; void Clear (Option_t *option="""") override;  Clears everything. Used in TH1::Fit and TGraph::Fit(). ;  ; virtual void ClearPoints ();  To be used when different sets of points are fitted with the same formula. ;  ; virtual Int_t Eval ();  Perform the fit and evaluate the parameters Returns 0 if the fit is ok, 1 if there are errors. ;  ; virtual Int_t EvalRobust (Double_t h=-1);  Finds the parameters of the fitted function in case data contains outliers. ;  ; Int_t ExecuteCommand (const char *command, Double_t *args, Int_t nargs) override;  To use in TGraph::Fit and TH1::Fit(). ;  ; void FixParameter (Int_t ipar) override;  Fixes paramter #ipar at its current value. ;  ; virtual void FixParameter (Int_t ipar, Double_t parvalue);  Fixes parameter #ipar at value parvalue. ;  ; virtual void GetAtbVector (TVectorD &v);  Get the Atb vector - a vector, used for internal computations. ;  ; virtual Double_t GetChisquare ();  Get the Chisquare. ;  ; void GetConfidenceIntervals (Int_t n, Int_t ndim, const Double_t *x, Double_t *ci, Double_t cl=0.95) override;  Computes point-by-point confidence intervals for the fitted function Parameters: n - number of points ndim - dimensions of points x - points, at which to compute the intervals, for ndim > 1 should be in or",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLinearFitter.html:9827,Perform,Perform,9827,doc/master/classTLinearFitter.html,https://root.cern,https://root.cern/doc/master/classTLinearFitter.html,1,['Perform'],['Perform']
Performance," CFunctionSplitInfoResult of splitting a function declaration into fReturnType fScopeName::fFunctionName<fFunctionTemplateArguments>(fFunctionParameters) ;  CTInterpreterLookupHelper;  CTSplitType;  ►Ntest;  Ctest;  NTGeoUnit;  NtimeSeriesFromCSV;  ►NTMathTMath ;  CLimits;  NTMatrixTCramerInv;  NTMatrixTSymCramerInv;  ►NTMVAAbstract ClassifierFactory template that handles arbitrary types ;  ►NDNN;  NBlas;  ►NCNN;  CTConvLayer;  CTConvParams;  CTMaxPoolLayerGeneric Max Pooling Layer class ;  ►NRNN;  CTBasicRNNLayer;  CBatchEncapsulates one mini-batch ;  CClassificationSettingsSettings for classificationused to distinguish between different function signatures ;  CLayerLayer defines the layout of a layer ;  CLayerDataLayerData holds the data of one layer ;  CMeanVariance;  CNetNeural net ;  CSettingsSettings for the training of the neural net ;  CSteepestSteepest Gradient Descent algorithm (SGD) ;  CTAdadeltaAdadelta Optimizer class ;  CTAdagradAdagrad Optimizer class ;  CTAdamAdam Optimizer class ;  CTBatchTBatch ;  CTBatchIteratorTBatchIterator ;  CTCpuThe TCpu architecture class ;  ►CTCpuBufferTCpuBuffer ;  CTDestructor;  CTCpuMatrixThe TCpuMatrix class ;  CTCudaThe TCuda architecture class ;  ►CTCudaDeviceBufferTCudaDeviceBuffer ;  CTDestructor;  CTCudaDeviceReferenceTCudaDeviceReference ;  ►CTCudaHostBufferTCudaHostBuffer ;  CTDestructor;  CTCudaMatrixTCudaMatrix Class ;  CTDataLoaderTDataLoader ;  CTDataLoader< AData, TReference< AReal > >;  CTDeepNetGeneric Deep Neural Network class ;  CTDenseLayerGeneric layer class ;  CTDeviceTDevice ;  CTDLGradientDescent;  CTGradientDescent;  CTLayerGeneric layer class ;  CTNetGeneric neural network class ;  CTReferenceThe reference architecture class ;  CTReshapeLayer;  CTRMSPropRMSProp Optimizer class ;  CTSGDStochastic Batch Gradient Descent Optimizer class ;  CTSharedLayerLayer class width shared weight and bias layers ;  CTTensorBatchTTensorBatch ;  CTTensorBatchIteratorTTensorBatchIterator ;  CTTensorDataLoaderTTensor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/namespaces.html:85170,Optimiz,Optimizer,85170,doc/v616/namespaces.html,https://root.cern,https://root.cern/doc/v616/namespaces.html,1,['Optimiz'],['Optimizer']
Performance," CMeanVariance;  CNetNeural net ;  CSettingsSettings for the training of the neural net ;  CSteepestSteepest Gradient Descent algorithm (SGD) ;  CTAdadeltaAdadelta Optimizer class ;  CTAdagradAdagrad Optimizer class ;  CTAdamAdam Optimizer class ;  CTBatchTBatch ;  CTBatchIteratorTBatchIterator ;  CTCpuThe TCpu architecture class ;  ►CTCpuBufferTCpuBuffer ;  CTDestructor;  CTCpuMatrixThe TCpuMatrix class ;  CTCudaThe TCuda architecture class ;  ►CTCudaDeviceBufferTCudaDeviceBuffer ;  CTDestructor;  CTCudaDeviceReferenceTCudaDeviceReference ;  ►CTCudaHostBufferTCudaHostBuffer ;  CTDestructor;  CTCudaMatrixTCudaMatrix Class ;  CTDataLoaderTDataLoader ;  CTDataLoader< AData, TReference< AReal > >;  CTDeepNetGeneric Deep Neural Network class ;  CTDenseLayerGeneric layer class ;  CTDeviceTDevice ;  CTDLGradientDescent;  CTGradientDescent;  CTLayerGeneric layer class ;  CTNetGeneric neural network class ;  CTReferenceThe reference architecture class ;  CTReshapeLayer;  CTRMSPropRMSProp Optimizer class ;  CTSGDStochastic Batch Gradient Descent Optimizer class ;  CTSharedLayerLayer class width shared weight and bias layers ;  CTTensorBatchTTensorBatch ;  CTTensorBatchIteratorTTensorBatchIterator ;  CTTensorDataLoaderTTensorDataLoader ;  CTTensorDataLoader< AData, TReference< AReal > >;  CVGeneralLayerGeneric General Layer class ;  CVOptimizerGeneric Optimizer class ;  ►NExperimental;  CClassification;  CClassificationResult;  ►NkNN;  CEvent;  CModulekNN;  CNodeThis file contains binary tree and global function template that searches tree for k-nearest neigbors ;  CAbsoluteDeviationLossFunctionAbsolute Deviation Loss Function ;  CAbsoluteDeviationLossFunctionBDTAbsolute Deviation BDT Loss Function ;  CAbsValue;  CBDTEventWrapper;  CBinarySearchTreeA simple Binary search tree including a volume search method ;  CBinarySearchTreeNodeNode for the BinarySearch or Decision Trees ;  CBinaryTreeBase class for BinarySearch and Decision Trees ;  CCCPrunerA helper class to prune a dec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:82051,Optimiz,Optimizer,82051,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['Optimiz'],['Optimizer']
Performance," CMeanVariance;  CNetNeural net ;  CSettingsSettings for the training of the neural net ;  CSteepestSteepest Gradient Descent algorithm (SGD) ;  CTAdadeltaAdadelta Optimizer class ;  CTAdagradAdagrad Optimizer class ;  CTAdamAdam Optimizer class ;  CTBatchTBatch ;  CTBatchIteratorTBatchIterator ;  CTCpuThe TCpu architecture class ;  ►CTCpuBufferTCpuBuffer ;  CTDestructor;  CTCpuMatrixThe TCpuMatrix class ;  CTCudaThe TCuda architecture class ;  ►CTCudaDeviceBufferTCudaDeviceBuffer ;  CTDestructor;  CTCudaDeviceReferenceTCudaDeviceReference ;  ►CTCudaHostBufferTCudaHostBuffer ;  CTDestructor;  CTCudaMatrixTCudaMatrix Class ;  CTDataLoaderTDataLoader ;  CTDataLoader< AData, TReference< AReal > >;  CTDeepNetGeneric Deep Neural Network class ;  CTDenseLayerGeneric layer class ;  CTDeviceTDevice ;  CTDLGradientDescent;  CTGradientDescent;  CTLayerGeneric layer class ;  CTNetGeneric neural network class ;  CTReferenceThe reference architecture class ;  CTReshapeLayer;  CTRMSPropRMSProp Optimizer class ;  CTSGDStochastic Batch Gradient Descent Optimizer class ;  CTSharedLayerLayer class width shared weight and bias layers ;  CTTensorBatchTTensorBatch ;  CTTensorBatchIteratorTTensorBatchIterator ;  CTTensorDataLoaderTTensorDataLoader ;  CTTensorDataLoader< AData, TReference< AReal > >;  CVGeneralLayerGeneric General Layer class ;  CVOptimizerGeneric Optimizer class ;  ►NExperimental;  CClassification;  CClassificationResult;  ►NkNN;  CEvent;  CModulekNN;  CNodeThis file contains binary tree and global function template that searches tree for k-nearest neigbors ;  NTMVAGlob;  CAbsoluteDeviationLossFunctionAbsolute Deviation Loss Function ;  CAbsoluteDeviationLossFunctionBDTAbsolute Deviation BDT Loss Function ;  CAbsValue;  CBDTEventWrapper;  CBinarySearchTreeA simple Binary search tree including a volume search method ;  CBinarySearchTreeNodeNode for the BinarySearch or Decision Trees ;  CBinaryTreeBase class for BinarySearch and Decision Trees ;  CCCPrunerA helper class to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/namespaces.html:85935,Optimiz,Optimizer,85935,doc/v616/namespaces.html,https://root.cern,https://root.cern/doc/v616/namespaces.html,1,['Optimiz'],['Optimizer']
Performance," Class(). static TClass * TBufferIO::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TBufferIO::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TBufferIO::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 120 of file TBufferIO.h. ◆ DeclFileName(). static const char * TBufferIO::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 120 of file TBufferIO.h. ◆ ForceWriteInfo(). void TBufferIO::ForceWriteInfo ; (; TVirtualStreamerInfo * ; info, . Bool_t ; force . ). overridevirtual . force writing the TStreamerInfo to the file ; Implements TBuffer.; Reimplemented in TMessage.; Definition at line 329 of file TBufferIO.cxx. ◆ ForceWriteInfoClones(). void TBufferIO::ForceWriteInfoClones ; (; TClonesArray * ; a). overridevirtual . Make sure TStreamerInfo is not optimized, otherwise it will not be possible to support schema evolution in read mode. ; In case the StreamerInfo has already been computed and optimized, one must disable the option BypassStreamer. ; Implements TBuffer.; Definition at line 341 of file TBufferIO.cxx. ◆ GetBufferDisplacement(). Int_t TBufferIO::GetBufferDisplacement ; (; ); const. inlineoverridevirtual . Implements TBuffer.; Definition at line 81 of file TBufferIO.h. ◆ GetGlobalReadParam(). Int_t TBufferIO::GetGlobalReadParam ; (; ). static . Get default read map size. ; Definition at line 572 of file TBufferIO.cxx. ◆ GetGlobalWriteParam(). Int_t TBufferIO::GetGlobalWriteParam ; (; ). static . Get default write map size. ; Definition at line 580 of file TBufferIO.cxx. ◆ GetLastProcessID(). TProcessID * TBufferIO::GetLastProcessID ; (; TRefTable * ; reftable); const. overridevirtual . Return the last TProcessID in the file. ; Implements TBuffer.; Definition at line 399 of file TBufferIO.cxx. ◆ GetMapCount(). Int_t TBufferIO::GetMapCount ; (; ); co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferIO.html:32497,optimiz,optimized,32497,doc/master/classTBufferIO.html,https://root.cern,https://root.cern/doc/master/classTBufferIO.html,1,['optimiz'],['optimized']
Performance," Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; double evaluate () const override;  Optimized implementation of createProfile for profile likelihoods. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1RooBarlowBeestonLL.html:48233,Optimiz,Optimized,48233,doc/master/classRooStats_1_1HistFactory_1_1RooBarlowBeestonLL.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1RooBarlowBeestonLL.html,1,['Optimiz'],['Optimized']
Performance," Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; void PreProcessEvent (Long64_t ent) override;  Actions to be done just before processing entry 'entry'. ;  ;  Protected Member Functions inherited from TEventIter; Int_t LoadDir ();  Load directory. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions; TTree * GetTrees (TDSetElement *elem);  Create a Tree for the main TDSetElement and for all the friends. ;  ; TTree * Load (TDSetElement *elem, Bool_t &localfile, const char *objname=0);  Load a tree from s TDSetElement. ;  . Private Attributes; Long64_t fCacheSize;  ; Bool_t fDontCacheFiles;  ; TList * fFileTrees;  ; TTree * fTree;  ; TTreeCache * fTreeCache;  ; Bool_t fTreeCacheIsLearning;  ; TString fTreeName;  ; Bool_t fUseParallelUnzip;  ; Bool_t fUseTreeCache;  . Additional Inherited Members;  Public Types inherited from TEventIter; enum  EIterType { kData = 15; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEventIterTree.html:10930,Load,Load,10930,doc/master/classTEventIterTree.html,https://root.cern,https://root.cern/doc/master/classTEventIterTree.html,2,['Load'],['Load']
Performance," Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; CacheElem * getCache (const RooArgSet *nset) const;  ; int idxmax (const double &m) const;  ; int idxmin (const double &m) const;  ; Int_t ij (const Int_t &i, const Int_t &j) const;  ; void initialize ();  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMomentMorphFunc.html:50489,cache,cached,50489,doc/master/classRooMomentMorphFunc.html,https://root.cern,https://root.cern/doc/master/classRooMomentMorphFunc.html,2,['cache'],"['cache', 'cached']"
Performance," Class_Version(). static constexpr Version_t TMVA::Factory::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 227 of file Factory.h. ◆ DeclFileName(). static const char * TMVA::Factory::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 227 of file Factory.h. ◆ DeleteAllMethods(). void TMVA::Factory::DeleteAllMethods ; (; void ; ). Delete methods. ; Definition at line 324 of file Factory.cxx. ◆ EvaluateAllMethods(). void TMVA::Factory::EvaluateAllMethods ; (; void ; ). Iterates over all MVAs that have been booked, and calls their evaluation methods. ; Definition at line 1376 of file Factory.cxx. ◆ EvaluateAllVariables(). void TMVA::Factory::EvaluateAllVariables ; (; DataLoader * ; loader, . TString ; options = """" . ). Iterates over all MVA input variables and evaluates them. ; Definition at line 1360 of file Factory.cxx. ◆ EvaluateImportance(). TH1F * TMVA::Factory::EvaluateImportance ; (; DataLoader * ; loader, . VIType ; vitype, . Types::EMVA ; theMethod, . TString ; methodTitle, . const char * ; theOption = """" . ). Evaluate Variable Importance. ; Definition at line 2217 of file Factory.cxx. ◆ EvaluateImportanceAll(). TH1F * TMVA::Factory::EvaluateImportanceAll ; (; DataLoader * ; loader, . Types::EMVA ; theMethod, . TString ; methodTitle, . const char * ; theOption = """" . ). private . Definition at line 2246 of file Factory.cxx. ◆ EvaluateImportanceRandom(). TH1F * TMVA::Factory::EvaluateImportanceRandom ; (; DataLoader * ; loader, . UInt_t ; nseeds, . Types::EMVA ; theMethod, . TString ; methodTitle, . const char * ; theOption = """" . ). private . Definition at line 2473 of file Factory.cxx. ◆ EvaluateImportanceShort(). TH1F * TMVA::Factory::EvaluateImportanceShort ; (; DataLoader * ; loader, . Types::EMVA ; theMethod, . TString ; methodTitle, . const char * ; theOption = """" . ). private . Definition at line 2358 of file Factory.cxx. ◆ GetImportance(). TH1F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory.html:24090,load,loader,24090,doc/master/classTMVA_1_1Factory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory.html,1,['load'],['loader']
Performance," Copy constructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Implements internal (analytical) integration capabilities. ;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  Force RooRealIntegral to offer all our actual observable for internal integration. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertises internal (analytical) integration capabilities. ;  ; RooDataHist * getCacheHist (const RooArgSet &nset) const;  ; RooDataHist * getCacheHist (const RooArgSet *nset=nullptr) const;  Return pointer to RooDataHist cache histogram for given choice of observables. ;  ; RooAbsPdf * getCachePdf (const RooArgSet &nset) const;  ; RooAbsPdf * getCachePdf (const RooArgSet *nset=nullptr) const;  Return pointer to RooHistPdf cache pdf for given choice of observables. ;  ; Int_t getInterpolationOrder () const;  ; double getValV (const RooArgSet *set=nullptr) const override;  Implementation of getVal() overriding default implementation of RooAbsPdf. ;  ; TClass * IsA () const override;  ; bool selfNormalized () const override;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void setInterpolationOrder (int order);  Change the interpolation order that is used in RooHistPdf cache representation smoothing the RooDataHist shapes. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedPdf.html:4297,cache,cache,4297,doc/master/classRooAbsCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedPdf.html,1,['cache'],['cache']
Performance," Copy constructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Implements internal (analytical) integration capabilities. ;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  Force RooRealIntegral to offer all our actual observable for internal integration. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertises internal (analytical) integration capabilities. ;  ; RooDataHist * getCacheHist (const RooArgSet &nset) const;  ; RooDataHist * getCacheHist (const RooArgSet *nset=nullptr) const;  Return pointer to RooDataHist cache histogram for given choice of observables. ;  ; RooAbsPdf * getCachePdf (const RooArgSet &nset) const;  ; RooAbsPdf * getCachePdf (const RooArgSet *nset=nullptr) const;  Return pointer to RooHistPdf cache pdf for given choice of observables. ;  ; Int_t getInterpolationOrder () const;  ; double getValV (const RooArgSet *set=nullptr) const override;  Implementation of getVal() overriding default implementation of RooAbsPdf. ;  ; bool selfNormalized () const override;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void setInterpolationOrder (int order);  Change the interpolation order that is used in RooHistPdf cache representation smoothing the RooDataHist shapes. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedPdf.html:2660,cache,cache,2660,doc/master/classRooCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooCachedPdf.html,2,['cache'],['cache']
Performance," Copy constructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Implements internal (analytical) integration capabilities. ;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  Force RooRealIntegral to offer all our actual observable for internal integration. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertises internal (analytical) integration capabilities. ;  ; RooDataHist * getCacheHist (const RooArgSet &nset) const;  ; RooDataHist * getCacheHist (const RooArgSet *nset=nullptr) const;  Return pointer to RooDataHist cache histogram for given choice of observables. ;  ; RooAbsPdf * getCachePdf (const RooArgSet &nset) const;  ; RooAbsPdf * getCachePdf (const RooArgSet *nset=nullptr) const;  Return pointer to RooHistPdf cache pdf for given choice of observables. ;  ; Int_t getInterpolationOrder () const;  ; double getValV (const RooArgSet *set=nullptr) const override;  Implementation of getVal() overriding default implementation of RooAbsPdf. ;  ; void setInterpolationOrder (int order);  Change the interpolation order that is used in RooHistPdf cache representation smoothing the RooDataHist shapes. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  An",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooIntegralMorph.html:6861,cache,cache,6861,doc/master/classRooIntegralMorph.html,https://root.cern,https://root.cern/doc/master/classRooIntegralMorph.html,1,['cache'],['cache']
Performance," Create and fill a histogram with the efficiency N[1] / ( N[1] + N[0] ), where N(1/0) is the number of data points with effCat=1 and effCat=0 as function of the frames variable. ;  ; virtual RooPlot * plotOn (RooPlot *frame, PlotOpt o) const;  Create and fill a histogram of the frame's variable and append it to the frame. ;  ; virtual std::unique_ptr< RooAbsData > reduceEng (const RooArgSet &varSubset, const RooFormulaVar *cutVar, const char *cutRange=nullptr, std::size_t nStart=0, std::size_t=std::numeric_limits< std::size_t >::max()) const =0;  ; virtual void resetCache ();  Internal method – Remove cached function values. ;  ; virtual void setArgStatus (const RooArgSet &set, bool active);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooArgSet _cachedVars;  ! External variables cached with this data set ;  ; std::unique_ptr< RooAbsDataStore > _dstore;  Data storage implementation. ;  ; std::unique_ptr< RooArgSet > _globalObservables;  Snapshot of global observables. ;  ; const TNamed * _namePtr = nullptr;  ! De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; std::map< std::string, RooAbsData * > _ownedComponents;  Owned external components. ;  ; RooArgSet _vars;  Dimensions of this data set. ;  ; StorageType storageType;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static StorageType defaultStorageType =RooAbsData::Vector;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Private Member Functions; void copyGlobalObservables (const RooAbsData &other);  ; void copyImpl (const RooAbsData &other, const char *newname);  . Private Attributes; const RooFit::UniqueId< RooAbsData > _uniqueId;  ! ;  . Friends; class RooAbsOptTestStatistic;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:30756,cache,cached,30756,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['cache'],['cached']
Performance, Factory.cxx;  FitterBase.cxx;  GeneticAlgorithm.cxx;  GeneticFitter.cxx;  GeneticGenes.cxx;  GeneticPopulation.cxx;  GeneticRange.cxx;  GiniIndex.cxx;  GiniIndexWithLaplace.cxx;  HyperParameterOptimisation.cxx;  IFitterTarget.cxx;  IMethod.cxx;  Interval.cxx;  KDEKernel.cxx;  LDA.cxx;  LogInterval.cxx;  LossFunction.cxx;  MCFitter.cxx;  MethodANNBase.cxx;  MethodBase.cxx;  MethodBayesClassifier.cxx;  MethodBDT.cxx;  MethodBoost.cxx;  MethodCategory.cxx;  MethodCFMlpANN.cxx;  MethodCFMlpANN_Utils.cxx;  MethodCompositeBase.cxx;  MethodCrossValidation.cxx;  MethodCuts.cxx;  MethodDL.cxx;  MethodDNN.cxx;  MethodDT.cxx;  MethodFDA.cxx;  MethodFisher.cxx;  MethodHMatrix.cxx;  MethodKNN.cxx;  MethodLD.cxx;  MethodLikelihood.cxx;  MethodMLP.cxx;  MethodPDEFoam.cxx;  MethodPDERS.cxx;  MethodPlugins.cxx;  MethodRuleFit.cxx;  MethodSVM.cxx;  MethodTMlpANN.cxx;  MinuitFitter.cxx;  MinuitWrapper.cxx;  MisClassificationError.cxx;  ModulekNN.cxx;  MsgLogger.cxx;  NeuralNet.cxx;  Node.cxx;  OptimizeConfigParameters.cxx;  Option.cxx;  OptionMap.cxx;  PDEFoam.cxx;  PDEFoamCell.cxx;  PDEFoamDecisionTree.cxx;  PDEFoamDecisionTreeDensity.cxx;  PDEFoamDensityBase.cxx;  PDEFoamDiscriminant.cxx;  PDEFoamDiscriminantDensity.cxx;  PDEFoamEvent.cxx;  PDEFoamEventDensity.cxx;  PDEFoamKernelBase.cxx;  PDEFoamKernelGauss.cxx;  PDEFoamKernelLinN.cxx;  PDEFoamKernelTrivial.cxx;  PDEFoamMultiTarget.cxx;  PDEFoamTarget.cxx;  PDEFoamTargetDensity.cxx;  PDEFoamVect.cxx;  PDF.cxx;  QuickMVAProbEstimator.cxx;  Ranking.cxx;  Reader.cxx;  RegressionVariance.cxx;  Results.cxx;  ResultsClassification.cxx;  ResultsMulticlass.cxx;  ResultsRegression.cxx;  ROCCalc.cxx;  ROCCurve.cxx;  RootFinder.cxx;  Rule.cxx;  RuleCut.cxx;  RuleEnsemble.cxx;  RuleFit.cxx;  RuleFitAPI.cxx;  RuleFitParams.cxx;  SdivSqrtSplusB.cxx;  SeparationBase.cxx;  SimulatedAnnealing.cxx;  SimulatedAnnealingFitter.cxx;  SVEvent.cxx;  SVKernelFunction.cxx;  SVKernelMatrix.cxx;  SVWorkingSet.cxx;  TActivation.cxx;  TActivationChooser.cxx;  T,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:88951,Optimiz,OptimizeConfigParameters,88951,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,2,['Optimiz'],['OptimizeConfigParameters']
Performance," Generic Deep Neural Network class. More...;  ; class  TDenseLayer;  Generic layer class. More...;  ; struct  TDescriptors;  ; class  TDevice;  TDevice. More...;  ; class  TDLGradientDescent;  ; struct  TDNNGenDescriptors;  ; class  TGradientDescent;  ; class  TLayer;  Generic layer class. More...;  ; class  TNet;  Generic neural network class. More...;  ; class  TReference;  The reference architecture class. More...;  ; class  TReshapeLayer;  ; class  TRMSProp;  RMSProp Optimizer class. More...;  ; class  TSGD;  Stochastic Batch Gradient Descent Optimizer class. More...;  ; class  TSharedLayer;  Layer class width shared weight and bias layers. More...;  ; class  TTensorBatch;  TTensorBatch. More...;  ; class  TTensorBatchIterator;  TTensorBatchIterator. More...;  ; class  TTensorDataLoader;  TTensorDataLoader. More...;  ; class  TTensorDataLoader< AData, TReference< AReal > >;  ; struct  TWorkspace;  ; class  VGeneralLayer;  Generic General Layer class. More...;  ; class  VOptimizer;  Generic Optimizer class. More...;  . Typedefs; typedef std::vector< char > DropContainer;  ; using IndexIterator_t = typename std::vector< size_t >::iterator;  ; using MatrixInput_t = std::tuple< const TMatrixT< Double_t > &, const TMatrixT< Double_t > &, const TMatrixT< Double_t > & >;  ; using MemoryLayout = TMVA::Experimental::MemoryLayout;  ; typedef std::tuple< Settings &, Batch &, DropContainer & > pass_through_type;  ; using TensorInput = std::tuple< const std::vector< TMatrixT< Double_t > > &, const TMatrixT< Double_t > &, const TMatrixT< Double_t > & >;  ; using TMVAInput_t = std::tuple< const std::vector< Event * > &, const DataSetInfo & >;  . Enumerations; enum class  EActivationFunction { ;   kIdentity = 0; , kRelu = 1; , kSigmoid = 2; , kTanh = 3; , ;   kSymmRelu = 4; , kSoftSign = 5; , kGauss = 6; , kFastTanh = 7. };  Enum that represents layer activation functions. More...;  ; enum class  EInitialization { ;   kGauss = 'G'; , kUniform = 'U'; , kIdentity = 'I'; , kZero = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html:3560,Optimiz,Optimizer,3560,doc/master/namespaceTMVA_1_1DNN.html,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html,2,['Optimiz'],['Optimizer']
Performance," GetErrno ();  Static function returning system error number. ;  ; static void ResetErrno ();  Static function resetting system error number. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TUnixSystem; const char * GetLinkedLibraries () override;  Get list of shared libraries loaded at the start of the executable. ;  ;  Protected Member Functions inherited from TSystem; virtual Bool_t ConsistentWith (const char *path, void *dirptr=nullptr);  Check consistency of this helper with the one required by 'path' or 'dirptr'. ;  ; virtual void DoBeep (Int_t=-1, Int_t=-1) const;  ; virtual const char * ExpandFileName (const char *fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; virtual Bool_t ExpandFileName (TString &fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; TSystem * FindHelper (const char *path, void *dirptr=nullptr);  Create helper TSystem to handle file and directory operations that might be special for remote file access. ;  ; TString & GetLastErrorString ();  Return the thread local storage for the custom last error message. ;  ; const TString & GetLastErrorString () const;  Return the thread local st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacOSXSystem.html:32233,load,loaded,32233,doc/master/classTMacOSXSystem.html,https://root.cern,https://root.cern/doc/master/classTMacOSXSystem.html,1,['load'],['loaded']
Performance," GetNumberOfBins ();  ; void GetStats (Double_t *stats) const override;  Fill the array stats from the contents of this profile. ;  ; virtual Double_t GetZmax () const;  ; virtual Double_t GetZmin () const;  ; TClass * IsA () const override;  ; void LabelsDeflate (Option_t *axis=""X"") override;  Reduce the number of bins for this axis to the number of bins having a label. ;  ; void LabelsInflate (Option_t *axis=""X"") override;  Double the number of bins for axis. ;  ; void LabelsOption (Option_t *option=""h"", Option_t *axis=""X"") override;  Set option(s) to draw axis with labels. ;  ; Long64_t Merge (TCollection *list) override;  Merge all histograms in the collection in this histogram. ;  ; Bool_t Multiply (const TH1 *h1) override;  Multiply this profile2D by h1. ;  ; Bool_t Multiply (const TH1 *h1, const TH1 *h2, Double_t c1=1, Double_t c2=1, Option_t *option="""") override;  Replace contents of this profile2D by multiplication of h1 by h2. ;  ; Bool_t Multiply (TF1 *h1, Double_t c1=1) override;  Performs the operation: this = this*c1*f1. ;  ; TProfile2D & operator= (const TProfile2D &profile);  ; TProfile * ProfileX (const char *name=""_pfx"", Int_t firstybin=0, Int_t lastybin=-1, Option_t *option="""") const;  Project a 2-D histogram into a profile histogram along X. ;  ; TProfile * ProfileY (const char *name=""_pfy"", Int_t firstxbin=0, Int_t lastxbin=-1, Option_t *option="""") const;  Project a 2-D histogram into a profile histogram along X. ;  ; TH2D * ProjectionXY (const char *name=""_pxy"", Option_t *option=""e"") const;  Project this profile2D into a 2-D histogram along X,Y. ;  ; void PutStats (Double_t *stats) override;  Replace current statistics with the values in array stats. ;  ; TProfile2D * Rebin2D (Int_t nxgroup=2, Int_t nygroup=2, const char *newname="""") override;  Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together. ;  ; TProfile2D * RebinX (Int_t ngroup=2, const char *newname="""") override;  Rebin only the X axis. ;  ; TProfile2D * Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile2D.html:8747,Perform,Performs,8747,doc/master/classTProfile2D.html,https://root.cern,https://root.cern/doc/master/classTProfile2D.html,1,['Perform'],['Performs']
Performance," GetUser(). const char * TProof::GetUser ; (; ); const. inline . Definition at line 906 of file TProof.h. ◆ GetWorkDir(). const char * TProof::GetWorkDir ; (; ); const. inline . Definition at line 908 of file TProof.h. ◆ GoAsynchronous(). void TProof::GoAsynchronous ; (; ). Send GOASYNC message to the master. ; Definition at line 6267 of file TProof.cxx. ◆ GoMoreParallel(). Int_t TProof::GoMoreParallel ; (; Int_t ; nWorkersToAdd). private . Add nWorkersToAdd workers to current list of workers. ; This function is works on the master only, and only when an analysis is ongoing. A message is sent back to the client when we go ""more"" parallel. Returns -1 on error, number of total (not added!) workers on success. ; Definition at line 7170 of file TProof.cxx. ◆ GoParallel(). Int_t TProof::GoParallel ; (; Int_t ; nodes, . Bool_t ; attach = kFALSE, . Bool_t ; random = kFALSE . ). private . Go in parallel mode with at most ""nodes"" slaves. ; Since the fSlaves list is sorted by slave performace the active list will contain first the most performant nodes. Returns the number of active slaves. If random is TRUE, and nodes is less than the number of available workers, a random selection is done. Returns -1 in case of error. ; Definition at line 7273 of file TProof.cxx. ◆ HandleInputMessage(). Int_t TProof::HandleInputMessage ; (; TSlave * ; sl, . TMessage * ; mess, . Bool_t ; deactonfail = kFALSE . ). private . Analyze the received message. ; Returns 0 on success (1 if this the last message from this socket), -1 if any failure occurs. ; Definition at line 3105 of file TProof.cxx. ◆ HandleLibIncPath(). void TProof::HandleLibIncPath ; (; const char * ; what, . Bool_t ; add, . const char * ; dirs . ). protected . Handle lib, inc search paths modification request. ; Definition at line 8998 of file TProof.cxx. ◆ HandleOutputOptions(). Int_t TProof::HandleOutputOptions ; (; TString & ; opt, . TString & ; target, . Int_t ; action . ). protected . Extract from opt information about output ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:108291,perform,performace,108291,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,2,['perform'],"['performace', 'performant']"
Performance," GetUser(). const char * TProofServ::GetUser ; (; ); const. inline . Definition at line 241 of file TProofServ.h. ◆ GetVirtMemMax(). Long_t TProofServ::GetVirtMemMax ; (; ). static . VirtMemMax getter. ; Definition at line 6920 of file TProofServ.cxx. ◆ GetWorkDir(). const char * TProofServ::GetWorkDir ; (; ); const. inline . Definition at line 243 of file TProofServ.h. ◆ GetWorkers(). TProofServ::EQueryAction TProofServ::GetWorkers ; (; TList * ; workers, . Int_t & ; prioritychange, . Bool_t ; resume = kFALSE . ). virtual . Get list of workers to be used from now on. ; The list must be provided by the caller. ; Definition at line 5692 of file TProofServ.cxx. ◆ HandleArchive(). void TProofServ::HandleArchive ; (; TMessage * ; mess, . TString * ; slb = 0 . ). protectedvirtual . Handle archive request. ; Definition at line 3597 of file TProofServ.cxx. ◆ HandleCache(). Int_t TProofServ::HandleCache ; (; TMessage * ; mess, . TString * ; slb = 0 . ). protectedvirtual . Handle here all cache and package requests. ; Definition at line 5280 of file TProofServ.cxx. ◆ HandleCheckFile(). void TProofServ::HandleCheckFile ; (; TMessage * ; mess, . TString * ; slb = 0 . ). protectedvirtual . Handle file checking request. ; Definition at line 5129 of file TProofServ.cxx. ◆ HandleDataSets(). Int_t TProofServ::HandleDataSets ; (; TMessage * ; mess, . TString * ; slb = 0 . ). protectedvirtual . Handle here requests about datasets. ; Definition at line 6087 of file TProofServ.cxx. ◆ HandleException(). void TProofServ::HandleException ; (; Int_t ; sig). overridevirtual . Exception handler: we do not try to recover here, just exit. ; Reimplemented from TApplication.; Definition at line 6070 of file TProofServ.cxx. ◆ HandleFork(). void TProofServ::HandleFork ; (; TMessage * ; mess). protectedvirtual . Cloning itself via fork. Not implemented. ; Reimplemented in TProofServLite.; Definition at line 6654 of file TProofServ.cxx. ◆ HandleLibIncPath(). Int_t TProofServ::HandleLibIncPath ; (; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:44084,cache,cache,44084,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,1,['cache'],['cache']
Performance," InitWindow (ULong_t window) override;  Creates a new window and return window number. ;  ; Atom_t InternAtom (const char *atom_name, Bool_t only_if_exist) override;  Returns the atom identifier associated with the specified ""atom_name"" string. ;  ; void IntersectRegion (Region_t rega, Region_t regb, Region_t result) override;  Computes the intersection of two regions. ;  ; TClass * IsA () const override;  ; Bool_t IsCmdThread () const override;  ; Bool_t IsCocoaDraw () const;  ; Bool_t IsDNDAware (Window_t win, Atom_t *typelist) override;  Checks if the Window is DND aware, and knows any of the DND formats passed in argument. ;  ; Int_t KeysymToKeycode (UInt_t keysym) override;  Converts the ""keysym"" to the appropriate keycode. ;  ; char ** ListFonts (const char *fontname, Int_t max, Int_t &count) override;  Returns list of font names matching fontname regexp, like ""-*-times-*"". ;  ; FontStruct_t LoadQueryFont (const char *font_name) override;  Provides the most common way for accessing a font: opens (loads) the specified font and returns a pointer to the appropriate FontStruct_t structure. ;  ; void LookupString (Event_t *event, char *buf, Int_t buflen, UInt_t &keysym) override;  Converts the keycode from the event structure to a key symbol (according to the modifiers specified in the event structure and the current keyboard mapping). ;  ; void LowerWindow (Window_t wid) override;  Lowers the specified window ""id"" to the bottom of the stack so that it does not obscure any sibling windows. ;  ; Bool_t MakeOpenGLContextCurrent (Handle_t ctx, Window_t windowID) override;  Makes context ctx current OpenGL context. ;  ; void MapRaised (Window_t wid) override;  Maps the window ""id"" and all of its subwindows that have had map requests on the screen and put this window on the top of of the stack of all windows. ;  ; void MapSubwindows (Window_t wid) override;  Maps all subwindows for the specified window ""id"" in top-to-bottom stacking order. ;  ; void MapWindow (Window_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:16852,Load,LoadQueryFont,16852,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,2,"['Load', 'load']","['LoadQueryFont', 'loads']"
Performance," Initializes the X system. ;  ; virtual Int_t InitWindow (ULongptr_t window);  Creates a new window and return window number. ;  ; virtual Atom_t InternAtom (const char *atom_name, Bool_t only_if_exist);  Returns the atom identifier associated with the specified ""atom_name"" string. ;  ; virtual void IntersectRegion (Region_t rega, Region_t regb, Region_t result);  Computes the intersection of two regions. ;  ; TClass * IsA () const override;  ; virtual Bool_t IsCmdThread () const;  ; virtual Bool_t IsDNDAware (Window_t win, Atom_t *typelist);  Checks if the Window is DND aware, and knows any of the DND formats passed in argument. ;  ; virtual Int_t KeysymToKeycode (UInt_t keysym);  Converts the ""keysym"" to the appropriate keycode. ;  ; virtual char ** ListFonts (const char *fontname, Int_t max, Int_t &count);  Returns list of font names matching fontname regexp, like ""-*-times-*"". ;  ; virtual FontStruct_t LoadQueryFont (const char *font_name);  Provides the most common way for accessing a font: opens (loads) the specified font and returns a pointer to the appropriate FontStruct_t structure. ;  ; virtual void LookupString (Event_t *event, char *buf, Int_t buflen, UInt_t &keysym);  Converts the keycode from the event structure to a key symbol (according to the modifiers specified in the event structure and the current keyboard mapping). ;  ; virtual void LowerWindow (Window_t id);  Lowers the specified window ""id"" to the bottom of the stack so that it does not obscure any sibling windows. ;  ; virtual Bool_t MakeOpenGLContextCurrent (Handle_t ctx, Window_t windowID);  Makes context ctx current OpenGL context. ;  ; virtual void MapGCFont (GContext_t, FontStruct_t);  Map the XftFont with the Graphics Context using it. ;  ; virtual void MapRaised (Window_t id);  Maps the window ""id"" and all of its subwindows that have had map requests on the screen and put this window on the top of of the stack of all windows. ;  ; virtual void MapSubwindows (Window_t id);  Maps all subw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:18373,Load,LoadQueryFont,18373,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,2,"['Load', 'load']","['LoadQueryFont', 'loads']"
Performance," IsSameType (const void *QualTypePtr1, const void *QualTypePtr2) const;  ; bool IsSignedIntegerType (const void *QualTypePtr) const;  ; bool IsUnsignedIntegerType (const void *QualTypePtr) const;  ; bool IsVoidPointerType (const void *QualTypePtr) const;  ; void * LazyFunctionCreatorAutoload (const std::string &mangled_name);  Autoload a library based on a missing symbol. ;  ; void LibraryLoaded (const void *dyLibHandle, const char *canonicalName);  ; bool LibraryLoadingFailed (const std::string &, const std::string &, bool, bool);  ; void LibraryUnloaded (const void *dyLibHandle, const char *canonicalName);  ; Int_t Load (const char *filenam, Bool_t system=kFALSE) final;  Load a library file in cling's memory. ;  ; void LoadEnums (TListOfEnums &cl) const final;  Create list of pointers to enums for TClass cl. ;  ; int LoadFile (const char *path) const final;  Load a source file or library called path into the interpreter. ;  ; virtual void LoadFunctionTemplates (TClass *cl) const final;  Create list of pointers to function templates for TClass cl. ;  ; Int_t LoadLibraryMap (const char *rootmapfile=nullptr) final;  Load map between class and library. ;  ; void LoadMacro (const char *filename, EErrorCode *error=nullptr) final;  Load a macro file in cling's memory. ;  ; Bool_t LoadText (const char *text) const final;  Load the declarations from text into the interpreter. ;  ; std::unique_ptr< TInterpreterValue > MakeInterpreterValue () const final;  ; const char * MapCppName (const char *) const final;  Interface to cling function. ;  ; const char * MethodArgInfo_DefaultValue (MethodArgInfo_t *marginfo) const final;  ; void MethodArgInfo_Delete (MethodArgInfo_t *marginfo) const final;  ; MethodArgInfo_t * MethodArgInfo_Factory () const final;  ; MethodArgInfo_t * MethodArgInfo_Factory (MethodInfo_t *minfo) const final;  ; MethodArgInfo_t * MethodArgInfo_FactoryCopy (MethodArgInfo_t *marginfo) const final;  ; bool MethodArgInfo_IsValid (MethodArgInfo_t *marginfo) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:23961,Load,LoadFunctionTemplates,23961,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['Load'],['LoadFunctionTemplates']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBCPEffDecay.html:66578,Cache,Cached,66578,doc/master/classRooBCPEffDecay.html,https://root.cern,https://root.cern/doc/master/classRooBCPEffDecay.html,7,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from RooAbsCachedPdf; using CacheElem = PdfCacheElem;  ;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedPdf.html:72973,Cache,Cached,72973,doc/master/classRooCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooCachedPdf.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , Rela",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooArgusBG.html:69860,Cache,Cached,69860,doc/master/classRooArgusBG.html,https://root.cern,https://root.cern/doc/master/classRooArgusBG.html,33,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddition.html:56625,Cache,Cached,56625,doc/master/classRooAddition.html,https://root.cern,https://root.cern/doc/master/classRooAddition.html,38,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class CacheElem;  ; class Grid2;  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observabl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMomentMorphFuncND.html:59282,Cache,Cached,59282,doc/master/classRooMomentMorphFuncND.html,https://root.cern,https://root.cern/doc/master/classRooMomentMorphFuncND.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class CacheElem;  Current normalization set. ;  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMomentMorph.html:72146,Cache,Cached,72146,doc/master/classRooMomentMorph.html,https://root.cern,https://root.cern/doc/master/classRooMomentMorph.html,2,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class MorphCacheElem;  . Additional Inherited Members;  Public Types inherited from RooAbsCachedPdf; using CacheElem = PdfCacheElem;  ;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooIntegralMorph.html:76818,Cache,Cached,76818,doc/master/classRooIntegralMorph.html,https://root.cern,https://root.cern/doc/master/classRooIntegralMorph.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class RICacheElem;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumRunningInt.html:59259,Cache,Cached,59259,doc/master/classRooNumRunningInt.html,https://root.cern,https://root.cern/doc/master/classRooNumRunningInt.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class RooAbsAnaConvPdf;  ; class RooAddModel;  ; class RooConvGenContext;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooResolutionModel.html:72546,Cache,Cached,72546,doc/master/classRooResolutionModel.html,https://root.cern,https://root.cern/doc/master/classRooResolutionModel.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class RooAbsTestStatistic;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealMPFE.html:56608,Cache,Cached,56608,doc/master/classRooRealMPFE.html,https://root.cern,https://root.cern/doc/master/classRooRealMPFE.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class RooAddGenContext;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:74921,Cache,Cached,74921,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class RooConvGenContext;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvPdf.html:72511,Cache,Cached,72511,doc/master/classRooNumConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooNumConvPdf.html,2,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class RooConvGenContext;  ; class RooNumConvPdf;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvolution.html:60705,Cache,Cached,60705,doc/master/classRooNumConvolution.html,https://root.cern,https://root.cern/doc/master/classRooNumConvolution.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class RooHistConstraint;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooParamHistFunc.html:56953,Cache,Cached,56953,doc/master/classRooParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooParamHistFunc.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Attributes; RooObjCacheManager _cacheMgr;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooJeffreysPrior.html:70029,Cache,Cached,70029,doc/master/classRooJeffreysPrior.html,https://root.cern,https://root.cern/doc/master/classRooJeffreysPrior.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Attributes; bool _disableCache = false;  Flag to run object in passthrough (= non-caching mode) ;  . Friends; class PdfCacheElem;  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedPdf.html:74377,Cache,Cached,74377,doc/master/classRooAbsCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedPdf.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Attributes; bool _disableCache;  . Friends; class FuncCacheElem;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedReal.html:58357,Cache,Cached,58357,doc/master/classRooAbsCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedReal.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Attributes; bool _doFast = false;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  Sc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVoigtian.html:70430,Cache,Cached,70430,doc/master/classRooVoigtian.html,https://root.cern,https://root.cern/doc/master/classRooVoigtian.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; double g (double x, double sigma) const;  . Private Attributes; bool _asymLeft = false;  ; bool _asymRight = false;  ; double _binWidth;  ; double * _dataPts = nullptr;  ; double * _dataWgts = nullptr;  ; double _hi;  ; double _lo;  ; double _lookupTable [_nPoints+1];  ; bool _mirrorLeft = false;  ; b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooKeysPdf.html:72271,Cache,Cached,72271,doc/master/classRooKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRooKeysPdf.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; void finalizeConstruction ();  ; std::pair< const RooArgSet *, AddCacheElem * > getNormAndCache (const RooArgSet *nset) const;  Look up projection cache and per-PDF norm sets. ;  ; void materializeRefCoefNormFromAttribute () const;  ; void setAllExtendable (bool allExtendable);  ; void setRecursiveFra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddPdf.html:73699,Cache,Cached,73699,doc/master/classRooAddPdf.html,https://root.cern,https://root.cern/doc/master/classRooAddPdf.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; void initializeOwnedDataHist (std::unique_ptr< RooDataHist > &&dataHist);  . Friends; class RooAbsCachedReal;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relativ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistFunc.html:58732,Cache,Cached,58732,doc/master/classRooHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooHistFunc.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; void initializeOwnedDataHist (std::unique_ptr< RooDataHist > &&dataHist);  . Static Private Member Functions; static double analyticalIntegral (Int_t code, const char *rangeName, RooArgSet const &histObsList, RooArgSet const &pdfObsList, RooDataHist &dataHist, bool histFuncMode);  ; static bool forceA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistPdf.html:71636,Cache,Cached,71636,doc/master/classRooHistPdf.html,https://root.cern,https://root.cern/doc/master/classRooHistPdf.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; void prepareFFTBinning (RooRealVar &convVar) const;  Try to improve the binning and inform user if possible. ;  . Friends; class FFTCacheElem;  ; class RooConvGenContext;  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:81780,Cache,Cached,81780,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions;  RooSimultaneous (const char *name, const char *title, InitializationOutput &&initInfo);  Private internal constructor. ;  . Static Private Member Functions; static std::unique_ptr< RooSimultaneous::InitializationOutput > initialize (std::string const &name, RooAbsCategoryLValue &inIndexCat, std::map<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimultaneous.html:74042,Cache,Cached,74042,doc/master/classRooSimultaneous.html,https://root.cern,https://root.cern/doc/master/classRooSimultaneous.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Private Member Functions; static NumBins getNumBinsPerDim (RooArgSet const &vars);  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classParamHistFunc.html:59417,Cache,Cached,59417,doc/master/classParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Private Member Functions; static void doEvalImpl (RooAbsArg const *caller, RooFit::EvalContext &, RooAbsReal const &x, RooArgList const &coefs, int lowestOrder);  ; static void fillCoeffValues (std::vector< double > &wksp, RooListProxy const &coefList);  . Friends; class RooPolynomial;  . Additional Inherited Members;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooPolyVar.html:56352,Cache,Cached,56352,doc/master/classRooPolyVar.html,https://root.cern,https://root.cern/doc/master/classRooPolyVar.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static Int_t _cacheAllNDim;  ! Cache all integrals with given numeric dimension ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:59822,Cache,Cached,59822,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static RooArgSet _emptySet;  Supports named argument constructor. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:64495,Cache,Cached,64495,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static RooCategory * _dummyBlindState = nullptr;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsHiddenReal.html:57185,Cache,Cached,57185,doc/master/classRooAbsHiddenReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsHiddenReal.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:77144,Cache,Cached,77144,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _doFloorGlobal = false;  Global flag for introducing floor at zero in pdf. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealSumPdf.html:63767,Cache,Cached,63767,doc/master/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/master/classRooRealSumPdf.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _doFloorGlobal = false;  Global flag for introducing floor at zero in pdf. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealSumFunc.html:49882,Cache,Cached,49882,doc/master/classRooRealSumFunc.html,https://root.cern,https://root.cern/doc/master/classRooRealSumFunc.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:58614,Cache,Cached,58614,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _printScientific;  ; static Int_t _printSigDigits;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:69838,Cache,Cached,69838,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBernstein.html:73070,Cache,Cached,73070,doc/master/classRooBernstein.html,https://root.cern,https://root.cern/doc/master/classRooBernstein.html,17,['Cache'],['Cached']
Performance," Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  St",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinWidthFunction.html:59332,Cache,Cached,59332,doc/master/classRooBinWidthFunction.html,https://root.cern,https://root.cern/doc/master/classRooBinWidthFunction.html,12,['Cache'],['Cached']
Performance," MnUserParameterState;  class which holds the external user and/or internal Minuit representation of the parameters and errors; transformation internal <-> external on demand; More...;  ; class  MnUserTransformation;  class dealing with the transformation between user specified parameters (external) and internal parameters used for minimization More...;  ; class  MnVectorTransform;  ; class  ModularFunctionMinimizer;  Base common class providing the API for all the minimizer Various Minimize methods are provided varying on the type of FCN function passesd and on the objects used for the parameters. More...;  ; class  MPIProcess;  ; class  MPITerminate;  ; class  NegativeG2LineSearch;  In case that one of the components of the second derivative g2 calculated by the numerical Gradient calculator is negative, a 1dim line search in the direction of that component is done in order to find a better position where g2 is again positive. More...;  ; class  Numerical2PGradientCalculator;  class performing the numerical gradient calculation More...;  ; class  NumericalDerivator;  ; class  ParametricFunction;  Function which has parameters. More...;  ; class  PrefixStack;  ; class  ScanBuilder;  Performs a minimization using the simplex method of Nelder and Mead (ref. More...;  ; class  ScanMinimizer;  Class implementing the required methods for a minimization using SCAN API is provided in the upper ROOT::Minuit2::ModularFunctionMinimizer class. More...;  ; class  SimplexBuilder;  Performs a minimization using the simplex method of Nelder and Mead (ref. More...;  ; class  SimplexMinimizer;  Class implementing the required methods for a minimization using Simplex. More...;  ; class  SimplexParameters;  class describing the simplex set of points (f(x), x ) which evolve during the minimization iteration process. More...;  ; class  SimplexSeedGenerator;  generate Simplex starting point (state) More...;  ; class  SinParameterTransformation;  class for the transformation for double-li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html:10991,perform,performing,10991,doc/master/namespaceROOT_1_1Minuit2.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html,2,['perform'],['performing']
Performance," RInterface (RInterface &&)=default;  Move-ctor for RInterface. ;  ; RResultPtr< U > Aggregate (AccFun aggregator, MergeFun merger, std::string_view columnName, const U &aggIdentity);  Execute a user-defined accumulation operation on the processed column values in each processing slot. ;  ; RResultPtr< U > Aggregate (AccFun aggregator, MergeFun merger, std::string_view columnName="""");  Execute a user-defined accumulation operation on the processed column values in each processing slot. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > Alias (std::string_view alias, std::string_view columnName);  Allow to refer to a column with a different name. ;  ; RResultPtr< typename std::decay_t< Helper >::Result_t > Book (Helper &&helper, const ColumnNames_t &columns={});  Book execution of a custom action using a user-defined helper object. ;  ; RInterface< RLoopManager > Cache (const ColumnNames_t &columnList);  Save selected columns in memory. ;  ; RInterface< RLoopManager > Cache (const ColumnNames_t &columnList);  Save selected columns in memory. ;  ; RInterface< RLoopManager > Cache (std::initializer_list< std::string > columnList);  Save selected columns in memory. ;  ; RInterface< RLoopManager > Cache (std::string_view columnNameRegexp="""");  Save selected columns in memory. ;  ; RResultPtr< ULong64_t > Count ();  Return the number of entries processed (lazy action). ;  ; RInterface< RDFDetail::RLoopManager, DS_t > DefaultValueFor (std::string_view column, const T &defaultValue);  In case the value in the given column is missing, provide a default value. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > Define (std::string_view name, F expression, const ColumnNames_t &columns={});  Define a new column. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > Define (std::string_view name, std::string_view expression);  Define a new column. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > DefinePerSample (std::string_view name, F expression);  Define a new column that is updated whe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:94552,Cache,Cache,94552,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['Cache'],['Cache']
Performance," RInterface (RInterface &&)=default;  Move-ctor for RInterface. ;  ; RResultPtr< U > Aggregate (AccFun aggregator, MergeFun merger, std::string_view columnName, const U &aggIdentity);  Execute a user-defined accumulation operation on the processed column values in each processing slot. ;  ; RResultPtr< U > Aggregate (AccFun aggregator, MergeFun merger, std::string_view columnName="""");  Execute a user-defined accumulation operation on the processed column values in each processing slot. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > Alias (std::string_view alias, std::string_view columnName);  Allow to refer to a column with a different name. ;  ; RResultPtr< typename std::decay_t< Helper >::Result_t > Book (Helper &&helper, const ColumnNames_t &columns={});  Book execution of a custom action using a user-defined helper object. ;  ; RInterface< RLoopManager > Cache (const ColumnNames_t &columnList);  Save selected columns in memory. ;  ; RInterface< RLoopManager > Cache (const ColumnNames_t &columnList);  Save selected columns in memory. ;  ; RInterface< RLoopManager > Cache (std::initializer_list< std::string > columnList);  Save selected columns in memory. ;  ; RInterface< RLoopManager > Cache (std::string_view columnNameRegexp="""");  Save selected columns in memory. ;  ; RResultPtr< ULong64_t > Count ();  Return the number of entries processed (lazy action). ;  ; RInterface< RDFDetail::RLoopManager, DS_t > Define (std::string_view name, F expression, const ColumnNames_t &columns={});  Define a new column. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > Define (std::string_view name, std::string_view expression);  Define a new column. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > DefinePerSample (std::string_view name, F expression);  Define a new column that is updated when the input sample changes. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > DefinePerSample (std::string_view name, std::string_view expression);  Define a new column that is updated when th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:87752,Cache,Cache,87752,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['Cache'],['Cache']
Performance," ROOT::Experimental::Detail::RCheckedMenuItem;  Menu item with check box. More...;  ; class  ROOT::Experimental::RColor;  The color class. More...;  ; class  ROOT::Experimental::RDisplayItem;  Base class for painting data for JS. More...;  ; class  ROOT::Experimental::RDrawable;  Base class for drawable entities: objects that can be painted on a RPad. More...;  ; class  ROOT::Experimental::RDrawableDisplayItem;  Generic display item for RDrawable, just reference drawable itself. More...;  ; class  ROOT::Experimental::RDrawableExecRequest;  Request execution of method of referenced drawable, no reply. More...;  ; class  ROOT::Experimental::RDrawableMenuRequest;  Request menu items for the drawable object. More...;  ; class  ROOT::Experimental::RDrawableReply;  Base class for replies on RDrawableRequest. More...;  ; class  ROOT::Experimental::RDrawableRequest;  Base class for requests which can be submitted from the clients. More...;  ; class  ROOT::Experimental::RFrame;  Holds an area where drawing on user coordinate-system can be performed. More...;  ; class  ROOT::Experimental::RIndirectDisplayItem;  Extract (reference) only basic attributes from drawable, but not drawable itself. More...;  ; class  ROOT::Experimental::Internal::RIOSharedBase;  ; class  ROOT::Experimental::Detail::RMenuArgument;  Argument description for menu item which should invoke class method. More...;  ; class  ROOT::Experimental::Detail::RMenuItem;  Base class for menu items, shown on JS side. More...;  ; class  ROOT::Experimental::RMenuItems;  List of items for object context menu. More...;  ; class  ROOT::Experimental::ROnFrameDrawable;  Base class for drawable which can be drawn on frame or on pad. More...;  ; class  ROOT::Experimental::RPad;  Graphic container for RDrawable-s. More...;  ; class  ROOT::Experimental::RPadBase;  Base class for graphic containers for RDrawable-s. More...;  ; class  ROOT::Experimental::RPadBaseDisplayItem;  class RPadBaseDisplayItem More...;  ; class  ROOT::Ex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__GpadROOT7.html:3124,perform,performed,3124,doc/master/group__GpadROOT7.html,https://root.cern,https://root.cern/doc/master/group__GpadROOT7.html,1,['perform'],['performed']
Performance," ReadMap (int nElements, TBuffer &b, const TClass *onfileClass);  ; void ReadMapHelper (StreamHelper *i, Value *v, Bool_t vsn3, TBuffer &b);  ; void ReadObjects (int nElements, TBuffer &b, const TClass *onfileClass);  ; void ReadPairFromMap (int nElements, TBuffer &b);  ; void ReadPrimitives (int nElements, TBuffer &b, const TClass *onfileClass);  ; void WriteMap (int nElements, TBuffer &b);  ; void WriteObjects (int nElements, TBuffer &b);  ; void WritePrimitives (int nElements, TBuffer &b);  ;  Protected Member Functions inherited from TGenCollectionProxy; void CheckFunctions () const;  Check existence of function pointers. ;  ; virtual void DeleteItem (Bool_t force, void *ptr) const;  Call to delete/destruct individual item. ;  ; TGenCollectionProxy * Initialize (Bool_t silent) const;  Proxy initializer. ;  ; virtual TGenCollectionProxy * InitializeEx (Bool_t silent);  Proxy initializer. ;  . Protected Attributes; ReadBuffer_t fReadBufferFunc;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionStreamer.html:9885,cache,cache,9885,doc/master/classTGenCollectionStreamer.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionStreamer.html,1,['cache'],['cache']
Performance," Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; std::string _binningName;  Name of binning to be used for cache histogram. ;  ; RooRealProxy func;  Proxy to functions whose running integral is calculated. ;  ; RooRealProxy x;  Integrated observable. ;  ;  Protected Attributes inherited from RooAbsCachedReal; std::map< Int_t, std::pair< const RooArgSet *, const RooArgSet * > > _anaIntMap;  ! Map for analytical integration codes ;  ; RooObjCacheManager _cacheMgr;  ! The cache manager ;  ; Int_t _ipOrder;  Interpolation order for cache histograms. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumRunningInt.html:57348,cache,cache,57348,doc/master/classRooNumRunningInt.html,https://root.cern,https://root.cern/doc/master/classRooNumRunningInt.html,1,['cache'],['cache']
Performance," Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; bool _allExtendable = false;  Flag indicating if all PDF components are extendable. ;  ; RooAICRegistry _codeReg = 10;  ! Registry of component analytical integration codes ;  ; std::vector< double > _coefCache;  ! Transient cache with transformed values of coefficients ;  ; Int_t _coefErrCount;  ! Coefficient error counter ;  ; RooListProxy _coefList;  List of coefficients. ;  ; bool _haveLastCoef = false;  Flag indicating if last PDFs coefficient was supplied in the constructor. ;  ; RooObjCacheManager _intCacheMgr;  ! Manager of cache with integrals ;  ; RooArgSet _ownedComps;  ! Owned components ;  ; RooListProxy _pdfList;  List of component PDFs. ;  ; RooObjCacheManager _projCacheMgr;  ! Manager of cache with coefficient projections and transformations ;  ; RooSetProxy _refCoefNorm;  ! Reference observable set for coefficient interpretation ;  ; TNamed * _refCoefRangeName = nullptr;  ! Reference range name for coefficient interpretation ;  ; RooArgList * _snormList {nullptr};  ! List of supplemental normalization factors ;  ;  Protected Attributes inherited from RooResolutionModel; RooFormulaVar * _basis = nullptr;  Basis function convolved with this resolution model. ;  ; Int_t _basisCode;  Identifier code for selected basis function. ;  ; bool _ownBasis;  Flag indicating ownership of _basis. ;  ; RooTemplateProxy< RooAbsRealLValue > x;  Dependent/convolution variable. ;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:71910,cache,cache,71910,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['cache'],['cache']
Performance," Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; Long_t fMaximum;  Maximum value if leaf range is specified. ;  ; Long_t fMinimum;  Minimum value if leaf range is specified. ;  ; Long_t ** fPointer;  ! Address of pointer to data buffer ;  ; Long_t * fValue;  ! Pointer to data buffer ;  ;  Protected Attributes inherited from TLeaf; TBranch * fBranch;  ! Pointer to supporting branch (we do not own the branch) ;  ; bool fIsRange;  (=true if leaf has a range, false otherwise). This is equivalent to being a 'leafcount'. For a TLeafElement the range information is actually store in the TBranchElement. ;  ; bool fIsUnsigned;  (=true if unsigned, false otherwise) ;  ; TLeaf * fLeafCount;  Pointer to Leaf count if variable length (we do not own the counter) ;  ; LeafCountValues * fLeafCountValues;  ! Cache of collection/array sizes ;  ; Int_t fLen;  Number of fixed length elements in the leaf's data. ;  ; Int_t fLenType;  Number of bytes for this data type. ;  ; Int_t fNdata;  ! Number of elements in fAddress data buffer. ;  ; Int_t fOffset;  Offset in ClonesArray object (if one) ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from TLeaf; enum class  DeserializeType { ;   kInvalid = 0; , kExternal; , kDestructive = kExternal; , kInPlace; , ;   kZeroCopy. };  ; enum  EStatusBits { kIndirectAddress = (1ULL << ( 11 )); , kNewValue = (1ULL << ( 12 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 ))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLeafG.html:14908,Cache,Cache,14908,doc/master/classTLeafG.html,https://root.cern,https://root.cern/doc/master/classTLeafG.html,1,['Cache'],['Cache']
Performance," Return expected number of events to be used in calculation of extended likelihood. ;  ; ExtendMode extendMode () const override;  Returns ability of PDF to provide extended likelihood terms. ;  ;  RooProjectedPdf ();  Default constructor. ;  ;  RooProjectedPdf (const char *name, const char *title, RooAbsReal &_intpdf, const RooArgSet &intObs);  Construct projection of input pdf '_intpdf' over observables 'intObs'. ;  ;  RooProjectedPdf (const RooProjectedPdf &other, const char *name=nullptr);  Copy constructor. ;  ;  Public Member Functions inherited from RooProjectedPdf;  RooProjectedPdf ();  Default constructor. ;  ;  RooProjectedPdf (const char *name, const char *title, RooAbsReal &_intpdf, const RooArgSet &intObs);  Construct projection of input pdf '_intpdf' over observables 'intObs'. ;  ;  RooProjectedPdf (const RooProjectedPdf &other, const char *name=nullptr);  Copy constructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Return analytical integral represent by appropriate element of projection cache. ;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; RooAbsPdf * createProjection (const RooArgSet &iset) override;  Special version of RooAbsReal::createProjection that deals with projections of projections. ;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  Force RooRealIntegral to relegate integration of all observables to internal logic. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Mark all requested variables as internally integrated. ;  ; void initGenerator (Int_t) override;  Interface for one-time initialization to setup the generator for the specified code. ;  ; TClass * IsA () const override;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classxRooProjectedPdf.html:1546,cache,cache,1546,doc/master/classxRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classxRooProjectedPdf.html,1,['cache'],['cache']
Performance," Return p.d.f. ;  ; std::vector< double > scanPdf (RooRealVar &obs, RooAbsPdf &pdf, const RooDataHist &hist, const RooArgSet &slicePos, Int_t &N, Int_t &N2, Int_t &zeroBin, double shift) const;  Scan the values of 'pdf' in observable 'obs' using the bin values stored in 'hist' at slice position 'slicePos' N is filled with the number of bins defined in hist, N2 is filled with N plus the number of buffer bins The return value is an array of doubles of length N2 with the sampled values. ;  ;  Protected Member Functions inherited from RooAbsCachedPdf; virtual const char * binningName () const;  ; std::string cacheNameSuffix (const RooArgSet &nset) const;  Construct string with unique suffix for cache objects based on observable names that define cache configuration. ;  ; void disableCache (bool flag);  ; void doEval (RooFit::EvalContext &) const override;  Base function for computing multiple values of a RooAbsReal. ;  ; PdfCacheElem * getCache (const RooArgSet *nset, bool recalculate=true) const;  Retrieve cache object associated with given choice of observables. ;  ; virtual const char * payloadUniqueSuffix () const;  ;  Protected Member Functions inherited from RooAbsPdf;  RooAbsPdf (const RooAbsPdf &other, const char *name=nullptr);  Copy constructor. ;  ; virtual std::unique_ptr< RooAbsReal > createNLLImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the NLL creation routine. ;  ; virtual std::unique_ptr< RooFitResult > fitToImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the likelihood fitting routine. ;  ; bool isActiveNormSet (RooArgSet const *normSet) const;  Checks if normSet is the currently active normalization set of this PDF, meaning is exactly the same object as the one the _normSet member points to (or both are nullptr). ;  ; double normalizeWithNaNPacking (double rawVal, double normVal) const;  ; RooPlot * plotOn (RooPlot *frame, PlotOpt o) const override;  Plot oneself on 'frame'. ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:70616,cache,cache,70616,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cache']
Performance," Return total number of bytes in the branch (including current buffer) ;  ; Long64_t GetTotBytes (Option_t *option="""") const;  Return total number of bytes in the branch (excluding current buffer) if option =""*"" includes all sub-branches of this branch too. ;  ; TBuffer * GetTransientBuffer (Int_t size);  Returns the transient buffer currently used by this TBranch for reading/writing baskets. ;  ; TTree * GetTree () const;  ; Int_t GetWriteBasket () const;  ; Long64_t GetZipBytes (Option_t *option="""") const;  Return total number of zip bytes in the branch if option =""*"" includes all sub-branches of this branch too. ;  ; bool IsAutoDelete () const;  Return true if an existing object in a TBranchObject must be deleted. ;  ; virtual void KeepCircular (Long64_t maxEntries);  keep a maximum of fMaxEntries in memory ;  ; virtual Int_t LoadBaskets ();  Baskets associated to this branch are forced to be in memory. ;  ; void PrintCacheInfo () const;  Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ;  ; virtual void ReadBasket (TBuffer &b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void Refresh (TBranch *b);  Refresh this branch using new information in b This function is called by TTree::Refresh. ;  ; virtual void Reset (Option_t *option="""");  Reset a Branch. ;  ; virtual void ResetAddress ();  Reset the address of the branch. ;  ; virtual void ResetAfterMerge (TFileMergeInfo *);  Reset a Branch. ;  ; virtual void ResetReadEntry ();  ; virtual void SetAutoDelete (bool autodel=true);  Set the automatic delete bit. ;  ; virtual void SetBasketSize (Int_t buffsize);  Set the basket size The function makes sure that the basket size is greater than fEntryOffsetlen. ;  ; virtual void SetBufferAddress (TBuffer *entryBuffer);  Set address of this branch directly from a TBuffer to avoid streaming. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchSTL.html:7261,cache,cached,7261,doc/master/classTBranchSTL.html,https://root.cern,https://root.cern/doc/master/classTBranchSTL.html,2,['cache'],"['cache', 'cached']"
Performance," Return total number of bytes in the branch (including current buffer) ;  ; Long64_t GetTotBytes (Option_t *option="""") const;  Return total number of bytes in the branch (excluding current buffer) if option =""*"" includes all sub-branches of this branch too. ;  ; TBuffer * GetTransientBuffer (Int_t size);  Returns the transient buffer currently used by this TBranch for reading/writing baskets. ;  ; TTree * GetTree () const;  ; Int_t GetWriteBasket () const;  ; Long64_t GetZipBytes (Option_t *option="""") const;  Return total number of zip bytes in the branch if option =""*"" includes all sub-branches of this branch too. ;  ; bool IsAutoDelete () const;  Return true if an existing object in a TBranchObject must be deleted. ;  ; virtual void KeepCircular (Long64_t maxEntries);  keep a maximum of fMaxEntries in memory ;  ; virtual Int_t LoadBaskets ();  Baskets associated to this branch are forced to be in memory. ;  ; void PrintCacheInfo () const;  Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ;  ; virtual void ReadBasket (TBuffer &b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void Refresh (TBranch *b);  Refresh this branch using new information in b This function is called by TTree::Refresh. ;  ; virtual void ResetAddress ();  Reset the address of the branch. ;  ; virtual void ResetReadEntry ();  ; virtual void SetAutoDelete (bool autodel=true);  Set the automatic delete bit. ;  ; virtual void SetBufferAddress (TBuffer *entryBuffer);  Set address of this branch directly from a TBuffer to avoid streaming. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  Set compression algorithm. ;  ; void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  Set compression level. ;  ; void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Set compressio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchClones.html:7557,cache,cached,7557,doc/master/classTBranchClones.html,https://root.cern,https://root.cern/doc/master/classTBranchClones.html,2,['cache'],"['cache', 'cached']"
Performance," Return total number of bytes in the branch (including current buffer) ;  ; Long64_t GetTotBytes (Option_t *option="""") const;  Return total number of bytes in the branch (excluding current buffer) if option =""*"" includes all sub-branches of this branch too. ;  ; TBuffer * GetTransientBuffer (Int_t size);  Returns the transient buffer currently used by this TBranch for reading/writing baskets. ;  ; TTree * GetTree () const;  ; Int_t GetWriteBasket () const;  ; Long64_t GetZipBytes (Option_t *option="""") const;  Return total number of zip bytes in the branch if option =""*"" includes all sub-branches of this branch too. ;  ; bool IsAutoDelete () const;  Return true if an existing object in a TBranchObject must be deleted. ;  ; virtual void KeepCircular (Long64_t maxEntries);  keep a maximum of fMaxEntries in memory ;  ; virtual Int_t LoadBaskets ();  Baskets associated to this branch are forced to be in memory. ;  ; void PrintCacheInfo () const;  Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ;  ; virtual void ReadBasket (TBuffer &b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void Refresh (TBranch *b);  Refresh this branch using new information in b This function is called by TTree::Refresh. ;  ; virtual void ResetAddress ();  Reset the address of the branch. ;  ; virtual void ResetReadEntry ();  ; virtual void SetBufferAddress (TBuffer *entryBuffer);  Set address of this branch directly from a TBuffer to avoid streaming. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  Set compression algorithm. ;  ; void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  Set compression level. ;  ; void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Set compression settings. ;  ; virtual void SetEntries (Long64_t entries);  Set the number of entr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchObject.html:8042,cache,cached,8042,doc/master/classTBranchObject.html,https://root.cern,https://root.cern/doc/master/classTBranchObject.html,2,['cache'],"['cache', 'cached']"
Performance," Return total number of bytes in the branch (including current buffer) ;  ; Long64_t GetTotBytes (Option_t *option="""") const;  Return total number of bytes in the branch (excluding current buffer) if option =""*"" includes all sub-branches of this branch too. ;  ; TBuffer * GetTransientBuffer (Int_t size);  Returns the transient buffer currently used by this TBranch for reading/writing baskets. ;  ; TTree * GetTree () const;  ; Int_t GetWriteBasket () const;  ; Long64_t GetZipBytes (Option_t *option="""") const;  Return total number of zip bytes in the branch if option =""*"" includes all sub-branches of this branch too. ;  ; bool IsAutoDelete () const;  Return true if an existing object in a TBranchObject must be deleted. ;  ; virtual void KeepCircular (Long64_t maxEntries);  keep a maximum of fMaxEntries in memory ;  ; virtual Int_t LoadBaskets ();  Baskets associated to this branch are forced to be in memory. ;  ; void PrintCacheInfo () const;  Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ;  ; virtual void ReadBasket (TBuffer &b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void Refresh (TBranch *b);  Refresh this branch using new information in b This function is called by TTree::Refresh. ;  ; virtual void ResetReadEntry ();  ; virtual void SetAutoDelete (bool autodel=true);  Set the automatic delete bit. ;  ; virtual void SetBufferAddress (TBuffer *entryBuffer);  Set address of this branch directly from a TBuffer to avoid streaming. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  Set compression algorithm. ;  ; void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  Set compression level. ;  ; void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Set compression settings. ;  ; virtual void SetEntries (Long64_t entries);  Set the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:12813,cache,cached,12813,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,2,['cache'],"['cache', 'cached']"
Performance," Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _doFloorGlobal = false;  Global flag for introducing floor at zero in pdf. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static Int_t _evalErrorCount = 0;  ; static std::map< const RooAbsArg *, std::pair< std::string, std::list< EvalError > > > _evalErrorList;  ; static ErrorLoggingMode _evalErrorMode = RooAbsReal::PrintErrors;  ; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Private Member Functions; void setExtended (bool extended);  . Static Private Member Functions; static double analyticalIntegralWN (RooAbsReal const &caller, RooObjCacheManager &normIntMgr, RooArgList const &funcList, RooArgList const &coefList, Int_t code, const RooArgSet *normSet, const char *rangeName, bool hasWarnedBefore);  ; static std::list< double > * binBoundaries (RooArgList const &funcList, RooAbsRealLValue &, double, double);  ; static bool checkObservables (RooAbsReal const &caller, RooArgSet const *nset, RooArgList const &funcList, RooArgList const &coefList);  ; static double evaluate (RooAbsReal const &caller, RooArgList const &funcList, RooArgList const &coefList, bool doFloor, bool &hasWarnedBefore);  ; static Int_t getAnalyticalIntegralWN (RooAbsReal const &caller, RooObjCacheManage",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumPdf.html:66310,cache,cache,66310,doc/v632/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumPdf.html,1,['cache'],['cache']
Performance," ShowBackground (Int_t niter=20, Option_t *option=""same"") override;  This function calculates the background spectrum in this histogram. ;  ; Int_t ShowPeaks (Double_t sigma=2, Option_t *option="""", Double_t threshold=0.05) override;  Interface to TSpectrum2::Search the function finds peaks in this histogram where the width is > sigma and the peak maximum greater than threshold*maximum bin content of this. ;  ; void Smooth (Int_t ntimes=1, Option_t *option="""") override;  Smooth bin contents of this 2-d histogram using kernel algorithms similar to the ones used in the raster graphics community. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TH1;  ~TH1 () override;  Histogram default destructor. ;  ; virtual Bool_t Add (const TH1 *h, const TH1 *h2, Double_t c1=1, Double_t c2=1);  Replace contents of this histogram by the addition of h1 and h2. ;  ; virtual Bool_t Add (const TH1 *h1, Double_t c1=1);  Performs the operation: this = this + c1*h1 If errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual Bool_t Add (TF1 *h1, Double_t c1=1, Option_t *option="""");  Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2), errors are also recalculated. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Double_t &advalue) const;  Same function as above but returning also the test statistic value. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Option_t *option="""") const;  Statistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling 2 sample test. ;  ; void Browse (TBrowser *b) override;  Browse the Histogram object. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for comparing weighted and unweighted histograms. ;  ; virtual Double_t Chi2TestX (const TH",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2C.html:11659,Perform,Performs,11659,doc/master/classTH2C.html,https://root.cern,https://root.cern/doc/master/classTH2C.html,6,['Perform'],['Performs']
Performance," StreamerNVirtual(). void TVirtualStreamerInfo::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 216 of file TVirtualStreamerInfo.h. ◆ TagFile(). virtual void TVirtualStreamerInfo::TagFile ; (; TFile * ; fFile). pure virtual . Implemented in TStreamerInfo. ◆ Update(). virtual void TVirtualStreamerInfo::Update ; (; const TClass * ; oldClass, . TClass * ; newClass . ). pure virtual . Implemented in TStreamerInfo. Member Data Documentation. ◆ fgCanDelete. Bool_t TVirtualStreamerInfo::fgCanDelete = kTRUE. staticprotected . true if the StreamerInfo has been compiled (i.e. fully built, ready to use for streaming). ; Definition at line 52 of file TVirtualStreamerInfo.h. ◆ fgInfoFactory. TVirtualStreamerInfo * TVirtualStreamerInfo::fgInfoFactory = nullptr. staticprotected . Definition at line 55 of file TVirtualStreamerInfo.h. ◆ fgOptimize. Bool_t TVirtualStreamerInfo::fgOptimize = kTRUE. staticprotected . Definition at line 53 of file TVirtualStreamerInfo.h. ◆ fgStreamMemberWise. Bool_t TVirtualStreamerInfo::fgStreamMemberWise = kTRUE. staticprotected . Definition at line 54 of file TVirtualStreamerInfo.h. ◆ fIsBuilt. Bool_t TVirtualStreamerInfo::fIsBuilt. protected . true if the StreamerInfo has been optimized ; Definition at line 48 of file TVirtualStreamerInfo.h. ◆ fIsCompiled. std::atomic<Bool_t> TVirtualStreamerInfo::fIsCompiled. protected . true if the StreamerInfo has been 'built' (i.e. has all the StreamerElements it should have) ; Definition at line 49 of file TVirtualStreamerInfo.h. ◆ fOptimized. Bool_t TVirtualStreamerInfo::fOptimized. protected . Definition at line 47 of file TVirtualStreamerInfo.h. Libraries for TVirtualStreamerInfo:. [legend]; The documentation for this class was generated from the following files:; core/meta/inc/TVirtualStreamerInfo.h; core/meta/src/TVirtualStreamerInfo.cxx. TVirtualStreamerInfo. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:46 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualStreamerInfo.html:35023,optimiz,optimized,35023,doc/master/classTVirtualStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTVirtualStreamerInfo.html,1,['optimiz'],['optimized']
Performance," TEveCalo3D (TEveCaloData *d=nullptr, const char *n=""TEveCalo3D"", const char *t=""xx"");  Constructor. ;  ;  ~TEveCalo3D () override;  ; void ComputeBBox () override;  Fill bounding-box information of the base-class TAttBBox (virtual method). ;  ; Char_t GetFrameTransparency () const;  ; Float_t GetFrameWidth () const;  ; Bool_t GetRnrBarrelFrame () const;  ; Bool_t GetRnrEndCapFrame () const;  ; void GetRnrFrame (Bool_t &e, Bool_t &b) const;  ; TClass * IsA () const override;  ; void SetFrameTransparency (Char_t x);  ; void SetFrameWidth (Float_t w);  ; void SetRnrBarrelFrame (Bool_t r);  ; void SetRnrEndCapFrame (Bool_t r);  ; void SetRnrFrame (Bool_t e, Bool_t b);  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TEveCaloViz;  TEveCaloViz (TEveCaloData *data=nullptr, const char *n=""TEveCaloViz"", const char *t="""");  ;  ~TEveCaloViz () override;  Destructor. ;  ; Bool_t AssertCellIdCache () const;  Assert cell id cache is ok. ;  ; TEveRGBAPalette * AssertPalette ();  Make sure the TEveRGBAPalette pointer is not null. ;  ; Bool_t CellInEtaPhiRng (TEveCaloData::CellData_t &) const;  Returns true if given cell is in the ceta phi range. ;  ; virtual void CellSelectionChanged ();  ; void DataChanged ();  Update setting and cache on data changed. ;  ; TEveElement * ForwardEdit () override;  Management of selection state and ownership of selected cell list is done in TEveCaloData. ;  ; TEveElement * ForwardSelection () override;  Management of selection state and ownership of selected cell list is done in TEveCaloData. ;  ; Bool_t GetAutoRange () const;  ; Float_t GetBackwardEndCapPos () const;  ; Float_t GetBarrelRadius () const;  ; TEveCaloData * GetData () const;  ; Color_t GetDataSliceColor (Int_t slice) const;  Get slice color from data. ;  ; Float_t GetDataSliceThreshold (Int_t slice) const;  Get threshold for given slice. ;  ; Float_t GetEndCapPos () const;  ; Float_t GetE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveCalo3D.html:1526,cache,cache,1526,doc/master/classTEveCalo3D.html,https://root.cern,https://root.cern/doc/master/classTEveCalo3D.html,1,['cache'],['cache']
Performance," Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; bool CreateMinimizer ();  internal function to create the minimizer for finding the contours ;  ; void ResetLimits ();  reset the cached limit values ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Attributes; RooArgSet * fBestFitParams;  snapshot of the model parameters with best fit value (managed internally) ;  ; double fConfidenceLevel;  Requested confidence level (eg. 0.95 for 95% CL) ;  ; std::shared_ptr< RooFunctor > fFunctor;  ! transient pointer to functor class used by the minimizer ;  ; RooAbsReal * fLikelihoodRatio;  likelihood ratio function used to make contours (managed internally) ;  ; std::map< std::string, double > fLowerLimits;  map with cached lower bound values ;  ; std::shared_ptr< ROOT::Math::IMultiGenFunction > fMinFunc;  ! transient pointer to the minimization function ;  ; std::shared_ptr< ROOT::Math::Minimizer > fMinimizer;  ! transient pointer to minimizer class used to find limits and contour ;  ; RooArgSet fParameters;  parameters of interest for this interval ;  ; std::map< std::string, double > fUpperLimits;  map with cached upper bound values ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1LikelihoodInterval.html:14906,cache,cached,14906,doc/master/classRooStats_1_1LikelihoodInterval.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1LikelihoodInterval.html,2,['cache'],['cached']
Performance," Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Types; enum  IntOperMode { Hybrid; , Analytic; , PassThrough; };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; RooArgSet const * actualFuncNormSet () const;  ; void autoSelectDirtyMode ();  Set appropriate cache operation mode for integral depending on cache operation mode of server objects. ;  ; double evaluate () const override;  Perform the integration and return the result. ;  ; bool initNumIntegrator () const;  (Re)Initialize numerical integration engine if necessary. ;  ; virtual double integrate () const;  Perform hybrid numerical/analytical integration over all real-valued dependents. ;  ; bool isValidReal (double value, bool printError=false) const override;  Check if current value is valid. ;  ; virtual double jacobianProduct () const;  Return product of jacobian terms originating from analytical integration. ;  ; const RooArgSet & parameters () const;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursive) override;  Intercept server redirects and reconfigure internal object accordingly. ;  ; virtual double sum () const;  Perform summation of list of category dependents to be integrated. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of gi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:49811,Perform,Perform,49811,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,1,['Perform'],['Perform']
Performance," TypeInfo_RefType(). int TCling::TypeInfo_RefType ; (; TypeInfo_t * ; tinfo); const. finalvirtual . Reimplemented from TInterpreter.; Definition at line 9404 of file TCling.cxx. ◆ TypeInfo_Size(). int TCling::TypeInfo_Size ; (; TypeInfo_t * ; tinfo); const. finalvirtual . Reimplemented from TInterpreter.; Definition at line 9412 of file TCling.cxx. ◆ TypeInfo_TrueName(). const char * TCling::TypeInfo_TrueName ; (; TypeInfo_t * ; tinfo); const. finalvirtual . Reimplemented from TInterpreter.; Definition at line 9420 of file TCling.cxx. ◆ TypeName(). const char * TCling::TypeName ; (; const char * ; typeDesc). finalvirtual . Return the absolute type of typeDesc. ; E.g.: typeDesc = ""class TNamed**"", returns ""TNamed"". You need to use the result immediately before it is being overwritten. ; Implements TInterpreter.; Definition at line 5478 of file TCling.cxx. ◆ UnloadAllSharedLibraryMaps(). Int_t TCling::UnloadAllSharedLibraryMaps ; (; ). finalvirtual . Unload the library map entries coming from all the loaded shared libraries. ; Returns 0 if succesful ; Implements TInterpreter.; Definition at line 5998 of file TCling.cxx. ◆ UnloadFile(). int TCling::UnloadFile ; (; const char * ; path); const. finalvirtual . Reimplemented from TInterpreter.; Definition at line 7648 of file TCling.cxx. ◆ UnloadLibraryMap(). Int_t TCling::UnloadLibraryMap ; (; const char * ; library). finalvirtual . Unload library map entries coming from the specified library. ; Returns -1 in case no entries for the specified library were found, 0 otherwise. ; Implements TInterpreter.; Definition at line 6016 of file TCling.cxx. ◆ UnRegisterTClassUpdate(). void TCling::UnRegisterTClassUpdate ; (; const TClass * ; oldcl). finalvirtual . If the dictionary is loaded, we can remove the class from the list (otherwise the class might be loaded twice). ; Implements TInterpreter.; Definition at line 2393 of file TCling.cxx. ◆ UpdateAllCanvases(). void TCling::UpdateAllCanvases ; (; ). static . Update all canvases",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:139582,load,loaded,139582,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['load'],['loaded']
Performance," USA_IN_PORT_UNSAFE(s)   ((s)->sin.sin_port);  ; #define UTF8_PATH_MAX   (PATH_MAX);  ; #define va_copy(x, y)   ((x) = (y));  ; #define vsnprintf_impl   vsnprintf;  ; #define WIN32_LEAN_AND_MEAN;  ; #define WINCDECL;  . Typedefs; typedef const void * SOCK_OPT_TYPE;  ; typedef int SOCKET;  ; typedef int volatile stop_flag_t;  . Enumerations; enum  { ;   LISTENING_PORTS; , NUM_THREADS; , RUN_AS_USER; , CONFIG_TCP_NODELAY; , ;   MAX_REQUEST_SIZE; , LINGER_TIMEOUT; , CONNECTION_QUEUE_SIZE; , LISTEN_BACKLOG_SIZE; , ;   THROTTLE; , ENABLE_KEEP_ALIVE; , REQUEST_TIMEOUT; , KEEP_ALIVE_TIMEOUT; , ;   DECODE_URL; , DECODE_QUERY_STRING; , DOCUMENT_ROOT; , ACCESS_LOG_FILE; , ;   ERROR_LOG_FILE; , CGI_EXTENSIONS; , CGI_ENVIRONMENT; , CGI_INTERPRETER; , ;   CGI_INTERPRETER_ARGS; , CGI2_EXTENSIONS; , CGI2_ENVIRONMENT; , CGI2_INTERPRETER; , ;   CGI2_INTERPRETER_ARGS; , PUT_DELETE_PASSWORDS_FILE; , PROTECT_URI; , AUTHENTICATION_DOMAIN; , ;   ENABLE_AUTH_DOMAIN_CHECK; , SSI_EXTENSIONS; , ENABLE_DIRECTORY_LISTING; , GLOBAL_PASSWORDS_FILE; , ;   INDEX_FILES; , ACCESS_CONTROL_LIST; , EXTRA_MIME_TYPES; , SSL_CERTIFICATE; , ;   SSL_CERTIFICATE_CHAIN; , URL_REWRITE_PATTERN; , HIDE_FILES; , SSL_DO_VERIFY_PEER; , ;   SSL_CACHE_TIMEOUT; , SSL_CA_PATH; , SSL_CA_FILE; , SSL_VERIFY_DEPTH; , ;   SSL_DEFAULT_VERIFY_PATHS; , SSL_CIPHER_LIST; , SSL_PROTOCOL_VERSION; , SSL_SHORT_TRUST; , ;   ACCESS_CONTROL_ALLOW_ORIGIN; , ACCESS_CONTROL_ALLOW_METHODS; , ACCESS_CONTROL_ALLOW_HEADERS; , ACCESS_CONTROL_ALLOW_CREDENTIALS; , ;   ERROR_PAGES; , STATIC_FILE_MAX_AGE; , STATIC_FILE_CACHE_CONTROL; , STRICT_HTTPS_MAX_AGE; , ;   ADDITIONAL_HEADER; , ALLOW_INDEX_SCRIPT_SUB_RES; , NUM_OPTIONS. };  ; enum  { REQUEST_HANDLER; , WEBSOCKET_HANDLER; , AUTH_HANDLER; };  ; enum  { CONTEXT_INVALID; , CONTEXT_SERVER; , CONTEXT_HTTP_CLIENT; , CONTEXT_WS_CLIENT; };  ; enum  { CONNECTION_TYPE_INVALID = 0; , CONNECTION_TYPE_REQUEST = 1; , CONNECTION_TYPE_RESPONSE = 2; };  ; enum  { PROTOCOL_TYPE_HTTP1 = 0; , PROTOCOL_TYPE_WEBSO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c.html:5589,THROTTLE,THROTTLE,5589,doc/master/civetweb_8c.html,https://root.cern,https://root.cern/doc/master/civetweb_8c.html,1,['THROTTLE'],['THROTTLE']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBCPEffDecay.html:66743,cache,cache,66743,doc/master/classRooBCPEffDecay.html,https://root.cern,https://root.cern/doc/master/classRooBCPEffDecay.html,6,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNDKeysPdf.html:77334,cache,cache,77334,doc/master/classRooNDKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRooNDKeysPdf.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from RooAbsCachedPdf; using CacheElem = PdfCacheElem;  ;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedPdf.html:73138,cache,cache,73138,doc/master/classRooCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooCachedPdf.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Ac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooArgusBG.html:70025,cache,cache,70025,doc/master/classRooArgusBG.html,https://root.cern,https://root.cern/doc/master/classRooArgusBG.html,33,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddition.html:56790,cache,cache,56790,doc/master/classRooAddition.html,https://root.cern,https://root.cern/doc/master/classRooAddition.html,38,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class CacheElem;  ; class Grid2;  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMomentMorphFuncND.html:59447,cache,cache,59447,doc/master/classRooMomentMorphFuncND.html,https://root.cern,https://root.cern/doc/master/classRooMomentMorphFuncND.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class CacheElem;  Current normalization set. ;  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMomentMorph.html:72311,cache,cache,72311,doc/master/classRooMomentMorph.html,https://root.cern,https://root.cern/doc/master/classRooMomentMorph.html,2,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class MorphCacheElem;  . Additional Inherited Members;  Public Types inherited from RooAbsCachedPdf; using CacheElem = PdfCacheElem;  ;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Typ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooIntegralMorph.html:76983,cache,cache,76983,doc/master/classRooIntegralMorph.html,https://root.cern,https://root.cern/doc/master/classRooIntegralMorph.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class RICacheElem;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumRunningInt.html:59424,cache,cache,59424,doc/master/classRooNumRunningInt.html,https://root.cern,https://root.cern/doc/master/classRooNumRunningInt.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class RooAbsAnaConvPdf;  ; class RooAddModel;  ; class RooConvGenContext;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooResolutionModel.html:72711,cache,cache,72711,doc/master/classRooResolutionModel.html,https://root.cern,https://root.cern/doc/master/classRooResolutionModel.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class RooAbsTestStatistic;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  Op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealMPFE.html:56773,cache,cache,56773,doc/master/classRooRealMPFE.html,https://root.cern,https://root.cern/doc/master/classRooRealMPFE.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class RooAddGenContext;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:75086,cache,cache,75086,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class RooConvGenContext;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , N",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvPdf.html:72676,cache,cache,72676,doc/master/classRooNumConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooNumConvPdf.html,2,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class RooConvGenContext;  ; class RooNumConvPdf;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueCha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvolution.html:60870,cache,cache,60870,doc/master/classRooNumConvolution.html,https://root.cern,https://root.cern/doc/master/classRooNumConvolution.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Friends; class RooHistConstraint;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  Oper",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooParamHistFunc.html:57118,cache,cache,57118,doc/master/classRooParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooParamHistFunc.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Attributes; RooObjCacheManager _cacheMgr;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , No",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooJeffreysPrior.html:70194,cache,cache,70194,doc/master/classRooJeffreysPrior.html,https://root.cern,https://root.cern/doc/master/classRooJeffreysPrior.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Attributes; bool _disableCache = false;  Flag to run object in passthrough (= non-caching mode) ;  . Friends; class PdfCacheElem;  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedPdf.html:74542,cache,cache,74542,doc/master/classRooAbsCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedPdf.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Attributes; bool _disableCache;  . Friends; class FuncCacheElem;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedReal.html:58522,cache,cache,58522,doc/master/classRooAbsCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedReal.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Attributes; bool _doFast = false;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVoigtian.html:70595,cache,cache,70595,doc/master/classRooVoigtian.html,https://root.cern,https://root.cern/doc/master/classRooVoigtian.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; double g (double x, double sigma) const;  . Private Attributes; bool _asymLeft = false;  ; bool _asymRight = false;  ; double _binWidth;  ; double * _dataPts = nullptr;  ; double * _dataWgts = nullptr;  ; double _hi;  ; double _lo;  ; double _lookupTable [_nPoints+1];  ; bool _mirrorLeft = false;  ; bool _mirrorRight = false;  ; Int_t _nEvents = 0;  ; double _rho;  ; double _sumWgt = 0.0;  ; Char_t _varName [128];  ; double * _weights = nullptr;  . Static Private Attributes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooKeysPdf.html:72436,cache,cache,72436,doc/master/classRooKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRooKeysPdf.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; void finalizeConstruction ();  ; std::pair< const RooArgSet *, AddCacheElem * > getNormAndCache (const RooArgSet *nset) const;  Look up projection cache and per-PDF norm sets. ;  ; void materializeRefCoefNormFromAttribute () const;  ; void setAllExtendable (bool allExtendable);  ; void setRecursiveFraction (bool recursiveFraction);  . Private Attributes; std::unique_ptr< const RooArgSet > _copyOfLastNormSet = nullptr;  ! ;  ; RooFit::UniqueId< RooArgSet >::Value_t _idOfLast",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddPdf.html:73864,cache,cache,73864,doc/master/classRooAddPdf.html,https://root.cern,https://root.cern/doc/master/classRooAddPdf.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; void initializeOwnedDataHist (std::unique_ptr< RooDataHist > &&dataHist);  . Friends; class RooAbsCachedReal;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistFunc.html:58897,cache,cache,58897,doc/master/classRooHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooHistFunc.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; void initializeOwnedDataHist (std::unique_ptr< RooDataHist > &&dataHist);  . Static Private Member Functions; static double analyticalIntegral (Int_t code, const char *rangeName, RooArgSet const &histObsList, RooArgSet const &pdfObsList, RooDataHist &dataHist, bool histFuncMode);  ; static bool forceAnalyticalInt (RooArgSet const &pdfObsList, RooAbsArg const &dep);  ; static Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName, RooArgS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistPdf.html:71801,cache,cache,71801,doc/master/classRooHistPdf.html,https://root.cern,https://root.cern/doc/master/classRooHistPdf.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; void prepareFFTBinning (RooRealVar &convVar) const;  Try to improve the binning and inform user if possible. ;  . Friends; class FFTCacheElem;  ; class RooConvGenContext;  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:81945,cache,cache,81945,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions;  RooSimultaneous (const char *name, const char *title, InitializationOutput &&initInfo);  Private internal constructor. ;  . Static Private Member Functions; static std::unique_ptr< RooSimultaneous::InitializationOutput > initialize (std::string const &name, RooAbsCategoryLValue &inIndexCat, std::map< std::string, RooAbsPdf * > const &pdfMap);  . Private Attributes; std::unique_ptr< RooArgSet > _indexCatSet;  ! Index category wrapped in a RooArgSet if needed internally ;  .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimultaneous.html:74207,cache,cache,74207,doc/master/classRooSimultaneous.html,https://root.cern,https://root.cern/doc/master/classRooSimultaneous.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Private Member Functions; static NumBins getNumBinsPerDim (RooArgSet const &vars);  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classParamHistFunc.html:59582,cache,cache,59582,doc/master/classParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Private Member Functions; static void doEvalImpl (RooAbsArg const *caller, RooFit::EvalContext &, RooAbsReal const &x, RooArgList const &coefs, int lowestOrder);  ; static void fillCoeffValues (std::vector< double > &wksp, RooListProxy const &coefList);  . Friends; class RooPolynomial;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooPolyVar.html:56517,cache,cache,56517,doc/master/classRooPolyVar.html,https://root.cern,https://root.cern/doc/master/classRooPolyVar.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static Int_t _cacheAllNDim;  ! Cache all integrals with given numeric dimension ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:59987,cache,cache,59987,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static RooArgSet _emptySet;  Supports named argument constructor. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:64660,cache,cache,64660,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static RooCategory * _dummyBlindState = nullptr;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Additional ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsHiddenReal.html:57350,cache,cache,57350,doc/master/classRooAbsHiddenReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsHiddenReal.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:77309,cache,cache,77309,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _doFloorGlobal = false;  Global flag for introducing floor at zero in pdf. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _ve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealSumPdf.html:63932,cache,cache,63932,doc/master/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/master/classRooRealSumPdf.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _doFloorGlobal = false;  Global flag for introducing floor at zero in pdf. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealSumFunc.html:50047,cache,cache,50047,doc/master/classRooRealSumFunc.html,https://root.cern,https://root.cern/doc/master/classRooRealSumFunc.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Private Member Functions; double _DEBUG_getVal (const RooArgSet *normalisationSet) const;  Debug version of getVal(), w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:58779,cache,cache,58779,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _printScientific;  ; static Int_t _printSigDigits;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:70003,cache,cache,70003,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrint",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBernstein.html:73235,cache,cache,73235,doc/master/classRooBernstein.html,https://root.cern,https://root.cern/doc/master/classRooBernstein.html,17,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooAbsRealLValue.h>. Inheritance diagram for RooAbsRealLValue:. This browser is no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsRealLValue.html:66942,cache,cache,66942,doc/master/classRooAbsRealLValue.html,https://root.cern,https://root.cern/doc/master/classRooAbsRealLValue.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooBinWidthFunction.h>. Inheritance diagram for RooBinWidthFunction:. This browser",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinWidthFunction.html:59497,cache,cache,59497,doc/master/classRooBinWidthFunction.html,https://root.cern,https://root.cern/doc/master/classRooBinWidthFunction.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooConstVar.h>. Inheritance diagram for RooConstVar:. This browser is not able to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooConstVar.html:58640,cache,cache,58640,doc/master/classRooConstVar.html,https://root.cern,https://root.cern/doc/master/classRooConstVar.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooFit/TestStatistics/RooRealL.h>. Inheritance diagram for RooFit::TestStatistics:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFit_1_1TestStatistics_1_1RooRealL.html:59313,cache,cache,59313,doc/master/classRooFit_1_1TestStatistics_1_1RooRealL.html,https://root.cern,https://root.cern/doc/master/classRooFit_1_1TestStatistics_1_1RooRealL.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooFormulaVar.h>. Inheritance diagram for RooFormulaVar:. This browser is not able",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFormulaVar.html:61496,cache,cache,61496,doc/master/classRooFormulaVar.html,https://root.cern,https://root.cern/doc/master/classRooFormulaVar.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooLagrangianMorphFunc.h>. Inheritance diagram for RooLagrangianMorphFunc:. This b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLagrangianMorphFunc.html:69616,cache,cache,69616,doc/master/classRooLagrangianMorphFunc.html,https://root.cern,https://root.cern/doc/master/classRooLagrangianMorphFunc.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooLinearCombination.h>. Inheritance diagram for RooLinearCombination:. This brows",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLinearCombination.html:58920,cache,cache,58920,doc/master/classRooLinearCombination.html,https://root.cern,https://root.cern/doc/master/classRooLinearCombination.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooMultiBinomial.h>. Inheritance diagram for RooMultiBinomial:. This browser is no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMultiBinomial.html:59565,cache,cache,59565,doc/master/classRooMultiBinomial.html,https://root.cern,https://root.cern/doc/master/classRooMultiBinomial.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooNumCdf.h>. Inheritance diagram for RooNumCdf:. This browser is not able to show",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumCdf.html:62808,cache,cache,62808,doc/master/classRooNumCdf.html,https://root.cern,https://root.cern/doc/master/classRooNumCdf.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooSpHarmonic.h>. Inheritance diagram for RooSpHarmonic:. This browser is not able",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSpHarmonic.html:60883,cache,cache,60883,doc/master/classRooSpHarmonic.html,https://root.cern,https://root.cern/doc/master/classRooSpHarmonic.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooSpline.h>. Inheritance diagram for RooSpline:. This browser is not able to show",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSpline.html:60498,cache,cache,60498,doc/master/classRooSpline.html,https://root.cern,https://root.cern/doc/master/classRooSpline.html,1,['cache'],['cache']
Performance," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooStepFunction.h>. Inheritance diagram for RooStepFunction:. This browser is not ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStepFunction.html:59253,cache,cache,59253,doc/master/classRooStepFunction.html,https://root.cern,https://root.cern/doc/master/classRooStepFunction.html,1,['cache'],['cache']
Performance," _varsNoWgt;  Vars without weight variable. ;  ; RooRealVar * _wgtVar = nullptr;  Pointer to weight variable (if set) ;  ;  Protected Attributes inherited from RooAbsData; RooArgSet _cachedVars;  ! External variables cached with this data set ;  ; std::unique_ptr< RooAbsDataStore > _dstore;  Data storage implementation. ;  ; std::unique_ptr< RooArgSet > _globalObservables;  Snapshot of global observables. ;  ; const TNamed * _namePtr = nullptr;  ! De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; std::map< std::string, RooAbsData * > _ownedComponents;  Owned external components. ;  ; RooArgSet _vars;  Dimensions of this data set. ;  ; StorageType storageType;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from RooDirItem; TDirectory * _dir {nullptr};  ! Associated directory ;  . Private Member Functions; void loadValuesFromSlices (RooCategory &indexCat, std::map< std::string, RooAbsData * > const &slices, const char *rangeName, RooFormulaVar const *cutVar, const char *cutSpec);  . Private Attributes; bool _doWeightErrorCheck {true};  ! When adding events with weights, check that weights can actually be stored. ;  ; unsigned short _errorMsgCount {0};  ! Counter to silence error messages when filling dataset. ;  ; std::unique_ptr< std::vector< double > > _sumW2Buffer;  ! Buffer for sumW2 in case a batch of values is requested. ;  . Friends; class RooProdGenContext;  . Additional Inherited Members;  Public Types inherited from RooAbsData; using CategorySpans = std::map< RooFit::Detail::DataKey, std::span< const RooAbsCategory::value_type > >;  ; enum  ErrorType { ;   Poisson; , SumW2; , None; , Auto; , ;   Expected. };  ; using RealSpans = std::map< RooFit::Detail::DataKey, std::span< const double > >;  ; enum  StorageType { Tree; , Vector; , Composite; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataSet.html:34495,load,loadValuesFromSlices,34495,doc/master/classRooDataSet.html,https://root.cern,https://root.cern/doc/master/classRooDataSet.html,1,['load'],['loadValuesFromSlices']
Performance," basic3d.C Show 3-D polylines and markers ;  canvas.C Example of primitives in a canvas ;  canvas2.C Example of canvas partitioning ;  compile.C This macro produces the flowchart of TFormula::Compile ;  crown.C Draw crowns ;  diamond.C Draw a diamond ;  earth.C This tutorial illustrates the special contour options ;  ellipse.C Draw ellipses ;  eval.C This macro produces the flowchart of TFormula::Eval ;  event.C Illustrate some basic primitives ;  feynman.C Draw Feynman diagrams ;  first.C Show some basic primitives ;  formula1.C Display interpreted functions ;  framework.C An example with basic graphics illustrating the Object Oriented User Interface of ROOT ;  gaxis.C Simple example illustrating how to draw TGaxis objects in various formats ;  gaxis2.C Example illustrating how to draw TGaxis with labels defined by a function ;  gaxis3.C Example illustrating how to modify individual labels of a TGaxis ;  graph_edit_playback.CThis macro plays a recorded ROOT session showing how to perform various interactive graphical editing operations ;  gtime.CExample of a graph of data moving in time ;  latex.C This macro draws 5 Latex-style formula in a canvas and prints the canvas as a Postscript file ;  latex2.C This macro draws 4 Latex-style formula in a canvas and prints the canvas as a Postscript file ;  latex3.C Example illustrating a TPaveText with Latex inside ;  latex4.C Draw the Greek letters as a table and save the result as GIF, PS, PDF and SVG files ;  latex5.C This draws the Mathematical Symbols letters as a table and save the result as GIF, PS, PDF and SVG files ;  mandelbrot.C Using TExec to handle keyboard events and TComplex to draw the Mandelbrot set ;  manyaxis.C Show several TGaxis formats ;  markerwarning.C This script illustrates the danger of using asymmetric symbols ;  mass_spectrum.C This macro makes use of some basic graphics primitives such as line, arrow and text ;  palettes.C This macro draws all the high definition palettes available in ROOT ;  pav",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:113832,perform,perform,113832,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,2,['perform'],['perform']
Performance, fFunctionNextIterator. Next_t TGenCollectionProxy::fFunctionNextIterator. protected . Definition at line 326 of file TGenCollectionProxy.h. ◆ fKey. Value* TGenCollectionProxy::fKey. protected . Descriptor of the key_type. ; Definition at line 313 of file TGenCollectionProxy.h. ◆ fName. std::string TGenCollectionProxy::fName. protected . Name of the class being proxied. ; Definition at line 299 of file TGenCollectionProxy.h. ◆ fNext. Method TGenCollectionProxy::fNext. protected . Container accessors: generic iteration: next. ; Definition at line 305 of file TGenCollectionProxy.h. ◆ fOnFileClass. TClass* TGenCollectionProxy::fOnFileClass. protected . On file class. ; Definition at line 322 of file TGenCollectionProxy.h. ◆ fPointers. Bool_t TGenCollectionProxy::fPointers. protected . Flag to indicate if containee has pointers (key or value) ; Definition at line 300 of file TGenCollectionProxy.h. ◆ fProxyKept. Proxies_t TGenCollectionProxy::fProxyKept. protected . Optimization: Keep proxies once they were created. ; Definition at line 318 of file TGenCollectionProxy.h. ◆ fProxyList. Proxies_t TGenCollectionProxy::fProxyList. protected . Stack of recursive proxies. ; Definition at line 317 of file TGenCollectionProxy.h. ◆ fReadMemberWise. TObjArray* TGenCollectionProxy::fReadMemberWise. mutableprotected . Array of bundle of TStreamerInfoActions to stream out (read) ; Definition at line 291 of file TGenCollectionProxy.h. ◆ fResize. Sizing_t TGenCollectionProxy::fResize. protected . Container accessors: resize container. ; Definition at line 303 of file TGenCollectionProxy.h. ◆ fSize. Method TGenCollectionProxy::fSize. protected . Container accessors: size of container. ; Definition at line 302 of file TGenCollectionProxy.h. ◆ fStaged. Staged_t TGenCollectionProxy::fStaged. protected . Optimization: Keep staged array once they were created. ; Definition at line 319 of file TGenCollectionProxy.h. ◆ fSTL_type. int TGenCollectionProxy::fSTL_type. protected . STL container typ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionProxy.html:30246,Optimiz,Optimization,30246,doc/master/classTGenCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionProxy.html,1,['Optimiz'],['Optimization']
Performance," fNMissReadOk. Int_t TTreeCache::fNMissReadOk {0}. protected . Number of blocks read, not found in the primary cache, and found in the secondary cache. ; Definition at line 46 of file TTreeCache.h. ◆ fNMissReadPref. Int_t TTreeCache::fNMissReadPref {0}. protected . Number of blocks read into the secondary (""miss"") cache. ; Definition at line 50 of file TTreeCache.h. ◆ fNReadMiss. Int_t TTreeCache::fNReadMiss {0}. protected . Number of blocks read and not found in the cache. ; Definition at line 47 of file TTreeCache.h. ◆ fNReadOk. Int_t TTreeCache::fNReadOk {0}. protected . Number of blocks read and found in the cache. ; Definition at line 45 of file TTreeCache.h. ◆ fNReadPref. Int_t TTreeCache::fNReadPref {0}. protected . Number of blocks that were prefetched. ; Definition at line 49 of file TTreeCache.h. ◆ fOneTime. bool TTreeCache::fOneTime {false}. protected . ! used in the learning phase ; Definition at line 57 of file TTreeCache.h. ◆ fOptimizeMisses. bool TTreeCache::fOptimizeMisses {false}. protected . ! true if we should optimize cache misses. ; Definition at line 72 of file TTreeCache.h. ◆ fPrefillType. EPrefillType TTreeCache::fPrefillType. protected . Whether a pre-filling is enabled (and if applicable which type) ; Definition at line 64 of file TTreeCache.h. ◆ fReadDirectionSet. bool TTreeCache::fReadDirectionSet {false}. protected . ! read direction established ; Definition at line 62 of file TTreeCache.h. ◆ fReverseRead. bool TTreeCache::fReverseRead {false}. protected . ! reading in reverse mode ; Definition at line 58 of file TTreeCache.h. ◆ fTree. TTree* TTreeCache::fTree {nullptr}. protected . ! pointer to the current Tree ; Definition at line 53 of file TTreeCache.h. Libraries for TTreeCache:. [legend]; The documentation for this class was generated from the following files:; tree/tree/inc/TTreeCache.h; tree/tree/src/TTreeCache.cxx. TTreeCache. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:39 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:56532,optimiz,optimize,56532,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,2,"['cache', 'optimiz']","['cache', 'optimize']"
Performance," fReceivedObject;  ; TSeqCollection * fRootFiles;  ; TSocket * fSocket;  ; TUrl fUrl;  ; TRemoteObject * fWorkingDir;  . Static Private Attributes; static Int_t fgPortAttempts = 100;  ; static Int_t fgPortLower = 49152;  ; static Int_t fgPortUpper = 65535;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TApplication;  TApplication ();  Default ctor. Can be used by classes deriving from TApplication. ;  ; virtual void Forum (const char *line);  The function ("".forum <type>"") submits a new post on the ROOT forum via web browser. ;  ; virtual void GitHub (const char *line);  The function ("".gh <type>"") submits a new issue on GitHub via web browser. ;  ; virtual void Help (const char *line);  The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxygen ("".help scope"" or "".help scope::member""). ;  ; virtual void LoadGraphicsLibs ();  Load shared libs necessary for graphics. ;  ; virtual void MakeBatch ();  Switch to batch mode. ;  ; virtual Longptr_t ProcessRemote (const char *line, Int_t *error=nullptr);  Process the content of a line starting with "".R"" (already stripped-off) The format is. ;  ; void SetSignalHandler (TSignalHandler *sh);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  ;  Static Protected Member Functions inherited from TApplication; static void Close (TApplication *app);  Static function used to close a remote application. ;  ; static TApplication * Open (const char *url, Int_t debug, const char *script);  Static function used to attach to an existing remote application or to start one. ;  ; static I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationRemote.html:20399,Load,LoadGraphicsLibs,20399,doc/master/classTApplicationRemote.html,https://root.cern,https://root.cern/doc/master/classTApplicationRemote.html,2,['Load'],"['Load', 'LoadGraphicsLibs']"
Performance," fill () override;  Forward fill request to appropriate subset. ;  ; void forceCacheUpdate () override;  ; virtual const RooArgSet * get () const;  ; const RooArgSet * get (Int_t index) const override;  Load the n-th data point (n='idx') in memory and return a pointer to the internal RooArgSet holding its coordinates. ;  ; virtual const RooArgSet * get (Int_t index) const=0;  ; RooAbsData::RealSpans getBatches (std::size_t first, std::size_t len) const override;  Retrieve batches for all observables in this data store. ;  ; std::span< const double > getWeightBatch (std::size_t first, std::size_t len) const override;  Get the weights of the events in the range [first, first+len). ;  ; bool hasFilledCache () const override;  ; RooCategory * index ();  ; TClass * IsA () const override;  ; bool isWeighted () const override;  ; void loadValues (const RooAbsDataStore *tds, const RooFormulaVar *select=nullptr, const char *rangeName=nullptr, std::size_t nStart=0, std::size_t nStop=std::numeric_limits< std::size_t >::max()) override;  ; RooAbsDataStore * merge (const RooArgSet &allvars, std::list< RooAbsDataStore * > dstoreList) override;  ; Int_t numEntries () const override;  ; void recalculateCache (const RooArgSet *, Int_t, Int_t, Int_t, bool) override;  Forward recalculate request to all subsets. ;  ; std::unique_ptr< RooAbsDataStore > reduce (RooStringView name, RooStringView title, const RooArgSet &vars, const RooFormulaVar *cutVar, const char *cutRange, std::size_t nStart, std::size_t nStop) override;  ; void reset () override;  ; void resetBuffers () override;  ; void resetCache () override;  ; void setArgStatus (const RooArgSet &set, bool active) override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; double sumEntries () const override;  Forward fill request to appropriate subset. ;  ; double weight () const override;  ; virtual double weight () const=0;  ; double we",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCompositeDataStore.html:3302,load,loadValues,3302,doc/master/classRooCompositeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooCompositeDataStore.html,1,['load'],['loadValues']
Performance," forceAnalyticalInt(). bool RooAddPdf::forceAnalyticalInt ; (; const RooAbsArg & ; ); const. inlineoverridevirtual . Force RooRealIntegral to offer all observables for internal integration. ; Reimplemented from RooAbsReal.; Definition at line 50 of file RooAddPdf.h. ◆ genContext(). RooAbsGenContext * RooAddPdf::genContext ; (; const RooArgSet & ; vars, . const RooDataSet * ; prototype = nullptr, . const RooArgSet * ; auxProto = nullptr, . bool ; verbose = false . ); const. overrideprotectedvirtual . Return specialized context to efficiently generate toy events from RooAddPdfs return RooAbsPdf::genContext(vars,prototype,auxProto,verbose) ; // WVE DEBUG. ; Reimplemented from RooAbsPdf.; Definition at line 901 of file RooAddPdf.cxx. ◆ getAnalyticalIntegralWN(). Int_t RooAddPdf::getAnalyticalIntegralWN ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Determine which part (if any) of given integral can be performed analytically. ; If any analytical integration is possible, return integration scenario code; RooAddPdf queries each component PDF for its analytical integration capability of the requested set ('allVars'). It finds the largest common set of variables that can be integrated by all components. If such a set exists, it reconfirms that each component is capable of analytically integrating the common set, and combines the components individual integration codes into a single integration code valid for RooAddPdf. ; Reimplemented from RooAbsReal.; Definition at line 631 of file RooAddPdf.cxx. ◆ getCoefNormalization(). const RooArgSet & RooAddPdf::getCoefNormalization ; (; ); const. Definition at line 335 of file RooAddPdf.cxx. ◆ getCoefRange(). const char * RooAddPdf::getCoefRange ; (; ); const. inline . Definition at line 83 of file RooAddPdf.h. ◆ getNormAndCache(). std::pair< const RooArgSet *, AddCacheElem * > RooAddPdf::getNormAndCache ; (; const RooArgSet * ; ns",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddPdf.html:87012,perform,performed,87012,doc/master/classRooAddPdf.html,https://root.cern,https://root.cern/doc/master/classRooAddPdf.html,2,['perform'],['performed']
Performance," kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TStreamerInfo ();  Status bits See TVirtualStreamerInfo::EStatusBits for the values. ;  ;  TStreamerInfo (TClass *cl);  Create a TStreamerInfo object. ;  ;  ~TStreamerInfo () override;  TStreamerInfo dtor. ;  ; void Build (Bool_t isTransient=kFALSE) override;  Build the I/O data structure for the current class version. ;  ; void BuildCheck (TFile *file=nullptr, Bool_t load=kTRUE) override;  Check if built and consistent with the class dictionary. ;  ; void BuildEmulated (TFile *file) override;  Create an Emulation TStreamerInfo object. ;  ; Bool_t BuildFor (const TClass *cl) override;  Check if we can build this for foreign class - do we have some rules to do that. ;  ; void BuildOld () override;  rebuild the TStreamerInfo structure ;  ; void CallShowMembers (const void *obj, TMemberInspector &insp, Bool_t isTransient) const override;  Emulated a call ShowMembers() on the obj of this class type, passing insp and parent. ;  ; void Clear (Option_t *="""") override;  If opt contains 'built', reset this StreamerInfo as if Build or BuildOld was never called on it (useful to force their re-running). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Bool_t CompareContent (TClass *cl, TVirtualStreamerInfo *info, Bool_t warn, Bool_t complete, TFile *file) override;  Return True if the current StreamerI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerInfo.html:3908,load,load,3908,doc/master/classTStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTStreamerInfo.html,1,['load'],['load']
Performance, wgtErrLoArray(). double const * RooDataHist::wgtErrLoArray ; (; ); const. inline . Definition at line 217 of file RooDataHist.h. Friends And Related Symbol Documentation. ◆ RooDataHistSliceIter. friend class RooDataHistSliceIter. friend . Definition at line 227 of file RooDataHist.h. Member Data Documentation. ◆ _arrSize. Int_t RooDataHist::_arrSize {0}. protected . Definition at line 246 of file RooDataHist.h. ◆ _binbounds. std::vector<std::vector<double> > RooDataHist::_binbounds. mutableprotected . ! list of bin bounds per dimension ; Definition at line 260 of file RooDataHist.h. ◆ _binv. double* RooDataHist::_binv {nullptr}. protected . [_arrSize] Bin volume array ; Definition at line 253 of file RooDataHist.h. ◆ _cache_sum. double RooDataHist::_cache_sum {0.}. mutableprotected . ! Cache for sum of entries ; ; Definition at line 264 of file RooDataHist.h. ◆ _cache_sum_valid. Int_t RooDataHist::_cache_sum_valid {kInvalid}. mutableprotected . ! Is cache sum valid? Needs to be Int_t instead of CacheSumState_t for subclasses. ; Definition at line 263 of file RooDataHist.h. ◆ _curIndex. ULong64_t RooDataHist::_curIndex {std::numeric_limits<ULong64_t>::max()}. mutableprotected . Current index. ; Definition at line 255 of file RooDataHist.h. ◆ _errHi. double* RooDataHist::_errHi {nullptr}. mutableprotected . [_arrSize] High-side error on weight array ; Definition at line 251 of file RooDataHist.h. ◆ _errLo. double* RooDataHist::_errLo {nullptr}. mutableprotected . [_arrSize] Low-side error on weight array ; Definition at line 250 of file RooDataHist.h. ◆ _idxMult. std::vector<Int_t> RooDataHist::_idxMult. protected . Definition at line 247 of file RooDataHist.h. ◆ _interpolationBuffer. std::vector<double> RooDataHist::_interpolationBuffer. private . ! Buffer to contain values used for weight interpolation ; Definition at line 280 of file RooDataHist.h. ◆ _lvbins. std::vector<std::unique_ptr<const RooAbsBinning> > RooDataHist::_lvbins. protected . ! List of used binning,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:87102,cache,cache,87102,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['cache'],['cache']
Performance,"  kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TVirtualStreamerInfo ();  Default constructor. ;  ;  TVirtualStreamerInfo (TClass *);  Default constructor. ;  ; virtual ~TVirtualStreamerInfo ();  Destructor. ;  ; virtual void Build (Bool_t isTransient=kFALSE)=0;  ; virtual void BuildCheck (TFile *file=nullptr, Bool_t load=kTRUE)=0;  ; virtual void BuildEmulated (TFile *file)=0;  ; virtual Bool_t BuildFor (const TClass *cl)=0;  ; virtual void BuildOld ()=0;  ; virtual void CallShowMembers (const void *obj, TMemberInspector &insp, Bool_t isTransient) const =0;  ; virtual void Clear (Option_t *="""") override=0;  Set name and title to empty strings (""""). ;  ; virtual Bool_t CompareContent (TClass *cl, TVirtualStreamerInfo *info, Bool_t warn, Bool_t complete, TFile *file)=0;  ; virtual void Compile ()=0;  ; virtual void DeleteArray (void *p, Bool_t dtorOnly=kFALSE)=0;  ; virtual void Destructor (void *p, Bool_t dtorOnly=kFALSE)=0;  ; virtual void ForceWriteInfo (TFile *file, Bool_t force=kFALSE)=0;  ; virtual TClassStreamer * GenEmulatedClassStreamer (const char *class_name, Bool_t silent)=0;  ; virtual TVirtualCollectionProxy * GenEmulatedProxy (const char *class_name, Bool_t silent)=0;  ; virtual Int_t GenerateHeaderFile (const char *dirname, const TList *subClasses=nullptr, const TList *extrainfos=nullptr)=0;  ; virtual TVirtualStreamerInfo * GenerateInfoForPair (const std::string &firstname, const std::string &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualStreamerInfo.html:2875,load,load,2875,doc/master/classTVirtualStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTVirtualStreamerInfo.html,1,['load'],['load']
Performance,"’ is appended, the shared library is also loaded.; root[] f.MakeProject(""MyProject"",""*"", ""recreate++""); MakeProject has generated 0 classes in MyProject; MyProject/MAKE file has been generated; Shared lib MyProject/MyProject.so has been generated; Shared lib MyProject/MyProject.so has been dynamically linked; The contents of MyProject:; root[] .! ls MyProject; ATLFCluster.h ATLFJet.h ATLFMiscMaker.h ATLFTrack.h; TMCParticle.h ATLFClusterMaker.h ATLFJetMaker.h ATLFMuon.h; ATLFElectron.h ATLFMCMaker.h ATLFMuonMaker.h ATLFElectronMaker.h; ATLFMaker.h ATLFPhoton.h ATLFHistBrowser.h ATLFMisc.h; ATLFPhotonMaker.h ATLFTrackMaker.h ATLFTrigger.h ATLFTriggerMaker.h; LinkDef.h MAKE MyProject.so MyProjectProjectDict.h; MyProjectProjectDict.cxx MyProjectProjectDict.o; Now you can load the shared library in any consecutive root session to use the atlfast classes.; root[]gSystem->Load(""MyProject/MyProject""); root[]ATLFMuon muon; This is an example of a generated header file:; //////////////////////////////////////////////////////////; // This class has been generated by TFile::MakeProject; // (Thu Apr 5 10:18:37 2001 by ROOT version 3.00/06); // from the TStreamerInfo in file atlfast.root; //////////////////////////////////////////////////////////; #ifndef ATLFMuon_h; #define ATLFMuon_h; #include ""TObject.h""; #include ""TAtt3D.h""; class ATLFMuon : public TObject , public TAtt3D {; public:; Int_t m_KFcode; //Muon KF-code; Int_t m_MCParticle; //Muon position in MCParticles list; Int_t m_KFmother; //Muon mother KF-code; Int_t m_UseFlag; //Muon energy usage flag; Int_t m_Isolated; //Muon isolation (1 for isolated); Float_t m_Eta; //Eta coordinate; Float_t m_Phi; //Phi coordinate; Float_t m_PT; //Transverse energy; Int_t m_Trigger; //Result of trigger; ATLFMuon() {;}; virtual ~ATLFMuon() {;}; ClassDef(ATLFMuon,1) //; };; ClassImp(ATLFMuon); #endif; 11.6 Compression and Performance; ROOT uses a compression algorithm based on the well-known gzip algorithm. It supports nine levels of compr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:511516,Load,Load,511516,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Load'],['Load']
Performance,"’ sets On/Off the option “+”- add function to the list without deleting the previous one. When fitting a histogram, the function is attached to the histogram’s list of functions. By default, the previously fitted function is deleted and replaced with the most recent one, so the list only contains one function. Setting this option to On will add the newly fitted function to the existing list of functions for the histogram. Note that the fitted functions are saved with the histogram when it is written to a ROOT file. By default, the function is drawn on the pad displaying the histogram.; 5.6.3 Draw Options; ‘SAME’ sets On/Off function drawing on the same pad. When a fit is executed, the image of the function is drawn on the current pad.; ‘No drawing’ sets On/Off the option “0”- do not draw the fit results.; ‘Do not store/draw’ sets On/Off option “N”- do not store the function and do not draw it.; 5.6.4 Advances Options; The advance option button is enabled only after having performed the fit and provides additional drawing options that can be used after having done the fit. These new drawing tools, which can be selected by the “Advanced Drawing Tool” panel that pops up when clicking the “Advanced” button, are:. Contour: to plot the confidence contour of two chosen parameters. One can select the number of points to draw the contour (more points might require more time to compute it), the parameters and the desired confidence level .; Scan : to plot a scan of the minimization function (likelihood or chi-squared) around the minimum as function of the chosen parameter.; Conf Interval : to plot the confidence interval of the fitted function as a filled coloured band around its central value. One can select the desired confidence level for the band to be plotted. 5.6.5 Print Options; This set of options specifies the amount of feedback printed on the root command line after performed fits.; ‘Verbose’ - prints fit results after each iteration.; ‘Quiet’ - no fit information i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:186516,perform,performed,186516,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performed']
Performance,"◆ GetClass(). const char * TPluginHandler::GetClass ; (; ); const. inline . Definition at line 212 of file TPluginManager.h. ◆ GetCtor(). const char * TPluginHandler::GetCtor ; (; ); const. inlineprivate . Definition at line 139 of file TPluginManager.h. ◆ GetOrigin(). const char * TPluginHandler::GetOrigin ; (; ); const. inlineprivate . Definition at line 140 of file TPluginManager.h. ◆ GetPlugin(). const char * TPluginHandler::GetPlugin ; (; ); const. inlineprivate . Definition at line 138 of file TPluginManager.h. ◆ GetRegexp(). const char * TPluginHandler::GetRegexp ; (; ); const. inlineprivate . Definition at line 137 of file TPluginManager.h. ◆ IsA(). TClass * TPluginHandler::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 254 of file TPluginManager.h. ◆ LoadPlugin(). Int_t TPluginHandler::LoadPlugin ; (; ). Load the plugin library for this handler. ; Returns 0 on successful loading and -1 in case the library does not exist or in case of error. ; Definition at line 293 of file TPluginManager.cxx. ◆ LoadPluginImpl(). void TPluginHandler::LoadPluginImpl ; (; ). private . Load the plugin library for this handler. ; Sets status to 0 on successful loading and -1 in case the library does not exist or in case of error. ; Definition at line 274 of file TPluginManager.cxx. ◆ operator=(). TPluginHandler & TPluginHandler::operator= ; (; const TPluginHandler & ; ). privatedelete . ◆ Print(). void TPluginHandler::Print ; (; Option_t * ; opt = """"); const. overridevirtual . Print info about the plugin handler. ; If option is ""a"" print also the ctor's that will be used. ; Reimplemented from TObject.; Definition at line 341 of file TPluginManager.cxx. ◆ SetupCallEnv(). void TPluginHandler::SetupCallEnv ; (; ). private . Setup ctor or static method call environment. ; Definition at line 198 of file TPluginManager.cxx. ◆ Streamer(). void TPluginHandler::Streamer ; (; TBuffer & ; R__b). overridevi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPluginHandler.html:17153,load,loading,17153,doc/master/classTPluginHandler.html,https://root.cern,https://root.cern/doc/master/classTPluginHandler.html,1,['load'],['loading']
Performance,"◆ Init(). void TGTextView::Init ; (; Pixel_t ; bg). protected . Initialize a text view widget. ; Definition at line 73 of file TGTextView.cxx. ◆ IsA(). TClass * TGTextView::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGCompositeFrame.; Reimplemented in TGTextViewostream.; Definition at line 141 of file TGTextView.h. ◆ IsMarked(). Bool_t TGTextView::IsMarked ; (; ); const. inline . Definition at line 119 of file TGTextView.h. ◆ IsReadOnly(). Bool_t TGTextView::IsReadOnly ; (; ); const. inline . Definition at line 118 of file TGTextView.h. ◆ IsSaved(). virtual Bool_t TGTextView::IsSaved ; (; ). inlinevirtual . Definition at line 77 of file TGTextView.h. ◆ Layout(). void TGTextView::Layout ; (; ). overridevirtual . Layout the components of view. ; Reimplemented from TGCompositeFrame.; Definition at line 1329 of file TGTextView.cxx. ◆ LoadBuffer(). Bool_t TGTextView::LoadBuffer ; (; const char * ; txtbuf). virtual . Load text from a text buffer. Return false in case of failure. ; Definition at line 471 of file TGTextView.cxx. ◆ LoadFile(). Bool_t TGTextView::LoadFile ; (; const char * ; filename, . long ; startpos = 0, . long ; length = -1 . ). virtual . Load a file in the text view widget. ; Return false in case file does not exist. ; Definition at line 454 of file TGTextView.cxx. ◆ Mark(). void TGTextView::Mark ; (; Long_t ; xPos, . Long_t ; yPos . ). protectedvirtual . Mark a text region from xPos to yPos. ; Definition at line 1170 of file TGTextView.cxx. ◆ Marked(). virtual void TGTextView::Marked ; (; Bool_t ; mark). inlinevirtual . Definition at line 137 of file TGTextView.h. ◆ operator=(). TGTextView & TGTextView::operator= ; (; const TGTextView & ; ). privatedelete . ◆ ReturnHeighestColHeight(). virtual Long_t TGTextView::ReturnHeighestColHeight ; (; ). inlinevirtual . Definition at line 90 of file TGTextView.h. ◆ ReturnLineCount(). virtual Long_t TGTextView::ReturnLineCount ; (; ). inlinevirtual . Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextView.html:49041,Load,Load,49041,doc/master/classTGTextView.html,https://root.cern,https://root.cern/doc/master/classTGTextView.html,1,['Load'],['Load']
Performance,"◆ RooCachedReal() [3/4]. RooCachedReal::RooCachedReal ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; _func . ). Constructor taking name, title and function to be cached. ; To control granularity of the binning of the cache histogram set the desired properties in the binning named ""cache"" in the observables of the function ; Definition at line 42 of file RooCachedReal.cxx. ◆ RooCachedReal() [4/4]. RooCachedReal::RooCachedReal ; (; const RooCachedReal & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 87 of file RooCachedReal.cxx. Member Function Documentation. ◆ actualObservables(). RooFit::OwningPtr< RooArgSet > RooCachedReal::actualObservables ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . If this pdf is operated with a fixed set of observables, return the subset of the fixed observables that are actual dependents of the external input p.d.f. ; If this p.d.f is operated without a fixed set of cache observables, return the actual observables of the external input p.d.f given the choice of observables defined in nset ; Implements RooAbsCachedReal.; Definition at line 165 of file RooCachedReal.cxx. ◆ actualParameters(). RooFit::OwningPtr< RooArgSet > RooCachedReal::actualParameters ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . If this p.d.f is operated with a fixed set of observables, return all variables of the external input p.d.f that are not one of the cache observables. ; If this p.d.f is operated in automatic mode, return the parameters of the external input p.d.f ; Implements RooAbsCachedReal.; Definition at line 178 of file RooCachedReal.cxx. ◆ cacheSource(). bool RooCachedReal::cacheSource ; (; ); const. inline . Definition at line 42 of file RooCachedReal.h. ◆ Class(). static TClass * RooCachedReal::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooCachedReal::Class_Name ; (; ). static . ReturnsName of this class . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:65276,cache,cache,65276,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,1,['cache'],['cache']
Performance,"◆ SetBaggedSampleFraction(). void TMVA::MethodBDT::SetBaggedSampleFraction ; (; Double_t ; f). inline . Definition at line 143 of file MethodBDT.h. ◆ SetMaxDepth(). void TMVA::MethodBDT::SetMaxDepth ; (; Int_t ; d). inline . Definition at line 134 of file MethodBDT.h. ◆ SetMinNodeSize() [1/2]. void TMVA::MethodBDT::SetMinNodeSize ; (; Double_t ; sizeInPercent). Definition at line 660 of file MethodBDT.cxx. ◆ SetMinNodeSize() [2/2]. void TMVA::MethodBDT::SetMinNodeSize ; (; TString ; sizeInPercent). Definition at line 674 of file MethodBDT.cxx. ◆ SetNodePurityLimit(). void TMVA::MethodBDT::SetNodePurityLimit ; (; Double_t ; l). inline . Definition at line 140 of file MethodBDT.h. ◆ SetNTrees(). void TMVA::MethodBDT::SetNTrees ; (; Int_t ; d). inline . Definition at line 138 of file MethodBDT.h. ◆ SetShrinkage(). void TMVA::MethodBDT::SetShrinkage ; (; Double_t ; s). inline . Definition at line 141 of file MethodBDT.h. ◆ SetTuneParameters(). void TMVA::MethodBDT::SetTuneParameters ; (; std::map< TString, Double_t > ; tuneParameters). virtual . Set the tuning parameters according to the argument. ; Reimplemented from TMVA::MethodBase.; Definition at line 1121 of file MethodBDT.cxx. ◆ SetUseNvars(). void TMVA::MethodBDT::SetUseNvars ; (; Int_t ; n). inline . Definition at line 142 of file MethodBDT.h. ◆ Streamer(). virtual void TMVA::MethodBDT::Streamer ; (; TBuffer & ; ). virtual . Reimplemented from TMVA::MethodBase. ◆ StreamerNVirtual(). void TMVA::MethodBDT::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 305 of file MethodBDT.h. ◆ TestTreeQuality(). Double_t TMVA::MethodBDT::TestTreeQuality ; (; DecisionTree * ; dt). Test the tree quality.. in terms of Misclassification. ; Definition at line 1696 of file MethodBDT.cxx. ◆ Train(). void TMVA::MethodBDT::Train ; (; void ; ). virtual . BDT training. ; Implements TMVA::MethodBase.; Definition at line 1142 of file MethodBDT.cxx. ◆ UpdateTargets(). void TMVA::MethodBDT::UpdateTa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:58297,tune,tuneParameters,58297,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['tune'],['tuneParameters']
Performance,"◆ fNMissReadOk. Int_t TTreeCache::fNMissReadOk {0}. protected . Number of blocks read, not found in the primary cache, and found in the secondary cache. ; Definition at line 46 of file TTreeCache.h. ◆ fNMissReadPref. Int_t TTreeCache::fNMissReadPref {0}. protected . Number of blocks read into the secondary (""miss"") cache. ; Definition at line 50 of file TTreeCache.h. ◆ fNReadMiss. Int_t TTreeCache::fNReadMiss {0}. protected . Number of blocks read and not found in the cache. ; Definition at line 47 of file TTreeCache.h. ◆ fNReadOk. Int_t TTreeCache::fNReadOk {0}. protected . Number of blocks read and found in the cache. ; Definition at line 45 of file TTreeCache.h. ◆ fNReadPref. Int_t TTreeCache::fNReadPref {0}. protected . Number of blocks that were prefetched. ; Definition at line 49 of file TTreeCache.h. ◆ fOneTime. bool TTreeCache::fOneTime {false}. protected . ! used in the learning phase ; Definition at line 57 of file TTreeCache.h. ◆ fOptimizeMisses. bool TTreeCache::fOptimizeMisses {false}. protected . ! true if we should optimize cache misses. ; Definition at line 72 of file TTreeCache.h. ◆ fPrefillType. EPrefillType TTreeCache::fPrefillType. protected . Whether a pre-filling is enabled (and if applicable which type) ; Definition at line 64 of file TTreeCache.h. ◆ fReadDirectionSet. bool TTreeCache::fReadDirectionSet {false}. protected . ! read direction established ; Definition at line 62 of file TTreeCache.h. ◆ fReverseRead. bool TTreeCache::fReverseRead {false}. protected . ! reading in reverse mode ; Definition at line 58 of file TTreeCache.h. ◆ fTree. TTree* TTreeCache::fTree {nullptr}. protected . ! pointer to the current Tree ; Definition at line 53 of file TTreeCache.h. Libraries for TTreeCache:. [legend]; The documentation for this class was generated from the following files:; tree/tree/inc/TTreeCache.h; tree/tree/src/TTreeCache.cxx. TTreeCache. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:13:13 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:56462,optimiz,optimize,56462,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,"['cache', 'optimiz']","['cache', 'optimize']"
Performance,"������ bin = 1 + Int_t(a +; 0.5);�� ������������ ; ������� PosX[i] =; d->GetBinCenter(bin);; ������� PosY[i] =; d->GetBinContent(bin);; �� }; �� TPolyMarker * pm =; (TPolyMarker*)h->GetListOfFunctions()->FindObject(""TPolyMarker"");; �� if (pm) {; �����; h->GetListOfFunctions()->Remove(pm);; ����� delete pm;; �� }; �� pm = new; TPolyMarker(nfound, PosX, PosY);; ��; h->GetListOfFunctions()->Add(pm);; �� pm->SetMarkerStyle(23);; ��; pm->SetMarkerColor(kRed);; �� pm->SetMarkerSize(1);��. }. void SetFitParameters(Int_t xmin, Int_t xmax, Int_t numberIterations, Double_t alpha, Int_t statisticType, Int_t alphaOptim, Int_t power, Int_t fitTaylor). SETTER FUNCTION. This function sets the following fitting parameters:; -xmin, xmax - fitting region; -numberIterations - # of desired iterations in the fit; -alpha - convergence coefficient, it should be positive number and <=1, for details see references; -statisticType - type of statistics, possible values kFitOptimChiCounts (chi square statistics with counts as weighting coefficients), kFitOptimChiFuncValues (chi square statistics with function values as weighting coefficients),kFitOptimMaxLikelihood; -alphaOptim - optimization of convergence algorithm, possible values kFitAlphaHalving, kFitAlphaOptimal; -power - possible values kFitPower2,4,6,8,10,12, for details see references. It applies only for Awmi fitting function.; -fitTaylor - order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. void SetPeakParameters(Double_t sigma, Bool_t fixSigma, const Double_t* positionInit, const Bool_t* fixPosition, const Double_t* ampInit, const Bool_t* fixAmp). SETTER FUNCTION. This function sets the following fitting parameters of peaks:; -sigma - initial value of sigma parameter; -fixSigma - logical value of sigma parameter, which allows to fix the parameter (not to fit); -positionInit - aray of initial values of peaks positions; -fixPosition - array of logical value",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrumFit.html:36289,optimiz,optimization,36289,root/html602/TSpectrumFit.html,https://root.cern,https://root.cern/root/html602/TSpectrumFit.html,2,['optimiz'],['optimization']
Performance,"������ bin = 1 + Int_t(a +; 0.5);�� ������������ ; ������� PosX[i] =; d->GetBinCenter(bin);; ������� PosY[i] =; d->GetBinContent(bin);; �� }; �� TPolyMarker * pm =; (TPolyMarker*)h->GetListOfFunctions()->FindObject(""TPolyMarker"");; �� if (pm) {; �����; h->GetListOfFunctions()->Remove(pm);; ����� delete pm;; �� }; �� pm = new; TPolyMarker(nfound, PosX, PosY);; ��; h->GetListOfFunctions()->Add(pm);; �� pm->SetMarkerStyle(23);; ��; pm->SetMarkerColor(kRed);; �� pm->SetMarkerSize(1);��. }. void SetFitParameters(Int_t xmin, Int_t xmax, Int_t numberIterations, Double_t alpha, Int_t statisticType, Int_t alphaOptim, Int_t power, Int_t fitTaylor). SETTER FUNCTION. This function sets the following fitting parameters:; -xmin, xmax - fitting region; -numberIterations - # of desired iterations in the fit; -alpha - convergence coefficient, it should be positive number and <=1, for details see references; -statisticType - type of statistics, possible values kFitOptimChiCounts (chi square statistics with counts as weighting coefficients), kFitOptimChiFuncValues (chi square statistics with function values as weighting coefficients),kFitOptimMaxLikelihood; -alphaOptim - optimization of convergence algorithm, possible values kFitAlphaHalving, kFitAlphaOptimal; -power - possible values kFitPower2,4,6,8,10,12, for details see references. It applies only for Awmi fitting function.; -fitTaylor - order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. void SetPeakParameters(Double_t sigma, Bool_t fixSigma, const Float_t* positionInit, const Bool_t* fixPosition, const Float_t* ampInit, const Bool_t* fixAmp). SETTER FUNCTION. This function sets the following fitting parameters of peaks:; -sigma - initial value of sigma parameter; -fixSigma - logical value of sigma parameter, which allows to fix the parameter (not to fit); -positionInit - aray of initial values of peaks positions; -fixPosition - array of logical values ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrumFit.html:35243,optimiz,optimization,35243,root/html528/TSpectrumFit.html,https://root.cern,https://root.cern/root/html528/TSpectrumFit.html,4,['optimiz'],['optimization']
Safety," """") constMENU ; virtual Int_tTProofPlayer::SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayer::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayer::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayer::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayer::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerLocal(Bool_t client = kTRUE); TProofPlayerLocal(const TProofPlayerLocal&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerLocal.html:11345,timeout,timeout,11345,root/html602/TProofPlayerLocal.html,https://root.cern,https://root.cern/root/html602/TProofPlayerLocal.html,1,['timeout'],['timeout']
Safety," """") constMENU ; virtual Int_tTProofPlayer::SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayer::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayer::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayer::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayer::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerSlave(TSocket* socket = 0); TProofPlayerSlave(TProofPlayerSlave&&); TProofPlayerSlave(const TProofPlayerSlave&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerSlave.html:11201,timeout,timeout,11201,root/html602/TProofPlayerSlave.html,https://root.cern,https://root.cern/root/html602/TProofPlayerSlave.html,1,['timeout'],['timeout']
Safety," """");; 161 } else {; 162 if ((fBranch->GetListOfLeaves()->GetEntries() > 1) ||; 163 (strcmp(fBranch->GetName(), GetName()) != 0)) {; 164 TString name(fBranch->GetName());; 165 if (!name.EndsWith(""."")) name += ""."";; 166 name += GetName();; 167 fBranch->GetTree()->Draw(name, """", b ? b->GetDrawOption() : """");; 168 } else {; 169 fBranch->GetTree()->Draw(GetName(), """", b ? b->GetDrawOption() : """");; 170 }; 171 }; 172 if (gPad) {; 173 gPad->Update();; 174 }; 175}; 176 ; 177////////////////////////////////////////////////////////////////////////////////; 178/// Pack leaf elements in Basket output buffer.; 179 ; 180void TLeaf::FillBasket(TBuffer &); 181{; 182}; 183 ; 184////////////////////////////////////////////////////////////////////////////////; 185/// If the class supports it, generate an offset array base.; 186///; 187/// This class only returns `nullptr` on error.; 188Int_t *TLeaf::GenerateOffsetArrayBase(Int_t base, Int_t events) const; 189{; 190 // In order to avoid a virtual call, we assume ROOT developers will override; 191 // the default GenerateOffsetArray for cases where this function does not apply.; 192 ; 193 Int_t *retval = new Int_t[events];; 194 if (R__unlikely(!retval || !fLeafCount)) {; 195 delete [] retval;; 196 return nullptr;; 197 }; 198 ; 199 Long64_t orig_entry = std::max(fBranch->GetReadEntry(), 0LL); // -1 indicates to start at the beginning; 200 const std::vector<Int_t> *countValues = fLeafCount->GetLeafCountValues(orig_entry, events);; 201 ; 202 if (!countValues || ((Int_t)countValues->size()) < events) {; 203 Error(""GenerateOffsetArrayBase"", ""The leaf %s could not retrieve enough entries from its branch count (%s), ask for %d and got %ld"",; 204 GetName(), fLeafCount->GetName(), events, (long)(countValues ? countValues->size() : -1));; 205 delete [] retval;; 206 return nullptr;; 207 }; 208 ; 209 Int_t header = GetOffsetHeaderSize();; 210 Int_t len = 0;; 211 for (Int_t idx = 0, offset = base; idx < events; idx++) {; 212 retval[idx] = offset;; 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLeaf_8cxx_source.html:5633,avoid,avoid,5633,doc/master/TLeaf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLeaf_8cxx_source.html,1,['avoid'],['avoid']
Safety," """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowCache(Bool_t all = kFALSE); voidTProof::ShowData(); voidTProof::ShowDataSet(const char* dataset = """", const char* opt = ""M""); virtual voidShowDataSetCache(const char* dataset = 0); voidTProof::ShowDataSetQuota(Option_t* opt = 0); virtual voidShowDataSets(const char* uri = """", const char* = 0); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp); voidTProof::ShowMissingFiles(TQueryResult* qr = 0); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); Int_tTProof::UploadDataSet(const char* dataset, TList* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSet(const char* dataset, const char* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSetFromFile(const char* dataset, const char* file, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tVerifyDataSet(const char* uri, const char* = 0); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Writ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofLite.html:16925,timeout,timeout,16925,root/html530/TProofLite.html,https://root.cern,https://root.cern/root/html530/TProofLite.html,2,['timeout'],['timeout']
Safety," """", Option_t* option = """") constMENU ; virtual Int_tTProofPlayer::SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayer::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayer::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayer::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayer::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerLocal(Bool_t client = kTRUE); TProofPlayerLocal(const TProofPlayerLocal&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerLocal.html:11323,abort,abort,11323,root/html602/TProofPlayerLocal.html,https://root.cern,https://root.cern/root/html602/TProofPlayerLocal.html,1,['abort'],['abort']
Safety," """", Option_t* option = """") constMENU ; virtual Int_tTProofPlayer::SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayer::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayer::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayer::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayer::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerSlave(TSocket* socket = 0); TProofPlayerSlave(TProofPlayerSlave&&); TProofPlayerSlave(const TProofPlayerSlave&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerSlave.html:11179,abort,abort,11179,root/html602/TProofPlayerSlave.html,https://root.cern,https://root.cern/root/html602/TProofPlayerSlave.html,1,['abort'],['abort']
Safety," ""; 441 ""encounter problems.""; 442 << Endl;; 443 }; 444 ; 445 if (fArchitectureString == ""OPENCL"") {; 446 Log() << kERROR << ""The OPENCL architecture has not been implemented yet. ""; 447 ""Please use Architecture=CPU or Architecture=CPU for the ""; 448 ""time being. See the TMVA Users' Guide for instructions ""; 449 ""if you encounter problems.""; 450 << Endl;; 451 Log() << kFATAL << ""The OPENCL architecture has not been implemented yet. ""; 452 ""Please use Architecture=CPU or Architecture=CPU for the ""; 453 ""time being. See the TMVA Users' Guide for instructions ""; 454 ""if you encounter problems.""; 455 << Endl;; 456 }; 457 ; 458 if (fArchitectureString == ""GPU"") {; 459#ifndef DNNCUDA // Included only if DNNCUDA flag is _not_ set.; 460 Log() << kERROR << ""CUDA backend not enabled. Please make sure ""; 461 ""you have CUDA installed and it was successfully ""; 462 ""detected by CMAKE.""; 463 << Endl;; 464 Log() << kFATAL << ""CUDA backend not enabled. Please make sure ""; 465 ""you have CUDA installed and it was successfully ""; 466 ""detected by CMAKE.""; 467 << Endl;; 468#endif // DNNCUDA; 469 }; 470 ; 471 if (fArchitectureString == ""CPU"") {; 472#ifndef DNNCPU // Included only if DNNCPU flag is _not_ set.; 473 Log() << kERROR << ""Multi-core CPU backend not enabled. Please make sure ""; 474 ""you have a BLAS implementation and it was successfully ""; 475 ""detected by CMake as well that the imt CMake flag is set.""; 476 << Endl;; 477 Log() << kFATAL << ""Multi-core CPU backend not enabled. Please make sure ""; 478 ""you have a BLAS implementation and it was successfully ""; 479 ""detected by CMake as well that the imt CMake flag is set.""; 480 << Endl;; 481#endif // DNNCPU; 482 }; 483 ; 484 //; 485 // Set network structure.; 486 //; 487 ; 488 fLayout = TMVA::MethodDNN::ParseLayoutString (fLayoutString);; 489 size_t inputSize = GetNVariables ();; 490 size_t outputSize = 1;; 491 if (fAnalysisType == Types::kRegression && GetNTargets() != 0) {; 492 outputSize = GetNTargets();; 493 } else if (fAnaly",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:15899,detect,detected,15899,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['detect'],['detected']
Safety," ""; 454 ""if you encounter problems.""; 455 << Endl;; 456 }; 457 ; 458 if (fArchitectureString == ""GPU"") {; 459#ifndef DNNCUDA // Included only if DNNCUDA flag is _not_ set.; 460 Log() << kERROR << ""CUDA backend not enabled. Please make sure ""; 461 ""you have CUDA installed and it was successfully ""; 462 ""detected by CMAKE.""; 463 << Endl;; 464 Log() << kFATAL << ""CUDA backend not enabled. Please make sure ""; 465 ""you have CUDA installed and it was successfully ""; 466 ""detected by CMAKE.""; 467 << Endl;; 468#endif // DNNCUDA; 469 }; 470 ; 471 if (fArchitectureString == ""CPU"") {; 472#ifndef DNNCPU // Included only if DNNCPU flag is _not_ set.; 473 Log() << kERROR << ""Multi-core CPU backend not enabled. Please make sure ""; 474 ""you have a BLAS implementation and it was successfully ""; 475 ""detected by CMake as well that the imt CMake flag is set.""; 476 << Endl;; 477 Log() << kFATAL << ""Multi-core CPU backend not enabled. Please make sure ""; 478 ""you have a BLAS implementation and it was successfully ""; 479 ""detected by CMake as well that the imt CMake flag is set.""; 480 << Endl;; 481#endif // DNNCPU; 482 }; 483 ; 484 //; 485 // Set network structure.; 486 //; 487 ; 488 fLayout = TMVA::MethodDNN::ParseLayoutString (fLayoutString);; 489 size_t inputSize = GetNVariables ();; 490 size_t outputSize = 1;; 491 if (fAnalysisType == Types::kRegression && GetNTargets() != 0) {; 492 outputSize = GetNTargets();; 493 } else if (fAnalysisType == Types::kMulticlass && DataInfo().GetNClasses() >= 2) {; 494 outputSize = DataInfo().GetNClasses();; 495 }; 496 ; 497 fNet.SetBatchSize(1);; 498 fNet.SetInputWidth(inputSize);; 499 ; 500 auto itLayout = std::begin (fLayout);; 501 auto itLayoutEnd = std::end (fLayout)-1;; 502 for ( ; itLayout != itLayoutEnd; ++itLayout) {; 503 fNet.AddLayer((*itLayout).first, (*itLayout).second);; 504 }; 505 fNet.AddLayer(outputSize, EActivationFunction::kIdentity);; 506 ; 507 //; 508 // Loss function and output.; 509 //; 510 ; 511 fOutputFunction = EOutputFunctio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:16445,detect,detected,16445,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['detect'],['detected']
Safety," ""ObjectsTable"". In this there are following columns: . Name Description . ""key:id"" key identifier to which belong object . ""obj:id"" object identifier . ""Class"" object class name . ""Version"" object class version . Data in each ""ObjectsTable"" row uniquely identify, in which table and which column object is stored.; In normal situation all class data should be sorted column-wise. Up to now following member are supported:; Basic data types. Here is everything clear. Column SQL type will be as much as possible close to the original type of value.; Fixed array of basic data types. In this case n columns like fArr[0], fArr[1] and so on will be created. If there is multidimensional array, names will be fArr2[1][2][1] and so on; Parent class. In this case version of parent class is stored and data of parent class will be stored with the same obj:id in correspondent table. There is a special case, when parent store nothing (this is for instance TQObject). In that case just -1 is written to avoid any extra checks if table exist or not.; Object as data member. In that case object is saved in normal way to data base and column will contain id of this object.; Pointer on object. Same as before. In case if object was already stored, just its id will be placed in the column. For NULL pointer 0 is used.; TString. Now column with limited width like VARCAHR(255) in MySQL is used. Later this will be improved to support maximum possible strings; Anything else. Data will be converted to raw format and saved in streamer table. Each row supplied with obj:id and row:id, where row:id indicates data, corresponding to this particular data member, and column will contain this raw:id. All conversion to SQL statements are done with help of TSQLStructure class. This is special hierarchical structure wich internally is very similar to XML structures. TBufferSQL2 creates these structures, when object data is streamed by ROOT and only afterwards all SQL statements will be produced and applied all tog",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:2251,avoid,avoid,2251,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['avoid'],['avoid']
Safety," ""cannot create socket (entry %i)"",; 15023 portsTotal);; 15024 continue;; 15025 }; 15026 ; 15027#if defined(_WIN32); 15028 /* Windows SO_REUSEADDR lets many procs binds to a; 15029 * socket, SO_EXCLUSIVEADDRUSE makes the bind fail; 15030 * if someone already has the socket -- DTL */; 15031 /* NOTE: If SO_EXCLUSIVEADDRUSE is used,; 15032 * Windows might need a few seconds before; 15033 * the same port can be used again in the; 15034 * same process, so a short Sleep may be; 15035 * required between mg_stop and mg_start.; 15036 */; 15037 if (setsockopt(so.sock,; 15038 SOL_SOCKET,; 15039 SO_EXCLUSIVEADDRUSE,; 15040 (SOCK_OPT_TYPE)&on,; 15041 sizeof(on)); 15042 != 0) {; 15043 ; 15044 /* Set reuse option, but don't abort on errors. */; 15045 mg_cry_ctx_internal(; 15046 phys_ctx,; 15047 ""cannot set socket option SO_EXCLUSIVEADDRUSE (entry %i)"",; 15048 portsTotal);; 15049 }; 15050#else; 15051 if (setsockopt(so.sock,; 15052 SOL_SOCKET,; 15053 SO_REUSEADDR,; 15054 (SOCK_OPT_TYPE)&on,; 15055 sizeof(on)); 15056 != 0) {; 15057 ; 15058 /* Set reuse option, but don't abort on errors. */; 15059 mg_cry_ctx_internal(; 15060 phys_ctx,; 15061 ""cannot set socket option SO_REUSEADDR (entry %i)"",; 15062 portsTotal);; 15063 }; 15064#endif; 15065 ; 15066#if defined(USE_X_DOM_SOCKET); 15067 if (ip_version == 99) {; 15068 /* Unix domain socket */; 15069 } else; 15070#endif; 15071 ; 15072 if (ip_version > 4) {; 15073 /* Could be 6 for IPv6 onlyor 10 (4+6) for IPv4+IPv6 */; 15074#if defined(USE_IPV6); 15075 if (ip_version > 6) {; 15076 if (so.lsa.sa.sa_family == AF_INET6; 15077 && setsockopt(so.sock,; 15078 IPPROTO_IPV6,; 15079 IPV6_V6ONLY,; 15080 (void *)&off,; 15081 sizeof(off)); 15082 != 0) {; 15083 ; 15084 /* Set IPv6 only option, but don't abort on errors. */; 15085 mg_cry_ctx_internal(phys_ctx,; 15086 ""cannot set socket option ""; 15087 ""IPV6_V6ONLY=off (entry %i)"",; 15088 portsTotal);; 15089 }; 15090 } else {; 15091 if (so.lsa.sa.sa_family == AF_INET6; 15092 && setsockopt(so.sock,; 15093 I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:445624,abort,abort,445624,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['abort'],['abort']
Safety," ""cannot create socket (entry %i)"",; 15024 portsTotal);; 15025 continue;; 15026 }; 15027 ; 15028#if defined(_WIN32); 15029 /* Windows SO_REUSEADDR lets many procs binds to a; 15030 * socket, SO_EXCLUSIVEADDRUSE makes the bind fail; 15031 * if someone already has the socket -- DTL */; 15032 /* NOTE: If SO_EXCLUSIVEADDRUSE is used,; 15033 * Windows might need a few seconds before; 15034 * the same port can be used again in the; 15035 * same process, so a short Sleep may be; 15036 * required between mg_stop and mg_start.; 15037 */; 15038 if (setsockopt(so.sock,; 15039 SOL_SOCKET,; 15040 SO_EXCLUSIVEADDRUSE,; 15041 (SOCK_OPT_TYPE)&on,; 15042 sizeof(on)); 15043 != 0) {; 15044 ; 15045 /* Set reuse option, but don't abort on errors. */; 15046 mg_cry_ctx_internal(; 15047 phys_ctx,; 15048 ""cannot set socket option SO_EXCLUSIVEADDRUSE (entry %i)"",; 15049 portsTotal);; 15050 }; 15051#else; 15052 if (setsockopt(so.sock,; 15053 SOL_SOCKET,; 15054 SO_REUSEADDR,; 15055 (SOCK_OPT_TYPE)&on,; 15056 sizeof(on)); 15057 != 0) {; 15058 ; 15059 /* Set reuse option, but don't abort on errors. */; 15060 mg_cry_ctx_internal(; 15061 phys_ctx,; 15062 ""cannot set socket option SO_REUSEADDR (entry %i)"",; 15063 portsTotal);; 15064 }; 15065#endif; 15066 ; 15067#if defined(USE_X_DOM_SOCKET); 15068 if (ip_version == 99) {; 15069 /* Unix domain socket */; 15070 } else; 15071#endif; 15072 ; 15073 if (ip_version > 4) {; 15074 /* Could be 6 for IPv6 onlyor 10 (4+6) for IPv4+IPv6 */; 15075#if defined(USE_IPV6); 15076 if (ip_version > 6) {; 15077 if (so.lsa.sa.sa_family == AF_INET6; 15078 && setsockopt(so.sock,; 15079 IPPROTO_IPV6,; 15080 IPV6_V6ONLY,; 15081 (void *)&off,; 15082 sizeof(off)); 15083 != 0) {; 15084 ; 15085 /* Set IPv6 only option, but don't abort on errors. */; 15086 mg_cry_ctx_internal(phys_ctx,; 15087 ""cannot set socket option ""; 15088 ""IPV6_V6ONLY=off (entry %i)"",; 15089 portsTotal);; 15090 }; 15091 } else {; 15092 if (so.lsa.sa.sa_family == AF_INET6; 15093 && setsockopt(so.sock,; 15094 I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:445657,abort,abort,445657,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['abort'],['abort']
Safety," && !page_handler_found; scope++) {; 4418 switch (scope) {; 4419 case 1: /* Handler for specific error, e.g. 404 error */; 4420 mg_snprintf(conn,; 4421 &truncated,; 4422 path_buf,; 4423 sizeof(path_buf) - 32,; 4424 ""%serror%03u."",; 4425 error_handler,; 4426 status);; 4427 break;; 4428 case 2: /* Handler for error group, e.g., 5xx error; 4429 * handler; 4430 * for all server errors (500-599) */; 4431 mg_snprintf(conn,; 4432 &truncated,; 4433 path_buf,; 4434 sizeof(path_buf) - 32,; 4435 ""%serror%01uxx."",; 4436 error_handler,; 4437 status / 100);; 4438 break;; 4439 default: /* Handler for all errors */; 4440 mg_snprintf(conn,; 4441 &truncated,; 4442 path_buf,; 4443 sizeof(path_buf) - 32,; 4444 ""%serror."",; 4445 error_handler);; 4446 break;; 4447 }; 4448 ; 4449 /* String truncation in buf may only occur if; 4450 * error_handler is too long. This string is; 4451 * from the config, not from a client. */; 4452 (void)truncated;; 4453 ; 4454 /* The following code is redundant, but it should avoid; 4455 * false positives in static source code analyzers and; 4456 * vulnerability scanners.; 4457 */; 4458 path_buf[sizeof(path_buf) - 32] = 0;; 4459 len = (int)strlen(path_buf);; 4460 if (len > (int)sizeof(path_buf) - 32) {; 4461 len = (int)sizeof(path_buf) - 32;; 4462 }; 4463 ; 4464 /* Start with the file extenstion from the configuration. */; 4465 tstr = strchr(error_page_file_ext, '.');; 4466 ; 4467 while (tstr) {; 4468 for (i = 1;; 4469 (i < 32) && (tstr[i] != 0) && (tstr[i] != ',');; 4470 i++) {; 4471 /* buffer overrun is not possible here, since; 4472 * (i < 32) && (len < sizeof(path_buf) - 32); 4473 * ==> (i + len) < sizeof(path_buf) */; 4474 path_buf[len + i - 1] = tstr[i];; 4475 }; 4476 /* buffer overrun is not possible here, since; 4477 * (i <= 32) && (len < sizeof(path_buf) - 32); 4478 * ==> (i + len) <= sizeof(path_buf) */; 4479 path_buf[len + i - 1] = 0;; 4480 ; 4481 if (mg_stat(conn, path_buf, &error_page_file.stat)) {; 4482 DEBUG_TRACE(""Check error page %s - found"",; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:133150,redund,redundant,133150,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety," && !page_handler_found; scope++) {; 4419 switch (scope) {; 4420 case 1: /* Handler for specific error, e.g. 404 error */; 4421 mg_snprintf(conn,; 4422 &truncated,; 4423 path_buf,; 4424 sizeof(path_buf) - 32,; 4425 ""%serror%03u."",; 4426 error_handler,; 4427 status);; 4428 break;; 4429 case 2: /* Handler for error group, e.g., 5xx error; 4430 * handler; 4431 * for all server errors (500-599) */; 4432 mg_snprintf(conn,; 4433 &truncated,; 4434 path_buf,; 4435 sizeof(path_buf) - 32,; 4436 ""%serror%01uxx."",; 4437 error_handler,; 4438 status / 100);; 4439 break;; 4440 default: /* Handler for all errors */; 4441 mg_snprintf(conn,; 4442 &truncated,; 4443 path_buf,; 4444 sizeof(path_buf) - 32,; 4445 ""%serror."",; 4446 error_handler);; 4447 break;; 4448 }; 4449 ; 4450 /* String truncation in buf may only occur if; 4451 * error_handler is too long. This string is; 4452 * from the config, not from a client. */; 4453 (void)truncated;; 4454 ; 4455 /* The following code is redundant, but it should avoid; 4456 * false positives in static source code analyzers and; 4457 * vulnerability scanners.; 4458 */; 4459 path_buf[sizeof(path_buf) - 32] = 0;; 4460 len = (int)strlen(path_buf);; 4461 if (len > (int)sizeof(path_buf) - 32) {; 4462 len = (int)sizeof(path_buf) - 32;; 4463 }; 4464 ; 4465 /* Start with the file extenstion from the configuration. */; 4466 tstr = strchr(error_page_file_ext, '.');; 4467 ; 4468 while (tstr) {; 4469 for (i = 1;; 4470 (i < 32) && (tstr[i] != 0) && (tstr[i] != ',');; 4471 i++) {; 4472 /* buffer overrun is not possible here, since; 4473 * (i < 32) && (len < sizeof(path_buf) - 32); 4474 * ==> (i + len) < sizeof(path_buf) */; 4475 path_buf[len + i - 1] = tstr[i];; 4476 }; 4477 /* buffer overrun is not possible here, since; 4478 * (i <= 32) && (len < sizeof(path_buf) - 32); 4479 * ==> (i + len) <= sizeof(path_buf) */; 4480 path_buf[len + i - 1] = 0;; 4481 ; 4482 if (mg_stat(conn, path_buf, &error_page_file.stat)) {; 4483 DEBUG_TRACE(""Check error page %s - found"",; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:133182,redund,redundant,133182,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety," & ; ). privatedelete . ◆ TGeoHelix() [2/3]. TGeoHelix::TGeoHelix ; (; ). Dummy constructor. ; Definition at line 61 of file TGeoHelix.cxx. ◆ TGeoHelix() [3/3]. TGeoHelix::TGeoHelix ; (; Double_t ; curvature, . Double_t ; step, . Int_t ; charge = 1 . ). Normal constructor. ; Definition at line 82 of file TGeoHelix.cxx. ◆ ~TGeoHelix(). TGeoHelix::~TGeoHelix ; (; ). override . Destructor. ; Definition at line 104 of file TGeoHelix.cxx. Member Function Documentation. ◆ Class(). static TClass * TGeoHelix::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGeoHelix::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGeoHelix::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 73 of file TGeoHelix.h. ◆ ComputeSafeStep(). Double_t TGeoHelix::ComputeSafeStep ; (; Double_t ; epsil = 1E-6); const. Compute safe linear step that can be made such that the error between linear-helix extrapolation is less than EPSIL. ; Definition at line 114 of file TGeoHelix.cxx. ◆ DeclFileName(). static const char * TGeoHelix::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 73 of file TGeoHelix.h. ◆ GetCurrentDirection(). const Double_t * TGeoHelix::GetCurrentDirection ; (; ); const. inline . Definition at line 51 of file TGeoHelix.h. ◆ GetCurrentPoint(). const Double_t * TGeoHelix::GetCurrentPoint ; (; ); const. inline . Definition at line 50 of file TGeoHelix.h. ◆ GetStep(). Double_t TGeoHelix::GetStep ; (; ); const. inline . Definition at line 53 of file TGeoHelix.h. ◆ GetTotalCurvature(). Double_t TGeoHelix::GetTotalCurvature ; (; ); const. Compute helix total curvature. ; Definition at line 169 of file TGeoHelix.cxx. ◆ GetXYcurvature(). Double_t TGeoHelix::GetXYcurvature ; (; ); const. inline . Definition at line 52 of file TGeoHelix.h. ◆ InitDirection() [1/2]. void TGeoHelix::InitDire",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHelix.html:15014,safe,safe,15014,doc/master/classTGeoHelix.html,https://root.cern,https://root.cern/doc/master/classTGeoHelix.html,1,['safe'],['safe']
Safety," ( 12 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; virtual TBranch * BranchImp (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch() with added check that addobj matches className. ;  ; virtual TBranch * BranchImp (const char *branchname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:57964,detect,detection,57964,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,2,['detect'],['detection']
Safety," ();  ;  TGeoPcon (const char *name);  ;  TGeoPcon (const char *name, Double_t phi, Double_t dphi, Int_t nz);  ;  TGeoPcon (Double_t *params);  ;  TGeoPcon (Double_t phi, Double_t dphi, Int_t nz);  ;  ~TGeoPcon () override;  ; virtual void DefineSection (Int_t snum, Double_t z, Double_t rmin, Double_t rmax);  ; Double_t DistToSegZ (const Double_t *point, const Double_t *dir, Int_t &iz) const;  ; Double_t & Dphi ();  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; Double_t GetDphi () const;  ; Int_t GetNz () const;  ; Double_t GetPhi1 () const;  ; Double_t * GetRmax () const;  ; Double_t GetRmax (Int_t ipl) const;  ; Double_t * GetRmin () const;  ; Double_t GetRmin (Int_t ipl) const;  ; Double_t * GetZ () const;  ; Double_t GetZ (Int_t ipl) const;  ; Bool_t IsCylType () const override;  ; Double_t & Phi1 ();  ; Double_t & Rmax (Int_t ipl);  ; Double_t & Rmin (Int_t ipl);  ; Double_t SafetyToSegment (const Double_t *point, Int_t ipl, Bool_t in=kTRUE, Double_t safmin=TGeoShape::Big()) const;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Double_t & Z (Int_t ipl);  ;  Public Member Functions inherited from TGeoBBox;  TGeoBBox ();  ;  TGeoBBox (const char *name, Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  TGeoBBox (Double_t *param);  ;  TGeoBBox (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  ~TGeoBBox () override;  ; Bool_t CouldBeCrossed (const Double_t *point, const Double_t *dir) const override;  ; virtual Double_t GetDX () const;  ; virtual Double_t GetDY () const;  ; virtual Double_t GetDZ () const;  ; virtual Double_t GetFacetArea (Int_t index=0) const;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; virtual const Double_t * GetOrigin () const;  ; virtual Bool_t GetPointsOnFacet (Int_t index, Int_t npoints, Double_t *arra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPgon.html:4727,Safe,SafetyToSegment,4727,doc/master/classTGeoPgon.html,https://root.cern,https://root.cern/doc/master/classTGeoPgon.html,1,['Safe'],['SafetyToSegment']
Safety," (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoCone.h>. Inheritance diagram for TGeoCone:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoCone() [1/5]. TGeoCone::TGeoCone ; (; const TGeoCone & ; ). protecteddelete . ◆ TGeoCone() [2/5]. TGeoCone::TGeoCone ; (; ). ◆ TGeoCone() [3/5]. TGeoCone::TGeoCone ; (; Double_t ; dz, . Double_t ; rmin1, . Double_t ; rmax1, . Double_t ; rmin2, . Double_t ; rmax2 . ). ◆ TGeoCone() [4/5]. TGeoCone::TGeoCone ; (; const char * ; name, . Double_t ; dz, . Double_t ; rmin1, . Double_t ; rmax1, . Double_t ; rmin2, . Double_t ; rmax2 . ). ◆ TGeoCone() [5/5]. TGeoCone::TGeoCone ; (; Double_t * ; params). ◆ ~TGeoCone(). TGeoCone::~TGeoCone ; (; ). override . Member Function Documentation. ◆ Capacity() [1/2]. Double_t TGeoCone::Capacity ; (; ); const. overridevirtual . Reimplemen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCone.html:22958,detect,detection,22958,doc/master/classTGeoCone.html,https://root.cern,https://root.cern/doc/master/classTGeoCone.html,1,['detect'],['detection']
Safety," (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoCone.h>. Inheritance diagram for TGeoConeSeg:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoConeSeg() [1/4]. TGeoConeSeg::TGeoConeSeg ; (; ). ◆ TGeoConeSeg() [2/4]. TGeoConeSeg::TGeoConeSeg ; (; Double_t ; dz, . Double_t ; rmin1, . Double_t ; rmax1, . Double_t ; rmin2, . Double_t ; rmax2, . Double_t ; phi1, . Double_t ; phi2 . ). ◆ TGeoConeSeg() [3/4]. TGeoConeSeg::TGeoConeSeg ; (; const char * ; name, . Double_t ; dz, . Double_t ; rmin1, . Double_t ; rmax1, . Double_t ; rmin2, . Double_t ; rmax2, . Double_t ; phi1, . Double_t ; phi2 . ). ◆ TGeoConeSeg() [4/4]. TGeoConeSeg::TGeoConeSeg ; (; Double_t * ; params). ◆ ~TGeoConeSeg(). TGeoConeSeg::~TGeoConeSeg ; (; ). override . Member Function Documentation. ◆ AfterStreamer(). void TGeoConeSeg::AfterStreamer ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoConeSeg.html:25333,detect,detection,25333,doc/master/classTGeoConeSeg.html,https://root.cern,https://root.cern/doc/master/classTGeoConeSeg.html,1,['detect'],['detection']
Safety," (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoPara.h>. Inheritance diagram for TGeoPara:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoPara() [1/5]. TGeoPara::TGeoPara ; (; const TGeoPara & ; ). protecteddelete . ◆ TGeoPara() [2/5]. TGeoPara::TGeoPara ; (; ). ◆ TGeoPara() [3/5]. TGeoPara::TGeoPara ; (; Double_t ; dx, . Double_t ; dy, . Double_t ; dz, . Double_t ; alpha, . Double_t ; theta, . Double_t ; phi . ). ◆ TGeoPara() [4/5]. TGeoPara::TGeoPara ; (; const char * ; name, . Double_t ; dx, . Double_t ; dy, . Double_t ; dz, . Double_t ; alpha, . Double_t ; theta, . Double_t ; phi . ). ◆ TGeoPara() [5/5]. TGeoPara::TGeoPara ; (; Double_t * ; param). ◆ ~TGeoPara(). TGeoPara::~TGeoPara ; (; ). override . Member Function Documentation. ◆ Capacity(). Double_t TGeoPara::Capacity ; (; ); const. overridevir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPara.html:22109,detect,detection,22109,doc/master/classTGeoPara.html,https://root.cern,https://root.cern/doc/master/classTGeoPara.html,1,['detect'],['detection']
Safety," (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoPcon.h>. Inheritance diagram for TGeoPcon:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoPcon() [1/6]. TGeoPcon::TGeoPcon ; (; const TGeoPcon & ; ). protecteddelete . Cosine of dphi. . ◆ TGeoPcon() [2/6]. TGeoPcon::TGeoPcon ; (; ). ◆ TGeoPcon() [3/6]. TGeoPcon::TGeoPcon ; (; const char * ; name). inline . Definition at line 45 of file TGeoPcon.h. ◆ TGeoPcon() [4/6]. TGeoPcon::TGeoPcon ; (; Double_t ; phi, . Double_t ; dphi, . Int_t ; nz . ). ◆ TGeoPcon() [5/6]. TGeoPcon::TGeoPcon ; (; const char * ; name, . Double_t ; phi, . Double_t ; dphi, . Int_t ; nz . ). ◆ TGeoPcon() [6/6]. TGeoPcon::TGeoPcon ; (; Double_t * ; params). ◆ ~TGeoPcon(). TGeoPcon::~TGeoPcon ; (; ). override . Member Function Documentation. ◆ Capacity(). Double_t TGeoPcon::Capacity ; (; )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPcon.html:22976,detect,detection,22976,doc/master/classTGeoPcon.html,https://root.cern,https://root.cern/doc/master/classTGeoPcon.html,1,['detect'],['detection']
Safety," (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoPgon.h>. Inheritance diagram for TGeoPgon:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoPgon() [1/5]. TGeoPgon::TGeoPgon ; (; const TGeoPgon & ; ). protecteddelete . ◆ TGeoPgon() [2/5]. TGeoPgon::TGeoPgon ; (; ). ◆ TGeoPgon() [3/5]. TGeoPgon::TGeoPgon ; (; Double_t ; phi, . Double_t ; dphi, . Int_t ; nedges, . Int_t ; nz . ). ◆ TGeoPgon() [4/5]. TGeoPgon::TGeoPgon ; (; const char * ; name, . Double_t ; phi, . Double_t ; dphi, . Int_t ; nedges, . Int_t ; nz . ). ◆ TGeoPgon() [5/5]. TGeoPgon::TGeoPgon ; (; Double_t * ; params). ◆ ~TGeoPgon(). TGeoPgon::~TGeoPgon ; (; ). override . Member Function Documentation. ◆ Capacity(). Double_t TGeoPgon::Capacity ; (; ); const. overridevirtual . Reimplemented from TGeoPcon. ◆ Class(). static TClass * TGeoPgon::Class ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPgon.html:25522,detect,detection,25522,doc/master/classTGeoPgon.html,https://root.cern,https://root.cern/doc/master/classTGeoPgon.html,1,['detect'],['detection']
Safety," (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoSphere.h>. Inheritance diagram for TGeoSphere:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoSphere() [1/5]. TGeoSphere::TGeoSphere ; (; const TGeoSphere & ; ). protecteddelete . ◆ TGeoSphere() [2/5]. TGeoSphere::TGeoSphere ; (; ). ◆ TGeoSphere() [3/5]. TGeoSphere::TGeoSphere ; (; Double_t ; rmin, . Double_t ; rmax, . Double_t ; theta1 = 0, . Double_t ; theta2 = 180, . Double_t ; phi1 = 0, . Double_t ; phi2 = 360 . ). ◆ TGeoSphere() [4/5]. TGeoSphere::TGeoSphere ; (; const char * ; name, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; theta1 = 0, . Double_t ; theta2 = 180, . Double_t ; phi1 = 0, . Double_t ; phi2 = 360 . ). ◆ TGeoSphere() [5/5]. TGeoSphere::TGeoSphere ; (; Double_t * ; param, . Int_t ; nparam = 6 . ). ◆ ~TGeoSphere(). TGeoSphere::~TGeo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoSphere.html:22583,detect,detection,22583,doc/master/classTGeoSphere.html,https://root.cern,https://root.cern/doc/master/classTGeoSphere.html,1,['detect'],['detection']
Safety," (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoTorus.h>. Inheritance diagram for TGeoTorus:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoTorus() [1/5]. TGeoTorus::TGeoTorus ; (; const TGeoTorus & ; ). protecteddelete . ◆ TGeoTorus() [2/5]. TGeoTorus::TGeoTorus ; (; ). ◆ TGeoTorus() [3/5]. TGeoTorus::TGeoTorus ; (; Double_t ; r, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; phi1 = 0, . Double_t ; dphi = 360 . ). ◆ TGeoTorus() [4/5]. TGeoTorus::TGeoTorus ; (; const char * ; name, . Double_t ; r, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; phi1 = 0, . Double_t ; dphi = 360 . ). ◆ TGeoTorus() [5/5]. TGeoTorus::TGeoTorus ; (; Double_t * ; params). ◆ ~TGeoTorus(). TGeoTorus::~TGeoTorus ; (; ). inlineoverride . Definition at line 45 of file TGeoTorus.h. Member Function Documentation. ◆ Capacity(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTorus.html:22405,detect,detection,22405,doc/master/classTGeoTorus.html,https://root.cern,https://root.cern/doc/master/classTGeoTorus.html,1,['detect'],['detection']
Safety," (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoTrd1.h>. Inheritance diagram for TGeoTrd1:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoTrd1() [1/5]. TGeoTrd1::TGeoTrd1 ; (; const TGeoTrd1 & ; ). protecteddelete . ◆ TGeoTrd1() [2/5]. TGeoTrd1::TGeoTrd1 ; (; ). ◆ TGeoTrd1() [3/5]. TGeoTrd1::TGeoTrd1 ; (; Double_t ; dx1, . Double_t ; dx2, . Double_t ; dy, . Double_t ; dz . ). ◆ TGeoTrd1() [4/5]. TGeoTrd1::TGeoTrd1 ; (; const char * ; name, . Double_t ; dx1, . Double_t ; dx2, . Double_t ; dy, . Double_t ; dz . ). ◆ TGeoTrd1() [5/5]. TGeoTrd1::TGeoTrd1 ; (; Double_t * ; params). ◆ ~TGeoTrd1(). TGeoTrd1::~TGeoTrd1 ; (; ). override . Member Function Documentation. ◆ Capacity(). Double_t TGeoTrd1::Capacity ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Class(). static TClass * TGeoTrd1::Clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd1.html:21945,detect,detection,21945,doc/master/classTGeoTrd1.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd1.html,1,['detect'],['detection']
Safety," (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoTrd2.h>. Inheritance diagram for TGeoTrd2:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoTrd2() [1/5]. TGeoTrd2::TGeoTrd2 ; (; const TGeoTrd2 & ; ). protecteddelete . ◆ TGeoTrd2() [2/5]. TGeoTrd2::TGeoTrd2 ; (; ). ◆ TGeoTrd2() [3/5]. TGeoTrd2::TGeoTrd2 ; (; Double_t ; dx1, . Double_t ; dx2, . Double_t ; dy1, . Double_t ; dy2, . Double_t ; dz . ). ◆ TGeoTrd2() [4/5]. TGeoTrd2::TGeoTrd2 ; (; const char * ; name, . Double_t ; dx1, . Double_t ; dx2, . Double_t ; dy1, . Double_t ; dy2, . Double_t ; dz . ). ◆ TGeoTrd2() [5/5]. TGeoTrd2::TGeoTrd2 ; (; Double_t * ; params). ◆ ~TGeoTrd2(). TGeoTrd2::~TGeoTrd2 ; (; ). override . Member Function Documentation. ◆ Capacity(). Double_t TGeoTrd2::Capacity ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd2.html:22024,detect,detection,22024,doc/master/classTGeoTrd2.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd2.html,1,['detect'],['detection']
Safety," (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoTube.h>. Inheritance diagram for TGeoTube:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoTube() [1/5]. TGeoTube::TGeoTube ; (; const TGeoTube & ; ). protecteddelete . ◆ TGeoTube() [2/5]. TGeoTube::TGeoTube ; (; ). ◆ TGeoTube() [3/5]. TGeoTube::TGeoTube ; (; Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz . ). ◆ TGeoTube() [4/5]. TGeoTube::TGeoTube ; (; const char * ; name, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz . ). ◆ TGeoTube() [5/5]. TGeoTube::TGeoTube ; (; Double_t * ; params). ◆ ~TGeoTube(). TGeoTube::~TGeoTube ; (; ). override . Member Function Documentation. ◆ Capacity() [1/2]. Double_t TGeoTube::Capacity ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ Capacity() [2/2]. static Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTube.html:22456,detect,detection,22456,doc/master/classTGeoTube.html,https://root.cern,https://root.cern/doc/master/classTGeoTube.html,1,['detect'],['detection']
Safety," (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoTube.h>. Inheritance diagram for TGeoTubeSeg:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoTubeSeg() [1/4]. TGeoTubeSeg::TGeoTubeSeg ; (; ). ◆ TGeoTubeSeg() [2/4]. TGeoTubeSeg::TGeoTubeSeg ; (; Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz, . Double_t ; phi1, . Double_t ; phi2 . ). ◆ TGeoTubeSeg() [3/4]. TGeoTubeSeg::TGeoTubeSeg ; (; const char * ; name, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz, . Double_t ; phi1, . Double_t ; phi2 . ). ◆ TGeoTubeSeg() [4/4]. TGeoTubeSeg::TGeoTubeSeg ; (; Double_t * ; params). ◆ ~TGeoTubeSeg(). TGeoTubeSeg::~TGeoTubeSeg ; (; ). override . Member Function Documentation. ◆ AfterStreamer(). void TGeoTubeSeg::AfterStreamer ; (; ). overridevirtual . Reimplemented from TGeoShape. ◆ Capacity() [1/2]. Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTubeSeg.html:24401,detect,detection,24401,doc/master/classTGeoTubeSeg.html,https://root.cern,https://root.cern/doc/master/classTGeoTubeSeg.html,1,['detect'],['detection']
Safety," (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoXtru.h>. Inheritance diagram for TGeoXtru:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoXtru() [1/4]. TGeoXtru::TGeoXtru ; (; const TGeoXtru & ; ). protecteddelete . mutex for thread data . ◆ TGeoXtru() [2/4]. TGeoXtru::TGeoXtru ; (; ). ◆ TGeoXtru() [3/4]. TGeoXtru::TGeoXtru ; (; Int_t ; nz). ◆ TGeoXtru() [4/4]. TGeoXtru::TGeoXtru ; (; Double_t * ; param). ◆ ~TGeoXtru(). TGeoXtru::~TGeoXtru ; (; ). override . Member Function Documentation. ◆ Capacity(). Double_t TGeoXtru::Capacity ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Class(). static TClass * TGeoXtru::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGeoXtru::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoXtru.html:23002,detect,detection,23002,doc/master/classTGeoXtru.html,https://root.cern,https://root.cern/doc/master/classTGeoXtru.html,1,['detect'],['detection']
Safety," (; ); const. overridevirtual . Return the line style. ; Reimplemented from TAttLine. ◆ GetLineWidth(). Width_t TGWin32VirtualXProxy::GetLineWidth ; (; ); const. overridevirtual . Return the line width. ; Reimplemented from TAttLine. ◆ GetMarkerColor(). Color_t TGWin32VirtualXProxy::GetMarkerColor ; (; ); const. overridevirtual . Return the marker color. ; Reimplemented from TAttMarker. ◆ GetMarkerSize(). Size_t TGWin32VirtualXProxy::GetMarkerSize ; (; ); const. overridevirtual . Return the marker size. ; Reimplemented from TAttMarker. ◆ GetMarkerStyle(). Style_t TGWin32VirtualXProxy::GetMarkerStyle ; (; ); const. overridevirtual . Return the marker style. ; Reimplemented from TAttMarker. ◆ GetNativeEvent(). Handle_t TGWin32VirtualXProxy::GetNativeEvent ; (; ); const. overridevirtual . Returns the current native event handle. ; Reimplemented from TVirtualX. ◆ GetParent(). Window_t TGWin32VirtualXProxy::GetParent ; (; Window_t ; id); const. overridevirtual . might be thread unsafe (?) ; Reimplemented from TVirtualX.; Definition at line 274 of file TGWin32VirtualXProxy.cxx. ◆ GetPasteBuffer(). void TGWin32VirtualXProxy::GetPasteBuffer ; (; Window_t ; id, . Atom_t ; atom, . TString & ; text, . Int_t & ; nchar, . Bool_t ; del . ). overridevirtual . Gets contents of the paste buffer ""atom"" into the string ""text"". ; (nchar = number of characters) If ""del"" is true deletes the paste buffer afterwards. ; Reimplemented from TVirtualX. ◆ GetPixel(). ULong_t TGWin32VirtualXProxy::GetPixel ; (; Color_t ; cindex). overridevirtual . Returns pixel value associated to specified ROOT color number ""cindex"". ; Reimplemented from TVirtualX. ◆ GetPlanes(). void TGWin32VirtualXProxy::GetPlanes ; (; Int_t & ; nplanes). overridevirtual . Returns the maximum number of planes. ; Reimplemented from TVirtualX. ◆ GetPrimarySelectionOwner(). Window_t TGWin32VirtualXProxy::GetPrimarySelectionOwner ; (; ). overridevirtual . Returns the window id of the current owner of the primary selection. ; That ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32VirtualXProxy.html:82641,unsafe,unsafe,82641,doc/master/classTGWin32VirtualXProxy.html,https://root.cern,https://root.cern/doc/master/classTGWin32VirtualXProxy.html,1,['unsafe'],['unsafe']
Safety," (; const Double_t * ; point, . const Double_t * ; dir, . Double_t * ; norm . ). overridevirtual . Reimplemented from TGeoBBox. ◆ ComputeNormal_v(). void TGeoCtub::ComputeNormal_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; norms, . Int_t ; vecsize . ). overridevirtual . Reimplemented from TGeoBBox. ◆ Contains(). Bool_t TGeoCtub::Contains ; (; const Double_t * ; point); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Contains_v(). void TGeoCtub::Contains_v ; (; const Double_t * ; points, . Bool_t * ; inside, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DeclFileName(). static const char * TGeoCtub::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 226 of file TGeoTube.h. ◆ DistFromInside(). Double_t TGeoCtub::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromInside_v(). void TGeoCtub::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside(). Double_t TGeoCtub::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside_v(). void TGeoCtub::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Divide(). TGeoVolume * TGeoCtub::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimpleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCtub.html:30620,safe,safe,30620,doc/master/classTGeoCtub.html,https://root.cern,https://root.cern/doc/master/classTGeoCtub.html,1,['safe'],['safe']
Safety," (Style_t style);  Internal helper function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  . Static Public Attributes; static constexpr auto kBigNumber = TTree::kMaxEntries;  ;  Static Public Attributes inherited from TTree; static constexpr Long64_t kMaxEntries = TVirtualTreePlayer::kMaxEntries;  . Protected Member Functions; void InvalidateCurrentTree ();  Set the TTree to be reloaded as soon as possible. ;  ; void ReleaseChainProof ();  ;  Protected Member Functions inherited from TTree; virtual TBranch * BranchImp (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch() with added check that addobj matches className. ;  ; virtual TBranch * BranchImp (const char *branchname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:43309,detect,detection,43309,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,2,['detect'],['detection']
Safety," (TStreamerInfo *)Clone(TString::Format(""%s@@%d"",GetName(),GetClassVersion()));; 673 if (!infoalloc) {; 674 if (!isTransient); 675 Error(""Build"",""Could you create a TStreamerInfo for %s\n"",TString::Format(""%s@@%d"",GetName(),GetClassVersion()).Data());; 676 } else {; 677 // Tell clone we should rerun BuildOld; 678 infoalloc->SetBit(kBuildOldUsed,false);; 679 // Temporarily mark it as built to avoid the BuildCheck from removing; 680 // Technically we only need to do this for the 'current' StreamerInfo; 681 fIsBuilt = kTRUE;; 682 infoalloc->BuildCheck();; 683 infoalloc->BuildOld();; 684 fIsBuilt = kFALSE;; 685 TClass *allocClass = infoalloc->GetClass();; 686 ; 687 {; 688 TIter next(fElements);; 689 TStreamerElement* element;; 690 while ((element = (TStreamerElement*) next())) {; 691 if (element->TestBit(TStreamerElement::kRepeat) && element->IsaPointer()) {; 692 TStreamerElement *other = (TStreamerElement*) infoalloc->GetElements()->FindObject(element->GetName());; 693 if (other) {; 694 other->SetBit(TStreamerElement::kDoNotDelete);; 695 }; 696 }; 697 }; 698 infoalloc->GetElements()->Compress();; 699 }; 700 {; 701 TIter next(fElements);; 702 TStreamerElement* element;; 703 while ((element = (TStreamerElement*) next())) {; 704 if (element->TestBit(TStreamerElement::kCache)) {; 705 element->SetOffset(infoalloc->GetOffset(element->GetName()));; 706 }; 707 }; 708 }; 709 ; 710 TStreamerElement *el = new TStreamerArtificial(""@@alloc"","""", 0, TStreamerInfo::kCacheNew, allocClass->GetName());; 711 R__TObjArray_InsertAt( fElements, el, 0 );; 712 ; 713 el = new TStreamerArtificial(""@@dealloc"","""", 0, TStreamerInfo::kCacheDelete, allocClass->GetName());; 714 fElements->Add( el );; 715 }; 716 }; 717 ; 718 //; 719 // Make a more compact version.; 720 //; 721 Compile();; 722 fIsBuilt = kTRUE;; 723}; 724 ; 725////////////////////////////////////////////////////////////////////////////////; 726/// Check if built and consistent with the class dictionary.; 727/// This method is called by ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:25054,avoid,avoid,25054,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['avoid'],['avoid']
Safety," (also known as ""variable binning""). More...;  ; class  RAxisLabels;  A RAxisGrow that has a label assigned to each bin and a bin width of 1. More...;  ; class  RBitsetField;  The generic field an std::bitset<N>. More...;  ; class  RCanvas;  A window's topmost RPad. More...;  ; class  RCanvasDisplayItem;  class RCanvasDisplayItem More...;  ; class  RCanvasPainter;  ; class  RCardinalityField;  An artificial field that transforms an RNTuple column that contains the offset of collections into collection sizes. More...;  ; class  RChangeAttrRequest;  ; class  RClassField;  The field for a class with dictionary. More...;  ; class  RClusterDescriptor;  Meta-data for a set of ntuple clusters. More...;  ; class  RClusterGroupDescriptor;  Clusters are bundled in cluster groups. More...;  ; class  RClusterIndex;  Addresses a column element or field item relative to a particular cluster, instead of a global NTupleSize_t index. More...;  ; struct  RClusterSize;  Wrap the integer in a struct in order to avoid template specialization clash with std::uint64_t. More...;  ; class  RCollectionField;  The collection field is only used for writing; when reading, untyped collections are projected to an std::vector. More...;  ; class  RColor;  The color class. More...;  ; class  RColumnDescriptor;  Meta-data stored for every column of an ntuple. More...;  ; class  RColumnGroupDescriptor;  Meta-data for a sets of columns; non-trivial column groups are used for sharded clusters. More...;  ; class  RColumnModel;  Holds the static meta-data of an RNTuple column. More...;  ; class  RColumnSwitch;  Holds the index and the tag of a kSwitch column. More...;  ; class  RDirectory;  Key/value store of objects. More...;  ; class  RDirectoryTypeMismatch;  Objects of this class are thrown to signal that the value known under the given name . More...;  ; class  RDirectoryUnknownKey;  Objects of this class are thrown to signal that no key with that name exists. More...;  ; class  RDisplayHistStat;  Obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html:3667,avoid,avoid,3667,doc/v632/namespaceROOT_1_1Experimental.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html,1,['avoid'],['avoid']
Safety," (data); const TH1D*fBdatmeasured distribution (data); const TH1D*fBinireconstructed distribution (MC); TH1D*fDHist! Distribution of d (for checking regularization); Int_tfDdim! Derivative for curvature matrix; Int_tfKReg! Regularisation parameter; Bool_tfMatToyMode! Internal switch for evaluation of statistical uncertainties from response matrix; Int_tfNdim! Truth and reconstructed dimensions; Bool_tfNormalize! Normalize unfolded spectrum to 1; TH1D*fSVHist! Distribution of singular values; Bool_tfToyMode! Internal switch for covariance matrix propagation; TH1D*fToyhisto! Toy MC histogram; TH2D*fToymat! Toy MC detector response matrix; const TH1D*fXinitruth distribution (MC); TH2D*fXinv! Computed inverse of covariance matrix; TH2D*fXtau! Computed regularized covariance matrix. Class Charts. Inheritance Chart:. TObject. ←; TSVDUnfold. Function documentation; TSVDUnfold(const TH1D* bdat, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Alternative constructor; User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum. TSVDUnfold(const TH1D* bdat, TH2D* Bcov, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Default constructor; Initialisation of TSVDUnfold; User provides data and MC test spectra, as well as detector response matrix and the covariance matrix of the measured distribution. TSVDUnfold(const TSVDUnfold& other); Copy constructor. ~TSVDUnfold(); Destructor. TH1D* Unfold(Int_t kreg); Perform the unfolding with regularisation parameter kreg. TH2D* GetUnfoldCovMatrix(const TH2D* cov, Int_t ntoys, Int_t seed = 1); Determine for given input error matrix covariance matrix of unfolded; spectrum from toy simulation given the passed covariance matrix on measured spectrum; ""cov"" - covariance matrix on the measured spectrum, to be propagated; ""ntoys"" - number of pseudo experiments used for the propagation; ""seed"" - seed for pseudo experiments;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSVDUnfold.html:10711,detect,detector,10711,root/html602/TSVDUnfold.html,https://root.cern,https://root.cern/root/html602/TSVDUnfold.html,2,['detect'],['detector']
Safety," (default: """", example: http://root.cern.ch/viewcvs).; Root.Html.ViewCVS:; Stem of the CERN XWho system (default: http://consult.cern.ch/xwho/people?); Root.Html.XWho:; If set to Doc++, allow method documentation in front of method even for methods in the source file (default: """"); Root.Html.DescriptionStyle:; Search path for the source and header files with their default settings:; Unix.*.Root.Html.SourceDir: .:src:include; WinNT.*.Root.Html.SourceDir: .;src;include; URL stem for ROOT documentation pages (default is """").; Root.Html.Root: http://root.cern.ch/root/html; Filesystem output directory for generated web pages (default: htmldoc).; Root.Html.OutputDir: htmldoc/; Address of the package’s home page (default: http://root.cern.ch):; Root.Html.HomePage:; Location of user defined header and footer files, see http://root.cern.ch/root/html/THtml#conf:header (defaults are """", example: ../header.txt, ../footer.txt):; Root.Html.Header:; Root.Html.Footer:; Tag for detecting class description comments (default value is set below).; Root.Html.Description: //____________________; Tag for detecting “Author” comment (default value is set below).; Root.Html.Author: // Author:; Tag for detecting “last updated” comment. THtml uses the current date if this tag is not found in a class source file (default value is set below).; Root.Html.LastUpdate: // @(#); Tag for detecting “Copyright” comment (default value is set below).; Root.Html.Copyright: * Copyright; 28.6.3 GUI Specific Settings; Set the “native” ROOT GUI interface to be used in a ROOT session.; Gui.Backend: native; Gui.Factory: native; GUI default fonts in use:; Gui.DefaultFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuHiFont: -adobe-helvetica-bold-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocFixedFont: -adobe-courier-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocPropFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.IconFont: -ad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1259965,detect,detecting,1259965,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['detect'],['detecting']
Safety," (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. TList * GetListOfDeActives() const; Returns a list with all de-active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. void Ready(TSocket* sock); Emit signal when some socket is ready. void * Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMonitor.html:12811,timeout,timeout,12811,root/html528/TMonitor.html,https://root.cern,https://root.cern/root/html528/TMonitor.html,6,['timeout'],['timeout']
Safety," (low): check if this is still required */; 6390 /* EAGAIN/EWOULDBLOCK:; 6391 * standard case if called from close_socket_gracefully; 6392 * => should return -1 */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6420 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6421 }; 6422 if (timeout <= 0.0) {; 6423 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6424 / 1000.0;; 6425 }; 6426 start_time = mg_get_current_time_ns();; 6427 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6428 ; 6429 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6430 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6431 if (n == -2) {; 6432 if (nread == 0) {; 6433 nread = -1; /* Propagate the error */; 6434 }; 6435 break;; 6436 } else if (n == -1) {; 6437 /* timeout */; 6438 if (timeout >= 0.0) {; 6439 now = mg_get_current_time_ns();; 6440 if ((now - start_time) <= timeout_ns) {; 6441 continue;; 6442 }; 6443 }; 6444 break;; 6445 } else if (n == 0) {; 6446 break; /* No more data to read */; 6447 } else {; 6448 nread += n;; 6449 len -= n;; 6450 }; 6451 }; 6452 ; 6453 return nread;; 6454}; 6455 ; 6456 ; 6457static void; 6458discard_unread_request_data(struct mg_connection *conn); 6459{; 6460 char buf[MG_BUF_LEN];; 6461 ; 6462 while (mg_read(conn, bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:187111,timeout,timeout,187111,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety," (low): check if this is still required */; 6391 /* EAGAIN/EWOULDBLOCK:; 6392 * standard case if called from close_socket_gracefully; 6393 * => should return -1 */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6421 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6422 }; 6423 if (timeout <= 0.0) {; 6424 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6425 / 1000.0;; 6426 }; 6427 start_time = mg_get_current_time_ns();; 6428 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6429 ; 6430 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6431 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6432 if (n == -2) {; 6433 if (nread == 0) {; 6434 nread = -1; /* Propagate the error */; 6435 }; 6436 break;; 6437 } else if (n == -1) {; 6438 /* timeout */; 6439 if (timeout >= 0.0) {; 6440 now = mg_get_current_time_ns();; 6441 if ((now - start_time) <= timeout_ns) {; 6442 continue;; 6443 }; 6444 }; 6445 break;; 6446 } else if (n == 0) {; 6447 break; /* No more data to read */; 6448 } else {; 6449 nread += n;; 6450 len -= n;; 6451 }; 6452 }; 6453 ; 6454 return nread;; 6455}; 6456 ; 6457 ; 6458static void; 6459discard_unread_request_data(struct mg_connection *conn); 6460{; 6461 char buf[MG_BUF_LEN];; 6462 ; 6463 while (mg_read(conn, bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:187143,timeout,timeout,187143,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety," (other._specGeneratorConfig) {; 268 _specGeneratorConfig = std::make_unique<RooNumGenConfig>(*other._specGeneratorConfig);; 269 }; 270}; 271 ; 272 ; 273 ; 274////////////////////////////////////////////////////////////////////////////////; 275/// Destructor; 276 ; 277RooAbsPdf::~RooAbsPdf(); 278{; 279}; 280 ; 281 ; 282double RooAbsPdf::normalizeWithNaNPacking(double rawVal, double normVal) const {; 283 ; 284 if (normVal < 0. || (normVal == 0. && rawVal != 0)) {; 285 //Unreasonable normalisations. A zero integral can be tolerated if the function vanishes, though.; 286 const std::string msg = ""p.d.f normalization integral is zero or negative: "" + std::to_string(normVal);; 287 logEvalError(msg.c_str());; 288 clearValueAndShapeDirty();; 289 return RooNaNPacker::packFloatIntoNaN(-normVal + (rawVal < 0. ? -rawVal : 0.));; 290 }; 291 ; 292 if (rawVal < 0.) {; 293 logEvalError(Form(""p.d.f value is less than zero (%f), trying to recover"", rawVal));; 294 clearValueAndShapeDirty();; 295 return RooNaNPacker::packFloatIntoNaN(-rawVal);; 296 }; 297 ; 298 if (TMath::IsNaN(rawVal)) {; 299 logEvalError(""p.d.f value is Not-a-Number"");; 300 clearValueAndShapeDirty();; 301 return rawVal;; 302 }; 303 ; 304 return (rawVal == 0. && normVal == 0.) ? 0. : rawVal / normVal;; 305}; 306 ; 307 ; 308////////////////////////////////////////////////////////////////////////////////; 309/// Return current value, normalized by integrating over; 310/// the observables in `nset`. If `nset` is 0, the unnormalized value; 311/// is returned. All elements of `nset` must be lvalues.; 312///; 313/// Unnormalized values are not cached.; 314/// Doing so would be complicated as `_norm->getVal()` could; 315/// spoil the cache and interfere with returning the cached; 316/// return value. Since unnormalized calls are typically; 317/// done in integration calls, there is no performance hit.; 318 ; 319double RooAbsPdf::getValV(const RooArgSet* nset) const; 320{; 321 ; 322 // Special handling of case without normali",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:11171,recover,recover,11171,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['recover'],['recover']
Safety," (same physics properties). In other words, the limitation in proceeding this way is that D,E, and F must point to the same medium. If this was not the case, we would have to define different virtual volumes for each placement: C, C' and C"", having the same shape but different media matching the corresponding containers. This might not happen so often, but when it does, it forces the creation of several extra virtual volumes. Other limitation comes from the fact that any container is directly used by navigation algorithms to optimize tracking. These must geometrically contain their belongings (positioned volumes) so that these do not extrude its shape boundaries. Not respecting this rule generally leads to unpredictable results. Therefore A and B together must fit into C that has to fit also into D,E, and F. This is not always straightforward to accomplish, especially when instead of A and B we have many more volumes.; In order to avoid these problems, one can use for the difficult cases the class TGeoVolumeAssembly, representing an assembly of volumes. This behaves like a normal container volume supporting other volumes positioned inside, but it has neither shape nor medium. It cannot be used directly as a piece of the geometry, but just as a temporary structure helping temporary assembling and positioning volumes.; If we define now C as an assembly containing A and B, positioning the assembly into D,E and F will actually position only A and Bdirectly into these volumes, taking into account their combined transformations A/B to C and C to D/E/F. This looks much nicer, is it? In fact, it is and it is not. Of course, we managed to get rid of the ‘unnecessary’ volume C in our geometry, but we end-up with a more flat structure for D,E and F (more daughters inside). This can get much worse when extensively used, as in the case: assemblies of assemblies.; For deciding what to choose between using virtual containers or assemblies for a specific case, one can use for both ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:942355,avoid,avoid,942355,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety," ) Log() << kWARNING << ""Negative background efficiency found and set to 0. This is probably due to many events with negative weights in a certain cut-region."" << Endl;; 1042 fNegEffWarning = kTRUE;; 1043 }; 1044}; 1045 ; 1046////////////////////////////////////////////////////////////////////////////////; 1047/// compute signal and background efficiencies from event counting; 1048/// for given cut sample; 1049 ; 1050void TMVA::MethodCuts::GetEffsfromSelection( Double_t* cutMin, Double_t* cutMax,; 1051 Double_t& effS, Double_t& effB); 1052{; 1053 Float_t nTotS = 0, nTotB = 0;; 1054 Float_t nSelS = 0, nSelB = 0;; 1055 ; 1056 Volume* volume = new Volume( cutMin, cutMax, GetNvar() );; 1057 ; 1058 // search for all events lying in the volume, and add up their weights; 1059 nSelS = fBinaryTreeS->SearchVolume( volume );; 1060 nSelB = fBinaryTreeB->SearchVolume( volume );; 1061 ; 1062 delete volume;; 1063 ; 1064 // total number of ""events"" (sum of weights) as reference to compute efficiency; 1065 nTotS = fBinaryTreeS->GetSumOfWeights();; 1066 nTotB = fBinaryTreeB->GetSumOfWeights();; 1067 ; 1068 // sanity check; 1069 if (nTotS == 0 && nTotB == 0) {; 1070 Log() << kFATAL << ""<GetEffsfromSelection> fatal error in zero total number of events:""; 1071 << "" nTotS, nTotB: "" << nTotS << "" "" << nTotB << "" ***"" << Endl;; 1072 }; 1073 ; 1074 // efficiencies; 1075 if (nTotS == 0 ) {; 1076 effS = 0;; 1077 effB = nSelB/nTotB;; 1078 Log() << kWARNING << ""<ComputeEstimator> zero number of signal events"" << Endl;; 1079 }; 1080 else if (nTotB == 0) {; 1081 effB = 0;; 1082 effS = nSelS/nTotS;; 1083 Log() << kWARNING << ""<ComputeEstimator> zero number of background events"" << Endl;; 1084 }; 1085 else {; 1086 effS = nSelS/nTotS;; 1087 effB = nSelB/nTotB;; 1088 }; 1089 ; 1090 // quick fix to prevent from efficiencies < 0; 1091 if( effS < 0.0 ) {; 1092 effS = 0.0;; 1093 if( !fNegEffWarning ) Log() << kWARNING << ""Negative signal efficiency found and set to 0. This is probably due to many events w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:40021,sanity check,sanity check,40021,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['sanity check'],['sanity check']
Safety," ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 568 of file TBufferSQL.cxx. ◆ WriteFastArray() [11/15]. void TBufferSQL::WriteFastArray ; (; const ULong64_t * ; ul, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 648 of file TBufferSQL.cxx. ◆ WriteFastArray() [12/15]. void TBufferSQL::WriteFastArray ; (; const ULong_t * ; ul, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 608 of file TBufferSQL.cxx. ◆ WriteFastArray() [13/15]. void TBufferSQL::WriteFastArray ; (; const UShort_t * ; us, . Long64_t ; n . ). finalvirtual . WriteFastArray SQL implementation. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Reimplemented from TBufferFile.; Definition at line 527 of file TBufferSQL.cxx. ◆ WriteFastArray() [14/15]. Int_t TBufferSQL::WriteFastArray ; (; void ** ; startp, . const TClass * ; cl, . Long64_t ; n = 1, . bool ; isPreAlloc = false, . TMemberStreamer * ; s = nullptr . ). finalvirtual . WriteFastArray SQL implementation. ; Reimplemented from TBufferFile.; Definition at line 717 of file TBufferSQL.cxx. ◆ WriteFastAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferSQL.html:55569,abort,aborts,55569,doc/master/classTBufferSQL.html,https://root.cern,https://root.cern/doc/master/classTBufferSQL.html,1,['abort'],['aborts']
Safety," ); const. inlinevirtual . Reimplemented in TGeoBBox, TGeoCone, TGeoConeSeg, TGeoHype, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoSphere, TGeoTessellated, TGeoTorus, TGeoTube, TGeoTubeSeg, TGeoXtru, TGeoVGShape, TEveGeoPolyShape, and ROOT::Experimental::REveGeoPolyShape.; Definition at line 146 of file TGeoShape.h. ◆ NormalPhi(). void TGeoShape::NormalPhi ; (; const Double_t * ; point, . const Double_t * ; dir, . Double_t * ; norm, . Double_t ; c1, . Double_t ; s1, . Double_t ; c2, . Double_t ; s2 . ). static . Static method to compute normal to phi planes. ; Definition at line 464 of file TGeoShape.cxx. ◆ Paint(). void TGeoShape::Paint ; (; Option_t * ; option = """"). overridevirtual . Paint this shape. ; Reimplemented from TObject.; Reimplemented in TGeoVGShape.; Definition at line 784 of file TGeoShape.cxx. ◆ ResetShapeBit(). void TGeoShape::ResetShapeBit ; (; UInt_t ; f). inline . Definition at line 166 of file TGeoShape.h. ◆ Safety(). virtual Double_t TGeoShape::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. pure virtual . Implemented in TGeoArb8, TGeoTrap, TGeoGtra, TGeoBBox, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, TGeoXtru, and TGeoVGShape. ◆ Safety_v(). virtual void TGeoShape::Safety_v ; (; const Double_t * ; , . const Bool_t * ; , . Double_t * ; , . Int_t ;  . ); const. inlinevirtual . Reimplemented in TGeoArb8, TGeoTrap, TGeoGtra, TGeoBBox, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, and TGeoXtru.; Definition at line 151 of file TGeoShape.h. ◆ SafetyPhi(). Double_t TGeoShape::SafetyPhi ; (; const Double_t * ; point, . Bool_t ; in, . Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShape.html:45623,Safe,Safety,45623,doc/master/classTGeoShape.html,https://root.cern,https://root.cern/doc/master/classTGeoShape.html,1,['Safe'],['Safety']
Safety," * InitRint(Bool_t prompt = kFALSE, const char* appClassName = ""QtRint"", int* argc = 0, char** argv = 0, void* options = 0, int numOptions = 0, Bool_t noLogo = kTRUE). Instantiate ROOT from within Qt application if needed; Return the TRint pointer; Most parametrs are passed to TRint class ctor. Bool_t prompt = kTRUE; Instantiate ROOT with ROOT command prompt; kFALSE; No ROOT prompt. The default for Qt GUI applications. The prompt option can be defined via ROOT parameter file "".rootrc""; .rootrc:; . . .; Gui.Prompt yes. void Erase(); Erases the entire widget and its double buffer. void cd(); [slot] to make this embedded canvas the current one. void cd(int subpadnumber); [slot] to make this embedded canvas / pad the current one. void Disconnect(); [slot] Disconnect the Qt widget from TCanvas object before deleting; to avoid the dead lock; one has to set CanvasID = 0 to disconnect things properly. void Refresh(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed; use the permanent single shot timer to eliminate; the redundand refreshing for the sake of the performance. void RefreshCB(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed. void SetCanvas(TCanvas* c); remember my host TCanvas and adopt its name. customEvent(QEvent* ); The custom response to the special WIN32 events; These events are not present with X11 systems. void contextMenuEvent(QContextMenuEvent* ); The custom response to the Qt QContextMenuEvent; Map QContextMenuEvent to the ROOT kButton3Down = 3 event. void focusInEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""in""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void focusOutEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""out""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void mousePressEvent(QMouseEvent* ); Map the Qt mouse press button event to the ROOT TCanvas events; Mouse events occur when a mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQtWidget.html:25148,redund,redundand,25148,root/html602/TQtWidget.html,https://root.cern,https://root.cern/root/html602/TQtWidget.html,2,['redund'],['redundand']
Safety," * InitRint(Bool_t prompt = kFALSE, const char* appClassName = ""QtRint"", int* argc = 0, char** argv = 0, void* options = 0, int numOptions = 0, Bool_t noLogo = kTRUE). Instantiate ROOT from within Qt application if needed; Return the TRint pointer; Most parametrs are passed to TRint class ctor. Bool_t prompt = kTRUE; Instantiate ROOT with ROOT command prompt; kFALSE; No ROOT prompt. The default for Qt GUI applications. The prompt option can be defined via ROOT parameter file "".rootrc""; .rootrc:; . . .; Gui.Prompt yes. void Erase(); Erases the entire widget and its double buffer. void cd(); [slot] to make this embedded canvas the current one. void cd(int subpadnumber); [slot] to make this embedded canvas / pad the current one. void Disconnect(); [slot] Disconnect the Qt widget from TCanvas object before deleting; to avoid the dead lock; one has to set CanvasID = 0 to disconnect things properly. void Refresh(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed; use the permanent single shot timer to eliminate; the redundand refreshing for the sake of the performance. void SetCanvas(TCanvas* c); remember my host TCanvas and adopt its name. customEvent(QEvent* ); The custom response to the special WIN32 events; These events are not present with X11 systems. void contextMenuEvent(QContextMenuEvent* ); The custom response to the Qt QContextMenuEvent; Map QContextMenuEvent to the ROOT kButton3Down = 3 event. void focusInEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""in""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void focusOutEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""out""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void mousePressEvent(QMouseEvent* ); Map the Qt mouse press button event to the ROOT TCanvas events; Mouse events occur when a mouse button is pressed or released inside; a widget or when the mouse cursor is move",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQtWidget.html:8539,redund,redundand,8539,root/html528/TQtWidget.html,https://root.cern,https://root.cern/root/html528/TQtWidget.html,3,['redund'],['redundand']
Safety," * InvertMSparse(const TMatrixDSparse* A) const; get the inverse of a sparse matrix; A: the original matrix; this is a replacement of the call; new TMatrixD(TMatrixD::kInverted, a);; the matrix inversion is optimized for the case; where a large submatrix of A is diagonal. Bool_t InvertMConditioned(TMatrixD* A); invert the matrix A; the inversion is done with pre-conditioning; all rows and columns are normalized to sqrt(abs(a_ii*a_jj)); such that the diagonals are equal to 1.0; This type of preconditioning improves the numerival results; for the symmetric, positive definite matrices which are; treated here in the context of unfolding. TUnfold(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea); set up unfolding matrix and initial regularisation scheme; hist_A: matrix that describes the migrations; histmap: mapping of the histogram axes to the unfolding output; regmode: global regularisation mode; constraint: type of constraint to use; data members initialized to something different from zero:; fA: filled from hist_A; fDA: filled from hist_A; fX0: filled from hist_A; fLsquared: filled depending on the regularisation scheme; Treatment of overflow bins; Bins where the unfolding input (Detector level) is in overflow; are used for the efficiency correction. They have to be filled; properly!; Bins where the unfolding output (Generator level) is in overflow; are treated as a part of the generator level distribution.; I.e. the unfolding output could have non-zero overflow bins if the; input matrix does have such bins. ~TUnfold(void); delete all data members. void SetBias(const TH1* bias); initialize alternative bias from histogram; modifies data member fX0. Int_t RegularizeSize(int bin, Double_t scale = 1.0); add regularisation on the size of bin i; bin: bin number; scale: size of the regularisation; return value: number of conditions which have been skipped; modifies data member fLsquare",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfold.html:24657,Detect,Detector,24657,root/html528/TUnfold.html,https://root.cern,https://root.cern/root/html528/TUnfold.html,3,['Detect'],['Detector']
Safety," * RooTemplateProxy< T >::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). template<class T > . static constexpr Version_t RooTemplateProxy< T >::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 448 of file RooTemplateProxy.h. ◆ DeclFileName(). template<class T > . static const char * RooTemplateProxy< T >::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 448 of file RooTemplateProxy.h. ◆ IsA(). template<class T > . TClass * RooTemplateProxy< T >::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooArgProxy.; Definition at line 448 of file RooTemplateProxy.h. ◆ lvptr() [1/4]. template<class T > . const LValue_t * RooTemplateProxy< T >::lvptr ; (; const LValue_t * ; ); const. inline . Return l-value pointer to contents. ; If the contents derive from RooAbsLValue or RooAbsCategoryLValue, the conversion is safe, and the function directly returns the pointer using a static_cast. If the template parameter of this proxy is not an LValue type, then; in a debug build, a dynamic_cast with an assertion is used.; in a release build, a static_cast is forced, irrespective of what the type of the object actually is. This is dangerous, but equivalent to the behaviour before refactoring the RooFit proxies. Deprecated:This function is unnecessary if the template parameter is RooAbsRealLValue (+ derived types) or RooAbsCategoryLValue (+derived types), as arg() will always return the correct type. . Definition at line 407 of file RooTemplateProxy.h. ◆ lvptr() [2/4]. template<class T > . const LValue_t * RooTemplateProxy< T >::lvptr ; (; const RooAbsArg * ; ); const. inline . Return l-value pointer to contents. ; If the contents derive from RooAbsLValue or RooAbsCategoryLValue, the conversion is safe, and the function directly returns the pointer using a static_cast. If the template parameter of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTemplateProxy.html:23479,safe,safe,23479,doc/master/classRooTemplateProxy.html,https://root.cern,https://root.cern/doc/master/classRooTemplateProxy.html,1,['safe'],['safe']
Safety," * TSessionQueryFrame::GetQueryEditFrame ; (; ); const. inline . Definition at line 419 of file TSessionViewer.h. ◆ GetStatsCanvas(). TCanvas * TSessionQueryFrame::GetStatsCanvas ; (; ); const. inline . Definition at line 418 of file TSessionViewer.h. ◆ GetTab(). TGTab * TSessionQueryFrame::GetTab ; (; ); const. inline . Definition at line 420 of file TSessionViewer.h. ◆ IndicateStop(). void TSessionQueryFrame::IndicateStop ; (; Bool_t ; aborted). Indicate that Cancel or Stop was clicked. ; Definition at line 2878 of file TSessionViewer.cxx. ◆ IsA(). TClass * TSessionQueryFrame::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGCompositeFrame.; Definition at line 448 of file TSessionViewer.h. ◆ Modified(). void TSessionQueryFrame::Modified ; (; Bool_t ; mod = kTRUE). Notify changes in query editor settings. ; Definition at line 2531 of file TSessionViewer.cxx. ◆ OnBtnAbort(). void TSessionQueryFrame::OnBtnAbort ; (; ). Abort processing query. ; Definition at line 3070 of file TSessionViewer.cxx. ◆ OnBtnFinalize(). void TSessionQueryFrame::OnBtnFinalize ; (; ). Finalize query. ; Definition at line 2954 of file TSessionViewer.cxx. ◆ OnBtnRetrieve(). void TSessionQueryFrame::OnBtnRetrieve ; (; ). Retrieve query. ; Definition at line 3018 of file TSessionViewer.cxx. ◆ OnBtnShowLog(). void TSessionQueryFrame::OnBtnShowLog ; (; ). Show query log. ; Definition at line 3004 of file TSessionViewer.cxx. ◆ OnBtnStop(). void TSessionQueryFrame::OnBtnStop ; (; ). Stop processing query. ; Definition at line 2984 of file TSessionViewer.cxx. ◆ OnBtnSubmit(). void TSessionQueryFrame::OnBtnSubmit ; (; ). Submit query. ; Definition at line 3090 of file TSessionViewer.cxx. ◆ Progress() [1/3]. void TSessionQueryFrame::Progress ; (; Long64_t ; total, . Long64_t ; processed . ). Update progress bar and status labels. ; Definition at line 2615 of file TSessionViewer.cxx. ◆ Progress() [2/3]. void TSessionQueryFrame::Progress ; (; Long6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSessionQueryFrame.html:35575,Abort,Abort,35575,doc/master/classTSessionQueryFrame.html,https://root.cern,https://root.cern/doc/master/classTSessionQueryFrame.html,1,['Abort'],['Abort']
Safety," * TUnixSystem::HostName ; (; ). overridevirtual . Return the system's host name. ; Reimplemented from TSystem.; Definition at line 762 of file TUnixSystem.cxx. ◆ IgnoreSignal(). void TUnixSystem::IgnoreSignal ; (; ESignals ; sig, . Bool_t ; ignore = kTRUE . ). overridevirtual . If ignore is true ignore the specified signal, else restore previous behaviour. ; Reimplemented from TSystem.; Definition at line 895 of file TUnixSystem.cxx. ◆ Init(). Bool_t TUnixSystem::Init ; (; ). overridevirtual . Initialize Unix system interface. ; Reimplemented from TSystem.; Definition at line 595 of file TUnixSystem.cxx. ◆ IsA(). TClass * TUnixSystem::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TSystem.; Definition at line 219 of file TUnixSystem.h. ◆ IsPathLocal(). Bool_t TUnixSystem::IsPathLocal ; (; const char * ; path). overridevirtual . Returns TRUE if the url in 'path' points to the local file system. ; This is used to avoid going through the NIC card for local operations. ; Reimplemented from TSystem.; Definition at line 1643 of file TUnixSystem.cxx. ◆ Link(). int TUnixSystem::Link ; (; const char * ; from, . const char * ; to . ). overridevirtual . Create a link from file1 to file2. ; Returns 0 when successful, -1 in case of failure. ; Reimplemented from TSystem.; Definition at line 1686 of file TUnixSystem.cxx. ◆ ListLibraries(). void TUnixSystem::ListLibraries ; (; const char * ; regexp = """"). overridevirtual . List all loaded shared libraries. ; Reimplemented from TSystem.; Definition at line 2848 of file TUnixSystem.cxx. ◆ ListSymbols(). void TUnixSystem::ListSymbols ; (; const char * ; module, . const char * ; re = """" . ). overridevirtual . List symbols in a shared library. ; Reimplemented from TSystem.; Definition at line 2840 of file TUnixSystem.cxx. ◆ Load(). int TUnixSystem::Load ; (; const char * ; module, . const char * ; entry = """", . Bool_t ; system = kFALSE . ). overridevirtual . Load a shared library.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:57841,avoid,avoid,57841,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['avoid'],['avoid']
Safety," */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6420 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6421 }; 6422 if (timeout <= 0.0) {; 6423 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6424 / 1000.0;; 6425 }; 6426 start_time = mg_get_current_time_ns();; 6427 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6428 ; 6429 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6430 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6431 if (n == -2) {; 6432 if (nread == 0) {; 6433 nread = -1; /* Propagate the error */; 6434 }; 6435 break;; 6436 } else if (n == -1) {; 6437 /* timeout */; 6438 if (timeout >= 0.0) {; 6439 now = mg_get_current_time_ns();; 6440 if ((now - start_time) <= timeout_ns) {; 6441 continue;; 6442 }; 6443 }; 6444 break;; 6445 } else if (n == 0) {; 6446 break; /* No more data to read */; 6447 } else {; 6448 nread += n;; 6449 len -= n;; 6450 }; 6451 }; 6452 ; 6453 return nread;; 6454}; 6455 ; 6456 ; 6457static void; 6458discard_unread_request_data(struct mg_connection *conn); 6459{; 6460 char buf[MG_BUF_LEN];; 6461 ; 6462 while (mg_read(conn, buf, sizeof(buf)) > 0); 6463 ;; 6464}; 6465 ; 6466 ; 6467static int; 6468mg_read_inner(struct mg_connection *conn, void *buf, size_t len); 6469{; 6470 int64_t con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:187304,timeout,timeout,187304,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety," */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6421 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6422 }; 6423 if (timeout <= 0.0) {; 6424 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6425 / 1000.0;; 6426 }; 6427 start_time = mg_get_current_time_ns();; 6428 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6429 ; 6430 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6431 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6432 if (n == -2) {; 6433 if (nread == 0) {; 6434 nread = -1; /* Propagate the error */; 6435 }; 6436 break;; 6437 } else if (n == -1) {; 6438 /* timeout */; 6439 if (timeout >= 0.0) {; 6440 now = mg_get_current_time_ns();; 6441 if ((now - start_time) <= timeout_ns) {; 6442 continue;; 6443 }; 6444 }; 6445 break;; 6446 } else if (n == 0) {; 6447 break; /* No more data to read */; 6448 } else {; 6449 nread += n;; 6450 len -= n;; 6451 }; 6452 }; 6453 ; 6454 return nread;; 6455}; 6456 ; 6457 ; 6458static void; 6459discard_unread_request_data(struct mg_connection *conn); 6460{; 6461 char buf[MG_BUF_LEN];; 6462 ; 6463 while (mg_read(conn, buf, sizeof(buf)) > 0); 6464 ;; 6465}; 6466 ; 6467 ; 6468static int; 6469mg_read_inner(struct mg_connection *conn, void *buf, size_t len); 6470{; 6471 int64_t con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:187336,timeout,timeout,187336,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety," *a, const TMatrixDSparse *b) const;  multiply two sparse matrices ;  ; TMatrixDSparse * MultiplyMSparseMSparseTranspVector (const TMatrixDSparse *m1, const TMatrixDSparse *m2, const TMatrixTBase< Double_t > *v) const;  calculate a sparse matrix product M1*V*M2T where the diagonal matrix V is given by a vector ;  ; TMatrixDSparse * MultiplyMSparseTranspMSparse (const TMatrixDSparse *a, const TMatrixDSparse *b) const;  multiply a transposed Sparse matrix with another Sparse matrix ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; const TUnfoldBinning * fConstInputBins;  binning scheme for the input (detector level) ;  ; const TUnfoldBinning * fConstOutputBins;  binning scheme for the output (truth level) ;  ; TUnfoldBinning * fOwnedInputBins;  pointer to input binning scheme if owned by this class ;  ; TUnfoldBinning * fOwnedOutputBins;  pointer to output binning scheme if owned by this class ;  ; TUnfoldBinning * fRegularisationConditions;  binning scheme for the regularisation conditions ;  ;  Protected Attributes inherited from TUnfoldSys; TMatrixD * fAoutside;  Input: underflow/overflow bins. ;  ; TMap * fBgrErrScaleIn;  Input: background sources correlated error. ;  ; TMap * fBgrErrUncorrInSq;  Input: uncorr error squared from bgr sources. ;  ; TMap * fBgrIn;  Input: size of background sources. ;  ; TMatrixD * fDAinColRelSq;  Input: normalized column err.sq. (inp.matr.) ;  ; TMatrixDSparse * fDAinRelSq;  Input: normalized errors from input matrix. ;  ; TMap * fDeltaCorrAx;  Result: syst.shift from fSysIn on fAx. ;  ; TMap * fDeltaCorrX;  Result: syst.shift from fSysIn on fX. ;  ; TMatrixDSparse * fDeltaSysTau;  Result: systematic shift from tau. ;  ; Double_t fDtau;  Input: error on tau. ;  ; TMatrixDSparse * fEmatUncorrAx;  Result: syst.error from fDA2 on fAx. ;  ; TMatrixDSpa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldDensity.html:37007,detect,detector,37007,doc/master/classTUnfoldDensity.html,https://root.cern,https://root.cern/doc/master/classTUnfoldDensity.html,1,['detect'],['detector']
Safety," *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }. ----- script treer.C; void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }. TBranch* BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch() with added check that addobj matches className. See TTree::Branch() for other details. TBranch* BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); Deprecated function. Use next function instead. Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); Create one branch for each element in the collection. Each entry in the collection becomes a top level branch if the; corresponding class is not a collection. If it is a collecti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:40765,detect,detection,40765,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,6,['detect'],['detection']
Safety," *tree, const char *alias, bool warn); 1399{; 1400 if (!tree) {; 1401 return nullptr;; 1402 }; 1403 if (!fFriends) {; 1404 fFriends = new TList();; 1405 }; 1406 TFriendElement *fe = new TFriendElement(this, tree, alias);; 1407 R__ASSERT(fe); // this assert is for historical reasons. Don't remove it unless you understand all the consequences.; 1408 TTree *t = fe->GetTree();; 1409 if (warn && (t->GetEntries() < fEntries)) {; 1410 Warning(""AddFriend"", ""FriendElement '%s' in file '%s' has less entries %lld than its parent tree: %lld"",; 1411 tree->GetName(), fe->GetFile() ? fe->GetFile()->GetName() : ""(memory resident)"", t->GetEntries(),; 1412 fEntries);; 1413 }; 1414 if (CheckReshuffling(*this, *t)); 1415 fFriends->Add(fe);; 1416 else; 1417 tree->RemoveExternalFriend(fe);; 1418 return fe;; 1419}; 1420 ; 1421////////////////////////////////////////////////////////////////////////////////; 1422/// AutoSave tree header every fAutoSave bytes.; 1423///; 1424/// When large Trees are produced, it is safe to activate the AutoSave; 1425/// procedure. Some branches may have buffers holding many entries.; 1426/// If fAutoSave is negative, AutoSave is automatically called by; 1427/// TTree::Fill when the number of bytes generated since the previous; 1428/// AutoSave is greater than -fAutoSave bytes.; 1429/// If fAutoSave is positive, AutoSave is automatically called by; 1430/// TTree::Fill every N entries.; 1431/// This function may also be invoked by the user.; 1432/// Each AutoSave generates a new key on the file.; 1433/// Once the key with the tree header has been written, the previous cycle; 1434/// (if any) is deleted.; 1435///; 1436/// Note that calling TTree::AutoSave too frequently (or similarly calling; 1437/// TTree::SetAutoSave with a small value) is an expensive operation.; 1438/// You should make tests for your own application to find a compromise; 1439/// between speed and the quantity of information you may loose in case of; 1440/// a job crash.; 1441///; 1442/// In c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:52256,safe,safe,52256,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['safe'],['safe']
Safety," * ; b). overridevirtual . Browse pad. ; Reimplemented from TObject.; Definition at line 523 of file TPad.cxx. ◆ BuildLegend(). TLegend * TPad::BuildLegend ; (; Double_t ; x1 = 0.3, . Double_t ; y1 = 0.21, . Double_t ; x2 = 0.3, . Double_t ; y2 = 0.21, . const char * ; title = """", . Option_t * ; option = """" . ). overridevirtual . Build a legend from the graphical objects in the pad. ; A simple method to build automatically a TLegend from the primitives in a TPad.; Only those deriving from TAttLine, TAttMarker and TAttFill are added, excluding TPave and TFrame derived classes.; ReturnsThe built TLegend; Parameters. [in]x1,y1,x2,y2The TLegend coordinates ; [in]titleThe legend title. By default it is "" "" ; [in]optionThe TLegend option. The caller program owns the returned TLegend.; If the pad contains some TMultiGraph or THStack the individual graphs or histograms in them are added to the TLegend. Automatic placement of the legend; If x1 is equal to x2 and y1 is equal to y2 the legend will be automatically placed to avoid overlapping with the existing primitives already displayed. x1 is considered as the width of the legend and y1 the height. By default the legend is automatically placed with width = x1= x2 = 0.3 and height = y1= y2 = 0.21. ; Implements TVirtualPad.; Definition at line 555 of file TPad.cxx. ◆ cd(). TVirtualPad * TPad::cd ; (; Int_t ; subpadnumber = 0). overridevirtual . Set Current pad. ; When a canvas/pad is divided via TPad::Divide, one can directly set the current path to one of the subdivisions. See TPad::Divide for the convention to number sub-pads.; Returns the new current pad, or 0 in case of failure.; For example: c1.Divide(2,3); // create 6 pads (2 divisions along x, 3 along y).; To set the current pad to the bottom right pad, do c1.cd(6);; Note1: c1.cd() is equivalent to c1.cd(0) and sets the current pad to c1 itself.; Note2: after a statement like c1.cd(6), the global variable gPad points to the current pad. One can use gPad to set attributes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPad.html:59346,avoid,avoid,59346,doc/master/classTPad.html,https://root.cern,https://root.cern/doc/master/classTPad.html,1,['avoid'],['avoid']
Safety," * ; dir, . XMLNodePointer_t ; topnode . ). protected . Read list of keys for directory. ; Definition at line 630 of file TXMLFile.cxx. ◆ ReadStreamerElement(). void TXMLFile::ReadStreamerElement ; (; XMLNodePointer_t ; node, . TStreamerInfo * ; info . ). protected . read and reconstruct single TStreamerElement from xml node ; Definition at line 825 of file TXMLFile.cxx. ◆ Recover(). Int_t TXMLFile::Recover ; (; ). inlinefinalvirtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented from TFile.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:67028,recover,recovered,67028,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,2,"['recover', 'safe']","['recovered', 'safely']"
Safety," * ; elem, . Int_t ; comp_type . ). finalvirtual . Function is called from TStreamerInfo WriteBuffer and ReadBuffer functions and add/verify next element of json structure This calls allows separate data, correspondent to one class member, from another. ; Implements TBuffer.; Definition at line 2092 of file TBufferJSON.cxx. ◆ SetTypenameTag(). void TBufferJSON::SetTypenameTag ; (; const char * ; tag = ""_typename""). Configures _typename tag in JSON structures By default ""_typename"" field in JSON structures used to store class information One can specify alternative tag like ""$typename"" or ""xy"", but such JSON can not be correctly used in JSROOT If empty string is provided, class information will not be stored. ; Definition at line 578 of file TBufferJSON.cxx. ◆ SetTypeversionTag(). void TBufferJSON::SetTypeversionTag ; (; const char * ; tag = nullptr). Configures _typeversion tag in JSON One can specify name of the JSON tag like ""_typeversion"" or ""$tv"" which will be used to store class version Such tag can be used to correctly recover objects from JSON If empty string is provided (default), class version will not be stored. ; Definition at line 592 of file TBufferJSON.cxx. ◆ SkipObjectAny(). void TBufferJSON::SkipObjectAny ; (; ). finalvirtual . Skip any kind of object from buffer. ; Implements TBuffer.; Definition at line 2508 of file TBufferJSON.cxx. ◆ Stack(). TJSONStackObj * TBufferJSON::Stack ; (; ). inlineprotected . Definition at line 257 of file TBufferJSON.h. ◆ StoreObject(). TString TBufferJSON::StoreObject ; (; const void * ; obj, . const TClass * ; cl . ). Store provided object as JSON structure Allows to configure different TBufferJSON properties before converting object into JSON Actual object class must be specified here Method can be safely called once - after that TBufferJSON instance must be destroyed Code should look like: ; auto obj = new UserClass(); TBufferJSON buf; buf.SetCompact(TBufferJSON::kNoSpaces); // change any other settings in TBufferJSO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferJSON.html:86095,recover,recover,86095,doc/master/classTBufferJSON.html,https://root.cern,https://root.cern/doc/master/classTBufferJSON.html,1,['recover'],['recover']
Safety," * ; norm . ). pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ Contains(). virtual Bool_t TGeoBoolNode::Contains ; (; const Double_t * ; point); const. pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ CreateThreadData(). void TGeoBoolNode::CreateThreadData ; (; Int_t ; nthreads). Create thread data for n threads max. ; Definition at line 100 of file TGeoBoolNode.cxx. ◆ DeclFileName(). static const char * TGeoBoolNode::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 91 of file TGeoBoolNode.h. ◆ DistanceToPrimitive(). virtual Int_t TGeoBoolNode::DistanceToPrimitive ; (; Int_t ; px, . Int_t ; py . ). pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ DistFromInside(). virtual Double_t TGeoBoolNode::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = 0, . Double_t * ; safe = nullptr . ); const. pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ DistFromOutside(). virtual Double_t TGeoBoolNode::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = 0, . Double_t * ; safe = nullptr . ); const. pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ GetBooleanOperator(). virtual EGeoBoolType TGeoBoolNode::GetBooleanOperator ; (; ); const. pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ GetLeftMatrix(). TGeoMatrix * TGeoBoolNode::GetLeftMatrix ; (; ); const. inline . Definition at line 76 of file TGeoBoolNode.h. ◆ GetLeftShape(). TGeoShape * TGeoBoolNode::GetLeftShape ; (; ); const. inline . Definition at line 78 of file TGeoBoolNode.h. ◆ GetNpoints(). virtual Int_t TGeoBoolNode::GetNpoints ; (; ). pure virtual . Implemented in TGeoUnion, TGeoIntersection, and TGeoSubtraction. ◆ GetRightMatrix(). TGeoMatrix ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBoolNode.html:17147,safe,safe,17147,doc/master/classTGeoBoolNode.html,https://root.cern,https://root.cern/doc/master/classTGeoBoolNode.html,1,['safe'],['safe']
Safety," * ; pt, . const Double_t * ; dir, . Double_t ; t . ); const. ◆ DDaxis(). Double_t TGeoTorus::DDaxis ; (; const Double_t * ; pt, . const Double_t * ; dir, . Double_t ; t . ); const. ◆ DDDaxis(). Double_t TGeoTorus::DDDaxis ; (; const Double_t * ; pt, . const Double_t * ; dir, . Double_t ; t . ); const. ◆ DeclFileName(). static const char * TGeoTorus::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 91 of file TGeoTorus.h. ◆ DistancetoPrimitive(). Int_t TGeoTorus::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TGeoBBox. ◆ DistFromInside(). Double_t TGeoTorus::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromInside_v(). void TGeoTorus::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside(). Double_t TGeoTorus::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside_v(). void TGeoTorus::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Divide(). TGeoVolume * TGeoTorus::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTorus.html:25750,safe,safe,25750,doc/master/classTGeoTorus.html,https://root.cern,https://root.cern/doc/master/classTGeoTorus.html,1,['safe'],['safe']
Safety," + CurSize);; 1109 ; 1110 // Set end.; 1111 this->set_size(RHSSize);; 1112 ; 1113 RHS.clear();; 1114 return *this;; 1115}; 1116 ; 1117template <typename T>; 1118bool IsSmall(const ROOT::VecOps::RVec<T> &v); 1119{; 1120 return v.isSmall();; 1121}; 1122 ; 1123template <typename T>; 1124bool IsAdopting(const ROOT::VecOps::RVec<T> &v); 1125{; 1126 return !v.Owns();; 1127}; 1128 ; 1129} // namespace VecOps; 1130} // namespace Detail; 1131 ; 1132namespace VecOps {; 1133// Note that we open here with @{ the Doxygen group vecops and it is; 1134// closed again at the end of the C++ namespace VecOps; 1135/**; 1136 * \defgroup vecops VecOps; 1137 * A ""std::vector""-like collection of values implementing handy operation to analyse them; 1138 * @{; 1139*/; 1140 ; 1141// From the original SmallVector code:; 1142// This is a 'vector' (really, a variable-sized array), optimized; 1143// for the case when the array is small. It contains some number of elements; 1144// in-place, which allows it to avoid heap allocation when the actual number of; 1145// elements is below that threshold. This allows normal ""small"" cases to be; 1146// fast without losing generality for large inputs.; 1147//; 1148// Note that this does not attempt to be exception safe.; 1149 ; 1150template <typename T, unsigned int N>; 1151class R__CLING_PTRCHECK(off) RVecN : public Detail::VecOps::RVecImpl<T>, Internal::VecOps::SmallVectorStorage<T, N> {; 1152public:; 1153 RVecN() : Detail::VecOps::RVecImpl<T>(N) {}; 1154 ; 1155 ~RVecN(); 1156 {; 1157 if (this->Owns()) {; 1158 // Destroy the constructed elements in the vector.; 1159 this->destroy_range(this->begin(), this->end());; 1160 }; 1161 }; 1162 ; 1163 explicit RVecN(size_t Size, const T &Value) : Detail::VecOps::RVecImpl<T>(N) { this->assign(Size, Value); }; 1164 ; 1165 explicit RVecN(size_t Size) : Detail::VecOps::RVecImpl<T>(N); 1166 {; 1167 if (Size > N); 1168 this->grow(Size);; 1169 this->fSize = Size;; 1170 ROOT::Internal::VecOps::UninitializedValueConstruct(t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:39573,avoid,avoid,39573,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['avoid'],['avoid']
Safety," , kGeoTrd2 = (1ULL << ( 24 )); , kGeoComb = (1ULL << ( 25 )); , ;   kGeoClosedShape = (1ULL << ( 26 )); , kGeoXtru = (1ULL << ( 27 )); , kGeoParaboloid = (1ULL << ( 28 )); , kGeoHalfSpace = (1ULL << ( 29 )); , ;   kGeoHype = (1ULL << ( 30 )); , kGeoSavePrimitive = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  . #include <TGeoArb8.h>. Inheritance diagram for TGeoArb8:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EGeoArb8Type. enum TGeoArb8::EGeoArb8Type. protected . EnumeratorkArb8Trap ; kArb8Tra . Definition at line 19 of file TGeoArb8.h. Constructor & Destructor Documentation. ◆ TGeoArb8() [1/4]. TGeoArb8::TGeoArb8 ; (; const TGeoArb8 & ; ). protecteddelete . ◆ TGeoArb8() [2/4]. TGeoArb8::TGeoArb8 ; (; ). ◆ TGeoArb8() [3/4]. TGeoArb8::TGeoArb8 ; (; Double_t ; dz, . Double_t * ; vertices = nullptr . ). ◆ TGeoArb8() [4/4]. TGeoArb8::TGeoArb8 ; (; const char * ; name, . Double_t ; dz, . Double_t * ; vertices = nullptr . ). ◆ ~TGeoArb8(). TGeoArb8::~TGeoArb8 ; (; ). override . Member Function Documentation. ◆ Capacity(). Double_t TGeoArb8::Capacity ; (; ); const. overridevirtual . Implements TGeoShape. ◆ Class(). static TClass * T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoArb8.html:24983,detect,detection,24983,doc/master/classTGeoArb8.html,https://root.cern,https://root.cern/doc/master/classTGeoArb8.html,1,['detect'],['detection']
Safety," , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TSlave;  TSlave ();  Default constructor used by derived classes. ;  ; virtual void FlushSocket ();  ; void Init (TSocket *s, Int_t stype);  Init a PROOF slave object using the connection opened via s. ;  ; virtual void Interrupt (Int_t type);  Send interrupt OOB byte to master or slave servers. ;  ; virtual Int_t Ping ();  Ping the remote master or slave servers. ;  ; virtual TObjString * SendCoordinator (Int_t kind, const char *msg=0, Int_t int2=0);  Send message to intermediate coordinator. ;  ; virtual Int_t SendGroupPriority (const char *, Int_t);  ; virtual void SetAlias (const char *alias);  Set an alias for this session. ;  ; void SetSocket (TSocket *s);  ; virtual void SetStatus (Int_t st);  ; virtual void StopProcess (Bool_t abort, Int_t timeout);  Sent stop/abort request to PROOF server. ;  ;  Protected Member Functions inherited from TObject; void MakeZombie ();  ;  Protected Attributes inherited from TSlave; TString fArchComp;  ; Long64_t fBytesRead;  ; Float_t fCpuTime;  ; TString fGroup;  ; TString fImage;  ; TFileHandler * fInput;  ; TString fMsd;  ; TString fName;  ; TString fOrdinal;  ; Int_t fParallel;  ; Int_t fPerfIdx;  ; Int_t fPort;  ; TProof * fProof;  ; TString fProofWorkDir;  ; Int_t fProtocol;  ; Float_t fRealTime;  ; TString fROOTVers;  ; TString fSessionTag;  ; ESlaveType fSlaveType;  ; TSocket * fSocket;  ; Int_t fStatus;  ; TString fUser;  ; TString fWorkDir;  . #include <TSlaveLite.h>. Inheritance diagram for TSlaveLite:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TSlaveLite(). TSlaveLite::TSlaveLite ; (; const char * ; ord, . Int_t ; perf, . const char * ; image, . TPr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSlaveLite.html:12934,abort,abort,12934,doc/master/classTSlaveLite.html,https://root.cern,https://root.cern/doc/master/classTSlaveLite.html,3,"['abort', 'timeout']","['abort', 'timeout']"
Safety," - 1'; ports starting from port + 1, i.e. port + 1, ... , port + scan - 1. ~TApplicationRemote(); Destructor. Int_t Broadcast(const TMessage& mess); Broadcast a message to the remote session.; Returns 0 on success, -1 in case of error. Int_t Broadcast(const char* mess, Int_t kind = kMESS_STRING, Int_t type = kRRT_Undef); Broadcast a character string buffer to the remote session.; Use kind to set the TMessage what field.; Returns 0 on success, -1 in case of error. Int_t BroadcastObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Broadcast an object to the remote session.; Use kind to set the TMessage what field.; Returns 0 on success, -1 in case of error. Int_t BroadcastRaw(const void* buffer, Int_t length); Broadcast a raw buffer of specified length to the remote session.; Returns 0 on success, -1 in case of error. Int_t Collect(Long_t timeout = -1); Collect responses from the remote server.; Returns the number of messages received.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever). Int_t CollectInput(); Collect and analyze available input from the socket.; Returns 0 on success, -1 if any failure occurs. void RecvLogFile(Int_t size); Receive the log file from the server. Int_t SendObject(const TObject* obj); Send object to server.; Return 0 on success, -1 in case of error. Bool_t CheckFile(const char* file, Long_t modtime); Check if a file needs to be send to the server. Use the following; algorithm:; - check if file appears in file map; - if yes, get file's modtime and check against time in map,; if modtime not same get md5 and compare against md5 in map,; if not same return kTRUE.; - if no, get file's md5 and modtime and store in file map, ask; slave if file exists with specific md5, if yes return kFALSE,; if no return kTRUE.; Returns kTRUE in case file needs to be send, returns kFALSE in case; file is already on remote node. Int_t SendFile(const char* file, Int_t opt = kAscii, const char* rfile = 0); Send a fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TApplicationRemote.html:14600,timeout,timeout,14600,root/html526/TApplicationRemote.html,https://root.cern,https://root.cern/root/html526/TApplicationRemote.html,21,['timeout'],['timeout']
Safety," - a PDEFoam kernel (optional). If NULL is given, the; kernel is ignored and the pure cell values are; plotted. - nbin - number of bins in x and y direction of result histogram; (optional, default is 50). Returns:; a 2-dimensional histogram. Float_t GetCellValue(const PDEFoamCell* cell, ECellValue cv); Returns the cell value of 'cell' corresponding to the given; option 'cv'. This function should be overridden by the subclass; in order to specify which cell elements to return for a given; cell value 'cv'. By default kValue returns cell element 0, and; kValueError returns cell element 1. Double_t GetCellElement(const TMVA::PDEFoamCell* cell, UInt_t i) const; Returns cell element i of cell 'cell'. If the cell has no; elements or the index 'i' is out of range, than 0 is returned. void SetCellElement(TMVA::PDEFoamCell* cell, UInt_t i, Double_t value); Set cell element i of cell to value. If the cell element i does; not exist, it is created. void OutputGrow(Bool_t finished = false); Overridden function of PDEFoam to avoid native foam output.; Draw TMVA-process bar instead. void RootPlot2dim(const TString& filename, TString opt, Bool_t CreateCanvas = kTRUE, Bool_t colors = kTRUE); Debugging tool which plots the cells of a 2-dimensional PDEFoam; as rectangles in C++ format readable for ROOT. Parameters:; - filename - filename of ouput root macro. - opt - cell_value, rms, rms_ov_mean; If cell_value is set, the following values will be filled into; the result histogram:; - number of events - in case of classification with 2 separate; foams or multi-target regression; - discriminator - in case of classification with one; unified foam; - target - in case of mono-target regression; If none of {cell_value, rms, rms_ov_mean} is given, the cells; will not be filled.; If 'opt' contains the string 'cellnumber', the index of; each cell is draw in addition. - CreateCanvas - whether to create a new canvas or not. - colors - whether to fill cells with colors or shades of grey. Example:. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__PDEFoam.html:20868,avoid,avoid,20868,root/html530/TMVA__PDEFoam.html,https://root.cern,https://root.cern/root/html530/TMVA__PDEFoam.html,2,['avoid'],['avoid']
Safety," - a PDEFoam kernel (optional). If NULL is given, the; kernel is ignored and the pure cell values are; plotted. - nbin - number of bins in x and y direction of result histogram; (optional, default is 50). Returns:; a 2-dimensional histogram. Float_t GetCellValue(const PDEFoamCell* cell, ECellValue cv); Returns the cell value of 'cell' corresponding to the given; option 'cv'. This function should be overridden by the subclass; in order to specify which cell elements to return for a given; cell value 'cv'. By default kValue returns cell element 0, and; kValueError returns cell element 1. Double_t GetCellElement(const TMVA::PDEFoamCell* cell, UInt_t i) const; Returns cell element i of cell 'cell'. If the cell has no; elements or the index 'i' is out of range, than 0 is returned. void SetCellElement(TMVA::PDEFoamCell* cell, UInt_t i, Double_t value); Set cell element i of cell to value. If the cell element i does; not exist, it is created. void OutputGrow(Bool_t finished = false); Overridden function of PDEFoam to avoid native foam output.; Draw TMVA-process bar instead. void RootPlot2dim(const TString& filename, TString opt, Bool_t createCanvas = kTRUE, Bool_t colors = kTRUE); Debugging tool which plots the cells of a 2-dimensional PDEFoam; as rectangles in C++ format readable for ROOT. Parameters:; - filename - filename of ouput root macro. - opt - cell_value, rms, rms_ov_mean; If cell_value is set, the following values will be filled into; the result histogram:; - number of events - in case of classification with 2 separate; foams or multi-target regression; - discriminator - in case of classification with one; unified foam; - target - in case of mono-target regression; If none of {cell_value, rms, rms_ov_mean} is given, the cells; will not be filled.; If 'opt' contains the string 'cellnumber', the index of; each cell is draw in addition. - createCanvas - whether to create a new canvas or not. - colors - whether to fill cells with colors or shades of grey. Example:. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__PDEFoam.html:20881,avoid,avoid,20881,root/html534/TMVA__PDEFoam.html,https://root.cern,https://root.cern/root/html534/TMVA__PDEFoam.html,3,['avoid'],['avoid']
Safety," -= kExtraSpace;; 119 }; 120 if (!adopt) ResetBit(kIsOwner);; 121 } else {; 122 if (fBufSize < kMinimalSize) {; 123 fBufSize = kMinimalSize;; 124 }; 125 fBuffer = new char[(Long64_t)fBufSize+kExtraSpace];; 126 }; 127 fBufCur = fBuffer;; 128 fBufMax = fBuffer + fBufSize;; 129 ; 130 SetReAllocFunc( reallocfunc );; 131 ; 132 if (buf && ( (fMode&kWrite)!=0 ) && fBufSize < 0) {; 133 Expand( kMinimalSize );; 134 }; 135}; 136 ; 137////////////////////////////////////////////////////////////////////////////////; 138/// Delete an I/O buffer object.; 139 ; 140TBuffer::~TBuffer(); 141{; 142 if (TestBit(kIsOwner)) {; 143 //printf(""Deleting fBuffer=%lx\n"", fBuffer);; 144 delete [] fBuffer;; 145 }; 146 fBuffer = nullptr;; 147 fParent = nullptr;; 148}; 149 ; 150////////////////////////////////////////////////////////////////////////////////; 151/// Automatically calculate a new size and expand the buffer to fit at least size_needed.; 152/// The goals is to minimize the number of memory allocation and the memory allocation; 153/// which avoiding too much memory wastage.; 154///; 155/// If the size_needed is larger than the current size, the policy; 156/// is to expand to double the current size or the size_needed which ever is largest.; 157 ; 158void TBuffer::AutoExpand(Int_t size_needed); 159{; 160 if (size_needed < 0) {; 161 Fatal(""AutoExpand"",""Request to expand to a negative size, likely due to an integer overflow: 0x%x for a max of 0x%x."", size_needed, kMaxBufferSize);; 162 }; 163 if (size_needed > fBufSize) {; 164 Long64_t doubling = 2LLU * fBufSize;; 165 if (doubling > kMaxBufferSize); 166 doubling = kMaxBufferSize;; 167 if (size_needed > doubling) {; 168 Expand(size_needed);; 169 } else {; 170 Expand(doubling);; 171 }; 172 }; 173}; 174 ; 175////////////////////////////////////////////////////////////////////////////////; 176/// Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; 177/// new buffer is expected to have the same size as the previous buffer.; 17",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBuffer_8cxx_source.html:5114,avoid,avoiding,5114,doc/master/TBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html,1,['avoid'],['avoiding']
Safety," . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » ROOT 6 Analysis Workshop 5. Fitting. Distributions; Some analyses want to check theory predictions that exist as a function definition. Others want to use a distribution from a histogram in another step of the analysis. But histograms have bin steps by nature instead of being smooth, and they have bumps / fluctuations due to limited statistics (i.e. ""not enough data"").; So what's needed is a function whose line is ""as close as possible"" to the histogram counts. I.e. we need a function (that predicts the shape of the histogram) and that we can vary a bit (""free parameters""). Then we search for the best set of parameters, such that the function resembles the histogram.; That's fitting.; Fitting in Practice; As often with ROOT, you can use a GUI element (the fit panel, available through the menu in ""Tools"", ""Fit Panel"", or on the prompt (TH1::Fit()). Let's use the fit panel!; First, we draw the distribution of the vertex position along X for all muons. Do that into a histogram that has 20 bins and runs from -10 to +10. Now open the fit panel and click the histogram. We wan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/5-fitting.html:1934,predict,predictions,1934,d/5-fitting.html,https://root.cern,https://root.cern/d/5-fitting.html,1,['predict'],['predictions']
Safety," . Conversion method to create VecGeom solid corresponding to TGeoShape. ; Definition at line 104 of file TGeoVGShape.cxx. ◆ DistancetoPrimitive(). Int_t TGeoVGShape::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). inlineoverridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TGeoBBox.; Definition at line 52 of file TGeoVGShape.h. ◆ DistFromInside(). Double_t TGeoVGShape::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox.; Definition at line 448 of file TGeoVGShape.cxx. ◆ DistFromOutside(). Double_t TGeoVGShape::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox.; Definition at line 458 of file TGeoVGShape.cxx. ◆ Divide(). TGeoVolume * TGeoVGShape::Divide ; (; TGeoVolume * ; , . const char * ; , . Int_t ; , . Int_t ; , . Double_t ; , . Double_t ;  . ). inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 57 of file TGeoVGShape.h. ◆ Draw(). void TGeoVGShape::Draw ; (; Option_t * ; option = """"). inlineoverridevirtual . Draw this shape. ; Reimplemented from TGeoShape.; Definition at line 58 of file TGeoVGShape.h. ◆ GetAxisName(). const char * TGeoVGShape::GetAxisName ; (; Int_t ; iaxis); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 59 of file TGeoVGShape.h. ◆ GetAxisRange(). Double_t TGeoVGShape::GetAxisRange ; (; Int_t ; iaxis, . Double_t & ; xlo, . Double_t & ; xhi . ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 60 of file TGeoVGShape.h. ◆ GetBoundingCylinder(). void TGeoVGShape::Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVGShape.html:25972,safe,safe,25972,doc/master/classTGeoVGShape.html,https://root.cern,https://root.cern/doc/master/classTGeoVGShape.html,1,['safe'],['safe']
Safety," . Definition at line 166 of file TGeoShape.h. ◆ Safety(). virtual Double_t TGeoShape::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. pure virtual . Implemented in TGeoArb8, TGeoTrap, TGeoGtra, TGeoBBox, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, TGeoXtru, and TGeoVGShape. ◆ Safety_v(). virtual void TGeoShape::Safety_v ; (; const Double_t * ; , . const Bool_t * ; , . Double_t * ; , . Int_t ;  . ); const. inlinevirtual . Reimplemented in TGeoArb8, TGeoTrap, TGeoGtra, TGeoBBox, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, and TGeoXtru.; Definition at line 151 of file TGeoShape.h. ◆ SafetyPhi(). Double_t TGeoShape::SafetyPhi ; (; const Double_t * ; point, . Bool_t ; in, . Double_t ; phi1, . Double_t ; phi2 . ). static . Static method to compute safety w.r.t a phi corner defined by cosines/sines of the angles phi1, phi2. ; Definition at line 494 of file TGeoShape.cxx. ◆ SafetySeg(). Double_t TGeoShape::SafetySeg ; (; Double_t ; r, . Double_t ; z, . Double_t ; r1, . Double_t ; z1, . Double_t ; r2, . Double_t ; z2, . Bool_t ; outer . ). static . Compute distance from point of coordinates (r,z) to segment (r1,z1):(r2,z2) ; Definition at line 528 of file TGeoShape.cxx. ◆ SetDimensions(). virtual void TGeoShape::SetDimensions ; (; Double_t * ; param). pure virtual . Implemented in TGeoCompositeShape, TGeoArb8, TGeoTrap, TGeoGtra, TGeoBBox, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, TGeoXtru, and TGeoVGShape. ◆ SetId(). void TGeoShape::SetId",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShape.html:46532,Safe,SafetyPhi,46532,doc/master/classTGeoShape.html,https://root.cern,https://root.cern/doc/master/classTGeoShape.html,1,['Safe'],['SafetyPhi']
Safety," . Definition at line 192 of file TTreeFormula.h. ◆ GetMethodCall(). TMethodCall * TTreeFormula::GetMethodCall ; (; Int_t ; code); const. Return methodcall corresponding to code. ; function called by TLeafObject::GetValue with the value of fLookupType computed in TTreeFormula::DefinedVariable ; Definition at line 4476 of file TTreeFormula.cxx. ◆ GetMultiplicity(). virtual Int_t TTreeFormula::GetMultiplicity ; (; ); const. inlinevirtual . Definition at line 194 of file TTreeFormula.h. ◆ GetNcodes(). virtual Int_t TTreeFormula::GetNcodes ; (; ); const. inlinevirtual . Definition at line 196 of file TTreeFormula.h. ◆ GetNdata(). Int_t TTreeFormula::GetNdata ; (; ). virtual . Return number of available instances in the formula. ; Definition at line 4485 of file TTreeFormula.cxx. ◆ GetRealInstance(). Int_t TTreeFormula::GetRealInstance ; (; Int_t ; instance, . Int_t ; codeindex . ). protected . Now let calculate what physical instance we really need. ; Some redundant code is used to speed up the cases where they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so we can skip the modulo when virt_dim is 0. ; Definition at line 3362 of file TTreeFormula.cxx. ◆ GetTree(). virtual TTree * TTreeFormula::GetTree ; (; ); const. inlinevirtual . Definition at line 213 of file TTreeFormula.h. ◆ GetValueFromMethod(). Double_t TTreeFormula::GetValueFromMethod ; (; Int_t ; i, . TLeaf * ; leaf . ); const. protectedvirtual . Return result of a leafobject method. ; Definition at line 4493 of file TTreeFormula.cxx. ◆ GetValuePointerFromMethod(). void * TTreeFormula::GetValuePointerFromMethod ; (; Int_t ; i, . TLeaf * ; leaf . ); const. protectedvirtual . Return result of a leafobject method. ; Definition at line 4554 of file TTreeFormula.cxx. ◆ Init(). void TTreeFormula::Init ; (; const char * ; name, . const char * ; formula . ). protected . Initialization called from the constructors. ; Definition at line 178 of file TTreeFormula.cxx. ◆ IsA(). TClass * TTreeForm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeFormula.html:41972,redund,redundant,41972,doc/master/classTTreeFormula.html,https://root.cern,https://root.cern/doc/master/classTTreeFormula.html,1,['redund'],['redundant']
Safety," . Int_t & ; iz . ); const. ◆ Divide(). TGeoVolume * TGeoPcon::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ Dphi(). Double_t & TGeoPcon::Dphi ; (; ). inline . Definition at line 94 of file TGeoPcon.h. ◆ GetAxisName(). const char * TGeoPcon::GetAxisName ; (; Int_t ; iaxis); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetAxisRange(). Double_t TGeoPcon::GetAxisRange ; (; Int_t ; iaxis, . Double_t & ; xlo, . Double_t & ; xhi . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetBoundingCylinder(). void TGeoPcon::GetBoundingCylinder ; (; Double_t * ; param); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ GetBuffer3D(). const TBuffer3D & TGeoPcon::GetBuffer3D ; (; Int_t ; reqSections, . Bool_t ; localFrame . ); const. overridevirtual . Stub implementation to avoid forcing implementation at this stage. ; Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ GetByteCount(). Int_t TGeoPcon::GetByteCount ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon.; Definition at line 75 of file TGeoPcon.h. ◆ GetDphi(). Double_t TGeoPcon::GetDphi ; (; ); const. inline . Definition at line 77 of file TGeoPcon.h. ◆ GetMakeRuntimeShape(). TGeoShape * TGeoPcon::GetMakeRuntimeShape ; (; TGeoShape * ; , . TGeoMatrix * ;  . ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon.; Definition at line 86 of file TGeoPcon.h. ◆ GetMeshNumbers(). void TGeoPcon::GetMeshNumbers ; (; Int_t & ; nvert, . Int_t & ; nsegs, . Int_t & ; npols . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ GetNmeshVertices(). Int_t TGeoPcon::GetNmeshVertices ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ GetNsegments(). virtual Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPcon.html:28258,avoid,avoid,28258,doc/master/classTGeoPcon.html,https://root.cern,https://root.cern/doc/master/classTGeoPcon.html,1,['avoid'],['avoid']
Safety," . const ColumnNames_t & ; branches, . const RColumnRegister & ; colRegister, . TTree * ; tree, . RDataSource * ; ds . ). Book the jitting of a Filter call. ; Definition at line 658 of file RDFInterfaceUtils.cxx. ◆ BookVariationJit(). std::shared_ptr< RJittedVariation > ROOT::Internal::RDF::BookVariationJit ; (; const std::vector< std::string > & ; colNames, . std::string_view ; variationName, . const std::vector< std::string > & ; variationTags, . std::string_view ; expression, . RLoopManager & ; lm, . RDataSource * ; ds, . const RColumnRegister & ; colRegister, . const ColumnNames_t & ; branches, . std::shared_ptr< RNodeBase > * ; upcastNodeOnHeap, . bool ; isSingleColumn . ). Book the jitting of a Vary call. ; Definition at line 782 of file RDFInterfaceUtils.cxx. ◆ CacheLineStep(). template<typename T > . constexpr std::size_t ROOT::Internal::RDF::CacheLineStep ; (; ). constexpr . Stepping through CacheLineStep<T> values in a vector<T> brings you to a new cache line. ; Useful to avoid false sharing. ; Definition at line 222 of file Utils.hxx. ◆ ChangeEmptyEntryRange(). void ROOT::Internal::RDF::ChangeEmptyEntryRange ; (; const ROOT::RDF::RNode & ; node, . std::pair< ULong64_t, ULong64_t > && ; newRange . ). Definition at line 13 of file RInterface.cxx. ◆ ChangeSpec(). void ROOT::Internal::RDF::ChangeSpec ; (; const ROOT::RDF::RNode & ; node, . ROOT::RDF::Experimental::RDatasetSpec && ; spec . ). Changes the input dataset specification of an RDataFrame. ; Parameters. nodeAny node of the computation graph. ; specThe new specification. . Definition at line 26 of file RInterface.cxx. ◆ CheckForDefinition(). void ROOT::Internal::RDF::CheckForDefinition ; (; const std::string & ; where, . std::string_view ; definedColView, . const RColumnRegister & ; colRegister, . const ColumnNames_t & ; treeColumns, . const ColumnNames_t & ; dataSourceColumns . ). Throw if column definedColView is not already there. ; Definition at line 513 of file RDFInterfaceUtils.cxx. ◆ CheckForDup",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1RDF.html:22883,avoid,avoid,22883,doc/master/namespaceROOT_1_1Internal_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1RDF.html,1,['avoid'],['avoid']
Safety," . std::size_t ; nVariations, . std::string_view ; variationName . ). inline . Register systematic variations for for multiple existing columns using custom variation tags. ; Parameters. [in]colNamesset of names of the columns for which varied values are provided. ; [in]expressiona callable that evaluates the varied values for the specified columns. The callable can take any column values as input, similarly to what happens during Filter and Define calls. It must return an RVec of varied values, one for each variation tag, in the same order as the tags. ; [in]inputColumnsthe names of the columns to be passed to the callable. ; [in]inputColumnsthe names of the columns to be passed to the callable. ; [in]nVariationsnumber of variations returned by the expression. The corresponding tags will be ""0"", ""1"", etc. ; [in]variationNamea generic name for this set of varied values, e.g. ""ptvariation"". colName is used if none is provided. NoteThis overload ensures that the ambiguity between C++20 string, vector<string> construction from init list is avoided.; See alsoThis Vary() overload for more information. ; Definition at line 1043 of file RInterface.hxx. ◆ Vary() [7/11]. template<typename Proxied , typename DataSource = void> . RInterface< Proxied, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::Vary ; (; std::initializer_list< std::string > ; colNames, . std::string_view ; expression, . std::size_t ; nVariations, . std::string_view ; variationName . ). inline . Register systematic variations for multiple existing columns using auto-generated variation tags. ; Parameters. [in]colNamesset of names of the columns for which varied values are provided. ; [in]expressiona string containing valid C++ code that evaluates to an RVec containing the varied values for the specified column. ; [in]nVariationsnumber of variations returned by the expression. The corresponding tags will be ""0"", ""1"", etc. ; [in]variationNamea generic name for this set of varied values, e.g. ""ptvariation""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:146743,avoid,avoided,146743,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['avoid'],['avoided']
Safety," / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::fTimeUpdttime between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?. private:. TList*fActivenodes with unfinished files; Float_tfBaseLocalPreferenceindicates how much more likely the nodes will be; Bool_tfCachePacketSynccontrol synchronization of cache and packet sizes; TList*fFileNodesnodes with files; TSortedList*fFilesToProcessGlobal list of files (TFileStat) to be processed; Bool_tfForceLocalif 1 - eliminate the remote processing; Float_tfFractionOfRemoteFilesfraction of TDSetElements that are on non-workers; Double_tfMaxEntriesRatiomax file entries to avg allowed ratio for cache-to-packet sync; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Long64_tfNEventsOnRemLocnumber of events in currently; Int_tfPacketAsAFractionused to calculate the packet size; TList*fPartitionslist of partitions on nodes; Int_tfStrategy0 means the classic and 1 (default) - the adaptive strategy; TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* file); Remove file from the list of acti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPacketizerAdaptive.html:11167,avoid,avoid,11167,root/html528/TPacketizerAdaptive.html,https://root.cern,https://root.cern/root/html528/TPacketizerAdaptive.html,1,['avoid'],['avoid']
Safety," /* Wait until process is terminated (don't leave zombies) */; 11260 while (waitpid(proc->pid, &status, 0) != (pid_t)-1) /* nop */; 11261 ;; 11262 } else {; 11263 DEBUG_TRACE(""CGI timer: Child process %d already stopped\n"", proc->pid);; 11264 }; 11265 /* Dec reference counter */; 11266 refs = mg_atomic_dec(&proc->references);; 11267 if (refs == 0) {; 11268 /* no more references - free data */; 11269 mg_free(data);; 11270 }; 11271 ; 11272 return 0;; 11273}; 11274 ; 11275 ; 11276/* Local (static) function assumes all arguments are valid. */; 11277static void; 11278handle_cgi_request(struct mg_connection *conn,; 11279 const char *prog,; 11280 unsigned char cgi_config_idx); 11281{; 11282 char *buf;; 11283 size_t buflen;; 11284 int headers_len, data_len, i, truncated;; 11285 int fdin[2] = {-1, -1}, fdout[2] = {-1, -1}, fderr[2] = {-1, -1};; 11286 const char *status, *status_text, *connection_state;; 11287 char *pbuf, dir[UTF8_PATH_MAX], *p;; 11288 struct mg_request_info ri;; 11289 struct cgi_environment blk;; 11290 FILE *in = NULL, *out = NULL, *err = NULL;; 11291 struct mg_file fout = STRUCT_FILE_INITIALIZER;; 11292 pid_t pid = (pid_t)-1;; 11293 struct process_control_data *proc = NULL;; 11294 ; 11295#if defined(USE_TIMERS); 11296 double cgi_timeout;; 11297 if (conn->dom_ctx->config[CGI_TIMEOUT + cgi_config_idx]) {; 11298 /* Get timeout in seconds */; 11299 cgi_timeout =; 11300 atof(conn->dom_ctx->config[CGI_TIMEOUT + cgi_config_idx]) * 0.001;; 11301 } else {; 11302 cgi_timeout =; 11303 atof(config_options[REQUEST_TIMEOUT].default_value) * 0.001;; 11304 }; 11305 ; 11306#endif; 11307 ; 11308 buf = NULL;; 11309 buflen = conn->phys_ctx->max_request_size;; 11310 i = prepare_cgi_environment(conn, prog, &blk, cgi_config_idx);; 11311 if (i != 0) {; 11312 blk.buf = NULL;; 11313 blk.var = NULL;; 11314 goto done;; 11315 }; 11316 ; 11317 /* CGI must be executed in its own directory. 'dir' must point to the; 11318 * directory containing executable program, 'p' must point to the; 11",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:326602,timeout,timeout,326602,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety," /* Wait until process is terminated (don't leave zombies) */; 11261 while (waitpid(proc->pid, &status, 0) != (pid_t)-1) /* nop */; 11262 ;; 11263 } else {; 11264 DEBUG_TRACE(""CGI timer: Child process %d already stopped\n"", proc->pid);; 11265 }; 11266 /* Dec reference counter */; 11267 refs = mg_atomic_dec(&proc->references);; 11268 if (refs == 0) {; 11269 /* no more references - free data */; 11270 mg_free(data);; 11271 }; 11272 ; 11273 return 0;; 11274}; 11275 ; 11276 ; 11277/* Local (static) function assumes all arguments are valid. */; 11278static void; 11279handle_cgi_request(struct mg_connection *conn,; 11280 const char *prog,; 11281 unsigned char cgi_config_idx); 11282{; 11283 char *buf;; 11284 size_t buflen;; 11285 int headers_len, data_len, i, truncated;; 11286 int fdin[2] = {-1, -1}, fdout[2] = {-1, -1}, fderr[2] = {-1, -1};; 11287 const char *status, *status_text, *connection_state;; 11288 char *pbuf, dir[UTF8_PATH_MAX], *p;; 11289 struct mg_request_info ri;; 11290 struct cgi_environment blk;; 11291 FILE *in = NULL, *out = NULL, *err = NULL;; 11292 struct mg_file fout = STRUCT_FILE_INITIALIZER;; 11293 pid_t pid = (pid_t)-1;; 11294 struct process_control_data *proc = NULL;; 11295 ; 11296#if defined(USE_TIMERS); 11297 double cgi_timeout;; 11298 if (conn->dom_ctx->config[CGI_TIMEOUT + cgi_config_idx]) {; 11299 /* Get timeout in seconds */; 11300 cgi_timeout =; 11301 atof(conn->dom_ctx->config[CGI_TIMEOUT + cgi_config_idx]) * 0.001;; 11302 } else {; 11303 cgi_timeout =; 11304 atof(config_options[REQUEST_TIMEOUT].default_value) * 0.001;; 11305 }; 11306 ; 11307#endif; 11308 ; 11309 buf = NULL;; 11310 buflen = conn->phys_ctx->max_request_size;; 11311 i = prepare_cgi_environment(conn, prog, &blk, cgi_config_idx);; 11312 if (i != 0) {; 11313 blk.buf = NULL;; 11314 blk.var = NULL;; 11315 goto done;; 11316 }; 11317 ; 11318 /* CGI must be executed in its own directory. 'dir' must point to the; 11319 * directory containing executable program, 'p' must point to the; 11",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:326635,timeout,timeout,326635,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety," // Making a volume with a given shape in one step; TGeoVolume *vol = gGeoManager->MakeBox(""VNAME"",ptrMed,dx,dy,dz);; TGeoVolume *vol = gGeoManager->MakeTubs(""VNAME"",ptrMed,rmin,rmax,; dz,phi1,phi2);. // See class TGeoManager for the rest of shapes.; // Making a volume with a given shape with a unique prototype; TGeoVolume *vol = gGeoManager->Volume(""VNAME"",""XXXX"",nmed,upar,; npar);. // Where XXXX stands for the first 4 letters of the specific shape; // classes, nmed is the medium number, upar is an Double_t * array; // of the shape parameters and npar is the number of parameters.; // This prototype allows (npar = 0) to define volumes with shape; // defined only at positioning time (volumes defined in this way; // need to be positioned using TGeoManager::Node() method); 18.4.2.3 Positioned Volumes (Nodes); Geometrical modeling is a difficult task when the number of different geometrical objects is 106-108. This is more or less the case for detector geometries of complex experiments, where a ‘flat’ CSG model description cannot scale with the current CPU performances. This is the reason why models like GEANT [1] introduced an additional dimension (depth) in order to reduce the complexity of the problem. This concept is also preserved by the ROOT modeller and introduces a pure geometrical constraint between objects (volumes in our case) - containment. This means in fact that any positioned volume has to be contained by another. Now what means contained and positioned?. We will say that a volume contains a point if this is inside the shape associated to the volume. For instance, a volume having a box shape will contain all points P=(X,Y,Z) verifying the conditions: Abs(Pi)dXi. The points on the shape boundaries are considered as inside the volume. The volume contains a daughter if it contains all the points contained by the daughter.; The definition of containment works of course only with points defined in the local coordinate system of the considered volume. Positionin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:936748,detect,detector,936748,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['detect'],['detector']
Safety," // Swap the shared elements.; 970 size_t NumShared = this->size();; 971 if (NumShared > RHS.size()); 972 NumShared = RHS.size();; 973 for (size_type i = 0; i != NumShared; ++i); 974 std::iter_swap(this->begin() + i, RHS.begin() + i);; 975 ; 976 // Copy over the extra elts.; 977 if (this->size() > RHS.size()) {; 978 size_t EltDiff = this->size() - RHS.size();; 979 this->uninitialized_copy(this->begin() + NumShared, this->end(), RHS.end());; 980 RHS.set_size(RHS.size() + EltDiff);; 981 if (this->Owns()); 982 this->destroy_range(this->begin() + NumShared, this->end());; 983 this->set_size(NumShared);; 984 } else if (RHS.size() > this->size()) {; 985 size_t EltDiff = RHS.size() - this->size();; 986 this->uninitialized_copy(RHS.begin() + NumShared, RHS.end(), this->end());; 987 this->set_size(this->size() + EltDiff);; 988 if (RHS.Owns()); 989 this->destroy_range(RHS.begin() + NumShared, RHS.end());; 990 RHS.set_size(NumShared);; 991 }; 992}; 993 ; 994template <typename T>; 995RVecImpl<T> &RVecImpl<T>::operator=(const RVecImpl<T> &RHS); 996{; 997 // Avoid self-assignment.; 998 if (this == &RHS); 999 return *this;; 1000 ; 1001 // If we already have sufficient space, assign the common elements, then; 1002 // destroy any excess.; 1003 size_t RHSSize = RHS.size();; 1004 size_t CurSize = this->size();; 1005 if (CurSize >= RHSSize) {; 1006 // Assign common elements.; 1007 iterator NewEnd;; 1008 if (RHSSize); 1009 NewEnd = std::copy(RHS.begin(), RHS.begin() + RHSSize, this->begin());; 1010 else; 1011 NewEnd = this->begin();; 1012 ; 1013 // Destroy excess elements.; 1014 if (this->Owns()); 1015 this->destroy_range(NewEnd, this->end());; 1016 ; 1017 // Trim.; 1018 this->set_size(RHSSize);; 1019 return *this;; 1020 }; 1021 ; 1022 // If we have to grow to have enough elements, destroy the current elements.; 1023 // This allows us to avoid copying them during the grow.; 1024 // From the original LLVM implementation:; 1025 // FIXME: don't do this if they're efficiently moveable.; 102",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:34943,Avoid,Avoid,34943,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['Avoid'],['Avoid']
Safety," 0) {; 19283 for (i = 0; i < ctx->num_listening_sockets; i++) {; 19284 /* NOTE(lsm): on QNX, poll() returns POLLRDNORM after the; 19285 * successful poll, and POLLIN is defined as; 19286 * (POLLRDNORM | POLLRDBAND); 19287 * Therefore, we're checking pfd[i].revents & POLLIN, not; 19288 * pfd[i].revents == POLLIN. */; 19289 if (STOP_FLAG_IS_ZERO(&ctx->stop_flag); 19290 && (pfd[i].revents & POLLIN)) {; 19291 accept_new_connection(&ctx->listening_sockets[i], ctx);; 19292 }; 19293 }; 19294 }; 19295 }; 19296 ; 19297 /* Here stop_flag is 1 - Initiate shutdown. */; 19298 DEBUG_TRACE(""%s"", ""stopping workers"");; 19299 ; 19300 /* Stop signal received: somebody called mg_stop. Quit. */; 19301 close_all_listening_sockets(ctx);; 19302 ; 19303 /* Wakeup workers that are waiting for connections to handle. */; 19304#if defined(ALTERNATIVE_QUEUE); 19305 for (i = 0; i < ctx->cfg_worker_threads; i++) {; 19306 event_signal(ctx->client_wait_events[i]);; 19307 }; 19308#else; 19309 (void)pthread_mutex_lock(&ctx->thread_mutex);; 19310 pthread_cond_broadcast(&ctx->sq_full);; 19311 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 19312#endif; 19313 ; 19314 /* Join all worker threads to avoid leaking threads. */; 19315 workerthreadcount = ctx->cfg_worker_threads;; 19316 for (i = 0; i < workerthreadcount; i++) {; 19317 if (ctx->worker_threadids[i] != 0) {; 19318 mg_join_thread(ctx->worker_threadids[i]);; 19319 }; 19320 }; 19321 ; 19322#if defined(USE_LUA); 19323 /* Free Lua state of lua background task */; 19324 if (ctx->lua_background_state) {; 19325 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 19326 ctx->lua_bg_log_available = 0;; 19327 ; 19328 /* call ""stop()"" in Lua */; 19329 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19330 lua_getglobal(lstate, ""stop"");; 19331 if (lua_type(lstate, -1) == LUA_TFUNCTION) {; 19332 int ret = lua_pcall(lstate, /* args */ 0, /* results */ 0, 0);; 19333 if (ret != 0) {; 19334 struct mg_connection fc;; 19335 lua_cry(fake_connection(&fc, ctx),; 19336 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:576157,avoid,avoid,576157,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['avoid'],['avoid']
Safety," 0) {; 19284 for (i = 0; i < ctx->num_listening_sockets; i++) {; 19285 /* NOTE(lsm): on QNX, poll() returns POLLRDNORM after the; 19286 * successful poll, and POLLIN is defined as; 19287 * (POLLRDNORM | POLLRDBAND); 19288 * Therefore, we're checking pfd[i].revents & POLLIN, not; 19289 * pfd[i].revents == POLLIN. */; 19290 if (STOP_FLAG_IS_ZERO(&ctx->stop_flag); 19291 && (pfd[i].revents & POLLIN)) {; 19292 accept_new_connection(&ctx->listening_sockets[i], ctx);; 19293 }; 19294 }; 19295 }; 19296 }; 19297 ; 19298 /* Here stop_flag is 1 - Initiate shutdown. */; 19299 DEBUG_TRACE(""%s"", ""stopping workers"");; 19300 ; 19301 /* Stop signal received: somebody called mg_stop. Quit. */; 19302 close_all_listening_sockets(ctx);; 19303 ; 19304 /* Wakeup workers that are waiting for connections to handle. */; 19305#if defined(ALTERNATIVE_QUEUE); 19306 for (i = 0; i < ctx->cfg_worker_threads; i++) {; 19307 event_signal(ctx->client_wait_events[i]);; 19308 }; 19309#else; 19310 (void)pthread_mutex_lock(&ctx->thread_mutex);; 19311 pthread_cond_broadcast(&ctx->sq_full);; 19312 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 19313#endif; 19314 ; 19315 /* Join all worker threads to avoid leaking threads. */; 19316 workerthreadcount = ctx->cfg_worker_threads;; 19317 for (i = 0; i < workerthreadcount; i++) {; 19318 if (ctx->worker_threadids[i] != 0) {; 19319 mg_join_thread(ctx->worker_threadids[i]);; 19320 }; 19321 }; 19322 ; 19323#if defined(USE_LUA); 19324 /* Free Lua state of lua background task */; 19325 if (ctx->lua_background_state) {; 19326 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 19327 ctx->lua_bg_log_available = 0;; 19328 ; 19329 /* call ""stop()"" in Lua */; 19330 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19331 lua_getglobal(lstate, ""stop"");; 19332 if (lua_type(lstate, -1) == LUA_TFUNCTION) {; 19333 int ret = lua_pcall(lstate, /* args */ 0, /* results */ 0, 0);; 19334 if (ret != 0) {; 19335 struct mg_connection fc;; 19336 lua_cry(fake_connection(&fc, ctx),; 19337 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:576190,avoid,avoid,576190,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['avoid'],['avoid']
Safety," 0; }. Int_t SysClose(Int_t ); { return 0; }. Int_t SysRead(Int_t , void* , Int_t ); { return 0; }. Int_t SysWrite(Int_t , const void* , Int_t ); { return 0; }. Long64_t SysSeek(Int_t , Long64_t , Int_t ); { return 0; }. Int_t SysStat(Int_t , Long_t* , Long64_t* , Long_t* , Long_t* ); { return 0; }. Int_t SysSync(Int_t ); { return 0; }. void DrawMap(const char* = ""*"", Option_t* = """"); {}. void FillBuffer(char*& ); {}. void Flush(); {}. Long64_t GetEND() const; { return 0; }. Int_t GetErrno() const; { return 0; }. void ResetErrno() const; {}. Int_t GetNfree() const; { return 0; }. Int_t GetNbytesInfo() const; {return 0; }. Int_t GetNbytesFree() const; {return 0; }. Long64_t GetSeekFree() const; {return 0; }. Long64_t GetSeekInfo() const; {return 0; }. Long64_t GetSize() const; { return 0; }. Int_t GetIOVersion() const; { return fIOVersion; }. void MakeFree(Long64_t , Long64_t ); {}. void MakeProject(const char* , const char* = ""*"", Option_t* = ""new""); {}. void Map(); {}. void Paint(Option_t* = """"); {}. void Print(Option_t* = """") const; {}. Bool_t ReadBuffer(char* , Int_t ); { return kFALSE; }. Bool_t ReadBuffer(char* , Long64_t , Int_t ); { return kFALSE; }. void ReadFree(); {}. Int_t Recover(); { return 0; }. void Seek(Long64_t , TFile::ERelativeTo = kBeg); {}. void SetEND(Long64_t ); {}. Int_t Sizeof() const; { return 0; }. void UseCache(Int_t = 10, Int_t = 0); {}. Bool_t WriteBuffer(const char* , Int_t ); { return kFALSE; }. Int_t Write(const char* = 0, Int_t = 0, Int_t = 0); { return 0; }. Int_t Write(const char* = 0, Int_t = 0, Int_t = 0) const; { return 0; }. void WriteFree(); {}. void WriteHeader(); {}. » Author: Sergey Linev 10.05.2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/xml:$Id: TXMLFile.h 34444 2010-07-16 02:17:39Z pcanal $ » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLFile.html:33957,Recover,Recover,33957,root/html528/TXMLFile.html,https://root.cern,https://root.cern/root/html528/TXMLFile.html,1,['Recover'],['Recover']
Safety," 0; }. Int_t SysClose(Int_t ); { return 0; }. Int_t SysRead(Int_t , void* , Int_t ); { return 0; }. Int_t SysWrite(Int_t , const void* , Int_t ); { return 0; }. Long64_t SysSeek(Int_t , Long64_t , Int_t ); { return 0; }. Int_t SysStat(Int_t , Long_t* , Long64_t* , Long_t* , Long_t* ); { return 0; }. Int_t SysSync(Int_t ); { return 0; }. void DrawMap(const char* = ""*"", Option_t* = """"); {}. void FillBuffer(char*& ); {}. void Flush(); {}. Long64_t GetEND() const; { return 0; }. Int_t GetErrno() const; { return 0; }. void ResetErrno() const; {}. Int_t GetNfree() const; { return 0; }. Int_t GetNbytesInfo() const; {return 0; }. Int_t GetNbytesFree() const; {return 0; }. Long64_t GetSeekFree() const; {return 0; }. Long64_t GetSeekInfo() const; {return 0; }. Long64_t GetSize() const; { return 0; }. Int_t GetIOVersion() const; { return fIOVersion; }. void MakeFree(Long64_t , Long64_t ); {}. void MakeProject(const char* , const char* = ""*"", Option_t* = ""new""); {}. void Map(); {}. void Paint(Option_t* = """"); {}. void Print(Option_t* = """") const; {}. Bool_t ReadBuffer(char* , Int_t ); { return kFALSE; }. Bool_t ReadBuffer(char* , Long64_t , Int_t ); { return kFALSE; }. void ReadFree(); {}. Int_t Recover(); { return 0; }. void Seek(Long64_t , TFile::ERelativeTo = kBeg); {}. void SetEND(Long64_t ); {}. Int_t Sizeof() const; { return 0; }. void UseCache(Int_t = 10, Int_t = 0); {}. Bool_t WriteBuffer(const char* , Int_t ); { return kFALSE; }. Int_t Write(const char* = 0, Int_t = 0, Int_t = 0); { return 0; }. Int_t Write(const char* = 0, Int_t = 0, Int_t = 0) const; { return 0; }. void WriteFree(); {}. void WriteHeader(); {}. » Author: Sergey Linev 10.05.2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/xml:$Id: TXMLFile.h 34444 2010-07-16 02:17:39Z pcanal $ » Last generated: 2011-07-04 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXMLFile.html:34211,Recover,Recover,34211,root/html530/TXMLFile.html,https://root.cern,https://root.cern/root/html530/TXMLFile.html,1,['Recover'],['Recover']
Safety," 0; }. Int_t SysClose(Int_t ); { return 0; }. Int_t SysRead(Int_t , void* , Int_t ); { return 0; }. Int_t SysWrite(Int_t , const void* , Int_t ); { return 0; }. Long64_t SysSeek(Int_t , Long64_t , Int_t ); { return 0; }. Int_t SysStat(Int_t , Long_t* , Long64_t* , Long_t* , Long_t* ); { return 0; }. Int_t SysSync(Int_t ); { return 0; }. void DrawMap(const char* = ""*"", Option_t* = """"); {}. void FillBuffer(char*& ); {}. void Flush(); {}. Long64_t GetEND() const; { return 0; }. Int_t GetErrno() const; { return 0; }. void ResetErrno() const; {}. Int_t GetNfree() const; { return 0; }. Int_t GetNbytesInfo() const; {return 0; }. Int_t GetNbytesFree() const; {return 0; }. Long64_t GetSeekFree() const; {return 0; }. Long64_t GetSeekInfo() const; {return 0; }. Long64_t GetSize() const; { return 0; }. Int_t GetIOVersion() const; { return fIOVersion; }. void MakeFree(Long64_t , Long64_t ); {}. void MakeProject(const char* , const char* = ""*"", Option_t* = ""new""); {}. void Map(); {}. void Paint(Option_t* = """"); {}. void Print(Option_t* = """") const; {}. Bool_t ReadBuffer(char* , Int_t ); { return kFALSE; }. Bool_t ReadBuffer(char* , Long64_t , Int_t ); { return kFALSE; }. void ReadFree(); {}. Int_t Recover(); { return 0; }. void Seek(Long64_t , TFile::ERelativeTo = kBeg); {}. void SetEND(Long64_t ); {}. Int_t Sizeof() const; { return 0; }. void UseCache(Int_t = 10, Int_t = 0); {}. Bool_t WriteBuffer(const char* , Int_t ); { return kFALSE; }. Int_t Write(const char* = 0, Int_t = 0, Int_t = 0); { return 0; }. Int_t Write(const char* = 0, Int_t = 0, Int_t = 0) const; { return 0; }. void WriteFree(); {}. void WriteHeader(); {}. » Author: Sergey Linev 10.05.2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/xml:$Id: TXMLFile.h 34444 2010-07-16 02:17:39Z pcanal $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXMLFile.html:34667,Recover,Recover,34667,root/html532/TXMLFile.html,https://root.cern,https://root.cern/root/html532/TXMLFile.html,1,['Recover'],['Recover']
Safety," 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Print composite tree in ASCII; # -----------------------------------------------------------; ; # Print tree to stdout; model.Print(""t""); ; # Print tree to file; model.printCompactTree("""", ""rf206_asciitree.txt""); ; # Draw composite tree graphically; # -------------------------------------------------------------; ; # Print GraphViz DOT file with representation of tree; model.graphVizTree(""rf206_model.dot""); ; # Make graphic output file with one of the GraphViz tools; # (freely available from www.graphviz.org); #; # 'Top-to-bottom graph'; # unix> dot -Tgif -o rf207_model_dot.gif rf207_model.dot; #; # 'Spring-model graph'; # unix> fdp -Tgif -o rf207_model_fdp.gif rf207_model.dot; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; 0x788d230 RooAddPdf::model = 0.602695/1 [Auto,Clean] ; 0x73f4730/V- RooAddPdf::bkg = 0.20539/1 [Auto,Clean] ; 0x793f3e0/V- RooChebychev::bkg1 = 1 [Auto,Dirty] ; 0x71161c0/V- RooRealVar::x = 5; 0x7539e30/V- RooRealVar::a0 = 0.5; 0x7496810/V- RooRealVar::a1 = 0; 0x7353b80/V- RooRealVar::bkg1frac = 0.2; 0x792d390/V- RooExponential::bkg2 = 0.00673795 [Auto,Dirty] ; 0x71161c0/V- RooRealVar::x = 5; 0x7429310/V- RooRealVar::alpha = -1; 0x2ee1ac0/V- RooRealVar::bkgfrac = 0.5; 0x4d76f30/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x7444460/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x71161c0/V- RooRealVar::x = 5; 0x6dbe690/V- RooRealVar::mean = 5; 0x3bcf160/V- RooRealVar::sigma1 = 0.5; 0x736e030/V- RooRealVar::sig1frac = 0.8; 0x7422370/V- RooGaussian::sig2 = 1 [Auto,Dirty] ; 0x71161c0/V- RooRealVar::x = 5; 0x6dbe690/V- RooRealVar::mean = 5; 0x2ee16d0/V- RooRealVar::sigma2 = 1; DateFebruary 2018 ; AuthorsC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf206__treevistools_8py.html:2840,safe,safe,2840,doc/master/rf206__treevistools_8py.html,https://root.cern,https://root.cern/doc/master/rf206__treevistools_8py.html,1,['safe'],['safe']
Safety," 10000);; 7242 TTree::Class()->WriteBuffer(b, (TTree*) this);; 7243 total += b.Length();; 7244 Long64_t file = zipBytes + s;; 7245 Float_t cx = 1;; 7246 if (zipBytes) {; 7247 cx = (GetTotBytes() + 0.00001) / zipBytes;; 7248 }; 7249 Printf(""******************************************************************************"");; 7250 Printf(""*Tree :%-10s: %-54s *"", GetName(), GetTitle());; 7251 Printf(""*Entries : %8lld : Total = %15lld bytes File Size = %10lld *"", fEntries, total, file);; 7252 Printf(""* : : Tree compression factor = %6.2f *"", cx);; 7253 Printf(""******************************************************************************"");; 7254 ; 7255 // Avoid many check of option validity; 7256 if (!option); 7257 option = """";; 7258 ; 7259 if (strncmp(option,""clusters"",strlen(""clusters""))==0) {; 7260 Printf(""%-16s %-16s %-16s %8s %20s"",; 7261 ""Cluster Range #"", ""Entry Start"", ""Last Entry"", ""Size"", ""Number of clusters"");; 7262 Int_t index= 0;; 7263 Long64_t clusterRangeStart = 0;; 7264 Long64_t totalClusters = 0;; 7265 bool estimated = false;; 7266 bool unknown = false;; 7267 auto printer = [this, &totalClusters, &estimated, &unknown](Int_t ind, Long64_t start, Long64_t end, Long64_t recordedSize) {; 7268 Long64_t nclusters = 0;; 7269 if (recordedSize > 0) {; 7270 nclusters = (1 + end - start) / recordedSize;; 7271 Printf(""%-16d %-16lld %-16lld %8lld %10lld"",; 7272 ind, start, end, recordedSize, nclusters);; 7273 } else {; 7274 // NOTE: const_cast ... DO NOT Merge for now; 7275 TClusterIterator iter((TTree*)this, start);; 7276 iter.Next();; 7277 auto estimated_size = iter.GetNextEntry() - start;; 7278 if (estimated_size > 0) {; 7279 nclusters = (1 + end - start) / estimated_size;; 7280 Printf(""%-16d %-16lld %-16lld %8lld %10lld (estimated)"",; 7281 ind, start, end, recordedSize, nclusters);; 7282 estimated = true;; 7283 } else {; 7284 Printf(""%-16d %-16lld %-16lld %8lld (unknown)"",; 7285 ind, start, end, recordedSize);; 7286 unknown = true;; 7287 }; 7288 }; 7289 start = end",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:285500,Avoid,Avoid,285500,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['Avoid'],['Avoid']
Safety," 1048 ; 1049Bool_t TQObject::AreAllSignalsBlocked(); 1050{; 1051 return fgAllSignalsBlocked;; 1052}; 1053 ; 1054////////////////////////////////////////////////////////////////////////////////; 1055/// Block or unblock all signals. Returns the previous block status.; 1056 ; 1057Bool_t TQObject::BlockAllSignals(Bool_t b); 1058{; 1059 Bool_t ret = fgAllSignalsBlocked;; 1060 fgAllSignalsBlocked = b;; 1061 return ret;; 1062}; 1063 ; 1064////////////////////////////////////////////////////////////////////////////////; 1065/// Global function which simplifies making connection in interpreted ROOT session; 1066///; 1067/// ConnectCINT - connects to interpreter(CINT) command; 1068 ; 1069Bool_t ConnectCINT(TQObject *sender, const char *signal, const char *slot); 1070{; 1071 TString str = ""ProcessLine(="";; 1072 str += '""';; 1073 str += slot;; 1074 str += '""';; 1075 str += "")"";; 1076 return TQObject::Connect(sender, signal, ""TInterpreter"",; 1077 gInterpreter, str.Data());; 1078}; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; RQ_OBJECT.h; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Char_tchar Char_tDefinition RtypesCore.h:37; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; TBaseClass.h; TBuffer.h; TClass.h; TDataType.h; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDispl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TQObject_8cxx_source.html:35377,Safe,SafeDelete,35377,doc/master/TQObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html,2,['Safe'],['SafeDelete']
Safety," 1120 return v.isSmall();; 1121}; 1122 ; 1123template <typename T>; 1124bool IsAdopting(const ROOT::VecOps::RVec<T> &v); 1125{; 1126 return !v.Owns();; 1127}; 1128 ; 1129} // namespace VecOps; 1130} // namespace Detail; 1131 ; 1132namespace VecOps {; 1133// Note that we open here with @{ the Doxygen group vecops and it is; 1134// closed again at the end of the C++ namespace VecOps; 1135/**; 1136 * \defgroup vecops VecOps; 1137 * A ""std::vector""-like collection of values implementing handy operation to analyse them; 1138 * @{; 1139*/; 1140 ; 1141// From the original SmallVector code:; 1142// This is a 'vector' (really, a variable-sized array), optimized; 1143// for the case when the array is small. It contains some number of elements; 1144// in-place, which allows it to avoid heap allocation when the actual number of; 1145// elements is below that threshold. This allows normal ""small"" cases to be; 1146// fast without losing generality for large inputs.; 1147//; 1148// Note that this does not attempt to be exception safe.; 1149 ; 1150template <typename T, unsigned int N>; 1151class R__CLING_PTRCHECK(off) RVecN : public Detail::VecOps::RVecImpl<T>, Internal::VecOps::SmallVectorStorage<T, N> {; 1152public:; 1153 RVecN() : Detail::VecOps::RVecImpl<T>(N) {}; 1154 ; 1155 ~RVecN(); 1156 {; 1157 if (this->Owns()) {; 1158 // Destroy the constructed elements in the vector.; 1159 this->destroy_range(this->begin(), this->end());; 1160 }; 1161 }; 1162 ; 1163 explicit RVecN(size_t Size, const T &Value) : Detail::VecOps::RVecImpl<T>(N) { this->assign(Size, Value); }; 1164 ; 1165 explicit RVecN(size_t Size) : Detail::VecOps::RVecImpl<T>(N); 1166 {; 1167 if (Size > N); 1168 this->grow(Size);; 1169 this->fSize = Size;; 1170 ROOT::Internal::VecOps::UninitializedValueConstruct(this->begin(), this->end());; 1171 }; 1172 ; 1173 template <typename ItTy,; 1174 typename = typename std::enable_if<std::is_convertible<; 1175 typename std::iterator_traits<ItTy>::iterator_category, std::input_ite",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:39823,safe,safe,39823,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['safe'],['safe']
Safety," 1136}; 1137 ; 1138 ; 1139FUNCTION_MAY_BE_UNUSED; 1140static ptrdiff_t; 1141mg_atomic_dec(volatile ptrdiff_t *addr); 1142{; 1143 ptrdiff_t ret;; 1144 ; 1145#if defined(_WIN64) && !defined(NO_ATOMICS); 1146 ret = InterlockedDecrement64(addr);; 1147#elif defined(_WIN32) && !defined(NO_ATOMICS); 1148 ret = InterlockedDecrement(addr);; 1149#elif defined(__GNUC__) \; 1150 && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0))) \; 1151 && !defined(NO_ATOMICS); 1152 ret = __sync_sub_and_fetch(addr, 1);; 1153#else; 1154 mg_global_lock();; 1155 ret = (--(*addr));; 1156 mg_global_unlock();; 1157#endif; 1158 return ret;; 1159}; 1160 ; 1161 ; 1162#if defined(USE_SERVER_STATS) || defined(STOP_FLAG_NEEDS_LOCK); 1163static ptrdiff_t; 1164mg_atomic_add(volatile ptrdiff_t *addr, ptrdiff_t value); 1165{; 1166 ptrdiff_t ret;; 1167 ; 1168#if defined(_WIN64) && !defined(NO_ATOMICS); 1169 ret = InterlockedAdd64(addr, value);; 1170#elif defined(_WIN32) && !defined(NO_ATOMICS); 1171 ret = InterlockedExchangeAdd(addr, value) + value;; 1172#elif defined(__GNUC__) \; 1173 && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0))) \; 1174 && !defined(NO_ATOMICS); 1175 ret = __sync_add_and_fetch(addr, value);; 1176#else; 1177 mg_global_lock();; 1178 *addr += value;; 1179 ret = (*addr);; 1180 mg_global_unlock();; 1181#endif; 1182 return ret;; 1183}; 1184 ; 1185 ; 1186FUNCTION_MAY_BE_UNUSED; 1187static ptrdiff_t; 1188mg_atomic_compare_and_swap(volatile ptrdiff_t *addr,; 1189 ptrdiff_t oldval,; 1190 ptrdiff_t newval); 1191{; 1192 ptrdiff_t ret;; 1193 ; 1194#if defined(_WIN64) && !defined(NO_ATOMICS); 1195 ret = InterlockedCompareExchange64(addr, newval, oldval);; 1196#elif defined(_WIN32) && !defined(NO_ATOMICS); 1197 ret = InterlockedCompareExchange(addr, newval, oldval);; 1198#elif defined(__GNUC__) \; 1199 && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0))) \; 1200 && !defined(NO_ATOMICS); 1201 ret = __sync_val_compare_and_swap(addr, oldval, newval);; 1202#else; 1203 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:36599,Interlock,InterlockedExchangeAdd,36599,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['Interlock'],['InterlockedExchangeAdd']
Safety," 1259 of file RuleFitParams.cxx. ◆ Optimism(). Double_t TMVA::RuleFitParams::Optimism ; (; ). protected . implementation of eq. ; 7.17 in Hastie,Tibshirani & Friedman book this is the covariance between the estimated response yhat and the true value y. NOT REALLY SURE IF THIS IS CORRECT! — THIS IS NOT USED — ; Definition at line 925 of file RuleFitParams.cxx. ◆ Penalty(). Double_t TMVA::RuleFitParams::Penalty ; (; ); const. This is the ""lasso"" penalty To be used for regression. ; — NOT USED — ; Definition at line 356 of file RuleFitParams.cxx. ◆ Risk() [1/2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_t ; ind1, . UInt_t ; ind2, . Double_t ; neff . ); const. risk assessment ; Definition at line 314 of file RuleFitParams.cxx. ◆ Risk() [2/2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_t ; ind1, . UInt_t ; ind2, . Double_t ; neff, . UInt_t ; itau . ); const. risk assessment for tau model <itau> ; Definition at line 334 of file RuleFitParams.cxx. ◆ RiskPath(). Double_t TMVA::RuleFitParams::RiskPath ; (; ); const. inline . Definition at line 108 of file RuleFitParams.h. ◆ RiskPerf() [1/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; ); const. inline . Definition at line 109 of file RuleFitParams.h. ◆ RiskPerf() [2/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; UInt_t ; itau); const. inline . Definition at line 110 of file RuleFitParams.h. ◆ RiskPerfTst(). UInt_t TMVA::RuleFitParams::RiskPerfTst ; (; ). Estimates the error rate with the current set of parameters. ; using the <Perf> subsample. Return the tau index giving the lowest error ; Definition at line 1201 of file RuleFitParams.cxx. ◆ SetGDErrScale(). void TMVA::RuleFitParams::SetGDErrScale ; (; Double_t ; s). inline . Definition at line 85 of file RuleFitParams.h. ◆ SetGDNPathSteps(). void TMVA::RuleFitParams::SetGDNPathSteps ; (; Int_t ; np). inline . Definition at line 65 of file RuleFitParams.h. ◆ SetGDPathStep(). void TMVA::RuleFitParams::SetGDPathStep ; (; Double_t ; s). inline . Definition at line 68 of f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:16903,Risk,RiskPath,16903,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,1,['Risk'],['RiskPath']
Safety," 1314 ; 1315////////////////////////////////////////////////////////////////////////////////; 1316/// Merge TH2Polys; 1317/// Given the special nature of the TH2Poly, the merge is implemented in; 1318/// terms of subsequent TH2Poly::Add calls.; 1319Long64_t TH2Poly::Merge(TCollection *coll); 1320{; 1321 for (auto h2pAsObj : *coll) {; 1322 if (!Add((TH1*)h2pAsObj, 1.)) {; 1323 Warning(""Merge"", ""An issue was encountered during the merge operation."");; 1324 return 0L;; 1325 }; 1326 }; 1327 return GetEntries();; 1328}; 1329 ; 1330////////////////////////////////////////////////////////////////////////////////; 1331/// Save primitive as a C++ statement(s) on output stream out; 1332 ; 1333void TH2Poly::SavePrimitive(std::ostream &out, Option_t *option); 1334{; 1335 out <<"" ""<<std::endl;; 1336 out <<"" ""<< ClassName() <<"" *"";; 1337 ; 1338 //histogram pointer has by default the histogram name.; 1339 //however, in case histogram has no directory, it is safer to add a; 1340 //incremental suffix; 1341 static Int_t hcounter = 0;; 1342 TString histName = GetName();; 1343 if (!fDirectory && !histName.Contains(""Graph"")) {; 1344 hcounter++;; 1345 histName += ""__"";; 1346 histName += hcounter;; 1347 }; 1348 ; 1349 TString hname = gInterpreter->MapCppName(histName.Data());; 1350 ; 1351 //Construct the class initialization; 1352 out << hname << "" = new "" << ClassName() << ""(\"""" << hname << ""\"", \""""; 1353 << GetTitle() << ""\"", "" << fCellX << "", "" << fXaxis.GetXmin(); 1354 << "", "" << fXaxis.GetXmax(); 1355 << "", "" << fCellY << "", "" << fYaxis.GetXmin() << "", ""; 1356 << fYaxis.GetXmax() << "");"" << std::endl;; 1357 ; 1358 // Save Bins; 1359 TIter next(fBins);; 1360 TObject *obj;; 1361 TH2PolyBin *th2pBin;; 1362 ; 1363 while((obj = next())){; 1364 th2pBin = (TH2PolyBin*) obj;; 1365 th2pBin->GetPolygon()->SavePrimitive(out, TString::Format(""th2poly%s"",hname.Data()));; 1366 }; 1367 ; 1368 // save bin contents; 1369 out<<"" ""<<std::endl;; 1370 Int_t bin;; 1371 for (bin=1;bin<=GetNumberOfBins();bi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2Poly_8cxx_source.html:46287,safe,safer,46287,doc/master/TH2Poly_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html,1,['safe'],['safer']
Safety," 167 fSeekParent = 0;; 168 fNbytesName = 0;; 169 fSeekDir = f->DirCreateEntry(this);; 170 if (fSeekDir == 0) return;; 171 }; 172 ; 173}; 174 ; 175////////////////////////////////////////////////////////////////////////////////; 176/// Destructor.; 177 ; 178TDirectoryFile::~TDirectoryFile(); 179{; 180 if (fKeys) {; 181 fKeys->Delete(""slow"");; 182 SafeDelete(fKeys);; 183 }; 184 ; 185 TDirectoryFile::CleanTargets();; 186 ; 187 // Delete our content before we become somewhat invalid; 188 // since some those objects (TTree for example) needs information; 189 // from this object. Note that on some platform after the end; 190 // of the body (i.e. thus during ~TDirectory which is also; 191 // contains this code) the execution of 'this->GetFile()' fails; 192 // to return the 'proper' value (because it uses the wrong; 193 // virtual function).; 194 if (fList) {; 195 fList->Delete(""slow"");; 196 SafeDelete(fList);; 197 }; 198 ; 199 if (gDebug) {; 200 Info(""~TDirectoryFile"", ""dtor called for %s"", GetName());; 201 }; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Append object to this directory.; 206///; 207/// If replace is true:; 208/// remove any existing objects with the same same (if the name is not """"; 209 ; 210void TDirectoryFile::Append(TObject *obj, Bool_t replace /* = kFALSE */); 211{; 212 if (!obj || !fList) return;; 213 ; 214 TDirectory::Append(obj,replace);; 215 ; 216 if (!fMother) return;; 217 if (fMother->IsA() == TMapFile::Class()) {; 218 TMapFile *mfile = (TMapFile*)fMother;; 219 mfile->Add(obj);; 220 }; 221}; 222 ; 223////////////////////////////////////////////////////////////////////////////////; 224/// Insert key in the linked list of keys of this directory.; 225 ; 226Int_t TDirectoryFile::AppendKey(TKey *key); 227{; 228 if (!fKeys) {; 229 Error(""AppendKey"",""TDirectoryFile not initialized yet."");; 230 return 0;; 231 }; 232 ; 233 fModified = kTRUE;; 234 ; 235 key->SetMotherDir(this);; 236 ; 237 // This i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:6763,Safe,SafeDelete,6763,doc/master/TDirectoryFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety," 172 bool LeastSquareFit(const BinData & data, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 173 SetData(data);; 174 return DoLeastSquareFit(executionPolicy);; 175 }; 176 /**; 177 Fit a binned data set using a least square fit NOT copying the input data.; 178 */; 179 bool LeastSquareFit(const std::shared_ptr<BinData> & data, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 180 SetData(data);; 181 return DoLeastSquareFit(executionPolicy);; 182 }; 183 ; 184 /**; 185 Fit an un-binned data set using the negative log-likelihood method.; 186 This function copies the input data.; 187 */; 188 bool Fit(const UnBinData & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 189 return LikelihoodFit(data, extended, executionPolicy);; 190 }; 191 /**; 192 Fit an un-binned data set using the negative log-likelihood method.; 193 This function uses a `shared_ptr` to avoid copying the input data.; 194 */; 195 bool Fit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 196 return LikelihoodFit(data, extended, executionPolicy);; 197 }; 198 ; 199 /**; 200 Binned Likelihood fit copying the input data.; 201 Default is extended.; 202 */; 203 bool LikelihoodFit(const BinData &data, bool extended = true,; 204 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 205 SetData(data);; 206 return DoBinnedLikelihoodFit(extended, executionPolicy);; 207 }; 208 /**; 209 Binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 210 Default is extended.; 211 */; 212 bool LikelihoodFit(const std::shared_ptr<BinData> &data, bool extended = true,; 213 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 214 SetData(data);; 215 return DoBinnedLikelihoodFit(extended, executionPol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8h_source.html:7005,avoid,avoid,7005,doc/master/Fitter_8h_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html,1,['avoid'],['avoid']
Safety," 1889void TApplication::Run(Bool_t retrn); 1890{; 1891 SetReturnFromRun(retrn);; 1892 ; 1893 fIsRunning = kTRUE;; 1894 ; 1895 gSystem->Run();; 1896 fIsRunning = kFALSE;; 1897}; 1898 ; 1899////////////////////////////////////////////////////////////////////////////////; 1900/// Set the command to be executed after the system has been idle for; 1901/// idleTimeInSec seconds. Normally called via TROOT::Idle(...).; 1902 ; 1903void TApplication::SetIdleTimer(UInt_t idleTimeInSec, const char *command); 1904{; 1905 if (fIdleTimer) RemoveIdleTimer();; 1906 fIdleCommand = command;; 1907 fIdleTimer = new TIdleTimer(idleTimeInSec*1000);; 1908 gSystem->AddTimer(fIdleTimer);; 1909}; 1910 ; 1911////////////////////////////////////////////////////////////////////////////////; 1912/// Remove idle timer. Normally called via TROOT::Idle(0).; 1913 ; 1914void TApplication::RemoveIdleTimer(); 1915{; 1916 if (fIdleTimer) {; 1917 // timers are removed from the gSystem timer list by their dtor; 1918 SafeDelete(fIdleTimer);; 1919 }; 1920}; 1921 ; 1922////////////////////////////////////////////////////////////////////////////////; 1923/// Called when system starts idleing.; 1924 ; 1925void TApplication::StartIdleing(); 1926{; 1927 if (fIdleTimer) {; 1928 fIdleTimer->Reset();; 1929 gSystem->AddTimer(fIdleTimer);; 1930 }; 1931}; 1932 ; 1933////////////////////////////////////////////////////////////////////////////////; 1934/// Called when system stops idleing.; 1935 ; 1936void TApplication::StopIdleing(); 1937{; 1938 if (fIdleTimer); 1939 gSystem->RemoveTimer(fIdleTimer);; 1940}; 1941 ; 1942////////////////////////////////////////////////////////////////////////////////; 1943/// What to do when tab is pressed. Re-implemented by TRint.; 1944/// See TTabCom::Hook() for meaning of return values.; 1945 ; 1946Int_t TApplication::TabCompletionHook(char* /*buf*/, int* /*pLoc*/, std::ostream& /*out*/); 1947{; 1948 return -1;; 1949}; 1950 ; 1951 ; 1952/////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:73233,Safe,SafeDelete,73233,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety," 1925 }; 1926 }; 1927 if (fu < 1.e-9) fu = 1.e-9;; 1928 icu = Int_t(cu);; 1929 fsub = -fu +icu*TMath::Log(fu);; 1930 fobs = GetSumLog(icu);; 1931 fsub -= fobs;; 1932 Derivatives(df,x);; 1933 int n=0;; 1934 // Here we need gradients of Log likelihood function; 1935 //; 1936 for (j=0;j<npar;j++) {; 1937 if (pl0[j]>0){; 1938 df[n] = df[j]*(icu/fu-1);; 1939 gin[j] -= df[n];; 1940 n++;; 1941 }; 1942 }; 1943 Int_t l = 0;; 1944 // Z-matrix here - production of first derivatives; 1945 // of log-likelihood function; 1946 for (j=0;j<n;j++); 1947 for (Int_t k=0;k<=j;k++); 1948 zik[l++] += df[j]*df[k];; 1949 ; 1950 f -= fsub;; 1951 npfit++;; 1952 cache += fPointSize;; 1953 }; 1954 f *= 2;; 1955 f1->SetNumberFitPoints(npfit);; 1956 delete[] df;; 1957}; 1958 ; 1959////////////////////////////////////////////////////////////////////////////////; 1960/// Minimization function for H1s using a Likelihood method.; 1961/// Basically, it forms the likelihood by determining the Poisson; 1962/// probability that given a number of entries in a particular bin,; 1963/// the fit would predict it's value. This is then done for each bin,; 1964/// and the sum of the logs is taken as the likelihood.; 1965///; 1966/// The ""I""ntegral method is used; 1967/// for each point the cache contains the following info; 1968/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1969/// - 2D : bc,e,xc,xw,yc,yw; 1970/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1971 ; 1972void TFumili::FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1973{; 1974 Double_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {del",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:56706,predict,predict,56706,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,1,['predict'],['predict']
Safety," 1949///; 1950/// If the object is not already entered in the gROOT list, it is added.; 1951 ; 1952TProcessID *TFile::ReadProcessID(UShort_t pidf); 1953{; 1954 TProcessID *pid = nullptr;; 1955 TObjArray *pids = GetListOfProcessIDs();; 1956 if (pidf < pids->GetSize()) pid = (TProcessID *)pids->UncheckedAt(pidf);; 1957 if (pid) {; 1958 pid->CheckInit();; 1959 return pid;; 1960 }; 1961 ; 1962 //check if fProcessIDs[uid] is set in file; 1963 //if not set, read the process uid from file; 1964 char pidname[32];; 1965 snprintf(pidname,32,""ProcessID%d"",pidf);; 1966 pid = (TProcessID *)Get(pidname);; 1967 if (gDebug > 0) {; 1968 printf(""ReadProcessID, name=%s, file=%s, pid=%zx\n"",pidname,GetName(),(size_t)pid);; 1969 }; 1970 if (!pid) {; 1971 //file->Error(""ReadProcessID"",""Cannot find %s in file %s"",pidname,file->GetName());; 1972 return pid;; 1973 }; 1974 ; 1975 //check that a similar pid is not already registered in fgPIDs; 1976 TObjArray *pidslist = TProcessID::GetPIDs();; 1977 TIter next(pidslist);; 1978 TProcessID *p;; 1979 bool found = false;; 1980 ; 1981 {; 1982 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 1983 while ((p = (TProcessID*)next())) {; 1984 if (!strcmp(p->GetTitle(),pid->GetTitle())) {; 1985 found = true;; 1986 break;; 1987 }; 1988 }; 1989 }; 1990 ; 1991 if (found) {; 1992 delete pid;; 1993 pids->AddAtAndExpand(p,pidf);; 1994 p->IncrementCount();; 1995 return p;; 1996 }; 1997 ; 1998 pids->AddAtAndExpand(pid,pidf);; 1999 pid->IncrementCount();; 2000 ; 2001 {; 2002 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2003 pidslist->Add(pid);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:71659,recover,recover,71659,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,2,['recover'],"['recover', 'recovered']"
Safety," 197 ; 198 // to allow user to interact with TCanvas's under WIN32; 199 gROOT->SetLineHasBeenProcessed();; 200 ; 201 //Needs to be done last; 202 gApplication = this;; 203 gROOT->SetApplication(this);; 204 ; 205}; 206 ; 207////////////////////////////////////////////////////////////////////////////////; 208/// TApplication dtor.; 209 ; 210TApplication::~TApplication(); 211{; 212 for (int i = 0; i < fArgc; i++); 213 if (fArgv[i]) delete [] fArgv[i];; 214 delete [] fArgv;; 215 ; 216 if (fgApplications); 217 fgApplications->Remove(this);; 218 ; 219 // Reduce the risk of the files or sockets being closed after the; 220 // end of 'main' (or more exactly before the library start being; 221 // unloaded).; 222 if (fgApplications == nullptr || fgApplications->FirstLink() == nullptr ) {; 223 TROOT::ShutDown();; 224 }; 225 ; 226 // Now that all the canvases and files have been closed we can; 227 // delete the implementation.; 228 SafeDelete(fAppImp);; 229}; 230 ; 231////////////////////////////////////////////////////////////////////////////////; 232/// Static method. This method should be called from static library; 233/// initializers if the library needs the low level graphics system.; 234 ; 235void TApplication::NeedGraphicsLibs(); 236{; 237 fgGraphNeeded = kTRUE;; 238}; 239 ; 240////////////////////////////////////////////////////////////////////////////////; 241/// Initialize the graphics environment.; 242/// If @param only_web is specified, only web-related part of graphics is loaded; 243 ; 244void TApplication::InitializeGraphics(Bool_t only_web); 245{; 246 if (fgGraphInit || !fgGraphNeeded); 247 return;; 248 ; 249 if (!only_web) {; 250 // Load the graphics related libraries; 251 LoadGraphicsLibs();; 252 ; 253 // Try to load TrueType font renderer. Only try to load if not in batch; 254 // mode and Root.UseTTFonts is true and Root.TTFontPath exists. Abort silently; 255 // if libttf or libGX11TTF are not found in $ROOTSYS/lib or $ROOTSYS/ttf/lib.; 256 const char *ttpath ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:8096,Safe,SafeDelete,8096,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety," 202 fLastPoint[0] = x;; 203 fLastPoint[1] = y, fLastPoint[2] = z;; 204 }; 205 ; 206 // Check if we have a cached safety value from parallel world, and if this can still be used.; 207 // Return negative value if no cache available.; 208 Double_t GetPWSafetyEstimateFromCache(Double_t cpoint[3]) const; 209 {; 210 // disregard too small or invalid safeties; 211 if (fLastPWSafety < TGeoShape::Tolerance()) {; 212 return -1.;; 213 }; 214 const auto d0 = fLastPWSaftyPnt[0] - cpoint[0];; 215 const auto d1 = fLastPWSaftyPnt[1] - cpoint[1];; 216 const auto d2 = fLastPWSaftyPnt[2] - cpoint[2];; 217 const auto d_sq = d0 * d0 + d1 * d1 + d2 * d2;; 218 // if we have moved too much return -1 as ""invalid""; 219 if (d_sq >= (fLastPWSafety * fLastPWSafety)) {; 220 return -1.;; 221 }; 222 // or return a reasonable cache estimate for safety; 223 return fLastPWSafety - std::sqrt(d_sq);; 224 }; 225 ; 226 // Wrapper for getting the safety from the parallel world.; 227 // Takes care of caching mechanics and talking to the Safety function of parallel world.; 228 Double_t GetPWSafety(Double_t cpoint[3], Double_t saf_max);; 229 ; 230 // enable/disable parallel world safety caching; 231 static void SetPWSafetyCaching(Bool_t b) { fgUsePWSafetyCaching = b; }; 232 static Bool_t IsPWSafetyCaching() { return fgUsePWSafetyCaching; }; 233 ; 234 //--- point/vector reference frame conversion; 235 void LocalToMaster(const Double_t *local, Double_t *master) const { fCache->LocalToMaster(local, master); }; 236 void LocalToMasterVect(const Double_t *local, Double_t *master) const { fCache->LocalToMasterVect(local, master); }; 237 void LocalToMasterBomb(const Double_t *local, Double_t *master) const { fCache->LocalToMasterBomb(local, master); }; 238 void MasterToLocal(const Double_t *master, Double_t *local) const { fCache->MasterToLocal(master, local); }; 239 void MasterToLocalVect(const Double_t *master, Double_t *local) const { fCache->MasterToLocalVect(master, local); }; 240 void MasterToLocalBomb(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:11198,Safe,Safety,11198,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['Safe'],['Safety']
Safety," 206 ; 207void Break(const char *location, const char *fmt, ...); 208{; 209 std::va_list ap;; 210 va_start(ap, fmt);; 211 ErrorHandler(kBreak, location, fmt, ap);; 212 va_end(ap);; 213}; 214 ; 215////////////////////////////////////////////////////////////////////////////////; 216/// Use this function for informational messages.; 217 ; 218void Info(const char *location, const char *fmt, ...); 219{; 220 std::va_list ap;; 221 va_start(ap, fmt);; 222 ErrorHandler(kInfo, location, fmt, ap);; 223 va_end(ap);; 224}; 225 ; 226////////////////////////////////////////////////////////////////////////////////; 227/// Use this function in warning situations.; 228 ; 229void Warning(const char *location, const char *fmt, ...); 230{; 231 std::va_list ap;; 232 va_start(ap, fmt);; 233 ErrorHandler(kWarning, location, fmt, ap);; 234 va_end(ap);; 235}; 236 ; 237////////////////////////////////////////////////////////////////////////////////; 238/// Use this function in case of a fatal error. It will abort the program.; 239 ; 240/// @warning Fatal() *will* not abort the program if `gErrorIgnoreLevel > kFatal`; 241/// - but for all reasonable settings it *will* abort.; 242// So let's be reasonable wrt Coverity:; 243// coverity[+kill]; 244void Fatal(const char *location, const char *fmt, ...); 245{; 246 std::va_list ap;; 247 va_start(ap, fmt);; 248 ErrorHandler(kFatal, location, fmt, ap);; 249 va_end(ap);; 250}; h#define h(i)Definition RSha256.hxx:106; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; gErrorAbortLevelInt_t gErrorAbortLevelDefinition TError.cxx:32; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35; Errorvoid Error(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Breakvoid Break(const char *location, const char *fmt,...)Use this function in case an error oc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8cxx_source.html:8016,abort,abort,8016,doc/master/TError_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html,1,['abort'],['abort']
Safety," 2185 if ( (!scaledHistogram && comparisonUU) ) {; 2186 if ( ( TMath::Abs(sumBinContent1 - effEntries1) >= 1) || (TMath::Abs(sumBinContent2 - effEntries2) >= 1) ) {; 2187 Warning(""Chi2TestX"",""Both histograms are not unweighted and option UU has been requested"");; 2188 }; 2189 }; 2190 ; 2191 ; 2192 //get number of events in histogram; 2193 if (comparisonUU && scaledHistogram) {; 2194 for (Int_t i = i_start; i <= i_end; ++i) {; 2195 for (Int_t j = j_start; j <= j_end; ++j) {; 2196 for (Int_t k = k_start; k <= k_end; ++k) {; 2197 ; 2198 Int_t bin = GetBin(i, j, k);; 2199 ; 2200 Double_t cnt1 = RetrieveBinContent(bin);; 2201 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2202 Double_t e1sq = GetBinErrorSqUnchecked(bin);; 2203 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2204 ; 2205 if (e1sq > 0.0) cnt1 = TMath::Floor(cnt1 * cnt1 / e1sq + 0.5); // avoid rounding errors; 2206 else cnt1 = 0.0;; 2207 ; 2208 if (e2sq > 0.0) cnt2 = TMath::Floor(cnt2 * cnt2 / e2sq + 0.5); // avoid rounding errors; 2209 else cnt2 = 0.0;; 2210 ; 2211 // sum contents; 2212 sum1 += cnt1;; 2213 sum2 += cnt2;; 2214 sumw1 += e1sq;; 2215 sumw2 += e2sq;; 2216 }; 2217 }; 2218 }; 2219 if (sumw1 <= 0.0 || sumw2 <= 0.0) {; 2220 Error(""Chi2TestX"", ""Cannot use option NORM when one histogram has all zero errors"");; 2221 return 0.0;; 2222 }; 2223 ; 2224 } else {; 2225 for (Int_t i = i_start; i <= i_end; ++i) {; 2226 for (Int_t j = j_start; j <= j_end; ++j) {; 2227 for (Int_t k = k_start; k <= k_end; ++k) {; 2228 ; 2229 Int_t bin = GetBin(i, j, k);; 2230 ; 2231 sum1 += RetrieveBinContent(bin);; 2232 sum2 += h2->RetrieveBinContent(bin);; 2233 ; 2234 if ( comparisonWW ) sumw1 += GetBinErrorSqUnchecked(bin);; 2235 if ( comparisonUW || comparisonWW ) sumw2 += h2->GetBinErrorSqUnchecked(bin);; 2236 }; 2237 }; 2238 }; 2239 }; 2240 //checks that the histograms are not empty; 2241 if (sum1 == 0.0 || sum2 == 0.0) {; 2242 Error(""Chi2TestX"",""one histogram is empty"");; 2243 return 0.0;; 2244 }; 2245 ; 2246 if ( comparis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:89659,avoid,avoid,89659,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['avoid'],['avoid']
Safety," 3087 //====process old versions before automatic schema evolution; 3088 TTree::Streamer(b);; 3089 b >> fTreeOffsetLen;; 3090 b >> fNtrees;; 3091 fFiles->Streamer(b);; 3092 if (R__v > 1) {; 3093 fStatus->Streamer(b);; 3094 fTreeOffset = new Long64_t[fTreeOffsetLen];; 3095 b.ReadFastArray(fTreeOffset,fTreeOffsetLen);; 3096 }; 3097 b.CheckByteCount(R__s, R__c, TChain::IsA());; 3098 //====end of old versions; 3099 }; 3100 // Re-add using the new name.; 3101 {; 3102 R__LOCKGUARD(gROOTMutex);; 3103 gROOT->GetListOfCleanups()->Add(this);; 3104 }; 3105 ; 3106 } else {; 3107 b.WriteClassBuffer(TChain::Class(),this);; 3108 }; 3109}; 3110 ; 3111////////////////////////////////////////////////////////////////////////////////; 3112/// Dummy function kept for back compatibility.; 3113/// The cache is now activated automatically when processing TTrees/TChain.; 3114 ; 3115void TChain::UseCache(Int_t /* maxCacheSize */, Int_t /* pageSize */); 3116{; 3117}; InternalTreeUtils.hxx; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; b#define b(i)Definition RSha256.hxx:100; h#define h(i)Definition RSha256.hxx:106; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Version_tshort Version_tDefinition RtypesCore.h:65; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBranch.h; TBrowser.h; TBuffer.h; TChainElement.h; TChain.h; TClass.h; TColor.h; TCut.h; EDataTypeEDataTypeDefinition TDataType.h:28; TEntryListFromFile.h; TEntryList.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; TEventList.h; TFileInfo.h; TFilePrefetch.h; TFileStager.h; TFile.h; TFriendElement.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; filenameOption_t Option_t TPoint TPo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:113003,Safe,SafeDelete,113003,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,2,['Safe'],['SafeDelete']
Safety," 319 TTree& operator=(const TTree& tt) = delete;; 320 ; 321 virtual Int_t AddBranchToCache(const char *bname, bool subbranches = false);; 322 virtual Int_t AddBranchToCache(TBranch *branch, bool subbranches = false);; 323 virtual Int_t DropBranchFromCache(const char *bname, bool subbranches = false);; 324 virtual Int_t DropBranchFromCache(TBranch *branch, bool subbranches = false);; 325 void AddClone(TTree*);; 326 virtual TFriendElement *AddFriend(const char* treename, const char* filename = """");; 327 virtual TFriendElement *AddFriend(const char* treename, TFile* file);; 328 virtual TFriendElement *AddFriend(TTree* tree, const char* alias = """", bool warn = false);; 329 // As the TBasket invokes Add{Tot,Zip}Bytes on its parent tree, we must do these updates in a thread-safe; 330 // manner only when we are flushing multiple baskets in parallel.; 331 virtual void AddTotBytes(Int_t tot) { if (fIMTFlush) { fIMTTotBytes += tot; } else { fTotBytes += tot; } }; 332 virtual void AddZipBytes(Int_t zip) { if (fIMTFlush) { fIMTZipBytes += zip; } else { fZipBytes += zip; } }; 333// NOTE: these counters aren't thread safe like the ones above.; 334#ifdef R__TRACK_BASKET_ALLOC_TIME; 335 void AddAllocationTime(ULong64_t time) { fAllocationTime += time; }; 336#endif; 337 void AddAllocationCount(UInt_t count) { fAllocationCount += count; }; 338 virtual Long64_t AutoSave(Option_t* option = """");; 339 ; 340 /// Add a new branch, and infer the data type from the type of `obj` being passed.; 341 ///; 342 /// \note This and the next overload should cover most cases for creating a branch. Try to use these two whenever; 343 /// possible, unless e.g. type conversions are needed.; 344 ///; 345 /// \param[in] name Name of the branch to be created.; 346 /// \param[in] obj Address of the object to be added. Make sure to pass a pointer to the actual type/class that; 347 /// should be stored in the tree (no pointers to base classes). When calling Fill(), the current value of the type/object will be ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:15678,safe,safe,15678,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['safe'],['safe']
Safety," 3474 ; 3475 ; 3476#define mg_cry DO_NOT_USE_THIS_FUNCTION__USE_mg_cry_internal; 3477 ; 3478 ; 3479const char *; 3480mg_version(void); 3481{; 3482 return CIVETWEB_VERSION;; 3483}; 3484 ; 3485 ; 3486const struct mg_request_info *; 3487mg_get_request_info(const struct mg_connection *conn); 3488{; 3489 if (!conn) {; 3490 return NULL;; 3491 }; 3492#if defined(MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE); 3493 if (conn->connection_type == CONNECTION_TYPE_RESPONSE) {; 3494 char txt[16];; 3495 struct mg_workerTLS *tls =; 3496 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 3497 ; 3498 sprintf(txt, ""%03i"", conn->response_info.status_code);; 3499 if (strlen(txt) == 3) {; 3500 memcpy(tls->txtbuf, txt, 4);; 3501 } else {; 3502 strcpy(tls->txtbuf, ""ERR"");; 3503 }; 3504 ; 3505 ((struct mg_connection *)conn)->request_info.local_uri =; 3506 tls->txtbuf; /* use thread safe buffer */; 3507 ((struct mg_connection *)conn)->request_info.local_uri_raw =; 3508 tls->txtbuf; /* use the same thread safe buffer */; 3509 ((struct mg_connection *)conn)->request_info.request_uri =; 3510 tls->txtbuf; /* use the same thread safe buffer */; 3511 ; 3512 ((struct mg_connection *)conn)->request_info.num_headers =; 3513 conn->response_info.num_headers;; 3514 memcpy(((struct mg_connection *)conn)->request_info.http_headers,; 3515 conn->response_info.http_headers,; 3516 sizeof(conn->response_info.http_headers));; 3517 } else; 3518#endif; 3519 if (conn->connection_type != CONNECTION_TYPE_REQUEST) {; 3520 return NULL;; 3521 }; 3522 return &conn->request_info;; 3523}; 3524 ; 3525 ; 3526const struct mg_response_info *; 3527mg_get_response_info(const struct mg_connection *conn); 3528{; 3529 if (!conn) {; 3530 return NULL;; 3531 }; 3532 if (conn->connection_type != CONNECTION_TYPE_RESPONSE) {; 3533 return NULL;; 3534 }; 3535 return &conn->response_info;; 3536}; 3537 ; 3538 ; 3539static const char *; 3540get_proto_name(const struct mg_connection *conn); 3541{; 3542#if defined(__clang__); 3543#pragma cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:104224,safe,safe,104224,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['safe'],['safe']
Safety," 3475 ; 3476 ; 3477#define mg_cry DO_NOT_USE_THIS_FUNCTION__USE_mg_cry_internal; 3478 ; 3479 ; 3480const char *; 3481mg_version(void); 3482{; 3483 return CIVETWEB_VERSION;; 3484}; 3485 ; 3486 ; 3487const struct mg_request_info *; 3488mg_get_request_info(const struct mg_connection *conn); 3489{; 3490 if (!conn) {; 3491 return NULL;; 3492 }; 3493#if defined(MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE); 3494 if (conn->connection_type == CONNECTION_TYPE_RESPONSE) {; 3495 char txt[16];; 3496 struct mg_workerTLS *tls =; 3497 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 3498 ; 3499 sprintf(txt, ""%03i"", conn->response_info.status_code);; 3500 if (strlen(txt) == 3) {; 3501 memcpy(tls->txtbuf, txt, 4);; 3502 } else {; 3503 strcpy(tls->txtbuf, ""ERR"");; 3504 }; 3505 ; 3506 ((struct mg_connection *)conn)->request_info.local_uri =; 3507 tls->txtbuf; /* use thread safe buffer */; 3508 ((struct mg_connection *)conn)->request_info.local_uri_raw =; 3509 tls->txtbuf; /* use the same thread safe buffer */; 3510 ((struct mg_connection *)conn)->request_info.request_uri =; 3511 tls->txtbuf; /* use the same thread safe buffer */; 3512 ; 3513 ((struct mg_connection *)conn)->request_info.num_headers =; 3514 conn->response_info.num_headers;; 3515 memcpy(((struct mg_connection *)conn)->request_info.http_headers,; 3516 conn->response_info.http_headers,; 3517 sizeof(conn->response_info.http_headers));; 3518 } else; 3519#endif; 3520 if (conn->connection_type != CONNECTION_TYPE_REQUEST) {; 3521 return NULL;; 3522 }; 3523 return &conn->request_info;; 3524}; 3525 ; 3526 ; 3527const struct mg_response_info *; 3528mg_get_response_info(const struct mg_connection *conn); 3529{; 3530 if (!conn) {; 3531 return NULL;; 3532 }; 3533 if (conn->connection_type != CONNECTION_TYPE_RESPONSE) {; 3534 return NULL;; 3535 }; 3536 return &conn->response_info;; 3537}; 3538 ; 3539 ; 3540static const char *; 3541get_proto_name(const struct mg_connection *conn); 3542{; 3543#if defined(__clang__); 3544#pragma cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:104256,safe,safe,104256,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['safe'],['safe']
Safety," 4978 HeadersDeclsMap_t headersClassesMap;; 4979 HeadersDeclsMap_t headersDeclsMap;; 4980 if (!gOptIgnoreExistingDict) {; 4981 const std::string fwdDeclnArgsToKeepString(GetFwdDeclnArgsToKeepString(normCtxt, interp));; 4982 ; 4983 ExtractHeadersForDecls(scan.fSelectedClasses,; 4984 scan.fSelectedTypedefs,; 4985 scan.fSelectedFunctions,; 4986 scan.fSelectedVariables,; 4987 scan.fSelectedEnums,; 4988 headersClassesMap,; 4989 headersDeclsMap,; 4990 interp);; 4991 ; 4992 std::string detectedUmbrella;; 4993 for (auto & arg : pcmArgs) {; 4994 if (gOptInlineInput && !ROOT::TMetaUtils::IsLinkdefFile(arg.c_str()) && ROOT::TMetaUtils::IsHeaderName(arg)) {; 4995 detectedUmbrella = arg;; 4996 break;; 4997 }; 4998 }; 4999 ; 5000 if (gOptWriteEmptyRootPCM){; 5001 headersDeclsMap.clear();; 5002 }; 5003 ; 5004 ; 5005 std::string headersClassesMapString = ""\""\"""";; 5006 std::string fwdDeclsString = ""\""\"""";; 5007 if (!gOptCxxModule) {; 5008 headersClassesMapString = GenerateStringFromHeadersForClasses(headersDeclsMap,; 5009 detectedUmbrella,; 5010 true);; 5011 if (!gDriverConfig->fBuildingROOTStage1) {; 5012 if (!gOptWriteEmptyRootPCM); 5013 fwdDeclsString = GenerateFwdDeclString(scan, interp);; 5014 }; 5015 }; 5016 modGen.WriteRegistrationSource(dictStream, fwdDeclnArgsToKeepString, headersClassesMapString, fwdDeclsString,; 5017 extraIncludes, gOptCxxModule);; 5018 // If we just want to inline the input header, we don't need; 5019 // to generate any files.; 5020 if (!gOptInlineInput) {; 5021 // Write the module/PCH depending on what mode we are on; 5022 if (modGen.IsPCH()) {; 5023 if (!GenerateAllDict(modGen, CI, currentDirectory)) return 1;; 5024 } else if (gOptCxxModule) {; 5025 if (!CheckModuleValid(modGen, llvmResourceDir, interp, linkdefFilename, moduleName.str())); 5026 return 1;; 5027 }; 5028 }; 5029 }; 5030 ; 5031 ; 5032 if (!gOptLibListPrefix.empty()) {; 5033 string liblist_filename = gOptLibListPrefix + "".out"";; 5034 ; 5035 ofstream outputfile(liblist_filename.c_str(), ios:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:203960,detect,detectedUmbrella,203960,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['detect'],['detectedUmbrella']
Safety," 511 if (gROOT->GetListOfFiles()) { // in case this function is called from TROOT destructor; 512 gROOT->GetListOfGeometries()->Remove(this);; 513 gROOT->GetListOfBrowsables()->Remove(this);; 514 }; 515 // TSeqCollection *brlist = gROOT->GetListOfBrowsers();; 516 // TIter next(brlist);; 517 // TBrowser *browser = 0;; 518 // while ((browser=(TBrowser*)next())) browser->RecursiveRemove(this);; 519 ClearThreadsMap();; 520 ClearThreadData();; 521 delete TGeoBuilder::Instance(this);; 522 if (fBits); 523 delete[] fBits;; 524 SafeDelete(fNodes);; 525 SafeDelete(fTopNode);; 526 if (fOverlaps) {; 527 fOverlaps->Delete();; 528 SafeDelete(fOverlaps);; 529 }; 530 if (fRegions) {; 531 fRegions->Delete();; 532 SafeDelete(fRegions);; 533 }; 534 if (fMaterials) {; 535 fMaterials->Delete();; 536 SafeDelete(fMaterials);; 537 }; 538 SafeDelete(fElementTable);; 539 if (fMedia) {; 540 fMedia->Delete();; 541 SafeDelete(fMedia);; 542 }; 543 if (fHashVolumes) {; 544 fHashVolumes->Clear(""nodelete"");; 545 SafeDelete(fHashVolumes);; 546 }; 547 if (fHashGVolumes) {; 548 fHashGVolumes->Clear(""nodelete"");; 549 SafeDelete(fHashGVolumes);; 550 }; 551 if (fHashPNE) {; 552 fHashPNE->Delete();; 553 SafeDelete(fHashPNE);; 554 }; 555 if (fArrayPNE) {; 556 delete fArrayPNE;; 557 }; 558 if (fVolumes) {; 559 fVolumes->Delete();; 560 SafeDelete(fVolumes);; 561 }; 562 if (fShapes) {; 563 fShapes->Delete();; 564 SafeDelete(fShapes);; 565 }; 566 if (fPhysicalNodes) {; 567 fPhysicalNodes->Delete();; 568 SafeDelete(fPhysicalNodes);; 569 }; 570 if (fMatrices) {; 571 fMatrices->Delete();; 572 SafeDelete(fMatrices);; 573 }; 574 if (fTracks) {; 575 fTracks->Delete();; 576 SafeDelete(fTracks);; 577 }; 578 SafeDelete(fUniqueVolumes);; 579 if (fPdgNames) {; 580 fPdgNames->Delete();; 581 SafeDelete(fPdgNames);; 582 }; 583 if (fGDMLMatrices) {; 584 fGDMLMatrices->Delete();; 585 SafeDelete(fGDMLMatrices);; 586 }; 587 if (fOpticalSurfaces) {; 588 fOpticalSurfaces->Delete();; 589 SafeDelete(fOpticalSurfaces);; 590 }; 591 if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:21908,Safe,SafeDelete,21908,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety," 67 of file TGeoShape.h. ◆ DeclFileName(). static const char * TGeoShape::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 171 of file TGeoShape.h. ◆ DistancetoPrimitive(). Int_t TGeoShape::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridepure virtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TObject.; Implemented in TGeoTessellated, TGeoBBox, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTube, TGeoTubeSeg, TGeoXtru, and TGeoVGShape. ◆ DistFromInside(). virtual Double_t TGeoShape::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. pure virtual . Implemented in TGeoArb8, TGeoTrap, TGeoGtra, TGeoBBox, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, TGeoXtru, and TGeoVGShape. ◆ DistFromInside_v(). virtual void TGeoShape::DistFromInside_v ; (; const Double_t * ; , . const Double_t * ; , . Double_t * ; , . Int_t ; , . Double_t * ;  . ); const. inlinevirtual . Reimplemented in TGeoArb8, TGeoTrap, TGeoGtra, TGeoBBox, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, and TGeoXtru.; Definition at line 105 of file TGeoShape.h. ◆ DistFromOutside(). virtual Double_t TGeoShape::DistFromOutside ; (; const Double_t * ; point, . const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShape.html:32412,safe,safe,32412,doc/master/classTGeoShape.html,https://root.cern,https://root.cern/doc/master/classTGeoShape.html,1,['safe'],['safe']
Safety," 85 ; 86////////////////////////////////////////////////////////////////////////////////; 87/// Default selector ctor.; 88 ; 89TSelector::TSelector() : TObject(); 90{; 91 fStatus = 0;; 92 fAbort = kContinue;; 93 fObject = nullptr;; 94 fInput = nullptr;; 95 fOutput = new TSelectorList;; 96 fOutput->SetOwner();; 97}; 98 ; 99////////////////////////////////////////////////////////////////////////////////; 100/// Selector destructor.; 101 ; 102TSelector::~TSelector(); 103{; 104 delete fOutput;; 105}; 106 ; 107////////////////////////////////////////////////////////////////////////////////; 108/// Abort processing. If what = kAbortProcess, the Process() loop will be; 109/// aborted. If what = kAbortFile, the current file in a chain will be; 110/// aborted and the processing will continue with the next file, if there; 111/// is no next file then Process() will be aborted. Abort() can also be; 112/// called from Begin(), SlaveBegin(), Init() and Notify(). After abort; 113/// the SlaveTerminate() and Terminate() are always called. The abort flag; 114/// can be checked in these methods using GetAbort().; 115 ; 116void TSelector::Abort(const char *why, EAbort what); 117{; 118 fAbort = what;; 119 TString mess = ""Abort"";; 120 if (fAbort == kAbortProcess); 121 mess = ""AbortProcess"";; 122 else if (fAbort == kAbortFile); 123 mess = ""AbortFile"";; 124 ; 125 Info(mess, ""%s"", why);; 126}; 127 ; 128////////////////////////////////////////////////////////////////////////////////; 129/// The code in filename is loaded (interpreted or compiled, see below),; 130/// filename must contain a valid class implementation derived from TSelector.; 131///; 132/// If filename is of the form file.C, the file will be interpreted.; 133/// If filename is of the form file.C++, the file file.C will be compiled; 134/// and dynamically loaded. The corresponding binary file and shared; 135/// library will be deleted at the end of the function.; 136/// If filename is of the form file.C+, the file file.C will ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSelector_8cxx_source.html:4702,abort,abort,4702,doc/master/TSelector_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSelector_8cxx_source.html,1,['abort'],['abort']
Safety," 90\anchor cheatsheet; 91## Cheat sheet; 92These are the operations which can be performed with RDataFrame.; 93 ; 94### Transformations; 95Transformations are a way to manipulate the data.; 96 ; 97| **Transformation** | **Description** |; 98|------------------|--------------------|; 99| Alias() | Introduce an alias for a particular column name. |; 100| Define() | Create a new column in the dataset. Example usages include adding a column that contains the invariant mass of a particle, or a selection of elements of an array (e.g. only the `pt`s of ""good"" muons). |; 101| DefinePerSample() | Define a new column that is updated when the input sample changes, e.g. when switching tree being processed in a chain. |; 102| DefineSlot() | Same as Define(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-safe Define() transformation when using RDataFrame after ROOT::EnableImplicitMT(). DefineSlot() works just as well with single-thread execution: in that case `slot` will always be `0`. |; 103| DefineSlotEntry() | Same as DefineSlot(), but the entry number is passed in addition to the slot number. This is meant as a helper in case the expression depends on the entry number. For details about entry numbers in multi-threaded runs, see [here](\ref helper-cols). |; 104| Filter() | Filter rows based on user-defined conditions. |; 105| Range() | Filter rows based on entry number (single-thread only). |; 106| Redefine() | Overwrite the value and/or type of an existing column. See Define() for more information. |; 107| RedefineSlot() | Overwrite the value and/or type of an existing column. See DefineSlot() for more information. |; 108| RedefineSlotEntry() | Overwrite the value and/or type of an existing column. See DefineSlotEntry() for more information. |; 109| Vary() | Register systematic variations for an exis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:5487,safe,safe,5487,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['safe'],['safe']
Safety," 942#ifdef R__COMPLETE_MEM_TERMINATION; 943 SafeDelete(fCanvases);; 944 SafeDelete(fTasks);; 945 SafeDelete(fProofs);; 946 SafeDelete(fDataSets);; 947 SafeDelete(fClipboard);; 948 ; 949 fCleanups->Clear();; 950 delete fPluginManager; gPluginMgr = fPluginManager = 0;; 951 delete gClassTable; gClassTable = 0;; 952 delete gEnv; gEnv = 0;; 953 ; 954 if (fTypes) fTypes->Delete();; 955 SafeDelete(fTypes);; 956 if (fGlobals) fGlobals->Delete();; 957 SafeDelete(fGlobals);; 958 if (fGlobalFunctions) fGlobalFunctions->Delete();; 959 SafeDelete(fGlobalFunctions);; 960 fEnums.load()->Delete();; 961 ; 962 // FIXME: Causes segfault in rootcling, debug and uncomment; 963 // fClasses->Delete(); SafeDelete(fClasses); // TClass'es must be deleted last; 964#endif; 965 ; 966 // Remove shared libraries produced by the TSystem::CompileMacro() call; 967 gSystem->CleanCompiledMacros();; 968 ; 969 // Cleanup system class; 970 ROOT::Internal::SetErrorSystemMsgHandler(ROOT::Internal::ErrorSystemMsgHandlerFunc_t());; 971 SetErrorHandler(ROOT::Internal::MinimalErrorHandler);; 972 ROOT::Internal::ReleaseDefaultErrorHandler();; 973 delete gSystem;; 974 ; 975 // ROOT-6022:; 976 // if (gInterpreterLib) dlclose(gInterpreterLib);; 977#ifdef R__COMPLETE_MEM_TERMINATION; 978 // On some 'newer' platform (Fedora Core 17+, Ubuntu 12), the; 979 // initialization order is (by default?) is 'wrong' and so we can't; 980 // delete the interpreter now .. because any of the static in the; 981 // interpreter's library have already been deleted.; 982 // On the link line, we must list the most dependent .o file; 983 // and end with the least dependent (LLVM libraries), unfortunately,; 984 // Fedora Core 17+ or Ubuntu 12 will also execute the initialization; 985 // in the same order (hence doing libCore's before LLVM's and; 986 // vice et versa for both the destructor. We worked around the; 987 // initialization order by delay the TROOT creation until first use.; 988 // We can not do the same for destruction as we hav",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:37941,Safe,SafeDelete,37941,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['Safe'],['SafeDelete']
Safety," 96 of file TGeoArb8.h. Public Member Functions;  TGeoTrap ();  ;  TGeoTrap (const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);  ;  TGeoTrap (Double_t dz, Double_t theta, Double_t phi);  ;  TGeoTrap (Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);  ;  ~TGeoTrap () override;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAlpha1 () const;  ; Double_t GetAlpha2 () const;  ; Double_t GetBl1 () const;  ; Double_t GetBl2 () const;  ; Double_t GetH1 () const;  ; Double_t GetH2 () const;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; Double_t GetPhi () const;  ; Double_t GetTheta () const;  ; Double_t GetTl1 () const;  ; Double_t GetTl2 () const;  ; TClass * IsA () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetDimension",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrap.html:933,safe,safe,933,doc/master/classTGeoTrap.html,https://root.cern,https://root.cern/doc/master/classTGeoTrap.html,4,"['Safe', 'safe']","['Safety', 'safe']"
Safety," : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_cnn.h5; PyKeras : [dataset] : Evaluation of PyKeras on training sample (1600 events); : Elapsed time for evaluation of 1600 events: 0.261 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_PyKeras.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVA_CNN_Classification_PyKeras.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: PyTorch for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ PyTorch ] :␛[0m; : ; : PyTorch is a scientific computing package supporting; : automatic differentiation. This method wraps the training; : and predictions steps of the PyTorch Python package for; : TMVA, so that dataloading, preprocessing and evaluation; : can be done within the TMVA system. To use this PyTorch; : interface, you need to generatea model with PyTorch first.; : Then, this model can be loaded and trained in TMVA.; : ; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Split TMVA training data in 1280 training events and 320 validation events; : Print Training Model Architecture; : Option SaveBestOnly: Only model weights with smallest validation loss will be stored; : Elapsed time for training with 1600 events: 23.1 sec ; PyTorch : [dataset] : Evaluation of PyTorch on training sample (1600 events); : Elapsed time for evaluation of 1600 events: 0.434 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_PyTorch.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVA_CNN_Classification_PyTorch.class.C␛[0m; Factory : Training",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:28416,predict,predictions,28416,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['predict'],['predictions']
Safety," ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TGeoTrap, and TGeoGtra.; Definition at line 93 of file TGeoArb8.h. ◆ IsCylType(). Bool_t TGeoArb8::IsCylType ; (; ); const. inlineoverridevirtual . Implements TGeoShape.; Definition at line 73 of file TGeoArb8.h. ◆ IsSamePoint(). static Bool_t TGeoArb8::IsSamePoint ; (; const Double_t * ; p1, . const Double_t * ; p2 . ). inlinestatic . Definition at line 74 of file TGeoArb8.h. ◆ IsTwisted(). Bool_t TGeoArb8::IsTwisted ; (; ); const. inline . Definition at line 80 of file TGeoArb8.h. ◆ operator=(). TGeoArb8 & TGeoArb8::operator= ; (; const TGeoArb8 & ; ). protecteddelete . ◆ Safety(). Double_t TGeoArb8::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Implements TGeoShape.; Reimplemented in TGeoTrap, and TGeoGtra. ◆ Safety_v(). void TGeoArb8::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoShape.; Reimplemented in TGeoTrap, and TGeoGtra. ◆ SafetyToFace(). Double_t TGeoArb8::SafetyToFace ; (; const Double_t * ; point, . Int_t ; iseg, . Bool_t ; in . ); const. ◆ SavePrimitive(). void TGeoArb8::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TObject.; Reimplemented in TGeoTrap, and TGeoGtra. ◆ SetDimensions(). void TGeoArb8::SetDimensions ; (; Double_t * ; param). overridevirtual . Implements TGeoShape.; Reimplemented in TGeoTrap, and TGeoGtra. ◆ SetDz(). void TGeoArb8::SetDz ; (; Double_t ; dz). inline . Definition at line 88 of file TGeoArb8.h. ◆ SetPlaneVertices(). void TGeoArb8::SetPlaneVertices ; (; Double_t ; zpl, . Double_t * ; vertices . ); const. ◆ SetPoints() [1/2]. void TGeoArb8::SetPoints ; (; Double_t * ; points); const. overridevirtual . Implements TGeoShap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoArb8.html:31830,safe,safe,31830,doc/master/classTGeoArb8.html,https://root.cern,https://root.cern/doc/master/classTGeoArb8.html,1,['safe'],['safe']
Safety, ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 198 of file TGDNDManager.h. Member Data Documentation. ◆ fAcceptedAction. Atom_t TGDNDManager::fAcceptedAction. protected . Definition at line 94 of file TGDNDManager.h. ◆ fDNDNoDropCursor. Cursor_t TGDNDManager::fDNDNoDropCursor. protected . no drop cursor type ; Definition at line 111 of file TGDNDManager.h. ◆ fDraggerTypes. Atom_t * TGDNDManager::fDraggerTypes. protected . lists of DND types ; Definition at line 92 of file TGDNDManager.h. ◆ fDragging. Bool_t TGDNDManager::fDragging. protected . kTRUE while dragging ; Definition at line 96 of file TGDNDManager.h. ◆ fDragWin. TGDragWindow* TGDNDManager::fDragWin. protected . drag window ; Definition at line 107 of file TGDNDManager.h. ◆ fDropAccepted. Bool_t TGDNDManager::fDropAccepted. protected . kTRUE if drop accepted ; Definition at line 97 of file TGDNDManager.h. ◆ fDropTimeout. TTimer* TGDNDManager::fDropTimeout. protected . drop timeout ; Definition at line 106 of file TGDNDManager.h. ◆ fDropType. Atom_t TGDNDManager::fDropType. protected . drop type ; Definition at line 93 of file TGDNDManager.h. ◆ fgDNDActionAsk. Atom_t TGDNDManager::fgDNDActionAsk = kNone. staticprotected . Definition at line 119 of file TGDNDManager.h. ◆ fgDNDActionCopy. Atom_t TGDNDManager::fgDNDActionCopy = kNone. staticprotected . Definition at line 118 of file TGDNDManager.h. ◆ fgDNDActionDescrip. Atom_t TGDNDManager::fgDNDActionDescrip = kNone. staticprotected . Definition at line 120 of file TGDNDManager.h. ◆ fgDNDActionLink. Atom_t TGDNDManager::fgDNDActionLink = kNone. staticprotected . Definition at line 118 of file TGDNDManager.h. ◆ fgDNDActionList. Atom_t TGDNDManager::fgDNDActionList = kNone. staticprotected . Definition at line 120 of file TGDNDManager.h. ◆ fgDNDActionMove. Atom_t TGDNDManager::fgDNDActionMove = kNone. staticprotected . Definition at line 118 of file TGDNDManager.h. ◆ fgDNDActionPrivate. Atom_t TGDNDManager::fgDNDActionPrivate = kNon,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDNDManager.html:26019,timeout,timeout,26019,doc/master/classTGDNDManager.html,https://root.cern,https://root.cern/doc/master/classTGDNDManager.html,1,['timeout'],['timeout']
Safety," ; (; std::string const & ; type). Choose the minimizer algorithm. ; Passing an empty string selects the default minimizer type returned by ROOT::Math::MinimizerOptions::DefaultMinimizerType(). ; Definition at line 246 of file RooMinimizer.cxx. ◆ setOffsetting(). void RooMinimizer::setOffsetting ; (; bool ; flag). Enable internal likelihood offsetting for enhanced numeric precision. ; Definition at line 234 of file RooMinimizer.cxx. ◆ setPrintEvalErrors(). void RooMinimizer::setPrintEvalErrors ; (; int ; numEvalErrors). inline . Definition at line 152 of file RooMinimizer.h. ◆ setPrintLevel(). void RooMinimizer::setPrintLevel ; (; int ; newLevel). Change the MINUIT internal printing level. ; Definition at line 472 of file RooMinimizer.cxx. ◆ setProfile(). void RooMinimizer::setProfile ; (; bool ; flag = true). inline . Definition at line 170 of file RooMinimizer.h. ◆ setRecoverFromNaNStrength(). void RooMinimizer::setRecoverFromNaNStrength ; (; double ; strength). Try to recover from invalid function values. ; When invalid function values are encountered, a penalty term is returned to the minimiser to make it back off. This sets the strength of this penalty. NoteA strength of zero is equivalent to a constant penalty (= the gradient vanishes, ROOT < 6.24). Positive values lead to a gradient pointing away from the undefined regions. Use ~10 to force the minimiser away from invalid function values. ; Definition at line 802 of file RooMinimizer.cxx. ◆ setStrategy(). void RooMinimizer::setStrategy ; (; int ; istrat). Change MINUIT strategy to istrat. ; Accepted codes are 0,1,2 and represent MINUIT strategies for dealing most efficiently with fast FCNs (0), expensive FCNs (2) and 'intermediate' FCNs (1) ; Definition at line 189 of file RooMinimizer.cxx. ◆ setVerbose(). void RooMinimizer::setVerbose ; (; bool ; flag = true). inline . Definition at line 153 of file RooMinimizer.h. ◆ simplex(). int RooMinimizer::simplex ; (; ). Execute SIMPLEX. ; Changes in parameter values a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMinimizer.html:28630,recover,recover,28630,doc/master/classRooMinimizer.html,https://root.cern,https://root.cern/doc/master/classRooMinimizer.html,1,['recover'],['recover']
Safety," ; 182////////////////////////////////////////////////////////////////////////////////; 183/// Set the object to be notified at time out. Removes the command to; 184/// be executed (if it was set).; 185 ; 186void TTimer::SetObject(TObject *object); 187{; 188 fObject = object;; 189 fCommand = """";; 190}; 191 ; 192////////////////////////////////////////////////////////////////////////////////; 193/// When the argument is true the a-synchronous timer (SIGALRM) signal; 194/// handler is set so that interrupted syscalls will not be restarted; 195/// by the kernel. This is typically used in case one wants to put a; 196/// timeout on an I/O operation. By default interrupted syscalls will; 197/// be restarted.; 198 ; 199void TTimer::SetInterruptSyscalls(Bool_t set); 200{; 201 fIntSyscalls = set;; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Starts the timer with a milliSec timeout. If milliSec is 0; 206/// then the timeout will be the minimum timeout (see TSystem::ESysConstants,; 207/// i.e. 10 ms), if milliSec is -1 then the time interval as previously; 208/// specified (in ctor or SetTime()) will be used.; 209/// If singleShot is kTRUE, the timer will be activated only once,; 210/// otherwise it will continue until it is stopped.; 211/// See also TurnOn(), Stop(), TurnOff().; 212 ; 213void TTimer::Start(Long_t milliSec, Bool_t singleShot); 214{; 215 if (milliSec >= 0); 216 SetTime(milliSec);; 217 Reset();; 218 TurnOn();; 219 if (singleShot); 220 Connect(this, ""Timeout()"", ""TTimer"", this, ""TurnOff()"");; 221 else; 222 Disconnect(this, ""Timeout()"", this, ""TurnOff()"");; 223}; 224 ; 225////////////////////////////////////////////////////////////////////////////////; 226/// Remove timer from system timer list. This requires that a timer; 227/// has been placed in the system timer list (using TurnOn()).; 228/// If a TTimer subclass is placed on another list, override TurnOff() to; 229/// remove the timer from the correct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTimer_8cxx_source.html:7105,timeout,timeout,7105,doc/master/TTimer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTimer_8cxx_source.html,2,['timeout'],['timeout']
Safety," ; 293 INLINE_TEMPLATE_ARGS Int_t ReadTextObject(TBuffer &buf, void *addr, const TConfiguration *config); 294 {; 295 void *x = (void *)(((char *)addr) + config->fOffset);; 296 buf.ReadFastArray(x, config->fCompInfo->fClass, config->fCompInfo->fLength, config->fCompInfo->fStreamer);; 297 return 0;; 298 }; 299 ; 300 INLINE_TEMPLATE_ARGS Int_t ReadTextTObject(TBuffer &buf, void *addr, const TConfiguration *config); 301 {; 302 void *x = (void *)(((char *)addr) + config->fOffset);; 303 buf.StreamObject(x, TObject::Class(), TObject::Class());; 304 return 0;; 305 }; 306 ; 307 INLINE_TEMPLATE_ARGS Int_t ReadTextBaseClass(TBuffer &buf, void *addr, const TConfiguration *config); 308 {; 309 void *x = (void *)(((char *)addr) + config->fOffset);; 310 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 311 ((TBufferText *)&buf)->ReadBaseClass(x, (TStreamerBase *)config->fCompInfo->fElem);; 312 return 0;; 313 }; 314 ; 315 INLINE_TEMPLATE_ARGS Int_t ReadTextStreamer(TBuffer &buf, void *addr, const TConfiguration *config); 316 {; 317 void *x = (void *)(((char *)addr) + config->fOffset);; 318 TMemberStreamer *pstreamer = config->fCompInfo->fStreamer;; 319 ; 320 UInt_t start, count;; 321 /* Version_t v = */ buf.ReadVersion(&start, &count, config->fCompInfo->fClass);; 322 (*pstreamer)(buf, x, config->fCompInfo->fLength);; 323 buf.CheckByteCount(start, count, config->fCompInfo->fElem->GetFullName());; 324 return 0;; 325 }; 326 ; 327 INLINE_TEMPLATE_ARGS Int_t ReadTextTObjectBase(TBuffer &buf, void *addr, const TConfiguration *config); 328 {; 329 // action required to call custom code for TObject as base class; 330 void *x = (void *)(((char *)addr) + config->fOffset);; 331 buf.ReadClassBuffer(TObject::Class(), x, TObject::Class());; 332 return 0;; 333 }; 334 ; 335 INLINE_TEMPLATE_ARGS Int_t ReadTextTNamed(TBuffer &buf, void *addr, const TConfiguration *config); 336 {; 337 void *x = (void *)(((char *)addr) + config->fOffset);; 338 buf.StreamObject(x, TNamed::Class(), TNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:11642,avoid,avoid,11642,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['avoid'],['avoid']
Safety," ; 4283////////////////////////////////////////////////////////////////////////////////; 4284/// Activate/deactivate usage of parallel world navigation. Can only be done if; 4285/// there is a parallel world. Activating navigation will automatically close; 4286/// the parallel geometry.; 4287 ; 4288void TGeoManager::SetUseParallelWorldNav(Bool_t flag); 4289{; 4290 if (!fParallelWorld) {; 4291 Error(""SetUseParallelWorldNav"", ""No parallel world geometry defined. Use CreateParallelWorld."");; 4292 return;; 4293 }; 4294 if (!flag) {; 4295 fUsePWNav = flag;; 4296 return;; 4297 }; 4298 if (!fClosed) {; 4299 Error(""SetUseParallelWorldNav"", ""The geometry must be closed first"");; 4300 return;; 4301 }; 4302 // Closing the parallel world geometry is mandatory; 4303 if (fParallelWorld->CloseGeometry()); 4304 fUsePWNav = kTRUE;; 4305}; 4306 ; 4307Bool_t TGeoManager::LockDefaultUnits(Bool_t new_value); 4308{; 4309 Bool_t val = gGeometryLocked;; 4310 gGeometryLocked = new_value;; 4311 return val;; 4312}; 4313 ; 4314TGeoManager::EDefaultUnits TGeoManager::GetDefaultUnits(); 4315{; 4316 return fgDefaultUnits;; 4317}; 4318 ; 4319void TGeoManager::SetDefaultUnits(EDefaultUnits new_value); 4320{; 4321 if (fgDefaultUnits == new_value) {; 4322 gGeometryLocked = true;; 4323 return;; 4324 } else if (gGeometryLocked) {; 4325 ::Fatal(""TGeoManager"", ""The system of units may only be changed once, \n""; 4326 ""BEFORE any elements and materials are created! \n""; 4327 ""Alternatively unlock the default units at own risk."");; 4328 } else if (new_value == kG4Units) {; 4329 ::Info(""TGeoManager"", ""Changing system of units to Geant4 units (mm, ns, MeV)."");; 4330 } else if (new_value == kRootUnits) {; 4331 ::Info(""TGeoManager"", ""Changing system of units to ROOT units (cm, s, GeV)."");; 4332 }; 4333 fgDefaultUnits = new_value;; 4334}; 4335 ; 4336void TGeoManager::SetExportPrecision(UInt_t prec); 4337{; 4338 fgExportPrecision = prec;; 4339}; 4340 ; 4341UInt_t TGeoManager::GetExportPrecision(); 4342{; 4343 ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:157415,risk,risk,157415,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['risk'],['risk']
Safety," ; 770void TCanvas::Cleared(TVirtualPad *pad); 771{; 772 Emit(""Cleared(TVirtualPad*)"", (Longptr_t)pad);; 773}; 774 ; 775////////////////////////////////////////////////////////////////////////////////; 776/// Emit Closed signal.; 777 ; 778void TCanvas::Closed(); 779{; 780 Emit(""Closed()"");; 781}; 782 ; 783////////////////////////////////////////////////////////////////////////////////; 784/// Close canvas.; 785///; 786/// Delete window/pads data structure; 787 ; 788void TCanvas::Close(Option_t *option); 789{; 790 auto padsave = gPad;; 791 TCanvas *cansave = padsave ? padsave->GetCanvas() : nullptr;; 792 ; 793 if (fCanvasID != -1) {; 794 ; 795 if (!gROOT->IsLineProcessing() && !gVirtualX->IsCmdThread()) {; 796 gInterpreter->Execute(this, IsA(), ""Close"", option);; 797 return;; 798 }; 799 ; 800 R__LOCKGUARD(gROOTMutex);; 801 ; 802 FeedbackMode(kFALSE);; 803 ; 804 cd();; 805 TPad::Close(option);; 806 ; 807 if (!IsBatch() && !IsWeb()) {; 808 gVirtualX->SelectWindow(fCanvasID); //select current canvas; 809 ; 810 DeleteCanvasPainter();; 811 ; 812 if (fCanvasImp); 813 fCanvasImp->Close();; 814 }; 815 fCanvasID = -1;; 816 fBatch = kTRUE;; 817 ; 818 gROOT->GetListOfCanvases()->Remove(this);; 819 ; 820 // Close actual window on screen; 821 SafeDelete(fCanvasImp);; 822 }; 823 ; 824 if (cansave == this) {; 825 gPad = (TCanvas *) gROOT->GetListOfCanvases()->First();; 826 } else {; 827 gPad = padsave;; 828 }; 829 ; 830 Closed();; 831}; 832 ; 833////////////////////////////////////////////////////////////////////////////////; 834/// Copy the canvas pixmap of the pad to the canvas.; 835 ; 836void TCanvas::CopyPixmaps(); 837{; 838 if (!IsBatch()) {; 839 CopyPixmap();; 840 TPad::CopyPixmaps();; 841 }; 842}; 843 ; 844////////////////////////////////////////////////////////////////////////////////; 845/// Draw a canvas.; 846/// If a canvas with the name is already on the screen, the canvas is repainted.; 847/// This function is useful when a canvas object has been saved in a Root file.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:26294,Safe,SafeDelete,26294,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety," ; 9044////////////////////////////////////////////////////////////////////////////////; 9045/// Set an EntryList; 9046 ; 9047void TTree::SetEntryList(TEntryList *enlist, Option_t * /*opt*/); 9048{; 9049 if (fEntryList) {; 9050 //check if the previous entry list is owned by the tree; 9051 if (fEntryList->TestBit(kCanDelete)){; 9052 delete fEntryList;; 9053 }; 9054 }; 9055 fEventList = nullptr;; 9056 if (!enlist) {; 9057 fEntryList = nullptr;; 9058 return;; 9059 }; 9060 fEntryList = enlist;; 9061 fEntryList->SetTree(this);; 9062 ; 9063}; 9064 ; 9065////////////////////////////////////////////////////////////////////////////////; 9066/// This function transfroms the given TEventList into a TEntryList; 9067/// The new TEntryList is owned by the TTree and gets deleted when the tree; 9068/// is deleted. This TEntryList can be returned by GetEntryList() function.; 9069 ; 9070void TTree::SetEventList(TEventList *evlist); 9071{; 9072 fEventList = evlist;; 9073 if (fEntryList){; 9074 if (fEntryList->TestBit(kCanDelete)) {; 9075 TEntryList *tmp = fEntryList;; 9076 fEntryList = nullptr; // Avoid problem with RecursiveRemove.; 9077 delete tmp;; 9078 } else {; 9079 fEntryList = nullptr;; 9080 }; 9081 }; 9082 ; 9083 if (!evlist) {; 9084 fEntryList = nullptr;; 9085 fEventList = nullptr;; 9086 return;; 9087 }; 9088 ; 9089 fEventList = evlist;; 9090 char enlistname[100];; 9091 snprintf(enlistname,100, ""%s_%s"", evlist->GetName(), ""entrylist"");; 9092 fEntryList = new TEntryList(enlistname, evlist->GetTitle());; 9093 fEntryList->SetDirectory(nullptr); // We own this.; 9094 Int_t nsel = evlist->GetN();; 9095 fEntryList->SetTree(this);; 9096 Long64_t entry;; 9097 for (Int_t i=0; i<nsel; i++){; 9098 entry = evlist->GetEntry(i);; 9099 fEntryList->Enter(entry);; 9100 }; 9101 fEntryList->SetReapplyCut(evlist->GetReapplyCut());; 9102 fEntryList->SetBit(kCanDelete, true);; 9103}; 9104 ; 9105////////////////////////////////////////////////////////////////////////////////; 9106/// Set number of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:351152,Avoid,Avoid,351152,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['Avoid'],['Avoid']
Safety," ; Definition at line 98 of file Net.h. ◆ Loss() [1/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TNet< Architecture_t, Layer_t >::Loss ; (; const Matrix_t & ; Y, . const Matrix_t & ; weights, . bool ; includeRegularization = true . ); const. inline . Evaluate the loss function of the net using the activations that are currently stored in the output layer. ; Definition at line 305 of file Net.h. ◆ Loss() [2/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TNet< Architecture_t, Layer_t >::Loss ; (; Matrix_t & ; X, . const Matrix_t & ; Y, . const Matrix_t & ; weights, . bool ; applyDropout = false, . bool ; includeRegularization = true . ). inline . Propagate the input batch X through the net and evaluate the error function for the resulting activations of the output layer. ; Definition at line 320 of file Net.h. ◆ Prediction() [1/2]. template<typename Architecture_t , typename Layer_t > . void TMVA::DNN::TNet< Architecture_t, Layer_t >::Prediction ; (; Matrix_t & ; Y_hat, . EOutputFunction ; f . ); const. inline . Compute the neural network prediction obtained from applying the output function f to the activation of the last layer in the network. ; Definition at line 339 of file Net.h. ◆ Prediction() [2/2]. template<typename Architecture_t , typename Layer_t > . void TMVA::DNN::TNet< Architecture_t, Layer_t >::Prediction ; (; Matrix_t & ; Y_hat, . Matrix_t & ; X, . EOutputFunction ; f . ). inline . Compute the neural network prediction obtained from forwarding the batch X through the neural network and applying the output function f to the activation of the last layer in the network. ; Definition at line 329 of file Net.h. ◆ Print(). template<typename Architecture_t , typename Layer_t > . void TMVA::DNN::TNet< Architecture_t, Layer_t >::Print. Definition at line 392 of file Net.h. ◆ SetBatchSize(). template<typename Architecture_t , typename Layer_t = TLayer<Architecture_t>> . void TMVA::DNN::TNet< Architecture_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TNet.html:13839,Predict,Prediction,13839,doc/master/classTMVA_1_1DNN_1_1TNet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TNet.html,1,['Predict'],['Prediction']
Safety," ;  . Protected Member Functions;  TGeoParallelWorld (const TGeoParallelWorld &)=delete;  switch between different algorithm implementations ;  ; TGeoParallelWorld & operator= (const TGeoParallelWorld &)=delete;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; AccelerationMode fAccMode = AccelerationMode::kVoxelFinder;  to keep the vector of primitive axis aligned bounding boxes ;  ; void * fBoundingBoxes = nullptr;  stores bounding boxes serving a quick safety candidates (to be used with the VoxelGrid and SafetyVoxelInfo) ;  ; void * fBVH = nullptr;  array of physical nodes ;  ; TGeoManager * fGeoManager;  ; Bool_t fIsClosed;  ; TGeoPhysicalNode * fLastState;  helper volume ;  ; TObjArray * fPaths;  ; TObjArray * fPhysical;  Last PN touched. ;  ; std::vector< unsigned int > fSafetyCandidateStore {};  A regular 3D cache layer for fast point-based safety lookups. ;  ; TGeoVoxelGrid< SafetyVoxelInfo > * fSafetyVoxelCache;  BVH helper structure for safety and navigation. ;  ; Bool_t fUseOverlaps;  ; TGeoVolume * fVolume;  Closed flag. ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; TGeoPhysicalNode * FindNextBoundaryBVH (Double_t point[3], Double_t dir[3], Double_t &step, Double_t stepmax=1.E30);  Same functionality as TGeoNavigator::FindNextDaughterBoundary for the parallel world. ;  ; TGeoPhysicalNode * FindNextBoundaryLoop (Double_t point[3], Double_t dir[3], Double_t &step, Double_t stepmax=1.E30);  Same functionality as TGeoNavigator::FindNextDaughterBoundary for the parallel world in a trivial loop version (for debugging) ;  ; TGeoPhysicalNode * FindNextBoundaryOrig (Double_t point[3], Double_t dir[3], Double_t &step, Double_t stepmax=1.E30);  Same functionality as TGeoNavigator::FindNextDaughterBoundary for the par",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:14208,safe,safety,14208,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['safe'],['safety']
Safety," ;  ; static Bool_t IsCrossingSemiplane (const Double_t *point, const Double_t *dir, Double_t cphi, Double_t sphi, Double_t &snext, Double_t &rxy);  Compute distance from POINT to semiplane defined by PHI angle along DIR. ;  ; static Bool_t IsInPhiRange (const Double_t *point, Double_t phi1, Double_t phi2);  Static method to check if a point is in the phi range (phi1, phi2) [degrees]. ;  ; static Bool_t IsSameWithinTolerance (Double_t a, Double_t b);  Check if two numbers differ with less than a tolerance. ;  ; static Bool_t IsSegCrossing (Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t x3, Double_t y3, Double_t x4, Double_t y4);  Check if segments (A,B) and (C,D) are crossing, where: A(x1,y1), B(x2,y2), C(x3,y3), D(x4,y4) ;  ; static void NormalPhi (const Double_t *point, const Double_t *dir, Double_t *norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2);  Static method to compute normal to phi planes. ;  ; static Double_t SafetyPhi (const Double_t *point, Bool_t in, Double_t phi1, Double_t phi2);  Static method to compute safety w.r.t a phi corner defined by cosines/sines of the angles phi1, phi2. ;  ; static Double_t SafetySeg (Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer);  Compute distance from point of coordinates (r,z) to segment (r1,z1):(r2,z2) ;  ; static void SetTransform (TGeoMatrix *matrix);  Set current transformation matrix that applies to shape. ;  ; static Double_t Tolerance ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoArb8.html:20190,Safe,SafetyPhi,20190,doc/master/classTGeoArb8.html,https://root.cern,https://root.cern/doc/master/classTGeoArb8.html,54,"['Safe', 'safe']","['SafetyPhi', 'safety']"
Safety, ;  ; void StreamerNVi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoGtra.html:2693,safe,safe,2693,doc/master/classTGeoGtra.html,https://root.cern,https://root.cern/doc/master/classTGeoGtra.html,1,['safe'],['safe']
Safety," = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPara.html:2356,safe,safe,2356,root/html532/TGeoPara.html,https://root.cern,https://root.cern/root/html532/TGeoPara.html,3,['safe'],['safe']
Safety," = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowCache(Bool_t all = kFALSE); virtual voidShowData(); voidShowDataSet(const char* dataset = """", const char* opt = ""filter:SsCc""); virtual voidShowDataSetCache(const char* dataset = 0); voidShowDataSetQuota(Option_t* opt = 0); virtual voidShowDataSets(const char* uri = """", const char* optStr = """"); voidShowEnabledPackages(Bool_t all = kFALSE); voidShowFeedback() const; voidShowLog(Int_t qry = -1); voidShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector&); voidShowMissingFiles(TQueryResult* qr = 0); voidShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidShowParameters(const char* wildcard = ""PROOF_*"") const; voidShowQueries(Option_t* opt = """"); virtual voidShowStagingStatusDataSet(const char* dataset, const char* optStr = ""filter:SsCc""); virtual Int_tTNamed::Sizeof() const; voidStartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTouch(); Int_tUploadDataSet(const char*, TList*, const char* = 0, Int_t = 0, TList* = 0); Int_tUploadDataSet(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tUploadDataSetFromFile(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tUploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar, TList* workers = 0); virtual voidTObject::UseCurrentStyle(); Bool_tUseDynamicStartup() const; virtual Int_tVerifyDataSet(const char* dataset, const char* optStr = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:17609,abort,abort,17609,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,1,['abort'],['abort']
Safety," = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TTask.h>. Inheritance diagram for TTask:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TTask() [1/3]. TTask::TTask ; (; ). Default constructor invoked when reading a TTask object from a file. ; Definition at line 98 of file TTask.cxx. ◆ TTask() [2/3]. TTask::TTask ; (; const char * ; name, . const char * ; title . ). Standard constructor. ; Definition at line 110 of file TTask.cxx. ◆ ~TTask(). TTask::~TTask ; (; ). virtual . Delete a task and its subtasks. ; Definition at line 168 of file TTask.cxx. ◆ TTask() [3/3]. TTask::TTask ; (; const TTask & ; task). Copy constructor. ; Definition at line 150 of file TTask.cxx. Member Function Documentation. ◆ Abort(). void TTask::Abort ; (; ). virtual . Abort current tree of tasks. ; After this call, the tree of tasks is ready to be executed again. The application must take care of cleaning data structures created by previous executions. ; Definition at line 192 of file TTask.cxx. ◆ Add(). void TTask::Add ; (; TTask * ; task). virtual . Add TTask to this. ; Definition at line 176 of file TTask.cxx. ◆ Browse(). void TTask::Browse ; (; TBrowser * ; b). overridevirtual . Browse the list of tasks. ; It is recommended to add the top level task to the list of ROOT browsables by: gROOT->GetListOfBrowsables()->Add(myTopLevelTask). Reimplemented from TObject.; Definition at line 211 of file TTask.cxx. ◆ Class(). static TClass * TTask::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTask::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTask::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTask.html:16510,Abort,Abort,16510,doc/master/classTTask.html,https://root.cern,https://root.cern/doc/master/classTTask.html,1,['Abort'],['Abort']
Safety," = 1 minimal compression level but fast. compress = 9 maximal compression level but slow. Note that the compression level may be changed at any time.; The new compression level will only apply to newly written objects.; The function TFile::Map() shows the compression factor; for each object written to this file.; The function TFile::GetCompressionFactor returns the global; compression factor for this file. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile::Recover 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of the TProcessID data structures in memory by forcing a delete of; the unused TProcessID. TKey* CreateKey(TDirectory* mother, const TObject* obj, const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:26316,recover,recovery,26316,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,2,"['Recover', 'recover']","['Recover', 'recovery']"
Safety," = fBuffer;; 916 if (fObjlen > fNbytes-fKeylen) {; 917 fBuffer = bufferRead;; 918 memcpy(bufferRef.Buffer(),fBuffer,fKeylen);; 919 } else {; 920 fBuffer = bufferRef.Buffer();; 921 ReadFile(); //Read object structure from file; 922 }; 923 fBuffer = storeBuffer;; 924 ; 925 // get version of key; 926 bufferRef.SetBufferOffset(sizeof(fNbytes));; 927 Version_t kvers = bufferRef.ReadVersion();; 928 ; 929 bufferRef.SetBufferOffset(fKeylen);; 930 TObject *tobj = 0;; 931 // Create an instance of this class; 932 ; 933 char *pobj = (char*)cl->New();; 934 if (!pobj) {; 935 Error(""ReadObjWithBuffer"", ""Cannot create new object of class %s"", fClassName.Data());; 936 return 0;; 937 }; 938 Int_t baseOffset = cl->GetBaseClassOffset(TObject::Class());; 939 if (baseOffset==-1) {; 940 // cl does not inherit from TObject.; 941 // Since this is not possible yet, the only reason we could reach this code; 942 // is because something is screw up in the ROOT code.; 943 Fatal(""ReadObjWithBuffer"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 944 fClassName.Data());; 945 }; 946 tobj = (TObject*)(pobj+baseOffset);; 947 ; 948 if (kvers > 1); 949 bufferRef.MapObject(pobj,cl); //register obj in map to handle self reference; 950 ; 951 if (fObjlen > fNbytes-fKeylen) {; 952 char *objbuf = bufferRef.Buffer() + fKeylen;; 953 UChar_t *bufcur = (UChar_t *)&bufferRead[fKeylen];; 954 Int_t nin, nout = 0, nbuf;; 955 Int_t noutot = 0;; 956 while (1) {; 957 Int_t hc = R__unzip_header(&nin, bufcur, &nbuf);; 958 if (hc!=0) break;; 959 R__unzip(&nin, bufcur, &nbuf, (unsigned char*) objbuf, &nout);; 960 if (!nout) break;; 961 noutot += nout;; 962 if (noutot >= fObjlen) break;; 963 bufcur += nin;; 964 objbuf += nout;; 965 }; 966 if (nout) {; 967 tobj->Streamer(bufferRef); //does not work with example 2 above; 968 } else {; 969 // Even-though we have a TObject, if the class is emulated the virtual; 970 // table may not be 'right', so let's go via the TClass.; 971 cl->Destructor(pobj);; 972 r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TKey_8cxx_source.html:33571,detect,detection,33571,doc/master/TKey_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html,1,['detect'],['detection']
Safety," = fTree->GetListOfFriends();; 9834 if (!list) return next;; 9835 fTreeIter = list->MakeIterator(fDirection);; 9836 if (!fTreeIter) return nullptr;; 9837 }; 9838 TFriendElement * nextFriend = (TFriendElement*) fTreeIter->Next();; 9839 ///nextTree = (TTree*)fTreeIter->Next();; 9840 if (nextFriend) {; 9841 nextTree = const_cast<TTree*>(nextFriend->GetTree());; 9842 if (!nextTree) return Next();; 9843 SafeDelete(fLeafIter);; 9844 fLeafIter = nextTree->GetListOfLeaves()->MakeIterator(fDirection);; 9845 if (!fLeafIter) return nullptr;; 9846 next = fLeafIter->Next();; 9847 }; 9848 }; 9849 return next;; 9850}; 9851 ; 9852////////////////////////////////////////////////////////////////////////////////; 9853/// Returns the object option stored in the list.; 9854 ; 9855Option_t* TTreeFriendLeafIter::GetOption() const; 9856{; 9857 if (fLeafIter) return fLeafIter->GetOption();; 9858 return """";; 9859}; RConfig.hxx; R__unlikely#define R__unlikely(expr)Definition RConfig.hxx:586; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; UChar_tunsigned char UChar_tDefinition RtypesCore.h:38; Long_tlong Long_tDefinition RtypesCore.h:54; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; StringConv.hxx; TArrayC.h; TBaseClass.h; TBasket.h; TBranchClones.h; TBranchElement.h; TBra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:378345,Safe,SafeDelete,378345,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,2,['Safe'],['SafeDelete']
Safety," = kVoid_t;; 342 return;; 343 }; 344 }; 345 ; 346 if ( intype.substr(0,6) == ""string"" || intype.substr(0,11) == ""std::string"" ) {; 347 fCase = kBIT_ISSTRING;; 348 fType = TClass::GetClass(""string"");; 349 fCtor = fType->GetNew();; 350 fDtor = fType->GetDestructor();; 351 fDelete = fType->GetDelete();; 352 if (isPointer) {; 353 fCase |= kIsPointer;; 354 fSize = sizeof(void*);; 355 } else {; 356 fSize = sizeof(std::string);; 357 }; 358 }; 359 else {; 360 // In the case where we have an emulated class,; 361 // if the class is nested (in a class or a namespace),; 362 // calling G__TypeInfo ti(inside.c_str());; 363 // might fail because CINT does not known the nesting; 364 // scope, so let's first look for an emulated class:; 365 ; 366 fType = TClass::GetClass(intype.c_str(),kTRUE,silent, hint_pair_offset, hint_pair_size);; 367 ; 368 if (fType) {; 369 if (isPointer) {; 370 fCase |= kIsPointer;; 371 fSize = sizeof(void*);; 372 if (fType == TString::Class()) {; 373 fCase |= kBIT_ISTSTRING;; 374 }; 375 }; 376 fCase |= kIsClass;; 377 fCtor = fType->GetNew();; 378 fDtor = fType->GetDestructor();; 379 fDelete = fType->GetDelete();; 380 } else {; 381 R__LOCKGUARD(gInterpreterMutex);; 382 ; 383 // Try to avoid autoparsing.; 384 ; 385 THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );; 386 assert(typeTable && ""The type of the list of type has changed"");; 387 ; 388 TDataType *fundType = (TDataType *)typeTable->THashTable::FindObject( intype.c_str() );; 389 if (fundType && fundType->GetType() < 0x17 && fundType->GetType() > 0) {; 390 fKind = (EDataType)fundType->GetType();; 391 // R__ASSERT((fKind>0 && fKind<0x17) || (fKind==-1&&(prop&kIsPointer)) );; 392 ; 393 fCase |= kIsFundamental;; 394 if (isPointer) {; 395 fCase |= kIsPointer;; 396 fSize = sizeof(void*);; 397 } else {; 398 fSize = fundType->Size();; 399 }; 400 } else if (TEnum::GetEnum( intype.c_str(), TEnum::kNone) ) {; 401 // This is a known enum.; 402 fCase = kIsEnum;; 403 fSize = sizeof(Int_t);; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:11235,avoid,avoid,11235,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['avoid'],['avoid']
Safety," = nullptr;; 493 fValuePNEId = nullptr;; 494 fMultiThread = kFALSE;; 495 fRaytraceMode = 0;; 496 fMaxThreads = 0;; 497 fUsePWNav = kFALSE;; 498 fParallelWorld = nullptr;; 499 ClearThreadsMap();; 500}; 501 ; 502////////////////////////////////////////////////////////////////////////////////; 503/// Destructor; 504 ; 505TGeoManager::~TGeoManager(); 506{; 507 if (gGeoManager != this); 508 gGeoManager = this;; 509 fIsGeomCleaning = kTRUE;; 510 ; 511 if (gROOT->GetListOfFiles()) { // in case this function is called from TROOT destructor; 512 gROOT->GetListOfGeometries()->Remove(this);; 513 gROOT->GetListOfBrowsables()->Remove(this);; 514 }; 515 // TSeqCollection *brlist = gROOT->GetListOfBrowsers();; 516 // TIter next(brlist);; 517 // TBrowser *browser = 0;; 518 // while ((browser=(TBrowser*)next())) browser->RecursiveRemove(this);; 519 ClearThreadsMap();; 520 ClearThreadData();; 521 delete TGeoBuilder::Instance(this);; 522 if (fBits); 523 delete[] fBits;; 524 SafeDelete(fNodes);; 525 SafeDelete(fTopNode);; 526 if (fOverlaps) {; 527 fOverlaps->Delete();; 528 SafeDelete(fOverlaps);; 529 }; 530 if (fRegions) {; 531 fRegions->Delete();; 532 SafeDelete(fRegions);; 533 }; 534 if (fMaterials) {; 535 fMaterials->Delete();; 536 SafeDelete(fMaterials);; 537 }; 538 SafeDelete(fElementTable);; 539 if (fMedia) {; 540 fMedia->Delete();; 541 SafeDelete(fMedia);; 542 }; 543 if (fHashVolumes) {; 544 fHashVolumes->Clear(""nodelete"");; 545 SafeDelete(fHashVolumes);; 546 }; 547 if (fHashGVolumes) {; 548 fHashGVolumes->Clear(""nodelete"");; 549 SafeDelete(fHashGVolumes);; 550 }; 551 if (fHashPNE) {; 552 fHashPNE->Delete();; 553 SafeDelete(fHashPNE);; 554 }; 555 if (fArrayPNE) {; 556 delete fArrayPNE;; 557 }; 558 if (fVolumes) {; 559 fVolumes->Delete();; 560 SafeDelete(fVolumes);; 561 }; 562 if (fShapes) {; 563 fShapes->Delete();; 564 SafeDelete(fShapes);; 565 }; 566 if (fPhysicalNodes) {; 567 fPhysicalNodes->Delete();; 568 SafeDelete(fPhysicalNodes);; 569 }; 570 if (fMatrices) {; 571 fMatrices-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:21463,Safe,SafeDelete,21463,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety," = true . ); const. Function for evaluating the loss, based on the activations stored in the last layer. ; Definition at line 1263 of file DeepNet.h. ◆ Loss() [2/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::Loss ; (; Tensor_t & ; input, . const Matrix_t & ; groundTruth, . const Matrix_t & ; weights, . bool ; inTraining = false, . bool ; includeRegularization = true . ). Function for evaluating the loss, based on the propagation of the given input. ; Definition at line 1279 of file DeepNet.h. ◆ Prediction() [1/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::Prediction ; (; Matrix_t & ; predictions, . EOutputFunction ; f . ); const. Prediction based on activations stored in the last layer. ; Definition at line 1303 of file DeepNet.h. ◆ Prediction() [2/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::Prediction ; (; Matrix_t & ; predictions, . Tensor_t & ; input, . EOutputFunction ; f . ). Prediction for the given inputs, based on what network learned. ; Definition at line 1311 of file DeepNet.h. ◆ Print(). template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::Print. Print the Deep Net Info. ; Definition at line 1321 of file DeepNet.h. ◆ RegularizationTerm(). template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::RegularizationTerm. Function for computing the regularizaton term to be added to the loss function . Definition at line 1289 of file DeepNet.h. ◆ ResetTraining(). template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TDeepNet< Architecture_t, Layer_t >::ResetTraining. Function that reset some training flags after looping all the events but not the weights. ; Definition at line 886 of file DeepNet.h. ◆ SetBatchDepth(). template<typename Archite",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDeepNet.html:24859,Predict,Prediction,24859,doc/master/classTMVA_1_1DNN_1_1TDeepNet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDeepNet.html,2,"['Predict', 'predict']","['Prediction', 'predictions']"
Safety," > . auto ROOT::Internal::GetTheRightOp ; (; T(F::*)(T *, double *) ; opPtr); -> decltype(opPtr); . Definition at line 219 of file TF1.h. ◆ gVersionCheck(). static TVersionCheck ROOT::Internal::gVersionCheck ; (; ROOT_VERSION_CODE ; ). static . ◆ hasBeginEnd() [1/2]. template<typename > . constexpr bool ROOT::Internal::hasBeginEnd ; (;  ; ...). constexpr . Definition at line 72 of file RRangeCast.hxx. ◆ hasBeginEnd() [2/2]. template<typename T > . constexpr auto ROOT::Internal::hasBeginEnd ; (; int ; ); -> decltype(std::begin(std::declval<T>()), std::end(std::declval<T>()), true). constexpr . Definition at line 66 of file RRangeCast.hxx. ◆ HasConsistentHashMember() [1/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; const char * ; cname). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. This routines is used for a small subset of the class for which we need the answer before gROOT is properly initialized. ; Definition at line 7345 of file TClass.cxx. ◆ HasConsistentHashMember() [2/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; TClass & ; clRef). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. ; Definition at line 7371 of file TClass.cxx. ◆ IsImplicitMTEnabledImpl(). static Bool_t & ROOT::Internal::IsImplicitMTEnabledImpl ; (; ). static . Keeps track of the status of ImplicitMT w/o resorting to the load of libImt. ; Definition at line 463 of file TROOT.cxx. ◆ IsParBranchProcessingEnabled(). Bool_t ROOT::Internal::IsParBranchProcessingEnabled ; (; ). Returns true if parallel branch pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html:35990,safe,safe,35990,doc/v632/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html,1,['safe'],['safe']
Safety," > . auto ROOT::Internal::GetTheRightOp ; (; T(F::*)(T *, double *) ; opPtr); -> decltype(opPtr); . Definition at line 219 of file TF1.h. ◆ gVersionCheck(). static TVersionCheck ROOT::Internal::gVersionCheck ; (; ROOT_VERSION_CODE ; ). static . ◆ hasBeginEnd() [1/2]. template<typename > . constexpr bool ROOT::Internal::hasBeginEnd ; (;  ; ...). constexpr . Definition at line 72 of file RRangeCast.hxx. ◆ hasBeginEnd() [2/2]. template<typename T > . constexpr auto ROOT::Internal::hasBeginEnd ; (; int ; ); -> decltype(std::begin(std::declval<T>()), std::end(std::declval<T>()), true). constexpr . Definition at line 66 of file RRangeCast.hxx. ◆ HasConsistentHashMember() [1/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; const char * ; cname). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. This routines is used for a small subset of the class for which we need the answer before gROOT is properly initialized. ; Definition at line 7412 of file TClass.cxx. ◆ HasConsistentHashMember() [2/2]. Bool_t ROOT::Internal::HasConsistentHashMember ; (; TClass & ; clRef). Return true is the Hash/RecursiveRemove setup is consistent, i.e. ; when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. ; Definition at line 7438 of file TClass.cxx. ◆ IsImplicitMTEnabledImpl(). static Bool_t & ROOT::Internal::IsImplicitMTEnabledImpl ; (; ). static . Keeps track of the status of ImplicitMT w/o resorting to the load of libImt. ; Definition at line 463 of file TROOT.cxx. ◆ IsParBranchProcessingEnabled(). Bool_t ROOT::Internal::IsParBranchProcessingEnabled ; (; ). Returns true if parallel branch pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal.html:36571,safe,safe,36571,doc/master/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal.html,1,['safe'],['safe']
Safety," Abort(int code=0) overrideTUnixSystemvirtual; AbstractMethod(const char *method) constTObject; AcceptConnection(int sock) overrideTUnixSystemvirtual; AccessPathName(const char *path, EAccessMode mode=kFileExists) overrideTUnixSystemvirtual; AddDynamicPath(const char *lib) overrideTUnixSystemvirtual; AddFileHandler(TFileHandler *fh) overrideTUnixSystemvirtual; AddIncludePath(const char *includePath)TSystemvirtual; AddLinkedLibs(const char *linkedLib)TSystemvirtual; AddSignalHandler(TSignalHandler *sh) overrideTUnixSystemvirtual; AddStdExceptionHandler(TStdExceptionHandler *eh)TSystemvirtual; AddTimer(TTimer *ti) overrideTUnixSystemvirtual; AddToTObjectTable(TObject *)TObjectprivatestatic; AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize=-1) overrideTUnixSystemvirtual; AnnounceUdpService(int port, int backlog) overrideTUnixSystemvirtual; AnnounceUnixService(int port, int backlog) overrideTUnixSystemvirtual; AnnounceUnixService(const char *sockpath, int backlog) overrideTUnixSystemvirtual; AppendPad(Option_t *option="""")TObjectvirtual; BaseName(const char *pathname)TSystemvirtual; Beep(Int_t freq=-1, Int_t duration=-1, Bool_t setDefault=kFALSE)TSystem; Browse(TBrowser *b)TObjectvirtual; cd(const char *path)TSysteminline; ChangeDirectory(const char *path) overrideTUnixSystemvirtual; CheckChilds()TUnixSystem; CheckDescriptors()TUnixSystem; CheckedHash()TObjectinline; CheckSignals(Bool_t sync)TUnixSystem; Chmod(const char *file, UInt_t mode) overrideTUnixSystemvirtual; Class()TUnixSystemstatic; Class_Name()TUnixSystemstatic; Class_Version()TUnixSysteminlinestatic; ClassName() constTObjectvirtual; CleanCompiledMacros()TSystemvirtual; Clear(Option_t *option="""") overrideTNamedvirtual; Clone(const char *newname="""") const overrideTNamedvirtual;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem-members.html:214,Abort,Abort,214,doc/master/classTUnixSystem-members.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem-members.html,1,['Abort'],['Abort']
Safety," Abort(int code=0)TSystemvirtual; AbstractMethod(const char *method) constTObject; AcceptConnection(int sock)TSystemvirtual; AccessPathName(const char *path, EAccessMode mode=kFileExists)TSystemvirtual; AddDynamicPath(const char *pathname)TSystemvirtual; AddFileHandler(TFileHandler *fh)TSystemvirtual; AddIncludePath(const char *includePath)TSystemvirtual; AddLinkedLibs(const char *linkedLib)TSystemvirtual; AddSignalHandler(TSignalHandler *sh)TSystemvirtual; AddStdExceptionHandler(TStdExceptionHandler *eh)TSystemvirtual; AddTimer(TTimer *t)TSystemvirtual; AddToTObjectTable(TObject *)TObjectprivatestatic; AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize=-1)TSystemvirtual; AnnounceUdpService(int port, int backlog)TSystemvirtual; AnnounceUnixService(int port, int backlog)TSystemvirtual; AnnounceUnixService(const char *sockpath, int backlog)TSystemvirtual; AppendPad(Option_t *option="""")TObjectvirtual; BaseName(const char *pathname)TSystemvirtual; Beep(Int_t freq=-1, Int_t duration=-1, Bool_t setDefault=kFALSE)TSystem; Browse(TBrowser *b)TObjectvirtual; cd(const char *path)TSysteminline; ChangeDirectory(const char *path)TSystemvirtual; CheckedHash()TObjectinline; Chmod(const char *file, UInt_t mode)TSystemvirtual; Class()TSystemstatic; Class_Name()TSystemstatic; Class_Version()TSysteminlinestatic; ClassName() constTObjectvirtual; CleanCompiledMacros()TSystemvirtual; Clear(Option_t *option="""") overrideTNamedvirtual; Clone(const char *newname="""") const overrideTNamedvirtual; CloseConnection(int sock, Bool_t force=kFALSE)TSystemvirtual; Closelog()TSystemvirtual; ClosePipe(FILE *pipe)TSystemvirtual; Compare(const TObject *obj) const overrideTNamedvirtual; CompileMacro(const char *filename, Option_t *opt="""", const char *library_name="""", const char *bui",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem-members.html:206,Abort,Abort,206,doc/master/classTSystem-members.html,https://root.cern,https://root.cern/doc/master/classTSystem-members.html,1,['Abort'],['Abort']
Safety," And Related Symbol Documentation. ◆ RWebWindow. friend class RWebWindow. friend . Definition at line 38 of file RWebWindowsManager.hxx. Member Data Documentation. ◆ fAddr. std::string ROOT::RWebWindowsManager::fAddr. private . ! HTTP address of the server ; Definition at line 42 of file RWebWindowsManager.hxx. ◆ fAssgnExec. std::unique_ptr<TExec> ROOT::RWebWindowsManager::fAssgnExec. private . ! special exec to assign thread id via ProcessEvents ; Definition at line 51 of file RWebWindowsManager.hxx. ◆ fExternalProcessEvents. bool ROOT::RWebWindowsManager::fExternalProcessEvents {false}. private . ! indicate that there are external process events engine ; Definition at line 50 of file RWebWindowsManager.hxx. ◆ fIdCnt. unsigned ROOT::RWebWindowsManager::fIdCnt {0}. private . ! counter for identifiers ; Definition at line 46 of file RWebWindowsManager.hxx. ◆ fLaunchTmout. float ROOT::RWebWindowsManager::fLaunchTmout {30.}. private . ! timeout in seconds to start browser process, default 30s ; Definition at line 49 of file RWebWindowsManager.hxx. ◆ fMutex. std::recursive_mutex ROOT::RWebWindowsManager::fMutex. private . ! main mutex, used for window creations ; Definition at line 45 of file RWebWindowsManager.hxx. ◆ fServer. std::unique_ptr<THttpServer> ROOT::RWebWindowsManager::fServer. private . ! central communication with the all used displays ; Definition at line 41 of file RWebWindowsManager.hxx. ◆ fSessionKey. std::string ROOT::RWebWindowsManager::fSessionKey. private . ! secret session key used on client to code connections keys ; Definition at line 43 of file RWebWindowsManager.hxx. ◆ fShowCallback. WebWindowShowCallback_t ROOT::RWebWindowsManager::fShowCallback. private . ! function called for each RWebWindow::Show call ; Definition at line 52 of file RWebWindowsManager.hxx. ◆ fUseHttpThrd. bool ROOT::RWebWindowsManager::fUseHttpThrd {false}. private . ! use special thread for THttpServer ; Definition at line 47 of file RWebWindowsManager.hxx. ◆ fUseSenderThr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html:20291,timeout,timeout,20291,doc/v632/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html,1,['timeout'],['timeout']
Safety," Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 60+12*fNz;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetDphi() const; {return fDphi;}. Int_t GetNz() const; {return fNz;}. Double_t * GetRmin() const; {return fRmin;}. Double_t * GetRmax() const; {return fRmax;}. Double_t * GetZ() const; {return fZ;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsCylType() const; {return kTRUE;}. Double_t & Phi1(); {return fPhi1;}. Double_t & Dphi(); {return fDphi;}. Double_t & Rmin(Int_t ipl); {return fRmin[ipl];}. Double_t & Rmax(Int_t ipl); {return fRmax[ipl];}. Double_t & Z(Int_t ipl); {return fZ[ipl];}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPcon.html:19358,Safe,Safety,19358,root/html534/TGeoPcon.html,https://root.cern,https://root.cern/root/html534/TGeoPcon.html,1,['Safe'],['Safety']
Safety," Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 60+12*fNz;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetDphi() const; {return fDphi;}. Int_t GetNz() const; {return fNz;}. Double_t * GetRmin() const; {return fRmin;}. Double_t * GetRmax() const; {return fRmax;}. Double_t * GetZ() const; {return fZ;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsCylType() const; {return kTRUE;}. Double_t & Phi1(); {return fPhi1;}. Double_t & Dphi(); {return fDphi;}. Double_t & Rmin(Int_t ipl); {return fRmin[ipl];}. Double_t & Rmax(Int_t ipl); {return fRmax[ipl];}. Double_t & Z(Int_t ipl); {return fZ[ipl];}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 16:03; This page has been automatically generated. For comments or suggestions",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoPcon.html:21109,Safe,Safety,21109,root/html604/TGeoPcon.html,https://root.cern,https://root.cern/root/html604/TGeoPcon.html,1,['Safe'],['Safety']
Safety," Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 60+12*fNz;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetDphi() const; {return fDphi;}. Int_t GetNz() const; {return fNz;}. Double_t * GetRmin() const; {return fRmin;}. Double_t * GetRmax() const; {return fRmax;}. Double_t * GetZ() const; {return fZ;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsCylType() const; {return kTRUE;}. Double_t & Phi1(); {return fPhi1;}. Double_t & Dphi(); {return fDphi;}. Double_t & Rmin(Int_t ipl); {return fRmin[ipl];}. Double_t & Rmax(Int_t ipl); {return fRmax[ipl];}. Double_t & Z(Int_t ipl); {return fZ[ipl];}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPcon.html:21109,Safe,Safety,21109,root/html602/TGeoPcon.html,https://root.cern,https://root.cern/root/html602/TGeoPcon.html,1,['Safe'],['Safety']
Safety," Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoSphere(); methods; constructors. Int_t GetByteCount() const; {return 42;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNumberOfDivisions() const; {return fNseg;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Int_t GetNz() const; {return fNz;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetTheta1() const; {return fTheta1;}. Double_t GetTheta2() const; {return fTheta2;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetPhi2() const; {return fPhi2;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT suppor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoSphere.html:19092,Safe,Safety,19092,root/html534/TGeoSphere.html,https://root.cern,https://root.cern/root/html534/TGeoSphere.html,1,['Safe'],['Safety']
Safety," Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoSphere(); methods; constructors. Int_t GetByteCount() const; {return 42;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNumberOfDivisions() const; {return fNseg;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Int_t GetNz() const; {return fNz;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetTheta1() const; {return fTheta1;}. Double_t GetTheta2() const; {return fTheta2;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetPhi2() const; {return fPhi2;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 16:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT suppor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoSphere.html:20846,Safe,Safety,20846,root/html604/TGeoSphere.html,https://root.cern,https://root.cern/root/html604/TGeoSphere.html,1,['Safe'],['Safety']
Safety," Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoSphere(); methods; constructors. Int_t GetByteCount() const; {return 42;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNumberOfDivisions() const; {return fNseg;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Int_t GetNz() const; {return fNz;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetTheta1() const; {return fTheta1;}. Double_t GetTheta2() const; {return fTheta2;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetPhi2() const; {return fPhi2;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT suppor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoSphere.html:20846,Safe,Safety,20846,root/html602/TGeoSphere.html,https://root.cern,https://root.cern/root/html602/TGeoSphere.html,1,['Safe'],['Safety']
Safety," Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. ThreadData_t& GetThreadData() const. Int_t GetNz() const; virtual Int_t GetByteCount() const {return 60+12*fNz;}. {return fNz;}. Int_t GetNvert() const; {return fNvert;}. Double_t GetX(Int_t i) const; {return (i<fNvert&&i>-1 &&fX!=0) ? fX[i] : -1.0E10;}. Double_t GetY(Int_t i) const; {return (i<fNvert&&i>-1 &&fY!=0) ? fY[i] : -1.0E10;}. Double_t GetXOffset(Int_t i) const; {return (i<fNz&&i>-1 && fX0!=0) ? fX0[i] : 0.0;}. Double_t GetYOffset(Int_t i) const; {return (i<fNz&&i>-1 && fY0!=0) ? fY0[i] : 0.0;}. Double_t GetScale(Int_t i) const; {return (i<fNz&&i>-1 && fScale!=0) ? fScale[i] : 1.0;}. Double_t * GetZ() const; {return fZ;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Double_t & Z(Int_t ipl); {return fZ[ipl];}. » Author: Mihaela Gheata 24/01/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:40; This page has bee",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoXtru.html:21563,Safe,Safety,21563,root/html534/TGeoXtru.html,https://root.cern,https://root.cern/root/html534/TGeoXtru.html,1,['Safe'],['Safety']
Safety," Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. ThreadData_t& GetThreadData() const. Int_t GetNz() const; virtual Int_t GetByteCount() const {return 60+12*fNz;}. {return fNz;}. Int_t GetNvert() const; {return fNvert;}. Double_t GetX(Int_t i) const; {return (i<fNvert&&i>-1 &&fX!=0) ? fX[i] : -1.0E10;}. Double_t GetY(Int_t i) const; {return (i<fNvert&&i>-1 &&fY!=0) ? fY[i] : -1.0E10;}. Double_t GetXOffset(Int_t i) const; {return (i<fNz&&i>-1 && fX0!=0) ? fX0[i] : 0.0;}. Double_t GetYOffset(Int_t i) const; {return (i<fNz&&i>-1 && fY0!=0) ? fY0[i] : 0.0;}. Double_t GetScale(Int_t i) const; {return (i<fNz&&i>-1 && fScale!=0) ? fScale[i] : 1.0;}. Double_t * GetZ() const; {return fZ;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Double_t & Z(Int_t ipl); {return fZ[ipl];}. » Author: Mihaela Gheata 24/01/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 16:04; This page has bee",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoXtru.html:23326,Safe,Safety,23326,root/html604/TGeoXtru.html,https://root.cern,https://root.cern/root/html604/TGeoXtru.html,1,['Safe'],['Safety']
Safety," Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. ThreadData_t& GetThreadData() const. Int_t GetNz() const; virtual Int_t GetByteCount() const {return 60+12*fNz;}. {return fNz;}. Int_t GetNvert() const; {return fNvert;}. Double_t GetX(Int_t i) const; {return (i<fNvert&&i>-1 &&fX!=0) ? fX[i] : -1.0E10;}. Double_t GetY(Int_t i) const; {return (i<fNvert&&i>-1 &&fY!=0) ? fY[i] : -1.0E10;}. Double_t GetXOffset(Int_t i) const; {return (i<fNz&&i>-1 && fX0!=0) ? fX0[i] : 0.0;}. Double_t GetYOffset(Int_t i) const; {return (i<fNz&&i>-1 && fY0!=0) ? fY0[i] : 0.0;}. Double_t GetScale(Int_t i) const; {return (i<fNz&&i>-1 && fScale!=0) ? fScale[i] : 1.0;}. Double_t * GetZ() const; {return fZ;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Double_t & Z(Int_t ipl); {return fZ[ipl];}. » Author: Mihaela Gheata 24/01/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:04; This page has bee",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoXtru.html:23326,Safe,Safety,23326,root/html602/TGeoXtru.html,https://root.cern,https://root.cern/root/html602/TGeoXtru.html,1,['Safe'],['Safety']
Safety," Bool_t CouldBeCrossed(Double_t* point, Double_t* dir) const; Decides fast if the bounding box could be crossed by a vector. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this box shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Test if point is inside this shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get ra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoBBox.html:14638,safe,safe,14638,root/html528/TGeoBBox.html,https://root.cern,https://root.cern/root/html528/TGeoBBox.html,3,['safe'],['safe']
Safety," Bool_t Init();; 347 virtual void SetProgname(const char *name);; 348 virtual void SetDisplay();; 349 void SetErrorStr(const char *errstr);; 350 const char *GetErrorStr() const { return GetLastErrorString(); }; 351 virtual const char *GetError();; 352 virtual Int_t GetCryptoRandom(void *buf, Int_t len);; 353 void RemoveOnExit(TObject *obj);; 354 virtual const char *HostName();; 355 virtual void NotifyApplicationCreated();; 356 ; 357 static Int_t GetErrno();; 358 static void ResetErrno();; 359 void Beep(Int_t freq=-1, Int_t duration=-1, Bool_t setDefault=kFALSE);; 360 void GetBeepDefaults(Int_t &freq, Int_t &duration) const { freq = fBeepFreq; duration = fBeepDuration; }; 361 ; 362 //---- EventLoop; 363 virtual void Run();; 364 virtual Bool_t ProcessEvents();; 365 virtual void DispatchOneEvent(Bool_t pendingOnly = kFALSE);; 366 virtual void ExitLoop();; 367 Bool_t InControl() const { return fInControl; }; 368 virtual void InnerLoop();; 369 virtual Int_t Select(TList *active, Long_t timeout);; 370 virtual Int_t Select(TFileHandler *fh, Long_t timeout);; 371 ; 372 //---- Handling of system events; 373 virtual void AddSignalHandler(TSignalHandler *sh);; 374 virtual TSignalHandler *RemoveSignalHandler(TSignalHandler *sh);; 375 virtual void ResetSignal(ESignals sig, Bool_t reset = kTRUE);; 376 virtual void ResetSignals();; 377 virtual void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE);; 378 virtual void IgnoreInterrupt(Bool_t ignore = kTRUE);; 379 virtual TSeqCollection *GetListOfSignalHandlers() const { return fSignalHandler; }; 380 virtual void AddFileHandler(TFileHandler *fh);; 381 virtual TFileHandler *RemoveFileHandler(TFileHandler *fh);; 382 virtual TSeqCollection *GetListOfFileHandlers() const { return fFileHandler; }; 383 virtual void AddStdExceptionHandler(TStdExceptionHandler *eh);; 384 virtual TStdExceptionHandler *RemoveStdExceptionHandler(TStdExceptionHandler *eh);; 385 virtual TSeqCollection *GetListOfStdExceptionHandlers() const { return fStdExceptionHa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:15423,timeout,timeout,15423,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['timeout'],['timeout']
Safety," Bool_t add(const RooAbsArg& var, Bool_t silent); Add element to non-owning set. The operation will fail if; a similarly named object already exists in the set, or; the set is specified to own its elements. Eventual error messages; can be suppressed with the silent flag. Bool_t addOwned(RooAbsArg& var, Bool_t silent); Add element to an owning set. The operation will fail if; a similarly named object already exists in the set, or; the set is not specified to own its elements. Eventual error messages; can be suppressed with the silent flag. RooAbsArg* addClone(const RooAbsArg& var, Bool_t silent); Add clone of specified element to an owning set. If sucessful, the; set will own the clone, not the original. The operation will fail if; a similarly named object already exists in the set, or; the set is not specified to own its elements. Eventual error messages; can be suppressed with the silent flag. RooAbsArg& operator[](const char* name) const; Array operator. Named element must exist in set, otherwise; code will abort. When used as lvalue in assignment operations, the element contained in; the list will not be changed, only the value of the existing element!. Bool_t checkForDup(const RooAbsArg& arg, Bool_t silent) const; Check if element with var's name is already in set. Double_t getRealValue(const char* name, Double_t defVal = 0, Bool_t verbose = kFALSE) const; Get value of a RooAbsReal stored in set with given name. If none is found, value of defVal is returned.; No error messages are printed unless the verbose flag is set. Bool_t setRealValue(const char* name, Double_t newVal = 0, Bool_t verbose = kFALSE); Set value of a RooAbsRealLValye stored in set with given name to newVal; No error messages are printed unless the verbose flag is set. const char* getCatLabel(const char* name, const char* defVal = """", Bool_t verbose = kFALSE) const; Get state name of a RooAbsCategory stored in set with given name. If none is found, value of defVal is returned.; No error messages ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooArgSet.html:18186,abort,abort,18186,root/html526/RooArgSet.html,https://root.cern,https://root.cern/root/html526/RooArgSet.html,1,['abort'],['abort']
Safety," Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoHalfSpace&operator=(const TGeoHalfSpace&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoHalfSpace.html:8289,safe,safe,8289,root/html602/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html602/TGeoHalfSpace.html,2,['safe'],['safe']
Safety," C++ type_info, we must be in the case of; 1669 // a template of Double32_t. This is actually a correct case.; 1670 } else {; 1671 Error(""Branch"", ""The actual class (%s) of the object provided for the definition of the branch \""%s\"" does not inherit from %s"",; 1672 actualClass->GetName(), branchname, claim->GetName());; 1673 }; 1674 }; 1675 }; 1676 if (!actualClass) {; 1677 Warning(""Branch"", ""The actual TClass corresponding to the object provided for the definition of the branch \""%s\"" is missing.\n\tThe object will be truncated down to its %s part"",; 1678 branchname, ptrClass->GetName());; 1679 actualClass = ptrClass;; 1680 } else if ((ptrClass != actualClass) && !actualClass->InheritsFrom(ptrClass)) {; 1681 Error(""Branch"", ""The actual class (%s) of the object provided for the definition of the branch \""%s\"" does not inherit from %s"", actualClass->GetName(), branchname, ptrClass->GetName());; 1682 return nullptr;; 1683 }; 1684 if (actualClass && actualClass->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(actualClass->GetCollectionProxy())) {; 1685 Error(""Branch"", writeStlWithoutProxyMsg,; 1686 actualClass->GetName(), branchname, actualClass->GetName());; 1687 return nullptr;; 1688 }; 1689 return BronchExec(branchname, actualClass->GetName(), (void*) addobj, false, bufsize, splitlevel);; 1690}; 1691 ; 1692////////////////////////////////////////////////////////////////////////////////; 1693/// Same as TTree::Branch but automatic detection of the class name.; 1694/// \see TTree::Branch for other details.; 1695 ; 1696TBranch* TTree::BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); 1697{; 1698 if (!ptrClass) {; 1699 if (datatype == kOther_t || datatype == kNoType_t) {; 1700 Error(""Branch"", ""The pointer specified for %s is not of a class or type known to ROOT"", branchname);; 1701 } else {; 1702 TString varname; varname.Form(""%s/%c"",branchname,DataTypeToChar(datatype));; 1703 retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:65390,detect,detection,65390,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['detect'],['detection']
Safety," Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube segment. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube segment; first check if point is inside the tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTubeSeg.html:16476,safe,safe,16476,root/html534/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html,3,['safe'],['safe']
Safety," ClearThreadsMap();; 520 ClearThreadData();; 521 delete TGeoBuilder::Instance(this);; 522 if (fBits); 523 delete[] fBits;; 524 SafeDelete(fNodes);; 525 SafeDelete(fTopNode);; 526 if (fOverlaps) {; 527 fOverlaps->Delete();; 528 SafeDelete(fOverlaps);; 529 }; 530 if (fRegions) {; 531 fRegions->Delete();; 532 SafeDelete(fRegions);; 533 }; 534 if (fMaterials) {; 535 fMaterials->Delete();; 536 SafeDelete(fMaterials);; 537 }; 538 SafeDelete(fElementTable);; 539 if (fMedia) {; 540 fMedia->Delete();; 541 SafeDelete(fMedia);; 542 }; 543 if (fHashVolumes) {; 544 fHashVolumes->Clear(""nodelete"");; 545 SafeDelete(fHashVolumes);; 546 }; 547 if (fHashGVolumes) {; 548 fHashGVolumes->Clear(""nodelete"");; 549 SafeDelete(fHashGVolumes);; 550 }; 551 if (fHashPNE) {; 552 fHashPNE->Delete();; 553 SafeDelete(fHashPNE);; 554 }; 555 if (fArrayPNE) {; 556 delete fArrayPNE;; 557 }; 558 if (fVolumes) {; 559 fVolumes->Delete();; 560 SafeDelete(fVolumes);; 561 }; 562 if (fShapes) {; 563 fShapes->Delete();; 564 SafeDelete(fShapes);; 565 }; 566 if (fPhysicalNodes) {; 567 fPhysicalNodes->Delete();; 568 SafeDelete(fPhysicalNodes);; 569 }; 570 if (fMatrices) {; 571 fMatrices->Delete();; 572 SafeDelete(fMatrices);; 573 }; 574 if (fTracks) {; 575 fTracks->Delete();; 576 SafeDelete(fTracks);; 577 }; 578 SafeDelete(fUniqueVolumes);; 579 if (fPdgNames) {; 580 fPdgNames->Delete();; 581 SafeDelete(fPdgNames);; 582 }; 583 if (fGDMLMatrices) {; 584 fGDMLMatrices->Delete();; 585 SafeDelete(fGDMLMatrices);; 586 }; 587 if (fOpticalSurfaces) {; 588 fOpticalSurfaces->Delete();; 589 SafeDelete(fOpticalSurfaces);; 590 }; 591 if (fSkinSurfaces) {; 592 fSkinSurfaces->Delete();; 593 SafeDelete(fSkinSurfaces);; 594 }; 595 if (fBorderSurfaces) {; 596 fBorderSurfaces->Delete();; 597 SafeDelete(fBorderSurfaces);; 598 }; 599 ClearNavigators();; 600 CleanGarbage();; 601 SafeDelete(fPainter);; 602 SafeDelete(fGLMatrix);; 603 if (fSizePNEId) {; 604 delete[] fKeyPNEId;; 605 delete[] fValuePNEId;; 606 }; 607 delete fParallelWorld;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:22306,Safe,SafeDelete,22306,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['Safe'],['SafeDelete']
Safety," ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a tube with given radius, starting from; POINT along DIR director cosines. The distance is computed as :; RSQ = point[0]*point[0]+point[1]*point[1]; NSQ = dir[0]*dir[0]+dir[1]*dir[1] ---> should NOT be 0 !!!; RDOTN = point[0]*dir[0]+point[1]*dir[1]; The distance can be computed as :; D = -B +/- DELTA; where DELTA.GT.0 and D.GT.0. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTube.html:14057,safe,safe,14057,root/html528/TGeoTube.html,https://root.cern,https://root.cern/root/html528/TGeoTube.html,3,['safe'],['safe']
Safety," Create a socket. The socket will adopt previously opened TCP socket with; descriptor desc. TSocket(Int_t descriptor, const char* sockpath); Create a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TSocket(const TSocket& s); TSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSocket.html:13270,timeout,timeout,13270,root/html528/TSocket.html,https://root.cern,https://root.cern/root/html528/TSocket.html,3,['timeout'],['timeout']
Safety," Data Members; private:. Ssiz_tfBeginIndex of starting character; Ssiz_tfExtentLength of TSubString; TString&fStrReferenced string. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char * Data() const; Return a pointer to the beginning of the substring. Note that the; terminating null is in the same place as for the original; TString, so this method is not appropriate for converting the; TSubString to a string. To do that, construct a TString from the; TSubString. For example:. root [0] TString s(""hello world""); root [1] TSubString sub=s(0, 5); root [2] sub.Data(); (const char* 0x857c8b8)""hello world""; root [3] TString substr(sub); root [4] substr; (class TString)""hello"". char operator[](Ssiz_t i) const; Access to elements of sub-string with bounds checking. { AssertElement(i); return fStr.GetPointer()[fBegin+i]; }. char operator()(Ssiz_t i) const; { return fStr.GetPointer()[fBegin+i]; }. TSubString & operator=(const TSubString& s); { fStr = s.fStr; fBegin = s.fBegin; fExtent = s.fExtent; return *this; }. TSubString(const TString& s, Ssiz_t start, Ssiz_t len); NB: the only constructor is private. void SubStringError(Ssiz_t , Ssiz_t , Ssiz_t ) const. void AssertElement(Ssiz_t i) const. TSubString(const TSubString& s); { }. TSubString & operator=(const char* s). TSubString & operator=(const TString& s). char & operator()(Ssiz_t i). char & operator[](Ssiz_t i). Ssiz_t Length() const; { return fExtent; }. Ssiz_t Start() const; { return fBegin; }. void ToLower(). void ToUpper(). Bool_t IsNull() const; For detecting null substrings. { return fBegin == kNPOS; }. int operator!() const; { return fBegin == kNPOS; }. » Author: Fons Rademakers 04/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSubString.html:2560,detect,detecting,2560,root/html534/TSubString.html,https://root.cern,https://root.cern/root/html534/TSubString.html,1,['detect'],['detecting']
Safety, Definition at line 191 of file RuleFitParams.h. ◆ fNTCoeff. Double_t* TMVA::RuleFitParams::fNTCoeff. protected . GD path: rule coefficients. ; Definition at line 243 of file RuleFitParams.h. ◆ fNTCoefRad. Double_t TMVA::RuleFitParams::fNTCoefRad. protected . GD path: 'radius' of all rulecoeffs. ; Definition at line 241 of file RuleFitParams.h. ◆ fNTErrorRate. Double_t TMVA::RuleFitParams::fNTErrorRate. protected . GD path: error rate (or performance) ; Definition at line 239 of file RuleFitParams.h. ◆ fNTLinCoeff. Double_t* TMVA::RuleFitParams::fNTLinCoeff. protected . GD path: linear coefficients. ; Definition at line 244 of file RuleFitParams.h. ◆ fNTNuval. Double_t TMVA::RuleFitParams::fNTNuval. protected . GD path: value of nu. ; Definition at line 240 of file RuleFitParams.h. ◆ fNTOffset. Double_t TMVA::RuleFitParams::fNTOffset. protected . GD path: model offset. ; Definition at line 242 of file RuleFitParams.h. ◆ fNTRisk. Double_t TMVA::RuleFitParams::fNTRisk. protected . GD path: risk. ; Definition at line 238 of file RuleFitParams.h. ◆ fPathIdx1. UInt_t TMVA::RuleFitParams::fPathIdx1. protected . first event index for path search ; Definition at line 197 of file RuleFitParams.h. ◆ fPathIdx2. UInt_t TMVA::RuleFitParams::fPathIdx2. protected . last event index for path search ; Definition at line 198 of file RuleFitParams.h. ◆ fPerfIdx1. UInt_t TMVA::RuleFitParams::fPerfIdx1. protected . first event index for performance evaluation ; Definition at line 199 of file RuleFitParams.h. ◆ fPerfIdx2. UInt_t TMVA::RuleFitParams::fPerfIdx2. protected . last event index for performance evaluation ; Definition at line 200 of file RuleFitParams.h. ◆ fRuleEnsemble. RuleEnsemble* TMVA::RuleFitParams::fRuleEnsemble. protected . rule ensemble ; Definition at line 189 of file RuleFitParams.h. ◆ fRuleFit. RuleFit* TMVA::RuleFitParams::fRuleFit. protected . rule fit ; Definition at line 188 of file RuleFitParams.h. ◆ fsigave. Double_t TMVA::RuleFitParams::fsigave. protected . Si,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:25910,risk,risk,25910,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,1,['risk'],['risk']
Safety," Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » ROOT 6 Analysis Workshop 5. Fitting. Distributions; Some analyses want to check theory predictions that exist as a function definition. Others want to use a distribution from a histogram in another step of the analysis. But histograms have bin steps by nature instead of being smooth, and they have bumps / fluctuations due to limited statistics (i.e. ""not enough data"").; So what's needed is a function whose line is ""as close as possible"" to the histogram counts. I.e. we need a function (that predicts the shape of the histogram) and that we can vary a bit (""free parameters""). Then we search for the best set of parameters, such that the function resembles the histogram.; That's fitting.; Fitting in Practice; As often with ROOT, you can use a GUI element (the fit panel, available through the menu in ""Tools"", ""Fit Panel"", or on the prompt (TH1::Fit()). Let's use the fit panel!; First, we draw the distribution of the vertex position along X for all muons. Do that into a histogram that has 20 bins and runs from -10 to +10. Now open the fit panel and click the histogram. We want to fit a Gaussian distribution - and hat's already selected by default. Se just press ""Fit"". Looks good, right?; Fit Parameters; As mentioned before, fitting means finding the optimal set of parameters. In the menu, select ""Options"", ""Fit Parameters"" (and resize the statistics box to make its content readable). You will see the values that the minimizer has found optimal, for instance it chose 1.2 as the mean of the Gaussian and 1.04",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/5-fitting.html:2343,predict,predicts,2343,d/5-fitting.html,https://root.cern,https://root.cern/d/5-fitting.html,1,['predict'],['predicts']
Safety," Disconnect(this, ""Timeout()"", this, ""TurnOff()"");; 223}; 224 ; 225////////////////////////////////////////////////////////////////////////////////; 226/// Remove timer from system timer list. This requires that a timer; 227/// has been placed in the system timer list (using TurnOn()).; 228/// If a TTimer subclass is placed on another list, override TurnOff() to; 229/// remove the timer from the correct list.; 230 ; 231void TTimer::TurnOff(); 232{; 233 if (gSystem); 234 if (gSystem->RemoveTimer(this)); 235 Emit(""TurnOff()"");; 236}; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/// Add the timer to the system timer list. If a TTimer subclass has to be; 240/// placed on another list, override TurnOn() to add the timer to the correct; 241/// list.; 242 ; 243void TTimer::TurnOn(); 244{; 245 // might have been set in a previous Start(); 246 Disconnect(this, ""Timeout()"", this, ""TurnOff()"");; 247 ; 248 if (gSystem) {; 249 gSystem->AddTimer(this);; 250 Emit(""TurnOn()"");; 251 }; 252}; 253 ; 254////////////////////////////////////////////////////////////////////////////////; 255/// This static function calls a slot after a given time interval.; 256/// Created internal timer will be deleted after that.; 257 ; 258void TTimer::SingleShot(Int_t milliSec, const char *receiver_class,; 259 void *receiver, const char *method); 260{; 261 TTimer *singleShotTimer = new TTimer(milliSec);; 262 TQObject::Connect(singleShotTimer, ""Timeout()"",; 263 receiver_class, receiver, method);; 264 ; 265 static TSingleShotCleaner singleShotCleaner; // single shot timer cleaner; 266 ; 267 // gSingleShotCleaner will delete singleShotTimer a; 268 // short period after Timeout() signal is emitted; 269 TQObject::Connect(singleShotTimer, ""Timeout()"",; 270 ""TTimer"", &singleShotCleaner, ""TurnOn()"");; 271 ; 272 singleShotTimer->Start(milliSec, kTRUE);; 273}; 274 ; 275////////////////////////////////////////////////////////////////////////////////; 276/// This funct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTimer_8cxx_source.html:8633,Timeout,Timeout,8633,doc/master/TTimer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTimer_8cxx_source.html,1,['Timeout'],['Timeout']
Safety," Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a tube with given radius, starting from; POINT along DIR director cosines. The distance is computed as :; RSQ = point[0]*point[0]+point[1]*point[1]; NSQ = dir[0]*dir[0]+dir[1]*dir[1] ---> should NOT be 0 !!!; RDOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTube.html:15107,safe,safe,15107,root/html534/TGeoTube.html,https://root.cern,https://root.cern/root/html534/TGeoTube.html,6,['safe'],['safe']
Safety," Double_t rok = ran.Gaus(10, 1);; Double_t rbad1 = ran.Gaus(8, 5);; Double_t rbad2 = ran.Gaus(-8, 5);; ; Double_t val = rok;; ; xoffset1 += 0.00002;; yoffset1 += 0.00002;; ; xoffset2 += 0.00003;; yoffset2 += 0.00004;; ; if (r2 > 3. - yoffset1 && r2 < 8. - yoffset1 &&; r1 > 1. + xoffset1 && r1 < 5. + xoffset1 ) {; val -= rbad1;; }; ; if (r2 > -10 + yoffset2 && r2 < -8 + yoffset2 &&; r1 > -6 + xoffset2 && r1 < 8 + xoffset2 ) {; val -= rbad2;; }; ; tot_avg_ls[i].Fill(r1, r2, val);; det_avg_ls[i].Fill(r1, r2, val);; det_err_ls[i].Fill(r1, r2, val);; }; ; std::string title;; ; c1->cd(i+1);; title = ""Global View: Avg in LS "" + std::to_string(i);; tot_avg_ls[i].SetTitle(title.c_str());; tot_avg_ls[i].SetStats(false);; tot_avg_ls[i].Draw(""COLZ"");; c1->Update();; ; c1->cd((i+1)+NUM_LS);; title = ""Detector View: Avg in LS "" + std::to_string(i);; det_avg_ls[i].SetTitle(title.c_str());; det_avg_ls[i].SetStats(false);; det_avg_ls[i].Draw(""COLZ"");; c1->Update();; ; c1->cd((i+1)+(NUM_LS*2));; title = ""Detector View: Error in LS "" + std::to_string(i);; det_err_ls[i].SetTitle(title.c_str());; det_err_ls[i].SetStats(false);; det_err_ls[i].SetContentToError();; det_err_ls[i].Draw(""COLZ"");; c1->Update();; }; ; std::vector<TProfile2Poly*> tot_avg_v;; std::vector<TProfile2Poly*> det_avg_v;; for (int t = 0; t < NUM_LS; t++){; tot_avg_v.push_back(&tot_avg_ls[t]);; det_avg_v.push_back(&det_avg_ls[t]);; }; ; std::cout << ""[In Progress] Merging"" << std::endl;; ; tot_merge->Merge(tot_avg_v);; c2->cd(1);; tot_merge->SetTitle(""Total average merge"");; tot_merge->Draw(""COLZ"");; ; det_avg_merge->Merge(det_avg_v);; c2->cd(2);; det_avg_merge->SetTitle(""Detector average merge"");; det_avg_merge->SetContentToAverage(); // implicit; det_avg_merge->Draw(""COLZ"");; ; det_err_merge->Merge(det_avg_v);; c2->cd(3);; det_err_merge->SetTitle(""Detector error merge"");; det_err_merge->SetContentToError();; det_err_merge->Draw(""COLZ"");; }; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RSha256.hxx:99",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tprofile2polyRealistic_8C.html:4137,Detect,Detector,4137,doc/master/tprofile2polyRealistic_8C.html,https://root.cern,https://root.cern/doc/master/tprofile2polyRealistic_8C.html,1,['Detect'],['Detector']
Safety," Double_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoScaledShape&operator=(const TGeoScaledShape&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidTGeoBBox::SetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); voidSetScale(TGeoScale* scale); virtual voidSetSegsAndPol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoScaledShape.html:7694,Safe,SafetyPhi,7694,root/html530/TGeoScaledShape.html,https://root.cern,https://root.cern/root/html530/TGeoScaledShape.html,2,['Safe'],['SafetyPhi']
Safety," Double_t xmin, Double_t xmax ); 111{; 112 return 2*(x - xmin)/(xmax - xmin) - 1.0;; 113}; 114 ; 115////////////////////////////////////////////////////////////////////////////////; 116/// compute ""separation"" defined as; 117/// \f[; 118/// <s2> = \frac{1}{2} \int_{-\infty}^{+\infty} \frac{(S(x) - B(x))^2}{(S(x) + B(x))} dx; 119/// \f]; 120 ; 121Double_t TMVA::Tools::GetSeparation( TH1* S, TH1* B ) const; 122{; 123 Double_t separation = 0;; 124 ; 125 // sanity checks; 126 // signal and background histograms must have same number of bins and; 127 // same limits; 128 if ((S->GetNbinsX() != B->GetNbinsX()) || (S->GetNbinsX() <= 0)) {; 129 Log() << kFATAL << ""<GetSeparation> signal and background""; 130 << "" histograms have different number of bins: ""; 131 << S->GetNbinsX() << "" : "" << B->GetNbinsX() << Endl;; 132 }; 133 ; 134 if (S->GetXaxis()->GetXmin() != B->GetXaxis()->GetXmin() ||; 135 S->GetXaxis()->GetXmax() != B->GetXaxis()->GetXmax() ||; 136 S->GetXaxis()->GetXmax() <= S->GetXaxis()->GetXmin()) {; 137 Log() << kINFO << S->GetXaxis()->GetXmin() << "" "" << B->GetXaxis()->GetXmin(); 138 << "" "" << S->GetXaxis()->GetXmax() << "" "" << B->GetXaxis()->GetXmax(); 139 << "" "" << S->GetXaxis()->GetXmax() << "" "" << S->GetXaxis()->GetXmin() << Endl;; 140 Log() << kFATAL << ""<GetSeparation> signal and background""; 141 << "" histograms have different or invalid dimensions:"" << Endl;; 142 }; 143 ; 144 Int_t nstep = S->GetNbinsX();; 145 Double_t intBin = (S->GetXaxis()->GetXmax() - S->GetXaxis()->GetXmin())/nstep;; 146 Double_t nS = S->GetSumOfWeights()*intBin;; 147 Double_t nB = B->GetSumOfWeights()*intBin;; 148 ; 149 if (nS > 0 && nB > 0) {; 150 for (Int_t bin=0; bin<nstep; bin++) {; 151 Double_t s = S->GetBinContent( bin+1 )/Double_t(nS);; 152 Double_t b = B->GetBinContent( bin+1 )/Double_t(nB);; 153 // separation; 154 if (s + b > 0) separation += (s - b)*(s - b)/(s + b);; 155 }; 156 separation *= (0.5*intBin);; 157 }; 158 else {; 159 Log() << kWARNING << ""<GetSeparation> histogra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:3955,sanity check,sanity checks,3955,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['sanity check'],['sanity checks']
Safety," Double_t zc) const; compute real Z coordinate of a point belonging to either lower or; higher caps (z should be either +fDz or -fDz). Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the cut tube. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the cut tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the tube along one axis. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SetCtubDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); set dimensions of a cut tube. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set dimensions of the cut tube starting from a list. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; Fills array with n random points located on the line segments of the shape mesh.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation is implemented. void SetPoints(Double_t* points) const; Create mesh points for the cut tube. void SetPoints(Float_t* points) const; Create mesh points for the cut tube. void GetMeshNumbers(Int_t& nvert, Int_t& ns",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCtub.html:17158,Safe,Safety,17158,root/html534/TGeoCtub.html,https://root.cern,https://root.cern/root/html534/TGeoCtub.html,3,['Safe'],['Safety']
Safety," Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this sphere. Double_t DistToCons(Double_t* point, Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base; - phi1, phi2 - phi limits. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from inside point to surface of the tube segment. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube segment. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from outside point to surface of arbitrary tube. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to create",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoConeSeg.html:15358,safe,safe,15358,root/html528/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html528/TGeoConeSeg.html,3,['safe'],['safe']
Safety," Double_t* w, Bool_t userw, Double_t* rw, Bool_t& ok); Fit value at x[i] *-*-*-*-*-*-*-*-*-. Based on R function lowest: Translated to C++ by C. Stratowa; (R source file: lowess.c by R Development Core Team (C) 1999-2001). -. TGraph * SmoothSuper(TGraph* grin, Option_t* option = """", Double_t bass = 0, Double_t span = 0, Bool_t isPeriodic = kFALSE, Double_t* w = 0); Smooth data with Super smoother*-*-*-. Smooth the (x, y) values by Friedman's ``super smoother''. Arguments:; grin: graph for smoothing. span: the fraction of the observations in the span of the running lines; smoother, or 0 to choose this by leave-one-out cross-validation.; bass: controls the smoothness of the fitted curve.; Values of up to 10 indicate increasing smoothness.; isPeriodic: if TRUE, the x values are assumed to be in [0, 1]; and of period 1.; w: case weights. Details:; supsmu is a running lines smoother which chooses between three spans for; the lines. The running lines smoothers are symmetric, with k/2 data points; each side of the predicted point, and values of k as 0.5 * n, 0.2 * n and; 0.05 * n, where n is the number of data points. If span is specified,; a single smoother with span span * n is used. The best of the three smoothers is chosen by cross-validation for each; prediction. The best spans are then smoothed by a running lines smoother; and the final prediction chosen by linear interpolation. The FORTRAN code says: ``For small samples (n < 40) or if there are; substantial serial correlations between observations close in x - value,; then a prespecified fixed span smoother (span > 0) should be used.; Reasonable span values are 0.2 to 0.4.''. References:; Friedman, J. H. (1984) SMART User's Guide.; Laboratory for Computational Statistics,; Stanford University Technical Report No. 1. Friedman, J. H. (1984) A variable span scatterplot smoother.; Laboratory for Computational Statistics,; Stanford University Technical Report No. 5. void BDRsupsmu(Int_t n, Double_t* x, Double_t* y, Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphSmooth.html:11212,predict,predicted,11212,root/html528/TGraphSmooth.html,https://root.cern,https://root.cern/root/html528/TGraphSmooth.html,6,['predict'],['predicted']
Safety," Double_tTGeoTrap::fTl2half length in x at high z and y high edge; Double_t*TGeoArb8::fTwist! [4] tangents of twist angles; Double_tfTwistAngletwist angle in degrees; Double_tTGeoArb8::fXY[8][2]list of vertices; static TGeoArb8::EGeoArb8TypeTGeoArb8::kArb8Tra; static TGeoArb8::EGeoArb8TypeTGeoArb8::kArb8Trap. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGtra(); Default ctor. TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor. TGeoGtra(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor providing the name of the shape. ~TGeoGtra(); Destructor. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these has to be computed; in order to fit the mother. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = theta; param[2] = phi; param[3] = h1; param[4] = bl1; param[5] = tl1; param[6] = alpha1; param[7] = h2; param[8] = bl2; param[9] = tl2; param[10] = alpha2; param[11] = twist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoGtra.html:17810,safe,safe,17810,root/html602/TGeoGtra.html,https://root.cern,https://root.cern/root/html602/TGeoGtra.html,2,['safe'],['safe']
Safety," Double_t ; r1, . Double_t ; r2, . Double_t & ; b, . Double_t & ; delta . ). static . ◆ Divide(). TGeoVolume * TGeoCone::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ GetAxisName(). const char * TGeoCone::GetAxisName ; (; Int_t ; iaxis); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetAxisRange(). Double_t TGeoCone::GetAxisRange ; (; Int_t ; iaxis, . Double_t & ; xlo, . Double_t & ; xhi . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ GetBoundingCylinder(). void TGeoCone::GetBoundingCylinder ; (; Double_t * ; param); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ GetBuffer3D(). const TBuffer3D & TGeoCone::GetBuffer3D ; (; Int_t ; reqSections, . Bool_t ; localFrame . ); const. overridevirtual . Stub implementation to avoid forcing implementation at this stage. ; Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ GetByteCount(). Int_t TGeoCone::GetByteCount ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg.; Definition at line 69 of file TGeoCone.h. ◆ GetDz(). virtual Double_t TGeoCone::GetDz ; (; ); const. inlinevirtual . Definition at line 71 of file TGeoCone.h. ◆ GetMakeRuntimeShape(). TGeoShape * TGeoCone::GetMakeRuntimeShape ; (; TGeoShape * ; mother, . TGeoMatrix * ; mat . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ GetMeshNumbers(). void TGeoCone::GetMeshNumbers ; (; Int_t & ; nvert, . Int_t & ; nsegs, . Int_t & ; npols . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ GetNmeshVertices(). Int_t TGeoCone::GetNmeshVertices ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ GetPointsOnSegments(). Bool_t TGeoCone::GetP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCone.html:28988,avoid,avoid,28988,doc/master/classTGeoCone.html,https://root.cern,https://root.cern/doc/master/classTGeoCone.html,1,['avoid'],['avoid']
Safety," Dphi. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the torus. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; Test if point is inside the torus.; check phi range. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each vertex. Double_t Daxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Computes distance to axis of the torus from point pt + t*dir;. Double_t DDaxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Computes derivative w.r.t. t of the distance to axis of the torus from point pt + t*dir;. Double_t DDDaxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Second derivative of distance to torus axis w.r.t t. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the torus. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the torus. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this torus shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; Create a sh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTorus.html:14466,safe,safe,14466,root/html534/TGeoTorus.html,https://root.cern,https://root.cern/root/html534/TGeoTorus.html,3,['safe'],['safe']
Safety," Drawing of 3D implicit functions; 3D implicit functions (TF3) can be drawn the following way:. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",600,400);; TF3 *f3 = new TF3(""f3"",""sin(x*x+y*y+z*z-36)"",-2,2,-2,2,-2,2);; f3->SetClippingBoxOn(0,0,0);; f3->SetFillColor(30);; f3->SetLineColor(15);; f3->Draw(""FBBB"");; return c2;; }; Associated functions drawing; An associated function is created by TH1::Fit. More than on fitted; function can be associated with one histogram (see TH1::Fit).; A TF1 object f1 can be added to the list of associated; functions of an histogram h without calling TH1::Fit; simply doing:. h->GetListOfFunctions()->Add(f1);. or. h->GetListOfFunctions()->Add(f1,someoption);. To retrieve a function by name from this list, do:. TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);. or. TF1 *f1 = h->GetFunction(name);. Associated functions are automatically painted when an histogram is drawn.; To avoid the painting of the associated functions the option HIST; should be added to the list of the options used to paint the histogram.; Drawing using OpenGL; The class TGLHistPainter allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a lego plot. It works also for TH2Poly. ""GLLEGO2; Bins with color levels. ""GLLEGO3; Cylindrical bars. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. ""GLSURF"" ; Draw a surface. ""GLSURF1""; Surface with color levels. ""GLSURF2""; The same as ""GLSURF1"" but without polygon outlines. ""GLSURF3""; Color level",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:68848,avoid,avoid,68848,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,1,['avoid'],['avoid']
Safety," EGeoBoolType TGeoSubtraction::GetBooleanOperator ; (; ); const. inlineoverridevirtual . Implements TGeoBoolNode.; Definition at line 193 of file TGeoBoolNode.h. ◆ GetNpoints(). Int_t TGeoSubtraction::GetNpoints ; (; ). overridevirtual . Returns number of vertices for the composite shape described by this subtraction. ; Implements TGeoBoolNode.; Definition at line 1135 of file TGeoBoolNode.cxx. ◆ IsA(). TClass * TGeoSubtraction::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBoolNode.; Definition at line 203 of file TGeoBoolNode.h. ◆ MakeClone(). TGeoBoolNode * TGeoSubtraction::MakeClone ; (; ); const. overridevirtual . Make a clone of this. Pointers are preserved. ; Implements TGeoBoolNode.; Definition at line 875 of file TGeoBoolNode.cxx. ◆ Paint(). void TGeoSubtraction::Paint ; (; Option_t * ; option). overridevirtual . Paint method. ; Reimplemented from TGeoBoolNode.; Definition at line 883 of file TGeoBoolNode.cxx. ◆ Safety(). Double_t TGeoSubtraction::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Compute safety distance for a union node;. ; Implements TGeoBoolNode.; Definition at line 1177 of file TGeoBoolNode.cxx. ◆ SavePrimitive(). void TGeoSubtraction::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBoolNode.; Definition at line 1201 of file TGeoBoolNode.cxx. ◆ Sizeof3D(). void TGeoSubtraction::Sizeof3D ; (; ); const. overridevirtual . Register 3D size of this shape. ; Reimplemented from TGeoBoolNode.; Definition at line 1220 of file TGeoBoolNode.cxx. ◆ Streamer(). void TGeoSubtraction::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGeoBoolNode. ◆ StreamerNVirtual(). void TGeoSubtraction::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoSubtraction.html:18287,Safe,Safety,18287,doc/master/classTGeoSubtraction.html,https://root.cern,https://root.cern/doc/master/classTGeoSubtraction.html,1,['Safe'],['Safety']
Safety," FillTree(const TMVA::DecisionTree::EventList& eventSample); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void FillEvent(const TMVA::Event& event, TMVA::DecisionTreeNode* node); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = NULL); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = NULL); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = NULL, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__DecisionTree.html:11075,avoid,avoid,11075,root/html534/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html534/TMVA__DecisionTree.html,1,['avoid'],['avoid']
Safety," Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGTableLayout() [1/2]. TGTableLayout::TGTableLayout ; (; const TGTableLayout & ; ). privatedelete . ◆ TGTableLayout() [2/2]. TGTableLayout::TGTableLayout ; (; TGCompositeFrame * ; main, . UInt_t ; nrows, . UInt_t ; ncols, . Bool_t ; homogeneous = kFALSE, . Int_t ; sep = 0, . Int_t ; hints = 0 . ). TGTableLayout constructor. ; Note:; Number of rows first, number of Columns second; homogeneous == true means all table cells are the same size, set by the widest and the highest child frame.; s gives the amount of separation in pixels between cells; h are the hints, see TGTableLayoutHints. . Definition at line 93 of file TGTableLayout.cxx. ◆ ~TGTableLayout(). TGTableLayout::~TGTableLayout ; (; ). override . TGTableLayout constructor. ; Definition at line 110 of file TGTableLayout.cxx. Member Function Documentation. ◆ CheckSanity(). void TGTableLayout::CheckSanity ; (; ). protected . Sanity check various values. ; Definition at line 491 of file TGTableLayout.cxx. ◆ Class(). static TClass * TGTableLayout::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGTableLayout::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGTableLayout::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 112 of file TGTableLayout.h. ◆ DeclFileName(). static const char * TGTableLayout::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 112 of file TGTableLayout.h. ◆ FindRowColSizes(). void TGTableLayout::FindRowColSizes ; (; ). protected . Find the sizes of rows and columns needed to satisfy children's layout policies. ; Definition at line 120 of file TGTableLayout.cxx. ◆ FindRowColSizesHomogeneous(). void TGTableLayout::FindRowColSizesHomogeneous ; (; ). protected . If the table is homogeneous make",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTableLayout.html:14386,Sanity check,Sanity check,14386,doc/master/classTGTableLayout.html,https://root.cern,https://root.cern/doc/master/classTGTableLayout.html,1,['Sanity check'],['Sanity check']
Safety," For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1282/// environment variables in a pathname. If compatibility is not an issue; 1283/// you can use on Unix directly $XXX. The user must delete returned string.; 1284 ; 1285char *TSystem::ExpandPathName(const char *); 1286{; 1287 return nullptr;; 1288}; 1289 ; 1290////////////////////////////////////////////////////////////////////////////////; 1291/// Returns FALSE if one can access a file using the specified access mode.; 1292/// The file name must not contain any special shell characters line ~ or $,; 1293/// in those cases first call ExpandPathName().; 1294/// Attention, bizarre convention of return value!!; 1295 ; 1296Bool_t TSystem::AccessPathName(const char *, EAccessMode); 1297{; 1298 return kFALSE;; 1299}; 1300 ; 1301////////////////////////////////////////////////////////////////////////////////; 1302/// Returns TRUE if the url in 'path' points to the local file system.; 1303/// This is used to avoid going through the NIC card for local operations.; 1304 ; 1305Bool_t TSystem::IsPathLocal(const char *path); 1306{; 1307 Bool_t localPath = kTRUE;; 1308 ; 1309 TUrl url(path);; 1310 if (strlen(url.GetHost()) > 0) {; 1311 // Check locality; 1312 localPath = kFALSE;; 1313 TInetAddress a(gSystem->GetHostByName(url.GetHost()));; 1314 TInetAddress b(gSystem->GetHostByName(gSystem->HostName()));; 1315 if (!strcmp(a.GetHostName(), b.GetHostName()) ||; 1316 !strcmp(a.GetHostAddress(), b.GetHostAddress())) {; 1317 // Host OK; 1318 localPath = kTRUE;; 1319 // Check the user if specified; 1320 if (strlen(url.GetUser()) > 0) {; 1321 UserGroup_t *u = gSystem->GetUserInfo();; 1322 if (u) {; 1323 if (strcmp(u->fUser, url.GetUser())); 1324 // Requested a different user; 1325 localPath = kFALSE;; 1326 delete u;; 1327 }; 1328 }; 1329 }; 1330 }; 1331 // Done; 1332 return localPath;; 1333}; 1334 ; 1335////////////////////////////////////////////////////////////////////////////////; 1336/// Copy a file. If overwrit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:40527,avoid,avoid,40527,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['avoid'],['avoid']
Safety," GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-03-13 19:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLSAViewer.html:27678,timeout,timeout,27678,root/html534/TGLSAViewer.html,https://root.cern,https://root.cern/root/html534/TGLSAViewer.html,2,['timeout'],['timeout']
Safety," GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-02 15:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLSAViewer.html:29963,timeout,timeout,29963,root/html604/TGLSAViewer.html,https://root.cern,https://root.cern/root/html604/TGLSAViewer.html,2,['timeout'],['timeout']
Safety," GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLSAViewer.html:29832,timeout,timeout,29832,root/html602/TGLSAViewer.html,https://root.cern,https://root.cern/root/html602/TGLSAViewer.html,2,['timeout'],['timeout']
Safety," Geometry classes. ; Bridge class for using a VecGeom solid as TGeoShape. ; Definition at line 30 of file TGeoVGShape.h. Public Member Functions;  TGeoVGShape ();  ;  ~TGeoVGShape () override;  Destructor. ;  ; Double_t Capacity () const override;  Returns analytic capacity of the solid. ;  ; void ComputeBBox () override;  Compute bounding box. ;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  Normal computation. ;  ; Bool_t Contains (const Double_t *point) const override;  Test if point is inside this shape. ;  ; Bool_t CouldBeCrossed (const Double_t *point, const Double_t *dir) const override;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Computes distance from point (px,py) to the object. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; TGeoVolume * Divide (TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t) override;  ; void Draw (Option_t *option="""") override;  Draw this shape. ;  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; const char * GetName () const override;  Get the shape n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVGShape.html:1250,safe,safe,1250,doc/master/classTGeoVGShape.html,https://root.cern,https://root.cern/doc/master/classTGeoVGShape.html,2,['safe'],['safe']
Safety," GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize idDefinition TGWin32VirtualXProxy.cxx:94; modeOption_t Option_t TPoint TPoint const char modeDefinition TGWin32VirtualXProxy.cxx:68; TString.h; TSysEvtHandler.h; TTime.h; TObjectMother of all ROOT objects.Definition TObject.h:41; TQObject::Emitvoid Emit(const char *signal, const T &arg)Activate signal with single parameter.Definition TQObject.h:164; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TSysEvtHandlerAbstract base class for handling system events.Definition TSysEvtHandler.h:28; TTimeBasic time type with millisecond precision.Definition TTime.h:27; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::GetAbsTimeTTime GetAbsTime() constDefinition TTimer.h:78; TTimer::TurnOffvirtual void TurnOff()Remove timer from system timer list.Definition TTimer.cxx:231; TTimer::Startvirtual void Start(Long_t milliSec=-1, Bool_t singleShot=kFALSE)Starts the timer with a milliSec timeout.Definition TTimer.cxx:213; TTimer::~TTimervirtual ~TTimer()Definition TTimer.h:71; TTimer::SetTimerIDvoid SetTimerID(UInt_t id=0)Definition TTimer.h:92; TTimer::TurnOnvirtual void TurnOn()Add the timer to the system timer list.Definition TTimer.cxx:243; TTimer::SetCommandvoid SetCommand(const char *command)Set the interpreter command to be executed at time out.Definition TTimer.cxx:176; TTimer::fCommandTString fCommandDefinition TTimer.h:61; TTimer::SetInterruptSyscallsvoid SetInterruptSyscalls(Bool_t set=kTRUE)When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted...Definition TTimer.cxx:199; TTimer::IsAsyncBool_t IsAsync() constDefinition TTimer.h:81; TTimer::GetCommandconst char * GetCommand() constDefinition TTimer.h:74; TTimer::fTimeTTime fTimeDefinition TTimer.h:54; TTimer::GetObjectTObject * GetObject()Definition TTimer.h:75; TTimer::Resetvoid Reset()Reset the timer.Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTimer_8h_source.html:5716,timeout,timeout,5716,doc/master/TTimer_8h_source.html,https://root.cern,https://root.cern/doc/master/TTimer_8h_source.html,1,['timeout'],['timeout']
Safety," Histogram default constructor. ; Definition at line 615 of file TH1.cxx. ◆ TH1() [3/5]. TH1::TH1 ; (; const char * ; name, . const char * ; title, . Int_t ; nbins, . Double_t ; xlow, . Double_t ; xup . ). protected . Constructor for fix bin size histograms. ; Creates the main histogram structure.; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz, the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsnumber of bins ; [in]xlowlow edge of first bin ; [in]xupupper edge of last bin (not included in last bin) . Definition at line 697 of file TH1.cxx. ◆ TH1() [4/5]. TH1::TH1 ; (; const char * ; name, . const char * ; title, . Int_t ; nbins, . const Float_t * ; xbins . ). protected . Constructor for variable bin size histograms using an input array of type float. ; Creates the main histogram structure.; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsnumber of bins ; [in]xbinsarray of low-edges for each bin. This is an array of type float and size nbins+1 . Definition at line 719 of file TH1.cxx. ◆ TH1() [5/5]. TH1::TH1 ; (; const char * ; name, . const char * ; title, . Int_t ; nbins, . const Double_t * ; xbins . ). protected . Constructor for variable bin size histograms using an input array of type double. ; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsnumber of bins ; [in]xbinsarray of low-edges for each bin. This is an array of type double and size nbins+1 . Definition at line 741 of file TH1.cxx. ◆ ~TH1(). TH1::~TH1 ; (; ). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:73014,avoid,avoid,73014,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['avoid'],['avoid']
Safety," IF THIS IS CORRECT! — THIS IS NOT USED — ; Definition at line 925 of file RuleFitParams.cxx. ◆ Penalty(). Double_t TMVA::RuleFitParams::Penalty ; (; ); const. This is the ""lasso"" penalty To be used for regression. ; — NOT USED — ; Definition at line 356 of file RuleFitParams.cxx. ◆ Risk() [1/2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_t ; ind1, . UInt_t ; ind2, . Double_t ; neff . ); const. risk assessment ; Definition at line 314 of file RuleFitParams.cxx. ◆ Risk() [2/2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_t ; ind1, . UInt_t ; ind2, . Double_t ; neff, . UInt_t ; itau . ); const. risk assessment for tau model <itau> ; Definition at line 334 of file RuleFitParams.cxx. ◆ RiskPath(). Double_t TMVA::RuleFitParams::RiskPath ; (; ); const. inline . Definition at line 108 of file RuleFitParams.h. ◆ RiskPerf() [1/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; ); const. inline . Definition at line 109 of file RuleFitParams.h. ◆ RiskPerf() [2/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; UInt_t ; itau); const. inline . Definition at line 110 of file RuleFitParams.h. ◆ RiskPerfTst(). UInt_t TMVA::RuleFitParams::RiskPerfTst ; (; ). Estimates the error rate with the current set of parameters. ; using the <Perf> subsample. Return the tau index giving the lowest error ; Definition at line 1201 of file RuleFitParams.cxx. ◆ SetGDErrScale(). void TMVA::RuleFitParams::SetGDErrScale ; (; Double_t ; s). inline . Definition at line 85 of file RuleFitParams.h. ◆ SetGDNPathSteps(). void TMVA::RuleFitParams::SetGDNPathSteps ; (; Int_t ; np). inline . Definition at line 65 of file RuleFitParams.h. ◆ SetGDPathStep(). void TMVA::RuleFitParams::SetGDPathStep ; (; Double_t ; s). inline . Definition at line 68 of file RuleFitParams.h. ◆ SetGDTau(). void TMVA::RuleFitParams::SetGDTau ; (; Double_t ; t). inline . Definition at line 82 of file RuleFitParams.h. ◆ SetGDTauPrec(). void TMVA::RuleFitParams::SetGDTauPrec ; (; Double_t ; p). inline . Definition at line 86 of file RuleFit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:17165,Risk,RiskPerf,17165,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,1,['Risk'],['RiskPerf']
Safety," IMT flush basketsDefinition TTree.h:160; TTree::SetCacheLearnEntriesvirtual void SetCacheLearnEntries(Int_t n=10)Interface to TTreeCache to set the number of entries for the learning phase.Definition TTree.cxx:8865; TTree::fEntryListTEntryList * fEntryList! Pointer to event selection list (if one)Definition TTree.h:126; TTree::GetTreeIndexvirtual TVirtualIndex * GetTreeIndex() constDefinition TTree.h:558; TTree::fExternalFriendsTList * fExternalFriends! List of TFriendsElement pointing to us and need to be notified of LoadTree. Content not owned.Definition TTree.h:131; TTree::Mergevirtual Long64_t Merge(TCollection *list, Option_t *option="""")Merge the trees in the TList into this tree.Definition TTree.cxx:6890; TTree::SetMaxVirtualSizevirtual void SetMaxVirtualSize(Long64_t size=0)Definition TTree.h:665; TTree::DropBasketsvirtual void DropBaskets()Remove some baskets from memory.Definition TTree.cxx:4518; TTree::SetAutoSavevirtual void SetAutoSave(Long64_t autos=-300000000)In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSa...Definition TTree.cxx:8342; TTree::fMaxEntryLoopLong64_t fMaxEntryLoopMaximum number of entries to process.Definition TTree.h:98; TTree::SetParallelUnzipvirtual void SetParallelUnzip(bool opt=true, Float_t RelSize=-1)Enable or disable parallel unzipping of Tree buffers.Definition TTree.cxx:9291; TTree::SetDirectoryvirtual void SetDirectory(TDirectory *dir)Change the tree's directory.Definition TTree.cxx:8966; TTree::SortBranchesByTimevoid SortBranchesByTime()Sorts top-level branches by the last average task time recorded per branch.Definition TTree.cxx:5834; TTree::Deletevoid Delete(Option_t *option="""") overrideDelete this tree from memory or/and disk.Definition TTree.cxx:3747; TTree::GetBranchRefvirtual TBranchRef * GetBranchRef() constDefinition TTree.h:450; TTree::Processvirtual Long64_t Process(const char *filename, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:447232,recover,recover,447232,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['recover'],['recover']
Safety," Inherited Members; Includes; Libraries. Function documentation; QString SetFileName(const QString& fileName); Set the file pattern. QString GetNewFileName(const QString& fileNamePrototype); Find the filename for the given ""fileNamePrototype"". QPaintDevice * iwid(Window_t wid); Convert ROOT Widget Id to the Qt QPaintDevice pointer. Int_t iwid(QPaintDevice* wid); method to provide the ROOT ""cast"" from (QPaintDevice*) to ROOT windows ""id"". QPaintDevice * iwid(Int_t wid); method to restore (cast) the QPaintDevice object pointer from ROOT windows ""id"". QWidget * winid(Window_t id); returns the top level QWidget for the ROOT widget. Window_t wid(TQtClientWidget* widget). Window_t rootwid(QPaintDevice* dev). QWidget * wid(Window_t id); method to restore (dynamic cast) the QWidget object pointer (if any) from ROOT windows ""id"". void PrintEvent(Event_t& ); Dump trhe ROOT Event_t structure to debug the code. int CoinFlag(); return the Coin/QGL viewer flag safely. void SetCoinFlag(int flag); Set the Coin/QGL viewer flag safely. void SetCoinLoaded(); { fgCoinLoaded = 1; }. Int_t IsCoinLoaded(); { return fgCoinLoaded;}. QString RootFileFormat(const char* selector); { return RootFileFormat(QString(selector)); }. QString RootFileFormat(const QString& selector); Define whether the input string contains any pattern; that matches the ROOT image formats; those Qt library can not provide. QString QtFileFormat(const char* selector); { return QtFileFormat(QString(selector)); }. QString QtFileFormat(const QString& selector); returns Qt file format. if no suitable format found and the selector is empty; the default PNG format is returned. a special treatment of the ""gif"" format.; If ""gif"" is not provided with the local Qt installation; replace ""gif"" format with ""png"" one. TQtApplication * CreateQtApplicationImp(); The method to instantiate the QApplication if needed. void PostQtEvent(QObject* receiver, QEvent* event); Qt announced that QThread::postEvent to become obsolete and; we have to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGQt.html:28011,safe,safely,28011,root/html602/TGQt.html,https://root.cern,https://root.cern/root/html602/TGQt.html,2,['safe'],['safely']
Safety," Int_t *volumeNumbers) const;; 104 void GetBranchOnlys(Int_t *isonly) const;; 105 Int_t GetNmany() const { return fNmany; }; 106 //--- geometry queries; 107 TGeoNode *CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode);; 108 TGeoNode *FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char *path = """", Bool_t frombdr = kFALSE);; 109 TGeoNode *FindNextDaughterBoundary(Double_t *point, Double_t *dir, Int_t &idaughter, Bool_t compmatrix = kFALSE);; 110 TGeoNode *FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE);; 111 TGeoNode *FindNode(Bool_t safe_start = kTRUE);; 112 TGeoNode *FindNode(Double_t x, Double_t y, Double_t z);; 113 Double_t *FindNormal(Bool_t forward = kTRUE);; 114 Double_t *FindNormalFast();; 115 TGeoNode *InitTrack(const Double_t *point, const Double_t *dir);; 116 TGeoNode *InitTrack(Double_t x, Double_t y, Double_t z, Double_t nx, Double_t ny, Double_t nz);; 117 void ResetState();; 118 void ResetAll();; 119 Double_t Safety(Bool_t inside = kFALSE);; 120 TGeoNode *SearchNode(Bool_t downwards = kFALSE, const TGeoNode *skipnode = nullptr);; 121 TGeoNode *Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE);; 122 const Double_t *GetLastPoint() const { return fLastPoint; }; 123 Int_t GetVirtualLevel();; 124 Bool_t GotoSafeLevel();; 125 Int_t GetSafeLevel() const;; 126 Double_t GetSafeDistance() const { return fSafety; }; 127 Double_t GetLastSafety() const { return fLastSafety; }; 128 Double_t GetStep() const { return fStep; }; 129 Int_t GetThreadId() const { return fThreadId; }; 130 void InspectState() const;; 131 Bool_t IsSafeStep(Double_t proposed, Double_t &newsafety) const;; 132 Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE);; 133 Bool_t IsSameLocation() const { return fIsSameLocation; }; 134 Bool_t IsSamePoint(Double_t x, Double_t y, Double_t z) const;; 135 Bool_t IsStartSafe() const { return fStartSafe; }; 136 void SetStartSafe(Bool_t flag = kTRUE) { fStartSafe = flag;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:5972,Safe,Safety,5972,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['Safe'],['Safety']
Safety," Int_t DirReadKeys(TDirectory*) { return 0; }; 169 virtual void DirWriteKeys(TDirectory*) {}; 170 virtual void DirWriteHeader(TDirectory*) {}; 171 ; 172private:; 173 TFile(const TFile &) = delete; //Files cannot be copied; 174 void operator=(const TFile &) = delete;; 175 ; 176 static void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch &watch);; 177 static TFile *OpenFromCache(const char *name, Option_t * = """",; 178 const char *ftitle = """", Int_t compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault,; 179 Int_t netopt = 0);; 180 ; 181public:; 182 /// TFile status bits. BIT(13) is taken up by TObject; 183 enum EStatusBits {; 184 // Produce files forward compatible with (unpatched) version older than; 185 // v6.30 by recording the internal bits kIsOnHeap and kNotDeleted; Older; 186 // releases were not explicitly setting those bits to the correct value; 187 // but instead used verbatim the value stored in the file.; 188 // Note that to avoid a circular dependency, this value is used; 189 // hard coded in TObject.cxx.; 190 k630forwardCompatibility = BIT(2),; 191 kRecovered = BIT(10),; 192 kHasReferences = BIT(11),; 193 kDevNull = BIT(12),; 194 kWriteError = BIT(14),; 195 kBinaryFile = BIT(15),; 196 kRedirected = BIT(16),; 197 kReproducible = BIT(17); 198 };; 199 enum ERelativeTo { kBeg = 0, kCur = 1, kEnd = 2 };; 200 enum { kStartBigFile = 2000000000 };; 201 /// File type; 202 enum EFileType { kDefault = 0, kLocal = 1, kNet = 2, kWeb = 3, kFile = 4, kMerge = 5 };; 203 ; 204 TFile();; 205 TFile(const char *fname, Option_t *option="""", const char *ftitle="""", Int_t compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);; 206 ~TFile() override;; 207 ; 208 void Close(Option_t *option="""") override; // *MENU*; 209 void Copy(TObject &) const override { MayNotUse(""Copy(TObject &)""); }; 210 virtual Bool_t Cp(const char *dst, Bool_t progressbar = kTRUE,UInt_t buffersize = 1000000);; 211 virtual TKey* CreateKey(TDirectory* mother, const TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:9005,avoid,avoid,9005,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['avoid'],['avoid']
Safety," Int_t TGeoParaboloid::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TGeoBBox. ◆ DistFromInside(). Double_t TGeoParaboloid::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromInside_v(). void TGeoParaboloid::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside(). Double_t TGeoParaboloid::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistFromOutside_v(). void TGeoParaboloid::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistToParaboloid(). Double_t TGeoParaboloid::DistToParaboloid ; (; const Double_t * ; point, . const Double_t * ; dir, . Bool_t ; in . ); const. ◆ Divide(). TGeoVolume * TGeoParaboloid::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimplemented from TGeoBBox. ◆ GetBoundingCylinder(). void TGeoParaboloid::GetBoundingCylinder ; (; Double_t * ; param); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetBuffer3D(). const TBuffer3D & TGeoParaboloid::GetBuffer3D ; (; Int_t ; reqSections, . Bool_t ; localFrame . ); const. overridevirtual . Stub implementation to avoi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParaboloid.html:25506,safe,safe,25506,doc/master/classTGeoParaboloid.html,https://root.cern,https://root.cern/doc/master/classTGeoParaboloid.html,1,['safe'],['safe']
Safety," Int_t TotalConts = conts->GetSize();; ; printf(""TotalConts = %d\n"", TotalConts);; ; for(i = 0; i < TotalConts; i++){; contLevel = (TList*)conts->At(i);; printf(""Contour %d has %d Graphs\n"", i, contLevel->GetSize());; nGraphs += contLevel->GetSize();; }; ; nGraphs = 0;; ; TCanvas* c1 = new TCanvas(""c1"",""Contour List"",610,0,600,600);; c1->SetTopMargin(0.15);; TH2F *hr = new TH2F(""hr"",; ""#splitline{Negative contours are returned first (highest to lowest). Positive contours are returned from}{lowest to highest. On this plot Negative contours are drawn in red and positive contours in blue.}"",; 2, -2, 2, 2, 0, 6.5);; ; hr->Draw();; Double_t xval0, yval0, zval0;; TLatex l;; l.SetTextSize(0.03);; char val[20];; ; for(i = 0; i < TotalConts; i++){; contLevel = (TList*)conts->At(i);; if (i<3) zval0 = contours[2-i];; else zval0 = contours[i];; printf(""Z-Level Passed in as: Z = %f\n"", zval0);; ; // Get first graph from list on curves on this level; curv = (TGraph*)contLevel->First();; for(j = 0; j < contLevel->GetSize(); j++){; curv->GetPoint(0, xval0, yval0);; if (zval0<0) curv->SetLineColor(kRed);; if (zval0>0) curv->SetLineColor(kBlue);; nGraphs ++;; printf(""\tGraph: %d -- %d Elements\n"", nGraphs,curv->GetN());; ; // Draw clones of the graphs to avoid deletions in case the 1st; // pad is redrawn.; gc = (TGraph*)curv->Clone();; gc->Draw(""C"");; ; sprintf(val,""%g"",zval0);; l.DrawLatex(xval0,yval0,val);; curv = (TGraph*)contLevel->After(curv); // Get Next graph; }; }; c1->Update();; printf(""\n\n\tExtracted %d Contours and %d Graphs \n"", TotalConts, nGraphs );; gStyle->SetTitleW(0.);; gStyle->SetTitleH(0.);; return c1;; }; ; ; Double_t SawTooth(Double_t x, Double_t WaveLen){; ; // This function is specific to a sawtooth function with period; // WaveLen, symmetric about x = 0, and with amplitude = 1. Each segment; // is 1/4 of the wavelength.; //; // |; // /\ |; // / \ |; // / \ |; // / \; // /--------\--------/------------; // |\ /; // | \ /; // | \ /; // | \/; //; ; Double_t y;; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:84147,avoid,avoid,84147,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,2,['avoid'],['avoid']
Safety," Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these has to be computed; in order to fit the mother. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = theta; param[2] = phi; param[3] = h1; param[4] = bl1; param[5] = tl1; param[6] = alpha1; param[7] = h2; param[8] = bl2; param[9] = tl2; param[10] = alpha2; param[11] = twist. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoArb8& operator=(const TGeoGtra& ). TGeoGtra(); constructors. Double_t GetTwistAngle() const; {return fTwistAngle;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 16:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoGtra.html:19310,safe,safe,19310,root/html604/TGeoGtra.html,https://root.cern,https://root.cern/root/html604/TGeoGtra.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety," Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these has to be computed; in order to fit the mother. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = theta; param[2] = phi; param[3] = h1; param[4] = bl1; param[5] = tl1; param[6] = alpha1; param[7] = h2; param[8] = bl2; param[9] = tl2; param[10] = alpha2; param[11] = twist. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoArb8& operator=(const TGeoGtra& ). TGeoGtra(); constructors. Double_t GetTwistAngle() const; {return fTwistAngle;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoGtra.html:19310,safe,safe,19310,root/html602/TGeoGtra.html,https://root.cern,https://root.cern/root/html602/TGeoGtra.html,3,"['Safe', 'safe']","['Safety', 'safe']"
Safety," Int_t len);  ; Long64_t DavixReadBuffers (Davix_fd *fd, char *buf, Long64_t *pos, Int_t *len, Int_t nbuf);  ; Int_t DavixStat (struct stat *st) const;  ; Long64_t DavixWriteBuffer (Davix_fd *fd, const char *buf, Int_t len);  ; Double_t eventStart ();  ; void eventStop (Double_t t, Long64_t len, bool read=true);  set TFile state info ;  ; void Init (Bool_t init);  Initialize a TFile object. ;  . Private Attributes; TDavixFileInternal * d_ptr;  . Additional Inherited Members;  Public Types inherited from TFile; enum  { kStartBigFile = 2000000000; };  ; enum  EAsyncOpenStatus { kAOSNotAsync = -1; , kAOSFailure = 0; , kAOSInProgress = 1; , kAOSSuccess = 2; };  Asynchronous open request status. More...;  ; enum  ECacheAction { kDisconnect = 0; , kDoNotDisconnect = 1; };  TTreeCache flushing semantics. More...;  ; enum  EFileType { ;   kDefault = 0; , kLocal = 1; , kNet = 2; , kWeb = 3; , ;   kFile = 4; , kMerge = 5. };  File type. More...;  ; enum  EOpenTimeOut { kInstantTimeout = 0; , kEternalTimeout = 999999999; };  Open timeout constants. More...;  ; enum  ERelativeTo { kBeg = 0; , kCur = 1; , kEnd = 2; };  ; enum  EStatusBits { ;   k630forwardCompatibility = (1ULL << ( 2 )); , kRecovered = (1ULL << ( 10 )); , kHasReferences = (1ULL << ( 11 )); , kDevNull = (1ULL << ( 12 )); , ;   kWriteError = (1ULL << ( 14 )); , kBinaryFile = (1ULL << ( 15 )); , kRedirected = (1ULL << ( 16 )); , kReproducible = (1ULL << ( 17 )). };  TFile status bits. BIT(13) is taken up by TObject. More...;  ;  Public Types inherited from TDirectoryFile; enum  EStatusBits { kCloseDirectory = (1ULL << ( 7 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixFile.html:30482,timeout,timeout,30482,doc/master/classTDavixFile.html,https://root.cern,https://root.cern/doc/master/classTDavixFile.html,1,['timeout'],['timeout']
Safety," Int_t loglevel, const char *alias=0);  Start the PROOF environment. ;  ; TProofQueryResult * MakeQueryResult (Long64_t nent, const char *opt, Long64_t fst, TDSet *dset, const char *selec);  Create a TProofQueryResult instance for this query. ;  ; Int_t PollForNewWorkers () override;  Simulate dynamic addition, for test purposes. ;  ; void SetQueryRunning (TProofQueryResult *pq);  Set query in running state. ;  ; Int_t SetupWorkers (Int_t opt=0, TList *wrks=0);  Start up PROOF workers. ;  ;  Protected Member Functions inherited from TProof;  TProof ();  Protected constructor to be used by classes deriving from TProof (they have to call Init themselves and override StartSlaves appropriately). ;  ; Int_t AddWorkers (TList *wrks);  Works on the master node only. ;  ; Int_t AssertPath (const char *path, Bool_t writable);  Make sure that 'path' exists; if 'writable' is kTRUE, make also sure that the path is writable. ;  ; Int_t Collect (ESlaves list=kActive, Long_t timeout=-1, Int_t endtype=-1, Bool_t deactonfail=kFALSE);  Collect responses from the slave servers. ;  ; Int_t Collect (TList *slaves, Long_t timeout=-1, Int_t endtype=-1, Bool_t deactonfail=kFALSE);  Collect responses from the slave servers. ;  ; TSlave * CreateSlave (const char *url, const char *ord, Int_t perf, const char *image, const char *workdir);  Create a new TSlave of type TSlave::kSlave. ;  ; TSlave * CreateSubmaster (const char *url, const char *ord, const char *image, const char *msd, Int_t nwk=1);  Create a new TSlave of type TSlave::kMaster. ;  ; TList * GetEnabledPackages () const;  ; TList * GetListOfActiveSlaves () const;  ; TVirtualProofPlayer * GetPlayer () const;  ; TPluginHandler * GetProgressDialog () const;  ; Int_t GetSandbox (TString &sb, Bool_t assert=kFALSE, const char *rc=0);  Set the sandbox path from ' Proof.Sandbox' or the alternative var 'rc'. ;  ; void HandleLibIncPath (const char *what, Bool_t add, const char *dirs);  Handle lib, inc search paths modification request. ;  ; I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:36429,timeout,timeout,36429,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['timeout'],['timeout']
Safety," Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query information frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update query information (header) text view. TGTab * GetTab() const; { return fTab; }. TCanvas * GetStatsCanvas() const; { return fStatsCanvas; }. TEditQueryFrame * GetQueryEditFrame() const; { return fFD; }. void Progress(Long64_t total, Long64_t processed). » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-03-14 16:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSessionQueryFrame.html:22239,Abort,Abort,22239,root/html534/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html534/TSessionQueryFrame.html,1,['Abort'],['Abort']
Safety," Int_t, const T &... params);  Emit a signal with a varying number of arguments. ;  ; TList * GetListOfClassSignals () const;  Returns pointer to list of signals of this class. ;  ; TList * GetListOfConnections () const;  ; TList * GetListOfSignals () const;  ; virtual Bool_t HasConnection (const char *signal_name) const;  Return true if there is any object connected to this signal. ;  ; virtual void HighPriority (const char *signal_name, const char *slot_name=nullptr);  ; virtual void LowPriority (const char *signal_name, const char *slot_name=nullptr);  ; virtual void Message (const char *msg);  ; virtual Int_t NumberOfConnections () const;  Return number of connections for this object. ;  ; virtual Int_t NumberOfSignals () const;  Return number of signals for this object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void SetMenuHidingTimeout (Long_t timeout);  Set global timeout for menu-hiding in mili-seconds. ;  ;  Static Public Member Functions inherited from TGLViewer; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TGLColorSet & GetDefaultColorSet ();  Returns reference to the default color-set. ;  ; static Bool_t IsUsingDefaultColorSetForNewViewers ();  Returns the value of the static flag that determines if new viewers should use the default color-set. ;  ; static void SetAxisLabelScale (Float_t als);  Sets static scaling facor that allows simple guide axies to have label values scaled relative to actual scene dimensions. ;  ; static void UseDefaultColorSetForNewViewers (Bool_t x);  Sets static flag that determines if new viewers should use the default color-set. ;  ;  Static Public Member Functions inherited from TVirtualViewer3D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLSAViewer.html:28794,timeout,timeout,28794,doc/master/classTGLSAViewer.html,https://root.cern,https://root.cern/doc/master/classTGLSAViewer.html,2,['timeout'],['timeout']
Safety," Int_tTSystem::RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*TSystem::RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*TSystem::RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*TSystem::RemoveTimer(TTimer* t); virtual intTSystem::Rename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidTSystem::ResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidTSystem::ResetTimer(TTimer*); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tTSystem::Select(TList* active, Long_t timeout); virtual Int_tTSystem::Select(TFileHandler* fh, Long_t timeout); virtual intTSystem::SendBuf(int sock, const void* buffer, int length); virtual intTSystem::SendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidTSystem::SetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTSystem::SetDynamicPath(const char* pathname); virtual voidTSystem::Setenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tTSystem::SetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDCacheSystem.html:11366,timeout,timeout,11366,root/html528/TDCacheSystem.html,https://root.cern,https://root.cern/root/html528/TDCacheSystem.html,4,['timeout'],['timeout']
Safety," Int_tTSystem::RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*TSystem::RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*TSystem::RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*TSystem::RemoveTimer(TTimer* t); virtual intTSystem::Rename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidTSystem::ResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidTSystem::ResetTimer(TTimer*); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tTSystem::Select(TList* active, Long_t timeout); virtual Int_tTSystem::Select(TFileHandler* fh, Long_t timeout); virtual intTSystem::SendBuf(int sock, const void* buffer, int length); virtual intTSystem::SendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char*); virtual voidTSystem::SetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTSystem::SetDynamicPath(const char* pathname); virtual voidTSystem::Setenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tTSystem::SetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs(const char* linkedLibs); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TDCacheSystem.html:11316,timeout,timeout,11316,root/html526/TDCacheSystem.html,https://root.cern,https://root.cern/root/html526/TDCacheSystem.html,1,['timeout'],['timeout']
Safety," Internal back-end function to create a chi^2 from a function and a dataset. RooFitResult* chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); Internal driver function for chi2 fits. void setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); Set evaluation error logging mode. Options are. PrintErrors - Print each error through RooMsgService() as it occurs; CollectErrors - Accumulate errors, but do not print them. A subsequent call; to printEvalErrors() will print a summary; CountErrors - Accumulate error count, but do not print them. void setParameterizeIntegral(const RooArgSet& paramVars). Double_t getVal(const RooArgSet* set = 0) const; Return value and unit accessors. Double_t getVal(const RooArgSet& set) const; { return _fast ? _value : getValV(&set) ; }. const Text_t * getUnit() const; Return string with unit description. void setUnit(const char* unit); Set unit description to given string. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Interface to force RooRealIntegral to offer given observable for internal integration; even if this is deemed unsafe. This default implementation returns always flase. void forceNumInt(Bool_t flag = kTRUE); If flag is true, all advertised analytical integrals will be ignored; and all integrals are calculated numerically. Bool_t getForceNumInt() const; { return _forceNumInt ; }. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create integral over observables in iset in range named rangeName. return createIntegral(iset,0,0,rangeName). RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet& nset, const char* rangeName = 0) const; Create integral over observables in iset in range nam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsReal.html:82052,unsafe,unsafe,82052,root/html534/RooAbsReal.html,https://root.cern,https://root.cern/root/html534/RooAbsReal.html,3,['unsafe'],['unsafe']
Safety," L: matrix of regularisation conditions (dimension nl x nx); x0: bias distribution. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. and chi**2 is minimized; (a) not constrained: minimisation is performed a function of x for fixed lambda=0; or; (b) constrained: minimisation is performed a function of x and lambda. This applies to a very large number of problems, where the measured; distribution y is a linear superposition of several Monte Carlo shapes; and the sum of these shapes gives the output distribution x. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documentation is available here:; http://www.desy.de/~sschmitt. References:. A nice overview of the method is given in:; The L-curve and Its Use in the Numerical Treatment of Inverse Problems; (2000) by P. C. Hansen, in Computational Inverse Problems in; Electrocardiology, ed. P. Johnston,; Advances in Computational Bioengineering; http://www.imm.dtu.dk/~pch/TR/Lcurve.ps; The relevant equations are (1), (2) for the unfolding; and (14) for the L-curve curvature definition. Related literature on unfolding:; The program package RUN and the web-page by V.Blobel; http://www.desy.de/~blobel/unfold.html; Talk by V. Blobel, Terascale Statistics school; https://indico.desy.de/contributionDisplay.py?contribId=23&confId=1149; References quoted in Blobel's talk:; Per Chistian Hansen, Rank-Deficient and D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfold.html:1684,detect,detector,1684,root/html528/TUnfold.html,https://root.cern,https://root.cern/root/html528/TUnfold.html,3,['detect'],['detector']
Safety," Layer_t * GetLayerAt (size_t i) const;  ; std::vector< Layer_t * > & GetLayers ();  ; const std::vector< Layer_t * > & GetLayers () const;  ; ELossFunction GetLossFunction () const;  ; size_t GetOutputWidth () const;  ; ERegularization GetRegularization () const;  ; Scalar_t GetWeightDecay () const;  ; void Initialize ();  DAE functions. ;  ; bool IsTraining () const;  ; Scalar_t Loss (const Matrix_t &groundTruth, const Matrix_t &weights, bool includeRegularization=true) const;  Function for evaluating the loss, based on the activations stored in the last layer. ;  ; Scalar_t Loss (Tensor_t &input, const Matrix_t &groundTruth, const Matrix_t &weights, bool inTraining=false, bool includeRegularization=true);  Function for evaluating the loss, based on the propagation of the given input. ;  ; void Prediction (Matrix_t &predictions, EOutputFunction f) const;  Prediction based on activations stored in the last layer. ;  ; void Prediction (Matrix_t &predictions, Tensor_t &input, EOutputFunction f);  Prediction for the given inputs, based on what network learned. ;  ; void Print () const;  Print the Deep Net Info. ;  ; Scalar_t RegularizationTerm () const;  Function for computing the regularizaton term to be added to the loss function .  ; void ResetTraining ();  Function that reset some training flags after looping all the events but not the weights. ;  ; void SetBatchDepth (size_t batchDepth);  ; void SetBatchHeight (size_t batchHeight);  ; void SetBatchSize (size_t batchSize);  Setters. ;  ; void SetBatchWidth (size_t batchWidth);  ; void SetDropoutProbabilities (const std::vector< Double_t > &probabilities);  ; void SetInitialization (EInitialization I);  ; void SetInputDepth (size_t inputDepth);  ; void SetInputHeight (size_t inputHeight);  ; void SetInputWidth (size_t inputWidth);  ; void SetLossFunction (ELossFunction J);  ; void SetRegularization (ERegularization R);  ; void SetWeightDecay (Scalar_t weightDecay);  ; void Update (Scalar_t learningRate);  Function t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDeepNet.html:6597,Predict,Prediction,6597,doc/master/classTMVA_1_1DNN_1_1TDeepNet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDeepNet.html,3,"['Predict', 'predict']","['Prediction', 'predictions']"
Safety," Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMPAINTER; » TGeoChecker. class TGeoChecker: public TObject. TGeoChecker - Geometry checking package. TGeoChecker class provides several geometry checking methods. There are two; types of tests that can be performed. One is based on random sampling or; ray-tracing and provides a visual check on how navigation methods work for; a given geometry. The second actually checks the validity of the geometry; definition in terms of overlapping/extruding objects. Both types of checks; can be done for a given branch (starting with a given volume) as well as for; the geometry as a whole. 1. TGeoChecker::CheckPoint(Double_t x, Double_t y, Double_t z). This method can be called direcly from the TGeoManager class and print a; report on how a given point is classified by the modeller: which is the; full path to the deepest node containing it, and the (under)estimation; of the distance to the closest boundary (safety). 2. TGeoChecker::RandomPoints(Int_t npoints). Can be called from TGeoVolume class. It first draws the volume and its; content with the current visualization settings. Then randomly samples points; in its bounding box, plotting in the geometry display only the points; classified as belonging to visible volumes. 3. TGeoChecker::RandomRays(Int_t nrays, Double_t startx, starty, startz). Can be called and acts in the same way as the previous, but instead of points,; rays having random isotropic directions are generated from the given point.; A raytracing algorithm propagates all rays untill they exit geometry, plotting; all segments crossing visible nodes in the same color as these. 4. TGeoChecker::Test(Int_t npoints). Implementation of TGeoManager::Test(). Computes the time for the modeller; to find out ""Where am I?"" for a given number of random points. 5. T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoChecker.html:1147,safe,safety,1147,root/html528/TGeoChecker.html,https://root.cern,https://root.cern/root/html528/TGeoChecker.html,6,['safe'],['safety']
Safety," Matches. TGeoPhysicalNode.cxx. Go to the documentation of this file. 1// @(#)root/geom:$Id$; 2// Author: Andrei Gheata 17/02/04; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TGeoPhysicalNode; 13\ingroup Geometry_classes; 14 ; 15Physical nodes are the actual 'touchable' objects in the geometry, representing; 16a path of positioned volumes starting with the top node:; 17 path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes.; 18 ; 19The number of physical nodes is given by the total number of possible of; 20branches in the geometry hierarchy. In case of detector geometries and; 21specially for calorimeters this number can be of the order 1e6-1e9, therefore; 22it is impossible to create all physical nodes as objects in memory. In TGeo,; 23physical nodes are represented by the class TGeoPhysicalNode and can be created; 24on demand for alignment purposes:; 25 ; 26~~~ {.cpp}; 27 TGeoPhysicalNode *pn = new TGeoPhysicalNode(""path_to_object""); 28~~~; 29 ; 30Once created, a physical node can be misaligned, meaning that its position; 31or even shape can be changed:; 32 ; 33~~~ {.cpp}; 34 pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE); 35~~~; 36*/; 37 ; 38/** \class TGeoPNEntry; 39\ingroup Geometry_classes; 40 ; 41The knowledge of the path to the objects that need to be misaligned is; 42essential since there is no other way of identifying them. One can however; 43create 'symbolic links' to any complex path to make it more representable; 44for the object it designates:; 45 ; 46~~~ {.cpp}; 47 TGeoPNEntry *pne = new TGeoPNEntry(""TPC_SECTOR_2"", ""path_to_tpc_sect2"");; 48 pne->SetPhysicalNode(pn); 49~~~; 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:1046,detect,detector,1046,doc/master/TGeoPhysicalNode_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html,1,['detect'],['detector']
Safety," NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. void ls(Option_t* option = """") const; List histograms in the stack. Long64_t Merge(TCollection* li, TFileMergeInfo* info); Merge the THStack in the TList into this stack.; Returns the total number of histograms in the result or -1 in case of an error. void Modified(); invalidate sum of histograms. void Paint(Option_t* chopt = """"); paint the list of histograms; By default, histograms are shown stacked.; -the first histogram is paint; -then the sum of the first and second, etc. If option ""nostack"" is specified, histograms are all paint in the same pad; as if the option ""same"" had been specified. if option ""pads"" is specified, the current pad/canvas is subdivided into; a number of pads equal to the number of histograms and each histogram; is paint into a separate pad. By default the background of the histograms is erased before drawing the; histograms. The option ""noclear"" avoid this behaviour. This is useful; when drawing a THStack on top of an other plot. If the patterns used to; draw the histograms in the stack are transparents, then the plot behind; will be visible. See THistPainter::Paint for a list of valid options. void Print(Option_t* chopt = """") const; Print the list of histograms. void RecursiveRemove(TObject* obj); Recursively remove object from the list of histograms. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetMaximum(Double_t maximum = -1111); Set maximum. void SetMinimum(Double_t minimum = -1111); Set minimum. THStack& operator=(const THStack& ). TList * GetHists() const; { return fHists; }. void SetHistogram(TH1* h); {fHistogram = h;}. » Author: Rene Brun 10/12/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-03-14 16:41; This page has been automatically generated. For comments or suggestio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THStack.html:11771,avoid,avoid,11771,root/html534/THStack.html,https://root.cern,https://root.cern/root/html534/THStack.html,1,['avoid'],['avoid']
Safety," NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. void ls(Option_t* option = """") const; List histograms in the stack. Long64_t Merge(TCollection* li, TFileMergeInfo* info); Merge the THStack in the TList into this stack.; Returns the total number of histograms in the result or -1 in case of an error. void Modified(); invalidate sum of histograms. void Paint(Option_t* chopt = """"); paint the list of histograms; By default, histograms are shown stacked.; -the first histogram is paint; -then the sum of the first and second, etc. If option ""nostack"" is specified, histograms are all paint in the same pad; as if the option ""same"" had been specified. if option ""pads"" is specified, the current pad/canvas is subdivided into; a number of pads equal to the number of histograms and each histogram; is paint into a separate pad. By default the background of the histograms is erased before drawing the; histograms. The option ""noclear"" avoid this behaviour. This is useful; when drawing a THStack on top of an other plot. If the patterns used to; draw the histograms in the stack are transparents, then the plot behind; will be visible. See THistPainter::Paint for a list of valid options. void Print(Option_t* chopt = """") const; Print the list of histograms. void RecursiveRemove(TObject* obj); Recursively remove object from the list of histograms. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetMaximum(Double_t maximum = -1111); Set maximum. void SetMinimum(Double_t minimum = -1111); Set minimum. THStack& operator=(const THStack& ). TList * GetHists() const; { return fHists; }. void SetHistogram(TH1* h); {fHistogram = h;}. » Author: Rene Brun 10/12/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-30 15:09; This page has been automatically generated. For comments or suggestio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THStack.html:12496,avoid,avoid,12496,root/html602/THStack.html,https://root.cern,https://root.cern/root/html602/THStack.html,1,['avoid'],['avoid']
Safety," NUM_LS = 8;; TCanvas *c1 = new TCanvas(""c1"", ""moving charge"", 900, 400);; TCanvas *c2 = new TCanvas(""c2"", ""Merge Individual moving charge plots"", 800, 400);; ; c1->Divide(NUM_LS, 3);; c2->Divide(3,1);; ; // -------------------- Construct Reference plot bins ------------------------; auto new_avg = new TProfile2Poly();; ; auto tot_avg_ls = new TProfile2Poly[NUM_LS];; auto det_avg_ls = new TProfile2Poly[NUM_LS];; auto det_err_ls = new TProfile2Poly[NUM_LS];; auto tot_merge = new TProfile2Poly();; auto det_avg_merge = new TProfile2Poly();; auto det_err_merge = new TProfile2Poly();; ; float minx = -15;; float maxx = 15;; float miny = -15;; float maxy = 15;; float binsz = 0.5;; ; for (float i = minx; i < maxx; i += binsz) {; for (float j = miny; j < maxy; j += binsz) {; tot_merge->AddBin(i, j, i + binsz, j + binsz);; for (int l = 0; l < NUM_LS; ++l) {; tot_avg_ls[l].AddBin(i, j, i + binsz, j + binsz);; }; }; }; ; // -------------------- Construct detector bins ------------------------; auto h2p = new TH2Poly();; auto tp2p = new TProfile2Poly();; std::ifstream infile;; TString dir = gROOT->GetTutorialDir();; dir.Append(""/hist/data/tprofile2poly_tutorial.data"");; infile.open(dir.Data());; ; if (!infile) // Verify that the file was open successfully; {; std::cerr << dir.Data() << std::endl; // Report error; std::cerr << ""Error code: "" << std::strerror(errno) << std::endl; // Get some info as to why; return;; }; std::cout << "" WE ARE AFTER LOADING DATA "" << std::endl;; ; std::vector<std::pair<Double_t, Double_t>> allCoords;; Double_t a, b;; while (infile >> a >> b) ; allCoords.emplace_back(a, b);; ; if (allCoords.size() % 3 != 0) {; cout << ""[ERROR] Bad file"" << endl;; return;; }; ; Double_t x[3], y[3];; for (int i = 0; i < allCoords.size(); i += 3) {; x[0] = allCoords[i + 0].first;; y[0] = allCoords[i + 0].second;; x[1] = allCoords[i + 1].first;; y[1] = allCoords[i + 1].second;; x[2] = allCoords[i + 2].first;; y[2] = allCoords[i + 2].second;; ; det_avg_merge->AddBin(3, x, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tprofile2polyRealistic_8C.html:1458,detect,detector,1458,doc/master/tprofile2polyRealistic_8C.html,https://root.cern,https://root.cern/doc/master/tprofile2polyRealistic_8C.html,1,['detect'],['detector']
Safety," One can get a picture on which are the most ""burned"" volumes during transportation from geometry point of view. Another plot of the timing per volume vs. number of daughters is produced.; All histos are saved in the file statistics.root ; Definition at line 503 of file TGeoChecker.cxx. ◆ CheckOverlaps(). void TGeoChecker::CheckOverlaps ; (; const TGeoVolume * ; vol, . Double_t ; ovlp = 0.1, . Option_t * ; option = """" . ). Check illegal overlaps for volume VOL within a limit OVLP. ; Definition at line 1427 of file TGeoChecker.cxx. ◆ CheckOverlapsBySampling(). void TGeoChecker::CheckOverlapsBySampling ; (; TGeoVolume * ; vol, . Double_t ; ovlp = 0.1, . Int_t ; npoints = 1000000 . ); const. Check illegal overlaps for volume VOL within a limit OVLP by sampling npoints inside the volume shape. ; Definition at line 1196 of file TGeoChecker.cxx. ◆ CheckPoint(). void TGeoChecker::CheckPoint ; (; Double_t ; x = 0, . Double_t ; y = 0, . Double_t ; z = 0, . Option_t * ; option = """", . Double_t ; safety = 0. . ). Draw point (x,y,z) over the picture of the daughters of the volume containing this point. ; Generates a report regarding the path to the node containing this point and the distance to the closest boundary. ; Definition at line 1692 of file TGeoChecker.cxx. ◆ CheckShape(). void TGeoChecker::CheckShape ; (; TGeoShape * ; shape, . Int_t ; testNo, . Int_t ; nsamples, . Option_t * ; option . ). Test for shape navigation methods. ; Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate directions randomly in cos(theta). Compute DistFromInside and move the point with bigger distance. Compute DistFromOutside back from new point. Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate directions randomly in cos(theta) and compute distance to boundary. Check if distance to boundary is bigger than safety . Definition at line 1752 of file TGeoChecker.cxx. ◆ CheckVoxels(). Double_t TGeoChecker::CheckVoxe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoChecker.html:21081,safe,safety,21081,doc/master/classTGeoChecker.html,https://root.cern,https://root.cern/doc/master/classTGeoChecker.html,1,['safe'],['safety']
Safety," Option_t *option="""", TString *prefix=nullptr);  Resolve the file type as a function of the protocol field in 'name'. ;  ; static void IncrementFileCounter ();  ; static TFile * Open (const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0);  Create / open a file. ;  ; static TFile * Open (TFileOpenHandle *handle);  Waits for the completion of an asynchronous open request. ;  ; static Bool_t SetCacheFileDir (std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE);  Sets the directory where to locally stage/cache remote files. ;  ; static void SetFileBytesRead (Long64_t bytes=0);  ; static void SetFileBytesWritten (Long64_t bytes=0);  ; static void SetFileReadCalls (Int_t readcalls=0);  ; static Bool_t SetOnlyStaged (Bool_t onlystaged);  Sets only staged flag. ;  ; static UInt_t SetOpenTimeout (UInt_t timeout);  Sets open timeout time (in ms). Returns previous timeout value. ;  ; static void SetReadaheadSize (Int_t bufsize=256000);  ; static void SetReadStreamerInfo (Bool_t readinfo=kTRUE);  Specify if the streamerinfos must be read at file opening. ;  ; static Bool_t ShrinkCacheFileDir (Long64_t shrinkSize, Long_t cleanupInteval=0);  Try to shrink the cache to the desired size. ;  ;  Static Public Member Functions inherited from TDirectoryFile; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TDirectory; static void AddDirectory (Bool_t add=kTRUE);  Sets the flag controlling the automatic add objects like histograms, TGraph2D, etc in memory. ;  ; static Bool_t AddDirectoryStatus ();  Static function: see TDirectory::AddDirectory for more comments. ;  ; static Bool_t Cd (const char *path);  Change current directory to ""path"". ;  ; static TClass * Class ();  ; static const char * Class_Name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMemFile.html:30154,timeout,timeout,30154,doc/master/classTMemFile.html,https://root.cern,https://root.cern/doc/master/classTMemFile.html,15,['timeout'],['timeout']
Safety," PATH now fixed ROOT-7715; Fix builtin_xrootd option that was not working for XROOTD version 4.2.2.; Option gnuinstall also sets RPATH in librries and executables in installation directory; Various fixes for MacOS X 10.11 ROOT-7680. Core. Fix thread safety of the creation of TMethodCall from a TFunction.; Fix dictionary generation of STL collection involving one of ROOT’s core classes when the user header contains only a forward declaration of the class [ROOT-7695]. Bugs. [ROOT-7680] - Can’t build v6-02-12 on MacOS X 10.11; [ROOT-7695] - Segmentation violation in rootcint; [ROOT-7709] - PyROOT not functional with system-default Python version on MacOS X 10.11; [ROOT-7715] - Building ROOT with CMake not in my PATH fails. Release 6.04/08; Build. Add –disable-search-usrlocal to configure/make to be able to avoid conflict with incompatible installation (e.g. homebrew).; Add /opt/X11 to configure/make search for include files and libraries.; Updates PCRE to 8.37 (current upstream version) which can detect PPC64LE machine.; Fail cmake configuration if the specified CMAKE_BUILD_TYPE is unknown; Fix RPATH for MacOSX (El Capitan) to avoid building with -Drpath=ON. The default uses rpath=@loader_path/../lib. Core. Add missing protection when creating new StreamerInfo.; Add accessor functions and functionality needed by CMS event display.; Do not delete resource when replaceing default TApplication. Interpreter. Prevent crash in expressions which contain use undefined identifier ROOT-7737; Disable unnecessary code during dictionary generation that triggered problem due to the lack of support for template parameter packs ROOT-7708; Add suport in the type and name normalization routine for template parameter packs ROOT-7708. IO. For backward compatibility with ROOT5, allow to define IO constructors with the signature MyClass::MyClass(void&) where void is a forward declared type.; In TBuffer shrink buffers when requested. Histograms. Fix interval calculation in Divide for the Pois",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:32836,detect,detect,32836,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['detect'],['detect']
Safety," POINT. The orientation is chosen so that DIR.dot.NORM>0. ; Implements TGeoBoolNode.; Definition at line 1398 of file TGeoBoolNode.cxx. ◆ Contains(). Bool_t TGeoIntersection::Contains ; (; const Double_t * ; point); const. overridevirtual . Find if a intersection of two shapes contains a given point. ; Implements TGeoBoolNode.; Definition at line 1449 of file TGeoBoolNode.cxx. ◆ DeclFileName(). static const char * TGeoIntersection::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 166 of file TGeoBoolNode.h. ◆ DistanceToPrimitive(). Int_t TGeoIntersection::DistanceToPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Compute minimum distance to shape vertices. ; Implements TGeoBoolNode.; Definition at line 1464 of file TGeoBoolNode.cxx. ◆ DistFromInside(). Double_t TGeoIntersection::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = 0, . Double_t * ; safe = nullptr . ); const. overridevirtual . Compute distance from a given point inside to the shape boundary. ; Implements TGeoBoolNode.; Definition at line 1472 of file TGeoBoolNode.cxx. ◆ DistFromOutside(). Double_t TGeoIntersection::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = 0, . Double_t * ; safe = nullptr . ); const. overridevirtual . Compute distance from a given point outside to the shape. ; Implements TGeoBoolNode.; Definition at line 1505 of file TGeoBoolNode.cxx. ◆ GetBooleanOperator(). EGeoBoolType TGeoIntersection::GetBooleanOperator ; (; ); const. inlineoverridevirtual . Implements TGeoBoolNode.; Definition at line 156 of file TGeoBoolNode.h. ◆ GetNpoints(). Int_t TGeoIntersection::GetNpoints ; (; ). overridevirtual . Returns number of vertices for the composite shape described by this intersection. ; Implements TGeoBoolNode.; Definition at line 1599 of file TGeoBoolNode.cxx. ◆ IsA(). TClass * TGeoInters",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoIntersection.html:16758,safe,safe,16758,doc/master/classTGeoIntersection.html,https://root.cern,https://root.cern/doc/master/classTGeoIntersection.html,1,['safe'],['safe']
Safety," Physical nodes and their global transformations are subjected to a caching mechanism due to the sometimes very large memory requirements of logical graph expansion. The total number of physical instances of volumes triggers the caching mechanism and the cache manager is a client of TGeoManager. The manager class also controls the drawing/checking package (TGeoPainter client). This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions.; 18.5 Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.; We will hereby describe the user interface of TGeo to access tracking functionality. This allows either developing a tracker for simple navigation within a given geometry, either interfacing to an external tracking engine such as GEANT. Note that the abstract interface for external trackers can be found in $ROOTSYS/vmc folder and it can be used to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:970996,safe,safety,970996,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['safe'],['safety']
Safety," Private Attributes |; List of all members ; TGeoNavigator Class ReferenceThe Geometry Package » Geometry classes. ; Class providing navigation API for TGeo geometries. ; Several instances are allowed for a single geometry. A default navigator is provided for any geometry but one may add several others for parallel navigation:; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; Int_t inav = gGeoManager->AddNavigator(navig);; gGeoManager->SetCurrentNavigator(inav);; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManager::AddNavigatorTGeoNavigator * AddNavigator()Add a navigator in the list of navigators.Definition TGeoManager.cxx:789; TGeoManager::SetCurrentNavigatorBool_t SetCurrentNavigator(Int_t index)Switch to another existing navigator for the calling thread.Definition TGeoManager.cxx:849; TGeoNavigatorClass providing navigation API for TGeo geometries.Definition TGeoNavigator.h:32; TGeoNavigator::TGeoNavigatorTGeoNavigator()global mode is caching enabled for parallel world safety callsDefinition TGeoNavigator.cxx:57; int; .... and then switch back to the default navigator:; gGeoManager->SetCurrentNavigator(0);. Definition at line 32 of file TGeoNavigator.h. Public Member Functions;  TGeoNavigator ();  global mode is caching enabled for parallel world safety calls ;  ;  TGeoNavigator (TGeoManager *geom);  Constructor. ;  ;  ~TGeoNavigator () override;  Destructor. ;  ; void BuildCache (Bool_t dummy=kFALSE, Bool_t nodeid=kFALSE);  Builds the cache for physical nodes and global matrices. ;  ; Bool_t cd (const char *path="""");  Browse the tree of nodes starting from top node according to pathname. ;  ; void CdDown (Int_t index);  Make a daughter of current node current. ;  ; void CdDown (TGeoNode *node);  Make a daughter of current node current. ;  ; void CdNext ();  Do a cd to the node found next by FindNextBoundary. ;  ; void CdNode (Int_t nodeid);  Change current path to point to the node having this id. ;  ; void CdTop ();  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:1293,safe,safety,1293,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['safe'],['safety']
Safety," Proof (gProof).; 3003///; 3004/// ""Draw"" and ""Processed"" commands will be handled by PROOF.; 3005/// The refresh and gettreeheader are meaningful only if on == true.; 3006/// If refresh is true the underlying fProofChain (chain proxy) is always; 3007/// rebuilt (even if already existing).; 3008/// If gettreeheader is true the header of the tree will be read from the; 3009/// PROOF cluster: this is only needed for browsing and should be used with; 3010/// care because it may take a long time to execute.; 3011 ; 3012void TChain::SetProof(bool on, bool refresh, bool gettreeheader); 3013{; 3014 if (!on) {; 3015 // Disable; 3016 SafeDelete(fProofChain);; 3017 // Reset related bit; 3018 ResetBit(kProofUptodate);; 3019 } else {; 3020 if (fProofChain && !refresh &&; 3021 (!gettreeheader || (gettreeheader && fProofChain->GetTree()))) {; 3022 return;; 3023 }; 3024 SafeDelete(fProofChain);; 3025 ResetBit(kProofUptodate);; 3026 ; 3027 // Make instance of TChainProof via the plugin manager; 3028 TPluginHandler *h;; 3029 if ((h = gROOT->GetPluginManager()->FindHandler(""TChain"", ""proof""))) {; 3030 if (h->LoadPlugin() == -1); 3031 return;; 3032 if (!(fProofChain = reinterpret_cast<TChain *>(h->ExecPlugin(2, this, gettreeheader)))); 3033 Error(""SetProof"", ""creation of TProofChain failed"");; 3034 // Set related bits; 3035 SetBit(kProofUptodate);; 3036 }; 3037 }; 3038}; 3039 ; 3040////////////////////////////////////////////////////////////////////////////////; 3041/// Set chain weight.; 3042///; 3043/// The weight is used by TTree::Draw to automatically weight each; 3044/// selected entry in the resulting histogram.; 3045/// For example the equivalent of; 3046/// ~~~ {.cpp}; 3047/// chain.Draw(""x"",""w""); 3048/// ~~~; 3049/// is; 3050/// ~~~ {.cpp}; 3051/// chain.SetWeight(w,""global"");; 3052/// chain.Draw(""x"");; 3053/// ~~~; 3054/// By default the weight used will be the weight; 3055/// of each Tree in the TChain. However, one can force the individual; 3056/// weights to be ignored by ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:109772,Safe,SafeDelete,109772,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,2,['Safe'],['SafeDelete']
Safety," Public Member Functions;  TGeoArb8 ();  ;  TGeoArb8 (const char *name, Double_t dz, Double_t *vertices=nullptr);  ;  TGeoArb8 (Double_t dz, Double_t *vertices=nullptr);  ;  ~TGeoArb8 () override;  ; Double_t Capacity () const override;  ; void ComputeBBox () override;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; void ComputeTwist ();  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistToPlane (const Double_t *point, const Double_t *dir, Int_t ipl, Bool_t in) const;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; Int_t GetByteCount",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoArb8.html:1142,safe,safe,1142,doc/master/classTGeoArb8.html,https://root.cern,https://root.cern/doc/master/classTGeoArb8.html,1,['safe'],['safe']
Safety," Public Member Functions;  TGeoPara ();  ;  TGeoPara (const char *name, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi);  ;  TGeoPara (Double_t *param);  ;  TGeoPara (Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi);  ;  ~TGeoPara () override;  ; Double_t Capacity () const override;  ; void ComputeBBox () override;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAlpha () const;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; Int_t Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPara.html:1218,safe,safe,1218,doc/master/classTGeoPara.html,https://root.cern,https://root.cern/doc/master/classTGeoPara.html,1,['safe'],['safe']
Safety," Public Member Functions;  TGeoTrd1 ();  ;  TGeoTrd1 (const char *name, Double_t dx1, Double_t dx2, Double_t dy, Double_t dz);  ;  TGeoTrd1 (Double_t *params);  ;  TGeoTrd1 (Double_t dx1, Double_t dx2, Double_t dy, Double_t dz);  ;  ~TGeoTrd1 () override;  ; Double_t Capacity () const override;  ; void ComputeBBox () override;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; Int_t GetByteCount () const override;  ; Double_t GetDx1 () const;  ; Double_t GetDx2 () const;  ; Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd1.html:1157,safe,safe,1157,doc/master/classTGeoTrd1.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd1.html,1,['safe'],['safe']
Safety," Public Member Functions;  TGeoTrd2 ();  ;  TGeoTrd2 (const char *name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz);  ;  TGeoTrd2 (Double_t *params);  ;  TGeoTrd2 (Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz);  ;  ~TGeoTrd2 () override;  ; Double_t Capacity () const override;  ; void ComputeBBox () override;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; Int_t GetByteCount () const override;  ; Double_t GetDx1 () const;  ; D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd2.html:1187,safe,safe,1187,doc/master/classTGeoTrd2.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd2.html,1,['safe'],['safe']
Safety," PyPy, there are two new approaches: cffi for C and cppyy for C++. Both are part of the standard PyPy releases. There is also already a PyROOT version for the latter (see: http://root.cern.ch/drupal/content/pypyroot).; Cheers,; Wim. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:49 Permalink . Why? . I don't understand. You wish to maintain backwards compatibility. This implies maintaining the insanity that is the equivalence of ""."" and ""->"". Not only is this wrong, this egregiously ignores performance concerns that come with dereferencing. It also ensures that people using ROOT/Cling while learning C++ will have trouble compiling their programs using actual compilers. It implies that you intend to keep the (at best) insane class hierarchy TF1 <- TF2 <- TF3 and so on. This example shows some of the major design flaws in ROOT -- a 2-dimensional function IS a 1-dimensional function? There is no abstract base class? No templates? It implies that you plan to keep the pointless T in front of all the names of ROOT, even though you will have access to namespaces (finally) and thus can move past the 1970's C practice of avoiding name collisions by a sort of weird Hungarian notation. It implies that you plan to maintain the outdated interfaces which make no use of templates. Templates are one of the most powerful features of C++, are more relevant to performance critical tasks than inheritance, and help ensure the type-safety of code (thereby ensuring the accuracy of data by helping to prevent accidental narrowing etc). It implies that you intend to continue to encourage the use of bare new and delete operators, instead of relying on the more efficient, reliable, and safe method of using RAII. Why? This begs the obvious question: why bother migrating at all? You wish to migrate to the modern and superior C++11 in order to not take advantage of its features? Why not just simply maintain ROOT5 and CINT, and just refuse to upgrade? ROOT is not a particularly good ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:9553,avoid,avoiding,9553,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['avoid'],['avoiding']
Safety," RDFHelpers.cxx. ◆ SaveGraph() [1/2]. template<typename NodeType > . std::string ROOT::RDF::SaveGraph ; (; NodeType ; node). Create a graphviz representation of the dataframe computation graph, return it as a string. ; Parameters. [in]nodeany node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to. The output can be displayed with a command akin to dot -Tpng output.dot > output.png && open output.png.; Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are effectively optimized away from the computation graph.; Note that SaveGraph is not thread-safe and must not be called concurrently from different threads. ; Definition at line 120 of file RDFHelpers.hxx. ◆ SaveGraph() [2/2]. template<typename NodeType > . void ROOT::RDF::SaveGraph ; (; NodeType ; node, . const std::string & ; outputFile . ). Create a graphviz representation of the dataframe computation graph, write it to the specified file. ; Parameters. [in]nodeany node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to. ; [in]outputFilefile where to save the representation. The output can be displayed with a command akin to dot -Tpng output.dot > output.png && open output.png.; Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are effectively optimized away from the computation graph.; Note that SaveGraph is not thread-safe and must not be called concurrently from different threads. ; Definition at line 139 of file RDFHelpers.hxx. ◆ splitInEqualRanges(). void ROOT::RDF::splitInEqualRanges ; (; std::vector< std::pair< ULong64_t, ULong64_t > > & ; ranges, . int ; nRecords, . unsigned int ; nSlots . ). Definition at line 519 of file RArrowDS.cxx. ROOTRDF. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:14:04 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1RDF.html:16283,safe,safe,16283,doc/v632/namespaceROOT_1_1RDF.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1RDF.html,1,['safe'],['safe']
Safety," ROOT-7703. This restores the behavior of Locate() to that found with TXNetFileStager: Rather than return only the xrootd server’s reply, the endpoint hostname is looked up and Locate() returns the full url, including the path. Release 6.04/12; I/O. Add to the TClass StreamerInfo for non-stl collections. A ‘collection’ here is a class for which there is a TVirtualCollectionProxy. For example this applies to ATLAS’ DataVector.; TWebFile. Fixed ROOT-7809. Returns an error for a redirect which does not specify the new URI, rather than going into a loop. Interpreter. Cache ROOT specials (ROOT-7830 and friends).; Accelerated calls as seen e.g. in PyROOT [ROOT-7840]. This fixes a PyROOT performance regression between 6.02 and 6.04, seen by ATLAS. Documentation. Apply THtml->doxygen transformation for func doc. Eases cherry picking. Bugs and Improvements. [ROOT-7789] - ROOTConfig.cmake should not set CMAKE_MODULE_PATH nor install FindX modules; [ROOT-7809] - TWebFile infinite loop for 301 redirects without Location; [ROOT-7817] - Avoid a crash under some circumstances when trying to open an invalid path.; [ROOT-7787] - CMake: allow disabling ncurses. Release 6.04/14; Build system. Added build option builtin_openssl to build OpenSSL internally. This is specially needed for the lastest Mac OSX (El Capitan); Fix configuration of threading in LLVM.; Fix issue with inconsistent visibility ROOT-7896. GL. Mattias Ellert fixed a memory leak [PR114]. Interpreter. Update automatic variables if gDirectory changes ROOT-7830; Fix issue with initialization of statics in interpreter ROOT-7901. PyROOT. Fix handling of vector<enums> ROOT-7916. Release 6.04/16; Published on 2016-03-17.; Core. Properly handle the case of an executable with a space in its full pathname when search for linked in library. This fixes [ROOT-8019].; Reduce memory consumption (autoparsing) of plugins TXNetSystem/TNetXNGSystem and TGQt. Meta Library. Added a new mode for TClass::SetCanSplit (2) which indicates that ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:36371,Avoid,Avoid,36371,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['Avoid'],['Avoid']
Safety," ROOT::Math::GaussLegendreIntegrator:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ GaussLegendreIntegrator(). ROOT::Math::GaussLegendreIntegrator::GaussLegendreIntegrator ; (; int ; num = 10, . double ; eps = 1e-12 . ). Basic constructor of GaussLegendreIntegrator. ; @param num Number of desired points to calculate the integration. @param eps Desired relative error. ; Definition at line 23 of file GaussLegendreIntegrator.cxx. ◆ ~GaussLegendreIntegrator(). ROOT::Math::GaussLegendreIntegrator::~GaussLegendreIntegrator ; (; ). override . Default Destructor. ; Definition at line 34 of file GaussLegendreIntegrator.cxx. Member Function Documentation. ◆ CalcGaussLegendreSamplingPoints(). void ROOT::Math::GaussLegendreIntegrator::CalcGaussLegendreSamplingPoints ; (; ). private . Type: unsafe but fast interface filling the arrays x and w (static method) ; Given the number of sampling points this routine fills the arrays x and w of length num, containing the abscissa and weight of the Gauss-Legendre n-point quadrature formula.; Gauss-Legendre: W(x)=1 -1<x<1 (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}; num is the number of sampling points (>0) x and w are arrays of size num eps is the relative precision; If num<=0 or eps<=0 no action is done.; Reference: Numerical Recipes in C, Second Edition ; Definition at line 98 of file GaussLegendreIntegrator.cxx. ◆ DoIntegral(). double ROOT::Math::GaussLegendreIntegrator::DoIntegral ; (; double ; a, . double ; b, . const IGenFunction * ; func . ). overrideprivatevirtual . Integration surrogate method. ; Return integral of passed function in interval [a,b] Reimplement method of GaussIntegrator using CalcGaussLegendreSamplingPoints ; Reimplemented from ROOT::Math::GaussIntegrator.; Definition at line 60 of file GaussLegendreIntegrator.cxx. ◆ GetNumberPoints(). int ROOT::Math::GaussLegendreIntegrator::GetNumberPoints ; (; ); const. inline . Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GaussLegendreIntegrator.html:5423,unsafe,unsafe,5423,doc/master/classROOT_1_1Math_1_1GaussLegendreIntegrator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GaussLegendreIntegrator.html,1,['unsafe'],['unsafe']
Safety," ReadBasicType<BitsMarker>(TBuffer &buf, void *addr, const TConfiguration *config); 236 {; 237 UInt_t *x = (UInt_t*)( ((char*)addr) + config->fOffset );; 238 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 239 // Idea: This code really belongs inside TBuffer[File]; 240 const UInt_t isonheap = *x & TObject::kIsOnHeap; // Record how this instance was actually allocated.; 241 buf >> *x;; 242 *x |= isonheap | TObject::kNotDeleted; // by definition de-serialized object are not yet deleted.; 243 ; 244 if ((*x & kIsReferenced) != 0) {; 245 HandleReferencedTObject(buf,addr,config);; 246 }; 247 return 0;; 248 }; 249 ; 250 template <typename T>; 251 INLINE_TEMPLATE_ARGS Int_t WriteBasicType(TBuffer &buf, void *addr, const TConfiguration *config); 252 {; 253 T *x = (T *)(((char *)addr) + config->fOffset);; 254 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 255 buf << *x;; 256 return 0;; 257 }; 258 ; 259 INLINE_TEMPLATE_ARGS Int_t WriteTextTNamed(TBuffer &buf, void *addr, const TConfiguration *config); 260 {; 261 void *x = (void *)(((char *)addr) + config->fOffset);; 262 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 263 buf.StreamObject(x, TNamed::Class(), TNamed::Class());; 264 return 0;; 265 }; 266 ; 267 INLINE_TEMPLATE_ARGS Int_t WriteTextTObject(TBuffer &buf, void *addr, const TConfiguration *config); 268 {; 269 void *x = (void *)(((char *)addr) + config->fOffset);; 270 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 271 buf.StreamObject(x, TObject::Class(), TObject::Class());; 272 return 0;; 273 }; 274 ; 275 INLINE_TEMPLATE_ARGS Int_t WriteTextBaseClass(TBuffer &buf, void *addr, const TConfiguration *config); 276 {; 277 void *x = (void *)(((char *)addr) + config->fOffset);; 278 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 279 ((TBufferText *)&buf)->WriteBaseClass(x, (TStreamerBase *)config->fCompInfo->fElem);; 280 return 0;; 281 }; 282 ; 283 INLINE_TEMPLATE_A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:9332,avoid,avoid,9332,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['avoid'],['avoid']
Safety," ReadFastArray(ULong64_t* l, Int_t n); read array of ULong64_t from buffer. void ReadFastArray(Float_t* f, Int_t n); read array of Float_t from buffer. void ReadFastArray(Double_t* d, Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayWithFactor(Float_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Float16_t from buffer. void ReadFastArrayWithNbits(Float_t* ptr, Int_t n, Int_t nbits); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArrayWithFactor(Double_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Double32_t from buffer. void ReadFastArrayWithNbits(Double_t* ptr, Int_t n, Int_t nbits); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Lon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferJSON.html:32609,avoid,avoid,32609,root/html534/TBufferJSON.html,https://root.cern,https://root.cern/root/html534/TBufferJSON.html,6,['avoid'],['avoid']
Safety," Reimplemented from TGeoBBox.; Definition at line 454 of file TGeoShapeAssembly.cxx. ◆ IsA(). TClass * TGeoShapeAssembly::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 64 of file TGeoShapeAssembly.h. ◆ IsAssembly(). Bool_t TGeoShapeAssembly::IsAssembly ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoShape.; Definition at line 53 of file TGeoShapeAssembly.h. ◆ IsCylType(). Bool_t TGeoShapeAssembly::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 54 of file TGeoShapeAssembly.h. ◆ NeedsBBoxRecompute(). void TGeoShapeAssembly::NeedsBBoxRecompute ; (; ). inline . Definition at line 55 of file TGeoShapeAssembly.h. ◆ RecomputeBoxLast(). void TGeoShapeAssembly::RecomputeBoxLast ; (; ). Recompute bounding box of the assembly after adding a node. ; Definition at line 114 of file TGeoShapeAssembly.cxx. ◆ Safety(). Double_t TGeoShapeAssembly::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . computes the closest distance from given point to this shape, according to option. ; The matching point on the shape is stored in spoint. ; Reimplemented from TGeoBBox.; Definition at line 476 of file TGeoShapeAssembly.cxx. ◆ Safety_v(). void TGeoShapeAssembly::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Compute safe distance from each of the points in the input array. ; Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values ; Reimplemented from TGeoBBox.; Definition at line 617 of file TGeoShapeAssembly.cxx. ◆ SavePrimitive(). void TGeoShapeAssembly::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Definition at line 54",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShapeAssembly.html:30214,Safe,Safety,30214,doc/master/classTGeoShapeAssembly.html,https://root.cern,https://root.cern/doc/master/classTGeoShapeAssembly.html,1,['Safe'],['Safety']
Safety," RooAbsArg& var7, const RooAbsArg& var8, const char* name = """"); Constructor for set containing 8 initial objects. RooArgList(const RooAbsArg& var1, const RooAbsArg& var2, const RooAbsArg& var3, const RooAbsArg& var4, const RooAbsArg& var5, const RooAbsArg& var6, const RooAbsArg& var7, const RooAbsArg& var8, const RooAbsArg& var9, const char* name = """"); Constructor for set containing 9 initial objects. RooArgList(const TCollection& tcoll, const char* name = """"); Constructor from a root TCollection. Elements in the collection that; do not inherit from RooAbsArg will be skipped. A warning message; will be printed for every skipped item. RooArgList(const RooArgList& other, const char* name = """"); Copy constructor. Note that a copy of a list is always non-owning,; even the source list is owning. To create an owning copy of; a list (owning or not), use the snaphot() method. ~RooArgList(); Destructor. RooAbsArg& operator[](Int_t idx) const; Array operator. Element in slot 'idx' must already exist, otherwise; code will abort. When used as lvalue in assignment operations, the element contained in; the list will not be changed, only the value of the existing element!. void writeToStream(ostream& os, Bool_t compact); Write the contents of the argset in ASCII form to given stream. All elements will be printed on a single line separated by a single; white space. The contents of each element is written by the arguments'; writeToStream() function. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read the contents of the argset in ASCII form from given stream. A single line is read, and all elements are assumed to be separated; by white space. The value of each argument is read by the arguments; readFromStream function. TObject* clone(const char* newname) const; { return new RooArgList(*this,newname); }. TObject* create(const char* newname) const; { return new RooArgList(newname); }. RooArgList& operator=(const RooArgList& other); { RooAbsCollection::o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooArgList.html:15054,abort,abort,15054,root/html528/RooArgList.html,https://root.cern,https://root.cern/root/html528/RooArgList.html,6,['abort'],['abort']
Safety," RooAbsReal::plotSamplingHint ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. virtual . Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ; Parameters. [in]obsObservable to retrieve sampling hint for. ; [in]xloBeginning of range. ; [in]xhiEnd of range. . ReturnsThe caller owns the returned std::list. ; Reimplemented in RooLagrangianMorphFunc, RooAddition, RooFormulaVar, RooProduct, RooRealSumFunc, RooRealSumPdf, ParamHistFunc, PiecewiseInterpolation, RooMomentMorphFunc, RooParametricStepFunction, RooParamHistFunc, RooStepFunction, RooAddPdf, RooBinSamplingPdf, RooBinWidthFunction, RooHistFunc, RooHistPdf, RooLinearCombination, RooProdPdf, RooRangeBoolean, RooRealIntegral, and RooWrapperPdf.; Definition at line 3571 of file RooAbsReal.cxx. ◆ plotSanityChecks(). bool RooAbsReal::plotSanityChecks ; (; RooPlot * ; frame); const. protected . Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ; Definition at line 2860 of file RooAbsReal.cxx. ◆ preferredObservableScanOrder(). void RooAbsReal::preferredObservableScanOrder ; (; const RooArgSet & ; obs, . RooArgSet & ; orderedObs . ); const. virtual . Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ; The observables to be ordered are offered in argument 'obs' and should be copied in their preferred order into argument 'orderedObs', This default implementation indicates no preference and copies the original order of 'obs' into 'orderedObs' ; Reimplemented in RooIntegralMorph, and RooCachedPdf.; Definition at line 3694 of file RooAbsReal.cxx. ◆ printEvalErrors(). void RooAbsReal::printEvalErrors ; (; std::ostream & ; os = std::cout, . Int_t ; maxPerNode = 10000000 . ). static . Print all outstanding logged evaluation error on the given ostream. ; If maxPerNode is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:140376,sanity check,sanity check,140376,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,2,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety," RooAbsReal::plotSamplingHint ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. virtual . Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ; Parameters. [in]obsObservable to retrieve sampling hint for. ; [in]xloBeginning of range. ; [in]xhiEnd of range. . ReturnsThe caller owns the returned std::list. ; Reimplemented in RooLagrangianMorphFunc, RooAddition, RooFormulaVar, RooProduct, RooRealSumFunc, RooRealSumPdf, ParamHistFunc, PiecewiseInterpolation, RooMomentMorphFunc, RooParametricStepFunction, RooParamHistFunc, RooStepFunction, RooAddPdf, RooBinSamplingPdf, RooBinWidthFunction, RooHistFunc, RooHistPdf, RooLinearCombination, RooProdPdf, RooRangeBoolean, RooRealIntegral, and RooWrapperPdf.; Definition at line 3651 of file RooAbsReal.cxx. ◆ plotSanityChecks(). bool RooAbsReal::plotSanityChecks ; (; RooPlot * ; frame); const. protected . Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ; Definition at line 2945 of file RooAbsReal.cxx. ◆ plotSliceOn(). RooPlot * RooAbsReal::plotSliceOn ; (; RooPlot * ; frame, . const RooArgSet & ; sliceSet, . Option_t * ; drawOptions = ""L"", . double ; scaleFactor = 1.0, . ScaleType ; stype = Relative, . const RooAbsData * ; projData = nullptr . ); const. virtual . Deprecated:OBSOLETE – RETAINED FOR BACKWARD COMPATIBILITY. Use plotOn() with Slice() instead ; Definition at line 2253 of file RooAbsReal.cxx. ◆ preferredObservableScanOrder(). void RooAbsReal::preferredObservableScanOrder ; (; const RooArgSet & ; obs, . RooArgSet & ; orderedObs . ); const. virtual . Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ; The observables to be ordered are offered in argument 'obs' and should be copied in their preferred order into argument 'orderedObs', This default implementation",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:141803,sanity check,sanity check,141803,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,2,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety," RooProofDriverSelector(TTree* = 0); virtual~RooProofDriverSelector(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTSelector::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooProofDriverSelector.html:590,Abort,Abort,590,root/html530/RooProofDriverSelector.html,https://root.cern,https://root.cern/root/html530/RooProofDriverSelector.html,3,['Abort'],['Abort']
Safety," RooProofDriverSelector(TTree* = 0); virtual~RooProofDriverSelector(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTSelector::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProofDriverSelector.html:588,Abort,Abort,588,root/html526/RooProofDriverSelector.html,https://root.cern,https://root.cern/root/html526/RooProofDriverSelector.html,2,['Abort'],['Abort']
Safety," Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ~IBaseParam(). virtual ROOT::Math::IBaseParam::~IBaseParam ; (; ). inlinevirtual . Virtual Destructor (no operations) ; Definition at line 59 of file IParamFunction.h. Member Function Documentation. ◆ NPar(). virtual unsigned int ROOT::Math::IBaseParam::NPar ; (; ); const. pure virtual . Return the number of Parameters. ; Implemented in ROOT::Math::ParamFunction< IParamGradFunction >, ROOT::Math::WrappedMultiTF1Templ< T >, ROOT::Math::WrappedTF1, ROOT::Math::MultiDimParamFunctionAdapter, ROOT::Math::MultiDimParamGradFunctionAdapter, ROOT::Math::WrappedParamFunction< FuncPtr >, ROOT::Math::WrappedParamFunctionGen< FuncPtr >, ROOT::Math::VavilovAccurateCdf, ROOT::Math::VavilovAccuratePdf, and ROOT::Math::VavilovAccurateQuantile. ◆ ParameterName(). virtual std::string ROOT::Math::IBaseParam::ParameterName ; (; unsigned int ; i); const. inlinevirtual . Return the name of the i-th parameter (starting from zero) Overwrite if want to avoid the default name (""Par_0, Par_1, ..."") ; Reimplemented in ROOT::Math::WrappedMultiTF1Templ< T >, ROOT::Math::WrappedTF1, ROOT::Math::VavilovAccurateCdf, ROOT::Math::VavilovAccuratePdf, and ROOT::Math::VavilovAccurateQuantile.; Definition at line 86 of file IParamFunction.h. ◆ Parameters(). virtual const double * ROOT::Math::IBaseParam::Parameters ; (; ); const. pure virtual . Access the parameter values. ; Implemented in ROOT::Math::ParamFunction< IParamGradFunction >, ROOT::Math::WrappedMultiTF1Templ< T >, ROOT::Math::WrappedTF1, ROOT::Math::MultiDimParamFunctionAdapter, ROOT::Math::MultiDimParamGradFunctionAdapter, ROOT::Math::WrappedParamFunction< FuncPtr >, ROOT::Math::WrappedParamFunctionGen< FuncPtr >, ROOT::Math::VavilovAccurateCdf, ROOT::Math::VavilovAccuratePdf, and ROOT::Math::VavilovAccurateQuantile. ◆ SetParameters(). virtual void ROOT::Math::IBaseParam::SetParameters ; (; const double * ; p). pure virtual . Set the parameter values. ; Parameters. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IBaseParam.html:2401,avoid,avoid,2401,doc/master/classROOT_1_1Math_1_1IBaseParam.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IBaseParam.html,1,['avoid'],['avoid']
Safety," Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(Double32_t pt); ====== Set member functions for coordinates in other systems =======. void SetEta(Double32_t eta). void SetPhi(Double32_t phi). void SetE(Double32_t energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: 464c29f33a8bbd8462a3e15b7e4c30c6f5b74a30 $ » Last generated: 2015-09-08 17:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__PxPyPzM4D_Double32_t_.html:8620,avoid,avoid,8620,root/html534/ROOT__Math__PxPyPzM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__PxPyPzM4D_Double32_t_.html,1,['avoid'],['avoid']
Safety," Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoVolumeAssembly. class TGeoVolumeAssembly: public TGeoVolume. TGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly - the volume classes. Volumes are the basic objects used in building the geometrical hierarchy.; They represent unpositioned objects but store all information about the; placement of the other volumes they may contain. Therefore a volume can; be replicated several times in the geometry. In order to create a volume, one; has to put together a shape and a medium which are already defined. Volumes; have to be named by users at creation time. Every different name may represent a; an unique volume object, but may also represent more general a family (class); of volume objects having the same shape type and medium, but possibly; different shape parameters. It is the user's task to provide different names; for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases :; when a generic shape is provided to the volume constructor or when a division; operation is applied. Each volume in the geometry stores an unique; ID corresponding to its family. In order to ease-up their creation, the manager; class is providing an API that allows making a shape and a volume in a single step. Volumes are objects that can be visualized, therefore having visibility,; colour, line and fill attributes that can be defined or modified any time after; the volume creation. It is advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolumeAssembly.html:1117,avoid,avoid,1117,root/html534/TGeoVolumeAssembly.html,https://root.cern,https://root.cern/root/html534/TGeoVolumeAssembly.html,3,['avoid'],['avoid']
Safety," Stream an object of class TBranchElement.; 5963 ; 5964void TBranchElement::Streamer(TBuffer& R__b); 5965{; 5966 if (R__b.IsReading()) {; 5967 R__b.ReadClassBuffer(TBranchElement::Class(), this);; 5968 fParentClass.SetName(fParentName);; 5969 fBranchClass.SetName(fClassName);; 5970 fTargetClass.SetName(fClassName);; 5971 fClonesClass.SetName(fClonesName);; 5972 // The fAddress and fObject data members are not persistent,; 5973 // therefore we do not own anything.; 5974 // Also clear the bit possibly set by the schema evolution.; 5975 ResetBit(kDeleteObject|kCache|kOwnOnfileObj|kAddressSet|kDecomposedObj);; 5976 // Fixup a case where the TLeafElement was missing; 5977 if ((fType == 0) && (fLeaves.GetEntriesFast() == 0)) {; 5978 TLeaf* leaf = new TLeafElement(this, GetTitle(), fID, fStreamerType);; 5979 leaf->SetTitle(GetTitle());; 5980 fNleaves = 1;; 5981 fLeaves.Add(leaf);; 5982 fTree->GetListOfLeaves()->Add(leaf);; 5983 }; 5984 ; 5985 // SetReadLeavesPtr();; 5986 }; 5987 else {; 5988 TDirectory* dirsav = fDirectory;; 5989 fDirectory = nullptr; // to avoid recursive calls; 5990 {; 5991 // Save class version.; 5992 Int_t classVersion = fClassVersion;; 5993 // Record only positive 'version number'; 5994 if (fClassVersion < 0) {; 5995 fClassVersion = -fClassVersion;; 5996 }; 5997 // TODO: Should we clear the kDeleteObject bit before writing?; 5998 // If we did we would have to remember the old value and; 5999 // put it back, we wouldn't want to forget that we owned; 6000 // something just because we got written to disk.; 6001 R__b.WriteClassBuffer(TBranchElement::Class(), this);; 6002 // Restore class version.; 6003 fClassVersion = classVersion;; 6004 }; 6005 //; 6006 // Mark all streamer infos used by this branch element; 6007 // to be written to our output file.; 6008 //; 6009 {; 6010 R__b.ForceWriteInfo(GetInfoImp(), true);; 6011 }; 6012 //; 6013 // If we are a clones array master branch, or an; 6014 // STL container master branch, we must also mark; 6015 // the str",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:224368,avoid,avoid,224368,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['avoid'],['avoid']
Safety," TAttMarker; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Width_t GetMarkerLineWidth (Style_t style);  Internal helper function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; void FindMomentumLimits (TEveElement *el, Bool_t recurse=kTRUE);  Loop over track elements of argument el and find highest pT and p. ;  ; Double_t RoundMomentumLimit (Double_t x);  Round the momentum limit up to a nice value. ;  ; void SanitizeMinMaxCuts ();  Set Min/Max cuts so that they are within detected limits. ;  ;  Protected Member Functions inherited from TEveElement; virtual void AnnihilateRecursively ();  Protected member function called from TEveElement::Annihilate(). ;  ; virtual void PreDeleteElement ();  Externally assigned and controlled user data. ;  ; virtual void RemoveElementsInternal ();  Remove all elements. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Double_t fLimP;  ; Double_t fLimPt;  ; Double_t fMaxP;  ; Double_t fMaxPt;  ; Double_t fMinP;  ; Double_t fMinPt;  ; TEveTrackPropagator * fPropagator;  ; Bool_t fRecurse;  ; Bool_t fRnrLine;  ; Bool_t fRnrPoints;  ;  Protected Attributes inherited from TEveElementList; TClass * fChildClass;  ; Color_t fColor;  ;  Protected Attributes inherited from TEveElement; Bool_t fCanEditMainColor;  ; Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveTrackList.html:35241,detect,detected,35241,doc/master/classTEveTrackList.html,https://root.cern,https://root.cern/doc/master/classTEveTrackList.html,1,['detect'],['detected']
Safety," TBranch that was created. The branch is owned by the tree.; 370 template <class T> TBranch *Branch(const char* name, T** addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); 371 {; 372 return BranchImp(name, TClass::GetClass<T>(), addobj, bufsize, splitlevel);; 373 }; 374 ; 375 virtual Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """");; 376 virtual Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99);; 377 virtual Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99);; 378 virtual TBranch *Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000);; 379 TBranch *Branch(const char* name, char* address, const char* leaflist, Int_t bufsize = 32000); 380 {; 381 // Overload to avoid confusion between this signature and the template instance.; 382 return Branch(name,(void*)address,leaflist,bufsize);; 383 }; 384 TBranch *Branch(const char* name, Longptr_t address, const char* leaflist, Int_t bufsize = 32000); 385 {; 386 // Overload to avoid confusion between this signature and the template instance.; 387 return Branch(name,(void*)address,leaflist,bufsize);; 388 }; 389 TBranch *Branch(const char* name, int address, const char* leaflist, Int_t bufsize = 32000); 390 {; 391 // Overload to avoid confusion between this signature and the template instance.; 392 return Branch(name,(void*)(Longptr_t)address,leaflist,bufsize);; 393 }; 394 virtual TBranch *Branch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99);; 395 template <class T> TBranch *Branch(const char* name, const char* classname, T* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); 396 {; 397 // See BranchImpRed for details. Here we __ignore; 398 return BranchImpRef(name, classname, TClass::GetClass<T>(), obj, bufsize, splitlevel);; 399 }; 400 template <class T> TBranch *Branch(const char* name, const char* classname, T** addobj, Int_t bufsize = 32",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:19622,avoid,avoid,19622,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['avoid'],['avoid']
Safety," TBufferXML::XmlWriteBasic ; (; ULong_t ; value). protected . Converts ULong_t to string and add xml node to buffer. ; Definition at line 2940 of file TBufferXML.cxx. ◆ XmlWriteBasic() [13/13]. XMLNodePointer_t TBufferXML::XmlWriteBasic ; (; UShort_t ; value). protected . Converts UShort_t to string and add xml node to buffer. ; Definition at line 2920 of file TBufferXML.cxx. ◆ XmlWriteBlock(). void TBufferXML::XmlWriteBlock ; (; XMLNodePointer_t ; node). protected . Write binary data block from buffer to xml. ; This data can be produced only by direct call of TBuffer::WriteBuf() functions. ; Definition at line 390 of file TBufferXML.cxx. ◆ XmlWriteFastArray(). template<typename T > . R__ALWAYS_INLINE void TBufferXML::XmlWriteFastArray ; (; const T * ; arr, . Long64_t ; n . ). protected . Write array without size attribute Also treat situation, when instead of one single array chain of several elements should be produced. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Definition at line 2161 of file TBufferXML.cxx. ◆ XmlWriteObject(). XMLNodePointer_t TBufferXML::XmlWriteObject ; (; const void * ; obj, . const TClass * ; objClass, . Bool_t ; cacheReuse . ). protected . Write object to buffer If object was written before, only pointer will be stored Return pointer to top xml node, representing object. ; Definition at line 756 of file TBufferXML.cxx. ◆ XmlWriteValue(). XMLNodePointer_t TBufferXML::XmlWriteValue ; (; const char * ; value, . const char * ; name . ). protected . Create xml node with specified name and adds it to stack node. ; Definition at line 2959 of file TBufferXML.cxx. Friends And Related Symbol Documentation. ◆ TKeyXML. friend class TKeyXML. friend . Definition at line 35 of file TBufferXML.h. Member Data Documentation. ◆ fCanUseCompact. Bool_t TBufferXML::fCanUseCompact {kFALSE}. protected . ! F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferXML.html:103920,abort,aborts,103920,doc/master/classTBufferXML.html,https://root.cern,https://root.cern/doc/master/classTBufferXML.html,1,['abort'],['aborts']
Safety," TClass** cl, void* obj = 0); Recreate object from sql structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. Bool_t SqlObjectInfo(Long64_t objid, TString& clname, Version_t& version); Returns object info like classname and version; Should be taken from buffer, which is produced in the begginnig. TSQLObjectData* SqlObjectData(Long64_t objid, TSQLClassInfo* sqlinfo); creates TSQLObjectData for specifed object id and specified class; Object data for each class can be stored in two different tables.; First table contains data in column-wise form for simple types like integer,; strings and so on when second table contains any other data which cannot; be converted into column-wise representation.; TSQLObjectData will contain results of the requests to both such tables for; concrete object id. void WriteObject(const TObject* obj); Convert object into sql structures.; !!! Should be used only by TBufferSQL2 itself.; Use SqlWrite() functions to convert your object to sql; Redefined here to avoid gcc 3.x warning. Int_t SqlWriteObject(const void* obj, const TClass* objClass, TMemberStreamer* streamer = 0, Int_t streamer_index = 0); Write object to buffer; If object was written before, only pointer will be stored; Return id of saved object. void* SqlReadObject(void* obj, TClass** cl = 0, TMemberStreamer* streamer = 0, Int_t streamer_index = 0, const TClass* onFileClass = 0); Read object from the buffer. void* SqlReadObjectDirect(void* obj, TClass** cl, Long64_t objid, TMemberStreamer* streamer = 0, Int_t streamer_index = 0, const TClass* onFileClass = 0); Read object data.; Class name and version are taken from special objects table. void IncrementLevel(TVirtualStreamerInfo* ); Function is called from TStreamerInfo WriteBuffer and Readbuffer functions; and indent new level in data structure.; This call indicates, that TStreamerInfo functions starts streaming; object data of correspondent class. void DecrementLevel(TVirtualStreamerInfo* ); Fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBufferSQL2.html:24127,avoid,avoid,24127,root/html530/TBufferSQL2.html,https://root.cern,https://root.cern/root/html530/TBufferSQL2.html,5,['avoid'],['avoid']
Safety," TColor documentation: use modern C++ in the examples.; Make sure the python examples do not generate wrong namespaces in the documentation.; The dataframe tutorials json spec files were not displayed properly. Moreover there was no direct correspondence between the code source and the json file. Those files do not have any doc in them. With a direct link to the GitHub source file the dependency between source code and json is now more obvious.; Document how to remove shadow of TPave, as it was not evident (only explanations were hidden here and there in the forum).; Improve the SetFillColorAlpha documentation.; Simplify some graphics examples: arrow.C, crown.C, diamond.C and ellipse.C.; Fix a typo in the documentation of TGraph::SetHighlight in TGraph.cxx.; Change the marker style in the tutorial df014_CSVDataSource.; Remove useless settings in the tutorial scatter.C.; Fix the tutorial h1analysisTreeReader.C.; Fix doxygen formatting in TGNumberEntry.cxx.; Avoid the CDT documentation to appear in the reference guide.; Remove last references to the old ROOT drupal website. Build, Configuration and Testing Infrastructure; Release v6.32.00 is the first one integrated and tested entirely through the new GitHub based build system.; Bugs and Issues fixed in this release; More than 200 items were addressed for this release. The full list is:. [#15621] - Buffer overflow in TBranch::Init; [#15610] - Memory leak in TTree getattr pythonization; [#15590] - Infinite recursion in TFile::Open; [#15460] - TEnum::GetEnum(“B”)->GetUnderlyingType() does not following typedefs; [#15413] - Fails to build with cuDNN version 9; [#15406] - TEnum::GetEnum does not seem to see ‘through’ using statements.; [#15399] - Memory leak with jitted nodes if the execution is never triggered; [#15396] - [TMVA] Pymva test (Keras) failing on 632 and main; [#15370] - Broken link in HS3 printout; [#15340] - Webgraphics: canvas displayed, but many error printed; [#15253] - C++ standard not propagated via CMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:24413,Avoid,Avoid,24413,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['Avoid'],['Avoid']
Safety," TConfiguration *config); 260 {; 261 void *x = (void *)(((char *)addr) + config->fOffset);; 262 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 263 buf.StreamObject(x, TNamed::Class(), TNamed::Class());; 264 return 0;; 265 }; 266 ; 267 INLINE_TEMPLATE_ARGS Int_t WriteTextTObject(TBuffer &buf, void *addr, const TConfiguration *config); 268 {; 269 void *x = (void *)(((char *)addr) + config->fOffset);; 270 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 271 buf.StreamObject(x, TObject::Class(), TObject::Class());; 272 return 0;; 273 }; 274 ; 275 INLINE_TEMPLATE_ARGS Int_t WriteTextBaseClass(TBuffer &buf, void *addr, const TConfiguration *config); 276 {; 277 void *x = (void *)(((char *)addr) + config->fOffset);; 278 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 279 ((TBufferText *)&buf)->WriteBaseClass(x, (TStreamerBase *)config->fCompInfo->fElem);; 280 return 0;; 281 }; 282 ; 283 INLINE_TEMPLATE_ARGS Int_t WriteTextStreamer(TBuffer &buf, void *addr, const TConfiguration *config); 284 {; 285 void *x = (void *)(((char *)addr) + config->fOffset);; 286 TMemberStreamer *pstreamer = config->fCompInfo->fStreamer;; 287 UInt_t pos = buf.WriteVersion(config->fInfo->IsA(), kTRUE);; 288 (*pstreamer)(buf, x, config->fCompInfo->fLength);; 289 buf.SetByteCount(pos, kTRUE);; 290 return 0;; 291 }; 292 ; 293 INLINE_TEMPLATE_ARGS Int_t ReadTextObject(TBuffer &buf, void *addr, const TConfiguration *config); 294 {; 295 void *x = (void *)(((char *)addr) + config->fOffset);; 296 buf.ReadFastArray(x, config->fCompInfo->fClass, config->fCompInfo->fLength, config->fCompInfo->fStreamer);; 297 return 0;; 298 }; 299 ; 300 INLINE_TEMPLATE_ARGS Int_t ReadTextTObject(TBuffer &buf, void *addr, const TConfiguration *config); 301 {; 302 void *x = (void *)(((char *)addr) + config->fOffset);; 303 buf.StreamObject(x, TObject::Class(), TObject::Class());; 304 return 0;; 305 }; 306 ; 307 INLINE_TEMPLATE_ARGS Int_t ReadTextBaseClass(TBuffer &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:10290,avoid,avoid,10290,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['avoid'],['avoid']
Safety," TDCacheSystem(); virtual~TDCacheSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intTSystem::AnnounceUdpService(int port, int backlog); virtual intTSystem::AnnounceUnixService(int port, int backlog); virtual intTSystem::AnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tTSystem::ChangeDirectory(const char* path); virtual intTSystem::Chmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTSystem::CleanCompiledMacros(); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDCacheSystem.html:489,Abort,Abort,489,root/html532/TDCacheSystem.html,https://root.cern,https://root.cern/root/html532/TDCacheSystem.html,1,['Abort'],['Abort']
Safety," TDCacheSystem(); virtual~TDCacheSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intTSystem::AnnounceUnixService(int port, int backlog); virtual intTSystem::AnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tTSystem::ChangeDirectory(const char* path); virtual intTSystem::Chmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTSystem::CleanCompiledMacros(); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTSystem::CloseConnection(int sock, Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TDCacheSystem.html:489,Abort,Abort,489,root/html530/TDCacheSystem.html,https://root.cern,https://root.cern/root/html530/TDCacheSystem.html,1,['Abort'],['Abort']
Safety," TDCacheSystem(); virtual~TDCacheSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intTSystem::AnnounceUnixService(int port, int backlog); virtual intTSystem::AnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tTSystem::ChangeDirectory(const char* path); virtual intTSystem::Chmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTSystem::CleanCompiledMacros(); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTSystem::CloseConnection(int sock, Bool_t force = kFALSE); virtual voidTSystem::Closelog(); virtual i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TDCacheSystem.html:487,Abort,Abort,487,root/html526/TDCacheSystem.html,https://root.cern,https://root.cern/root/html526/TDCacheSystem.html,2,['Abort'],['Abort']
Safety," TEvePointSelector(TTree* t = 0, TEvePointSelectorConsumer* c = 0, const char* vexp = """", const char* sel = """"); virtual~TEvePointSelector(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTSelectorDraw::Begin(TTree* tree); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEvePointSelector.html:796,Abort,Abort,796,root/html528/TEvePointSelector.html,https://root.cern,https://root.cern/root/html528/TEvePointSelector.html,4,['Abort'],['Abort']
Safety," TEveSelectorToEventList(TEventList* evl, const char* sel); ~TEveSelectorToEventList(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTSelectorDraw::Begin(TTree* tree); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveSelectorToEventList.html:592,Abort,Abort,592,root/html528/TEveSelectorToEventList.html,https://root.cern,https://root.cern/root/html528/TEveSelectorToEventList.html,4,['Abort'],['Abort']
Safety," TEveTrackList(const char* name, TEveTrackPropagator* prop = 0); Constructor. If track-propagator argument is 0, a new default; one is created. ~TEveTrackList(); Destructor. void SetPropagator(TEveTrackPropagator* prop); Set default propagator for tracks.; This is not enforced onto the tracks themselves but this is the; propagator that is shown in the TEveTrackListEditor. void MakeTracks(Bool_t recurse = kTRUE); Regenerate the visual representations of tracks.; The momentum limits are rescanned during the same traversal. void FindMomentumLimits(Bool_t recurse = kTRUE); Loop over children and find highest pT and p of contained TEveTracks.; These are stored in members fLimPt and fLimP. void FindMomentumLimits(TEveElement* el, Bool_t recurse = kTRUE); Loop over track elements of argument el and find highest pT and p.; These are stored in members fLimPt and fLimP. Double_t RoundMomentumLimit(Double_t x); Round the momentum limit up to a nice value. void SanitizeMinMaxCuts(); Set Min/Max cuts so that they are within detected limits. void SetRnrLine(Bool_t rnr); Set rendering of track as line for the list and the elements. void SetRnrLine(Bool_t rnr, TEveElement* el); Set rendering of track as line for children of el. void SetRnrPoints(Bool_t r); Set rendering of track as points for the list and the elements. void SetRnrPoints(Bool_t r, TEveElement* el); Set rendering of track as points for children of el. void SetMainColor(Color_t c); Set main (line) color for the list and the elements. void SetLineColor(Color_t c, TEveElement* el); Set line color for children of el. void SetLineWidth(Width_t w); Set line width for the list and the elements. void SetLineWidth(Width_t w, TEveElement* el); Set line width for children of el. void SetLineStyle(Style_t s); Set line style for the list and the elements. void SetLineStyle(Style_t s, TEveElement* el); Set line style for children of el. void SetMarkerStyle(Style_t s); Set marker style for the list and the elements. void SetMarkerSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveTrackList.html:24105,detect,detected,24105,root/html530/TEveTrackList.html,https://root.cern,https://root.cern/root/html530/TEveTrackList.html,5,['detect'],['detected']
Safety," TGLSAViewer::GetFrame ; (; ); const. Return the main-frame. ; Definition at line 325 of file TGLSAViewer.cxx. ◆ GetLeftVerticalFrame(). TGCompositeFrame * TGLSAViewer::GetLeftVerticalFrame ; (; ); const. inline . Definition at line 122 of file TGLSAViewer.h. ◆ GetName(). const char * TGLSAViewer::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 104 of file TGLSAViewer.h. ◆ HandleMenuBarHiding(). void TGLSAViewer::HandleMenuBarHiding ; (; Event_t * ; ev). Maybe switch menu-bar / menu-button. ; Definition at line 583 of file TGLSAViewer.cxx. ◆ IsA(). TClass * TGLSAViewer::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 132 of file TGLSAViewer.h. ◆ MenuHidingTimeout(). void TGLSAViewer::MenuHidingTimeout ; (; ). Action for menu-hiding timeout. ; Definition at line 638 of file TGLSAViewer.cxx. ◆ operator=(). TGLSAViewer & TGLSAViewer::operator= ; (; const TGLSAViewer & ; ). private . ◆ ProcessFrameMessage(). Bool_t TGLSAViewer::ProcessFrameMessage ; (; Long_t ; msg, . Long_t ; parm1, . Long_t ;  . ). Process GUI message capture by the main GUI frame (TGLSAFrame). ; Definition at line 663 of file TGLSAViewer.cxx. ◆ ResetMenuHidingTimer(). void TGLSAViewer::ResetMenuHidingTimer ; (; Bool_t ; show_menu). private . Reset the timer for menu-bar hiding. ; Definition at line 620 of file TGLSAViewer.cxx. ◆ SelectionChanged(). void TGLSAViewer::SelectionChanged ; (; ). overridevirtual . Update GUI components for embedded viewer selection change. ; Override from TGLViewer. ; Reimplemented from TGLViewer.; Definition at line 481 of file TGLSAViewer.cxx. ◆ SetMenuHidingTimeout(). void TGLSAViewer::SetMenuHidingTimeout ; (; Long_t ; timeout). static . Set global timeout for menu-hiding in mili-seconds. ; Static function. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLSAViewer.html:45465,timeout,timeout,45465,doc/master/classTGLSAViewer.html,https://root.cern,https://root.cern/doc/master/classTGLSAViewer.html,1,['timeout'],['timeout']
Safety," TGeoArb8.h:130; TGeoTrap::TGeoTrapTGeoTrap(); TGeoTrap::TGeoTrapTGeoTrap(Double_t dz, Double_t theta, Double_t phi); TGeoTrap::fTl1Double_t fTl1Definition TGeoArb8.h:103; TGeoTrap::fH2Double_t fH2Definition TGeoArb8.h:105; TGeoTrap::GetAlpha1Double_t GetAlpha1() constDefinition TGeoArb8.h:135; TGeoTrap::DivideTGeoVolume * Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override; TGeoTrap::GetBl2Double_t GetBl2() constDefinition TGeoArb8.h:137; TGeoTrap::GetTl2Double_t GetTl2() constDefinition TGeoArb8.h:138; TGeoTrap::DistFromOutside_vvoid DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoTrap::GetH1Double_t GetH1() constDefinition TGeoArb8.h:132; TGeoTrap::fThetaDouble_t fThetaDefinition TGeoArb8.h:99; TGeoTrap::GetMakeRuntimeShapeTGeoShape * GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override; TGeoTrap::DistFromOutsideDouble_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoTrap::fAlpha1Double_t fAlpha1Definition TGeoArb8.h:104; TGeoTrap::GetH2Double_t GetH2() constDefinition TGeoArb8.h:136; TGeoTrap::GetBl1Double_t GetBl1() constDefinition TGeoArb8.h:133; TGeoTrap::TGeoTrapTGeoTrap(Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; bool; double; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; h1TH1F * h1Definition legend1.C:5; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123. geomgeomincTGeoArb8.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:13 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoArb8_8h_source.html:19964,safe,safe,19964,doc/master/TGeoArb8_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html,1,['safe'],['safe']
Safety," TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPara.html:2079,safe,safe,2079,root/html528/TGeoPara.html,https://root.cern,https://root.cern/root/html528/TGeoPara.html,3,['safe'],['safe']
Safety," TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tTGeoBBox::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoShapeAssembly.html:1716,safe,safe,1716,root/html528/TGeoShapeAssembly.html,https://root.cern,https://root.cern/root/html528/TGeoShapeAssembly.html,1,['safe'],['safe']
Safety," TGeoNavigator(const TGeoNavigator &) = delete;; 36 TGeoNavigator &operator=(const TGeoNavigator &) = delete;; 37 TGeoNode *FindInCluster(Int_t *cluster, Int_t nc);; 38 Int_t GetTouchedCluster(Int_t start, Double_t *point, Int_t *check_list, Int_t ncheck, Int_t *result);; 39 TGeoNode *CrossDivisionCell();; 40 void SafetyOverlaps();; 41 ; 42private:; 43 Double_t fStep; //! step to be done from current point and direction; 44 Double_t fSafety; //! safety radius from current point; 45 Double_t fLastSafety; //! last computed safety radius; 46 Double_t fNormal[3]; //! cosine of incident angle on current checked surface; 47 Double_t fCldir[3]; //! unit vector to current closest shape; 48 Double_t fCldirChecked[3]; //! unit vector to current checked shape; 49 Double_t fPoint[3]; //! current point; 50 Double_t fDirection[3]; //! current direction; 51 Double_t fLastPoint[3]; //! last point for which safety was computed; 52 Double_t fLastPWSaftyPnt[3]; //! last point for which parallel world safety was ""evaluated""; 53 Double_t fLastPWSafety{-1}; //! last safety returned from parallel world (negative if invalid); 54 Int_t fThreadId; //! thread id for this navigator; 55 Int_t fLevel; //! current geometry level;; 56 Int_t fNmany; //! number of overlapping nodes on current branch; 57 Int_t fNextDaughterIndex; //! next daughter index after FindNextBoundary; 58 Int_t fOverlapSize; //! current size of fOverlapClusters; 59 Int_t fOverlapMark; //! current recursive position in fOverlapClusters; 60 Int_t *fOverlapClusters; //! internal array for overlaps; 61 Bool_t fSearchOverlaps; //! flag set when an overlapping cluster is searched; 62 Bool_t fCurrentOverlapping; //! flags the type of the current node; 63 Bool_t fStartSafe; //! flag a safe start for point classification; 64 Bool_t fIsEntering; //! flag if current step just got into a new node; 65 Bool_t fIsExiting; //! flag that current track is about to leave current node; 66 Bool_t fIsStepEntering; //! flag that next geometric step ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:2201,safe,safety,2201,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['safe'],['safety']
Safety," TGeoNavigator::CdNodevoid CdNode(Int_t nodeid)Change current path to point to the node having this id.Definition TGeoNavigator.cxx:301; TGeoNavigator::IsCurrentOverlappingBool_t IsCurrentOverlapping() constDefinition TGeoNavigator.h:139; TGeoNavigator::operator=TGeoNavigator & operator=(const TGeoNavigator &)=delete; TGeoNavigator::GetNmanyInt_t GetNmany() constDefinition TGeoNavigator.h:105; TGeoNavigator::GetCacheTGeoNodeCache * GetCache() constDefinition TGeoNavigator.h:243; TGeoNavigator::fNextNodeTGeoNode * fNextNodelast searched nodeDefinition TGeoNavigator.h:78; TGeoNavigator::fCldirCheckedDouble_t fCldirChecked[3]unit vector to current closest shapeDefinition TGeoNavigator.h:48; TGeoNavigator::SetLastSafetyForPointvoid SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z)Definition TGeoNavigator.h:199; TGeoNavigator::fLevelInt_t fLevelthread id for this navigatorDefinition TGeoNavigator.h:55; TGeoNavigator::GetPWSafetyDouble_t GetPWSafety(Double_t cpoint[3], Double_t saf_max)Wrapper for getting the safety from the parallel world.Definition TGeoNavigator.cxx:1656; TGeoNavigator::ResetAllvoid ResetAll()Reset the navigator.Definition TGeoNavigator.cxx:2708; TGeoNavigator::fBackupStateTGeoCacheState * fBackupStatecurrent point is supposed to be inside this nodeDefinition TGeoNavigator.h:80; TGeoNavigator::GetLevelInt_t GetLevel() constDefinition TGeoNavigator.h:169; TGeoNavigator::IsSamePointBool_t IsSamePoint(Double_t x, Double_t y, Double_t z) constCheck if a new point with given coordinates is the same as the last located one.Definition TGeoNavigator.cxx:2634; TGeoNavigator::fCurrentOverlappingBool_t fCurrentOverlappingflag set when an overlapping cluster is searchedDefinition TGeoNavigator.h:62; TGeoNavigator::IsOnBoundaryBool_t IsOnBoundary() constDefinition TGeoNavigator.h:145; TGeoNavigator::fIsOutsideBool_t fIsOutsideflag that next geometric step will exit current volumeDefinition TGeoNavigator.h:68; TGeoNavigator::CdDownvoid CdDown(In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:33479,safe,safety,33479,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['safe'],['safety']
Safety," TGeoTube(Double_t *params);; 34 // destructor; 35 ~TGeoTube() override;; 36 // methods; 37 ; 38 Double_t Capacity() const override;; 39 static Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz);; 40 void ComputeBBox() override;; 41 void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) override;; 42 void ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;; 43 static void ComputeNormalS(const Double_t *point, const Double_t *dir, Double_t *norm, Double_t rmin, Double_t rmax,; 44 Double_t dz);; 45 Bool_t Contains(const Double_t *point) const override;; 46 void Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override;; 47 static Double_t; 48 DistFromInsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax, Double_t dz);; 49 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 50 Double_t *safe = nullptr) const override;; 51 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 52 Double_t *step) const override;; 53 static Double_t; 54 DistFromOutsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax, Double_t dz);; 55 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 56 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 57 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 58 Double_t *step) const override;; 59 static void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t &b, Double_t &delta);; 60 Int_t DistancetoPrimitive(Int_t px, Int_t py) override;; 61 TGeoVolume *; 62 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 63 const char *GetAxisName(Int_t iaxis) const override;; 64 Double_t GetAxisR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoTube_8h_source.html:2177,safe,safe,2177,doc/master/TGeoTube_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html,1,['safe'],['safe']
Safety," THistImpl ;  CTHistImplPrecisionAgnosticBaseBase class for THistImplBase that abstracts out the histogram's PRECISION ;  ►CTSchemaRuleSet;  CTMatches;  ►NFitNamespace for the fitting classes ;  CBasicFCNBasicFCN class: base class for the objective functions used in the fits It has a reference to the data and th emodel function used in the fit ;  CBinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y values and error on coordinates The dimension of the coordinate is free There are 4 different options: ;  CBinPointObsolete class, no more in use ;  CChi2FCNChi2FCN class for binnned fits using the least square methods ;  CDataOptionsDataOptions : simple structure holding the options on how the data are filled ;  CDataRangeClass describing the range in the coordinates it supports multiple range in a coordinate ;  CDataVectorClass holding the fit data points ;  CDataWrapperClass maintaining a pointer to external data Using this class avoids copying the data when performing a fit NOTE: this class is not thread-safe and should not be used in parallel fits ;  CDummyDeleter;  CFcnAdapter;  CFitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::ParameterSettings class ;  CFitDataBase class for all the fit data types ;  CFitResultClass containg the result of the fit and all the related information (fitted parameter values, error, covariance matrix and minimizer result information) Contains a pointer also to the fitted (model) function, modified with the fit parameter values ;  CFitterFitter class, entry point for performing all type of fits ;  CLogLikelihoodFCNLogLikelihoodFCN class for likelihood fits ;  CParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/retrieve values, step sizes, limits and fix the parameters ;  CPoissonLikelihoodFCNClass evaluating the log likelihood for binned Poisson likelihood fits ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:12054,avoid,avoids,12054,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['avoid'],['avoids']
Safety," TMVA::DNN::TNet< Architecture_t, Layer_t >::LayersEnd ; (; ). inline . Iterator to the last layer of the net. ; Definition at line 98 of file Net.h. ◆ Loss() [1/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TNet< Architecture_t, Layer_t >::Loss ; (; const Matrix_t & ; Y, . const Matrix_t & ; weights, . bool ; includeRegularization = true . ); const. inline . Evaluate the loss function of the net using the activations that are currently stored in the output layer. ; Definition at line 305 of file Net.h. ◆ Loss() [2/2]. template<typename Architecture_t , typename Layer_t > . auto TMVA::DNN::TNet< Architecture_t, Layer_t >::Loss ; (; Matrix_t & ; X, . const Matrix_t & ; Y, . const Matrix_t & ; weights, . bool ; applyDropout = false, . bool ; includeRegularization = true . ). inline . Propagate the input batch X through the net and evaluate the error function for the resulting activations of the output layer. ; Definition at line 320 of file Net.h. ◆ Prediction() [1/2]. template<typename Architecture_t , typename Layer_t > . void TMVA::DNN::TNet< Architecture_t, Layer_t >::Prediction ; (; Matrix_t & ; Y_hat, . EOutputFunction ; f . ); const. inline . Compute the neural network prediction obtained from applying the output function f to the activation of the last layer in the network. ; Definition at line 339 of file Net.h. ◆ Prediction() [2/2]. template<typename Architecture_t , typename Layer_t > . void TMVA::DNN::TNet< Architecture_t, Layer_t >::Prediction ; (; Matrix_t & ; Y_hat, . Matrix_t & ; X, . EOutputFunction ; f . ). inline . Compute the neural network prediction obtained from forwarding the batch X through the neural network and applying the output function f to the activation of the last layer in the network. ; Definition at line 329 of file Net.h. ◆ Print(). template<typename Architecture_t , typename Layer_t > . void TMVA::DNN::TNet< Architecture_t, Layer_t >::Print. Definition at line 392 of file Net.h. ◆ SetBatchSize(). temp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TNet.html:13714,Predict,Prediction,13714,doc/master/classTMVA_1_1DNN_1_1TNet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TNet.html,1,['Predict'],['Prediction']
Safety," TMVA::MethodRSNNS::fModel. protected . Definition at line 116 of file MethodRSNNS.h. ◆ fMvaCounter. UInt_t TMVA::MethodRSNNS::fMvaCounter. protected . Definition at line 84 of file MethodRSNNS.h. ◆ fNetType. TString TMVA::MethodRSNNS::fNetType. protected . Definition at line 88 of file MethodRSNNS.h. ◆ fProbResultForTestSig. std::vector<Float_t> TMVA::MethodRSNNS::fProbResultForTestSig. protected . Definition at line 86 of file MethodRSNNS.h. ◆ fProbResultForTrainSig. std::vector<Float_t> TMVA::MethodRSNNS::fProbResultForTrainSig. protected . Definition at line 85 of file MethodRSNNS.h. ◆ fPruneFunc. TString TMVA::MethodRSNNS::fPruneFunc. protected . Definition at line 106 of file MethodRSNNS.h. ◆ fPruneFuncParams. TString TMVA::MethodRSNNS::fPruneFuncParams. protected . Definition at line 107 of file MethodRSNNS.h. ◆ fShufflePatterns. Bool_t TMVA::MethodRSNNS::fShufflePatterns. protected . Definition at line 103 of file MethodRSNNS.h. ◆ fSize. TString TMVA::MethodRSNNS::fSize. protected . Definition at line 90 of file MethodRSNNS.h. ◆ fUpdateFunc. TString TMVA::MethodRSNNS::fUpdateFunc. protected . Definition at line 99 of file MethodRSNNS.h. ◆ fUpdateFuncParams. TString TMVA::MethodRSNNS::fUpdateFuncParams. protected . Definition at line 100 of file MethodRSNNS.h. ◆ IsModuleLoaded. Bool_t MethodRSNNS::IsModuleLoaded = ROOT::R::TRInterface::Instance().Require(""RSNNS""). staticprotected . Definition at line 112 of file MethodRSNNS.h. ◆ mlp. ROOT::R::TRFunctionImport TMVA::MethodRSNNS::mlp. protected . Definition at line 114 of file MethodRSNNS.h. ◆ predict. ROOT::R::TRFunctionImport TMVA::MethodRSNNS::predict. protected . Definition at line 113 of file MethodRSNNS.h. Libraries for TMVA::MethodRSNNS:. [legend]; The documentation for this class was generated from the following files:; tmva/rmva/inc/TMVA/MethodRSNNS.h; tmva/rmva/src/MethodRSNNS.cxx. TMVAMethodRSNNS. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:37 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodRSNNS.html:35532,predict,predict,35532,doc/master/classTMVA_1_1MethodRSNNS.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodRSNNS.html,2,['predict'],['predict']
Safety," TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::fTimeUpdttime between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. TList*fActivenodes with unfinished files; Bool_tfDefMaxWrkNodeWhether the default is used for the max workers per node; TList*fFileNodesnodes with files; Bool_tfHeuristicPSizWhether the packet size is calculated heuristically; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Int_tfPacketAsAFractionused to calculate the packet size; Long64_tfPacketSizeglobal base packet size; TList*fPacketsall processed packets; TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizer(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizer(); Destructor. Int_t AddWorkers(TList* workers); Adds new workers. Returns the number of workers added, or -1 on failure. void RemoveUnAllocNode(TPacketizer::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizer::TFileStat* file); Remove file from the list of actives. void RemoveActiveNode(TPacketizer::TFileNode* ); Remove node from the list of actives. void Reset(); Reset the internal datastructure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TPacketizer.html:11070,avoid,avoid,11070,root/html604/TPacketizer.html,https://root.cern,https://root.cern/root/html604/TPacketizer.html,1,['avoid'],['avoid']
Safety," TNetXNGSystem(Bool_t owner = kTRUE); TNetXNGSystem(const char* url, Bool_t owner = kTRUE); virtual~TNetXNGSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tTSystem::AccessPathName(const char* path, EAccessMode mode = kFileExists); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intTSystem::AnnounceUdpService(int port, int backlog); virtual intTSystem::AnnounceUnixService(int port, int backlog); virtual intTSystem::AnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tTSystem::ChangeDirectory(const char* path); virtual intTSystem::Chmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetXNGSystem.html:609,Abort,Abort,609,root/html534/TNetXNGSystem.html,https://root.cern,https://root.cern/root/html534/TNetXNGSystem.html,1,['Abort'],['Abort']
Safety," TO YOU; FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR; CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE; LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING; RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A; FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF; SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH; DAMAGES. END OF TERMS AND CONDITIONS; ; How to Apply These Terms to Your New Libraries. If you develop a new library, and you want it to be of the greatest; possible use to the public, we recommend making it free software that; everyone can redistribute and change. You can do so by permitting; redistribution under these terms (or, alternatively, under the terms of the; ordinary General Public License). To apply these terms, attach the following notices to the library. It is; safest to attach them to the start of each source file to most effectively; convey the exclusion of warranty; and each file should have at least the; ""copyright"" line and a pointer to where the full notice is found. <one line to give the library's name and a brief idea of what it does>; Copyright (C) <year> <name of author>. This library is free software; you can redistribute it and/or; modify it under the terms of the GNU Lesser General Public; License as published by the Free Software Foundation; either; version 2.1 of the License, or (at your option) any later version. This library is distributed in the hope that it will be useful,; but WITHOUT ANY WARRANTY; without even the implied warranty of; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public; License along with this library; if not, write to the Free Software; Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA. Also add information on how to contact you by electronic and paper mail. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/license.html:27075,safe,safest,27075,d/license.html,https://root.cern,https://root.cern/d/license.html,1,['safe'],['safest']
Safety," TObject destructor. Each TProcessID has a table (TObjArray *fObjects) that keeps track of all referenced objects. If a referenced object has a fUniqueID, a pointer to this unique object may be found using fObjects->At(fUniqueID). In the same way, when a TRef::GetObject is called, GetObject uses its own fUniqueID to find the pointer to the referenced object. See TProcessID::GetObjectWithID and PutObjectWithID.; 11.4.4.2 Object Number; When an object is referenced, a unique identifier is computed and stored in both the fUniqueID of the referenced and referencing object. This uniqueID is computed by incrementing by one the static global in TProcessID::fgNumber. The fUniqueID is the serial object number in the current session. One can retrieve the current fgNumber value by calling the static function TProcessID::GetObjectCount at any time or can set this number by TProcessID::SetObjectCount. To avoid a growing table of fObjects in TProcessID, in case, for example, one processes many events in a loop, it might be necessary to reset the object number at the end of processing of one event. See an example in $ROOTSYS/test/Event.cxx (look at function Build). The value of ObjectNumbermay be saved at the beginning of one event and reset to this original value at the end of the event. These actions may be nested.; saveNumber = TProcessID::GetObjectCount();; ...; TProcessID::SetObjectCount(savedNumber);; 11.4.5 Action on Demand; The normal behavior of a TRef has been described above. In addition, TRef supports “Actions on Demand”. It may happen that the referenced object is not yet in the memory, on a separate file or not yet computed. In this case, TRef is able to execute automatically an action:. Call to a compiled function (static function of member function); Call to an interpreted function; Execution of a Cling script. 11.4.5.1 How to Select This Option?; In the definition of the TRef data member in the original class, do:; TRef fRef; //EXEC:execName points to something; Wh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:485035,avoid,avoid,485035,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avoid'],['avoid']
Safety," TObject*Next(); booloperator!=(const TIter& aIter) const; TObject*operator()(); TObject*operator*() const; TIter&operator++(); TIter&operator=(const TIter& rhs); voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TIter(). Data Members; private:. TIterator*fIteratorcollection iterator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TIter(const TIter& iter); Copy a TIter. This involves allocating a new TIterator of the right; sub class and assigning it with the original. TIter & operator=(const TIter& rhs); Assigning an TIter to another. This involves allocatiing a new TIterator; of the right sub class and assigning it with the original. TIter & Begin(); Pointing to the first element of the container. TIter End(); Pointing to the element after the last - to a nullptr value in our case. TObject * operator()(const char *name). TIter(); { }. TIter(const TCollection* col, Bool_t dir = kIterForward); { }. TIter(TIterator* it); { }. virtual ~TIter(); { SafeDelete(fIterator); }. TObject * Next(); { return fIterator ? fIterator->Next() : nullptr; }. const TCollection * GetCollection() const; { return fIterator ? fIterator->GetCollection() : nullptr; }. Option_t * GetOption() const; { return fIterator ? fIterator->GetOption() : """"; }. void Reset(); { if (fIterator) fIterator->Reset(); }. TIter & operator++(); { Next(); return *this; }. bool operator!=(const TIter& aIter) const; { return ((*fIterator) != *(aIter.fIterator)); }. TObject * operator*() const; { return *(*fIterator); }. » Author: Fons Rademakers 13/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: TCollection.h 37411 2010-12-08 17:42:11Z pcanal $ » Last generated: 2010-12-08 19:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TIter.html:2584,Safe,SafeDelete,2584,root/html528/TIter.html,https://root.cern,https://root.cern/root/html528/TIter.html,1,['Safe'],['SafeDelete']
Safety," TObject*Next(); booloperator!=(const TIter& aIter) const; TObject*operator()(); TObject*operator*() const; TIter&operator++(); TIter&operator=(const TIter& rhs); voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TIter(). Data Members; private:. TIterator*fIteratorcollection iterator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TIter(const TIter& iter); Copy a TIter. This involves allocating a new TIterator of the right; sub class and assigning it with the original. TIter & operator=(const TIter& rhs); Assigning an TIter to another. This involves allocatiing a new TIterator; of the right sub class and assigning it with the original. TIter & Begin(); Pointing to the first element of the container. TIter End(); Pointing to the element after the last - to a nullptr value in our case. TObject * operator()(const char *name). TIter(); { }. TIter(const TCollection* col, Bool_t dir = kIterForward); { }. TIter(TIterator* it); { }. virtual ~TIter(); { SafeDelete(fIterator); }. TObject * Next(); { return fIterator ? fIterator->Next() : nullptr; }. const TCollection * GetCollection() const; { return fIterator ? fIterator->GetCollection() : nullptr; }. Option_t * GetOption() const; { return fIterator ? fIterator->GetOption() : """"; }. void Reset(); { if (fIterator) fIterator->Reset(); }. TIter & operator++(); { Next(); return *this; }. bool operator!=(const TIter& aIter) const; { return ((*fIterator) != *(aIter.fIterator)); }. TObject * operator*() const; { return *(*fIterator); }. » Author: Fons Rademakers 13/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: TCollection.h 37411 2010-12-08 17:42:11Z pcanal $ » Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TIter.html:2584,Safe,SafeDelete,2584,root/html530/TIter.html,https://root.cern,https://root.cern/root/html530/TIter.html,1,['Safe'],['SafeDelete']
Safety," TObject*Next(); booloperator!=(const TIter& aIter) const; TObject*operator()(); TObject*operator*() const; TIter&operator++(); TIter&operator=(const TIter& rhs); voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TIter(). Data Members; private:. TIterator*fIteratorcollection iterator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TIter(const TIter& iter); Copy a TIter. This involves allocating a new TIterator of the right; sub class and assigning it with the original. TIter & operator=(const TIter& rhs); Assigning an TIter to another. This involves allocatiing a new TIterator; of the right sub class and assigning it with the original. TIter & Begin(); Pointing to the first element of the container. TIter End(); Pointing to the element after the last - to a nullptr value in our case. TObject * operator()(const char *name). TIter(); { }. TIter(const TCollection* col, Bool_t dir = kIterForward); { }. TIter(TIterator* it); { }. virtual ~TIter(); { SafeDelete(fIterator); }. TObject * Next(); { return fIterator ? fIterator->Next() : nullptr; }. const TCollection * GetCollection() const; { return fIterator ? fIterator->GetCollection() : nullptr; }. Option_t * GetOption() const; { return fIterator ? fIterator->GetOption() : """"; }. void Reset(); { if (fIterator) fIterator->Reset(); }. TIter & operator++(); { Next(); return *this; }. bool operator!=(const TIter& aIter) const; { return ((*fIterator) != *(aIter.fIterator)); }. TObject * operator*() const; { return *(*fIterator); }. » Author: Fons Rademakers 13/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: TCollection.h 37411 2010-12-08 17:42:11Z pcanal $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TIter.html:2584,Safe,SafeDelete,2584,root/html532/TIter.html,https://root.cern,https://root.cern/root/html532/TIter.html,1,['Safe'],['SafeDelete']
Safety," TProofDrawEntryList(); virtual~TProofDrawEntryList(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTProofDraw::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofDrawEntryList.html:491,Abort,Abort,491,root/html528/TProofDrawEntryList.html,https://root.cern,https://root.cern/root/html528/TProofDrawEntryList.html,4,['Abort'],['Abort']
Safety," TProofDrawEntryList, TProofDrawProfile, TProofDrawProfile2D, TProofDrawGraph, TProofDrawPolyMarker3D, TProofDrawListOfGraphs, and TProofDrawListOfPolyMarkers3D.; Definition at line 93 of file TProofDraw.h. ◆ Notify(). Bool_t TProofDraw::Notify ; (; ). overridevirtual . Called when a new tree is loaded. ; Reimplemented from TObject.; Definition at line 152 of file TProofDraw.cxx. ◆ Process(). Bool_t TProofDraw::Process ; (; Long64_t ; entry). overridevirtual . Executed for each entry. ; Reimplemented from TSelector.; Definition at line 244 of file TProofDraw.cxx. ◆ ProcessSingle(). Bool_t TProofDraw::ProcessSingle ; (; Long64_t ; entry, . Int_t ; i . ). protectedvirtual . Processes a single variable from an entry. ; Definition at line 217 of file TProofDraw.cxx. ◆ SetCanvas(). void TProofDraw::SetCanvas ; (; const char * ; objname). protected . Move to a canvas named <name>_canvas; create the canvas if not existing. ; Used to avoid screwing up existing plots when non default names are used for the final objects ; Definition at line 310 of file TProofDraw.cxx. ◆ SetDrawAtt(). void TProofDraw::SetDrawAtt ; (; TObject * ; o). protected . Set the drawing attributes from the input list. ; Definition at line 326 of file TProofDraw.cxx. ◆ SetError(). void TProofDraw::SetError ; (; const char * ; sub, . const char * ; mesg . ). protected . Sets the error status. ; Definition at line 383 of file TProofDraw.cxx. ◆ SlaveBegin(). void TProofDraw::SlaveBegin ; (; TTree * ; ). overridevirtual . Executed by each slave before processing. ; Reimplemented from TSelector.; Reimplemented in TProofDrawHist, TProofDrawEventList, TProofDrawEntryList, TProofDrawProfile, TProofDrawProfile2D, TProofDrawGraph, TProofDrawPolyMarker3D, TProofDrawListOfGraphs, and TProofDrawListOfPolyMarkers3D.; Definition at line 196 of file TProofDraw.cxx. ◆ SlaveTerminate(). void TProofDraw::SlaveTerminate ; (; void ; ). overridevirtual . Executed by each slave after the processing has finished, before return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDraw.html:18064,avoid,avoid,18064,doc/master/classTProofDraw.html,https://root.cern,https://root.cern/doc/master/classTProofDraw.html,1,['avoid'],['avoid']
Safety," TProofDrawEventList(); virtual~TProofDrawEventList(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTProofDraw::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofDrawEventList.html:491,Abort,Abort,491,root/html528/TProofDrawEventList.html,https://root.cern,https://root.cern/root/html528/TProofDrawEventList.html,4,['Abort'],['Abort']
Safety," TProofDrawGraph(); ~TProofDrawGraph(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTProofDraw::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofDrawGraph.html:464,Abort,Abort,464,root/html528/TProofDrawGraph.html,https://root.cern,https://root.cern/root/html528/TProofDrawGraph.html,4,['Abort'],['Abort']
Safety," TProofDrawHist(); ~TProofDrawHist(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelector::GetEntry(Lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofDrawHist.html:459,Abort,Abort,459,root/html528/TProofDrawHist.html,https://root.cern,https://root.cern/root/html528/TProofDrawHist.html,4,['Abort'],['Abort']
Safety," TProofDrawListOfGraphs(); ~TProofDrawListOfGraphs(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTProofDraw::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofDrawListOfGraphs.html:499,Abort,Abort,499,root/html528/TProofDrawListOfGraphs.html,https://root.cern,https://root.cern/root/html528/TProofDrawListOfGraphs.html,4,['Abort'],['Abort']
Safety," TProofDrawListOfPolyMarkers3D(); ~TProofDrawListOfPolyMarkers3D(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTProofDraw::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOpt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofDrawListOfPolyMarkers3D.html:534,Abort,Abort,534,root/html528/TProofDrawListOfPolyMarkers3D.html,https://root.cern,https://root.cern/root/html528/TProofDrawListOfPolyMarkers3D.html,4,['Abort'],['Abort']
Safety," TProofDrawPolyMarker3D(); ~TProofDrawPolyMarker3D(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTProofDraw::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofDrawPolyMarker3D.html:499,Abort,Abort,499,root/html528/TProofDrawPolyMarker3D.html,https://root.cern,https://root.cern/root/html528/TProofDrawPolyMarker3D.html,4,['Abort'],['Abort']
Safety," TProofDrawProfile(); ~TProofDrawProfile(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofDrawProfile.html:474,Abort,Abort,474,root/html528/TProofDrawProfile.html,https://root.cern,https://root.cern/root/html528/TProofDrawProfile.html,4,['Abort'],['Abort']
Safety," TProofDrawProfile2D(); ~TProofDrawProfile2D(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofDrawProfile2D.html:484,Abort,Abort,484,root/html528/TProofDrawProfile2D.html,https://root.cern,https://root.cern/root/html528/TProofDrawProfile2D.html,4,['Abort'],['Abort']
Safety," TRFIOSystem(); virtual~TRFIOSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TRFIOSystem.html:1561,Abort,Abort,1561,root/html530/TRFIOSystem.html,https://root.cern,https://root.cern/root/html530/TRFIOSystem.html,2,['Abort'],['Abort']
Safety," TSelVerifyDataSet(); TSelVerifyDataSet(TTree*); virtual~TSelVerifyDataSet(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Lon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSelVerifyDataSet.html:523,Abort,Abort,523,root/html534/TSelVerifyDataSet.html,https://root.cern,https://root.cern/root/html534/TSelVerifyDataSet.html,1,['Abort'],['Abort']
Safety," TSelectorCint(); virtual~TSelectorCint(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* tree); virtual voidTObject::Browse(TBrowser* b); virtual voidBuild(TSelector* iselector, ClassInfo_t* cl, Bool_t isowner = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortGetAbort() const; virtual Option_t*TObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSelectorCint.html:480,Abort,Abort,480,root/html528/TSelectorCint.html,https://root.cern,https://root.cern/root/html528/TSelectorCint.html,1,['Abort'],['Abort']
Safety," TSelectorDraw(); virtual~TSelectorDraw(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* tree); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Int_tGetAction() const; virtual Bool_tGetCleanElist() const; virtual Int_tGetDimension() const; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSelectorDraw.html:466,Abort,Abort,466,root/html528/TSelectorDraw.html,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html,4,['Abort'],['Abort']
Safety," TSelectorEntries(const char* selection); TSelectorEntries(TTree* tree = 0, const char* selection = 0); virtual~TSelectorEntries(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* tree); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSelectorEntries.html:900,Abort,Abort,900,root/html530/TSelectorEntries.html,https://root.cern,https://root.cern/root/html530/TSelectorEntries.html,3,['Abort'],['Abort']
Safety," TSelectorEntries(const char* selection); TSelectorEntries(TTree* tree = 0, const char* selection = 0); virtual~TSelectorEntries(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* tree); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSelectorEntries.html:898,Abort,Abort,898,root/html528/TSelectorEntries.html,https://root.cern,https://root.cern/root/html528/TSelectorEntries.html,1,['Abort'],['Abort']
Safety," TString macroPath;; 478 return macroPath;; 479 }; 480 ; 481 // clang-format off; 482 ////////////////////////////////////////////////////////////////////////////////; 483 /// Enables the global mutex to make ROOT thread safe/aware.; 484 ///; 485 /// The following becomes safe:; 486 /// - concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); 487 /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; 489 /// - concurrent calls to the interpreter through gInterpreter; 490 /// - concurrent loading of ROOT plug-ins; 491 ///; 492 /// In addition, gDirectory, gFile and gPad become a thread-local variable.; 493 /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.; 494 /// gFile and gPad default to nullptr, as it is for single-thread programs.; 495 ///; 496 /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; 497 /// canvases from different threads (and analogous operations such as invoking `Draw` on a `TObject`) is not thread-safe.; 498 ///; 499 /// Note that there is no `DisableThreadSafety()`. ROOT's thread-safety features cannot be disabled once activated.; 500 // clang-format on; 501 void EnableThreadSafety(); 502 {; 503 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TThread_Initialize"");; 504 if (sym); 505 sym();; 506 }; 507 ; 508 ////////////////////////////////////////////////////////////////////////////////; 509 /// @param[in] numthreads Number of threads to use. If not specified or; 510 /// set to zero, the number of threads is automatically; 511 /// decided by the implementation. Any other",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:17660,safe,safe,17660,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['safe'],['safe']
Safety," TString fSoExt;  ; TSeqCollection * fStdExceptionHandler {nullptr};  ; TList * fTimers {nullptr};  ; TString fWdpath;  ; TFdSet * fWritemask {nullptr};  Files that should be checked for read events. ;  ; TFdSet * fWriteready {nullptr};  Files with reads waiting. ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . #include <TWinNTSystem.h>. Inheritance diagram for TWinNTSystem:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ ThreadMsgFunc_t. typedef Bool_t(* TWinNTSystem::ThreadMsgFunc_t) (MSG *). Definition at line 61 of file TWinNTSystem.h. Constructor & Destructor Documentation. ◆ TWinNTSystem(). TWinNTSystem::TWinNTSystem ; (; ). ctor ; Definition at line 985 of file TWinNTSystem.cxx. ◆ ~TWinNTSystem(). TWinNTSystem::~TWinNTSystem ; (; ). virtual . dtor ; Definition at line 1048 of file TWinNTSystem.cxx. Member Function Documentation. ◆ Abort(). void TWinNTSystem::Abort ; (; int ; code = 0). overridevirtual . Abort the application. ; Reimplemented from TSystem.; Definition at line 3949 of file TWinNTSystem.cxx. ◆ AcceptConnection(). int TWinNTSystem::AcceptConnection ; (; int ; socket). overridevirtual . Accept a connection. ; In case of an error return -1. In case non-blocking I/O is enabled and no connections are available return -2. ; Reimplemented from TSystem.; Definition at line 5525 of file TWinNTSystem.cxx. ◆ AccessPathName(). Bool_t TWinNTSystem::AccessPathName ; (; const char * ; path, . EAccessMode ; mode = kFileExists . ). overridevirtual . Returns FALSE if one can access a file using the specified access mode. ; Mode is the same as for the WinNT access(2) function. Attention, bizarre convention of return value!! ; Reimplemented from TSystem.; Definition at line 2557 of file TWinNTSystem.cxx. ◆ AddDynamicPath(). void TWinNTSystem::AddDynamicPath ; (; const char * ; dir). overridevirtual . Add a new directory to the dynamic path. ; Reimpl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:37195,Abort,Abort,37195,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['Abort'],['Abort']
