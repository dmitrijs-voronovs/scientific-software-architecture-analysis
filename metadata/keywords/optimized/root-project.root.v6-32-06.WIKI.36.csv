quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Energy Efficiency,"nadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); TMVA::KDEKernel&operator=(const TMVA::KDEKernel&); voidSetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum EKernelType { kNone; kGauss; };; enum EKernelIter { kNonadaptiveKDE; kAdaptiveKDE; };; enum EKernelBorder { kNoTreatment; kKernelRenorm; kSampleMirror; };. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the ; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE ; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__KDEKernel.html:1913,adapt,adaptive,1913,root/html534/TMVA__KDEKernel.html,https://root.cern,https://root.cern/root/html534/TMVA__KDEKernel.html,1,['adapt'],['adaptive']
Energy Efficiency,"name are optional. If tree_name is missing,; the chain name will be assumed.; In the file name part (but not in preceding directories) wildcarding; notation may be used, eg. specifying ""xxx*.root"" adds all files starting; with xxx in the current file system directory.; NB. To add all the files of a TChain to a chain, use Add(TChain *chain). A- if nentries <= 0, the file is connected and the tree header read; in memory to get the number of entries. B- if (nentries > 0, the file is not connected, nentries is assumed to be; the number of entries in the file. In this case, no check is made that; the file exists and the Tree existing in the file. This second mode; is interesting in case the number of entries in the file is already stored; in a run data base for example. C- if (nentries == kBigNumber) (default), the file is not connected.; the number of entries in each file will be read only when the file; will need to be connected to read an entry.; This option is the default and very efficient if one process; the chain sequentially. Note that in case TChain::GetEntry(entry); is called and entry refers to an entry in the 3rd file, for example,; this forces the Tree headers in the first and second file; to be read to find the number of entries in these files.; Note that if one calls TChain::GetEntriesFast() after having created; a chain with this default, GetEntriesFast will return kBigNumber!; TChain::GetEntries will force of the Tree headers in the chain to be; read to read the number of entries in each Tree. D- The TChain data structure; Each TChainElement has a name equal to the tree name of this TChain; and a title equal to the file name. So, to loop over the; TFiles that have been added to this chain:. TObjArray *fileElements=chain->GetListOfFiles();; TIter next(fileElements);; TChainElement *chEl=0;; while (( chEl=(TChainElement*)next() )) {; TFile f(chEl->GetTitle());; ... do something with f ...; }. Return value:. If nentries>0 (including the default of kBigNumber",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TChain.html:29151,efficient,efficient,29151,root/html532/TChain.html,https://root.cern,https://root.cern/root/html532/TChain.html,1,['efficient'],['efficient']
Energy Efficiency,"name are optional. If tree_name is missing,; the chain name will be assumed.; In the file name part (but not in preceding directories) wildcarding; notation may be used, eg. specifying ""xxx*.root"" adds all files starting; with xxx in the current file system directory.; NB. To add all the files of a TChain to a chain, use Add(TChain *chain). A- if nentries <= 0, the file is connected and the tree header read; in memory to get the number of entries. B- if (nentries > 0, the file is not connected, nentries is assumed to be; the number of entries in the file. In this case, no check is made that; the file exists and the Tree existing in the file. This second mode; is interesting in case the number of entries in the file is already stored; in a run data base for example. C- if (nentries == kBigNumber) (default), the file is not connected.; the number of entries in each file will be read only when the file; will need to be connected to read an entry.; This option is the default and very efficient if one process; the chain sequentially. Note that in case TChain::GetEntry(entry); is called and entry refers to an entry in the 3rd file, for example,; this forces the Tree headers in the first and second file; to be read to find the number of entries in these files.; Note that if one calls TChain::GetEntriesFast() after having created; a chain with this default, GetEntriesFast will return kBigNumber!; TChain::GetEntries will force of the Tree headers in the chain to be; read to read the number of entries in each Tree. D- The TChain data structure; Each TChainElement has a name equal to the tree name of this TChain; and a title equal to the file name. So, to loop over the; TFiles that have been added to this chain:. TObjArray *fileElements=chain->GetListOfFiles();; TIter next(fileElements);; TChainElement *chEl=0;; while (( chEl=(TChainElement*)next() )) {; TFile f(chEl->GetTitle());; ... do something with f ...; }. The function returns the total number of files connected. Int_t A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TChain.html:27162,efficient,efficient,27162,root/html526/TChain.html,https://root.cern,https://root.cern/root/html526/TChain.html,3,['efficient'],['efficient']
Energy Efficiency,"name! hostname of MonaLisa server; Bool_tfInitializedtrue if initialized; TStringfJobId! job id; Double_tfLastFCloseSendTimeIn order not to flood ML servers; time_tfLastProgressTimetimestamp of the last send command for player process; Double_tfLastRWSendTimetimestamp of the last send command for file reads/writes; map<UInt_t,MonitoredTFileInfo*>*fMonInfoRepo! repo to gather per-file-instance mon info;; Int_tfPid! process id; Int_tfReportIntervalinterval after which to send the latest value; TStopwatchfStopwatchcpu and time measurement for job and proc status; TStringfSubJobId! sub job id; Bool_tfVerboseverbocity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonaLisaWriter(const char* monserver, const char* montag, const char* monid = 0, const char* monsubid = 0, const char* option = """"); Create MonaLisa write object. void Init(const char* monserver, const char* montag, const char* monid, const char* monsubid, const char* option); Creates a TMonaLisaWriter object to send monitoring information to a; MonaLisa server using the MonaLisa ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.0.6.tar.gz. The ROOT implementation is primary optimized for process/job monitoring,; although all other generic MonaLisa ApMon functionality can be exploited; through the ApMon class directly (gMonitoringWriter->GetApMon()). Monitoring information in MonaLisa is structured in the following tree; structure:; <farmname>; |; ---> <nodename1>; |; ---> <key1> - <value1>; ---> <key2> - <value2>; ---> <nodename2>; |; ---> <key3> - <value3>; ---> <key4> - <value4>. The parameter monid is equivalent to the MonaLisa node name, for the; case of process monitoring it can be just an identifier to classify; the type of jobs e.g. ""PROOF_PROCESSING"".; If monid is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMonaLisaWriter.html:9478,monitor,monitoring,9478,root/html530/TMonaLisaWriter.html,https://root.cern,https://root.cern/root/html530/TMonaLisaWriter.html,2,['monitor'],['monitoring']
Energy Efficiency,"namePtr () const;  De-duplicated pointer to this object's name. ;  ; virtual Int_t numEntries () const;  Return number of entries in dataset, i.e., count unweighted entries. ;  ; RooAbsData & operator= (const RooAbsData &other);  ; void Print (Option_t *options=nullptr) const override;  This method must be overridden when a class wants to print itself. ;  ; void printClassName (std::ostream &os) const override;  Print class name of dataset. ;  ; void printName (std::ostream &os) const override;  Print name of dataset. ;  ; void printTitle (std::ostream &os) const override;  Print title of dataset. ;  ; void RecursiveRemove (TObject *obj) override;  If one of the TObject we have a referenced to is deleted, remove the reference. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const char *cut) const;  Create a subset of the data set by applying the given cut on the data points. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooArgSet &varSubset, const char *cut=nullptr) const;  Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooArgSet &varSubset, const RooFormulaVar &cutVar) const;  Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  Create a reduced copy of this dataset. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooFormulaVar &cutVar) const;  Create a subset of the data set by applying the given cut on the data points. ;  ; void resetBuffers ();  ; RooRealVar * rmsVar (const RooRealVar &var, const char *cutSpec=nullptr, const char *cutRange=nullptr) const;  Create a RooRealVar containing the RMS of observ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:18478,reduce,reduce,18478,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['reduce'],['reduce']
Energy Efficiency,"namely ""1111""; std::cout << TString::Itoa(15,2) ;; std::cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; std::cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; In case of error returns the ""!"" string. TString UItoa(UInt_t value, Int_t base); Converts a UInt_t (twice the range of an Int_t) to a TString with respect; to the base specified (2-36). Thus it is an enhanced version of sprintf; (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString LLtoa(Long64_t value, Int_t base); Converts a Long64_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString ULLtoa(ULong64_t value, Int_t base); Converts a ULong64_t (twice the range of an Long64_t) to a TString with; respect to the base specified (2-36). Thus it is an enhanced version of; sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString BaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); Converts string from base base_in to base base_out. Supported bases; are 2-36. At most 64 bit data can be converted. Bool_t EndsWith(const char* pat, TString::ECaseCompare cmp = kExact) const; Return true if string ends with the specified string. TObjArray * Tokenize(const TString& delim) const; This function is used to isolate sequential tokens in a TString.; These tokens are separated in the string by at least one of the; characters in delim. The returned array contains the tokens; as TObjString's. The returned array is the owner of the objects,; and must be deleted by the user. void FormImp(const char* fmt, va_list ap); Formats a string using a printf style format descriptor.; Existing string contents will be overwritten. void Form(const char *va_(fmt), ...); Formats a string using a p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TString.html:19494,adapt,adapted,19494,root/html602/TString.html,https://root.cern,https://root.cern/root/html602/TString.html,2,['adapt'],['adapted']
Energy Efficiency,"napsesarray of pointers to synapses, no structural data; boolTMVA::MethodANNBase::fUseRegulatorzjh; TRandom3*TMVA::MethodANNBase::frgenrandom number generator for various uses. private:. TMVA::MethodMLP::EBPTrainingModefBPModebackprop learning mode (sequential or batch); Int_tfBatchSizebatch size, only matters if in batch learning mode; TStringfBpModeSbackprop learning mode option string (sequential or batch); boolfCalculateErrorscompute inverse hessian matrix at the end of the training; Double_tfDecayRatedecay rate for above learning rate; Bool_tfEpochMoncreate and fill epoch-wise monitoring histograms (makes outputfile big!); Double_tfGA_SC_factorGA settings: SC_factor; Int_tfGA_SC_rateGA settings: SC_rate; Int_tfGA_SC_stepsGA settings: SC_steps; Int_tfGA_nstepsGA settings: number of steps; Int_tfGA_preCalcGA settings: number of pre-calc steps; Double_tfLastAlphaline search variable; Double_tfLearnRatelearning rate for synapse weight adjustments; Double_tfPriorzjh; vector<Double_t>fPriorDevzjh; Int_tfResetStepreset time (how often we clear hessian matrix); Float_tfSamplingEpochfraction of epochs where sampling is used; Float_tfSamplingFractionfraction of events which is sampled for training; Bool_tfSamplingTestingThe testing sample is sampled; Bool_tfSamplingTrainingThe training sample is sampled; Float_tfSamplingWeightchanging factor for event weights when sampling is turned on; Double_tfTauline search variable; Int_tfTestRatetest for overtraining performed at each #th epochs; TStringfTrainMethodStraining method option param; TMVA::MethodMLP::ETrainingMethodfTrainingMethodmethod of training, BP or GA; Int_tfUpdateLimitzjh; boolfUseRegulatorzjh; static const Bool_tfgPRINT_BATCHdebug flags; static const Int_tfgPRINT_ESTIMATOR_INCdebug flags; static const Bool_tfgPRINT_SEQdebug flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodMLP.html:20425,monitor,monitoring,20425,root/html528/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodMLP.html,1,['monitor'],['monitoring']
Energy Efficiency,"nates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html:15538,energy,energy,15538,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,1,['energy'],['energy']
Energy Efficiency,"nates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html:15538,energy,energy,15538,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,1,['energy'],['energy']
Energy Efficiency,"nbins,xmin,xmax);; TH1F *d = new TH1F(""d"","""",nbins,xmin,xmax);; TFile *f = new TFile(""spectra\\TSpectrum.root"");; back=(TH1F*) f->Get(""back1;1"");; TCanvas *Background = gROOT->GetListOfCanvases()->FindObject(""Background"");; if (!Background) Background =; new TCanvas(""Background"",""Estimation of background with decreasing window"",; 10,10,1000,700);; back->Draw(""L"");; TSpectrum *s = new TSpectrum();; for (i = 0; i < nbins; i++) source[i]=back->GetBinContent(i + 1);; s->Background(source,nbins,6,kBackDecreasingWindow,kBackOrder2,kFALSE,; kBackSmoothing3,kFALSE);; for (i = 0; i < nbins; i++) d->SetBinContent(i + 1,source[i]);; d->SetLineColor(kRed);; d->Draw(""SAME L"");; }. Example 3 script Background_width.c:. The question is how to choose the width of the clipping window, i.e.,; numberIterations parameter. The influence of this parameter on the estimated; background is illustrated in Figure 3. Figure 3 Example of the influence of clipping window width on the estimated; background for numberIterations=4 (red line), 6 (blue line) 8 (green line) using; decreasing clipping window algorithm. in general one should set this parameter so that the value; 2*numberIterations+1 was greater than the widths of preserved objects (peaks). Script:. // Example to illustrate the influence of the clipping window width on the; // estimated background. To execute this example, do:; // root > .x Background_width.C; #include ; void Background_width() {; Int_t i;; Double_t nbins = 256;; Double_t xmin = 0;; Double_t xmax = (Double_t)nbins;; Float_t * source = new float[nbins];; TH1F *h = new TH1F(""h"","""",nbins,xmin,xmax);; TH1F *d1 = new TH1F(""d1"","""",nbins,xmin,xmax);; TH1F *d2 = new TH1F(""d2"","""",nbins,xmin,xmax);; TH1F *d3 = new TH1F(""d3"","""",nbins,xmin,xmax);; TFile *f = new TFile(""spectra\\TSpectrum.root"");; h=(TH1F*) f->Get(""back1;1"");; TCanvas *background = gROOT->GetListOfCanvases()->FindObject(""background"");; if (!background) background = new TCanvas(""background"",; ""Influence of clipping win",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum.html:18378,green,green,18378,root/html528/TSpectrum.html,https://root.cern,https://root.cern/root/html528/TSpectrum.html,4,['green'],['green']
Energy Efficiency,"nbins,xmin,xmax);; TH1F *d = new TH1F(""d"","""",nbins,xmin,xmax);; TFile *f = new TFile(""spectra\\TSpectrum.root"");; back=(TH1F*) f->Get(""back1;1"");; TCanvas *Background = gROOT->GetListOfCanvases()->FindObject(""Background"");; if (!Background) Background =; new TCanvas(""Background"",""Estimation of background with decreasing window"",; 10,10,1000,700);; back->Draw(""L"");; TSpectrum *s = new TSpectrum();; for (i = 0; i < nbins; i++) source[i]=back->GetBinContent(i + 1);; s->Background(source,nbins,6,kBackDecreasingWindow,kBackOrder2,kFALSE,; kBackSmoothing3,kFALSE);; for (i = 0; i < nbins; i++) d->SetBinContent(i + 1,source[i]);; d->SetLineColor(kRed);; d->Draw(""SAME L"");; }. Example 3 script Background_width.c:. The question is how to choose the width of the clipping window, i.e.,; numberIterations parameter. The influence of this parameter on the estimated; background is illustrated in Figure 3. Figure 3 Example of the influence of clipping window width on the estimated; background for numberIterations=4 (red line), 6 (blue line) 8 (green line) using; decreasing clipping window algorithm. in general one should set this parameter so that the value; 2*numberIterations+1 was greater than the widths of preserved objects (peaks). Script:. // Example to illustrate the influence of the clipping window width on the; // estimated background. To execute this example, do:; // root > .x Background_width.C; #include ; void Background_width() {; Int_t i;; Double_t nbins = 256;; Double_t xmin = 0;; Double_t xmax = nbins;; Double_t * source = new Double_t[nbins];; TH1F *h = new TH1F(""h"","""",nbins,xmin,xmax);; TH1F *d1 = new TH1F(""d1"","""",nbins,xmin,xmax);; TH1F *d2 = new TH1F(""d2"","""",nbins,xmin,xmax);; TH1F *d3 = new TH1F(""d3"","""",nbins,xmin,xmax);; TFile *f = new TFile(""spectra\\TSpectrum.root"");; h=(TH1F*) f->Get(""back1;1"");; TCanvas *background = gROOT->GetListOfCanvases()->FindObject(""background"");; if (!background) background = new TCanvas(""background"",; ""Influence of clipping window wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum.html:19565,green,green,19565,root/html602/TSpectrum.html,https://root.cern,https://root.cern/root/html602/TSpectrum.html,2,['green'],['green']
Energy Efficiency,"nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t *&b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t *&c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t *&h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t *&ii); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t *&ll); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t *&ll); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t *&f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t *&d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferFile.html:26196,allocate,allocated,26196,root/html526/TBufferFile.html,https://root.cern,https://root.cern/root/html526/TBufferFile.html,1,['allocate'],['allocated']
Energy Efficiency,"nc, round, lround, llround; exp, exp2, expm1; log, log10, log2, log1p; pow; sqrt, cbrt; sin, cos, tan, asin, acos, atan, atan2, hypot; sinh, cosh, tanh, asinh, acosh; erf, erfc; lgamma, tgamma. If the VDT library is available, the following functions can be invoked. Internally the calculations are vectorized:; fast_expf, fast_logf, fast_sinf, fast_cosf, fast_tanf, fast_asinf, fast_acosf, fast_atanf; fast_exp, fast_log, fast_sin, fast_cos, fast_tan, fast_asin, fast_acos, fast_atan. Owning and adopting memory; RVec has contiguous memory associated to it. It can own it or simply adopt it. In the latter case, it can be constructed with the address of the memory associated to it and its length. For example: std::vector<int> myStlVec {1,2,3};; RVec<int> myRVec(myStlVec.data(), myStlVec.size());; In this case, the memory associated to myStlVec and myRVec is the same, myRVec simply ""adopted it"". If any method which implies a re-allocation is called, e.g. emplace_back or resize, the adopted memory is released and new one is allocated. The previous content is copied in the new memory and preserved. Sorting and manipulation of indices. Sorting; RVec complies to the STL interfaces when it comes to iterations. As a result, standard algorithms can be used, for example sorting: RVec<double> v{6., 4., 5.};; std::sort(v.begin(), v.end());; v@ vDefinition rootcling_impl.cxx:3687; For convenience, helpers are provided too: auto sorted_v = Sort(v);; auto reversed_v = Reverse(v);; ROOT::VecOps::ReverseRVec< T > Reverse(const RVec< T > &v)Return copy of reversed vector.Definition RVec.hxx:2481; ROOT::VecOps::SortRVec< T > Sort(const RVec< T > &v)Return copy of RVec with elements sorted in ascending order.Definition RVec.hxx:2502. Manipulation of indices; It is also possible to manipulated the RVecs acting on their indices. For example, the following syntax RVecD v0 {9., 7., 8.};; auto v1 = Take(v0, {1, 2, 0});; ROOT::VecOps::TakeRVec< T > Take(const RVec< T > &v, const RVec< typename RVec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html:5150,allocate,allocated,5150,doc/v632/classROOT_1_1VecOps_1_1RVec.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html,1,['allocate'],['allocated']
Energy Efficiency,"nc, round, lround, llround; exp, exp2, expm1; log, log10, log2, log1p; pow; sqrt, cbrt; sin, cos, tan, asin, acos, atan, atan2, hypot; sinh, cosh, tanh, asinh, acosh; erf, erfc; lgamma, tgamma. If the VDT library is available, the following functions can be invoked. Internally the calculations are vectorized:; fast_expf, fast_logf, fast_sinf, fast_cosf, fast_tanf, fast_asinf, fast_acosf, fast_atanf; fast_exp, fast_log, fast_sin, fast_cos, fast_tan, fast_asin, fast_acos, fast_atan. Owning and adopting memory; RVec has contiguous memory associated to it. It can own it or simply adopt it. In the latter case, it can be constructed with the address of the memory associated to it and its length. For example: std::vector<int> myStlVec {1,2,3};; RVec<int> myRVec(myStlVec.data(), myStlVec.size());; In this case, the memory associated to myStlVec and myRVec is the same, myRVec simply ""adopted it"". If any method which implies a re-allocation is called, e.g. emplace_back or resize, the adopted memory is released and new one is allocated. The previous content is copied in the new memory and preserved. Sorting and manipulation of indices. Sorting; RVec complies to the STL interfaces when it comes to iterations. As a result, standard algorithms can be used, for example sorting: RVec<double> v{6., 4., 5.};; std::sort(v.begin(), v.end());; v@ vDefinition rootcling_impl.cxx:3699; For convenience, helpers are provided too: auto sorted_v = Sort(v);; auto reversed_v = Reverse(v);; ROOT::VecOps::ReverseRVec< T > Reverse(const RVec< T > &v)Return copy of reversed vector.Definition RVec.hxx:2481; ROOT::VecOps::SortRVec< T > Sort(const RVec< T > &v)Return copy of RVec with elements sorted in ascending order.Definition RVec.hxx:2502. Manipulation of indices; It is also possible to manipulated the RVecs acting on their indices. For example, the following syntax RVecD v0 {9., 7., 8.};; auto v1 = Take(v0, {1, 2, 0});; ROOT::VecOps::TakeRVec< T > Take(const RVec< T > &v, const RVec< typename RVec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html:5151,allocate,allocated,5151,doc/master/classROOT_1_1VecOps_1_1RVec.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html,1,['allocate'],['allocated']
Energy Efficiency,"nc_t GetStreamerFunc() constGet a wrapper/accessor function around this class custom streamer (member function).Definition TClass.cxx:2939; TClass::RemoveStreamerInfovoid RemoveStreamerInfo(Int_t slot)Remove and delete the StreamerInfo in the given slot.Definition TClass.cxx:7320; TClass::SetCanSplitvoid SetCanSplit(Int_t splitmode)Set the splitability of this class:Definition TClass.cxx:5658; TClass::CreateListOfDataMembersTList * CreateListOfDataMembers(std::atomic< TListOfDataMembers * > &data, TDictionary::EMemberSelection selection, bool load)Create the list containing the TDataMembers (of actual data members or members pulled in through usin...Definition TClass.cxx:3741; TClass::GetStreamerInfoAbstractEmulatedTVirtualStreamerInfo * GetStreamerInfoAbstractEmulated(Int_t version=0) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4709; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:4978; TClass::SetMergevoid SetMerge(ROOT::MergeFunc_t mergeFunc)Install a new wrapper around 'Merge'.Definition TClass.cxx:6969; TClass::fConversionStreamerInfoConvSIMap_t fConversionStreamerInfoDefinition TClass.h:199; TClass::fDirAutoAddROOT::DirAutoAdd_t fDirAutoAddDefinition TClass.h:240; TClass::HasDataMemberInfoBool_t HasDataMemberInfo() constDefinition TClass.h:407; TClass::fRefProxyTVirtualRefProxy * fRefProxycached streamer info used in the last read.Definition TClass.h:280; TClass::GetMenuListTList * GetMenuList() constReturn the list of menu items associated with the class.Definition TClass.cxx:4341; TClass::fMergeROOT::MergeFunc_t fMergesaved info to call a IsA member functionDefinition TClass.h:233; TClass::GetMethodTMethod * GetMethod(const char *method, const char *params, Bool_t objectIsConst=kFALSE)Find the best method (if there is one) matching the parameters.Definition T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:311919,allocate,allocated,311919,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"nc_t GetStreamerFunc() constGet a wrapper/accessor function around this class custom streamer (member function).Definition TClass.cxx:3006; TClass::RemoveStreamerInfovoid RemoveStreamerInfo(Int_t slot)Remove and delete the StreamerInfo in the given slot.Definition TClass.cxx:7387; TClass::SetCanSplitvoid SetCanSplit(Int_t splitmode)Set the splitability of this class:Definition TClass.cxx:5725; TClass::CreateListOfDataMembersTList * CreateListOfDataMembers(std::atomic< TListOfDataMembers * > &data, TDictionary::EMemberSelection selection, bool load)Create the list containing the TDataMembers (of actual data members or members pulled in through usin...Definition TClass.cxx:3808; TClass::GetStreamerInfoAbstractEmulatedTVirtualStreamerInfo * GetStreamerInfoAbstractEmulated(Int_t version=0) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4776; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::SetMergevoid SetMerge(ROOT::MergeFunc_t mergeFunc)Install a new wrapper around 'Merge'.Definition TClass.cxx:7036; TClass::fConversionStreamerInfoConvSIMap_t fConversionStreamerInfoDefinition TClass.h:199; TClass::fDirAutoAddROOT::DirAutoAdd_t fDirAutoAddDefinition TClass.h:240; TClass::HasDataMemberInfoBool_t HasDataMemberInfo() constDefinition TClass.h:407; TClass::fRefProxyTVirtualRefProxy * fRefProxycached streamer info used in the last read.Definition TClass.h:280; TClass::GetMenuListTList * GetMenuList() constReturn the list of menu items associated with the class.Definition TClass.cxx:4408; TClass::fMergeROOT::MergeFunc_t fMergesaved info to call a IsA member functionDefinition TClass.h:233; TClass::GetMethodTMethod * GetMethod(const char *method, const char *params, Bool_t objectIsConst=kFALSE)Find the best method (if there is one) matching the parameters.Definition T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:314557,allocate,allocated,314557,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"nce for all code required to be generated up to that point, also across different computation graphs.; Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See Activating RDataFrame execution logs. Memory usage; There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies of the results are destroyed when the final result is produced. Reducing the number of threads or using coarser binning will reduce the memory usage.; Secondly, just-in-time compilation of string expressions or non-templated actions (see the previous paragraph) causes Cling, ROOT's C++ interpreter, to allocate some memory for the generated code that is only released at the end of the application. This commonly results in memory usage creep in long-running applications that create many RDataFrames one after the other. Possible mitigations include creating and running each RDataFrame event loop in a sub-process, or booking all operations for all different RDataFrame computation graphs before the first event loop is triggered, so that the interpreter is invoked only once for all computation graphs:; // assuming df1 and df2 are separate computation graphs, do:; auto h1 = df1.Histo1D(""x"");; auto h2 = df2.Histo1D(""y"");; h1->Draw(); // we just-in-time compile everything needed by df1 and df2 here; h2->Draw(""SAME"");; ; // do not:; auto h1 = df1.Histo1D(""x"");; h1->Draw(); // we just-in-time compile",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:51316,reduce,reduce,51316,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['reduce'],['reduce']
Energy Efficiency,"nce the check is done elsewhere.; kForward (0x4) if set, ask server to forward the file to slave; or submaster (meaningless for slave servers).; kCpBin (0x8) Retrieve from the cache the binaries associated; with the file; kCp (0x10) Retrieve the files from the cache. Int_t SendObject(const TObject* obj, TProof::ESlaves list = kActive); Send object to master or slave servers. Returns number of slaves object; was sent to, -1 in case of error. Int_t SendPrint(Option_t* option = """"); Send print command to master server. Returns number of slaves message; was sent to. Returns -1 in case of error. void SetLogLevel(Int_t level, UInt_t mask = TProofDebug::kAll); Set server logging level. void SetRealTimeLog(Bool_t on = kTRUE); Switch ON/OFF the real-time logging facility. When this option is; ON, log messages from processing are sent back as they come, instead of; being sent back at the end in one go. This may help debugging or monitoring; in some cases, but, depending on the amount of log, it may have significant; consequencies on the load over the network, so it must be used with care. Int_t SetParallelSilent(Int_t nodes, Bool_t random = kFALSE); Tell PROOF how many slaves to use in parallel. If random is TRUE a random; selection is done (if nodes is less than the available nodes).; Returns the number of parallel slaves. Returns -1 in case of error. Int_t SetParallel(Int_t nodes = 9999, Bool_t random = kFALSE); Tell PROOF how many slaves to use in parallel. Returns the number of; parallel slaves. Returns -1 in case of error. Int_t GoParallel(Int_t nodes, Bool_t accept = kFALSE, Bool_t random = kFALSE); Go in parallel mode with at most ""nodes"" slaves. Since the fSlaves; list is sorted by slave performace the active list will contain first; the most performant nodes. Returns the number of active slaves.; If random is TRUE, and nodes is less than the number of available workers,; a random selection is done.; Returns -1 in case of error. void ShowData(); List contents of the d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:57869,monitor,monitoring,57869,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,3,['monitor'],['monitoring']
Energy Efficiency,"nced objects at each Tree::Fill, the branch numbers containing the referenced objects are saved in the table of references. When the Tree header is saved (via TTree::Write for example), the branch is saved, keeping the information with the pointers to the branches having referenced objects. Enabling this optional table, allow TTree::Draw to automatically load the branches needed to dereference a TRef (or TRefArray) object.; 12.7.3 Autosave; Autosave gives the option to save all branch buffers every n byte. We recommend using Autosave for large acquisitions. If the acquisition fails to complete, you can recover the file and all the contents since the last Autosave. To set the number of bytes between Autosave you can use the TTree::SetAutosave() method. You can also call TTree::Autosave in the acquisition loop every nentry.; 12.7.4 Trees with Circular Buffers; When a TTree is memory resident, you set it up so that it retains retain only the last few entries. For example, this can be very useful for monitoring purpose.; void TTree::SetCircular(Long64_t maxEntries);; where maxEntries is the maximum number of entries to be kept in the buffers. When the number of entries exceeds this value, the first entries in the Tree are deleted and the buffers used again. An example of a script using a circular buffer is shown below:; void circular() {; gROOT->cd(); //make sure that the Tree is memory resident; TTree *T = new TTree(""T"",""test circular buffers"");; TRandom r;; Float_t px,py,pz;; Double_t random;; UShort_t i;; T->Branch(""px"",&px,""px/F"");; T->Branch(""py"",&py,""py/F"");; T->Branch(""pz"",&pz,""pz/F"");; T->Branch(""random"",&random,""random/D"");; T->Branch(""i"",&i,""i/s"");; T->SetCircular(20000);; for (i = 0; i < 65000; i++) {; r.Rannor(px,py);; pz = px*px + py*py;; random = r.Rndm();; T->Fill();; }; T->Print();; }; 12.7.5 Size of TTree in the File; When writing a TTree to a file, if the file size reaches the value stored in the TTree::GetMaxTreeSize(), the current file is closed and a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:532581,monitor,monitoring,532581,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['monitor'],['monitoring']
Energy Efficiency,"ncludes; Libraries. Function documentation; TGeoHelix(); Dummy constructor. TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); Normal constructor. ~TGeoHelix(); Destructor. Double_t ComputeSafeStep(Double_t epsil = 1E-6) const; Compute safe linear step that can be made such that the error; between linear-helix extrapolation is less than EPSIL. void InitPoint(Double_t x0, Double_t y0, Double_t z0); Initialize coordinates of a point on the helix. void InitPoint(Double_t* point); Set initial point on the helix. void InitDirection(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHelix.html:8467,charge,charge,8467,root/html528/TGeoHelix.html,https://root.cern,https://root.cern/root/html528/TGeoHelix.html,8,['charge'],['charge']
Energy Efficiency,"ncolors); 3020{; 3021 for (int i = 0; i < ncolors; i++); 3022 if (pixel == orgcolors[i]) return i;; 3023 ; 3024 Error(""FindColor"", ""did not find color, should never happen!"");; 3025 ; 3026 return 0;; 3027}; 3028 ; 3029////////////////////////////////////////////////////////////////////////////////; 3030/// Set color intensities for given color index.; 3031///; 3032/// \param [in] cindex : color index; 3033/// \param [in] r,g,b : red, green, blue intensities between 0.0 and 1.0; 3034 ; 3035void TGX11::SetRGB(int cindex, float r, float g, float b); 3036{; 3037 if (fColormap) {; 3038 RXColor xcol;; 3039 xcol.red = (UShort_t)(r * kBIGGEST_RGB_VALUE);; 3040 xcol.green = (UShort_t)(g * kBIGGEST_RGB_VALUE);; 3041 xcol.blue = (UShort_t)(b * kBIGGEST_RGB_VALUE);; 3042 xcol.flags = DoRed | DoGreen | DoBlue;; 3043 XColor_t &col = GetColor(cindex);; 3044 if (col.fDefined) {; 3045 // if color is already defined with same rgb just return; 3046 if (col.fRed == xcol.red && col.fGreen == xcol.green &&; 3047 col.fBlue == xcol.blue); 3048 return;; 3049 col.fDefined = kFALSE;; 3050 if (fRedDiv == -1); 3051 XFreeColors((Display*)fDisplay, fColormap, &col.fPixel, 1, 0);; 3052 }; 3053 if (AllocColor(fColormap, &xcol)) {; 3054 col.fDefined = kTRUE;; 3055 col.fPixel = xcol.pixel;; 3056 col.fRed = xcol.red;; 3057 col.fGreen = xcol.green;; 3058 col.fBlue = xcol.blue;; 3059 }; 3060 }; 3061}; 3062 ; 3063////////////////////////////////////////////////////////////////////////////////; 3064/// Set text alignment.; 3065///; 3066/// \param [in] talign text alignment; 3067 ; 3068void TGX11::SetTextAlign(Short_t talign); 3069{; 3070 Int_t txalh = talign/10;; 3071 Int_t txalv = talign%10;; 3072 fTextAlignH = txalh;; 3073 fTextAlignV = txalv;; 3074 ; 3075 switch (txalh) {; 3076 ; 3077 case 0 :; 3078 case 1 :; 3079 switch (txalv) { //left; 3080 case 1 :; 3081 fTextAlign = 7; //bottom; 3082 break;; 3083 case 2 :; 3084 fTextAlign = 4; //center; 3085 break;; 3086 case 3 :; 3087 fTextAlign = 1; //top; 3088 b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:101693,green,green,101693,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"nction.; The RooFFTConvPdf uses caching inherited from a RooAbsCachedPdf. If it is evaluated for a particular value of x, the FFT and convolution is calculated for all bins in the observable space for the given choice of parameters, which are also stored in the cache. Subsequent evaluations for different values of the convolution observable and identical parameters will be retrieved from the cache. If one or more of the parameters change, the cache will be updated, i.e., a new FFT runs.; The sampling density of the FFT is controlled by the binning of the the convolution observable, which can be changed using RooRealVar::setBins(N). For good results, N should be large (>=1000). Additional interpolation between the bins may improve the result if coarse binnings are chosen. These can be activated in the constructor or by calling setInterpolationOrder(). For N >> 1000, interpolation will not substantially improve the accuracy.; Additionial information on caching can be displayed by monitoring the message stream with topic ""Caching"" at the INFO level, i.e. by calling RooMsgService::instance().addStream(RooMsgService::INFO,Topic(""Caching"")) to see these message on stdout.; Multi-dimensional convolutions are not supported at the moment. Installing an external version of FFTW on Linux and compiling ROOT to use it; You have two options:; Recommended: ROOT can automatically install FFTW for itself, see builtin_fftw3 at https://root.cern/building-root; Install FFTW and let ROOT discover it. fftw3 is on by default (see https://root.cern/building-root). 1) Go to www.fftw.org and download the latest stable version (a .tar.gz file); If you have root access to your machine and want to make a system installation of FFTW; 2) Untar fftw-XXX.tar.gz in /tmp, cd into the untarred directory and type './configure' followed by 'make install'. This will install fftw in /usr/local/bin,lib etc...; 3) Start from a source installation of ROOT. ROOT should discover it. See https://root.cern/buildi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:3485,monitor,monitoring,3485,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['monitor'],['monitoring']
Energy Efficiency,"nctionDefinition NeuralNet.h:697; TMVA::DNN::Layer::LayerLayer(size_t numNodes, EnumFunction activationFunction, ModeOutputValues eModeOutputValues=ModeOutputValues::DIRECT)c'tor for defining a LayerDefinition NeuralNet.cxx:166; TMVA::DNN::Net::m_layersstd::vector< Layer > m_layerslayer-structure-dataDefinition NeuralNet.h:1272; TMVA::DNN::Net::inputSizesize_t inputSize() constinput size of the DNNDefinition NeuralNet.h:1098; TMVA::DNN::Net::numNodessize_t numNodes(size_t trainingStartLayer=0) constreturns the number of nodes in this netDefinition NeuralNet.cxx:556; TMVA::DNN::Net::fillDropContainervoid fillDropContainer(DropContainer &dropContainer, double dropFraction, size_t numNodes) constprepare the drop-out-container (select the nodes which are to be dropped out)Definition NeuralNet.cxx:572; TMVA::DNN::Net::numWeightssize_t numWeights(size_t trainingStartLayer=0) constreturns the number of weights in this netDefinition NeuralNet.cxx:540; TMVA::DNN::Settings::clearvoid clear(std::string histoName)for monitoringDefinition NeuralNet.h:824; TMVA::DNN::Settings::hasConvergedvirtual bool hasConverged(double testError)has this training converged already?Definition NeuralNet.cxx:485; TMVA::DNN::Settings::SettingsSettings(TString name, size_t _convergenceSteps=15, size_t _batchSize=10, size_t _testRepetitions=7, double _factorWeightDecay=1e-5, TMVA::DNN::EnumRegularization _regularization=TMVA::DNN::EnumRegularization::NONE, MinimizerType _eMinimizerType=MinimizerType::fSteepest, double _learningRate=1e-5, double _momentum=0.3, int _repetitions=3, bool _multithreading=true)c'torDefinition NeuralNet.cxx:232; TMVA::DNN::Settings::addPointvoid addPoint(std::string histoName, double x)for monitoringDefinition NeuralNet.h:821; TMVA::DNN::Settings::~Settingsvirtual ~Settings()d'torDefinition NeuralNet.cxx:261; TMVA::DNN::Settings::m_convergenceCountsize_t m_convergenceCountDefinition NeuralNet.h:857; TMVA::DNN::Settings::m_minErrordouble m_minErrorDefinition NeuralNet.h:859; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8cxx_source.html:26852,monitor,monitoringDefinition,26852,doc/master/NeuralNet_8cxx_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8cxx_source.html,1,['monitor'],['monitoringDefinition']
Energy Efficiency,"nctions to work on array of data (e.g. mean and RMS of arrays);; algorithms for binary search/hashing sorting;; special mathematical functions like Bessel, Erf, Gamma, etc.;; statistical functions, like common probability and cumulative (quantile) distributions; geometrical functions. For more details, see the reference documentation of TMath at <http://root.cern.ch/root/htmldoc/TMath.html>.; 13.3.1 Numerical Constants; TMath offers a wide range of constants in the form of inline functions. Notice that they are not defined as C/C++ preprocessor macros. This set of functions includes one or more definitions for the following constants:. Pi.; Base of natural logarithm.; Velocity of light.; Gravitational constant (G).; Standard acceleration of gravity (g).; Standard acceleration of Gravity.; Plank’s contant.; Boltzmann’s and Steffan-Boltzmann’s constants.; Avogadro’s number.; Universal gas constant.; Molecular weight of dry air.; Dry air gas constant.; Euler-Mascheroni Constant.; Elementary charge. 13.3.2 Elementary Functions; A set of miscellaneous elementary mathematical functions is provided along with a set of basic trigonometrical functions. Some of this functions refer to basic mathematical functions like the square root, the power to a number of the calculus of a logarithm, while others are used for number treatment, like rounding.; Although there are some functions that are not in the standard C math library (like Factorial), most of the functionality offered here is just a wrapper of the first ones. Nevertheless, some of the them also offer some security checks or a better precision, like the trigonometrical functions ASin(x), ACos(x) or ATan(x).; // Generate a vector with 10 random numbers; vector<double> v(10);; std::generate(v.begin(), v.end(), rand);. // Find the minimum value of the vector (iterator version); vector<double>::iterator it;; it = TMath::LocMin(v.begin(), v.end());; std::cout << *it << std::endl;. // The same with the old-style version; int i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:661987,charge,charge,661987,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['charge'],['charge']
Energy Efficiency,"nctions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1.0E-8) const. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1.0E-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1.0E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1.0E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1.0E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1.0E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1.0E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm wit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__Derivator.html:3889,adapt,adaptive,3889,root/html602/ROOT__Math__Derivator.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__Derivator.html,2,['adapt'],['adaptive']
Energy Efficiency,"nd also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCacheUnzip& ). TTreeCacheUnzip& operator=(const TTreeCacheUnzip& ). EParUnzipMode GetParallelUnzip(); Methods",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCacheUnzip.html:18158,allocate,allocate,18158,root/html528/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html528/TTreeCacheUnzip.html,6,['allocate'],['allocate']
Energy Efficiency,"nd its RMS for each cell in X,Y,Z ;  CTProfileHelper;  ►CTProofThis class controls a Parallel ROOT Facility, PROOF, cluster ;  CMD5Mod_t;  CTProofBenchSteering class for PROOF benchmarks ;  CTProofBenchDataSetHandle operations on datasets used by ProofBench ;  CTProofBenchRunAbstract base class for PROOF benchmark runs ;  CTProofBenchRunCPUCPU-intensive PROOF benchmark test generates events and fill 1, 2, or 3-D histograms ;  CTProofBenchRunDataReadI/O-intensive PROOF benchmark test reads in event files distributed on the cluster ;  CTProofChain;  CTProofCondor;  CTProofDebug;  CTProofDesc;  CTProofDrawImplement Tree drawing using PROOF ;  CTProofDrawEntryList;  CTProofDrawEventList;  CTProofDrawGraph;  CTProofDrawHist;  ►CTProofDrawListOfGraphs;  CPoint3D_t;  ►CTProofDrawListOfPolyMarkers3D;  CPoint4D_t;  CTProofDrawPolyMarker3D;  CTProofDrawProfile;  CTProofDrawProfile2D;  CTProofInputHandler;  CTProofInterruptHandler;  CTProofLimitsFinderClass to find axis limits and synchronize them between workers ;  CTProofLiteThis class starts a PROOF session on the local machine: no daemons, client and master merged, communications via UNIX-like sockets ;  CTProofLockPath;  CTProofLockPathGuard;  CTProofLogImplementation of the PROOF session log handler ;  CTProofLogElem;  CTProofMergePrg;  CTProofMgrThe PROOF manager interacts with the PROOF server coordinator to create or destroy a PROOF session, attach to or detach from existing one, and to monitor any client activity on the cluster ;  CTProofMgrLiteBasic TProofMgr functionality implementation in the case of Lite session ;  ►CTProofMonSenderProvides the interface for PROOF monitoring to different writers ;  CTDSetPlet;  CTProofMonSenderMLTProofMonSender implementation for the ML writer ;  CTProofMonSenderSQLTProofMonSender implementation for the SQL writers ;  CTProofNodeInfoThe purpose of this class is to provide a complete node description for masters, submasters and workers ;  CTProofNodesPROOF worker node information .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:203803,monitor,monitor,203803,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,2,['monitor'],"['monitor', 'monitoring']"
Energy Efficiency,"nd method return the pointer to the legend, otherwise return 0;. ; Definition at line 705 of file TPie.cxx. ◆ GetPercentFormat(). const char * TPie::GetPercentFormat ; (; ). inline . Definition at line 77 of file TPie.h. ◆ GetRadius(). Double_t TPie::GetRadius ; (; ). inline . Definition at line 78 of file TPie.h. ◆ GetSlice(). TPieSlice * TPie::GetSlice ; (; Int_t ; id). Return the reference to the slice of index 'id'. ; There are no controls of memory corruption, be carefull. ; Definition at line 714 of file TPie.cxx. ◆ GetValueFormat(). const char * TPie::GetValueFormat ; (; ). inline . Definition at line 80 of file TPie.h. ◆ GetX(). Double_t TPie::GetX ; (; ). inline . Definition at line 81 of file TPie.h. ◆ GetY(). Double_t TPie::GetY ; (; ). inline . Definition at line 82 of file TPie.h. ◆ Init(). void TPie::Init ; (; Int_t ; np, . Double_t ; ao, . Double_t ; x, . Double_t ; y, . Double_t ; r . ). private . Common initialization for all constructors. ; This is a private function called to allocate the memory. ; Definition at line 723 of file TPie.cxx. ◆ IsA(). TClass * TPie::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 111 of file TPie.h. ◆ MakeLegend(). TLegend * TPie::MakeLegend ; (; Double_t ; x1 = .65, . Double_t ; y1 = .65, . Double_t ; x2 = .95, . Double_t ; y2 = .95, . const char * ; leg_header = """" . ). This method create a legend that explains the contents of the slice for this pie-chart. ; The parameter passed reppresents the option passed to shown the slices, see TLegend::AddEntry() for further details.; The pointer of the TLegend is returned. ; Definition at line 770 of file TPie.cxx. ◆ MakeSlices(). void TPie::MakeSlices ; (; Bool_t ; force = kFALSE). Make the slices. ; If they already exist it does nothing unless force=kTRUE. ; Definition at line 1380 of file TPie.cxx. ◆ Paint(). void TPie::Paint ; (; Option_t * ; option). overridevirtual . Paint a Pie chart in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPie.html:29952,allocate,allocate,29952,doc/master/classTPie.html,https://root.cern,https://root.cern/doc/master/classTPie.html,1,['allocate'],['allocate']
Energy Efficiency,"nd on the same observable such as a PDF depending on x combined with another one depending on y. The composite storage will store two different datasets, {x} and {y}, but they can be passed as a single dataset to RooFit operations. A category tag will define which dataset has to be passed to which likelihood.; When iterated from start to finish, datasets will be traversed in the order of the category index. ; Definition at line 33 of file RooCompositeDataStore.h. Public Member Functions;  RooCompositeDataStore ();  ;  RooCompositeDataStore (const RooCompositeDataStore &other, const char *newname=nullptr);  Convert map by label to map by index for more efficient internal use. ;  ;  RooCompositeDataStore (const RooCompositeDataStore &other, const RooArgSet &vars, const char *newname=nullptr);  Update index category pointer, if it is contained in input argument vars. ;  ;  RooCompositeDataStore (RooStringView name, RooStringView title, const RooArgSet &vars, RooCategory &indexCat, std::map< std::string, RooAbsDataStore * > const &inputData);  Convert map by label to map by index for more efficient internal use. ;  ;  ~RooCompositeDataStore () override;  Destructor. ;  ; RooAbsArg * addColumn (RooAbsArg &var, bool adjustRange=true) override;  WVE ownership issue here!! Caller (a RooAbsData) should take ownership of all arguments, but only does for the first one here... ;  ; void append (RooAbsDataStore &other) override;  ; void attachBuffers (const RooArgSet &extObs) override;  ; void cacheArgs (const RooAbsArg *owner, RooArgSet &varSet, const RooArgSet *nset=nullptr, bool skipZeroWeights=false) override;  ; const RooAbsArg * cacheOwner () override;  ; bool changeObservableName (const char *from, const char *to) override;  Change name of internal observable named 'from' into 'to'. ;  ; RooAbsDataStore * clone (const char *newname=nullptr) const override;  ; RooAbsDataStore * clone (const RooArgSet &vars, const char *newname=nullptr) const override;  ; void dump () overri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCompositeDataStore.html:1551,efficient,efficient,1551,doc/master/classRooCompositeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooCompositeDataStore.html,1,['efficient'],['efficient']
Energy Efficiency,"nd supports fundamental types and ROOT::RVec thereof.; ; import ROOT; ; # To mark a Python callable to be used from C++, you have to use the decorator; # provided by PyROOT passing the C++ types of the input arguments and the return; # value.; @ROOT.Numba.Declare(['float', 'int'], 'float'); def pypow(x, y):; return x**y; ; # The Python callable is now available from C++ in the Numba namespace.; # For example, we can use it from the interpreter.; ROOT.gInterpreter.ProcessLine('cout << ""2^3 = "" << Numba::pypow(2, 3) << endl;'); ; # Or we can use the callable as well within a RDataFrame workflow.; data = ROOT.RDataFrame(4).Define('x', '(float)rdfentry_')\; .Define('x_pow3', 'Numba::pypow(x, 3)')\; .AsNumpy(); ; print('pypow({}, 3) = {}'.format(data['x'], data['x_pow3'])); ; # ROOT uses the numba Python package to create C++ functions from python ones.; # We support as input and return types of the callable fundamental types and; # ROOT::RVec thereof. See the following callable computing the power of the; # elements in an array.; @ROOT.Numba.Declare(['RVecF', 'int'], 'RVecF'); def pypowarray(x, y):; return x**y; ; ROOT.gInterpreter.ProcessLine('''; ROOT::RVecF x = {0, 1, 2, 3};; cout << ""pypowarray("" << x << "", 3) = "" << Numba::pypowarray(x, 3) << endl;; '''); ; # and now with RDataFrame; s = ROOT.RDataFrame(1).Define('x', 'ROOT::RVecF{1,2,3}')\; .Define('x2', 'Numba::pypowarray(x, 2)')\; .Sum('x2') # 1 + 4 + 9 == 14; print('sum(pypowarray({ 1, 2, 3 }, 2)) = ', s.GetValue()); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Poin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot004__NumbaDeclare_8py.html:1495,power,power,1495,doc/master/pyroot004__NumbaDeclare_8py.html,https://root.cern,https://root.cern/doc/master/pyroot004__NumbaDeclare_8py.html,1,['power'],['power']
Energy Efficiency,"nd the headers will be removed in ROOT 6.34:. RooAbsTestStatistic; RooAbsOptTestStatistic; RooNLLVar; RooChi2Var; RooXYChi2Var. Please use the higher-level functions RooAbsPdf::createNLL() and RooAbsPdf::createChi2() if you want to create objects that represent test statistics.; Change of RooParamHistFunc; The RooParamHistFunc didn’t take any observable RooRealVar as constructor argument. It assumes as observable the internal variables in the passed RooDataHist. This means it was in most contexts unusable, because the input can’t be changed, other than loading a different bin in the dataset.; Furthermore, there was actually a constructor that took a RooAbsArg x, but it was simply ignored.; To fix all these problems, the existing constructors were replaced by a new one that takes the observable explicitly.; Since the old constructors resulted in wrong computation graphs that caused trouble with the new CPU evaluation backend, they had to be removed without deprecation. Please adapt your code if necessary.; Renaming of some RooFit classes; The RooPower was renamed to RooPowerSum, and RooExpPoly was renamed to RooLegacyExpPoly.; This was a necessary change, because the names of these classes introduced in ROOT 6.28 collided with some classes in CMS combine, which were around already long before. Therefore, the classes had to be renamed to not cause any problems for CMS.; In the unlikeliy case where you should have used these new classes for analysis already, please adapt your code to the new names and re-create your workspaces.; RDataFrame. The RDataFrame constructors that take in input one or more file names (or globs thereof) will now infer the format of the dataset, either TTree or RNTuple, that is stored in the first input file. When multiple files are specified, it is assumed that all other files contain a coherent dataset of the same format and with the same schema, exactly as it used to happen with TChain. This automatic inference further contributes towards a ze",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:14328,adapt,adapt,14328,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['adapt'],['adapt']
Energy Efficiency,"ndObject(const TObject *obj) const overrideFind object using its hash value (returned by its Hash() member).Definition TListOfFunctions.cxx:443; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition TList.cxx:820; TList::AddLastvoid AddLast(TObject *obj) overrideAdd object at the end of the list.Definition TList.cxx:150; TList::FirstLinkvirtual TObjLink * FirstLink() constDefinition TList.h:104; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TList::AddFirstvoid AddFirst(TObject *obj) overrideAdd object at the beginning of the list.Definition TList.cxx:98; TMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberInspector::Inspectvirtual void Inspect(TClass *cl, const char *parent, const char *name, const void *addr)Definition TMemberInspector.cxx:99; TMemberStreamerDefinition TMemberStreamer.h:26; TMethodArgEach ROOT method (see TMethod) has a linked list of its arguments.Definition TMethodArg.h:36; TMethodArg::GetFullTypeNameconst char * GetFullTypeName() constGet full type description of method argument, e.g.: ""class TDirectory*"".Definition TMethodArg.cxx:74; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TMethod::GetClassTClass * GetClass() constDefinition TMethod.h:55; TMethod::IsMenuItemEMenuItemKind IsMenuItem() constDefinition TMethod.h:56; TMethod::GetListOfMethodArgsvirtual TList * GetListOfMethodArgs()Returns methodarg list and additionally upd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:359294,efficient,efficient,359294,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['efficient'],['efficient']
Energy Efficiency,"ndent variables ;  ; Double_t fMeanQuantity;  Mean of dependent quantity. ;  ; TVectorD fMeanVariables;  mean value of independent variables ;  ; Double_t fMinAngle;  Min angle for accepting new function. ;  ; Double_t fMinQuantity;  Min value of dependent quantity. ;  ; Double_t fMinRelativeError;  Min relative error accepted. ;  ; Double_t fMinResidual;  Min residual value. ;  ; Int_t fMinResidualRow;  Row giving min residual. ;  ; TVectorD fMinVariables;  min value of independent variables ;  ; Int_t fNCoefficients;  Dimension of model coefficients. ;  ; Int_t fNVariables;  Number of independent variables. ;  ; TVectorD fOrthCoefficients;  The model coefficients. ;  ; TMatrixD fOrthCurvatureMatrix;  Model matrix. ;  ; TVectorD fOrthFunctionNorms;  Norm of the evaluated functions. ;  ; TMatrixD fOrthFunctions;  As above, but orthogonalised. ;  ; Int_t fParameterisationCode;  Exit code of parameterisation. ;  ; EMDFPolyType fPolyType;  Fit object (MINUIT) ;  ; Int_t * fPowerIndex;  [fMaxTerms] Index of accepted powers ;  ; Double_t fPowerLimit;  Control parameter. ;  ; Int_t * fPowers;  [fMaxFuncNV] where fMaxFuncNV = fMaxFunctions*fNVariables ;  ; Double_t fPrecision;  Relative precision of param. ;  ; TVectorD fQuantity;  Training sample, dependent quantity. ;  ; TVectorD fResiduals;  Vector of the final residuals. ;  ; Double_t fRMS;  Root mean square of fit. ;  ; Int_t fSampleSize;  Size of training sample. ;  ; Bool_t fShowCorrelation;  print correlation matrix ;  ; TVectorD fSqError;  Training sample, error in quantity. ;  ; Double_t fSumSqAvgQuantity;  Sum of squares away from mean. ;  ; Double_t fSumSqQuantity;  SumSquare of dependent quantity. ;  ; Double_t fSumSqResidual;  Sum of Square residuals. ;  ; Double_t fTestCorrelationCoeff;  Multi Correlation coefficient. ;  ; Double_t fTestError;  Error from test. ;  ; Double_t fTestPrecision;  Relative precision of test. ;  ; TVectorD fTestQuantity;  Test sample, dependent quantity. ;  ; Int_t fTestSampleSize; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:37181,power,powers,37181,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['power'],['powers']
Energy Efficiency,"ndent. The only meta argument that is defined globally is $Alias(typeName,aliasName) to; define aliases for type names. For the definition of meta arguments in operator p.d.f.s; see the definitions below. std::string processExpression(const char* expr); Process a single high-level expression or list of; expressions. The returned string a the reduced expression where; all inline object creations have been executed and substituted; with the name of the created object. e.g. 'RooGaussian::g(x,m,s)' --> 'g'; '{x(-10,10),s} --> '{x,s}'. std::string processCompositeExpression(const char* arg); Process a single composite expression. e.g. 'A=RooGaussian::g[x,m,s]' --> 'A=g'; e.g. 'f[0,1]*RooGaussian::g[x,m,s]' --> 'f*g'; e.g. 'RooGaussian::g(x,y,s)|x' --> g|x'; e.g. '$MetaArg(RooGaussian::g[x,m,s],blah)' --> '$MetaArg(g,blah)'. std::string processSingleExpression(const char* arg); Process a single high-level expression. The returned string a the reduced; expression where all inline object creations have been executed and substituted; with the name of the created object. e.g. 'RooGaussian::g(x,m,s)' --> 'g'; e.g. 'x[-10,10]' --> 'x'. string processListExpression(const char* arg); Process a list of high-level expression. The returned string a the reduced; expression list where all inline object creations have been executed and substituted; with the name of the created object. E.g. '{x(-10,10),s} --> '{x,s}'. string processAliasExpression(const char* arg); Parse token. TClass* resolveClassName(const char* className). string varTag(string& func, vector<std::string>& args). string processCreateVar(string& func, vector<std::string>& args); Glue function between high-level syntax and low-level factory call to createVariable:; Process a parsed call to create a variable named 'func'. If initial token is non-numeric, a RooCategory will be created, and the args are interpreted; as either state names or 'name=id' assignments. Otherwise a RooRealvar is created and the; arg list is interpr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFactoryWSTool.html:17118,reduce,reduced,17118,root/html526/RooFactoryWSTool.html,https://root.cern,https://root.cern/root/html526/RooFactoryWSTool.html,5,['reduce'],['reduced']
Energy Efficiency,"ndent. The only meta argument that is defined globally is $Alias(typeName,aliasName) to; define aliases for type names. For the definition of meta arguments in operator p.d.f.s; see the definitions below. std::string processExpression(const char* expr); Process a single high-level expression or list of; expressions. The returned string a the reduced expression where; all inline object creations have been executed and substituted; with the name of the created object. e.g. 'RooGaussian::g(x,m,s)' --> 'g'; '{x(-10,10),s} --> '{x,s}'. std::string processCompositeExpression(const char* arg); Process a single composite expression. e.g. 'A=RooGaussian::g[x,m,s]' --> 'A=g'; e.g. 'f[0,1]*RooGaussian::g[x,m,s]' --> 'f*g'; e.g. 'RooGaussian::g(x,y,s)|x' --> g|x'; e.g. '$MetaArg(RooGaussian::g[x,m,s],blah)' --> '$MetaArg(g,blah)'. std::string processSingleExpression(const char* arg); Process a single high-level expression. The returned string a the reduced; expression where all inline object creations have been executed and substituted; with the name of the created object. e.g. 'RooGaussian::g(x,m,s)' --> 'g'; e.g. 'x[-10,10]' --> 'x'. string processListExpression(const char* arg); Process a list of high-level expression. The returned string a the reduced; expression list where all inline object creations have been executed and substituted; with the name of the created object. E.g. '{x(-10,10),s} --> '{x,s}'. string processAliasExpression(const char* arg); Parse token. TClass* resolveClassName(const char* className). string varTag(string& func, vector<string>& args). string processCreateVar(string& func, vector<string>& args); Glue function between high-level syntax and low-level factory call to createVariable:; Process a parsed call to create a variable named 'func'. If initial token is non-numeric, a RooCategory will be created, and the args are interpreted; as either state names or 'name=id' assignments. Otherwise a RooRealvar is created and the; arg list is interpreted as fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFactoryWSTool.html:18615,reduce,reduced,18615,root/html602/RooFactoryWSTool.html,https://root.cern,https://root.cern/root/html602/RooFactoryWSTool.html,2,['reduce'],['reduced']
Energy Efficiency,"ndex for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError2(Long64_t linidx) const; Get square of the error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return contents. Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approximate. ROOT::THnBaseBinIter* CreateIter(Bool_t respectAxisRange) const; Create an iterator over all filled bins of a THnSparse.; Use THnIter instead. void SetBinContent(Long64_t bin, Double_t v); Set content of bin with index ""bin"" to ""v"". void SetBinError2(Long64_t bin, Double_t e2); Set error of bin with index ""bin"" to ""e"", enable errors if needed. void AddBinError2(Long64_t bin, Double_t e2); Add ""e"" to error of bin with index ""bin"", enable errors if needed. void Sumw2(); Enable calculation of errors. void Reset(Option_t* option = """"); Clear the histogram. THnSparse& operator=(const THnSparse& ). THnSparseA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnSparse.html:17908,allocate,allocate,17908,root/html534/THnSparse.html,https://root.cern,https://root.cern/root/html534/THnSparse.html,2,['allocate'],['allocate']
Energy Efficiency,"ndex for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError2(Long64_t linidx) const; Get square of the error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return contents. Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approximate. ROOT::THnBaseBinIter* CreateIter(Bool_t respectAxisRange) const; Create an iterator over all filled bins of a THnSparse.; Use THnIter instead. void SetBinContent(Long64_t bin, Double_t v); Set content of bin with index ""bin"" to ""v"". void SetBinError2(Long64_t bin, Double_t e2); Set error of bin with index ""bin"" to ""e"", enable errors if needed. void AddBinError2(Long64_t bin, Double_t e2); Add ""e"" to error of bin with index ""bin"", enable errors if needed. void Sumw2(); Enable calculation of errors. void Reset(Option_t* option = """"); Clear the histogram. THnSparse(const THnSparse& ). THnSparse& operator=(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THnSparse.html:19158,allocate,allocate,19158,root/html602/THnSparse.html,https://root.cern,https://root.cern/root/html602/THnSparse.html,4,['allocate'],['allocate']
Energy Efficiency,"nding on the context, using TSpectrumTransform might still be a valid solution. For modeling a spectrum fitting and estimating the background one can use RooFit while for deconvolution and unfolding one can use TUnfold.; Class to carry out transforms of 1D spectra, its filtering and enhancement. It allows to calculate classic Fourier, Cosine, Sin, Hartley, Walsh, Haar transforms as well as mixed transforms (Fourier- Walsh, Fourier-Haar, Walsh-Haar, Cosine-Walsh, Cosine-Haar, Sin-Walsh and Sin-Haar). All the transforms are fast.; The algorithms in this class have been published in the following references:. C.V. Hampton, B. Lian, Wm. C. McHarris: Fast-Fourier-transform spectral enhancement techniques for gamma-ray spectroscopy.NIM A353(1994) 280-284.; Morhac M., Matousek V., New adaptive Cosine-Walsh transform and its application to nuclear data compression, IEEE Transactions on Signal Processing 48 (2000) 2693.; Morhac M., Matousek V., Data compression using new fast adaptive Cosine-Haar transforms, Digital Signal Processing 8 (1998) 63.; Morhac M., Matousek V.: Multidimensional nuclear data compression using fast adaptive Walsh-Haar transform. Acta Physica Slovaca 51 (2001) 307. . Definition at line 18 of file TSpectrumTransform.h. Public Types; enum  { ;   kTransformHaar =0; , kTransformWalsh =1; , kTransformCos =2; , kTransformSin =3; , ;   kTransformFourier =4; , kTransformHartley =5; , kTransformFourierWalsh =6; , kTransformFourierHaar =7; , ;   kTransformWalshHaar =8; , kTransformCosWalsh =9; , kTransformCosHaar =10; , kTransformSinWalsh =11; , ;   kTransformSinHaar =12; , kTransformForward =0; , kTransformInverse =1. };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumTransform.html:1644,adapt,adaptive,1644,doc/master/classTSpectrumTransform.html,https://root.cern,https://root.cern/doc/master/classTSpectrumTransform.html,1,['adapt'],['adaptive']
Energy Efficiency,"nds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tTTree::fUpdateUpdate frequency for EntryLoop; TList*TTree::fUserInfopointer to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static Int_tTTree::fgBranchStyleOld/New branch style; static Long64_tTTree::fgMaxTreeSizeMaximum size of a file containg a Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNtupleD(); Default constructor for Ntuple*-*-*-*-*-*-*-*-; *-* ==============================. TNtupleD(const char* name, const char* title, const char* varlist, Int_t bufsize = 32000); Create an Ntuple*-*-; *-* ================; The parameter varlist describes the list of the ntuple variables; separated by a colon:; example: ""x:y:z:energy""; For each variable in the list a separate branch is created. NOTE:; -Use TTree to create branches with variables of different data types.; -Use TTree when the number of branches is large (> 100).; -. ~TNtupleD(); Default destructor for an Ntuple*-*-*-*-*-*-; *-* ================================. void ResetBranchAddress(TBranch* ); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void ResetBranchAddresses(); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void Browse(TBrowser* b); Browse content. Int_t Fill(); -*-*Fill a Ntuple with current values in fArgs; *-* ==========================================; Note that this function is protected.; Currently called only by TChain::Merge. Int_t Fill(const Double_t* x); Fill a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNtupleD.html:24409,energy,energy,24409,root/html528/TNtupleD.html,https://root.cern,https://root.cern/root/html528/TNtupleD.html,1,['energy'],['energy']
Energy Efficiency,"ne 260 of file TMethodCall.cxx. ◆ InitImplementation(). void TMethodCall::InitImplementation ; (; const char * ; methodname, . const char * ; params, . const char * ; proto, . Bool_t ; objectIsConst, . TClass * ; cl, . const ClassInfo_t * ; cinfo, . ROOT::EFunctionMatchMode ; mode = ROOT::kConversionMatch . ). private . This function implements Init and InitWithPrototype. ; 'methodname' should NOT have any scope information in it. The scope information should be passed via the TClass or CINT ClassInfo. ; Definition at line 296 of file TMethodCall.cxx. ◆ InitWithPrototype() [1/2]. void TMethodCall::InitWithPrototype ; (; const char * ; function, . const char * ; proto, . ROOT::EFunctionMatchMode ; mode = ROOT::kConversionMatch . ). Initialize the function invocation environment. ; Necessary input information: the function name and the prototype string of the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(...). This two step method is much more efficient than calling for every invocation TInterpreter::Execute(...). ; Definition at line 363 of file TMethodCall.cxx. ◆ InitWithPrototype() [2/2]. void TMethodCall::InitWithPrototype ; (; TClass * ; cl, . const char * ; method, . const char * ; proto, . Bool_t ; objectIsConst = kFALSE, . ROOT::EFunctionMatchMode ; mode = ROOT::kConversionMatch . ). Initialize the method invocation environment. ; Necessary input information: the class, method name and the prototype string of the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(object,...). This two step method is much more efficient than calling for every invocation TInterpreter::Execute(...). ; Definition at line 342 of file TMethodCall.cxx. ◆ IsA(). TClass * TMethodCall::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 128 of file TMethodCall.h. ◆ IsValid(). Bool_t TMethodCall::IsValid ; (; ); const. Return true if the method call has been",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMethodCall.html:26057,efficient,efficient,26057,doc/master/classTMethodCall.html,https://root.cern,https://root.cern/doc/master/classTMethodCall.html,1,['efficient'],['efficient']
Energy Efficiency,"ne 655 of file THnSparse.cxx. ◆ GenerateArray(). virtual TArray * THnSparse::GenerateArray ; (; ); const. protectedpure virtual . Implemented in THnSparseT< CONT >. ◆ GetBin() [1/6]. Long64_t THnSparse::GetBin ; (; const char * ; name[]); const. inlineoverridevirtual . Implements THnBase.; Definition at line 98 of file THnSparse.h. ◆ GetBin() [2/6]. Long64_t THnSparse::GetBin ; (; const char * ; name[], . Bool_t ; allocate = kTRUE . ). overridevirtual . Get the bin index for the n dimensional tuple addressed by ""name"", allocate one if it doesn't exist yet and ""allocate"" is true. ; Implements THnBase.; Definition at line 718 of file THnSparse.cxx. ◆ GetBin() [3/6]. Long64_t THnSparse::GetBin ; (; const Double_t * ; x); const. inlineoverridevirtual . Implements THnBase.; Definition at line 97 of file THnSparse.h. ◆ GetBin() [4/6]. Long64_t THnSparse::GetBin ; (; const Double_t * ; x, . Bool_t ; allocate = kTRUE . ). overridevirtual . Get the bin index for the n dimensional tuple x, allocate one if it doesn't exist yet and ""allocate"" is true. ; Implements THnBase.; Definition at line 702 of file THnSparse.cxx. ◆ GetBin() [5/6]. Long64_t THnSparse::GetBin ; (; const Int_t * ; idx); const. inlineoverridevirtual . Implements THnBase.; Definition at line 96 of file THnSparse.h. ◆ GetBin() [6/6]. Long64_t THnSparse::GetBin ; (; const Int_t * ; idx, . Bool_t ; allocate = kTRUE . ). overridevirtual . Get the bin index for the n dimensional coordinates coord, allocate one if it doesn't exist yet and ""allocate"" is true. ; Implements THnBase.; Definition at line 733 of file THnSparse.cxx. ◆ GetBinContent() [1/2]. Double_t THnSparse::GetBinContent ; (; const Int_t * ; idx); const. inline . Forwards to THnBase::GetBinContent() overload. ; Non-virtual, CINT-compatible replacement of a using declaration. ; Definition at line 121 of file THnSparse.h. ◆ GetBinContent() [2/2]. Double_t THnSparse::GetBinContent ; (; Long64_t ; idx, . Int_t * ; coord = nullptr . ); const. overridevirtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnSparse.html:33820,allocate,allocate,33820,doc/master/classTHnSparse.html,https://root.cern,https://root.cern/doc/master/classTHnSparse.html,2,['allocate'],['allocate']
Energy Efficiency,"ne completely the class ; Definition at line 70 of file GSLSimAnnealing.h. ◆ ~GSLSimAnFunc(). virtual ROOT::Math::GSLSimAnFunc::~GSLSimAnFunc ; (; ). inlinevirtual . virtual destructor (no operations) ; Definition at line 78 of file GSLSimAnnealing.h. Member Function Documentation. ◆ Clone(). virtual GSLSimAnFunc * ROOT::Math::GSLSimAnFunc::Clone ; (; ); const. inlinevirtual . clone method. ; Needs to be re-implemented by the derived classes for deep copying ; Definition at line 92 of file GSLSimAnnealing.h. ◆ Distance(). double ROOT::Math::GSLSimAnFunc::Distance ; (; const GSLSimAnFunc & ; func); const. virtual . calculate the distance (metric) between this one and another configuration Presently a cartesian metric is used. ; re-implement by derived classes if needed to be modified ; Definition at line 66 of file GSLSimAnnealing.cxx. ◆ Energy(). double ROOT::Math::GSLSimAnFunc::Energy ; (; ); const. virtual . evaluate the energy ( objective function value) re-implement by derived classes if needed to be modified ; Definition at line 50 of file GSLSimAnnealing.cxx. ◆ FastCopy(). GSLSimAnFunc & ROOT::Math::GSLSimAnFunc::FastCopy ; (; const GSLSimAnFunc & ; f). virtual . fast copy method called by GSL simulated annealing internally copy only the things which have been changed must be re-implemented by derived classes if needed ; Definition at line 96 of file GSLSimAnnealing.cxx. ◆ NDim(). unsigned int ROOT::Math::GSLSimAnFunc::NDim ; (; ); const. inline . Definition at line 135 of file GSLSimAnnealing.h. ◆ Print(). void ROOT::Math::GSLSimAnFunc::Print ; (; ). virtual . print the position in the standard output std::ostream GSL prints in addition n iteration, n function calls, temperature and energy re-implement by derived classes if necessary ; Definition at line 83 of file GSLSimAnnealing.cxx. ◆ Scale(). double ROOT::Math::GSLSimAnFunc::Scale ; (; unsigned int ; i); const. inline . Definition at line 141 of file GSLSimAnnealing.h. ◆ SetX() [1/3]. void ROOT::Math::GSL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLSimAnFunc.html:4821,energy,energy,4821,doc/master/classROOT_1_1Math_1_1GSLSimAnFunc.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLSimAnFunc.html,1,['energy'],['energy']
Energy Efficiency,"ne found; 1632 if (opCurlyCurly==-1) { // }{ not found; 1633 // arguments missing for \splitline; 1634 fError = ""Missing second line for #splitline"";; 1635 delete[] text;; 1636 return TLatexFormSize(0,0,0);; 1637 }; 1638 Double_t height = GetHeight()*spec.fSize/8;; 1639 if (!fShow) {; 1640 fs1 = Anal1(spec,text+opSplitLine+11,opCurlyCurly-opSplitLine-11);; 1641 fs2 = Anal1(spec,text+opCurlyCurly+2,length-opCurlyCurly-3);; 1642 Savefs(&fs1);; 1643 Savefs(&fs2);; 1644 } else {; 1645 fs2 = Readfs();; 1646 fs1 = Readfs();; 1647 Analyse(x,y+fs2.Over()-height,spec,text+opCurlyCurly+2,length-opCurlyCurly-3); // second line; 1648 Analyse(x,y-fs1.Under()-3*height,spec,text+opSplitLine+11,opCurlyCurly-opSplitLine-11); //first line; 1649 }; 1650 ; 1651 result.Set(TMath::Max(fs1.Width(),fs2.Width()),fs1.Height()+3*height,fs2.Height()-height);; 1652 ; 1653 }; 1654 else if (opSqrt>-1) { // \sqrt found; 1655 if (!fShow) {; 1656 if (opSquareCurly>-1) {; 1657 // power nth #sqrt[n]{arg}; 1658 fs1 = Anal1(specNewSize,text+opSqrt+6,opSquareCurly-opSqrt-6);; 1659 fs2 = Anal1(spec,text+opSquareCurly+1,length-opSquareCurly-1);; 1660 Savefs(&fs1);; 1661 Savefs(&fs2);; 1662 result.Set(fs2.Width()+ GetHeight()*spec.fSize/10+TMath::Max(GetHeight()*spec.fSize/2,(Double_t)fs1.Width()),; 1663 fs2.Over()+fs1.Height()+GetHeight()*spec.fSize/4,fs2.Under());; 1664 } else {; 1665 fs1 = Anal1(spec,text+opSqrt+5,length-opSqrt-5);; 1666 Savefs(&fs1);; 1667 result.Set(fs1.Width()+GetHeight()*spec.fSize/2,fs1.Over()+GetHeight()*spec.fSize/4,fs1.Under());; 1668 }; 1669 } else {; 1670 if (opSquareCurly>-1) { // ]{; 1671 fs2 = Readfs();; 1672 fs1 = Readfs();; 1673 Double_t pas = TMath::Max(GetHeight()*spec.fSize/2,(Double_t)fs1.Width());; 1674 Double_t pas2 = pas + GetHeight()*spec.fSize/10;; 1675 Double_t y1 = y-fs2.Over() ;; 1676 Double_t y2 = y+fs2.Under() ;; 1677 Double_t y3 = y1-GetHeight()*spec.fSize/4;; 1678 Analyse(x+pas2,y,spec,text+opSquareCurly+1,length-opSquareCurly-1);; 1679 Analyse(x,y-fs2.Over",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLatex_8cxx_source.html:60154,power,power,60154,doc/master/TLatex_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html,1,['power'],['power']
Energy Efficiency,"ne; 351/// true color machine we will calculate the pixel value using:; 352/// for 15 and 16 bit true colors have 6 bits precision per color however; 353/// only the 5 most significant bits are used in the color index.; 354/// Except for 16 bits where green uses all 6 bits. I.e.:; 355/// ~~~ {.cpp}; 356/// 15 bits = rrrrrgggggbbbbb; 357/// 16 bits = rrrrrggggggbbbbb; 358/// ~~~; 359/// for 24 bits each r, g and b are represented by 8 bits.; 360///; 361/// Since all colors are set with a max of 65535 (16 bits) per r, g, b; 362/// we just right shift them by 10, 11 and 10 bits for 16 planes, and; 363/// (10, 10, 10 for 15 planes) and by 8 bits for 24 planes.; 364/// Returns kFALSE in case color allocation failed.; 365 ; 366Bool_t TGX11::AllocColor(Colormap cmap, RXColor *color); 367{; 368 if (fRedDiv == -1) {; 369 if (XAllocColor((Display*)fDisplay, cmap, color)); 370 return kTRUE;; 371 } else {; 372 color->pixel = (color->red >> fRedDiv) << fRedShift |; 373 (color->green >> fGreenDiv) << fGreenShift |; 374 (color->blue >> fBlueDiv) << fBlueShift;; 375 return kTRUE;; 376 }; 377 return kFALSE;; 378}; 379 ; 380////////////////////////////////////////////////////////////////////////////////; 381/// Returns the current RGB value for the pixel in the XColor structure.; 382 ; 383void TGX11::QueryColors(Colormap cmap, RXColor *color, Int_t ncolors); 384{; 385 if (fRedDiv == -1) {; 386 XQueryColors((Display*)fDisplay, cmap, color, ncolors);; 387 } else {; 388 ULong_t r, g, b;; 389 for (Int_t i = 0; i < ncolors; i++) {; 390 r = (color[i].pixel & fVisual->red_mask) >> fRedShift;; 391 color[i].red = UShort_t(r*kBIGGEST_RGB_VALUE/(fVisual->red_mask >> fRedShift));; 392 ; 393 g = (color[i].pixel & fVisual->green_mask) >> fGreenShift;; 394 color[i].green = UShort_t(g*kBIGGEST_RGB_VALUE/(fVisual->green_mask >> fGreenShift));; 395 ; 396 b = (color[i].pixel & fVisual->blue_mask) >> fBlueShift;; 397 color[i].blue = UShort_t(b*kBIGGEST_RGB_VALUE/(fVisual->blue_mask >> fBlueShift));; 398 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:11992,green,green,11992,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"nearVar is the most general form of a derived real-valued object that can be used by RooRealIntegral to integrate over ;  CRooLinkedListRooLinkedList is an collection class for internal use, storing a collection of RooAbsArg pointers in a doubly linked list ;  CRooLinkedListElemRooLinkedListElem is an link element for the RooLinkedList class ;  CRooLinkedListIterRooLinkedListIter is the TIterator implementation for RooLinkedList ;  CRooLinTransBinningRooLinTransBinning is a special binning implementation for RooLinearVar that transforms the binning of the RooLinearVar input variable in the same way that RooLinearVar does ;  CRooListA RooList is a TList with extra support for working with options that are associated with each node ;  CRooListProxyRooListProxy is the concrete proxy for RooArgList objects ;  CRooLognormalRooFit Lognormal PDF ;  CRooMapCatEntry;  ►CRooMappedCategory;  CEntry;  CRooMath;  CRooMathCoreReg;  CRooMathMoreReg;  CRooMCIntegratorRooMCIntegrator implements an adaptive multi-dimensional Monte Carlo numerical integration, following the VEGAS algorithm originally described in G ;  CRooMCStudyRooMCStudy is a help class to facilitate Monte Carlo studies such as 'goodness-of-fit' studies, that involve fitting a PDF to multiple toy Monte Carlo sets generated from the same PDF or another PDF ;  CRooMinimizerRooMinimizer is a wrapper class around ROOT::Fit:Fitter that provides a seamless interface between the minimizer functionality and the native RooFit interface ;  CRooMinimizerFcn;  CRooMinuitRooMinuit is a wrapper class around TFitter/TMinuit that provides a seamless interface between the MINUIT functionality and the native RooFit interface ;  CRooMomentRooMoment represents the first, second, or third order derivative of any RooAbsReal as calculated (numerically) by the MathCore Richardson derivator class ;  ►CRooMomentMorph;  CCacheElem;  ►CRooMomentMorphFunc;  CCacheElem;  ►CRooMomentMorphFuncND;  CCacheElem;  CDigits;  CGrid2;  ►CRooMomentMorphND;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:118823,adapt,adaptive,118823,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['adapt'],['adaptive']
Energy Efficiency,"needAddressReset = (updatedLeafCount.find(leaf->GetLeafCount()) != updatedLeafCount.end());; 3380 }; 3381 }; 3382 if (needAddressReset && leaf->GetValuePointer()) {; 3383 if (leaf->IsA() == TLeafElement::Class() && mother); 3384 mother->ResetAddress();; 3385 else; 3386 leaf->SetAddress(nullptr);; 3387 }; 3388 if (!branch->GetAddress() && !leaf->GetValuePointer()) {; 3389 // We should attempts to set the address of the branch.; 3390 // something like:; 3391 //(TBranchElement*)branch->GetMother()->SetAddress(0); 3392 //plus a few more subtleties (see TBranchElement::GetEntry).; 3393 //but for now we go the simplest route:; 3394 //; 3395 // Note: This may result in the allocation of an object.; 3396 branch->SetupAddresses();; 3397 }; 3398 if (branch->GetAddress()) {; 3399 tree->SetBranchAddress(branch->GetName(), (void*) branch->GetAddress());; 3400 TBranch* br = tree->GetBranch(branch->GetName());; 3401 if (br) {; 3402 if (br->IsA() != branch->IsA()) {; 3403 Error(; 3404 ""CopyAddresses"",; 3405 ""Branch kind mismatch between input tree '%s' and output tree '%s' for branch '%s': '%s' vs '%s'"",; 3406 tree->GetName(), br->GetTree()->GetName(), br->GetName(), branch->IsA()->GetName(),; 3407 br->IsA()->GetName());; 3408 }; 3409 // The copy does not own any object allocated by SetAddress().; 3410 // FIXME: We do too much here, br may not be a top-level branch.; 3411 if (br->InheritsFrom(TBranchElement::Class())) {; 3412 ((TBranchElement*) br)->ResetDeleteObject();; 3413 }; 3414 } else {; 3415 Warning(""CopyAddresses"", ""Could not find branch named '%s' in tree named '%s'"", branch->GetName(), tree->GetName());; 3416 }; 3417 } else {; 3418 tleaf->SetAddress(leaf->GetValuePointer());; 3419 }; 3420 }; 3421 }; 3422 ; 3423 if (undo &&; 3424 ( tree->IsA()->InheritsFrom(""TNtuple"") || tree->IsA()->InheritsFrom(""TNtupleD"") ); 3425 ) {; 3426 tree->ResetBranchAddresses();; 3427 }; 3428}; 3429 ; 3430namespace {; 3431 ; 3432 enum EOnIndexError { kDrop, kKeep, kBuild };; 3433 ; 3434 bool R__H",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:135144,allocate,allocated,135144,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"nelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); TMVA::KDEKernel&operator=(const TMVA::KDEKernel&); voidSetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum EKernelType { kNone; kGauss; };; enum EKernelIter { kNonadaptiveKDE; kAdaptiveKDE; };; enum EKernelBorder { kNoTreatment; kKernelRenorm; kSampleMirror; };. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the ; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE ; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__KDEKernel.html:1894,adapt,adaptive,1894,root/html528/TMVA__KDEKernel.html,https://root.cern,https://root.cern/root/html528/TMVA__KDEKernel.html,3,['adapt'],['adaptive']
Energy Efficiency,"neric functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1E-8) const. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__Derivator.html:3857,adapt,adaptive,3857,root/html526/ROOT__Math__Derivator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__Derivator.html,5,['adapt'],['adaptive']
Energy Efficiency,"nes . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » ROOT 6 Analysis Workshop 4. Histogramming. What is a histogram?; Our TTree contains for instance the energy of all electrons. What we usually care about is its distribution - for instance by counting how often electrons have an energy within a certain range. Such a range is called ""bin"". Let's look at an example: draw the histogram of the momentum (""fPt"") of all electrons with an energy (""fE"") > 80 and fTriggered being true.; Binning; You can tell TTree::Draw() what the binning should be:; tree->Draw(""electrons.fE >> htemp(15, 0., 30.)"",...). will use 15 bins, where the lower bin border of the first bin is at 0. and the upper bin border of the highest is at 30.; Style; ROOT displays a few properties for the histogram in the box in the upper right. You can move things around in the graphical display (""canvas"") of the histogram. You can modify graphical properties of the canvas by showing the editor: in the menu, select ""View"", then ""Editor"". Click on the histogram to select it, then change its visual appearance to magenta line, 5 pixels width, with pink fill. Eeew. This is likely the only time in your life that you are allowed to use this color combination - enjoy! :-); . ‹ 2. Running code in ROOT; up; 3. Examining a TTree's data ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/4-histogramming.html:2236,energy,energy,2236,d/4-histogramming.html,https://root.cern,https://root.cern/d/4-histogramming.html,1,['energy'],['energy']
Energy Efficiency,"nesArray, which should be; ""Cleared()"" in between several times. Keep deleting a TClonesArray is a double; waste. Not only you do not avoid memory fragmentation, but you worsen it because; the TClonesArray itself is a rather heavy structure, and there is quite some; code in the destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve program; execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used for; clearing TClonesArray. When option ""C"" is specified, ROOT automatically; executes the Clear() method (by default it is empty contained in TObject).; This method must be overridden in the relevant TClonesArray object class,; implementing the reset procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the TClonesArrays; are not destroyed and created on every event.; They must only be constructed/destructed at the beginning/end of the run. Function Members (Methods); public:. TClonesArray(); TClonesArray(const TClonesArray& tc); TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const TObject*, TObject*); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject*, Int_t); virtual voidAddAtAndExpand(TObject*, Int_t); virtual Int_tAddAtFree(TObject*); virtual voidAddBefore(const TObject*, TObject*); virtual voidAddFirst(TObject*); virtual voidAddLast(TObject*); TObject*AddrAt(Int_t idx); voidTCollection::AddVector(TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TClonesArray.html:3669,reduce,reduce,3669,root/html530/TClonesArray.html,https://root.cern,https://root.cern/root/html530/TClonesArray.html,1,['reduce'],['reduce']
Energy Efficiency,"nesArray, which should be; ""Cleared()"" in between several times. Keep deleting a TClonesArray is a double; waste. Not only you do not avoid memory fragmentation, but you worsen it because; the TClonesArray itself is a rather heavy structure, and there is quite some; code in the destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve program; execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used for; clearing TClonesArray. When option ""C"" is specified, ROOT automatically; executes the Clear() method (by default it is empty contained in TObject).; This method must be overridden in the relevant TClonesArray object class,; implementing the reset procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the TClonesArrays; are not destroyed and created on every event.; They must only be constructed/destructed at the beginning/end of the run. Function Members (Methods); public:. TClonesArray(); TClonesArray(const TClonesArray& tc); TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const TObject*, TObject*); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject*, Int_t); virtual voidAddAtAndExpand(TObject*, Int_t); virtual Int_tAddAtFree(TObject*); virtual voidAddBefore(const TObject*, TObject*); virtual voidAddFirst(TObject*); virtual voidAddLast(TObject*); TObject*AddrAt(Int_t idx); voidTCollection::AddVector(TObject* obj1); virtual TObject*TObjArray::After(const TObject* obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClonesArray.html:3669,reduce,reduce,3669,root/html528/TClonesArray.html,https://root.cern,https://root.cern/root/html528/TClonesArray.html,1,['reduce'],['reduce']
Energy Efficiency,"nfo::BuildForBool_t BuildFor(const TClass *cl) overrideCheck if we can build this for foreign class - do we have some rules to do that.Definition TStreamerInfo.cxx:1291; TStreamerInfo::Buildvoid Build(Bool_t isTransient=kFALSE) overrideBuild the I/O data structure for the current class version.Definition TStreamerInfo.cxx:263; TStreamerInfo::BuildOldvoid BuildOld() overriderebuild the TStreamerInfo structureDefinition TStreamerInfo.cxx:1705; TStreamerInfo::fReadMemberWiseTStreamerInfoActions::TActionSequence * fReadMemberWise! List of read action resulting from the compilation for use in member wise streaming.Definition TStreamerInfo.h:105; TStreamerInfo::GetTypeInt_t GetType(Int_t id) constDefinition TStreamerInfo.h:187; TStreamerInfo::fClassVersionInt_t fClassVersionClass version identifier.Definition TStreamerInfo.h:89; TStreamerInfo::fNdataInt_t fNdata!number of optimized elementsDefinition TStreamerInfo.h:93; TStreamerInfo::Newvoid * New(void *obj=nullptr) overrideAn emulated object is created at address obj, if obj is null we allocate memory for the object.Definition TStreamerInfo.cxx:4769; TStreamerInfo::TStreamerInfoTStreamerInfo()Status bits See TVirtualStreamerInfo::EStatusBits for the values.Definition TStreamerInfo.cxx:145; TStreamerInfo::fReadMemberWiseVecPtrTStreamerInfoActions::TActionSequence * fReadMemberWiseVecPtr! List of read action resulting from the compilation for use in member wise streaming.Definition TStreamerInfo.h:106; TStreamerInfo::fReadObjectWiseTStreamerInfoActions::TActionSequence * fReadObjectWise! List of read action resulting from the compilation.Definition TStreamerInfo.h:104; TStreamerInfo::GetActualClassTClass * GetActualClass(const void *obj) const overrideAssuming that obj points to (the part of) an object that is of the type described by this streamerInf...Definition TStreamerInfo.cxx:3255; TStreamerInfo::GetStreamerElementRealTStreamerElement * GetStreamerElementReal(Int_t i, Int_t j) constObsolete: this routine is obsolete ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:282249,allocate,allocate,282249,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,ng a proof session; TProofDraw Tree drawing selector for PROOF; TProofDrawEntryList A Selectoor to fill a TEntryList from TTree::Draw; TProofDrawEventList Tree drawing selector for PROOF; TProofDrawGraph Tree drawing selector for PROOF; TProofDrawHist Tree drawing selector for PROOF; TProofDrawListOfGraphs Tree drawing selector for PROOF; TProofDrawListOfGraphs::Point3D_t ; TProofDrawListOfPolyMarkers3D Tree drawing selector for PROOF; TProofDrawListOfPolyMarkers3D::Point4D_t ; TProofDrawPolyMarker3D Tree drawing selector for PROOF; TProofDrawProfile Tree drawing selector for PROOF; TProofDrawProfile2D Tree drawing selector for PROOF; TProofLimitsFinder Find and communicate best axis limits; TProofLite PROOF-Lite control class; TProofLog PROOF session log handler; TProofLogElem PROOF session log element; TProofMgr Abstract PROOF manager interface; TProofMgrLite XrdProofd PROOF manager interface; TProofMonSender Interface for PROOF monitoring; TProofMonSenderML Interface for PROOF monitoring; TProofMonSenderSQL Interface for PROOF monitoring; TProofNodeInfo Class describing a PROOF node; TProofNodes Node and worker information; TProofOutputFile Wrapper class to steer the merging of files produced on workers; TProofOutputList Output list specific TList derivation; TProofPerfAnalysis Set of tools to analyse the performance tree; TProofPlayer Basic PROOF player; TProofPlayerLite PROOF player running in PROOF-Lite; TProofPlayerLocal PROOF player running on client; TProofPlayerRemote PROOF player running on master server; TProofPlayerSlave PROOF player running on slave server; TProofPlayerSuperMaster PROOF player running on super master; TProofProgressDialog PROOF progress dialog; TProofProgressInfo Progress information; TProofProgressLog Class implementing a log graphic box; TProofProgressMemoryPlot PROOF progress memory plots; TProofProgressStatus Proof progress status class; TProofQueryResult Class describing a PROOF query; TProofResources Abstract class describing PROO,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:122767,monitor,monitoring,122767,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,3,['monitor'],['monitoring']
Energy Efficiency,ng a proof session; TProofDraw Tree drawing selector for PROOF; TProofDrawEntryList A Selectoor to fill a TEntryList from TTree::Draw; TProofDrawEventList Tree drawing selector for PROOF; TProofDrawGraph Tree drawing selector for PROOF; TProofDrawHist Tree drawing selector for PROOF; TProofDrawListOfGraphs Tree drawing selector for PROOF; TProofDrawListOfGraphs::Point3D_t ; TProofDrawListOfPolyMarkers3D Tree drawing selector for PROOF; TProofDrawListOfPolyMarkers3D::Point4D_t ; TProofDrawPolyMarker3D Tree drawing selector for PROOF; TProofDrawProfile Tree drawing selector for PROOF; TProofDrawProfile2D Tree drawing selector for PROOF; TProofLimitsFinder Find and communicate best axis limits; TProofLite PROOF-Lite control class; TProofLog PROOF session log handler; TProofLogElem PROOF session log element; TProofMgr Abstract PROOF manager interface; TProofMgrLite XrdProofd PROOF manager interface; TProofMonSender Interface for PROOF monitoring; TProofMonSenderML Interface for PROOF monitoring; TProofMonSenderSQL Interface for PROOF monitoring; TProofNodeInfo Class describing a PROOF node; TProofNodes Node and worker information; TProofOutputFile Wrapper class to steer the merging of files produced on workers; TProofOutputList Output list specific TList derivation; TProofPlayer Basic PROOF player; TProofPlayerLite PROOF player running in PROOF-Lite; TProofPlayerLocal PROOF player running on client; TProofPlayerRemote PROOF player running on master server; TProofPlayerSlave PROOF player running on slave server; TProofPlayerSuperMaster PROOF player running on super master; TProofProgressDialog PROOF progress dialog; TProofProgressInfo Progress information; TProofProgressLog Class implementing a log graphic box; TProofProgressMemoryPlot PROOF progress memory plots; TProofProgressStatus Proof progress status class; TProofQueryResult Class describing a PROOF query; TProofResources Abstract class describing PROOF resources; TProofResourcesStatic Class to handle PROOF static c,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:118403,monitor,monitoring,118403,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,1,['monitor'],['monitoring']
Energy Efficiency,"ng and logging; 808 ; 809 virtual void computeResult (const Net& /* net */, std::vector<double>& /* weights */) {} ///< callback for monitoring and logging; 810 ; 811 virtual bool hasConverged (double testError); ///< has this training converged already?; 812 ; 813 EnumRegularization regularization () const { return m_regularization; } ///< some regularization of the DNN is turned on?; 814 ; 815 bool useMultithreading () const { return m_useMultithreading; } ///< is multithreading turned on?; 816 ; 817 ; 818 void pads (int numPads) { if (fMonitoring) fMonitoring->pads (numPads); } ///< preparation for monitoring; 819 void create (std::string histoName, int bins, double min, double max) { if (fMonitoring) fMonitoring->create (histoName, bins, min, max); } ///< for monitoring; 820 void create (std::string histoName, int bins, double min, double max, int bins2, double min2, double max2) { if (fMonitoring) fMonitoring->create (histoName, bins, min, max, bins2, min2, max2); } ///< for monitoring; 821 void addPoint (std::string histoName, double x) { if (fMonitoring) fMonitoring->addPoint (histoName, x); } ///< for monitoring; 822 void addPoint (std::string histoName, double x, double y) {if (fMonitoring) fMonitoring->addPoint (histoName, x, y); } ///< for monitoring; 823 void plot (std::string histoName, std::string options, int pad, EColor color) { if (fMonitoring) fMonitoring->plot (histoName, options, pad, color); } ///< for monitoring; 824 void clear (std::string histoName) { if (fMonitoring) fMonitoring->clear (histoName); } ///< for monitoring; 825 bool exists (std::string histoName) { if (fMonitoring) return fMonitoring->exists (histoName); return false; } ///< for monitoring; 826 ; 827 size_t convergenceCount () const { return m_convergenceCount; } ///< returns the current convergence count; 828 size_t maxConvergenceCount () const { return m_maxConvergenceCount; } ///< returns the max convergence count so far; 829 size_t minError () const { return m_minError; } //",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:30902,monitor,monitoring,30902,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['monitor'],['monitoring']
Energy Efficiency,"ng data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulatedStreamer: the class is missing its shared library. void SetStreamerImpl(); Internal routine to set fStreamerImpl based on the value of; fStreamerType. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:54150,efficient,efficiently,54150,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['efficient'],['efficiently']
Energy Efficiency,"ng for every invocation TInterpreter::Execute(...). ; Definition at line 281 of file TMethodCall.cxx. ◆ Init() [2/4]. void TMethodCall::Init ; (; const TFunction * ; func). Initialize the method invocation environment based on the TFunction object. ; Definition at line 226 of file TMethodCall.cxx. ◆ Init() [3/4]. void TMethodCall::Init ; (; TClass * ; cl, . CallFunc_t * ; func, . Longptr_t ; offset = 0 . ). Initialize the method invocation environment based on the CallFunc object and the TClass describing the function context. ; Definition at line 185 of file TMethodCall.cxx. ◆ Init() [4/4]. void TMethodCall::Init ; (; TClass * ; cl, . const char * ; method, . const char * ; params, . Bool_t ; objectIsConst = kFALSE . ). Initialize the method invocation environment. ; Necessary input information: the class, method name and the parameter string of the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(object,...). This two step method is much more efficient than calling for every invocation TInterpreter::Execute(...). ; Definition at line 260 of file TMethodCall.cxx. ◆ InitImplementation(). void TMethodCall::InitImplementation ; (; const char * ; methodname, . const char * ; params, . const char * ; proto, . Bool_t ; objectIsConst, . TClass * ; cl, . const ClassInfo_t * ; cinfo, . ROOT::EFunctionMatchMode ; mode = ROOT::kConversionMatch . ). private . This function implements Init and InitWithPrototype. ; 'methodname' should NOT have any scope information in it. The scope information should be passed via the TClass or CINT ClassInfo. ; Definition at line 296 of file TMethodCall.cxx. ◆ InitWithPrototype() [1/2]. void TMethodCall::InitWithPrototype ; (; const char * ; function, . const char * ; proto, . ROOT::EFunctionMatchMode ; mode = ROOT::kConversionMatch . ). Initialize the function invocation environment. ; Necessary input information: the function name and the prototype string of the form: ""char*,int,float"".; To execute the method call TMe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMethodCall.html:24983,efficient,efficient,24983,doc/master/classTMethodCall.html,https://root.cern,https://root.cern/doc/master/classTMethodCall.html,1,['efficient'],['efficient']
Energy Efficiency,"ng processed per slave; TH2D*fProcTimeHist!histogram of real time spent processing packets; Int_tfSlaves!number of active slaves; Long64_tfTotBytesRead!total bytes read on all slaves; Double_tfTotCpuTime!total cpu time of all slaves; Long64_tfTotEvents!total number of events processed; TTree*fTrace!TTree with trace events; TTimeStampfTzero!start time of this run; static Long_tfgResMemMax! Max resident memory used by this process; static Long_tfgVirtMemMax! Max virtual memory used by this process. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPerfStats(TList* input, TList* output); Normal constructor. ~TPerfStats(); Destructor. void SimpleEvent(TVirtualPerfStats::EEventType type); Simple event. void PacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead); Packet event.; See WriteQueryLog for the descripition of the structure sent for monitoring; when fMonitorPerPacket is kTRUE. void FileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); File event. void FileOpenEvent(TFile* file, const char* filename, Double_t start); Open file event. void FileReadEvent(TFile* file, Int_t len, Double_t start); Read file event. void UnzipEvent(TObject* tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen); Record TTree file unzip event.; start is the TimeStamp before unzip; pos is where in the file the compressed buffer came from; complen is the length of the compressed buffer; objlen is the length of the de-compressed buffer. void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); Rate event. void SetBytesRead(Long64_t num); Set number of bytes read. Long64_t GetBytesRead() const; Get number of bytes read. void WriteQueryLog(); Send to the connected monitoring servers information related to this query.; The i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPerfStats.html:8697,monitor,monitoring,8697,root/html534/TPerfStats.html,https://root.cern,https://root.cern/root/html534/TPerfStats.html,3,['monitor'],['monitoring']
Energy Efficiency,"ng to do other than cleaning up.; 503 doDeletes();; 504 return;; 505 }; 506 ; 507 const ColumnNames_t cols(colsPtr, colsPtr + colsSize);; 508 ; 509 auto jittedDefine = wkJittedDefine->lock();; 510 ; 511 using Callable_t = std::decay_t<F>;; 512 using ColTypes_t = typename TTraits::CallableTraits<Callable_t>::arg_types;; 513 ; 514 auto ds = lm->GetDataSource();; 515 if (ds != nullptr); 516 AddDSColumns(cols, *lm, *ds, ColTypes_t(), *colRegister);; 517 ; 518 // will never actually be used (trumped by jittedDefine->GetTypeName()), but we set it to something meaningful; 519 // to help devs debugging; 520 const auto dummyType = ""jittedCol_t"";; 521 // use unique_ptr<RDefineBase> instead of make_unique<NewCol_t> to reduce jit/compile-times; 522 std::unique_ptr<RDefineBase> newCol{; 523 MakeDefineNode(RDefineTypeTag{}, name, dummyType, std::forward<F>(f), cols, *colRegister, *lm)};; 524 jittedDefine->SetDefine(std::move(newCol));; 525 ; 526 doDeletes();; 527}; 528 ; 529template <bool IsSingleColumn, typename F>; 530void JitVariationHelper(F &&f, const char **colsPtr, std::size_t colsSize, const char **variedCols,; 531 std::size_t variedColsSize, const char **variationTags, std::size_t variationTagsSize,; 532 std::string_view variationName, RLoopManager *lm,; 533 std::weak_ptr<RJittedVariation> *wkJittedVariation, RColumnRegister *colRegister,; 534 std::shared_ptr<RNodeBase> *prevNodeOnHeap) noexcept; 535{; 536 // a helper to delete objects allocated before jitting, so that the jitter can share data with lazily jitted code; 537 auto doDeletes = [&] {; 538 delete[] colsPtr;; 539 delete[] variedCols;; 540 delete[] variationTags;; 541 ; 542 delete wkJittedVariation;; 543 delete colRegister;; 544 delete prevNodeOnHeap;; 545 };; 546 ; 547 if (wkJittedVariation->expired()) {; 548 // The branch of the computation graph that needed this jitted variation went out of scope between the type; 549 // jitting was booked and the time jitting actually happened. Nothing to do other than cleani",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/InterfaceUtils_8hxx_source.html:23674,reduce,reduce,23674,doc/master/InterfaceUtils_8hxx_source.html,https://root.cern,https://root.cern/doc/master/InterfaceUtils_8hxx_source.html,2,"['allocate', 'reduce']","['allocated', 'reduce']"
Energy Efficiency,"ng.; 2091 ; 2092TString TString::Itoa(Int_t value, Int_t base); 2093{; 2094 std::string buf;; 2095 // check that the base if valid; 2096 if (base < 2 || base > 36) {; 2097 Error(""TString::Itoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base) ;; 2098 return (TString(""!""));; 2099 }; 2100 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2101 Int_t quotient = value;; 2102 // Translating number to string with base:; 2103 do {; 2104 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ TMath::Abs(quotient % base) ];; 2105 quotient /= base;; 2106 } while (quotient);; 2107 // Append the negative sign; 2108 if (value < 0) buf += '-';; 2109 std::reverse(buf.begin(), buf.end());; 2110 return (TString(buf.data()));; 2111}; 2112 ; 2113////////////////////////////////////////////////////////////////////////////////; 2114/// Converts a UInt_t (twice the range of an Int_t) to a TString with respect; 2115/// to the base specified (2-36). Thus it is an enhanced version of sprintf; 2116/// (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2117/// In case of error returns the ""!"" string.; 2118 ; 2119TString TString::UItoa(UInt_t value, Int_t base); 2120{; 2121 std::string buf;; 2122 // check that the base if valid; 2123 if (base < 2 || base > 36) {; 2124 Error(""TString::UItoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2125 return (TString(""!""));; 2126 }; 2127 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2128 UInt_t quotient = value;; 2129 // Translating number to string with base:; 2130 do {; 2131 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ quotient % base ];; 2132 quotient /= base;; 2133 } while (quotient);; 2134 std::reverse(buf.begin(), buf.end());; 2135 return (TString(buf.data()));; 2136}; 2137 ; 2138////////////////////////////////////////////////////////////////////////////////; 2139/// Converts a Long64_t to a TString with respect to the base specified (2-36).; 2140/// Thus ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:66519,adapt,adapted,66519,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['adapt'],['adapted']
Energy Efficiency,"ngEnabled () const;  ; void ResetSetFlag ();  resets the IsSet flag for all declare options to be called before options are read from stream ;  ; void WriteOptionsReferenceToFile ();  write complete options to output stream ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions; void DeclareOptions ();  MethodFisher options: format and syntax of option string: ""type"" where type is ""Fisher"" or ""Mahalanobis"". ;  ; void GetCov_BetweenClass (void);  the matrix of covariance 'between class' reflects the dispersion of the events of a class relative to the global center of gravity of all the class hence the separation between classes ;  ; void GetCov_Full (void);  compute full covariance matrix from sum of within and between matrices ;  ; void GetCov_WithinClass (void);  the matrix of covariance 'within class' reflects the dispersion of the events relative to the center of gravity of their own class ;  ; void GetDiscrimPower (void);  computation of discrimination power indicator for each variable small values of ""fWith"" indicates little compactness of sig & of backgd big values of ""fBetw"" indicates large separation between sig & backgd ;  ; void GetFisherCoeff (void);  Fisher = Sum { [coeff]*[variables] }. ;  ; void GetMean (void);  compute mean values of variables in each sample, and the overall means ;  ; void Init (void);  default initialization called by all constructors ;  ; void InitMatrices (void);  initialization method; creates global matrices and vectors ;  ; void ProcessOptions ();  process user options ;  . Private Attributes; TMatrixD * fBetw;  between-class matrix ;  ; TMatrixD * fCov;  full covariance matrix ;  ; std::vector< Double_t > * fDiscrimPow;  discriminating power ;  ; Double_t fF0;  offset ;  ; std::vector< Double_t > * fFisherCoeff;  Fisher coefficients. ;  ; EFish",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodFisher.html:30118,power,power,30118,doc/master/classTMVA_1_1MethodFisher.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodFisher.html,1,['power'],['power']
Energy Efficiency,"ngeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistPdf can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used on the integral over; all histogram observables is supported. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. Int_t getMaxVal(const RooArgSet& vars) const; Only handle case of maximum in all variables. Double_t maxVal(Int_t code) const. Bool_t areIdentical(const RooDataHist& dh1, const RooDataHist& dh2). Bool_t importWorkspaceHook(RooWorkspace& ws); Check if our datahist is already in the workspace. void Streamer(TBuffer& ); Stream an object of class RooHistPdf. TObject* clone(const char* newname) const; { return new RooHistPdf(*this,newname); }. RooDataHist& dataHist(); Return RooDataHist that is represented. const RooDataHist& dataHist() const; Return RooDataHist that is represented. void setInterpolationOrder(Int_t order); Set histogram interpolation order. Int_t getInterpolationOrder() const; Return histogram interpolation order. void setCdfBoundaries(Bool_t flag); Set use of special boundary conditions for c.d.f.s. Bool_t getCdfBoundaries() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHistPdf.html:46846,efficient,efficiently,46846,root/html534/RooHistPdf.html,https://root.cern,https://root.cern/root/html534/RooHistPdf.html,3,['efficient'],['efficiently']
Energy Efficiency,"ngeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistPdf can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used on the integral over; all histogram observables is supported. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. Int_t getMaxVal(const RooArgSet& vars) const; Only handle case of maximum in all variables. Double_t maxVal(Int_t code) const. Bool_t importWorkspaceHook(RooWorkspace& ws); Check if our datahist is already in the workspace. void Streamer(TBuffer& b); Stream an object of class RooHistPdf. TObject* clone(const char* newname) const; { return new RooHistPdf(*this,newname); }. RooDataHist& dataHist(); Return RooDataHist that is represented. const RooDataHist& dataHist() const; Return RooDataHist that is represented. void setInterpolationOrder(Int_t order); Set histogram interpolation order. Int_t getInterpolationOrder() const; Return histogram interpolation order. void setCdfBoundaries(Bool_t flag); Set use of special boundary conditions for c.d.f.s. Bool_t getCdfBoundaries() const; If true, special boundary conditions for c.d.f.s are used. vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHistPdf.html:45275,efficient,efficiently,45275,root/html532/RooHistPdf.html,https://root.cern,https://root.cern/root/html532/RooHistPdf.html,1,['efficient'],['efficiently']
Energy Efficiency,"ngeName = nullptr, . std::size_t ; nStart = 0, . std::size_t ; nStop = std::numeric_limits<std::size_t>::max() . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 280 of file RooCompositeDataStore.cxx. ◆ merge(). RooAbsDataStore * RooCompositeDataStore::merge ; (; const RooArgSet & ; allvars, . std::list< RooAbsDataStore * > ; dstoreList . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 335 of file RooCompositeDataStore.cxx. ◆ numEntries(). Int_t RooCompositeDataStore::numEntries ; (; ); const. overridevirtual . Implements RooAbsDataStore.; Definition at line 359 of file RooCompositeDataStore.cxx. ◆ recalculateCache(). void RooCompositeDataStore::recalculateCache ; (; const RooArgSet * ; proj, . Int_t ; firstEvent, . Int_t ; lastEvent, . Int_t ; stepSize, . bool ; skipZeroWeights . ). overridevirtual . Forward recalculate request to all subsets. ; Reimplemented from RooAbsDataStore.; Definition at line 149 of file RooCompositeDataStore.cxx. ◆ reduce(). std::unique_ptr< RooAbsDataStore > RooCompositeDataStore::reduce ; (; RooStringView ; name, . RooStringView ; title, . const RooArgSet & ; vars, . const RooFormulaVar * ; cutVar, . const char * ; cutRange, . std::size_t ; nStart, . std::size_t ; nStop . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 122 of file RooCompositeDataStore.cxx. ◆ reset(). void RooCompositeDataStore::reset ; (; ). overridevirtual . Implements RooAbsDataStore.; Definition at line 373 of file RooCompositeDataStore.cxx. ◆ resetBuffers(). void RooCompositeDataStore::resetBuffers ; (; ). overridevirtual . Implements RooAbsDataStore.; Definition at line 447 of file RooCompositeDataStore.cxx. ◆ resetCache(). void RooCompositeDataStore::resetCache ; (; ). overridevirtual . Implements RooAbsDataStore.; Definition at line 423 of file RooCompositeDataStore.cxx. ◆ setArgStatus(). void RooCompositeDataStore::setArgStatus ; (; const RooArgSet & ; set, . bool ; active . ). overridevirtual . Imple",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCompositeDataStore.html:28053,reduce,reduce,28053,doc/master/classRooCompositeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooCompositeDataStore.html,1,['reduce'],['reduce']
Energy Efficiency,"ngle used in TMap; TGRectangle Rectangle object; TGRedirectOutputGuard Exception safe output redirection; TGRegion Describes a region; TGRegionWithId Region with id, tooltip text and popup menu; TGResourcePool Graphics resource pool; TGRowLayout Row layout manager; TGSFile Read a ROOT file from the Google Storage cloud; TGScrollBar Scrollbar widget; TGScrollBarElement Scrollbar element (head, tail, slider); TGSearchDialog Text search dialog used by TGTextEdit widget; TGSearchType ; TGSelectBox TreeView dialog widget; TGSelectedPicture Selected looking picture; TGShapedFrame Shaped composite frame; TGShutter Shutter widget; TGShutterItem Shutter widget item; TGSimpleTable A simple table that owns it's interface.; TGSimpleTableInterface Interface to data in a 2D array of Double_t; TGSlider Slider widget abstract base class; TGSpeedo Base class for analog meter widget; TGSplitButton a split button widget; TGSplitFrame Splittable composite frame; TGSplitTool Split frame tool utility; TGSplitter A frame splitter abstract base class; TGStatusBar Status bar widget; TGString Graphics string; TGTRA GTRA shape; TGTab Tab widget; TGTabElement Little tab on tab widget; TGTabLayout Layout manager for TGTab widget; TGTable A table used to visualize data from diffent sources.; TGTableCell A single cell in a TGTable.; TGTableFrame A frame used internally by TGTable.; TGTableHeader Header for use in TGTable.; TGTableHeaderFrame A frame used internally by TGTable.; TGTableLayout Table layout manager; TGTableLayoutHints Class describing GUI table layout hints; TGText Text used by TGTextEdit; TGTextBuffer Text buffer used by widgets like TGTextEntry, etc.; TGTextButton A text button widget; TGTextEdit Text edit widget; TGTextEditor Simple text editor using TGTextEdit widget; TGTextEntry The TGTextEntry widget is a simple line editor for inputting text; TGTextLBEntry Text listbox entry; TGTextLayout Keep track of string measurement information.; TGTextLine Line in TGText; TGTextView Non-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:85534,meter,meter,85534,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,1,['meter'],['meter']
Energy Efficiency,"ngleCoordinateSize;; 667 const Char_t* endbuf = buf + singleCoordSize * chunkSize;; 668 for (; buf < endbuf; buf += singleCoordSize, ++idx) {; 669 Long64_t hash = compactCoord.GetHashFromBuffer(buf);; 670 Long64_t linidx = fBins.GetValue(hash);; 671 if (linidx) {; 672 Long64_t nextidx = linidx;; 673 while (nextidx) {; 674 // must be a collision, so go to fBinsContinued.; 675 linidx = nextidx;; 676 nextidx = fBinsContinued.GetValue(linidx);; 677 }; 678 fBinsContinued.Add(linidx, idx + 1);; 679 } else {; 680 fBins.Add(hash, idx + 1);; 681 }; 682 }; 683 }; 684}; 685 ; 686////////////////////////////////////////////////////////////////////////////////; 687/// Initialize storage for nbins; 688 ; 689void THnSparse::Reserve(Long64_t nbins) {; 690 if (!fBins.GetSize() && fBinContent.GetSize()) {; 691 FillExMap();; 692 }; 693 if (2 * nbins > fBins.Capacity()) {; 694 fBins.Expand(3 * nbins);; 695 }; 696}; 697 ; 698////////////////////////////////////////////////////////////////////////////////; 699/// Get the bin index for the n dimensional tuple x,; 700/// allocate one if it doesn't exist yet and ""allocate"" is true.; 701 ; 702Long64_t THnSparse::GetBin(const Double_t* x, Bool_t allocate /* = kTRUE */); 703{; 704 THnSparseCompactBinCoord* cc = GetCompactCoord();; 705 Int_t *coord = cc->GetCoord();; 706 for (Int_t i = 0; i < fNdimensions; ++i); 707 coord[i] = GetAxis(i)->FindBin(x[i]);; 708 cc->UpdateCoord();; 709 ; 710 return GetBinIndexForCurrentBin(allocate);; 711}; 712 ; 713 ; 714////////////////////////////////////////////////////////////////////////////////; 715/// Get the bin index for the n dimensional tuple addressed by ""name"",; 716/// allocate one if it doesn't exist yet and ""allocate"" is true.; 717 ; 718Long64_t THnSparse::GetBin(const char* name[], Bool_t allocate /* = kTRUE */); 719{; 720 THnSparseCompactBinCoord* cc = GetCompactCoord();; 721 Int_t *coord = cc->GetCoord();; 722 for (Int_t i = 0; i < fNdimensions; ++i); 723 coord[i] = GetAxis(i)->FindBin(name[i]);;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:26345,allocate,allocate,26345,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,2,['allocate'],['allocate']
Energy Efficiency,"ngside it.; 285 };; 286 ; 287 std::vector<ModuleHeaderInfo_t>& GetModuleHeaderInfoBuffer() {; 288 static std::vector<ModuleHeaderInfo_t> moduleHeaderInfoBuffer;; 289 return moduleHeaderInfoBuffer;; 290 }; 291}; 292 ; 293Int_t TROOT::fgDirLevel = 0;; 294Bool_t TROOT::fgRootInit = kFALSE;; 295 ; 296static void at_exit_of_TROOT() {; 297 if (ROOT::Internal::gROOTLocal); 298 ROOT::Internal::gROOTLocal->~TROOT();; 299}; 300 ; 301// This local static object initializes the ROOT system; 302namespace ROOT {; 303namespace Internal {; 304 class TROOTAllocator {; 305 // Simple wrapper to separate, time-wise, the call to the; 306 // TROOT destructor and the actual free-ing of the memory.; 307 //; 308 // Since the interpreter implementation (currently TCling) is; 309 // loaded via dlopen by libCore, the destruction of its global; 310 // variable (i.e. in particular clang's) is scheduled before; 311 // those in libCore so we need to schedule the call to the TROOT; 312 // destructor before that *but* we want to make sure the memory; 313 // stay around until libCore itself is unloaded so that code; 314 // using gROOT can 'properly' check for validity.; 315 //; 316 // The order of loading for is:; 317 // libCore.so; 318 // libRint.so; 319 // ... anything other library hard linked to the executable ...; 320 // ... for example libEvent; 321 // libCling.so; 322 // ... other libraries like libTree for example ....; 323 // and the destruction order is (of course) the reverse.; 324 // By default the unloading of the dictionary, does use; 325 // the service of the interpreter ... which of course; 326 // fails if libCling is already unloaded by that information; 327 // has not been registered per se.; 328 //; 329 // To solve this problem, we now schedule the destruction; 330 // of the TROOT object to happen _just_ before the; 331 // unloading/destruction of libCling so that we can; 332 // maximize the amount of clean-up we can do correctly; 333 // and we can still allocate the TROOT object's ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:10384,schedul,scheduled,10384,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,4,['schedul'],"['schedule', 'scheduled']"
Energy Efficiency,"nimization, but the weights are updated after considering all the; examples, with the total derivative dEdw. The parameters for this; method are Eta, EtaDecay, Delta and Epsilon.; Steepest descent algorithm: Weights; are set to the minimum along the line defined by the gradient. The; only parameter for this method is Tau. Lower tau = higher precision =; slower search. A value Tau = 3 seems reasonable.; Conjugate gradients with the; Polak-Ribiere updating formula: Weights are set to the; minimum along the line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Conjugate gradients with the; Fletcher-Reeves updating formula: Weights are set to the; minimum along the line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Broyden, Fletcher, Goldfarb, Shanno; (BFGS) method: Implies the computation of a NxN matrix; computation, but seems more powerful at least for less than 300; weights. Parameters are Tau and Reset, which defines the epochs where; the direction is reset to the steepes descent. How; to use it... TMLP is build from 3 classes: TNeuron, TSynapse and; TMultiLayerPerceptron. Only TMultiLayerPerceptron should be used; explicitely by the user.; TMultiLayerPerceptron will take examples from a TTree; given in the constructor. The network is described by a simple; string: The input/output layers are defined by giving the expression for; each neuron, separated by comas. Hidden layers are just described; by the number of neurons. The layers are separated by colons.; In addition, input/output layer formulas can be preceded by '@' (e.g ""@out""); if one wants to also normalize the data from the TTree.; Input and outputs are taken from the TTree given as second argument.; Expressions are evaluated as for TTree::Draw(), arrays are expended in; distinct neurons, one for each index.; This",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:5879,power,powerful,5879,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,3,['power'],['powerful']
Energy Efficiency,"nimization, but the weights are updated after considering all the; examples, with the total derivative dEdw. The parameters for this; method are Eta, EtaDecay, Delta and Epsilon.; Steepest descent algorithm: Weights; are set to the minimum along the line defined by the gradient. The; only parameter for this method is Tau. Lower tau = higher precision =; slower search. A value Tau = 3 seems reasonable.; Conjugate gradients with the; Polak-Ribiere updating formula: Weights are set to the; minimum along the line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Conjugate gradients with the; Fletcher-Reeves updating formula: Weights are set to the; minimum along the line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Broyden, Fletcher, Goldfarb, Shanno; (BFGS) method: Implies the computation of a NxN matrix; computation, but seems more powerful at least for less than 300; weights. Parameters are Tau and Reset, which defines the epochs where; the direction is reset to the steepes descent. How; to use it... TMLP is build from 3 classes: TNeuron, TSynapse and; TMultiLayerPerceptron. Only TMultiLayerPerceptron should be used; explicitly by the user.; TMultiLayerPerceptron will take examples from a TTree; given in the constructor. The network is described by a simple; string: The input/output layers are defined by giving the expression for; each neuron, separated by comas. Hidden layers are just described; by the number of neurons. The layers are separated by colons.; In addition, input/output layer formulas can be preceded by '@' (e.g ""@out""); if one wants to also normalize the data from the TTree.; Input and outputs are taken from the TTree given as second argument.; Expressions are evaluated as for TTree::Draw(), arrays are expended in; distinct neurons, one for each index.; This ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiLayerPerceptron.html:5877,power,powerful,5877,root/html534/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html534/TMultiLayerPerceptron.html,3,['power'],['powerful']
Energy Efficiency,"ning message is printed in each case, unless the Q verbose option is given. The number of events read and skipped is always summarized at the end.; If no further information is given a label name 'fileNNN' will be assigned to each event, where NNN is the sequential number of the source file in fileList.; Alternatively, it is possible to override the default label names of the index category by specifying them in the fileList string: When instead of file1.txt,file2.txt the string file1.txt:FOO,file2.txt:BAR is specified, a state named ""FOO"" is assigned to the index category for each event originating from file1.txt. The labels FOO,BAR may be predefined in the index category via defineType(), but don't have to be.; Finally, one can also assign the same label to multiple files, either by specifying file1.txt:FOO,file2,txt:FOO,file3.txt:BAR or file1.txt,file2.txt:FOO,file3.txt:BAR. ; Definition at line 1372 of file RooDataSet.cxx. ◆ reduceEng(). std::unique_ptr< RooAbsData > RooDataSet::reduceEng ; (; const RooArgSet & ; varSubset, . const RooFormulaVar * ; cutVar, . const char * ; cutRange = nullptr, . std::size_t ; nStart = 0, . std::size_t ; nStop = std::numeric_limits<std::size_t>::max() . ); const. overrideprotectedvirtual . Implementation of RooAbsData virtual method that drives the RooAbsData::reduce() methods. ; Implements RooAbsData.; Definition at line 684 of file RooDataSet.cxx. ◆ SetName(). void RooDataSet::SetName ; (; const char * ; name). overridevirtual . Change the name of this dataset into the given name. ; Reimplemented from RooAbsData.; Definition at line 1647 of file RooDataSet.cxx. ◆ SetNameTitle(). void RooDataSet::SetNameTitle ; (; const char * ; name, . const char * ; title . ). overridevirtual . Change the title of this dataset into the given name. ; Reimplemented from RooAbsData.; Definition at line 1659 of file RooDataSet.cxx. ◆ Streamer(). void RooDataSet::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class RooDataSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataSet.html:56093,reduce,reduceEng,56093,doc/master/classRooDataSet.html,https://root.cern,https://root.cern/doc/master/classRooDataSet.html,1,['reduce'],['reduceEng']
Energy Efficiency,"nitialize internal data-members for given particle parameters. void InitTrack(const TEveVectorF& v, Int_t charge); TEveVectorF wrapper. void ResetTrack(); Reset cache holding particle trajectory. Bool_t GoToVertex(TEveVectorD& v, TEveVectorD& p); Propagate particle with momentum p to vertex v. Bool_t GoToVertex(TEveVectorF& v, TEveVectorF& p); TEveVectorF wrapper. void GoToBounds(TEveVectorD& p); Propagate particle to bounds.; Return TRUE if hit bounds. void GoToBounds(TEveVectorF& p); TEveVectorF wrapper. void Update(const TEveVector4D& v, const TEveVectorD& p, Bool_t full_update = kFALSE, Bool_t enforce_max_step = kFALSE); Update helix / B-field projection state. void Step(const TEveVector4D& v, const TEveVectorD& p, TEveVector4D& vOut, TEveVectorD& pOut); Wrapper to step helix. void LoopToBounds(TEveVectorD& p); Propagate charged particle with momentum p to bounds.; It is expected that Update() with full-update was called before. Bool_t LoopToVertex(TEveVectorD& v, TEveVectorD& p); Propagate charged particle with momentum p to vertex v.; It is expected that Update() with full-update was called before. Bool_t LineToVertex(TEveVectorD& v); Propagate neutral particle to vertex v. void LineToBounds(TEveVectorD& p); Propagatate neutral particle with momentum p to bounds. Bool_t HelixIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); Intersect helix with a plane. Current position and argument p define; the helix. Bool_t LineIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); Intersect line with a plane. Current position and argument p define; the line. Bool_t IntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); Find intersection of currently propagated track with a plane.; Current track position is used as starting point. Args:; p - track momentum to use for extrapolation; point - a point on a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveTrackPropagator.html:26876,charge,charged,26876,root/html530/TEveTrackPropagator.html,https://root.cern,https://root.cern/root/html530/TEveTrackPropagator.html,2,['charge'],['charged']
Energy Efficiency,"nitoring. With such approach, a ROOT-based application creates and regularly updates content of a ROOT file, which can be accessed via normal web server. From the browser side, JSROOT could regularly read the specified objects and update their drawings. But such solution has three major caveats.; First of all, one need to store the data of all objects, which only potentially could be displayed in the browser. In case of 10 objects it does not matter, but for 1000 or 100000 objects this will be a major performance penalty. With such big amount of data one will never achieve higher update rate.; The second problem is I/O. To read the first object from the ROOT file, one need to perform several (about 5) file-reading operations via http protocol. There is no http file locking mechanism (at least not for standard web servers), therefore there is no guarantee that the file content is not changed/replaced between consequent read operations. Therefore, one should expect frequent I/O failures while trying to monitor data from ROOT binary files. There is a workaround for the problem - one could load the file completely and exclude many partial I/O operations by this. To achieve this with JSROOT, one should add “+” sign at the end of the file name. Of course, it only could work for small files.; If somebody still wants to use monitoring of data from ROOT files, could try link like:. https://root.cern/js/latest/?nobrowser&file=../files/hsimple.root+&item=hpx;1&monitoring=2000. In this particular case, the histogram is not changing.; 1.11 JSROOT API; JSROOT can be used in arbitrary HTML pages to display data, produced with or without ROOT-based applications.; Many different examples of JSROOT API usage can be found on JSROOT API examples page.; 1.11.1 Import JSROOT functionality; Major JSROOT functions are located in main.mjs module and can be imported like:; <script type='module'>; import { openFile, draw } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:22019,monitor,monitor,22019,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['monitor'],['monitor']
Energy Efficiency,"nked list before fNext */; 172 fPrev = fNext->prev;; 173 fNew->prev = fPrev;; 174 fPrev->next = fNew;; 175 fNew->next = fNext;; 176 fNext->prev = fNew;; 177 ; 178 fNew->anEdge = eOrig;; 179 fNew->data = NULL;; 180 fNew->trail = NULL;; 181 fNew->marked = FALSE;; 182 ; 183 /* The new face is marked ""inside"" if the old one was. This is a; 184 * convenience for the common case where a face has been split in two.; 185 */; 186 fNew->inside = fNext->inside;; 187 ; 188 /* fix other edges on this face loop */; 189 e = eOrig;; 190 do {; 191 e->Lface = fNew;; 192 e = e->Lnext;; 193 } while( e != eOrig );; 194}; 195 ; 196/* KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),; 197 * and removes from the global edge list.; 198 */; 199static void KillEdge( GLUhalfEdge *eDel ); 200{; 201 GLUhalfEdge *ePrev, *eNext;; 202 ; 203 /* Half-edges are allocated in pairs, see EdgePair above */; 204 if( eDel->Sym < eDel ) { eDel = eDel->Sym; }; 205 ; 206 /* delete from circular doubly-linked list */; 207 eNext = eDel->next;; 208 ePrev = eDel->Sym->next;; 209 eNext->Sym->next = ePrev;; 210 ePrev->Sym->next = eNext;; 211 ; 212 memFree( eDel );; 213}; 214 ; 215 ; 216/* KillVertex( vDel ) destroys a vertex and removes it from the global; 217 * vertex list. It updates the vertex loop to point to a given new vertex.; 218 */; 219static void KillVertex( GLUvertex *vDel, GLUvertex *newOrg ); 220{; 221 GLUhalfEdge *e, *eStart = vDel->anEdge;; 222 GLUvertex *vPrev, *vNext;; 223 ; 224 /* change the origin of all affected edges */; 225 e = eStart;; 226 do {; 227 e->Org = newOrg;; 228 e = e->Onext;; 229 } while( e != eStart );; 230 ; 231 /* delete from circular doubly-linked list */; 232 vPrev = vDel->prev;; 233 vNext = vDel->next;; 234 vNext->prev = vPrev;; 235 vPrev->next = vNext;; 236 ; 237 memFree( vDel );; 238}; 239 ; 240/* KillFace( fDel ) destroys a face and removes it from the global face; 241 * list. It updates the face loop to point to a given new face.; 242 */; 243static void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/mesh_8c_source.html:6724,allocate,allocated,6724,doc/master/mesh_8c_source.html,https://root.cern,https://root.cern/doc/master/mesh_8c_source.html,1,['allocate'],['allocated']
Energy Efficiency,"nly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions; void CalculatePrincipalComponents (const std::vector< Event * > &);  calculate the principal components for the signal and the background data it uses the MakePrincipal method of ROOT's TPrincipal class ;  ; void P2X (std::vector< Float_t > &, const std::vector< Float_t > &, Int_t cls) const;  Perform the back-transformation from the principal components pc, and return x It's the users responsibility to make sure that both x and pc are of the right size (i.e., memory must be allocated for p) ;  ; void X2P (std::vector< Float_t > &, const std::vector< Float_t > &, Int_t cls) const;  Calculate the principal components from the original data vector x, and return it in p (function extracted from TPrincipal::X2P) It's the users responsibility to make sure that both x and p are of the right size (i.e., memory must be allocated for p) ;  . Private Attributes; std::vector< TMatrixD * > fEigenVectors;  eigenvectors ;  ; std::vector< TVectorD * > fMeanValues;  mean values ;  . Additional Inherited Members;  Public Types inherited from TMVA::VariableTransformBase; typedef VectorOfCharAndInt::iterator ItVarTypeIdx;  ; typedef VectorOfCharAndInt::const_iterator ItVarTypeIdxConst;  ; typedef std::vector< std::pair< Char_t, UInt_t > > VectorOfCharAndInt;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1VariablePCATransform.html:13362,allocate,allocated,13362,doc/master/classTMVA_1_1VariablePCATransform.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1VariablePCATransform.html,1,['allocate'],['allocated']
Energy Efficiency,"nly the observed plot; EXP : draw only the expected plot; CLB : draw also the CLB; 2CL : draw both clsplusb and cls. default draw observed + expected with 1 and 2 sigma bands ; Reimplemented from TObject.; Definition at line 276 of file HypoTestInverterPlot.cxx. ◆ IsA(). TClass * RooStats::HypoTestInverterPlot::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 76 of file HypoTestInverterPlot.h. ◆ MakeExpectedPlot(). TMultiGraph * HypoTestInverterPlot::MakeExpectedPlot ; (; double ; sig1 = 1, . double ; sig2 = 2 . ). Make the expected plot and the bands nsig1 and nsig2 indicates the n-sigma value for the bands if nsig1 = 0 no band is computed (only expected value) if nsig2 > nsig1 (default is nsig1=1 and nsig2=2) the second band is also done. ; Make the expected plot and the bands nsig1 and nsig2 indicates the n-sigma value for the bands if nsig1 = 0 no band is drawn (only expected value) if nsig2 > nsig1 (default is nsig1=1 and nsig2=2) the second band is also drawn The first band is drawn in green while the second in yellow THe return result is a TMultiGraph object.; The first band is drawn in green while the second in yellow The plot (expected value + bands) is returned as a TMultiGraph object ; Definition at line 149 of file HypoTestInverterPlot.cxx. ◆ MakePlot(). TGraphErrors * HypoTestInverterPlot::MakePlot ; (; Option_t * ; opt = """"). return a TGraphErrors with the obtained observed p-values resultinf from the scan By default (Option = """") return CLs or CLsb depending if the flag UseCLs is set If Option = ""CLb"" return CLb plot = ""CLs+b"" return CLs+b plot independently of the flag = ""CLs"" return CLs plot independently of the flag ; Make the plot of the result of the scan using the observed data.; By default plot CLs or CLsb depending if the flag UseCLs is set for the results that are passed to this instance.; Parameters. optOptions according to following list:; Empty: Return CLs ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HypoTestInverterPlot.html:15963,green,green,15963,doc/master/classRooStats_1_1HypoTestInverterPlot.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HypoTestInverterPlot.html,1,['green'],['green']
Energy Efficiency,"nlyPrepStep = (1ULL << ( 3 )); };  . #include <TSpectrumTransform.h>. Inheritance diagram for TSpectrumTransform:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ anonymous enum. anonymous enum. EnumeratorkTransformHaar ; kTransformWalsh ; kTransformCos ; kTransformSin ; kTransformFourier ; kTransformHartley ; kTransformFourierWalsh ; kTransformFourierHaar ; kTransformWalshHaar ; kTransformCosWalsh ; kTransformCosHaar ; kTransformSinWalsh ; kTransformSinHaar ; kTransformForward ; kTransformInverse . Definition at line 31 of file TSpectrumTransform.h. Constructor & Destructor Documentation. ◆ TSpectrumTransform() [1/2]. TSpectrumTransform::TSpectrumTransform ; (; ). default constructor ; Definition at line 40 of file TSpectrumTransform.cxx. ◆ TSpectrumTransform() [2/2]. TSpectrumTransform::TSpectrumTransform ; (; Int_t ; size). the constructor creates TSpectrumTransform object. ; Its size must be > than zero and must be power of 2. It sets default transform type to be Cosine transform. Transform parameters can be changed using setter functions. ; Definition at line 56 of file TSpectrumTransform.cxx. ◆ ~TSpectrumTransform(). TSpectrumTransform::~TSpectrumTransform ; (; ). override . Destructor. ; Definition at line 85 of file TSpectrumTransform.cxx. Member Function Documentation. ◆ BitReverse(). void TSpectrumTransform::BitReverse ; (; Double_t * ; working_space, . Int_t ; num . ). protected . This function carries out bit-reverse reordering of data Function parameters: . working_space-pointer to vector of processed data; num-length of processed data . Definition at line 227 of file TSpectrumTransform.cxx. ◆ BitReverseHaar(). void TSpectrumTransform::BitReverseHaar ; (; Double_t * ; working_space, . Int_t ; shift, . Int_t ; num, . Int_t ; start . ). protected . This function carries out bit-reverse reordering for Haar transform Function parameters: . working_space-pointer to vector of p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumTransform.html:16855,power,power,16855,doc/master/classTSpectrumTransform.html,https://root.cern,https://root.cern/doc/master/classTSpectrumTransform.html,1,['power'],['power']
Energy Efficiency,"nnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfAdaptiveBandwidthFactorGeometric mean of the kernel density estimation from the data for adaptive iteration; TF1*fApproximateBiasOutput Kernel Density Estimation approximate bias; Bool_tfAsymLeft; Bool_tfAsymRight; vector<UInt_t>fBinCountNumber of events per bin for binned data option; TKDE::EBinningfBinning; vector<Double_t>fCanonicalBandwidths; vector<Double_t>fDataData events; vector<Double_t>fEventsOriginal data storage; TGraphErrors*fGraphGraph with the errors; TKDE::EIterationfIteration; TKDE::TKernel*fKernel; ROOT::Math::IBaseFunctionOneDim*fKernelFunction; vector<Double_t>fKernelSigmas2; TKDE::EKernelTypefKernelType; TF1*fLowerPDFOutput Kernel Density Estimation lower confidence interval PDF function; Double_tfMeanData mean; TKDE::EMirrorfMirror; Bool_tfMirrorLeft; Bool_tfMirrorRight; UInt_tfNBinsNumber of bins for binned data option; UInt_tfNEventsData's number of events; Bool_tfNewDataflag to control when new data are given; TF1*fPDFOutput Kernel Density Estimation PDF function; Double_tfRhoAdjustment factor for sigma; vector<Bool_t>fSettedOptionsUser input options flag; Double_tfSigmaData std deviation; Double_tfSigmaRobData std deviation (robust estimation); TF1*fUpperPDFOutput Kernel Density Estimation upper confidence interval PDF function; Bool_tfUseBins; UInt_tfUseBinsNEventsIf the algorithm is allowed to use binning this is the minimum number of events to do so; Bool_tfUseMinMaxFromDataflag top control if min and max must be used from data; Bool_tfUseMirroring; Double_tfWeightSizeCaches the weight size; Double_tfXMaxData maximum value; Double_tfXMinData minimum value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKDE(UInt_t events = 0, const Double_t* data = 0, Double_t xMin = 0.0, Double_t xMax = 0.0, Option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKDE.html:9226,adapt,adaptive,9226,root/html528/TKDE.html,https://root.cern,https://root.cern/root/html528/TKDE.html,4,['adapt'],['adaptive']
Energy Efficiency,"nonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TGeoNode**fArray![fMaxLevel+1] Array of nodes; Int_tfLevelBranch depth; TGeoHMatrixfMatrixGlobal matrix (owned); Int_tfMaxLevelArray length; TGeoNode*fRealArray[1]Beginning address of the array of nodes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBranchArray(Int_t level); Constructor. Alocates the array with a size given by level. TGeoBranchArray * MakeInstance(size_t maxlevel); Make an instance of the class which allocates the node array. To be; released using ReleaseInstance. If addr is non-zero, the user promised that; addr contains at least that many bytes: size_t needed = SizeOf(maxlevel);. TGeoBranchArray * MakeInstanceAt(size_t maxlevel, void* addr); Make an instance of the class which allocates the node array. To be; released using ReleaseInstance. If addr is non-zero, the user promised that; addr contains at least that many bytes: size_t needed = SizeOf(maxlevel);. TGeoBranchArray * MakeCopy(const TGeoBranchArray& other); Make a copy of a branch array at the location (if indicated). TGeoBranchArray * MakeCopyAt(const TGeoBranchArray& other, void* addr); Make a copy of a branch array at the location (if indicated). void CopyTo(TGeoBranchArray* dest); Raw memcpy of the branch array content to an existing destination. void ReleaseInstance(TGeoBranchArray* obj); Releases the space allocated for the object. void UpdateArray(size_t nobj); Updates the internal addresses for n contiguous objects which have the same; fMaxLevel; Updates the internal addresses for n contiguous objects which have the same fMaxLevel. TGeoBranchArray(const TGeoBranchArray& ); Copy constructor. Not callable anymore. Use TGeoBranchArray::MakeCopy instead. TGeoB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoBranchArray.html:8275,allocate,allocates,8275,root/html604/TGeoBranchArray.html,https://root.cern,https://root.cern/root/html604/TGeoBranchArray.html,1,['allocate'],['allocates']
Energy Efficiency,"nonymous)TObject::kZombie. protected:. ULong_tTGX11::fBlackPixelValue of black pixel in colormap; Int_tTGX11::fBlueDivBlue value divider; Int_tTGX11::fBlueShiftBits to left shift blue; Float_tTGX11::fCharacterUpXCharacter Up vector along X; Float_tTGX11::fCharacterUpYCharacter Up vector along Y; ColormapTGX11::fColormapDefault colormap, 0 if b/w; Int_tTGX11::fDepthNumber of color planes; void*TGX11::fDisplayPointer to display; TVirtualX::EDrawModeTVirtualX::fDrawModeDrawing mode; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Int_tTGX11::fGreenDivGreen value divider; Int_tTGX11::fGreenShiftBits to left shift green; Bool_tTGX11::fHasTTFontsTrue when TrueType fonts are used; Bool_tTGX11::fHasXftTrue when XftFonts are used; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; TStringTNamed::fNameobject identifier; Int_tTGX11::fRedDivRed value divider, -1 if no TrueColor visual; Int_tTGX11::fRedShiftBits to left shift red, -1 if no TrueColor visual; DrawableTGX11::fRootWinRoot window used as parent of all windows; Int_tTGX11::fScreenNumberScreen number; Int_tTGX11::fTextAlignText alignment (set in SetTextAlign); Short_tTAttText::fTextAlignText alignment; Int_tTGX11::fTextAlignHText Alignment Horizontal; Int_tTGX11::fTextAlignVText Alignment Vertical; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTGX11::fTextMagnitudeText Magnitude; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; DrawableTGX11::fVisRootWinRoot window with fVisual to be used to create GC's and XImages; RVisual*TGX11::fVisualPointer to visual used by all windows; ULong_tTGX11::fWhitePixelValue of white pixel in colormap. private:. FT_VectorfAlignalignment ve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGX11TTF.html:25292,green,green,25292,root/html604/TGX11TTF.html,https://root.cern,https://root.cern/root/html604/TGX11TTF.html,1,['green'],['green']
Energy Efficiency,"normRange () const;  ; virtual RooPlot * paramOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Add a box with parameter values (and errors) to the specified frame. ;  ; RooPlot * plotOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const override;  Helper calling plotOn(RooPlot*, RooLinkedList&) const. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const override;  Plot (project) PDF on specified frame. ;  ; GenSpec * prepareMultiGen (const RooArgSet &whatVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={});  Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Print multi line detailed information of this RooAbsPdf. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; virtual bool selfNormalized () const;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given config",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBMixDecay.html:16156,efficient,efficient,16156,doc/master/classRooBMixDecay.html,https://root.cern,https://root.cern/doc/master/classRooBMixDecay.html,49,['efficient'],['efficient']
Energy Efficiency,"normRange () const;  ; virtual RooPlot * paramOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Add a box with parameter values (and errors) to the specified frame. ;  ; RooPlot * plotOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const override;  Helper calling plotOn(RooPlot*, RooLinkedList&) const. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const override;  Plot (project) PDF on specified frame. ;  ; GenSpec * prepareMultiGen (const RooArgSet &whatVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={});  Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Print multi line detailed information of this RooAbsPdf. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedPdf.html:13413,efficient,efficient,13413,doc/master/classRooCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooCachedPdf.html,18,['efficient'],['efficient']
Energy Efficiency,"normRange () const;  ; virtual RooPlot * paramOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Add a box with parameter values (and errors) to the specified frame. ;  ; RooPlot * plotOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const override;  Helper calling plotOn(RooPlot*, RooLinkedList&) const. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const override;  Plot (project) PDF on specified frame. ;  ; GenSpec * prepareMultiGen (const RooArgSet &whatVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={});  Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Print multi line detailed information of this RooAbsPdf. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:15602,efficient,efficient,15602,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,2,['efficient'],['efficient']
Energy Efficiency,"normRange () const;  ; virtual RooPlot * paramOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Add a box with parameter values (and errors) to the specified frame. ;  ; RooPlot * plotOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const override;  Helper calling plotOn(RooPlot*, RooLinkedList&) const. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const override;  Plot (project) PDF on specified frame. ;  ; GenSpec * prepareMultiGen (const RooArgSet &whatVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={});  Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; virtual bool selfNormalized () const;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGenericPdf.html:13706,efficient,efficient,13706,doc/master/classRooGenericPdf.html,https://root.cern,https://root.cern/doc/master/classRooGenericPdf.html,1,['efficient'],['efficient']
Energy Efficiency,"normRange () const;  ; virtual RooPlot * paramOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Add a box with parameter values (and errors) to the specified frame. ;  ; RooPlot * plotOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const override;  Helper calling plotOn(RooPlot*, RooLinkedList&) const. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const override;  Plot (project) PDF on specified frame. ;  ; GenSpec * prepareMultiGen (const RooArgSet &whatVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={});  Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGaussModel.html:13974,efficient,efficient,13974,doc/master/classRooGaussModel.html,https://root.cern,https://root.cern/doc/master/classRooGaussModel.html,4,['efficient'],['efficient']
Energy Efficiency,"normRange () const;  ; virtual RooPlot * paramOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Add a box with parameter values (and errors) to the specified frame. ;  ; RooPlot * plotOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const override;  Helper calling plotOn(RooPlot*, RooLinkedList&) const. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const override;  Plot (project) PDF on specified frame. ;  ; GenSpec * prepareMultiGen (const RooArgSet &whatVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={});  Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'value'. ;  ; RooNumGenConfig * specialGeneratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumGenConfig *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:15320,efficient,efficient,15320,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['efficient'],['efficient']
Energy Efficiency,"not likely to fit new data at all 1. Therefore, the user is asked to provide an upper limit, \( L_{max}\) to the number of terms in \( D_p\) (TMultiDimFit::SetMaxTerms).; However, since there's an infinite number of \( F_l\) to choose from, the user is asked to give the maximum power. \( P_{max,i}\), of each variable \( x_i\) to be considered in the minimization of \( S\) (TMultiDimFit::SetMaxPowers).; One way of obtaining values for the maximum power in variable \( i\), is to perform a regular fit to the dependent quantity \( D\), using a polynomial only in \( x_i\). The maximum power is \( P_{max,i}\) is then the power that does not significantly improve the one-dimensional least-square fit over \( x_i\) to \( D\) 5.; There are still a huge amount of possible choices for \( F_l\); in fact there are \(\prod_{i=1}^{N} (P_{max,i} + 1)\) possible choices. Obviously we need to limit this. To this end, the user is asked to set a power control limit, \( Q\) (TMultiDimFit::SetPowerLimit), and a function \( F_l\) is only accepted if ; \[; Q_l = \sum_{i=1}^{N} \frac{P_{li}}{P_{max,i}} < Q; \]. where \( P_{li}\) is the leading power of variable \( x_i\) in function \( F_l\) (TMultiDimFit::MakeCandidates). So the number of functions increase with \( Q\) (1, 2 is fine, 5 is way out). Gram-Schmidt Orthogonalisation; To further reduce the number of functions in the final expression, only those functions that significantly reduce \( S\) is chosen. What ‘significant’ means, is chosen by the user, and will be discussed below (see 2.3).; The functions \( F_l\) are generally not orthogonal, which means one will have to evaluate all possible \( F_l\)'s over all data-points before finding the most significant 1. We can, however, do better then that. By applying the modified Gram-Schmidt orthogonalisation algorithm [5] [3] to the functions \( F_l\), we can evaluate the contribution to the reduction of \( S\) from each function in turn, and we may delay the actual inversion of the curvat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:5169,power,power,5169,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['power'],['power']
Energy Efficiency,"noting the drop-out probabilities for each layer ; endend of an array or vector denoting the drop-out probabilities for each layer ; _dropRepetitionsdenotes after how many repetitions the drop-out setting (which nodes are dropped out exactly) is changed . Definition at line 759 of file NeuralNet.h. ◆ setMonitoring(). void TMVA::DNN::Settings::setMonitoring ; (; std::shared_ptr< Monitoring > ; ptrMonitoring). inline . prepared for monitoring ; Definition at line 764 of file NeuralNet.h. ◆ setProgressLimits(). virtual void TMVA::DNN::Settings::setProgressLimits ; (; double ; minProgress = 0, . double ; maxProgress = 100 . ). inlinevirtual . Parameters. maxProgressfor monitoring and logging (set the current ""progress"" limits for the display of the progress); minProgressminimum value; maxProgressmaximum value . Definition at line 790 of file NeuralNet.h. ◆ startTestCycle(). virtual void TMVA::DNN::Settings::startTestCycle ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 804 of file NeuralNet.h. ◆ startTrainCycle(). virtual void TMVA::DNN::Settings::startTrainCycle ; (; ). inlinevirtual . Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 782 of file NeuralNet.h. ◆ startTraining(). virtual void TMVA::DNN::Settings::startTraining ; (; ). inlinevirtual . Definition at line 795 of file NeuralNet.h. ◆ testIteration(). virtual void TMVA::DNN::Settings::testIteration ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 806 of file NeuralNet.h. ◆ testRepetitions(). size_t TMVA::DNN::Settings::testRepetitions ; (; ); const. inline . how often is the test data tested ; Definition at line 768 of file NeuralNet.h. ◆ testSample(). virtual void TMVA::DNN::Settings::testSample ; (; double ; , . double ; , . double ; , . double ;  . ). inlinevirtual . virtual function to be used for monitoring (callba",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:11766,monitor,monitoring,11766,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['monitor'],['monitoring']
Energy Efficiency,"nown);; gr2->SetMarkerColor(kRed);; gr2->SetMarkerStyle(8);; gr2->SetMarkerSize(1);; mg->Add(gr2);; ; //passing x and y values to R for fitting; ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; r[""x""]<<TVectorD(n, x);; r[""y""]<<TVectorD(n, y);; //creating a R data frame; r<<""ds<-data.frame(x=x,y=y)"";; //fitting x and y to X^power using Nonlinear Least Squares; r<<""m <- nls(y ~ I(x^power),data = ds, start = list(power = 1),trace = T)"";; //getting the fitted value (power); Double_t power;; r[""summary(m)$coefficients[1]""]>>power;; ; TF1 *f_fitted=new TF1(""f_fitted"",""pow(x,[0])"",0,1);; f_fitted->SetParameter(0,power);; //plotting the fitted function; TGraph *gr3 = new TGraph(f_fitted);; gr3->SetMarkerColor(kGreen);; gr3->SetMarkerStyle(8);; gr3->SetMarkerSize(1);; ; mg->Add(gr3);; mg->Draw(""ap"");; ; //displaying basic results; TPaveText *pt = new TPaveText(0.1,0.6,0.5,0.9,""brNDC"");; pt->SetFillColor(18);; pt->SetTextAlign(12);; pt->AddText(""Fitting x^power "");; pt->AddText("" \""Blue\"" Points with gaussian noise to be fitted"");; pt->AddText("" \""Red\"" Known function x^3"");; TString fmsg;; fmsg.Form("" \""Green\"" Fitted function with power=%.4lf"",power);; pt->AddText(fmsg);; pt->Draw();; c1->Update();; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TVectorDTVectorT< Double_t > TVectorDDefinition TVectorDfwd.h:23; ROOT::R::TRInterfaceROOT R was implemented using the R Project library and the modules Rcpp and RInsideDefinition TRInterface.h:136; ROOT::R::TRInterface::Instancestatic TRInterface & Instance()static method to get an TRInterface instance referenceDefinition TRInterface.cxx:187; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1R_1_1TRInterface.html:2963,power,power,2963,doc/master/classROOT_1_1R_1_1TRInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1R_1_1TRInterface.html,1,['power'],['power']
Energy Efficiency,"nr_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSparse_float_.html:17762,allocate,allocated,17762,root/html528/TMatrixTSparse_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_float_.html,6,['allocate'],['allocated']
Energy Efficiency,"ns maximum number of objects displayed when the node is top node on scene. ;  ; TList * GetMembers () const;  Returns list with pointers to daughter nodes. ;  ; ULong_t GetMembersCount () const;  Returns numbers of members of node. ;  ; Float_t GetMiddle () const;  Returns center of outlining box on y-axis. ;  ; const char * GetName () const override;  Returns name of object. ;  ; ENodeType GetNodeType () const;  Returns type of node. ;  ; TStructNode * GetParent () const;  Returns pointer to parent node. ;  ; void * GetPointer () const;  Returns main pointer. ;  ; ULong_t GetRelativeMembersCount () const;  Returns relative numbers of members. ;  ; ULong_t GetRelativeSize () const;  Returns relative size of node. ;  ; ULong_t GetRelativeVolume () const;  Returns size or number of members. ;  ; Float_t GetRelativeVolumeRatio ();  Returns ratio - relative volume to area taken by utlining box. ;  ; ULong_t GetSize () const;  Returns size of node. ;  ; ULong_t GetTotalSize () const;  Returns total size of allocated memory in bytes. ;  ; TString GetTypeName () const;  Returns name of class. ;  ; ULong_t GetVolume () const;  Returns size or number of members. ;  ; Float_t GetVolumeRatio ();  Returns ratio - volme of node to area taken by outlining box. ;  ; Float_t GetWidth () const;  Returns width of outlining box. ;  ; Float_t GetX () const;  Returns X coordinate. ;  ; Float_t GetY () const;  Returns Y coordinate. ;  ; TClass * IsA () const override;  ; Bool_t IsCollapsed () const;  Returns true if node is colllapsed. ;  ; Bool_t IsSortable () const override;  Returns true, because we have overrided method Compare. ;  ; bool IsVisible () const;  Returns true if node is visible. ;  ; void SetAllMembersCount (ULong_t count);  Sets numbers of all members to ""number"". ;  ; void SetCollapsed (Bool_t collapsed);  Sets collapsing of node to ""collapse"". ;  ; void SetHeight (Float_t h);  Sets width of outlining box to ""w"". ;  ; void SetMaxLevel (UInt_t level);  Sets maximum numb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStructNode.html:2239,allocate,allocated,2239,doc/master/classTStructNode.html,https://root.cern,https://root.cern/doc/master/classTStructNode.html,1,['allocate'],['allocated']
Energy Efficiency,"ns |; Private Attributes |; Friends |; List of all members ; TMonitor Class Reference. . Definition at line 36 of file TMonitor.h. Public Types; enum  EInterest { kRead = 1; , kWrite = 2; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TMonitor (Bool_t mainloop=kTRUE);  Create a monitor object. ;  ;  TMonitor (const TMonitor &m);  Copy constructor. ;  ; virtual ~TMonitor ();  Cleanup the monitor object. Does not delete sockets being monitored. ;  ; virtual void Activate (TSocket *sock);  Activate a de-activated socket. ;  ; virtual void ActivateAll ();  Activate all de-activated sockets. ;  ; virtual void Add (TSocket *sock, Int_t interest=kRead);  Add socket to the monitor's active list. ;  ; virtual void DeActivate (TSocket *sock);  De-activate a socket. ;  ; virtual void DeActivateAll ();  De-activate all activated sockets. ;  ; Int_t GetActive (Long_t timeout=-1) const;  Return number of sockets in the active list. ;  ; Int_t GetDeActive () const;  Return number of sockets in the de-active list. ;  ; TList * GetListOfActives () const;  Returns a list with all active sockets. ;  ; TList * GetListOfDeActives () const;  Returns a list with all de-active sockets. ;  ; void Interrupt ();  ; TClass * IsA () const override;  ; Bool_t IsActive (TSocket *s) const;  Check if socket 's' is in the active list. ;  ; virtual void Ready (TSocket *sock);  Emit signal ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMonitor.html:1250,monitor,monitor,1250,doc/master/classTMonitor.html,https://root.cern,https://root.cern/doc/master/classTMonitor.html,1,['monitor'],['monitor']
Energy Efficiency,"ns; RooNDKeysPdf General N-dimensional non-parametric kernel estimation p.d.f; RooNLLVar Function representing (extended) -log(L) of p.d.f and dataset; RooNameReg String name registry; RooNameSet A sterile version of RooArgSet, containing only the names of the contained RooAbsArgs; RooNonCPEigenDecay PDF to model CP-violating decays to final states which are not CP eigenstates; RooNormSetCache Management tool for tracking sets of similar integration/normalization sets; RooNovosibirsk Novosibirsk PDF; RooNumCdf Numeric calculator for CDF for a given PDF; RooNumConvPdf Operator PDF implementing numeric convolution of 2 input PDFs; RooNumConvolution Operator PDF implementing numeric convolution of 2 input functions; RooNumGenConfig Numeric (MC) Event generator configuration ; RooNumGenFactory Numeric Generator factory; RooNumIntConfig Numeric Integrator configuration ; RooNumIntFactory Numeric Integrator factory; RooNumRunningInt Numeric calculator for running integral of a given function; RooNumber wrapper class for portable numerics; RooObjCacheManager Cache manager for generic caches that contain RooAbsArg objects; RooParamBinning Binning specification with ranges parameterized by external RooAbsReal functions; RooParametricStepFunction Parametric Step Function Pdf; RooPlot Plot frame and container for graphics objects; RooPlotable Abstract interface for plotable objects in a RooPlot; RooPoisson A Poisson PDF; RooPolyVar Polynomial function; RooPolynomial Polynomial PDF; RooPrintable Interface for printable objects; RooProdGenContext Context for efficient generation of a a dataset from a RooProdPdf; RooProdPdf PDF representing a product of PDFs; RooProduct Product of RooAbsReal and/or RooAbsCategory terms; RooProfileLL Real-valued function representing profile likelihood of external (likelihood) function; RooProjectedPdf Operator p.d.f calculating projection of another p.d.f; RooPullVar Calculation of pull of measurement w.r.t a truth value; RooQuasiRandomGenerator Q",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:38825,efficient,efficient,38825,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['efficient'],['efficient']
Energy Efficiency,"ns; geometrical functions. For more details, see the reference documentation of TMath at <http://root.cern.ch/root/htmldoc/TMath.html>.; 13.3.1 Numerical Constants; TMath offers a wide range of constants in the form of inline functions. Notice that they are not defined as C/C++ preprocessor macros. This set of functions includes one or more definitions for the following constants:. Pi.; Base of natural logarithm.; Velocity of light.; Gravitational constant (G).; Standard acceleration of gravity (g).; Standard acceleration of Gravity.; Plank’s contant.; Boltzmann’s and Steffan-Boltzmann’s constants.; Avogadro’s number.; Universal gas constant.; Molecular weight of dry air.; Dry air gas constant.; Euler-Mascheroni Constant.; Elementary charge. 13.3.2 Elementary Functions; A set of miscellaneous elementary mathematical functions is provided along with a set of basic trigonometrical functions. Some of this functions refer to basic mathematical functions like the square root, the power to a number of the calculus of a logarithm, while others are used for number treatment, like rounding.; Although there are some functions that are not in the standard C math library (like Factorial), most of the functionality offered here is just a wrapper of the first ones. Nevertheless, some of the them also offer some security checks or a better precision, like the trigonometrical functions ASin(x), ACos(x) or ATan(x).; // Generate a vector with 10 random numbers; vector<double> v(10);; std::generate(v.begin(), v.end(), rand);. // Find the minimum value of the vector (iterator version); vector<double>::iterator it;; it = TMath::LocMin(v.begin(), v.end());; std::cout << *it << std::endl;. // The same with the old-style version; int i;; i = TMath::LocMin(10, &v[0]);; std::cout << v[i] << std::endl;; Another example of these functions can be found in $ROOTSYS/tutorials/permute.C.; 13.3.3 Statistic Functions Operating on Arrays.; This set of functions processes arrays to calculate:. Mean.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:662233,power,power,662233,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['power'],['power']
Energy Efficiency,"nsform;  CVariableRearrangeTransform;  CVariableTransformBase;  CVarTransformHandler;  CVolume;  ►NTStreamerInfoActions;  CTActionSequence;  CTConfigurationBase class of the Configurations ;  CTConfiguredAction;  CTLoopConfigurationBase class of the Configurations for the member wise looping routines ;  ►Nvdt;  ►Ndetails;  Cieee754Used to switch between different type of interpretations of the data (64 bits) ;  ►Nwriter;  Cwriter;  C_root_std_complex;  C_x3d_data_;  C_x3d_sizeof_;  CAnyCollectionProxy;  CAnyCollectionStreamer;  CApplicationWindowMain Qt&Root Application Window: ;  CBalancerInfo;  CBaseSelectionRule;  Cbasic_string_view;  ►CBidirMMapPipeBidirMMapPipe creates a bidirectional channel between the current process and a child it forks ;  CPollEntryFor poll() interface ;  CBinaryOpPolicy;  CBinomialNeymanInterval;  CBinomialProbHelper;  CClassSelectionRule;  CClusterD;  CColorStruct_t;  CCompareAsc;  CcompareBAasc;  CcompareBAdesc;  CCompareDesc;  CContDistFree functions adapter needed by UNURAN for onedimensional continuous distributions ;  CContextSmall helper to keep current directory context ;  CCpuInfo_t;  CDiscrDistFree functions adapter needed by UNURAN for one-dimensional discrete distribution ;  CDUMMY;  CEditor;  CEvent_t;  CExceptionContext_t;  CFeldmanCousinsBinomialInterval;  CFeldmanCousinsSorter;  CFileStat_t;  CFontAttributes_t;  CFontMetrics_t;  CFoption_t;  CFUMILI2;  Cfuncptr_and_voidptr_t;  CGaussFunction;  CGcCache_t;  CGCValues_t;  Cgroup;  CGSL_BFGS;  CGSL_BFGS2;  CGSL_FR;  CGSL_NLS;  CGSL_PR;  Ch1analysis;  Ch1analysisTreeReader;  Chash< std::experimental::basic_string_view< _CharT, _Traits > >;  CHelperOps;  CHEPEVT_DEFHEPEVT common block ;  CHit;  CHoption_tHistogram option structure ;  CHparam_tHistogram parameters structure ;  CJet;  CJetEvent;  CLINEAR;  CMemInfo_t;  Cmg_callbacks;  Cmg_client_options;  Cmg_form_data_handler;  Cmg_option;  ►Cmg_request_info;  Cmg_header;  Cmg_server_ports;  CMINUIT2;  CMultiDistFree functions a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:72342,adapt,adapter,72342,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['adapt'],['adapter']
Energy Efficiency,"nsforms. orthogonal transforms can be successfully used for the processing of nuclear spectra (not only); they can be used to remove high frequency noise, to increase signal-to-background ratio as well as to enhance low intensity components [1], to carry out e.g. Fourier analysis etc.; we have implemented the function for the calculation of the commonly used orthogonal transforms as well as functions for the filtration and enhancement of experimental data. References:; [1] C.V. Hampton, B. Lian, Wm. C. McHarris: Fast-Fourier-transform spectral enhancement techniques for gamma-ray spectroscopy. NIM A353 (1994) 280-284.; [2] Morhac; M., Matouoek V., New adaptive Cosine-Walsh transform and its application to nuclear data compression, IEEE Transactions on Signal Processing 48 (2000) 2693.; [3] Morhac; M., Matouoek V., Data compression using new fast adaptive Cosine-Haar transforms, Digital Signal Processing 8 (1998) 63.; [4] Morhac; M., Matouoek V.: Multidimensional nuclear data compression using fast adaptive Walsh-Haar transform. Acta Physica Slovaca 51 (2001) 307. Example - script Transform.c:. Fig. 1 Original gamma-ray spectrum. Fig. 2 Transformed spectrum from Fig. 1 using Cosine transform; Script:; Example to illustrate Transform function (class TSpectrumTransform). To execute this example, do:; root > .x Transform.C; #include <TSpectrum>; #include <TSpectrumTransform>; void Transform() {; Int_t i;; Double_t nbins = 4096;; Double_t xmin = 0;; Double_t xmax = (Double_t)nbins;; Double_t * source = new Double_t[nbins];; Double_t * dest = new Double_t[nbins];; TH1F *h = new TH1F(""h"",""Transformed spectrum using Cosine transform"",nbins,xmin,xmax);; TFile *f = new TFile(""spectra/TSpectrum.root"");; h=(TH1F*) f->Get(""transform1;1"");; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; TCanvas *Transform1 = gROOT->GetListOfCanvases()->FindObject(""Transform1"");; if (!Transform1) Transform1 = new TCanvas(""Transform"",""Transform1"",10,10,1000,700);; TSpectrum *s = new",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumTransform.html:31049,adapt,adaptive,31049,doc/master/classTSpectrumTransform.html,https://root.cern,https://root.cern/doc/master/classTSpectrumTransform.html,1,['adapt'],['adaptive']
Energy Efficiency,"nsparent). One can attach to a material a user-defined object storing Cerenkov properties. Another hook for material shading properties is currently not in use. Mixtures are materials made of several elements. They are represented by the class TGeoMixture, deriving from TGeoMaterial and defined by their number of components and the density:; TGeoMixture(const char *name,Int_t nel,Double_t rho);; Elements have to be further defined one by one:; void TGeoMixture::DefineElement(Int_t iel,Double_t a,Double_t z,; Double_t weigth);; void TGeoMixture::DefineElement(Int_t iel, TGeoElement *elem,; Double_t weight);; void TGeoMixture::DefineElement(Int_t iel, Int_t z, Int_t natoms);; or:; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight). iel: index of the element[0,nel-1]; a and z: the atomic mass and charge; weight: proportion by mass of the elements; natoms: number of atoms of the element in the molecule making the mixture. The radiation length is automatically computed when all elements are defined. Since tracking MC provide several other ways to create materials/mixtures, the materials classes are likely to evolve as the interfaces to these engines are being developed. Generally in the process of tracking material properties are not enough and more specific media properties have to be defined. These highly depend on the MC performing tracking and sometimes allow the definition of different media properties (e.g. energy or range cuts) for the same material.; 18.2.2 Radionuclides; A new class TGeoElementRN was introduced in this version to provide support for radioactive nuclides and their decays. A database of 3162 radionuclides can be loaded on demand via the table of elements (TGeoElementTable class). One can make then materials/mixtures based on these radionuclides and use them in a geometry; root[] TGeoMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:890580,charge,charge,890580,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['charge'],['charge']
Energy Efficiency,"nst TMVA::IMethod&); virtual voidPrintHelpMessage() const; virtual voidProcessOptions(); virtual voidReadWeightsFromStream(istream&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTrain(); virtual voidWriteMonitoringHistosToFile() const. protected:. virtual voidGetHelpMessage() const; virtual voidMakeClassSpecific(ostream&, const TString&) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IMethod(); default destructur. {}. const char * GetName() const; ------- virtual member functions to be implemented by each MVA method; the name of the method. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the MVA value - some methods may return a per-event error estimate (unless: *err = -1). void Train( void ); training method. void ReadWeightsFromStream(istream& ); read weights from output stream. void WriteMonitoringHistosToFile( void ); write method specific monitoring histograms to target file. void MakeClass(const TString& classFileName = TString("""")) const; make ROOT-independent C++ class for classifier response. const Ranking* CreateRanking(); create ranking. void PrintHelpMessage() const; print help message. void Init(). void DeclareOptions(). void ProcessOptions(). Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets). void MakeClassSpecific(ostream& , const TString& ) const; make ROOT-independent C++ class for classifier response (classifier-specific implementation). void GetHelpMessage() const; get specific help message from classifer. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__IMethod.html:1971,monitor,monitoring,1971,root/html534/TMVA__IMethod.html,https://root.cern,https://root.cern/root/html534/TMVA__IMethod.html,1,['monitor'],['monitoring']
Energy Efficiency,"nst char* location, const char* msg); The PROOF error handler function. It prints the message on fgErrorHandlerFile and; if abort is set it aborts the application. Int_t CopyFromCache(const char* name, Bool_t cpbin); Retrieve any files related to 'macro' from the cache directory.; If 'cpbin' is true, the associated binaries are retrieved as well.; Returns 0 on success, -1 otherwise. Int_t CopyToCache(const char* name, Int_t opt = 0); Copy files related to 'macro' to the cache directory.; Action depends on 'opt':. opt = 0 copy 'macro' to cache and delete from cache any binary; related to name; e.g. if macro = bla.C, the binaries are; bla_C.so, bla_C.rootmap, ...; opt = 1 copy the binaries related to macro to the cache. Returns 0 on success, -1 otherwise. void MakePlayer(); Make player instance. void DeletePlayer(); Delete player instance. Int_t GetPriority(); Get the processing priority for the group the user belongs too. This; priority is a number (0 - 100) determined by a scheduler (third; party process) based on some basic priority the group has, e.g.; we might want to give users in a specific group (e.g. promptana); a higher priority than users in other groups, and on the analysis; of historical logging data (i.e. usage of CPU by the group in a; previous time slot, as recorded in TPerfStats::WriteQueryLog()). Currently the group priority is obtained by a query in a SQL DB; table proofpriority, which has the format:; CREATE TABLE proofpriority (; id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,; group VARCHAR(32) NOT NULL,; priority INT; ). Int_t SendAsynMessage(const char* msg, Bool_t lf = kTRUE); Send an asychronous message to the master / client .; Masters will forward up the message to the client.; The client prints 'msg' of stderr and adds a '\n'/'\r' depending on; 'lf' being kTRUE (default) or kFALSE.; Returns the return value from TSocket::Send(TMessage &) . void FlushLogFile(); Reposition the read pointer in the log file to the very end.; This allows to ""hide"" u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofServ.html:27852,schedul,scheduler,27852,root/html532/TProofServ.html,https://root.cern,https://root.cern/root/html532/TProofServ.html,4,['schedul'],['scheduler']
Energy Efficiency,"nst char* location, const char* msg); The PROOF error handler function. It prints the message on fgErrorHandlerFile and; if abort is set it aborts the application. Int_t CopyFromCache(const char* name, Bool_t cpbin); Retrieve any files related to 'macro' from the cache directory.; If 'cpbin' is true, the associated binaries are retrieved as well.; Returns 0 on success, -1 otherwise. Int_t CopyToCache(const char* name, Int_t opt = 0); Copy files related to 'macro' to the cache directory.; Action depends on 'opt':. opt = 0 copy 'macro' to cache and delete from cache any binary; related to name; e.g. if macro = bla.C, the binaries are; bla_C.so, bla_C.rootmap, ...; opt = 1 copy the binaries related to macro to the cache. Returns 0 on success, -1 otherwise. void MakePlayer(); Make player instance. void DeletePlayer(); Delete player instance. Int_t GetPriority(); Get the processing priority for the group the user belongs too. This; prioroty is a number (0 - 100) determined by a scheduler (third; party process) based on some basic priority the group has, e.g.; we might want to give users in a specific group (e.g. promptana); a higher priority than users in other groups, and on the analysis; of historical logging data (i.e. usage of CPU by the group in a; previous time slot, as recorded in TPerfStats::WriteQueryLog()). Currently the group priority is obtained by a query in a SQL DB; table proofpriority, which has the format:; CREATE TABLE proofpriority (; id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,; group VARCHAR(32) NOT NULL,; priority INT; ). Int_t SendAsynMessage(const char* msg, Bool_t lf = kTRUE); Send an asychronous message to the master / client .; Masters will forward up the message to the client.; The client prints 'msg' of stderr and adds a '\n'/'\r' depending on; 'lf' being kTRUE (default) or kFALSE.; Returns the return value from TSocket::Send(TMessage &) . void FlushLogFile(); Reposition the read pointer in the log file to the very end.; This allows to ""hide"" u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:27578,schedul,scheduler,27578,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,2,['schedul'],['scheduler']
Energy Efficiency,"nst double * Parameters() and uint NPar(). Example of creating a parametric function:. #include ""Math/IFunction.h""; #include ""Math/IParamFunction.h"". class MyParametricFunction: public ROOT::Math::IParametricFunctionMultiDim; {; private:; const double* pars;. public:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricFunctionMultiDim* Clone() const; {; return new MyParametricFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }; };. ROOT::Math::IParametricGradFunctionMultiDim: Provides an interface for parametric gradient multi-dimensional functions. In addition to function evaluation it provides the gradient with respect to the parameters, via the method ParameterGradient(). This interface is only used in case of some dedicated fitting algorithms, when is required or more efficient to provide derivatives with respect to the parameters. Here is an example:. #include ""Math/IFunction.h""; #include ""Math/IParamFunction.h"". class MyParametricGradFunction:; public ROOT::Math::IParametricGradFunctionMultiDim; {; private:; const double* pars;. public:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricGradFunctionMultiDim* Clone() const; {; return new MyParametricGradFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }. double DoParameterDerivative(const double* x, const double* p,; unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]) + p[1];; else; return p[0] * x[0] + x[1] * cos(x[1]) + p[1];; }; };; 13.7.4 Wrapper Functions; To facilitate the user to insert their own type of function in the needed fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:692789,efficient,efficient,692789,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['efficient'],['efficient']
Energy Efficiency,"nst double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidFdF(const double* x, double& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x) const. Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__IGradientOneDim.html:2865,efficient,efficient,2865,root/html534/ROOT__Math__IGradientOneDim.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientOneDim.html,1,['efficient'],['efficient']
Energy Efficiency,"nst double* x). construct from an interface of a multi-dimensional function. GSLSimAnFunc(const ROOT::Math::IMultiGenFunction& func, const double* x, const double* scale). construct from an interface of a multi-dimensional function; Use optionally a scale factor (for each coordinate) which can be used to scale the step sizes; (this is used for example by the minimization algorithm). GSLSimAnFunc(). derived classes might need to re-define completly the class. {}. virtual ~GSLSimAnFunc(); virtual distructor (no operations). { }. GSLSimAnFunc & FastCopy(const ROOT::Math::GSLSimAnFunc& f). fast copy method called by GSL simuated annealing internally; copy only the things which have been changed; must be re-implemented by derived classes if needed. GSLSimAnFunc * Clone() const. clone method. Needs to be re-implemented by the derived classes for deep copying. return new GSLSimAnFunc(const ROOT::Math::GSLSimAnFunc& ). double Energy() const. evaluate the energy ( objective function value); re-implement by derived classes if needed to be modified. void Step(const ROOT::Math::GSLRandomEngine& r, double maxstep). change the x[i] value using a random value urndm generated between [0,1]; up to a maximum value maxstep; re-implement by derived classes if needed to be modified. double Distance(const ROOT::Math::GSLSimAnFunc& func) const. calculate the distance (metric) between this one and another configuration; Presently a cartesian metric is used.; re-implement by derived classes if needed to be modified. void Print(). print the position in the standard output ostream; GSL prints in addition n iteration, n function calls, temperature and energy; re-implement by derived classes if necessary. void SetX(const double* x). change the x values (used by sim annealing to take a step). void SetX(unsigned int i, double x). unsigned int NDim() const; { return fX.size(); }. double X(unsigned int i) const; { return fX[i]; }. const std::vector<double> & X() const; { return fX; }. double Scale(u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__GSLSimAnFunc.html:2832,energy,energy,2832,root/html526/ROOT__Math__GSLSimAnFunc.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__GSLSimAnFunc.html,4,['energy'],['energy']
Energy Efficiency,"nst. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1.0E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1.0E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1.0E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1.0E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1.0E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1.0E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1.0E-8); Derivatives for multi-dimensio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__Derivator.html:4419,adapt,adaptive,4419,root/html602/ROOT__Math__Derivator.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__Derivator.html,2,['adapt'],['adaptive']
Energy Efficiency,"nst. TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<float>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<float>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixTSym_float_.html:18705,efficient,efficient,18705,root/html602/TMatrixTSym_float_.html,https://root.cern,https://root.cern/root/html602/TMatrixTSym_float_.html,2,['efficient'],['efficient']
Energy Efficiency,"nst; const Char_t *TTable::Print(Int_t row, Int_t rownumber, const Char_t *colfirst, const Char_t *collast) const. Print the contents of internal table per COLUMN. row - the index of the first row to print (counting from ZERO); rownumber - the total number of rows to print out (=10 by default). (No use !) Char_t *colfirst, *collast - the names of the first/last; to print out (not implemented yet). Check bounds and adjust it. void PrintContents(Option_t* opt = """") const; to be documented. void Project(const char* hname, const char* varexp, const char* selection = """", Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); -*-*Make a projection of a TTable using selections; *-* =============================================. Depending on the value of varexp (described in Draw) a 1-D,2-D,etc; projection of the TTable will be filled in histogram hname.; Note that the dimension of hname must match with the dimension of varexp. Int_t Purge(Option_t* opt = """"); Shrink the table to free the unused but still allocated rows. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Set(Int_t n); Set array size of TTable object to n longs. If n<0 leave array unchanged. void SetTablePointer(void* table); to be documented. void SetType(const char *const type); to be documented. Char_t * MakeExpression(const Char_t** expressions, Int_t nExpressions); Create CINT macro to evaluate the user-provided expresssion; Expression may contains:; - the table columen names; - 2 meta names: i$ - the current column index,; n$ - the total table size provided by TTable::GetNRows() method. return the name of temporary file with the current expressions. void Reset(Int_t c = 0); Fill the entire table with byte ""c"" ;; c=0 ""be default"". void ResetMap(Bool_t wipe = kTRUE); Clean all filled columns with the pointers to TTableMap; if any; wipe = kTRUE - delete all object the Map's point to; kFALSE - zero pointer, do not ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTable.html:30397,allocate,allocated,30397,root/html528/TTable.html,https://root.cern,https://root.cern/root/html528/TTable.html,4,['allocate'],['allocated']
Energy Efficiency,"nst; const Char_t *TTable::Print(Int_t row, Int_t rownumber, const Char_t *colfirst, const Char_t *collast) const. Print the contents of internal table per COLUMN. row - the index of the first row to print (counting from ZERO); rownumber - the total number of rows to print out (=10 by default). (No use !) Char_t *colfirst, *collast - the names of the first/last; to print out (not implemented yet). Check bounds and adjust it. void PrintContents(Option_t* opt = """") const; to be documented. void Project(const char* hname, const char* varexp, const char* selection = """", Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); -*-*Make a projection of a TTable using selections; *-* =============================================. Depending on the value of varexp (described in Draw) a 1-D,2-D,etc; projection of the TTable will be filled in histogram hname.; Note that the dimension of hname must match with the dimension of varexp. Int_t Purge(Option_t* opt = """"); Shrink the table to free the unused but still allocated rows. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Set(Int_t n); Set array size of TTable object to n longs. If n<0 leave array unchanged. void SetTablePointer(void* table); to be documented. void SetType(const char*const type); to be documented. Char_t * MakeExpression(const Char_t*[] expressions, Int_t nExpressions); Create CINT macro to evaluate the user-provided expresssion; Expression may contains:; - the table columen names; - 2 meta names: i$ - the current column index,; n$ - the total table size provided by TTable::GetNRows() method. return the name of temporary file with the current expressions. void Reset(Int_t c = 0); Fill the entire table with byte ""c"" ;; c=0 ""be default"". void ResetMap(Bool_t wipe = kTRUE); Clean all filled columns with the pointers to TTableMap; if any; wipe = kTRUE - delete all object the Map's point to; kFALSE - zero pointer, do not ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTable.html:31871,allocate,allocated,31871,root/html602/TTable.html,https://root.cern,https://root.cern/root/html602/TTable.html,2,['allocate'],['allocated']
Energy Efficiency,"nst; doubleDerivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidFdF(const double* x, double& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double * x, double & f, double * df). Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x ). Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double & f, double & df). Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documenta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IGradientOneDim.html:2276,efficient,efficient,2276,root/html526/ROOT__Math__IGradientOneDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IGradientOneDim.html,1,['efficient'],['efficient']
Energy Efficiency,"nst; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(RooCmdArg arg1, RooCmdArg arg2 = RooCmdArg(), RooCmdArg arg3 = RooCmdArg(), RooCmdArg arg4 = RooCmdArg(), RooCmdArg arg5 = RooCmdArg(), RooCmdArg arg6 = RooCmdArg(), RooCmdArg arg7 = RooCmdArg(), RooCmdArg arg8 = RooCmdArg()); voidremoveSelfFromDir(); virtual voidreset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidset(Double_t weight, Double_t wgtErr = -1); voidset(const RooArgSet& row, Double_t weight, Double_t wgtErr = -1); voidset(const RooArgSet& row, Double_t weight, Double_t wgtErrLo, Double_t wgtErrHi); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyPr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataHist.html:9223,reduce,reduce,9223,root/html526/RooDataHist.html,https://root.cern,https://root.cern/root/html526/RooDataHist.html,1,['reduce'],['reduce']
Energy Efficiency,"nst; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); voidremoveSelfFromDir(); virtual voidreset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidset(Double_t weight, Double_t wgtErr = -1); voidset(const RooArgSet& row, Double_t weight, Double_t wgtErr = -1); voidset(const RooArgSet& row, Double_t weight, Double_t wgtErrLo, Double_t wgtErrHi); voidTObject::SetBit(UInt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDataHist.html:9598,reduce,reduce,9598,root/html530/RooDataHist.html,https://root.cern,https://root.cern/root/html530/RooDataHist.html,1,['reduce'],['reduce']
Energy Efficiency,"nst; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); voidremoveSelfFromDir(); virtual voidreset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidset(Double_t weight, Double_t wgtErr = -1); voidset(const RooArgSet& row, Double_t weight, Double_t wgtErr = -1); voidset(const RooArgSet& row, Double_t weight, Double_t wgtErrLo, Double_t wgt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDataHist.html:9694,reduce,reduce,9694,root/html532/RooDataHist.html,https://root.cern,https://root.cern/root/html532/RooDataHist.html,2,['reduce'],['reduce']
Energy Efficiency,"nst; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); voidremoveSelfFromDir(); virtual voidreset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidset(Double_t weight, Double_t wgtErr = -1); voidset(const RooArgSet& row, Double_t weight, Double_t wgtErr = -1); voidset(const RooArgSet& row, Double_t weight, Double_t wgtErrLo, Double_t wgtErrHi); voidTObject::SetBit(UInt_t f); voidTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDataHist.html:9279,reduce,reduce,9279,root/html528/RooDataHist.html,https://root.cern,https://root.cern/root/html528/RooDataHist.html,1,['reduce'],['reduce']
Energy Efficiency,"nst; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { return E(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { return M2() + fPt*fPt; }. Scalar Mt() const. transverse mass - will be negative if Mt2() is negative. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_Double32_t_.html:7444,energy,energy,7444,root/html526/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,5,['energy'],['energy']
Energy Efficiency,"nst; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { return E(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { return M2() + fPt*fPt; }. Scalar Mt() const. transverse mass - will be negative if Mt2() is negative. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<double>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<double>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<double>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<double>::Scalar px, ROOT::Math::PtEtaPhiM4D<double>::Scalar py, ROOT::Math::PtEtaPhiM4D<double>::Scalar pz, ROOT::Math::PtEtaPhiM4D<double>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); there",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_double_.html:7084,energy,energy,7084,root/html526/ROOT__Math__PtEtaPhiM4D_double_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_double_.html,5,['energy'],['energy']
Energy Efficiency,"nst;  ; virtual void SavePrimitiveHelp (std::ostream &out, const char *hname, Option_t *option="""");  Helper function for the SavePrimitive functions from TH1 or classes derived from TH1, eg TProfile, TProfile2D. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TArray; Bool_t BoundsOk (const char *where, Int_t at) const;  ; Bool_t OutOfBoundsError (const char *where, Int_t i) const;  Generate an out-of-bounds error. Always returns false. ;  ;  Static Protected Member Functions inherited from TH3; static TH1D * DoProject1D (const TH3 &h, const char *name, const char *title, const TAxis *projX, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 1D histogram ;  ; static TH2D * DoProject2D (const TH3 &h, const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 2D histogram ;  ;  Static Protected Member Functions inherited from TH1; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2);  Check histogram compatibility. ;  ; static bool CheckConsistentSubAxes (const TAxis *a1, Int_t firstBin1,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLTH3Composition.html:58355,power,power,58355,doc/master/classTGLTH3Composition.html,https://root.cern,https://root.cern/doc/master/classTGLTH3Composition.html,1,['power'],['power']
Energy Efficiency,"nst;; 207 ; 208 /// parameter global correlation coefficient; 209 double GlobalCC(unsigned int i) const {; 210 return (i < fGlobalCC.size() ) ? fGlobalCC[i] : -1;; 211 }; 212 ; 213 ; 214 /// retrieve covariance matrix element; 215 double CovMatrix (unsigned int i, unsigned int j) const {; 216 if ( i >= fErrors.size() || j >= fErrors.size() ) return 0;; 217 if (fCovMatrix.empty()) return 0; // no matrix is available in case of non-valid fits; 218 if ( j < i ); 219 return fCovMatrix[j + i* (i+1) / 2];; 220 else; 221 return fCovMatrix[i + j* (j+1) / 2];; 222 }; 223 ; 224 /// retrieve correlation elements; 225 double Correlation(unsigned int i, unsigned int j ) const {; 226 if ( i >= fErrors.size() || j >= fErrors.size() ) return 0;; 227 if (fCovMatrix.empty()) return 0; // no matrix is available in case of non-valid fits; 228 double tmp = CovMatrix(i,i)*CovMatrix(j,j);; 229 return ( tmp > 0) ? CovMatrix(i,j)/ std::sqrt(tmp) : 0;; 230 }; 231 ; 232 /// fill covariance matrix elements using a generic matrix class implementing operator(i,j); 233 /// the matrix must be previously allocates with right size (npar * npar); 234 template<class Matrix>; 235 void GetCovarianceMatrix(Matrix & mat) const {; 236 unsigned int npar = fErrors.size();; 237 if (fCovMatrix.size() != npar*(npar+1)/2 ) return; // do nothing; 238 for (unsigned int i = 0; i< npar; ++i) {; 239 for (unsigned int j = 0; j<=i; ++j) {; 240 mat(i,j) = fCovMatrix[j + i*(i+1)/2 ];; 241 if (i != j) mat(j,i) = mat(i,j);; 242 }; 243 }; 244 }; 245 ; 246 /// fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); 247 /// the matrix must be previously allocates with right size (npar * npar); 248 template<class Matrix>; 249 void GetCorrelationMatrix(Matrix & mat) const {; 250 unsigned int npar = fErrors.size();; 251 if (fCovMatrix.size() != npar*(npar+1)/2) return; // do nothing; 252 for (unsigned int i = 0; i< npar; ++i) {; 253 for (unsigned int j = 0; j<=i; ++j) {; 254 double tm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitResult_8h_source.html:8886,allocate,allocates,8886,doc/master/FitResult_8h_source.html,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html,1,['allocate'],['allocates']
Energy Efficiency,"nstructor = kClassNew, . Bool_t ; quiet = kFALSE . ); const. Definition at line 4992 of file TClass.cxx. ◆ NewObject() [2/2]. TClass::ObjectPtr TClass::NewObject ; (; void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5106 of file TClass.cxx. ◆ NewObjectArray() [1/2]. TClass::ObjectPtr TClass::NewObjectArray ; (; Long_t ; nElements, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated array of objects of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5209 of file TClass.cxx. ◆ NewObjectArray() [2/2]. TClass::ObjectPtr TClass::NewObjectArray ; (; Long_t ; nElements, . void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5310 of file TClass.cxx. ◆ operator=(). TClass & TClass::operator= ; (; const TClass & ; ). privatedelete . ◆ PostLoadCheck(). void TClass::PostLoadCheck ; (; ). virtual . Do the initialization that can only be done after the CINT dictionary has been fully populated and can not be delayed efficiently. ; Definition at line 5959 of file TClass.cxx. ◆ Property(). Long_t TClass::Property ; (; ); const. overridevirtual . Returns the properties of the TClass as a bit field stored as a Long_t value. ; The bit values used for the return value are defined in the enum EProperty (in TDictionary.h); Also sets TObject::fBits and fStreamerType to cache information about the class. The bits stored in TObject::fBits are kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:108293,allocate,allocated,108293,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['allocate'],['allocated']
Energy Efficiency,"nstructor = kClassNew, . Bool_t ; quiet = kFALSE . ); const. Definition at line 5059 of file TClass.cxx. ◆ NewObject() [2/2]. TClass::ObjectPtr TClass::NewObject ; (; void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5173 of file TClass.cxx. ◆ NewObjectArray() [1/2]. TClass::ObjectPtr TClass::NewObjectArray ; (; Long_t ; nElements, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated array of objects of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5276 of file TClass.cxx. ◆ NewObjectArray() [2/2]. TClass::ObjectPtr TClass::NewObjectArray ; (; Long_t ; nElements, . void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5377 of file TClass.cxx. ◆ operator=(). TClass & TClass::operator= ; (; const TClass & ; ). privatedelete . ◆ PostLoadCheck(). void TClass::PostLoadCheck ; (; ). virtual . Do the initialization that can only be done after the CINT dictionary has been fully populated and can not be delayed efficiently. ; Definition at line 6026 of file TClass.cxx. ◆ Property(). Long_t TClass::Property ; (; ); const. overridevirtual . Returns the properties of the TClass as a bit field stored as a Long_t value. ; The bit values used for the return value are defined in the enum EProperty (in TDictionary.h); Also sets TObject::fBits and fStreamerType to cache information about the class. The bits stored in TObject::fBits are kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:108294,allocate,allocated,108294,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['allocate'],['allocated']
Energy Efficiency,"nsvers component with; // respect to another vector; pp2v2 = v.Perp(v1);; for convenience there are two more set functions SetPtEtaPhiE(pt,eta,phi,e); and SetPtEtaPhiM(pt,eta,phi,m);. Arithmetic and comparison operators; The TLorentzVector class provides operators to add, subtract or compare four-vectors:; v3 = -v1;; v1 = v2+v3;; v1+= v3;; v1 = v2 + v3;; v1-= v3;; ; if (v1 == v2) {...}; if(v1 != v3) {...}. Magnitude/Invariant mass, beta, gamma, scalar product; The scalar product of two four-vectors is calculated with the (-,-,-,+) metric,; i.e. s = v1*v2 = t1*t2-x1*x2-y1*y2-z1*z2 The magnitude squared mag2 of a four-vector is therefore:; mag2 = v*v = t*t-x*x-y*y-z*z; It mag2 is negative mag = -Sqrt(-mag*mag). The member functions are:; Double_t s, s2;; s = v1.Dot(v2); // scalar product; s = v1*v2; // scalar product; s2 = v.Mag2(); or s2 = v.M2();; s = v.Mag(); s = v.M();; Since in case of momentum and energy the magnitude has the meaning of invariant mass TLorentzVector provides the more meaningful aliases M2() and M(); The member functions Beta() and Gamma() returns beta and gamma = 1/Sqrt(1-beta*beta). . Lorentz boost; A boost in a general direction can be parameterised with three parameters which can be taken as the components of a three vector b = (bx,by,bz). With x = (x,y,z) and gamma = 1/Sqrt(1-beta*beta) (beta being the module of vector b), an arbitrary active Lorentz boost transformation (from the rod frame to the original frame) can be written as:; x = x' + (gamma-1)/(beta*beta) * (b*x') * b + gamma * t' * b; t = gamma (t'+ b*x').; b#define b(i)Definition RSha256.hxx:100; The member function Boost() performs a boost transformation from the rod frame to the original frame. BoostVector() returns a TVector3 of the spatial components divided by the time component:; TVector3 b;; v.Boost(bx,by,bz);; v.Boost(b);; b = v.BoostVector(); // b=(x/t,y/t,z/t). Rotations; There are four sets of functions to rotate the TVector3 component of a TLorentzVector:; rotation arou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLorentzVector.html:5194,energy,energy,5194,doc/master/classTLorentzVector.html,https://root.cern,https://root.cern/doc/master/classTLorentzVector.html,1,['energy'],['energy']
Energy Efficiency,"nsverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<double>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<double>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<double>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<double>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<double>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(double pt); ====== Set member functions for coordinates in other systems =======. void SetEta(double eta). void SetPhi(double phi). void SetE(double energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: 464c29f33a8bbd8462a3e15b7e4c30c6f5b74a30 $ » Last generated: 2015-09-08 17:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__PxPyPzM4D_double_.html:8140,energy,energy,8140,root/html534/ROOT__Math__PxPyPzM4D_double_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__PxPyPzM4D_double_.html,1,['energy'],['energy']
Energy Efficiency,"nt (histoName, x); } ///< for monitoring; 822 void addPoint (std::string histoName, double x, double y) {if (fMonitoring) fMonitoring->addPoint (histoName, x, y); } ///< for monitoring; 823 void plot (std::string histoName, std::string options, int pad, EColor color) { if (fMonitoring) fMonitoring->plot (histoName, options, pad, color); } ///< for monitoring; 824 void clear (std::string histoName) { if (fMonitoring) fMonitoring->clear (histoName); } ///< for monitoring; 825 bool exists (std::string histoName) { if (fMonitoring) return fMonitoring->exists (histoName); return false; } ///< for monitoring; 826 ; 827 size_t convergenceCount () const { return m_convergenceCount; } ///< returns the current convergence count; 828 size_t maxConvergenceCount () const { return m_maxConvergenceCount; } ///< returns the max convergence count so far; 829 size_t minError () const { return m_minError; } ///< returns the smallest error so far; 830 ; 831 public:; 832 Timer m_timer; ///< timer for monitoring; 833 double m_minProgress; ///< current limits for the progress bar; 834 double m_maxProgress; ///< current limits for the progress bar; 835 ; 836 ; 837 size_t m_convergenceSteps; ///< number of steps without improvement to consider the DNN to have converged; 838 size_t m_batchSize; ///< mini-batch size; 839 size_t m_testRepetitions;; 840 double m_factorWeightDecay;; 841 ; 842 size_t count_E;; 843 size_t count_dE;; 844 size_t count_mb_E;; 845 size_t count_mb_dE;; 846 ; 847 EnumRegularization m_regularization;; 848 ; 849 double m_dropRepetitions;; 850 std::vector<double> m_dropOut;; 851 ; 852 double fLearningRate;; 853 double fMomentum;; 854 int fRepetitions;; 855 MinimizerType fMinimizerType;; 856 ; 857 size_t m_convergenceCount;; 858 size_t m_maxConvergenceCount;; 859 double m_minError;; 860 ; 861 ; 862 protected:; 863 bool m_useMultithreading;; 864 ; 865 std::shared_ptr<Monitoring> fMonitoring;; 866 };; 867 ; 868 ; 869 ; 870 ; 871 ; 872 ; 873 ; 874 ; 875 ; 876 ; 877 ; 878 ; 879 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:31999,monitor,monitoring,31999,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['monitor'],['monitoring']
Energy Efficiency,"nt is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t *&ll); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t *&ll); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t *&f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t *&d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as float) from the I/O buffer.; Returns the number of doubles read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Double32_t encoding at TBufferFile::WriteDouble32. Int_t ReadStaticArray(Bool_t *b); Read array of bools from the I/O buffer. Returns the number of bools; read. Int_t ReadStaticArray(Char_t *c); Read array of characters from the I/O buffer. Returns the number of; characters read. Int_t ReadStaticArray(Short_t *h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. Int_t ReadStaticArray(Int_t *ii); Read array of ints from the I/O buffer. Returns the number of ints; read. Int_t ReadStaticArray(Long_t *ll); Read array of longs from the I/O buffer. Returns the number of longs; read. Int_t ReadStaticArray(Lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferFile.html:26993,allocate,allocated,26993,root/html526/TBufferFile.html,https://root.cern,https://root.cern/root/html526/TBufferFile.html,1,['allocate'],['allocated']
Energy Efficiency,"nt list of workers. ;  ; Int_t GoParallel (Int_t nodes, Bool_t accept=kFALSE, Bool_t random=kFALSE);  Go in parallel mode with at most ""nodes"" slaves. ;  ; Int_t HandleInputMessage (TSlave *wrk, TMessage *m, Bool_t deactonfail=kFALSE);  Analyze the received message. ;  ; void HandleSubmerger (TMessage *mess, TSlave *sl);  Process a message of type kPROOF_SUBMERGER. ;  ; void Interrupt (EUrgent type, ESlaves list=kActive);  Send interrupt to master or slave servers. ;  ; void InterruptCurrentMonitor ();  If in active in a monitor set ready state. ;  ; Bool_t IsEndMaster () const;  ; Bool_t IsSync () const;  ; Int_t LoadPackage (const char *package, Bool_t notOnClient=kFALSE, TList *loadopts=0, TList *workers=0);  Load specified package. ;  ; void MarkBad (TSlave *wrk, const char *reason=0);  Add a bad slave server to the bad slave list and remove it from the active list and from the two monitor objects. ;  ; void MarkBad (TSocket *s, const char *reason=0);  Add slave with socket s to the bad slave list and remove if from the active list and from the two monitor objects. ;  ; Int_t ModifyWorkerLists (const char *ord, Bool_t add, Bool_t save);  Modify the worker active/inactive list by making the worker identified by the ordinal number 'ord' active (add == TRUE) or inactive (add == FALSE). ;  ; void NotifyLogMsg (const char *msg, const char *sfx=""\n"");  Notify locally 'msg' to the appropriate units (file, stdout, window) If defined, 'sfx' is added after 'msg' (typically a line-feed);. ;  ; void operator= (const TProof &);  ; void ParseConfigField (const char *config);  The config file field may contain special instructions which need to be parsed at the beginning, e.g. ;  ; Int_t Ping (ESlaves list);  Ping PROOF slaves. Returns the number of slaves that responded. ;  ; void PrintProgress (Long64_t total, Long64_t processed, Float_t procTime=-1., Long64_t bytesread=-1);  Print a progress bar on stderr. Used in batch mode. ;  ; Bool_t Prompt (const char *p);  Prompt the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:50872,monitor,monitor,50872,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['monitor'],['monitor']
Energy Efficiency,"nt magnetic moment; excitation excitation energy [GeV]; Set a user defined ion.; name ion name; Z atomic number; A atomic mass; Q charge [eplus}; excitation excitation energy [GeV]; mass mass [GeV] (if not specified by user, approximative; mass is calculated). Double_t Xsec(char* , Double_t , Int_t , Int_t ); Set a user phase space decay for a particle; pdg particle PDG encoding; bratios the array with branching ratios (in %); mode[6][3] the array with daughters particles PDG codes for each; decay channel; Calculate X-sections; (Geant3 only). Int_t IdFromPDG(Int_t pdg) const. particle table usage. Return MC specific code from a PDG and pseudo ENDF code (pdg). Int_t PDGFromId(Int_t id) const; Return PDG code and pseudo ENDF code from MC specific code (id). TString ParticleName(Int_t pdg) const. get methods. Return name of the particle specified by pdg. Double_t ParticleMass(Int_t pdg) const; Return mass of the particle specified by pdg. Double_t ParticleCharge(Int_t pdg) const; Return charge (in e units) of the particle specified by pdg. Double_t ParticleLifeTime(Int_t pdg) const; Return life time of the particle specified by pdg. TMCParticleType ParticleMCType(Int_t pdg) const; Return VMC type of the particle specified by pdg. void StopTrack(). methods for step management. action methods. Stop the transport of the current particle and skip to the next. void StopEvent(); Stop simulation of the current event and skip to the next. void StopRun(); Stop simulation of the current event and set the abort run flag to true. void SetMaxStep(Double_t ). set methods. Set the maximum step allowed till the particle is in the current medium. void SetMaxNStep(Int_t ); Set the maximum number of steps till the particle is in the current medium. void SetUserDecay(Int_t pdg); Force the decays of particles to be done with Pythia; and not with the Geant routines. void ForceDecayTime(Float_t ); Force the decay time of the current particle. Int_t CurrentVolID(Int_t& copyNo) const. tracking ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMC.html:30535,charge,charge,30535,root/html528/TVirtualMC.html,https://root.cern,https://root.cern/root/html528/TVirtualMC.html,1,['charge'],['charge']
Energy Efficiency,"nt this way makes under/over-flow very; unlikely . Decompose(); Here the actually decomposition is performed . One can change the; matrix A after the decomposition constructor has been called; without effecting the decomposition result. Solve(TVectorD &b); Solve A x = b . x is supplied through the argument and replaced with; the solution . TransSolve(TVectorD &b); Solve A^T x = b . x is supplied through the argument and replaced; with the solution . MultiSolve(TMatrixD &B); Solve A X = B . where X and are now matrices . X is supplied through; the argument and replaced with the solution . Invert(TMatrixD &inv); This is of course just a call to MultiSolve with as input argument; the unit matrix . Note that for a matrix a(m,n) with m > n a; pseudo-inverse is calculated . Tolerances and Scaling. The tolerance parameter (which is a member of this base class) plays; a crucial role in all operations of the decomposition classes . It; gives the user a powerful tool to monitor and steer the operations; Its default value is sqrt(epsilon) where 1+epsilon = 1. If you do not want to be bothered by the following considerations,; like in most other linear algebra packages, just set the tolerance; with SetTol to an arbitrary small number . The tolerance number is used by each decomposition method to decide; whether the matrix is near singular, except of course SVD which can; handle singular matrices .; For each decomposition this will be checked in a different way; in LU; the matrix is considered singular when, at some point in the; decomposition, a diagonal element < fTol . Therefore, we had to set in; the example above of the (10x10) Hilbert, which is near singular, the; tolerance on 10e-12 . (The fact that we have to set the tolerance <; sqrt(epsilon) is a clear indication that we are losing precision .). If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices/vectors that are; invalid . The observant reader will notice t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDecompBase.html:2565,power,powerful,2565,root/html528/TDecompBase.html,https://root.cern,https://root.cern/root/html528/TDecompBase.html,12,"['monitor', 'power']","['monitor', 'powerful']"
Energy Efficiency,"nt! front or back of the active shallow ring?; Bool_tfShallowRing! does active ring form shallow angle to eye?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t Angle(const TGLVector3& v1, const TGLVector3& v2); Calculate unsigned angle between vectors v1 and v2. Double_t Angle(const TGLVector3& v1, const TGLVector3& v2, const TGLVector3& ref); Calculate signed angle between vectors v1 and v2, using ref to define right handed coord system; If v1.v2 parallel to ref vector: +ive for clockwise, -ive for anticlockwise; If v1.v2 antiparallel to ref vector: -ive for clockwise, +ive for anticlockwise. TGLRotateManip(); Construct rotation manipulator not bound to any physical shape. TGLRotateManip(TGLPhysicalShape* shape); Construct rotation manipulator bound to TGLPhysicalShape 'shape'. ~TGLRotateManip(); Destory the rotation manipulator. void Draw(const TGLCamera& camera) const; Draw rotate manipulator - axis rings drawn from attached; physical center, in plane defined by axis as normal, in red(X),; green(Y) and blue(Z), with white center sphere. If selected; widget (mouse over) this is drawn in active colour (yellow). Bool_t HandleButton(const Event_t& event, const TGLCamera& camera); Handle mouse button event over manipulator - returns kTRUE if; redraw required kFALSE otherwise. Bool_t HandleMotion(const Event_t& event, const TGLCamera& camera); Handle mouse motion over manipulator - if active (selected; widget) rotate physical around selected ring widget plane; normal. Returns kTRUE if redraw required kFALSE otherwise. Double_t CalculateAngleDelta(const TPoint& mouse, const TGLCamera& camera); Calculate angle delta for rotation based on new mouse position. TGLLine3 CalculateRingLine(const TPoint& mouse, const TGLCamera& camera) const; Calculated interaction line between 'mouse' viewport point, and; current selected widget (ring), under supplied 'camera'; projection. void DrawAxisRing(const TGLVertex3& origin, const TGLV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLRotateManip.html:3746,green,green,3746,root/html528/TGLRotateManip.html,https://root.cern,https://root.cern/root/html528/TGLRotateManip.html,6,['green'],['green']
Energy Efficiency,"nt(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::CeilDouble_t Ceil(Double_t x)Rounds x upward, returning the smallest integral value that is not less than x.Definition TMath.h:668; TMath::FiniteInt_t Finite(Double_t x)Check if it is finite with a mask in order to be consistent in presence of fast math.Definition TMath.h:770; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; v2@ v2Definition rootcling_impl.cxx:3702; v@ vDefinition rootcling_impl.cxx:3699; v1@ v1Definition rootcling_impl.cxx:3701; invvoid inv(rsa_NUMBER *, rsa_NUMBER *, rsa_NUMBER *)Definition rsaaux.cxx:949; Rectangle_tRectangle structure (maps to the X11 XRectangle structure)Definition GuiTypes.h:361; Rectangle_t::fXShort_t fXDefinition GuiTypes.h:362; Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:338397,power,power,338397,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['power'],['power']
Energy Efficiency,"nt*const , Int_t cls) const; apply the principal component analysis; TODO: implementation of inverse transformation; Log() << kFATAL << ""Inverse transformation for PCA transformation not yet implemented. Hence, this transformation cannot be applied together with regression. Please contact the authors if necessary."" << Endl;. void CalculatePrincipalComponents(const vector<TMVA::Event*>& ); calculate the principal components for the signal and the background data; it uses the MakePrincipal method of ROOT's TPrincipal class. void X2P(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Calculate the principal components from the original data vector; x, and return it in p (function extracted from TPrincipal::X2P); It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). void P2X(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Perform the back-transformation from the principal components; pc, and return x; It's the users responsibility to make sure that both x and pc are; of the right size (i.e., memory must be allocated for p). void WriteTransformationToStream(ostream& ) const; write mean values to stream. void AttachXMLTo(void* parent); create XML description of PCA transformation. void ReadFromXML(void* trfnode); Read the transformation matrices from the xml node. void ReadTransformationFromStream(istream& , const TString& ); Read mean values from input stream. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); creates C++ code fragment of the PCA transform for inclusion in standalone C++ class. VariablePCATransform( DataSetInfo& dsi ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__VariablePCATransform.html:11999,allocate,allocated,11999,root/html604/TMVA__VariablePCATransform.html,https://root.cern,https://root.cern/root/html604/TMVA__VariablePCATransform.html,1,['allocate'],['allocated']
Energy Efficiency,"nt*const , Int_t cls) const; apply the principal component analysis; TODO: implementation of inverse transformation; Log() << kFATAL << ""Inverse transformation for PCA transformation not yet implemented. Hence, this transformation cannot be applied together with regression. Please contact the authors if necessary."" << Endl;. void CalculatePrincipalComponents(const vector<TMVA::Event*>& ); calculate the principal components for the signal and the background data; it uses the MakePrincipal method of ROOT's TPrincipal class. void X2P(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Calculate the principal components from the original data vector; x, and return it in p (function extracted from TPrincipal::X2P); It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). void P2X(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Perform the back-transformation from the principal components; pc, and return x; It's the users responsibility to make sure that both x and pc are; of the right size (i.e., memory must be allocated for p). void WriteTransformationToStream(ostream& ) const; write mean values to stream. void AttachXMLTo(void* parent); create XML description of PCA transformation. void ReadFromXML(void* trfnode); Read the transformation matrices from the xml node. void ReadTransformationFromStream(istream& , const TString& ); Read mean values from input stream. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); creates C++ code fragment of the PCA transform for inclusion in standalone C++ class. VariablePCATransform( DataSetInfo& dsi ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__VariablePCATransform.html:11991,allocate,allocated,11991,root/html602/TMVA__VariablePCATransform.html,https://root.cern,https://root.cern/root/html602/TMVA__VariablePCATransform.html,1,['allocate'],['allocated']
Energy Efficiency,nt::fDenyDestroy! Deny-destroy count.; Float_tTEveProjected::fDepthz coordinate; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Bool_tTEveShape::fDrawFramedraw frame; Color_tTEveShape::fFillColorfill color of polygons; Bool_tTEveShape::fHighlightFramehighlight frame / all shape; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; TEveElement::sLTI_tTEveElement::fItems! Set of list-tree-items.; Color_tTEveShape::fLineColoroutline color of polygons; Float_tTEveShape::fLineWidthoutline width of polygons; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TEveProjectionManager*TEveProjected::fManagermanager; Bool_tTEveShape::fMiniFramedraw minimal frame; Int_tfNPntsnumber of reduced and projected points; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; TEveElement::List_tTEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; TEveVector*fPntsreduced and projected points; TEvePolygonSetProjected::vpPolygon_tfPolspolygons; TEvePolygonSetProjected::vpPolygon_tfPolsBPpolygons build from TBuffer3D polygons; TEvePolygonSetProjected::vpPolygon_tfPolsBSpolygons build from TBuffer3D segments; TEveProjectable*TEveProjected::fProjectablelink to original object; TEveProjectable::ProjList_tTEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items t,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEvePolygonSetProjected.html:22071,reduce,reduced,22071,root/html602/TEvePolygonSetProjected.html,https://root.cern,https://root.cern/root/html602/TEvePolygonSetProjected.html,2,['reduce'],['reduced']
Energy Efficiency,"ntType type); Simple event. void PacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead); Packet event. void FileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); File event. void FileOpenEvent(TFile* file, const char* filename, Double_t start); Open file event. void FileReadEvent(TFile* file, Int_t len, Double_t start); Read file event. void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); Rate event. void SetBytesRead(Long64_t num); Set number of bytes read. Long64_t GetBytesRead() const; Get number of bytes read. void WriteQueryLog(); Connect to SQL server and register query log used for quotas.; The proofquerylog table has the format:; CREATE TABLE proofquerylog (; id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,; user VARCHAR(32) NOT NULL,; group VARCHAR(32),; begin DATETIME,; end DATETIME,; walltime INT,; cputime FLOAT,; bytesread BIGINT,; events BIGINT,; workers INT; ); The same info is send to Monalisa (or other monitoring systems) in the; form of a list of name,value pairs. void Setup(TList* input); Setup the PROOF input list with requested statistics and tracing options. void Start(TList* input, TList* output); Initialize PROOF statistics run. void Stop(); Terminate the PROOF statistics run. TPerfStats(TList* input, TList* output). virtual ~TPerfStats(); {}. void SetNumEvents(Long64_t num); { fNumEvents = num; }. Long64_t GetNumEvents() const; { return fNumEvents; }. » Author: Kristjan Gulbrandsen 11/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TPerfStats.h 30965 2009-11-04 11:15:25Z ganis $ » Last generated: 2010-10-03 18:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPerfStats.html:8710,monitor,monitoring,8710,root/html528/TPerfStats.html,https://root.cern,https://root.cern/root/html528/TPerfStats.html,1,['monitor'],['monitoring']
Energy Efficiency,"nt_t col, double* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSparse_double_.html:18429,allocate,allocated,18429,root/html528/TMatrixTSparse_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_double_.html,6,['allocate'],['allocated']
Energy Efficiency,"nt_t firstbin, Int_t lastbin, Option_t *option) const;  Internal (protected) method for performing projection on the X or Y axis called by ProjectionX or ProjectionY. ;  ; virtual TH1D * DoQuantiles (bool onX, const char *name, Double_t prob) const;  Implementation of quantiles for x or y. ;  ; Double_t Interpolate (Double_t x) const override;  illegal for a TH2 ;  ;  Protected Member Functions inherited from TH1;  TH1 ();  Histogram default constructor. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins);  Constructor for variable bin size histograms using an input array of type double. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Float_t *xbins);  Constructor for variable bin size histograms using an input array of type float. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup);  Constructor for fix bin size histograms. ;  ; virtual Int_t AutoP2FindLimits (Double_t min, Double_t max);  Buffer-based estimate of the histogram range using the power of 2 algorithm. ;  ; Int_t AxisChoice (Option_t *axis) const;  Choose an axis according to ""axis"". ;  ; virtual void DoFillN (Int_t ntimes, const Double_t *x, const Double_t *w, Int_t stride=1);  Internal method to fill histogram content from a vector called directly by TH1::BufferEmpty. ;  ; virtual Double_t DoIntegral (Int_t ix1, Int_t ix2, Int_t iy1, Int_t iy2, Int_t iz1, Int_t iz2, Double_t &err, Option_t *opt, Bool_t doerr=kFALSE) const;  Internal function compute integral and optionally the error between the limits specified by the bin number values working for all histograms (1D, 2D and 3D) ;  ; virtual Bool_t FindNewAxisLimits (const TAxis *axis, const Double_t point, Double_t &newMin, Double_t &newMax);  finds new limits for the axis so that point is within the range and the limits are compatible with the previous ones (see TH1::Merge). ;  ; UInt_t GetAxisLabelStatus () const;  Internal function used in TH1::Fill to see ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile2D.html:58143,power,power,58143,doc/master/classTProfile2D.html,https://root.cern,https://root.cern/doc/master/classTProfile2D.html,1,['power'],['power']
Energy Efficiency,"nt_tTGraph::fNpointsNumber of points <= fMaxSize; TObject*fObjectX!pointer to an object corresponding to X; TObject*fObjectY!pointer to an object corresponding to Y; TStringTNamed::fTitleobject title; TStringfVarXX variable; TStringfVarYY variable; Double_t*TGraph::fX[fNpoints] array of X points; Double_t*TGraph::fY[fNpoints] array of Y points. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCutG(); TCutG default constructor. TCutG(const TCutG& cutg); TCutG copy constructor. TCutG(const char* name, Int_t n); TCutG normal constructor. TCutG(const char* name, Int_t n, const Float_t* x, const Float_t* y); TCutG normal constructor. TCutG(const char* name, Int_t n, const Double_t* x, const Double_t* y); TCutG normal constructor. ~TCutG(); TCutG destructor. Double_t Area() const; Compute the area inside this TCutG; The algorithm uses Stoke's theorem over the border of the closed polygon.; Just as a reminder: Stoke's theorem reduces a surface integral; to a line integral over the border of the surface integral. void Center(Double_t& cx, Double_t& cy) const; Compute the center x,y of this TCutG; The algorithm uses Stoke's theorem over the border of the closed polygon.; Just as a reminder: Stoke's theorem reduces a surface integral; to a line integral over the border of the surface integral. Double_t IntegralHist(TH2* h, Option_t* option = """") const; Compute the integral of 2-d histogram h for all bins inside the cut; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x and in y. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetObjectX(TObject* obj); Set the X object (and delete the previous one if any). void SetObjectY(TObject* obj); Set the Y object (and delete the previous one if any). void SetVarX(const char* varx); Set X variable. void SetVarY(const char* vary); Set Y variable. void Streamer(TBuffe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TCutG.html:16640,reduce,reduces,16640,root/html528/TCutG.html,https://root.cern,https://root.cern/root/html528/TCutG.html,3,['reduce'],['reduces']
Energy Efficiency,"nt_tfYmaxlast fitted channel in y direction; Int_tfYminfirst fitted channel in y direction. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TSpectrum2Fit. Function documentation; TSpectrum2Fit(); default constructor. TSpectrum2Fit(Int_t numberPeaks); numberPeaks: number of fitted peaks (must be greater than zero); the constructor allocates arrays for all fitted parameters (peak positions, amplitudes etc) and sets the member; variables to their default values. One can change these variables by member functions (setters) of TSpectrumFit class. . Shape function of the fitted; peaks contains the two-dimensional symmetrical Gaussian two one-dimensional; symmetrical Gaussian ridges as well as nonsymmetrical terms and background. ~TSpectrum2Fit(); destructor. Double_t Erfc(Double_t x). AUXILIARY FUNCTION. This function calculates error function of x. Double_t Derfc(Double_t x). AUXILIARY FUNCTION. This function calculates derivative of error function of x. Double_t Ourpowl(Double_t a, Int_t pw); power function. void StiefelInversion(Double_t** a, Int_t size). AUXILIARY FUNCTION. This function calculates solution of the system of linear equations.; The matrix a should have a dimension size*(size+4); The calling function should fill in the matrix, the column size should; contain vector y (right side of the system of equations). The result is; placed into size+1 column of the matrix.; according to sigma of peaks.; Function parameters:; -a-matrix with dimension size*(size+4) //; -size-number of rows of the matrix. Double_t Shape2(Int_t numOfFittedPeaks, Double_t x, Double_t y, const Double_t* parameter, Double_t sigmax, Double_t sigmay, Double_t ro, Double_t a0, Double_t ax, Double_t ay, Double_t txy, Double_t sxy, Double_t tx, Double_t ty, Double_t sx, Double_t sy, Double_t bx, Double_t by). AUXILIARY FUNCTION. This function calculates 2D peaks shape function (see manual); Function parameters:; -numOfFittedPeaks-number of fitted peaks; -x-channel in x-dimension; -y-c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum2Fit.html:23914,power,power,23914,root/html602/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html602/TSpectrum2Fit.html,2,['power'],['power']
Energy Efficiency,"ntable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tRooAbsCollection::_allRRVAll contents are RRV; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents.; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool; TNamed*RooAbsCollection::_structureTag! Structure tag; TNamed*RooAbsCollection::_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooArgSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void* operator new(size_t bytes, void* ptr); Overloaded new operator with placement does not guarante that all; RooArgSets allocated with new have a unique address, but uses the global; operator. void operator delete(void* ptr); Memory is owned by pool, we need to do nothing to release it. RooArgSet(); Default constructor. RooArgSet(const RooArgList& list); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. RooArgSet(const RooArgList& list, const RooAbsArg* var1); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooArgSet.html:15692,allocate,allocated,15692,root/html602/RooArgSet.html,https://root.cern,https://root.cern/root/html602/RooArgSet.html,2,['allocate'],['allocated']
Energy Efficiency,"ntative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. vector<Float_t>fAverageRMSaverage RMS of signal and background; TMVA::BinarySearchTree*fBinaryTreebinary tree; vector<Float_t>*fDeltasize of volume; Float_tfDeltaFracfraction of RMS; Double_tfGaussSigmasize of Gauss in adaptive volume ; Double_tfGaussSigmaNormsize of Gauss in adaptive volume (normalised to dimensions); Float_tfInitialScaleinitial scale for adaptive volume; Bool_tfInitializedVolumeEleis volume element initialized ?; TMVA::MethodPDERS::EKernelEstimatorfKernelEstimator; TStringfKernelStringoption kernel estimator; Float_tfMaxVIterationsmaximum number of iterations to adapt volume size; Double_tfMax_distancemaximum distance; Float_tfNEventsMaxmaximum number of events in adaptive volume; Float_tfNEventsMinminimum number of events in adaptive volume; Double_tfNRegOutnumber of output dimensions for regression; Bool_tfNormTreebinary-search tree is normalised; Bool_tfPrintedprint; Float_tfScaleBweight for background events; Float_tfScaleSweight for signal events; vector<Float_t>*fShiftvolume center; TMVA::MethodPDERS::EVolumeRangeModefVRangeMode; TStringfVolumeRangeoption volume range; static TMVA::MethodPDERS*fgThisPDERSthis pointer (required by root finder); Int_tfkNNMaxmax number of events in kNN tree; Int_tfkNNMinmin number of events in kNN tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodPDERS(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0); standard constructor for the PDERS method. MethodPDERS(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodPDERS.html:18693,adapt,adaptive,18693,root/html528/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDERS.html,6,['adapt'],"['adapt', 'adaptive']"
Energy Efficiency,"nted in TMVA::DNN::ClassificationSettings.; Definition at line 804 of file NeuralNet.h. ◆ startTrainCycle(). virtual void TMVA::DNN::Settings::startTrainCycle ; (; ). inlinevirtual . Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 782 of file NeuralNet.h. ◆ startTraining(). virtual void TMVA::DNN::Settings::startTraining ; (; ). inlinevirtual . Definition at line 795 of file NeuralNet.h. ◆ testIteration(). virtual void TMVA::DNN::Settings::testIteration ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 806 of file NeuralNet.h. ◆ testRepetitions(). size_t TMVA::DNN::Settings::testRepetitions ; (; ); const. inline . how often is the test data tested ; Definition at line 768 of file NeuralNet.h. ◆ testSample(). virtual void TMVA::DNN::Settings::testSample ; (; double ; , . double ; , . double ; , . double ;  . ). inlinevirtual . virtual function to be used for monitoring (callback) ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 781 of file NeuralNet.h. ◆ useMultithreading(). bool TMVA::DNN::Settings::useMultithreading ; (; ); const. inline . is multithreading turned on? ; Definition at line 815 of file NeuralNet.h. Member Data Documentation. ◆ count_dE. size_t TMVA::DNN::Settings::count_dE. Definition at line 843 of file NeuralNet.h. ◆ count_E. size_t TMVA::DNN::Settings::count_E. Definition at line 842 of file NeuralNet.h. ◆ count_mb_dE. size_t TMVA::DNN::Settings::count_mb_dE. Definition at line 845 of file NeuralNet.h. ◆ count_mb_E. size_t TMVA::DNN::Settings::count_mb_E. Definition at line 844 of file NeuralNet.h. ◆ fLearningRate. double TMVA::DNN::Settings::fLearningRate. Definition at line 852 of file NeuralNet.h. ◆ fMinimizerType. MinimizerType TMVA::DNN::Settings::fMinimizerType. Definition at line 855 of file NeuralNet.h. ◆ fMomentum. double TMVA::DNN::Settings::fMomentum. Definition at line 853 of file NeuralNet.h. ◆ fMonitor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:12780,monitor,monitoring,12780,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['monitor'],['monitoring']
Energy Efficiency,"ntegrationMultiDim::Type ; type = IntegrationMultiDim::kDEFAULT, . double ; absTol = -1, . double ; relTol = -1, . unsigned int ; ncall = 0 . ). inlineexplicit . Generic constructor of multi dimensional Integrator. ; By default uses the Adaptive integration method; Parameters. typeintegration type (adaptive, MC methods, etc..) ; absToldesired absolute Error ; relToldesired relative Error ; ncallnumber of function calls (apply only to MC integration methods). In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used ; Definition at line 64 of file IntegratorMultiDim.h. ◆ IntegratorMultiDim() [2/3]. ROOT::Math::IntegratorMultiDim::IntegratorMultiDim ; (; const IMultiGenFunction & ; f, . IntegrationMultiDim::Type ; type = IntegrationMultiDim::kDEFAULT, . double ; absTol = -1, . double ; relTol = -1, . unsigned int ; ncall = 0 . ). inlineexplicit . Generic Constructor of multi dimensional Integrator passing a function. ; By default uses the adaptive integration method; Parameters. fintegration function (multi-dim interface) ; typeintegration type (adaptive, MC methods, etc..) ; absToldesired absolute Error ; relToldesired relative Error ; ncallnumber of function calls (apply only to MC integration methods) . Definition at line 79 of file IntegratorMultiDim.h. ◆ ~IntegratorMultiDim(). virtual ROOT::Math::IntegratorMultiDim::~IntegratorMultiDim ; (; ). inlinevirtual . Template Constructor of multi dimensional Integrator passing a generic function. ; By default uses the adaptive integration method; Parameters. fintegration function (generic function implementing operator()(const double *) ; dimfunction dimension ; typeintegration type (adaptive, MC methods, etc..) ; absToldesired absolute Error ; relToldesired relative Error ; ncallnumber of function calls (apply only to MC integration methods) destructor . Definition at line 105 of file IntegratorMultiDim.h. ◆ IntegratorMultiDim() [3/3]. ROOT::Math::IntegratorMultiDim::IntegratorMul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorMultiDim.html:4987,adapt,adaptive,4987,doc/master/classROOT_1_1Math_1_1IntegratorMultiDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorMultiDim.html,1,['adapt'],['adaptive']
Energy Efficiency,"ntegrator(ROOT::Math::IntegrationOneDim::Type type, double absTol, double relTol, unsigned int size, int rule). private:. ROOT::Math::IntegratorOneDimIntegratorOneDim(const ROOT::Math::IntegratorOneDim&); ROOT::Math::IntegratorOneDim&operator=(const ROOT::Math::IntegratorOneDim&). Data Members; private:. auto_ptr<ROOT::Math::IGenFunction>fFuncpointer to owned function; ROOT::Math::VirtualIntegratorOneDim*fIntegratorpointer to integrator interface class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetFunction( Function & f). double Integral(const ROOT::Math::IGenFunction& f, double a, double b). double Integral(double a, double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). IntegratorOneDim(ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, unsigned int rule = 0); constructors. Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IntegratorOneDim.html:4645,adapt,adaptive,4645,root/html602/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IntegratorOneDim.html,1,['adapt'],['adaptive']
Energy Efficiency,"ntent() [1/2]. Double_t THnSparse::GetBinContent ; (; const Int_t * ; idx); const. inline . Forwards to THnBase::GetBinContent() overload. ; Non-virtual, CINT-compatible replacement of a using declaration. ; Definition at line 121 of file THnSparse.h. ◆ GetBinContent() [2/2]. Double_t THnSparse::GetBinContent ; (; Long64_t ; idx, . Int_t * ; coord = nullptr . ); const. overridevirtual . Return the content of the filled bin number ""idx"". ; If coord is non-null, it will contain the bin's coordinates for each axis that correspond to the bin. ; Implements THnBase.; Definition at line 744 of file THnSparse.cxx. ◆ GetBinError2(). Double_t THnSparse::GetBinError2 ; (; Long64_t ; linidx); const. overridevirtual . Get square of the error of bin addressed by linidx as \(\sum weight^{2}\) If errors are not enabled (via Sumw2() or CalculateErrors()) return contents. ; Implements THnBase.; Definition at line 771 of file THnSparse.cxx. ◆ GetBinIndexForCurrentBin(). Long64_t THnSparse::GetBinIndexForCurrentBin ; (; Bool_t ; allocate). protected . Return the index for fCurrentBinIndex. ; If it doesn't exist then return -1, or allocate a new bin if allocate is set ; Definition at line 789 of file THnSparse.cxx. ◆ GetChunk(). THnSparseArrayChunk * THnSparse::GetChunk ; (; Int_t ; idx); const. inlineprotected . Definition at line 56 of file THnSparse.h. ◆ GetChunkSize(). Int_t THnSparse::GetChunkSize ; (; ); const. inline . Definition at line 88 of file THnSparse.h. ◆ GetCompactCoord(). THnSparseCompactBinCoord * THnSparse::GetCompactCoord ; (; ); const. protected . Return THnSparseCompactBinCoord object. ; Definition at line 838 of file THnSparse.cxx. ◆ GetNbins(). Long64_t THnSparse::GetNbins ; (; ); const. inlineoverridevirtual . Implements THnBase.; Definition at line 93 of file THnSparse.h. ◆ GetNChunks(). Int_t THnSparse::GetNChunks ; (; ); const. inline . Definition at line 89 of file THnSparse.h. ◆ GetSparseFractionBins(). Double_t THnSparse::GetSparseFractionBins ; (; ); cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnSparse.html:35463,allocate,allocate,35463,doc/master/classTHnSparse.html,https://root.cern,https://root.cern/doc/master/classTHnSparse.html,1,['allocate'],['allocate']
Energy Efficiency,"ntergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object; or in the model itself. If no prior nuisance is specified, but prior parameters are then; the integration is performed assuming a flat prior for the nuisance parameters.; NOTE: the return object is managed by the class, users do not need to delete it. RooAbsPdf* GetPosteriorPdf() const; Build and return the posterior pdf (i.e posterior function normalized to all range of poi); Note that an extra integration in the POI is required for the normalization; NOTE: user must delete the returned object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__BayesianCalculator.html:12422,adapt,adaptive,12422,root/html530/RooStats__BayesianCalculator.html,https://root.cern,https://root.cern/root/html530/RooStats__BayesianCalculator.html,10,['adapt'],['adaptive']
Energy Efficiency,"nternal data structure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t maxent = -1, Bool_t byfile = kFALSE); Check existence of file/dir/tree an get number of entries.; Assumes the files have been setup. Int_t CalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); The result depends on the fStrategy. Int_t AddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); To be used by GetNextPacket but also in reaction to kPROOF_STOPPROCESS; message (when the worker was asked to stop processing during a packet).; returns the #entries intended in the last packet - #processed entries. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet;; A meaningfull difference to TPacketizer is the fact that this; packetizer, for each worker, tries to predict whether the worker; will finish processing it's local files before the end of the query.; If yes, it allocates, to those workers, files from non-slave filenodes; or from slaves that are overloaded. The check is done every time a new; file needs to be assigned. Int_t GetActiveWorkers(); Return the number of workers still processing. Float_t GetCurrentRate(Bool_t& all); Get Estimation of the current rate; just summing the current rates of; the active workers. Int_t GetEstEntriesProcessed(Float_t , Long64_t& ent, Long64_t& bytes, Long64_t& calls); Get estimation for the number of processed entries and bytes read at time t,; based on the numbers already processed and the latests worker measured speeds.; If t <= 0 the current time is used.; Only the estimation for the entries is currently implemented.; This is needed to smooth the instantaneous rate plot. void MarkBad(TSlave* s, TProofProgressStatus* status, TList** missingFiles); This method can be called at any time during processing; as an effect of handling kPROOF_STOPPROCESS; If the output list from this worker is going to be sent back to the master,; the 'status' includes th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPacketizerAdaptive.html:13068,allocate,allocates,13068,root/html528/TPacketizerAdaptive.html,https://root.cern,https://root.cern/root/html528/TPacketizerAdaptive.html,6,['allocate'],['allocates']
Energy Efficiency,"ntf(defhist, sizeof(defhist), ""%s/.root_hist"", gSystem->HomeDirectory());; 259 logon = gEnv->GetValue(""Rint.History"", defhist);; 260 // In the code we had HistorySize and HistorySave, in the rootrc and doc; 261 // we have HistSize and HistSave. Keep the doc as it is and check; 262 // now also for HistSize and HistSave in case the user did not use; 263 // the History versions; 264 int hist_size = gEnv->GetValue(""Rint.HistorySize"", 500);; 265 if (hist_size == 500); 266 hist_size = gEnv->GetValue(""Rint.HistSize"", 500);; 267 int hist_save = gEnv->GetValue(""Rint.HistorySave"", 400);; 268 if (hist_save == 400); 269 hist_save = gEnv->GetValue(""Rint.HistSave"", 400);; 270 const char *envHist = gSystem->Getenv(""ROOT_HIST"");; 271 if (envHist) {; 272 hist_size = atoi(envHist);; 273 envHist = strchr(envHist, ':');; 274 if (envHist); 275 hist_save = atoi(envHist+1);; 276 }; 277 Gl_histsize(hist_size, hist_save);; 278 Gl_histinit((char *)logon);; 279 ; 280 // black on white or white on black?; 281 static const char* defaultColorsBW[] = {; 282 ""bold blue"", ""magenta"", ""bold green"", ""bold red underlined"", ""default""; 283 };; 284 static const char* defaultColorsWB[] = {; 285 ""yellow"", ""magenta"", ""bold green"", ""bold red underlined"", ""default""; 286 };; 287 ; 288 const char** defaultColors = defaultColorsBW;; 289 TString revColor = gEnv->GetValue(""Rint.ReverseColor"", ""no"");; 290 if (revColor.Contains(""yes"", TString::kIgnoreCase)) {; 291 defaultColors = defaultColorsWB;; 292 }; 293 TString colorType = gEnv->GetValue(""Rint.TypeColor"", defaultColors[0]);; 294 TString colorTabCom = gEnv->GetValue(""Rint.TabComColor"", defaultColors[1]);; 295 TString colorBracket = gEnv->GetValue(""Rint.BracketColor"", defaultColors[2]);; 296 TString colorBadBracket = gEnv->GetValue(""Rint.BadBracketColor"", defaultColors[3]);; 297 TString colorPrompt = gEnv->GetValue(""Rint.PromptColor"", defaultColors[4]);; 298 Gl_setColors(colorType, colorTabCom, colorBracket, colorBadBracket, colorPrompt);; 299 ; 300 Gl_windowchang",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:9550,green,green,9550,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,2,['green'],['green']
Energy Efficiency,nting numeric convolution of 2 input PDFs; RooNumConvolution Operator PDF implementing numeric convolution of 2 input functions; RooNumGenConfig Numeric (MC) Event generator configuration ; RooNumGenFactory Numeric Generator factory; RooNumIntConfig Numeric Integrator configuration ; RooNumIntFactory Numeric Integrator factory; RooNumRunningInt Numeric calculator for running integral of a given function; RooNumber wrapper class for portable numerics; RooObjCacheManager Cache manager for generic caches that contain RooAbsArg objects; RooParamBinning Binning specification with ranges parameterized by external RooAbsReal functions; RooParamHistFunc Your description goes here...; RooParametricStepFunction Parametric Step Function Pdf; RooPlot Plot frame and container for graphics objects; RooPlotable Abstract interface for plotable objects in a RooPlot; RooPoisson A Poisson PDF; RooPolyVar Polynomial function; RooPolynomial Polynomial PDF; RooPrintable Interface for printable objects; RooProdGenContext Context for efficient generation of a a dataset from a RooProdPdf; RooProdPdf PDF representing a product of PDFs; RooProduct Product of RooAbsReal and/or RooAbsCategory terms; RooProfileLL Real-valued function representing profile likelihood of external (likelihood) function; RooProjectedPdf Operator p.d.f calculating projection of another p.d.f; RooProofDriverSelector ; RooPullVar Calculation of pull of measurement w.r.t a truth value; RooQuasiRandomGenerator Quasi-random number generator; RooRandom Random number generator interface; RooRandomizeParamMCSModule MCStudy module to vary one or more input parameters during fit/generation cycle; RooRangeBinning Binning that only defines the total range; RooRangeBoolean Polynomial function; RooRealAnalytic Function binding to an analytical integral of a RooAbsReal; RooRealBinding Function binding to RooAbsReal object; RooRealConstant RooRealVar constants factory; RooRealIntegral Real-valued function representing an integral over,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:41740,efficient,efficient,41740,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,1,['efficient'],['efficient']
Energy Efficiency,"ntion.; 129 // To remove this ambiguity which might not always be correctly handled in; 130 // downstream code, we set `normalisationSet` to nullptr if it is an empty set.; 131 return _fast ? _value : getValV(normalisationSet.empty() ? nullptr : &normalisationSet) ;; 132 }; 133 ; 134 virtual double getValV(const RooArgSet* normalisationSet = nullptr) const ;; 135 ; 136 double getPropagatedError(const RooFitResult &fr, const RooArgSet &nset = {}) const;; 137 ; 138 bool operator==(double value) const ;; 139 bool operator==(const RooAbsArg& other) const override;; 140 bool isIdentical(const RooAbsArg& other, bool assumeSameType=false) const override;; 141 ; 142 ; 143 inline const Text_t *getUnit() const {; 144 // Return string with unit description; 145 return _unit.Data();; 146 }; 147 inline void setUnit(const char *unit) {; 148 // Set unit description to given string; 149 _unit= unit;; 150 }; 151 TString getTitle(bool appendUnit= false) const;; 152 ; 153 // Lightweight interface adaptors (caller takes ownership); 154 RooFit::OwningPtr<RooAbsFunc> bindVars(const RooArgSet &vars, const RooArgSet* nset=nullptr, bool clipInvalid=false) const;; 155 ; 156 // Create a fundamental-type object that can hold our value.; 157 RooFit::OwningPtr<RooAbsArg> createFundamental(const char* newname=nullptr) const override;; 158 ; 159 // Analytical integration support; 160 virtual Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 161 virtual double analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 162 virtual Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName=nullptr) const ;; 163 virtual double analyticalIntegral(Int_t code, const char* rangeName=nullptr) const ;; 164 virtual bool forceAnalyticalInt(const RooAbsArg& /*dep*/) const {; 165 // Interface to force RooRealIntegral to offer given observable for internal ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8h_source.html:6106,adapt,adaptors,6106,doc/master/RooAbsReal_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html,1,['adapt'],['adaptors']
Energy Efficiency,"nto a single object ;  . Private Attributes; std::shared_ptr< ROOT::Internal::RTaskArenaWrapper > fTaskArenaW = nullptr;  Pointer to the TBB task arena wrapper. ;  ; friend TExecutorCRTP;  . Additional Inherited Members;  Protected Types inherited from ROOT::TExecutorCRTP< TThreadExecutor >; using InvokeResult_t = ROOT::TypeTraits::InvokeResult_t< F, Args... >;  ; using validMapReturnCond = std::enable_if_t<!std::is_reference< InvokeResult_t< F, T... > >::value &&!std::is_void< InvokeResult_t< F, T... > >::value >;  type definition used in templated functions for not allowing mapping functions that return references or void. ;  . #include <ROOT/TThreadExecutor.hxx>. Inheritance diagram for ROOT::TThreadExecutor:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TThreadExecutor() [1/2]. ROOT::TThreadExecutor::TThreadExecutor ; (; UInt_t ; nThreads = 0u). explicit . Class constructor. ; If the scheduler is active (e.g. because another TThreadExecutor is in flight, or ROOT::EnableImplicitMT() was called), work with the current pool of threads. If not, initialize the pool of threads, spawning nThreads. nThreads' default value, 0, initializes the pool with as many logical threads as are available in the system (see NLogicalCores in RTaskArenaWrapper.cxx).; At construction time, TThreadExecutor automatically enables ROOT's thread-safety locks as per calling ROOT::EnableThreadSafety(). ; Definition at line 149 of file TThreadExecutor.cxx. ◆ TThreadExecutor() [2/2]. ROOT::TThreadExecutor::TThreadExecutor ; (; const TThreadExecutor & ; ). delete . Member Function Documentation. ◆ Foreach() [1/5]. template<class F , class T > . void ROOT::TThreadExecutor::Foreach ; (; F ; func, . const std::vector< T > & ; args, . unsigned ; nChunks = 0 . ). Execute a function in parallel over the elements of a immutable vector, dividing the execution in nChunks. ; Parameters. funcFunction to be executed o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TThreadExecutor.html:15737,schedul,scheduler,15737,doc/v632/classROOT_1_1TThreadExecutor.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TThreadExecutor.html,2,['schedul'],['scheduler']
Energy Efficiency,"nto it as needed.; 448 template <typename It1, typename It2>; 449 static void uninitialized_copy(It1 I, It1 E, It2 Dest); 450 {; 451 // Arbitrary iterator types; just use the basic implementation.; 452 std::uninitialized_copy(I, E, Dest);; 453 }; 454 ; 455 /// Copy the range [I, E) onto the uninitialized memory; 456 /// starting with ""Dest"", constructing elements into it as needed.; 457 template <typename T1, typename T2>; 458 static void uninitialized_copy(; 459 T1 *I, T1 *E, T2 *Dest,; 460 typename std::enable_if<std::is_same<typename std::remove_const<T1>::type, T2>::value>::type * = nullptr); 461 {; 462 // Use memcpy for PODs iterated by pointers (which includes SmallVector; 463 // iterators): std::uninitialized_copy optimizes to memmove, but we can; 464 // use memcpy here. Note that I and E are iterators and thus might be; 465 // invalid for memcpy if they are equal.; 466 if (I != E); 467 memcpy(reinterpret_cast<void *>(Dest), I, (E - I) * sizeof(T));; 468 }; 469 ; 470 /// Double the size of the allocated memory, guaranteeing space for at; 471 /// least one more element or MinSize if specified.; 472 void grow(size_t MinSize = 0); 473 {; 474 this->grow_pod(MinSize, sizeof(T));; 475 }; 476 ; 477public:; 478 using iterator = typename SuperClass::iterator;; 479 using const_iterator = typename SuperClass::const_iterator;; 480 using reference = typename SuperClass::reference;; 481 using size_type = typename SuperClass::size_type;; 482 ; 483 void push_back(const T &Elt); 484 {; 485 if (R__unlikely(this->size() >= this->capacity())); 486 this->grow();; 487 memcpy(reinterpret_cast<void *>(this->end()), &Elt, sizeof(T));; 488 this->set_size(this->size() + 1);; 489 }; 490 ; 491 void pop_back() { this->set_size(this->size() - 1); }; 492};; 493 ; 494/// Storage for the SmallVector elements. This is specialized for the N=0 case; 495/// to avoid allocating unnecessary storage.; 496template <typename T, unsigned N>; 497struct SmallVectorStorage {; 498 alignas(T) char InlineElt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:17281,allocate,allocated,17281,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['allocate'],['allocated']
Energy Efficiency,"ntryFillColor(Int_t ); Return the color of the slice number ""i"". Int_t GetEntryFillStyle(Int_t ); Return the style use to fill the slice number ""i"". Int_t GetEntryLineColor(Int_t ); Return the line color used to outline thi ""i"" slice. Int_t GetEntryLineStyle(Int_t ); Return the style used to outline thi ""i"" slice. Int_t GetEntryLineWidth(Int_t ); Return the line width used to outline thi ""i"" slice. Double_t GetEntryRadiusOffset(Int_t ); Return the radial offset's value for the slice number ""i"". Double_t GetEntryVal(Int_t ); Return the value associated with the slice number ""i"". TLegend* GetLegend(); If created before by Paint option or by MakeLegend method return; the pointer to the legend, otherwise return 0;. TPieSlice* GetSlice(Int_t i); Return the reference to the slice of index 'id'. There are no controls; of memory corruption, be carefull. void Init(Int_t np, Double_t ao, Double_t x, Double_t y, Double_t r); Common initialization for all constructors.; This is a private function called to allocate the memory. TLegend* MakeLegend(Double_t x1 = .65, Double_t y1 = .65, Double_t x2 = .95, Double_t y2 = .95, const char* leg_header = """"); This method create a legend that explains the contents; of the slice for this pie-chart. The parameter passed reppresents the option passed to shown the slices,; see TLegend::AddEntry() for futher details. The pointer of the TLegend is returned. void Paint(Option_t* ); Paint a Pie chart in a canvas.; The possible option are:. ""R"" Print the labels along the central ""R""adius of slices.; ""T"" Print the label in a direction ""T""angent to circle that describes; the TPie.; ""3D"" Draw the pie-chart with a pseudo 3D effect.; ""NOL"" No OutLine: Don't draw the slices' outlines, any property over the; slices' line is ignored.; "">"" Sort the slices in increasing order.; ""<"" Sort the slices in decreasing order. After the use of > or < options the internal order of the TPieSlices; is changed. Other options changing the labels' format are described in;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPie.html:12033,allocate,allocate,12033,root/html528/TPie.html,https://root.cern,https://root.cern/root/html528/TPie.html,3,['allocate'],['allocate']
Energy Efficiency,"ntryFillColor(Int_t ); Return the color of the slice number ""i"". Int_t GetEntryFillStyle(Int_t ); Return the style use to fill the slice number ""i"". Int_t GetEntryLineColor(Int_t ); Return the line color used to outline thi ""i"" slice. Int_t GetEntryLineStyle(Int_t ); Return the style used to outline thi ""i"" slice. Int_t GetEntryLineWidth(Int_t ); Return the line width used to outline thi ""i"" slice. Double_t GetEntryRadiusOffset(Int_t ); Return the radial offset's value for the slice number ""i"". Double_t GetEntryVal(Int_t ); Return the value associated with the slice number ""i"". TLegend* GetLegend(); If created before by Paint option or by MakeLegend method return; the pointer to the legend, otherwise return 0;. TPieSlice* GetSlice(Int_t i); Return the reference to the slice of index 'id'. There are no controls; of memory corruption, be carefull. void Init(Int_t np, Double_t ao, Double_t x, Double_t y, Double_t r); Common initialization for all constructors.; This is a private function called to allocate the memory. TLegend* MakeLegend(Double_t x1 = .65, Double_t y1 = .65, Double_t x2 = .95, Double_t y2 = .95, const char* leg_header = """"); This method create a legend that explains the contents; of the slice for this pie-chart. The parameter passed reppresents the option passed to shown the slices,; see TLegend::AddEntry() for futher details. The pointer of the TLegend is returned. void Paint(Option_t* ); Paint a Pie chart in a canvas.; The possible option are:. ""R"" Print the labels along the central ""R""adius of slices.; ""T"" Print the label in a direction ""T""angent to circle that describes; the TPie.; ""SC"" Paint the the labels with the ""S""ame ""C""olor as the slices.; ""3D"" Draw the pie-chart with a pseudo 3D effect.; ""NOL"" No OutLine: Don't draw the slices' outlines, any property over the; slices' line is ignored.; "">"" Sort the slices in increasing order.; ""<"" Sort the slices in decreasing order. After the use of > or < options the internal order of the TPieSlices; is ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPie.html:12225,allocate,allocate,12225,root/html534/TPie.html,https://root.cern,https://root.cern/root/html534/TPie.html,1,['allocate'],['allocate']
Energy Efficiency,"ntryFillColor(Int_t ); Return the color of the slice number ""i"". Int_t GetEntryFillStyle(Int_t ); Return the style use to fill the slice number ""i"". Int_t GetEntryLineColor(Int_t ); Return the line color used to outline thi ""i"" slice. Int_t GetEntryLineStyle(Int_t ); Return the style used to outline thi ""i"" slice. Int_t GetEntryLineWidth(Int_t ); Return the line width used to outline thi ""i"" slice. Double_t GetEntryRadiusOffset(Int_t ); Return the radial offset's value for the slice number ""i"". Double_t GetEntryVal(Int_t ); Return the value associated with the slice number ""i"". TLegend* GetLegend(); If created before by Paint option or by MakeLegend method return; the pointer to the legend, otherwise return 0;. TPieSlice* GetSlice(Int_t i); Return the reference to the slice of index 'id'. There are no controls; of memory corruption, be carefull. void Init(Int_t np, Double_t ao, Double_t x, Double_t y, Double_t r); Common initialization for all constructors.; This is a private function called to allocate the memory. TLegend* MakeLegend(Double_t x1 = 0.65000000000000002, Double_t y1 = 0.65000000000000002, Double_t x2 = 0.94999999999999996, Double_t y2 = 0.94999999999999996, const char* leg_header = """"); This method create a legend that explains the contents; of the slice for this pie-chart. The parameter passed reppresents the option passed to shown the slices,; see TLegend::AddEntry() for futher details. The pointer of the TLegend is returned. void Paint(Option_t* ); Paint a Pie chart in a canvas.; The possible option are:. ""R"" Print the labels along the central ""R""adius of slices.; ""T"" Print the label in a direction ""T""angent to circle that describes; the TPie.; ""SC"" Paint the the labels with the ""S""ame ""C""olor as the slices.; ""3D"" Draw the pie-chart with a pseudo 3D effect.; ""NOL"" No OutLine: Don't draw the slices' outlines, any property over the; slices' line is ignored.; "">"" Sort the slices in increasing order.; ""<"" Sort the slices in decreasing order. After the u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPie.html:12791,allocate,allocate,12791,root/html602/TPie.html,https://root.cern,https://root.cern/root/html602/TPie.html,2,['allocate'],['allocate']
Energy Efficiency,"nts a fundamental (non-derived) real valued object ;  CRooRealVarSharedPropertiesClass RooRealVarSharedProperties is an implementation of RooSharedProperties that stores the properties of a RooRealVar that are shared among clones ;  CRooRecursiveFractionClass RooRecursiveFraction is a RooAbsReal implementation that calculates the plain fraction of sum of RooAddPdf components from a set of recursive fractions: for a given set of input fractions a_i it returns a_0 * Prod_i (1 - a_i) ;  CRooRefArray;  CRooRefCountListA RooRefCountList is a RooLinkedList that keeps a reference counter with each added node ;  CRooResolutionModel;  CRooScaledFuncLightweight RooAbsFunction implementation that applies a constant scale factor to another RooAbsFunc ;  CRooSecondMomentRooSecondMoment represents the first, second, or third order derivative of any RooAbsReal as calculated (numerically) by the MathCore Richardson derivator class ;  CRooSegmentedIntegrator1DRooSegmentedIntegrator1D implements an adaptive one-dimensional numerical integration algorithm ;  CRooSegmentedIntegrator2DRooSegmentedIntegrator2D implements an adaptive one-dimensional numerical integration algorithm ;  CRooSentinelRooSentinel is a special purposes singleton class that terminates all other RooFit singleton services when the process exists ;  CRooSetPairRooSetPair is a utility class that stores a pair of RooArgSets ;  CRooSetProxyRooSetProxy is the concrete proxy for RooArgSet objects ;  CRooSharedPropertiesClass RooSharedProperties is the base class for shared properties that can be stored in RooSharedPropertiesList ;  CRooSharedPropertiesListClass RooSharedPropertiesList maintains the properties of RooRealVars and RooCategories that are clones of each other ;  CRooSimGenContextRooSimGenContext is an efficient implementation of the generator context specific for RooSimultaneous PDFs when generating more than one of the component pdfs ;  CRooSimPdfBuilder;  CRooSimSplitGenContextRooSimSplitGenContext is an eff",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:103888,adapt,adaptive,103888,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,5,['adapt'],['adaptive']
Energy Efficiency,"nts, normalized by the histograms contents. Interpolation; is applied if the RooHistFunc is configured to do that. Double_t totVolume() const; Return the total volume spanned by the observables of the RooDataHist. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistFunc can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used, only the integral; over all RooHistPdf observables is implemented. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. TObject* clone(const char* newname) const; { return new RooHistFunc(*this,newname); }. virtual ~RooHistFunc(); { }. RooDataHist& dataHist(); Return RooDataHist that is represented. const RooDataHist& dataHist(); Return RooDataHist that is represented. void setInterpolationOrder(Int_t order); Set histogram interpolation order. Int_t getInterpolationOrder() const; Return histogram interpolation order. void setCdfBoundaries(Bool_t flag); Set use of special boundary conditions for c.d.f.s. Bool_t getCdfBoundaries() const; If true, special boundary conditions for c.d.f.s are used. Double_t totalVolume() const. » Last changed: Mon Dec 7 13:47:59 2009 » Last generated: 2009-12-07 13:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHistFunc.html:34948,efficient,efficiently,34948,root/html526/RooHistFunc.html,https://root.cern,https://root.cern/root/html526/RooHistFunc.html,1,['efficient'],['efficiently']
Energy Efficiency,"nts. TVectorD TMultiDimFit::fOrthCoefficients. protected . The model coefficients. ; Definition at line 80 of file TMultiDimFit.h. ◆ fOrthCurvatureMatrix. TMatrixD TMultiDimFit::fOrthCurvatureMatrix. protected . Model matrix. ; Definition at line 81 of file TMultiDimFit.h. ◆ fOrthFunctionNorms. TVectorD TMultiDimFit::fOrthFunctionNorms. protected . Norm of the evaluated functions. ; Definition at line 65 of file TMultiDimFit.h. ◆ fOrthFunctions. TMatrixD TMultiDimFit::fOrthFunctions. protected . As above, but orthogonalised. ; Definition at line 64 of file TMultiDimFit.h. ◆ fParameterisationCode. Int_t TMultiDimFit::fParameterisationCode. protected . Exit code of parameterisation. ; Definition at line 86 of file TMultiDimFit.h. ◆ fPolyType. EMDFPolyType TMultiDimFit::fPolyType. protected . Fit object (MINUIT) ; Type of polynomials to use ; Definition at line 103 of file TMultiDimFit.h. ◆ fPowerIndex. Int_t* TMultiDimFit::fPowerIndex. protected . [fMaxTerms] Index of accepted powers ; Definition at line 70 of file TMultiDimFit.h. ◆ fPowerLimit. Double_t TMultiDimFit::fPowerLimit. protected . Control parameter. ; Definition at line 55 of file TMultiDimFit.h. ◆ fPowers. Int_t* TMultiDimFit::fPowers. protected . [fMaxFuncNV] where fMaxFuncNV = fMaxFunctions*fNVariables ; Definition at line 69 of file TMultiDimFit.h. ◆ fPrecision. Double_t TMultiDimFit::fPrecision. protected . Relative precision of param. ; Definition at line 90 of file TMultiDimFit.h. ◆ fQuantity. TVectorD TMultiDimFit::fQuantity. protected . Training sample, dependent quantity. ; Definition at line 28 of file TMultiDimFit.h. ◆ fResiduals. TVectorD TMultiDimFit::fResiduals. protected . Vector of the final residuals. ; Definition at line 72 of file TMultiDimFit.h. ◆ fRMS. Double_t TMultiDimFit::fRMS. protected . Root mean square of fit. ; Definition at line 84 of file TMultiDimFit.h. ◆ fSampleSize. Int_t TMultiDimFit::fSampleSize. protected . Size of training sample. ; Definition at line 42 of file TMulti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:66946,power,powers,66946,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['power'],['powers']
Energy Efficiency,"ntupleName, std::string_view storage, const RNTupleWriteOptions &options=RNTupleWriteOptions());  ; static std::unique_ptr< RNTupleWriter > Recreate (std::unique_ptr< RNTupleModel > model, std::string_view ntupleName, std::string_view storage, const RNTupleWriteOptions &options=RNTupleWriteOptions());  Throws an exception if the model is null. ;  . Private Member Functions;  RNTupleWriter (std::unique_ptr< RNTupleModel > model, std::unique_ptr< Internal::RPageSink > sink);  ; void CommitClusterGroup ();  ; Internal::RPageSink & GetSink ();  ; RNTupleModel & GetUpdatableModel ();  . Static Private Member Functions; static std::unique_ptr< RNTupleWriter > Create (std::unique_ptr< RNTupleModel > model, std::unique_ptr< Internal::RPageSink > sink, const RNTupleWriteOptions &options);  Create a writer, potentially wrapping the sink in a RPageSinkBuf. ;  . Private Attributes; RNTupleFillContext fFillContext;  ; NTupleSize_t fLastCommittedClusterGroup = 0;  ; Detail::RNTupleMetrics fMetrics;  ; std::unique_ptr< Internal::RPageStorage::RTaskScheduler > fZipTasks;  The page sink's parallel page compression scheduler if IMT is on. ;  . Friends; std::unique_ptr< RNTupleWriter > Internal::CreateRNTupleWriter (std::unique_ptr< RNTupleModel >, std::unique_ptr< Internal::RPageSink >);  . #include <ROOT/RNTupleWriter.hxx>; Constructor & Destructor Documentation. ◆ RNTupleWriter() [1/2]. ROOT::Experimental::RNTupleWriter::RNTupleWriter ; (; std::unique_ptr< RNTupleModel > ; model, . std::unique_ptr< Internal::RPageSink > ; sink . ). private . Definition at line 32 of file RNTupleWriter.cxx. ◆ RNTupleWriter() [2/2]. ROOT::Experimental::RNTupleWriter::RNTupleWriter ; (; const RNTupleWriter & ; ). delete . ◆ ~RNTupleWriter(). ROOT::Experimental::RNTupleWriter::~RNTupleWriter ; (; ). Definition at line 47 of file RNTupleWriter.cxx. Member Function Documentation. ◆ Append(). std::unique_ptr< ROOT::Experimental::RNTupleWriter > ROOT::Experimental::RNTupleWriter::Append ; (; std::unique_pt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriter.html:4121,schedul,scheduler,4121,doc/master/classROOT_1_1Experimental_1_1RNTupleWriter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriter.html,1,['schedul'],['scheduler']
Energy Efficiency,"nue;; 2493 ; 2494 // Checking for float equality is a bad. We check if the values are; 2495 // negligibly far away from each other, relative to the uncertainty.; 2496 if(std::abs(rrvInAbsReal->getVal() - rrvFitRes->getVal()) > 0.01 * rrvFitRes->getError()) {; 2497 std::stringstream errMsg;; 2498 errMsg << ""RooAbsReal::getPropagatedError(): the parameters of the RooAbsReal don't have""; 2499 << "" the same values as in the fit result! The logic of getPropagatedError is broken in this case."";; 2500 ; 2501 throw std::runtime_error(errMsg.str());; 2502 }; 2503 ; 2504 paramList.add(*rrvInAbsReal);; 2505 }; 2506 ; 2507 std::vector<double> plusVar;; 2508 std::vector<double> minusVar;; 2509 plusVar.reserve(paramList.size());; 2510 minusVar.reserve(paramList.size());; 2511 ; 2512 // Create std::vector of plus,minus variations for each parameter; 2513 TMatrixDSym V(paramList.size() == fr.floatParsFinal().size() ?; 2514 fr.covarianceMatrix() :; 2515 fr.reducedCovarianceMatrix(paramList)) ;; 2516 ; 2517 for (std::size_t ivar=0 ; ivar<paramList.size() ; ivar++) {; 2518 ; 2519 auto& rrv = static_cast<RooRealVar&>(paramList[ivar]);; 2520 ; 2521 double cenVal = rrv.getVal() ;; 2522 double errVal = sqrt(V(ivar,ivar)) ;; 2523 ; 2524 // Make Plus variation; 2525 rrv.setVal(cenVal+errVal) ;; 2526 plusVar.push_back(getVal(nset)) ;; 2527 ; 2528 // Make Minus variation; 2529 rrv.setVal(cenVal-errVal) ;; 2530 minusVar.push_back(getVal(nset)) ;; 2531 ; 2532 rrv.setVal(cenVal) ;; 2533 }; 2534 ; 2535 // Re-evaluate this RooAbsReal with the central parameters just to be; 2536 // extra-safe that a call to `getPropagatedError()` doesn't change any state.; 2537 // It should not be necessary because thanks to the dirty flag propagation; 2538 // the RooAbsReal is re-evaluated anyway the next time getVal() is called.; 2539 // Still there are imaginable corner cases where it would not be triggered,; 2540 // for example if the user changes the RooFit operation more after the error; 2541 // propagation.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:110509,reduce,reducedCovarianceMatrix,110509,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['reduce'],['reducedCovarianceMatrix']
Energy Efficiency,"number of filled bins is returned by; THnSparse::GetNbins(); the bin content for each (linear) bin number can; be retrieved by THnSparse::GetBinContent(linidx, (Int_t*)coord).; After the call, coord will contain the bin coordinate of each axis for the bin; with linear index linidx. A possible call would be; std::cout << hs.GetBinContent(0, coord);; std::cout <<"" is the content of bin [x = "" << coord[0] ""; << "" | y = "" << coord[1] << ""]"" << std::endl;. * Efficiency; TH1 and TH2 are generally faster than THnSparse for one and two dimensional; distributions. THnSparse becomes competitive for a sparsely filled TH3; with large numbers of bins per dimension. The tutorial hist/sparsehist.C; shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins""; starting with a TH3 with 30 bins per dimension. Using a THnSparse for a; one-dimensional histogram is only reasonable if it has a huge number of bins. * Projections; The dimensionality of a THnSparse can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THnSparse. See the Projection() members. To only project parts of the; histogram, call; THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);. * Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THnSparse.html:3072,reduce,reduced,3072,root/html602/THnSparse.html,https://root.cern,https://root.cern/root/html602/THnSparse.html,2,['reduce'],['reduced']
Energy Efficiency,"number of specified fit bins 'get/setBins()'.; # Category dimensions of binned datasets get one bin per defined category; # state; x.setBins(10); y.setBins(10); dh = ROOT.RooDataHist(""dh"", ""binned version of d"", {x, y}, d); dh.Print(""v""); ; yframe = y.frame(Bins=10, Title=""Operations on binned datasets""); dh.plotOn(yframe) # plot projection of 2D binned data on y; ; # Examine the statistics of a binned dataset; print("">> number of bins in dh : "", dh.numEntries()); print("">> sum of weights in dh : "", dh.sum(False)); # accounts for bin volume; print("">> integral over histogram: "", dh.sum(True)); ; # Locate a bin from a set of coordinates and retrieve its properties; x.setVal(0.3); y.setVal(20.5); print("">> retrieving the properties of the bin enclosing coordinate (x,y) = (0.3,20.5) bin center:""); # load bin center coordinates in internal buffer; dh.get({x, y}).Print(""v""); print("" weight = "", dh.weight()) # return weight of last loaded coordinates; ; # Reduce the 2-dimensional binned dataset to a 1-dimensional binned dataset; #; # All reduce() methods are interfaced in RooAbsData. All reduction techniques; # demonstrated on unbinned datasets can be applied to binned datasets as; # well.; print("">> Creating 1-dimensional projection on y of dh for bins with x>0""); dh2 = dh.reduce({y}, ""x>0""); dh2.Print(""v""); ; # Add dh2 to yframe and redraw; dh2.plotOn(yframe, LineColor=""r"", MarkerColor=""r""); ; # Saving and loading from file; # -------------------------------------------------------; ; # Datasets can be persisted with ROOT I/O; print(""\n >> Persisting d via ROOT I/O""); f = ROOT.TFile(""rf402_datahandling.root"", ""RECREATE""); d.Write(); f.ls(); ; # To read back in future session:; # > ROOT.TFile f(""rf402_datahandling.root""); # > d = (ROOT.RooDataSet*) f.FindObject(""d""); ; c = ROOT.TCanvas(""rf402_datahandling"", ""rf402_datahandling"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); yframe.GetYaxis().SetTitleOffset(1.4); yframe.Draw(); ; c.SaveAs(""rf402_datahandling.png""); typeOption",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf402__datahandling_8py.html:4425,reduce,reduce,4425,doc/master/rf402__datahandling_8py.html,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8py.html,1,['reduce'],['reduce']
Energy Efficiency,"number; TStringfOrdinalslave ordinal number; TStringfPackageDirdirectory containing packages and user libs; TProofLockPath*fPackageLockpackage dir locker; TVirtualProofPlayer*fPlayeractual player; TStringfPrefixPrefix identifying the node; TProof*fProofPROOF talking to slave servers; Int_tfProtocolprotocol version number; TQueryResultManager*fQMgrQuery-result manager; TMutex*fQMtxTo protect async msg queue; TStringfQueryDirdirectory containing query results and status; TProofLockPath*fQueryLockquery dir locker; Int_tfQuerySeqNumsequential number of the current or last query; TList*fQueuedMsglist of messages waiting to be processed; Float_tfRealTimereal time spent executing commands; Bool_tfRealTimeLogTRUE if log messages should be send back in real-time; TReaperTimer*fReaperTimerTimer used to control children state; Bool_tfSendLogToMasterOn workers, controls logs sending to master; TStringfServiceservice we are running, either ""proofserv"" or ""proofslave""; TStringfSessionDirdirectory containing session dependent files; TStringfSessionTagtag for the server session; TShutdownTimer*fShutdownTimerTimer used to shutdown out-of-control sessions; TSocket*fSocketsocket connection to client; TStringfTopSessionTagtag for the global session; Int_tfTotSessionsTotal number of PROOF sessions on the cluster ; TStringfUseruser as which we run; TList*fWaitingQuerieslist of TProofQueryResult waiting to be processed; TStringfWorkDirdirectory containing all proof related info; static FILE*fgErrorHandlerFileFile where to log; static Int_tfgLogToSysLog>0 sent to syslog too; static Float_tfgMemHWMThreshold fraction of max for warning and finer monitoring; static Float_tfgMemStopFraction of max for stop processing; static Int_tfgRecursiveKeep track of recursive inputs during processing; static Long_tfgResMemMaxHard limit on the resident memory checked; static TStringfgSysLogEntitylogging entity (<user>:<group>); static TStringfgSysLogServicename of the syslog service (eg: proofm-0, proofw-0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:20018,monitor,monitoring,20018,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,3,['monitor'],['monitoring']
Energy Efficiency,"numbers template on the Engine type.; 52 The API of this class followed that of the class ROOT::Math::Random; 53 It must be implemented using as Engine one of the derived classes of; 54 ROOT::Math::GSLQuasiRandomEngine, like ROOT::Math::GSLQrngSobol; 55 ; 56 @ingroup QuasiRandom; 57 ; 58*/; 59template < class Engine>; 60class QuasiRandom {; 61 ; 62public:; 63 ; 64 ; 65 /**; 66 Create a QuasiRandom generator. Use default engine constructor.; 67 Engine will be initialized via Initialize() function in order to; 68 allocate resources; 69 */; 70 QuasiRandom(unsigned int dimension = 1) {; 71 fEngine.Initialize(dimension);; 72 }; 73 ; 74 ; 75 /**; 76 Create a QuasiRandom generator based on a provided generic engine.; 77 Engine will be initialized via Initialize() function in order to; 78 allocate resources; 79 */; 80 explicit QuasiRandom(const Engine & e, unsigned int dimension = 1) : fEngine(e) {; 81 fEngine.Initialize(dimension);; 82 }; 83 ; 84 /**; 85 Destructor: call Terminate() function of engine to free any; 86 allocated resource; 87 */; 88 ~QuasiRandom() {; 89 fEngine.Terminate();; 90 }; 91 ; 92 /**; 93 Generate next quasi random numbers points; 94 */; 95 bool Next(double * x) {; 96 return fEngine(x);; 97 }; 98 ; 99 /**; 100 Generate next quasi random numbers point (1 - dimension); 101 */; 102 double Next() {; 103 return fEngine();; 104 }; 105 ; 106 /**; 107 Generate quasi random numbers between ]0,1[; 108 0 and 1 are excluded; 109 Function to be compatible with ROOT TRandom compatibility; 110 */; 111 double Rndm() {; 112 return fEngine();; 113 }; 114 ; 115 /**; 116 skip the next n number and jumb directly to the current state + n; 117 */; 118 bool Skip(unsigned int n) {; 119 return fEngine.Skip(n);; 120 }; 121 /**; 122 Generate an array of random numbers between ]0,1[; 123 Function to preserve ROOT Trandom compatibility; 124 The array will be filled as x1,y1,z1,....x2,y2,z2,...; 125 */; 126 bool RndmArray(int n, double * array) {; 127 return fEngine.GenerateArray(ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/QuasiRandom_8h_source.html:2990,allocate,allocated,2990,doc/master/QuasiRandom_8h_source.html,https://root.cern,https://root.cern/doc/master/QuasiRandom_8h_source.html,1,['allocate'],['allocated']
Energy Efficiency,"nvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBranch*TBasket::fBranchPointer to the basket support branch; char*TKey::fBufferObject buffer; TBuffer*TKey::fBufferRefPointer to the TBuffer object; Int_tTBasket::fBufferSizefBuffer length in bytes; TStringTKey::fClassNameObject Class name; char*TBasket::fCompressedBuffer!Temporary place holder for the compressed buffer if needed.; Int_tTBasket::fCompressedSize!Size of the allocated memroy in fCompressedBuffer; Short_tTKey::fCycleCycle number; TDatimeTKey::fDatimeDate/Time of insertion in file; Int_t*TBasket::fDisplacement![fNevBuf] Displacement of entries in fBuffer(TKey); Int_t*TBasket::fEntryOffset[fNevBuf] Offset of entries in fBuffer(TKey); Bool_tTBasket::fHeaderOnlyTrue when only the basket header must be read/written; TString*fInsertQuery!; Short_tTKey::fKeylenNumber of bytes for the key itself; Int_tTBasket::fLastPointer to last used byte in basket; Int_tTKey::fLeftNumber of bytes left in current segment; TDirectory*TKey::fMotherDir! pointer to mother directory; TStringTNamed::fNameobject identifier; Int_tTKey::fNbytesNumber of bytes for the object on file; Int_tTBasket::fNevBufNumber of entries in basket; Int_tTBasket::fNevBufSizeLength in Int_t of fEntryOffset OR fixed length of each entry if fEntryOffset is null!; Int_tTKey::fObjlenLength of uncompressed object in bytes; UShort_tTKey::fPidOffset! Offset to be added to the pid index in this key/buffer. This is actually saved in the high bits of fSeekPdir; TSQLResult**fResultPtr!; TSQLRow**fRowPtr!; Long64_tTKey::fSeekKeyLocation of object on file; Long64_tTKey::fSeekPdirLocation of parent directory on file; TStringTNamed::fTitleobject title; Int_tTKey::fVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBasketSQL(); Default constructor. TBasketSQL(const char* name, const char* title, TBranch* bra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBasketSQL.html:8235,allocate,allocated,8235,root/html528/TBasketSQL.html,https://root.cern,https://root.cern/root/html528/TBasketSQL.html,1,['allocate'],['allocated']
Energy Efficiency,"nvention. The base of all folders is //root. It is visible at the top of the left panel in the browser. The browser shows several folders under //root.; New folders can be added and removed to/from a folder.; 10.2 Why Use Folders?; One reason to use folders is to reduce class dependencies and improve modularity. Each set of data has a producer class and one or many consumer classes. When using folders, the producer class places a pointer to the data into a folder, and the consumer class retrieves a reference to the folder.; The consumer can access the objects in a folder by specifying the path name of the folder.; Here is an example of a folder’s path name:; //root/Event/Hits/TCP; One does not have to specify the full path name. If the partial path name is unique, it will find it; otherwise it will return the first occurrence of the path.; The first diagram shows a system without folders. The objects have pointers to each other to access each other’s data. Pointers are an efficient way to share data between classes. However, a direct pointer creates a direct coupling between classes. This design can become a very tangled web of dependencies in a system with a large number of classes. In the second diagram, a reference to the data is in the folder and the consumers refer to the folder rather than each other to access the data. The naming and search service provided by the ROOT folders hierarchy provides an alternative. It loosely couples the classes and greatly enhances I/O operations. In this way, folders separate the data from the algorithms and greatly improve the modularity of an application by minimizing the class dependencies. In addition, the folder hierarchy creates a picture of the data organization. This is useful when discussing data design issues or when learning the data organization. The example below illustrates this point.; 10.3 How to Use Folders; Using folders means to build a hierarchy of folders, posting the reference to the data in the folder by t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:419557,efficient,efficient,419557,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['efficient'],['efficient']
Energy Efficiency,"o ...Definition RVec.hxx:458; ROOT::Internal::VecOps::SmallVectorTemplateBase< T, true >::destroy_rangestatic void destroy_range(T *, T *)Definition RVec.hxx:435; ROOT::Internal::VecOps::SmallVectorTemplateBase< T, true >::uninitialized_copystatic void uninitialized_copy(It1 I, It1 E, It2 Dest)Copy the range [I, E) onto the uninitialized memory starting with ""Dest"", constructing elements into ...Definition RVec.hxx:449; ROOT::Internal::VecOps::SmallVectorTemplateBaseSmallVectorTemplateBase<TriviallyCopyable = false> - This is where we put method implementations that...Definition RVec.hxx:328; ROOT::Internal::VecOps::SmallVectorTemplateBase::pop_backvoid pop_back()Definition RVec.hxx:378; ROOT::Internal::VecOps::SmallVectorTemplateBase::push_backvoid push_back(T &&Elt)Definition RVec.hxx:370; ROOT::Internal::VecOps::SmallVectorTemplateBase::push_backvoid push_back(const T &Elt)Definition RVec.hxx:362; ROOT::Internal::VecOps::SmallVectorTemplateBase::growvoid grow(size_t MinSize=0)Grow the allocated memory (without initializing new elements), doubling the size of the allocated mem...; ROOT::Internal::VecOps::SmallVectorTemplateBase::uninitialized_movestatic void uninitialized_move(It1 I, It1 E, It2 Dest)Move the range [I, E) into the uninitialized memory starting with ""Dest"", constructing elements as ne...Definition RVec.hxx:343; ROOT::Internal::VecOps::SmallVectorTemplateBase::SmallVectorTemplateBaseSmallVectorTemplateBase(size_t Size)Definition RVec.hxx:330; ROOT::Internal::VecOps::SmallVectorTemplateBase::destroy_rangestatic void destroy_range(T *S, T *E)Definition RVec.hxx:332; ROOT::Internal::VecOps::SmallVectorTemplateBase::uninitialized_copystatic void uninitialized_copy(It1 I, It1 E, It2 Dest)Copy the range [I, E) onto the uninitialized memory starting with ""Dest"", constructing elements as ne...Definition RVec.hxx:351; ROOT::Internal::VecOps::SmallVectorTemplateCommonThis is the part of SmallVectorTemplateBase which does not depend on whether the type T is a PO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:138759,allocate,allocated,138759,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,4,['allocate'],['allocated']
Energy Efficiency,"o 0 (old). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addobj parameter in; the case of new-style branches. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if the class can not be split. TBranch* BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); Create a new TTree BranchObject. Build a TBranchObject for an object of class classname.; addobj is the address of a pointer to an object of class classname.; IMPORTANT: classname must derive from TObject.; The class dictionary must be available (ClassDef in class header). This option requires access to the library where the corresponding class; is defined. Accessing one single data member in the object implies; reading the full object.; See the next Branch constructor for a more efficient storage; in case the entry consists of arrays of identical objects. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:47881,efficient,efficient,47881,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,6,['efficient'],['efficient']
Energy Efficiency,"o color nodes; TStructViewerGUI*fGUIPointer to GUI class; TObjArrayfLevelArrayArray with pointers to nodes on each level; TExMapfLevelMembersCountContains number of objects on each level; TExMapfLevelSizeContains total size in bytes of a level; void*fPointerMain pointer to represented object; TClass*fPointerClassTClass of a main pointer; TExMapfPointersMap of pointer to avoid circulation; TStructNode*fTopNodeMaster node for fPointer. Class Charts. Inheritance Chart:. TObject. ←; TStructViewer. Function documentation; TStructViewer(void* ptr = __null, const char* clname = __null); Default constructor. An argument ""ptr"" is a main pointer of type ""clname"", which should be shown in the viewer. ~TStructViewer(); Destructor. Clean all object after closing the viewer. void AddNode(TStructNode* node, ULong_t size); Find list with nodes on specified level and add node to this list and increment list of sizes and list of members. void CountMembers(TClass* cl, TStructNode* parent, void* pointer); Count allocated memory, increase member counters, find child nodes. void Draw(Option_t* option = """"); Draw object if there is valid pointer. TCanvas* GetCanvas(); Returns canvas used to keep TGeoVolumes. TGMainFrame* GetFrame(); Returns pointer to main window. void* GetPointer() const; Return main pointer. TExMap GetLevelMembersCount() const; Returns TExMap with pairs <level number, number of objects>. TExMap GetLevelSize() const; Returns TExMap with pairs <level number, size of level in bytes>. Bool_t GetLinksVisibility() const; Get visibility of links between objects. void Prepare(); Create top node and find all member nodes. void Reset(); Deleting nodes, maps and array. void SetColor(TString name, Int_t color); Sets color for the class ""name"" to color ""color"". void SetLinksVisibility(Bool_t val); ISets links visibility. void SetPointer(void* ptr, const char* clname = __null); Set main pointer of class ""clname"". TColor GetColor(const char* typeName); Returns color associated with typ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStructViewer.html:8412,allocate,allocated,8412,root/html602/TStructViewer.html,https://root.cern,https://root.cern/root/html602/TStructViewer.html,2,['allocate'],['allocated']
Energy Efficiency,"o do this round.; 2770 } else if (element->IsaPointer()) {; 2771 elementName.Form(""*%s"",element->GetFullName());; 2772 insp.Inspect(fClass, insp.GetParent(), elementName.Data(), eaddr, isTransient);; 2773 } else {; 2774 insp.Inspect(fClass, insp.GetParent(), element->GetFullName(), eaddr, isTransient);; 2775 Int_t etype = element->GetType();; 2776 switch(etype) {; 2777 case kObject:; 2778 case kAny:; 2779 case kTObject:; 2780 case kTString:; 2781 case kTNamed:; 2782 case kSTL:; 2783 {; 2784 TClass *ecl = element->GetClassPointer();; 2785 if (ecl && (fClass!=ecl /* This happens 'artificially for stl container see the use of ""This"" */)) {; 2786 insp.InspectMember(ecl, eaddr, TString(element->GetName()) + ""."", isTransient);; 2787 }; 2788 break;; 2789 }; 2790 } // switch(etype); 2791 } // if IsaPointer(); 2792 } // Loop over elements; 2793 ; 2794 // And now do the base classes; 2795 next.Reset();; 2796 element = (TStreamerElement*) next();; 2797 for (; element; element = (TStreamerElement*) next()) {; 2798 if (element->IsBase()) {; 2799 // Skip elements which have not been allocated memory.; 2800 if (element->GetOffset() == kMissing) {; 2801 continue;; 2802 }; 2803 ; 2804 char* eaddr = ((char*)obj) + element->GetOffset();; 2805 ; 2806 TClass *ecl = element->GetClassPointer();; 2807 if (ecl) {; 2808 ecl->CallShowMembers(eaddr, insp, isTransient);; 2809 }; 2810 } // If is a abse; 2811 } // Loop over elements; 2812}; 2813 ; 2814////////////////////////////////////////////////////////////////////////////////; 2815/// Make a clone of an object using the Streamer facility.; 2816/// If newname is specified, this will be the name of the new object.; 2817 ; 2818TObject *TStreamerInfo::Clone(const char *newname) const; 2819{; 2820 TStreamerInfo *newinfo = (TStreamerInfo*)TNamed::Clone(newname);; 2821 if (newname && newname[0] && fName != newname) {; 2822 TObjArray *newelems = newinfo->GetElements();; 2823 Int_t ndata = newelems->GetEntriesFast();; 2824 for(Int_t i = 0; i < ndata;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:111411,allocate,allocated,111411,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"o end_point.; If end_point is less than 0, distance to the end is returned. Bool_t GoToVertex(TEveVectorD& v, TEveVectorD& p); Propagate particle with momentum p to vertex v. Bool_t GoToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate particle with momentum p to line with start point s and vector r to the second point. Bool_t GoToVertex(TEveVectorF& v, TEveVectorF& p); TEveVectorF wrapper. Bool_t GoToLineSegment(const TEveVectorF& s, const TEveVectorF& r, TEveVectorF& p); TEveVectorF wrapper. void GoToBounds(TEveVectorD& p); Propagate particle to bounds.; Return TRUE if hit bounds. void GoToBounds(TEveVectorF& p); TEveVectorF wrapper. void Update(const TEveVector4D& v, const TEveVectorD& p, Bool_t full_update = kFALSE, Bool_t enforce_max_step = kFALSE); Update helix / B-field projection state. void Step(const TEveVector4D& v, const TEveVectorD& p, TEveVector4D& vOut, TEveVectorD& pOut); Wrapper to step helix. void LoopToBounds(TEveVectorD& p); Propagate charged particle with momentum p to bounds.; It is expected that Update() with full-update was called before. Bool_t LoopToVertex(TEveVectorD& v, TEveVectorD& p); Propagate charged particle with momentum p to vertex v.; It is expected that Update() with full-update was called before. Bool_t LoopToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate charged particle with momentum p to line segment with point s and vector r to the second point.; It is expected that Update() with full-update was called before. Returns kFALSE if hits bounds. void DistributeOffset(const TEveVectorD& off, Int_t first_point, Int_t np, TEveVectorD& p); Distribute offset between first and last point index and rotate; momentum. Bool_t LineToVertex(TEveVectorD& v); Propagate neutral particle to vertex v. void LineToBounds(TEveVectorD& p); Propagatate neutral particle with momentum p to bounds. Bool_t HelixIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVecto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveTrackPropagator.html:28327,charge,charged,28327,root/html534/TEveTrackPropagator.html,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html,3,['charge'],['charged']
Energy Efficiency,"o output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsData.html:16698,reduce,reduce,16698,root/html528/RooAbsData.html,https://root.cern,https://root.cern/root/html528/RooAbsData.html,6,['reduce'],['reduce']
Energy Efficiency,"o that these can be passed forward again as well at the call site, if necessary. ; Definition at line 231 of file IFunction.h. ◆ FdF(). template<class T > . virtual void ROOT::Math::IGradientFunctionMultiDimTempl< T >::FdF ; (; const T * ; x, . T & ; f, . T * ; df . ); const. inlinevirtual . Optimized method to evaluate at the same time the function value and derivative at a point x. ; Often both value and derivatives are needed and it is often more efficient to compute them at the same time. Derived class should implement this method if performances play an important role and if it is faster to evaluate value and derivative at the same time ; Definition at line 202 of file IFunction.h. ◆ Gradient(). template<class T > . virtual void ROOT::Math::IGradientFunctionMultiDimTempl< T >::Gradient ; (; const T * ; x, . T * ; grad . ); const. inlinevirtual . Evaluate all the vector of function derivatives (gradient) at a point x. ; Derived classes must re-implement it if more efficient than evaluating one at a time ; Definition at line 177 of file IFunction.h. ◆ GradientWithPrevResult(). template<class T > . virtual void ROOT::Math::IGradientFunctionMultiDimTempl< T >::GradientWithPrevResult ; (; const T * ; x, . T * ; grad, . T * ; previous_grad, . T * ; previous_g2, . T * ; previous_gstep . ); const. inlinevirtual . In some cases, the gradient algorithm will use information from the previous step, these can be passed in with this overload. ; The previous_* arrays can also be used to return second derivative and step size so that these can be passed forward again as well at the call site, if necessary. ; Definition at line 188 of file IFunction.h. ◆ HasGradient(). template<class T > . bool ROOT::Math::IGradientFunctionMultiDimTempl< T >::HasGradient ; (; ); const. inlinevirtual . Reimplemented from ROOT::Math::IBaseFunctionMultiDimTempl< T >.; Definition at line 220 of file IFunction.h. ◆ NDim(). template<class T > . virtual unsigned int ROOT::Math::IBaseFunctionMultiDimTem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IGradientFunctionMultiDimTempl.html:6951,efficient,efficient,6951,doc/master/classROOT_1_1Math_1_1IGradientFunctionMultiDimTempl.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IGradientFunctionMultiDimTempl.html,1,['efficient'],['efficient']
Energy Efficiency,"o the TBranchRef basket. When the Tree header is saved (via TTree::Write), the branch is saved keeping the information with the pointers to the branches having referenced objects. ; Definition at line 2328 of file TTree.cxx. ◆ Bronch(). TBranch * TTree::Bronch ; (; const char * ; name, . const char * ; classname, . void * ; addr, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99 . ). virtual . Create a new TTree BranchElement. . WARNING about this new function; This function is designed to replace the internal implementation of the old TTree::Branch (whose implementation has been moved to BranchOld).; NOTE: The 'Bronch' method supports only one possible calls signature (where the object type has to be specified explicitly and the address must be the address of a pointer). For more flexibility use 'Branch'. Use Bronch only in (rare) cases (likely to be legacy cases) where both the new and old implementation of Branch needs to be used at the same time.; This function is far more powerful than the old Branch function. It supports the full C++, including STL and has the same behaviour in split or non-split mode. classname does not have to derive from TObject. The function is based on the new TStreamerInfo.; Build a TBranchElement for an object of class classname.; addr is the address of a pointer to an object of class classname. The class dictionary must be available (ClassDef in class header).; Note: See the comments in TBranchElement::SetAddress() for a more detailed discussion of the meaning of the addr parameter.; This option requires access to the library where the corresponding class is defined. Accessing one single data member in the object implies reading the full object.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file; IMPORTANT NOTE about branch names:; And in general, in case two or more master branches contain subbranches with identical names, one must add a ""."" (dot) character at th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:95689,power,powerful,95689,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['power'],['powerful']
Energy Efficiency,"o the corresponding column page buffers. Writing of the buffers to storage is deferred and can be triggered by FlushCluster() or by destructing the context. On I/O errors, an exception is thrown.; Instances of this class are not meant to be used in isolation and can be created from an RNTupleParallelWriter. For sequential writing, please refer to RNTupleWriter. ; Definition at line 51 of file RNTupleFillContext.hxx. Public Member Functions;  ~RNTupleFillContext ();  ; void CommitStagedClusters ();  Logically append staged clusters to the RNTuple. ;  ; std::unique_ptr< REntry > CreateEntry ();  ; void EnableMetrics ();  ; void EnableStagedClusterCommitting (bool val=true);  ; std::size_t Fill (REntry &entry);  Fill an entry into this context. ;  ; void FillNoFlush (REntry &entry, RNTupleFillStatus &status);  Fill an entry into this context, but don't commit the cluster. ;  ; void FlushCluster ();  Flush so far filled entries to storage. ;  ; void FlushColumns ();  Flush column data, preparing for CommitCluster or to reduce memory usage. ;  ; NTupleSize_t GetLastFlushed () const;  Return the entry number that was last flushed in a cluster. ;  ; const Detail::RNTupleMetrics & GetMetrics () const;  ; const RNTupleModel & GetModel () const;  ; NTupleSize_t GetNEntries () const;  Return the number of entries filled so far. ;  ; bool IsStagedClusterCommittingEnabled () const;  . Private Member Functions;  RNTupleFillContext (const RNTupleFillContext &)=delete;  ;  RNTupleFillContext (std::unique_ptr< RNTupleModel > model, std::unique_ptr< Internal::RPageSink > sink);  ; RNTupleFillContext & operator= (const RNTupleFillContext &)=delete;  . Private Attributes; NTupleSize_t fLastFlushed = 0;  ; std::size_t fMaxUnzippedClusterSize;  Limit for committing cluster no matter the other tunables. ;  ; Detail::RNTupleMetrics fMetrics;  ; std::unique_ptr< RNTupleModel > fModel;  Needs to be destructed before fSink. ;  ; std::uint64_t fNBytesFilled = 0;  The total number of bytes fill",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleFillContext.html:1708,reduce,reduce,1708,doc/master/classROOT_1_1Experimental_1_1RNTupleFillContext.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleFillContext.html,1,['reduce'],['reduce']
Energy Efficiency,"o the current NT.; If nn>0 the line is clipped as a line.; If nn<0 the line is clipped as a fill area. void FontEncode(); Font encoding. void LineTo(Double_t x, Double_t y); Draw a line to a new position. void MoveTo(Double_t x, Double_t y); Move to a new position. void NewObject(Int_t n); Create a new object in the PDF file. void NewPage(); Start a new PDF page. void Off(); Deactivate an already open PDF file. void On(); Activate an already open PDF file. void Open(const char* filename, Int_t type = -111); Open a PDF file. void PatternEncode(); Patterns encoding. void PrintStr(const char* string = """"); Output the string str in the output buffer. void PrintFast(Int_t nch, const char* string = """"); Fast version of Print. void Range(Float_t xrange, Float_t yrange); Set the range for the paper in centimetres. void SetColor(Int_t color = 1); Set color with its color index. void SetColor(Float_t r, Float_t g, Float_t b); Set color with its R G B components. r: % of red in [0,1]; g: % of green in [0,1]; b: % of blue in [0,1]. void SetFillColor(Color_t cindex = 1); Set color index for fill areas. void SetFillPatterns(Int_t ipat, Int_t color); Set the fill patterns (1 to 25) for fill areas. void SetLineColor(Color_t cindex = 1); Set color index for lines. void SetLineStyle(Style_t linestyle = 1); Change the line style. linestyle = 2 dashed; = 3 dotted; = 4 dash-dotted; = else solid (1 in is used most of the time). void SetLineWidth(Width_t linewidth = 1); Change the line width. void SetMarkerColor(Color_t cindex = 1); Set color index for markers. void SetTextColor(Color_t cindex = 1); Set color index for text. void Text(Double_t x, Double_t y, const char* string); Draw text. xx: x position of the text; yy: y position of the text; chars: text to be drawn. void TextNDC(Double_t u, Double_t v, const char* string); Write a string of characters in NDC. Double_t UtoPDF(Double_t u); Convert U from NDC coordinate to PDF. Double_t VtoPDF(Double_t v); Convert V from NDC coordinate to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPDF.html:16461,green,green,16461,root/html528/TPDF.html,https://root.cern,https://root.cern/root/html528/TPDF.html,3,['green'],['green']
Energy Efficiency,"o times the expression) Need to check whether creating a temporary object with the expression result (like in op: A += A * B ) ;  CPolar2DClass describing a polar 2D coordinate system based on r and phi Phi is restricted to be in the range [-PI,PI) ;  CPolar3DClass describing a polar coordinate system based on r, theta and phi Phi is restricted to be in the range [-PI,PI) ;  CPolynomialParametric Function class describing polynomials of order n ;  CPositionVector2DClass describing a generic position vector (point) in 2 dimensions ;  CPositionVector3DClass describing a generic position vector (point) in 3 dimensions ;  CPtEtaPhiE4DClass describing a 4D cylindrical coordinate system using Pt , Phi, Eta and E (or rho, phi, eta , T) The metric used is (-,-,-,+) ;  CPtEtaPhiM4DClass describing a 4D cylindrical coordinate system using Pt , Phi, Eta and M (mass) The metric used is (-,-,-,+) ;  CPxPyPzE4DClass describing a 4D cartesian coordinate system (x, y, z, t coordinates) or momentum-energy vectors stored as (Px, Py, Pz, E) ;  CPxPyPzM4DClass describing a 4D coordinate system or momentum-energy vectors stored as (Px, Py, Pz, M) ;  CQuasiRandomUser class for MathMore random numbers template on the Engine type ;  CQuaternionRotation class with the (3D) rotation represented by a unit quaternion (u, i, j, k) ;  CRandomDocumentation for the Random class ;  CRandomBaseEngine;  CRandomFunctions;  CRandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >Specialized implementation of the Random functions based on the GSL library ;  CRandomFunctionsImplDefinition of the generic impelmentation class for the RandomFunctions ;  CRandomFunctionsImpl< TRandomEngine >Implementation class for the RandomFunction for all the engined that derives from TRandomEngine class, which defines an interface which has TRandomEngine::Rndm() In this way we can have a common implementation for the RandomFunctions ;  CRetrieveMatrixStructure for getting sub matrices We have different cases according ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:42092,energy,energy,42092,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['energy'],['energy']
Energy Efficiency,"o times the expression) Need to check whether creating a temporary object with the expression result (like in op: A += A * B ) ;  CPolar2DClass describing a polar 2D coordinate system based on r and phi Phi is restricted to be in the range [-PI,PI) ;  CPolar3DClass describing a polar coordinate system based on r, theta and phi Phi is restricted to be in the range [-PI,PI) ;  CPolynomialParametric Function class describing polynomials of order n ;  CPositionVector2DClass describing a generic position vector (point) in 2 dimensions ;  CPositionVector3DClass describing a generic position vector (point) in 3 dimensions ;  CPtEtaPhiE4DClass describing a 4D cylindrical coordinate system using Pt , Phi, Eta and E (or rho, phi, eta , T) The metric used is (-,-,-,+) ;  CPtEtaPhiM4DClass describing a 4D cylindrical coordinate system using Pt , Phi, Eta and M (mass) The metric used is (-,-,-,+) ;  CPxPyPzE4DClass describing a 4D cartesian coordinate system (x, y, z, t coordinates) or momentum-energy vectors stored as (Px, Py, Pz, E) ;  CPxPyPzM4DClass describing a 4D coordinate system or momentum-energy vectors stored as (Px, Py, Pz, M) ;  CQuasiRandomUser class for MathMore random numbers template on the Engine type ;  CQuaternionRotation class with the (3D) rotation represented by a unit quaternion (u, i, j, k) ;  CRandomDocumentation for the Random class ;  CRandomFunctions;  CRandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >Specialized implementation of the Random functions based on the GSL library ;  CRandomFunctionsImplDefinition of the generic impelmentation class for the RandomFunctions ;  CRandomFunctionsImpl< TRandomEngine >Implementation class for the RandomFunction for all the engined that derives from TRandomEngine class, which defines an interface which has TRandomEngine::Rndm() In this way we can have a common implementation for the RandomFunctions ;  CRetrieveMatrixStructure for getting sub matrices We have different cases according to the matrix repres",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:46331,energy,energy,46331,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,6,['energy'],['energy']
Energy Efficiency,"o use ROOT trees and ntuples. . Files; file  basic.C;   Read data from an ascii file and create a root file with an histogram and an ntuple. ;  ; file  basic2.C;   Create can ntuple reading data from an ascii file. ;  ; file  bill.C;   Benchmark comparing row-wise and column-wise storage performance ;  ; file  cernbuild.C;   Read data (CERN staff) from an ascii file and create a root file with a Tree. ;  ; file  cernstaff.C;   Playing with a Tree containing variables of type character ;  ; file  circular.C;   Example of a circular Tree ;  ; file  clonesA_Event.C;  Example to write & read a Tree built with a complex class inheritance tree. ;  ; file  copytree.C;   Copy a subset of a Tree to a new Tree ;  ; file  copytree2.C;   Copy a subset of a Tree to a new Tree, one branch in a separate file. ;  ; file  copytree3.C;   Example of Root macro to copy a subset of a Tree to a new Tree, selecting entries. ;  ; file  drawsparse.C;   Convert a THnSparse to a TTree using efficient iteration through the THnSparse and draw a THnSparse using TParallelCoord. ;  ; file  h1analysis.C;   Example of analysis class for the H1 data. ;  ; file  h1analysisProxy.C;  Example of analysis class for the H1 data using code generated by MakeProxy. ;  ; file  h1analysisTreeReader.C;  H1 analysis example expressed in terms of TTreeReader (see h1analysis.C). ;  ; file  h1chain.C;   Creates a TChain to be used by the h1analysis.C class the symbol H1 must point to a directory where the H1 data sets have been installed. ;  ; file  hsimpleProxy.C;   Used by hsimpleProxyDriver.C. ;  ; file  hsimpleProxyDriver.C;   This is the driver of the hsimpleProxy example. ;  ; file  hsimpleReader.C;   TTreeReader simplest example. ;  ; file  htest.C;   Save histograms in Tree branches ;  ; file  hvector.C;   Write and read STL vectors in a tree. ;  ; file  jets.C;  Usage of a Tree using the JetEvent class. ;  ; file  ntuple1.C;   Simple tree analysis. ;  ; file  parallelcoord.C;   Script illustrating the use o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__tree.html:1155,efficient,efficient,1155,doc/master/group__tutorial__tree.html,https://root.cern,https://root.cern/doc/master/group__tutorial__tree.html,1,['efficient'],['efficient']
Energy Efficiency,"o use the 'branchname' as if it was a data member; protection against array out-of-bound; ability to use the branch data as object (when the user code is available). For example with Event.root, if Double_t somepx = fTracks.fPx[2];; double; is executed by one of the method of the skeleton, somepx will be updated with the current value of fPx of the 3rd track.; Both macrofilename and the optional cutfilename are expected to be the name of source files which contain at least a free standing function with the signature: x_t macrofilename(); // i.e function with the same name as the file; and y_t cutfilename(); // i.e function with the same name as the file; x_t and y_t needs to be types that can convert respectively to a double and a bool (because the skeleton uses: if (cutfilename()) htemp->Fill(macrofilename());; This 2 functions are run in a context such that the branch names are available as local variables of the correct (read-only) type.; Note that if you use the same 'variable' twice, it is more efficient to 'cache' the value. For example Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; int; nconst Int_t nDefinition legend1.C:16; is more efficient than if (fEventNumber<10 || fEventNumber>10); Access to TClonesArray.; If a branch (or member) is a TClonesArray (let's say fTracks), you can access the TClonesArray itself by using ->: fTracks->GetLast();; However this will load the full TClonesArray object and its content. To quickly read the size of the TClonesArray use (note the dot): fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been split. To access the content of the TClonesArray, use the [] operator: float px = fTracks[i].fPx; // fPx of the i-th track; Warning:; The variable actually use for access are 'wrapper' around the real data type (to add autoload for example) and hence getting to the data involves the implicit call to a C++ conversion operator. This conversion is automatic in most case. How",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePlayer.html:33558,efficient,efficient,33558,doc/master/classTTreePlayer.html,https://root.cern,https://root.cern/doc/master/classTTreePlayer.html,1,['efficient'],['efficient']
Energy Efficiency,"o, then the caller has allocated a branch; 4887/// object and is asking us to use it. The caller owns it; 4888/// and must delete it when it is no longer needed.; 4889///; 4890/// Example:; 4891/// ~~~ {.cpp}; 4892/// Event* event = new Event();; 4893/// branch->SetAddress(&event);; 4894/// ... Do some work.; 4895/// delete event;; 4896/// event = 0;; 4897/// ~~~; 4898/// These rules affect users of TTree::Branch(),; 4899/// TTree::SetBranchAddress(), and TChain::SetBranchAddress(); 4900/// as well because those routines call this one.; 4901///; 4902/// An example of a tree with branches with objects allocated; 4903/// and owned by us:; 4904/// ~~~ {.cpp}; 4905/// TFile* f1 = new TFile(""myfile_original.root"");; 4906/// TTree* t1 = (TTree*) f->Get(""MyTree"");; 4907/// TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; 4908/// TTree* t2 = t1->Clone(0);; 4909/// for (Int_t i = 0; i < 10; ++i) {; 4910/// t1->GetEntry(i);; 4911/// t2->Fill();; 4912/// }; 4913/// t2->Write(); 4914/// delete f2;; 4915/// f2 = 0;; 4916/// delete f1;; 4917/// f1 = 0;; 4918/// ~~~; 4919/// An example of a branch with an object allocated by us,; 4920/// but owned by the caller:; 4921/// ~~~ {.cpp}; 4922/// TFile* f = new TFile(""myfile.root"", ""recreate"");; 4923/// TTree* t = new TTree(""t"", ""A test tree.""); 4924/// Event* event = 0;; 4925/// TBranchElement* br = t->Branch(""event."", &event);; 4926/// for (Int_t i = 0; i < 10; ++i) {; 4927/// ... Fill event with meaningful data in some way.; 4928/// t->Fill();; 4929/// }; 4930/// t->Write();; 4931/// delete event;; 4932/// event = 0;; 4933/// delete f;; 4934/// f = 0;; 4935/// ~~~; 4936/// Notice that the only difference between this example; 4937/// and the following example is that the event pointer; 4938/// is zero when the branch is created.; 4939///; 4940/// An example of a branch with an object allocated and; 4941/// owned by the caller:; 4942/// ~~~ {.cpp}; 4943/// TFile* f = new TFile(""myfile.root"", ""recreate"");; 4944/// TTree* t = new",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:181814,allocate,allocated,181814,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"oAbsArg& other); Equality operator when comparing to another RooAbsArg.; Only functional when the other arg is a RooAbsReal. TString getTitle(Bool_t appendUnit = kFALSE) const; Return this variable's title string. If appendUnit is true and; this variable has units, also append a string "" (<unit>)"". Double_t getVal(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Implements the actual analy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsReal.html:32977,efficient,efficient,32977,root/html528/RooAbsReal.html,https://root.cern,https://root.cern/root/html528/RooAbsReal.html,1,['efficient'],['efficient']
Energy Efficiency,"oAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); voidcacheValidEntries(); Int_tcalcTreeIndex() const; voidcalculatePartialBinVolume(const RooArgSet& dimSet) const; voidcheckBinBounds() const; Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidimportDHistSet(const RooArgList& vars, RooCategory& indexCat, map<std::string,RooDataHist*> dmap, Double_t initWgt); voidimportTH1(const RooArgList& vars, TH1& histo, Double_t initWgt, Bool_t doDensityCorrection); voidimportTH1Set(const RooArgList& vars, RooCategory& indexCat, map<std::string,TH1*> hmap, Double_t initWgt, Bool_t doDensityCorrection); voidinitialize(const char* binningName = 0, Bool_t fillTree = kTRUE); Double_tinterpolateDim(RooRealVar& dim, const RooAbsBinning* binning, Double_t xval, Int_t intOrder, Bool_t correctForBinSize, Bool_t cdfBoundaries); voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); voidRooDirItem::removeFromDir(TObject* obj); virtual voidRooAbsData::resetCache(); voidsetAllWeights(Double_t value); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataHist.html:16792,reduce,reduceEng,16792,root/html534/RooDataHist.html,https://root.cern,https://root.cern/root/html534/RooDataHist.html,1,['reduce'],['reduceEng']
Energy Efficiency,"oAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); voidcacheValidEntries(); Int_tcalcTreeIndex() const; voidcalculatePartialBinVolume(const RooArgSet& dimSet) const; Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidimportDHistSet(const RooArgList& vars, RooCategory& indexCat, map<std::string,RooDataHist*> dmap, Double_t initWgt); voidimportTH1(const RooArgList& vars, TH1& histo, Double_t initWgt, Bool_t doDensityCorrection); voidimportTH1Set(const RooArgList& vars, RooCategory& indexCat, map<std::string,TH1*> hmap, Double_t initWgt, Bool_t doDensityCorrection); voidinitialize(const char* binningName = 0, Bool_t fillTree = kTRUE); Double_tinterpolateDim(RooRealVar& dim, const RooAbsBinning* binning, Double_t xval, Int_t intOrder, Bool_t correctForBinSize, Bool_t cdfBoundaries); voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); voidRooDirItem::removeFromDir(TObject* obj); virtual voidRooAbsData::resetCache(); voidsetAllWeights(Double_t value); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDataHist.html:15734,reduce,reduceEng,15734,root/html528/RooDataHist.html,https://root.cern,https://root.cern/root/html528/RooDataHist.html,3,['reduce'],['reduceEng']
Energy Efficiency,"oAbsData::reduce() wrapper function, which uses this constructor, is the most convenient way to create a subset of an existing data ; Definition at line 539 of file RooDataSet.cxx. ◆ RooDataSet() [4/5]. RooDataSet::RooDataSet ; (; RooStringView ; name, . RooStringView ; title, . RooDataSet * ; dset, . const RooArgSet & ; vars, . const RooFormulaVar & ; cutVar, . const char * ; wgtVarName = nullptr . ). Constructor of a data set from (part of) an existing data set. ; The dimensions of the data set are defined by the 'vars' RooArgSet, which can be identical to 'dset' dimensions, or a subset thereof. The 'cutVar' formula variable is used to select the subset of data points to be copied. For subsets without selection on the data points, or involving cuts operating exclusively and directly on the data set dimensions, the equivalent constructor with a string based cut expression is recommended.; For most uses the RooAbsData::reduce() wrapper function, which uses this constructor, is the most convenient way to create a subset of an existing data ; Definition at line 594 of file RooDataSet.cxx. ◆ RooDataSet() [5/5]. RooDataSet::RooDataSet ; (; RooDataSet const & ; other, . const char * ; newname = nullptr . ). Copy constructor. ; Definition at line 601 of file RooDataSet.cxx. ◆ ~RooDataSet(). RooDataSet::~RooDataSet ; (; ). override . Destructor. ; Definition at line 725 of file RooDataSet.cxx. Member Function Documentation. ◆ add() [1/3]. void RooDataSet::add ; (; const RooArgSet & ; data, . double ; wgt, . double ; wgtError . ). Add one ore more rows of data. ; Add a data point, with its coordinates specified in the 'data' argset, to the data set.; Any variables present in 'data' but not in the dataset will be silently ignored. Parameters. [in]dataData point. ; [in]wgtEvent weight. Defaults to 1. The current value of the weight variable is ignored. . NoteTo obtain weighted events, a variable must be designated WeightVar in the constructor. ; Parameters. [in]wgtErrorOption",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataSet.html:41760,reduce,reduce,41760,doc/master/classRooDataSet.html,https://root.cern,https://root.cern/doc/master/classRooDataSet.html,1,['reduce'],['reduce']
Energy Efficiency,"oFlush(REntry &entry, RNTupleFillStatus &status)Fill an entry into this context, but don't commit the cluster.Definition RNTupleFillContext.hxx:93; ROOT::Experimental::RNTupleFillContext::Fillstd::size_t Fill(REntry &entry)Fill an entry into this context.Definition RNTupleFillContext.hxx:111; ROOT::Experimental::RNTupleFillContext::fModelstd::unique_ptr< RNTupleModel > fModelNeeds to be destructed before fSink.Definition RNTupleFillContext.hxx:58; ROOT::Experimental::RNTupleFillContext::GetNEntriesNTupleSize_t GetNEntries() constReturn the number of entries filled so far.Definition RNTupleFillContext.hxx:133; ROOT::Experimental::RNTupleFillContext::CreateEntrystd::unique_ptr< REntry > CreateEntry()Definition RNTupleFillContext.hxx:128; ROOT::Experimental::RNTupleFillContext::GetLastFlushedNTupleSize_t GetLastFlushed() constReturn the entry number that was last flushed in a cluster.Definition RNTupleFillContext.hxx:131; ROOT::Experimental::RNTupleFillContext::FlushColumnsvoid FlushColumns()Flush column data, preparing for CommitCluster or to reduce memory usage.Definition RNTupleFillContext.cxx:58; ROOT::Experimental::RNTupleFillContext::fSinkstd::unique_ptr< Internal::RPageSink > fSinkDefinition RNTupleFillContext.hxx:56; ROOT::Experimental::RNTupleFillStatusA status object after filling an entry.Definition RNTupleFillStatus.hxx:36; ROOT::Experimental::RNTupleModel::RUpdaterA model is usually immutable after passing it to an RNTupleWriter.Definition RNTupleModel.hxx:162; ROOT::Experimental::RNTupleModelThe RNTupleModel encapulates the schema of an ntuple.Definition RNTupleModel.hxx:136; ROOT::Experimental::RNTupleWriteOptionsCommon user-tunable settings for storing ntuples.Definition RNTupleWriteOptions.hxx:48; ROOT::Experimental::RNTupleWriterAn RNTuple that gets filled with entries (data) and writes them to storage.Definition RNTupleWriter.hxx:60; ROOT::Experimental::RNTupleWriter::FlushClustervoid FlushCluster()Flush so far filled entries to storage.Definition RNT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleWriter_8hxx_source.html:10201,reduce,reduce,10201,doc/master/RNTupleWriter_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleWriter_8hxx_source.html,1,['reduce'],['reduce']
Energy Efficiency,"oGaussian::g(x,m,s) --> g; e.g. {x(-10,10),s} --> {x,s} . Definition at line 882 of file RooFactoryWSTool.cxx. ◆ processListExpression(). string RooFactoryWSTool::processListExpression ; (; const char * ; arg). protected . Process a list of high-level expression. ; The returned string a the reduced expression list where all inline object creations have been executed and substituted with the name of the created object. E.g. {x(-10,10),s} --> {x,s} . Definition at line 1118 of file RooFactoryWSTool.cxx. ◆ processMetaArg(). std::string RooFactoryWSTool::processMetaArg ; (; std::string & ; func, . std::vector< std::string > & ; args . ). protected . Concatenate list of args into comma separated string. ; Definition at line 1385 of file RooFactoryWSTool.cxx. ◆ processSingleExpression(). std::string RooFactoryWSTool::processSingleExpression ; (; const char * ; arg). protected . Process a single high-level expression. ; The returned string a the reduced expression where all inline object creations have been executed and substituted with the name of the created object. e.g. RooGaussian::g(x,m,s) --> g; e.g. x[-10,10] --> x . Definition at line 972 of file RooFactoryWSTool.cxx. ◆ prod(). RooProdPdf * RooFactoryWSTool::prod ; (; const char * ; objName, . const char * ; pdfList . ). Definition at line 560 of file RooFactoryWSTool.cxx. ◆ prodfunc(). RooProduct * RooFactoryWSTool::prodfunc ; (; const char * ; objName, . const char * ; pdfList . ). Definition at line 726 of file RooFactoryWSTool.cxx. ◆ registerSpecial(). void RooFactoryWSTool::registerSpecial ; (; const char * ; typeName, . RooFactoryWSTool::IFace * ; iface . ). static . Register foreign special objects in factory. ; Definition at line 1891 of file RooFactoryWSTool.cxx. ◆ resolveClassName(). TClass * RooFactoryWSTool::resolveClassName ; (; const char * ; className). protected . Definition at line 1205 of file RooFactoryWSTool.cxx. ◆ setAutoClassNamePostFix(). void RooFactoryWSTool::setAutoClassNamePostFix ; (; con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFactoryWSTool.html:41041,reduce,reduced,41041,doc/master/classRooFactoryWSTool.html,https://root.cern,https://root.cern/doc/master/classRooFactoryWSTool.html,1,['reduce'],['reduced']
Energy Efficiency,"oHistFunc.cxx. ◆ ~RooHistFunc(). RooHistFunc::~RooHistFunc ; (; ). override . Definition at line 158 of file RooHistFunc.cxx. Member Function Documentation. ◆ analyticalIntegral(). double RooHistFunc::analyticalIntegral ; (; Int_t ; code, . const char * ; rangeName = nullptr . ); const. overridevirtual . Return integral identified by 'code'. ; The actual integration is deferred to RooDataHist::sum() which implements partial or complete summation over the histograms contents ; Reimplemented from RooAbsReal.; Definition at line 315 of file RooHistFunc.cxx. ◆ areIdentical(). bool RooHistFunc::areIdentical ; (; const RooDataHist & ; dh1, . const RooDataHist & ; dh2 . ). protected . Definition at line 497 of file RooHistFunc.cxx. ◆ binBoundaries(). std::list< double > * RooHistFunc::binBoundaries ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ; Reimplemented from RooAbsReal.; Definition at line 347 of file RooHistFunc.cxx. ◆ buildCallToAnalyticIntegral(). std::string RooHistFunc::buildCallToAnalyticIntegral ; (; int ; code, . const char * ; rangeName, . RooFit::Detail::CodeSquashContext & ; ctx . ); const. overridevirtual . This function defines the analytical integral translation for the class. ; Parameters. [in]codeThe code that decides the integrands. ; [in]rangeNameName of the normalization range. ; [in]ctxAn object to manage auxiliary information for code-squashing. ReturnsThe representative code string of the integral for the given object. ; Reimplemented from RooAbsReal.; Definition at line 325 of file RooHistFunc.cxx. ◆ Class(). static TClass * RooHistFunc::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooHistFunc::Class_Name ; (; ). static . ReturnsName of thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistFunc.html:65824,efficient,efficiently,65824,doc/master/classRooHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooHistFunc.html,1,['efficient'],['efficiently']
Energy Efficiency,"oHistPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 162 of file RooHistPdf.h. ◆ isBinnedDistribution(). bool RooHistPdf::isBinnedDistribution ; (; const RooArgSet & ; ); const. inlineoverridevirtual . Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ; Reimplemented from RooAbsReal.; Definition at line 94 of file RooHistPdf.h. ◆ maxVal(). double RooHistPdf::maxVal ; (; Int_t ; code); const. overridevirtual . Return maximum value for set of observables identified by code assigned in getMaxVal. ; Reimplemented from RooAbsReal.; Definition at line 571 of file RooHistPdf.cxx. ◆ plotSamplingHint() [1/2]. std::list< double > * RooHistPdf::plotSamplingHint ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ; Reimplemented from RooAbsReal.; Definition at line 469 of file RooHistPdf.cxx. ◆ plotSamplingHint() [2/2]. std::list< double > * RooHistPdf::plotSamplingHint ; (; RooDataHist const & ; dataHist, . RooArgSet const & ; pdfObsList, . RooArgSet const & ; histObsList, . int ; intOrder, . RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ). staticprivate . Definition at line 475 of file RooHistPdf.cxx. ◆ rooHistIntegralTranslateImpl(). std::string RooHistPdf::rooHistIntegralTranslateImpl ; (; int ; code, . RooAbsArg const * ; klass, . RooDataHist const * ; dataHist, . const RooArgSet & ; obs, . bool ; histFuncMode . ). staticprivate . Definition at line 398 of file RooHistPdf.cxx. ◆ rooHistTranslateImpl(). void RooHistPdf::rooHistTranslateImpl ; (; RooAbsArg const * ; klass, . RooFit::Detail::CodeSquashContext & ; ctx, . int ; intOrder, . RooDataHist const * ; dataHist, . con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistPdf.html:86081,efficient,efficiently,86081,doc/master/classRooHistPdf.html,https://root.cern,https://root.cern/doc/master/classRooHistPdf.html,1,['efficient'],['efficiently']
Energy Efficiency,"oKeysPdf.cxx. ◆ getAnalyticalIntegral(). Int_t RooKeysPdf::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 301 of file RooKeysPdf.cxx. ◆ getMaxVal(). Int_t RooKeysPdf::getMaxVal ; (; const RooArgSet & ; vars); const. overridevirtual . Advertise capability to determine maximum value of function for given set of observables. ; If no direct generator method is provided, this information will assist the accept/reject generator to operate more efficiently as it can skip the initial trial sampling phase to empirically find the function maximum ; Reimplemented from RooAbsReal.; Definition at line 348 of file RooKeysPdf.cxx. ◆ IsA(). TClass * RooKeysPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 80 of file RooKeysPdf.h. ◆ LoadDataSet(). void RooKeysPdf::LoadDataSet ; (; RooDataSet & ; data). Definition at line 148 of file RooKeysPdf.cxx. ◆ maxVal(). double RooKeysPdf::maxVal ; (; Int_t ; code); const. overridevirtual . Return maximum value for set of observables identified by code assigned in getMaxVal. ; Reimplemented from RooAbsReal.; Definition at line 354 of file RooKeysPdf.cxx. ◆ Streamer(). void RooKeysPdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooKeysPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooKeysPdf.html:78891,efficient,efficiently,78891,doc/master/classRooKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRooKeysPdf.html,1,['efficient'],['efficiently']
Energy Efficiency,"oPlot.cxx. ◆ printValue(). void RooPlot::printValue ; (; std::ostream & ; os); const. overridevirtual . Print frame arguments. ; Reimplemented from RooPrintable.; Definition at line 710 of file RooPlot.cxx. ◆ pullHist(). RooHist * RooPlot::pullHist ; (; const char * ; histname = nullptr, . const char * ; pdfname = nullptr, . bool ; useAverage = true . ); const. inline . Uses residHist() and sets normalize=true. ; Definition at line 185 of file RooPlot.h. ◆ remove(). void RooPlot::remove ; (; const char * ; name = nullptr, . bool ; deleteToo = true . ). Remove object with given name, or last object added if no name is given. ; Definition at line 868 of file RooPlot.cxx. ◆ residHist(). RooHist * RooPlot::residHist ; (; const char * ; histname = nullptr, . const char * ; curvename = nullptr, . bool ; normalize = false, . bool ; useAverage = true . ); const. Return a RooHist (derives from TGraphAsymErrors) containing the residuals of a histogram. ; The plotting range of the graph is adapted to the plotting range of the current plot.; Parameters. histnameName of the data histogram. Passing an empty string or nullptr will create residuals of the last-plotted histogram. ; curvenameName of the curve to compare to data. Passing an empty string or nullptr will create residuals of the last-plotted curve. ; normalizeIf true, the residuals are divided by the error of the histogram, effectively returning a pull histogram. ; useAverageIf true, the histogram is compared with the curve averaged in each bin. Otherwise, the curve is evaluated at the bin centres, which is not accurate for strongly curved distributions. . Definition at line 1101 of file RooPlot.cxx. ◆ setAddDirectoryStatus(). bool RooPlot::setAddDirectoryStatus ; (; bool ; flag). static . Configure whether new instances of RooPlot will add themselves to gDirectory. ; Like TH1::AddDirectory(). ; Definition at line 78 of file RooPlot.cxx. ◆ SetAxisColor(). void RooPlot::SetAxisColor ; (; Color_t ; color = 1, . Option_t * ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooPlot.html:45936,adapt,adapted,45936,doc/master/classRooPlot.html,https://root.cern,https://root.cern/doc/master/classRooPlot.html,1,['adapt'],['adapted']
Energy Efficiency,"oStats::ModelConfig&); voidSetNBins(Int_t bins); virtual voidSetNuisanceParameters(const RooArgSet&); voidSetParameterPointsToTest(RooAbsData& pointsToTest); virtual voidSetParameters(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); voidSetPOIPointsToTest(RooAbsData& poiToTest); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp); virtual Double_tSize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUseAdaptiveSampling(bool flag = true). private:. voidCreateParameterPoints() const; voidCreateTestStatSampler() const. Data Members; private:. Bool_tfAdaptiveSamplingcontrols use of adaptive sampling algorithm; Double_tfAdditionalNToysFactorgive user ability to ask for more toys; RooStats::ConfidenceBelt*fConfBelt; Bool_tfCreateBeltcontrols use if ConfidenceBelt should be saved to a TFile; RooAbsData&fDatadata set ; Bool_tfDoProfileConstructioninstead of full construction over nuisance parametrs, do profile; Bool_tfFluctuateDatatell ToyMCSampler to fluctuate number of entries in dataset; RooStats::ModelConfig&fModel; Int_tfNbinsnumber of samples per variable; RooAbsData*fPOIToTestvalue of POI points to perform the construction; RooAbsData*fPointsToTestpoints to perform the construction; Bool_tfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); standard constructor. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. TestStatSampler* GetTestStatSampler() const. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the paramet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__FeldmanCousins.html:3163,adapt,adaptive,3163,root/html530/RooStats__FeldmanCousins.html,https://root.cern,https://root.cern/root/html530/RooStats__FeldmanCousins.html,2,['adapt'],['adaptive']
Energy Efficiency,"oTestInverterHypoTestInverter(RooStats::FrequentistCalculator& hc, RooRealVar* scannedVariable, double size = 0.05); RooStats::HypoTestInverterHypoTestInverter(RooStats::AsymptoticCalculator& hc, RooRealVar* scannedVariable, double size = 0.05); RooStats::HypoTestInverterHypoTestInverter(RooAbsData& data, RooStats::ModelConfig& b, RooStats::ModelConfig& sb, RooRealVar* scannedVariable = 0, RooStats::HypoTestInverter::ECalculatorType type = kFrequentist, double size = 0.05); virtual TClass*IsA() const; RooStats::SamplingDistribution*RebuildDistributions(bool isUpper = true, int nToys = 100, TList* clsDist = 0, TList* clsbDist = 0, TList* clbDist = 0); boolRunFixedScan(int nBins, double xMin, double xMax) const; boolRunLimit(double& limit, double& limitErr, double absTol = 0, double relTol = 0, const double* hint = 0) const; boolRunOnePoint(double thisX, bool adaptive = false, double clTarget = -1) const; voidSetAutoScan(); static voidSetCloseProof(Bool_t flag); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData&); voidSetFixedScan(int nBins, double xMin = 1, double xMax = -1); voidSetMaximumToys(int ntoys); virtual voidSetModel(const RooStats::ModelConfig&); voidSetNumErr(double err); virtual voidSetTestSize(Double_t size); boolSetTestStatistic(RooStats::TestStatistic& stat); voidSetVerbose(int level = 1); virtual voidShowMembers(TMemberInspector& insp); virtual Double_tSize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUseCLs(bool on = true). protected:. static voidCheckInputModels(const RooStats::HypoTestCalculatorGeneric& hc, const RooRealVar& scanVar); voidCreateResults() const; RooStats::HypoTestResult*Eval(RooStats::HypoTestCalculatorGeneric& hc, bool adaptive, double clsTarget) const; static RooRealVar*GetVariableToScan(const RooStats::HypoTestCalculatorGeneric& hc); RooStats::HypoTestInverterHypoTestInverter(const RooStats::HypoTestInverter& rhs); RooStats::HypoTestInverter&operator=(const RooStats::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HypoTestInverter.html:3230,adapt,adaptive,3230,root/html532/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html532/RooStats__HypoTestInverter.html,1,['adapt'],['adaptive']
Energy Efficiency,"oTestInverterHypoTestInverter(RooStats::HybridCalculator& hc, RooRealVar* scannedVariable = 0, double size = 0.05); RooStats::HypoTestInverterHypoTestInverter(RooStats::FrequentistCalculator& hc, RooRealVar* scannedVariable, double size = 0.05); RooStats::HypoTestInverterHypoTestInverter(RooAbsData& data, RooStats::ModelConfig& b, RooStats::ModelConfig& sb, RooRealVar* scannedVariable = 0, RooStats::HypoTestInverter::ECalculatorType type = kFrequentist, double size = 0.05); virtual TClass*IsA() const; RooStats::SamplingDistribution*RebuildDistributions(bool isUpper = true, int nToys = 100, TList* clsDist = 0, TList* clsbDist = 0, TList* clbDist = 0); boolRunFixedScan(int nBins, double xMin, double xMax) const; boolRunLimit(double& limit, double& limitErr, double absTol = 0, double relTol = 0, const double* hint = 0) const; boolRunOnePoint(double thisX, bool adaptive = false, double clTarget = -1) const; voidSetAutoScan(); static voidSetCloseProof(Bool_t flag); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData&); voidSetFixedScan(int nBins, double xMin = 1, double xMax = -1); voidSetMaximumToys(int ntoys); virtual voidSetModel(const RooStats::ModelConfig&); voidSetNumErr(double err); virtual voidSetTestSize(Double_t size); boolSetTestStatistic(RooStats::TestStatistic& stat); voidSetVerbose(int level = 1); virtual voidShowMembers(TMemberInspector& insp); virtual Double_tSize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUseCLs(bool on = true). protected:. static voidCheckInputModels(const RooStats::HypoTestCalculatorGeneric& hc, const RooRealVar& scanVar); voidCreateResults() const; RooStats::HypoTestResult*Eval(RooStats::HypoTestCalculatorGeneric& hc, bool adaptive, double clsTarget) const; static RooRealVar*GetVariableToScan(const RooStats::HypoTestCalculatorGeneric& hc); RooStats::HypoTestInverterHypoTestInverter(const RooStats::HypoTestInverter& rhs); RooStats::HypoTestInverter&operator=(const RooStats::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HypoTestInverter.html:3101,adapt,adaptive,3101,root/html530/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html530/RooStats__HypoTestInverter.html,1,['adapt'],['adaptive']
Energy Efficiency,"oadcastRaw(const void* buffer, Int_t length, TList* slaves); Broadcast a raw buffer of specified length to all slaves in the; specified list. Returns the number of slaves the buffer was sent to.; Returns -1 in case of error. Int_t BroadcastRaw(const void* buffer, Int_t length, TProof::ESlaves list = kActive); Broadcast a raw buffer of specified length to all slaves in the; specified list. Returns the number of slaves the buffer was sent to.; Returns -1 in case of error. Int_t BroadcastFile(const char* file, Int_t opt, const char* rfile, TList* wrks); Broadcast file to all workers in the specified list. Returns the number of workers; the buffer was sent to.; Returns -1 in case of error. Int_t BroadcastFile(const char* file, Int_t opt, const char* rfile = 0, TProof::ESlaves list = kAllUnique); Broadcast file to all workers in the specified list. Returns the number of workers; the buffer was sent to.; Returns -1 in case of error. void ReleaseMonitor(TMonitor* mon); Release the used monitor to be used, making sure to delete newly created; monitors. Int_t Collect(const TSlave* sl, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from slave sl. Returns the number of slaves that; responded (=1).; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(ESlaves list, Long_t timeout, Int_t endtype, Bool_t deactonfail); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:41518,monitor,monitor,41518,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,12,['monitor'],"['monitor', 'monitors']"
Energy Efficiency,"oat_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; x1Option_t Option_t TPoint TPoint const char x1Definition TGWin32VirtualXProxy.cxx:70; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TStopwatch.h; WrappedFunction.h; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::BinData::GetPointconst double * GetPoint(unsigned int ipoint, double &value) constretrieve at the same time a pointer to the coordinate data and the fit value More efficient than call...Definition BinData.h:381; ROOT::Fit::BinData::Valuedouble Value(unsigned int ipoint) constreturn the value for the given fit pointDefinition BinData.h:220; ROOT::Fit::FitData::Sizeunsigned int Size() constreturn number of fit pointsDefinition FitData.h:293; ROOT::Fit::FitData::NDimunsigned int NDim() constreturn coordinate data dimensionDefinition FitData.h:301; ROOT::Math::GoFTest::GetSigmaNstatic Double_t GetSigmaN(const std::vector< size_t > &ns, size_t N)Computation of sigma_N as described in (1)Definition GoFTest.cxx:311; ROOT::Math::GoFTest::SetCDFvoid SetCDF()Definition GoFTest.cxx:244; ROOT::Math::GoFTest::operator()void operator()(ETestType test, Double_t &pvalue, Double_t &testStat) constThe class's unary functions performing the gif test according to the ETestType provided.Definition GoFTest.cxx:208; ROOT::Math::GoFTest::SetDistributionFunctionvoid SetDistributionFunction(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GoFTest_8cxx_source.html:37802,efficient,efficient,37802,doc/master/GoFTest_8cxx_source.html,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html,1,['efficient'],['efficient']
Energy Efficiency,"oat_t f2 = step*cos1t;; Float_t f3 = step*tsint*vect[kPZ];; Float_t f4 = -tet*cos1t;; Float_t f5 = sint;; Float_t f6 = tet*cos1t*vect[kPZ];; vout[kX] = vect[kX] + (f1*vect[kPX] - f2*vect[kPY]);; vout[kY] = vect[kY] + (f1*vect[kPY] + f2*vect[kPX]);; vout[kZ] = vect[kZ] + (f1*vect[kPZ] + f3);; vout[kPX] = vect[kPX] + (f4*vect[kPX] - f5*vect[kPY]);; vout[kPY] = vect[kPY] + (f4*vect[kPY] + f5*vect[kPX]);; vout[kPZ] = vect[kPZ] + (f4*vect[kPZ] + f6);; }; ; void tree2w(); {; //create a Tree file tree2.root; ; //create the file, the Tree and a few branches with; //a subset of gctrak; TFile f(""tree2.root"",""recreate"");; TTree t2(""t2"",""a Tree with data from a fake Geant3"");; Gctrak_t gstep;; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot);; t2.Branch(""gekin"",&gstep.gekin);; t2.Branch(""nmec"",&gstep.nmec);; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; t2.Branch(""destep"",&gstep.destep);; t2.Branch(""pid"",&gstep.pid);; ; //Initialize particle parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep.step = 0.1;; gstep.destep = 0;; gstep.nmec = 0;; gstep.pid = 0;; ; //transport particles; for (Int_t i=0;i<10000;i++) {; //generate a new particle if necessary; if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1; if (gRandom->Rndm() < 0.5) charge = -1;; gstep.pid += 1;; gstep.vect[0] = 0;; gstep.vect[1] = 0;; gstep.vect[2] = 0;; gstep.vect[3] = px/p;; gstep.vect[4] = py/p;; gstep.vect[5] = pz/p;; gstep.vect[6] = p*charge;; gstep.getot = TMath::Sqrt(p*p + mass*mass);; gstep.gekin = gstep.getot - mass;; newParticle = kFALSE;; }; ; // fill the Tree with current step parameters; t2.Fill();; ; //transport particle in magnetic field; helixStep(gstep.step, gstep.vect, vout); //make one step; ; //apply energy loss; gstep.destep = gstep.step*gRandom->Gaus(0.0002,0.00001);; gstep.gekin -= gstep.d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree2_8C.html:2817,charge,charge,2817,doc/master/tree2_8C.html,https://root.cern,https://root.cern/doc/master/tree2_8C.html,1,['charge'],['charge']
Energy Efficiency,"oat_t GetMean ();  Compute and return the mean of the circular buffer content. ;  ; Int_t GetOdoVal () const;  ; Float_t GetPeakVal () const;  ; const TGPicture * GetPicture () const;  ; Float_t GetScaleMax () const;  ; Float_t GetScaleMin () const;  ; void Glow (EGlowColor col=kGreen);  Make speedo glowing. ;  ; Bool_t HandleButton (Event_t *event) override;  Handle mouse button event. ;  ; TClass * IsA () const override;  ; Bool_t IsThresholdActive ();  ; void LedClicked ();  ; void OdoClicked ();  ; void ResetPeakVal ();  ; void SetBufferSize (Int_t size);  Change the circular buffer size (used for the automatic mean calculation). ;  ; void SetDisplayText (const char *text1, const char *text2="""");  Set small display text (two lines). ;  ; void SetLabelText (const char *text1, const char *text2="""");  Set main label text (two lines). ;  ; void SetMeanValue (Float_t mean);  ; void SetMinMaxScale (Float_t min, Float_t max);  Set min and max scale values. ;  ; void SetOdoValue (Int_t val);  Set actual value of odo meter. ;  ; void SetScaleValue (Float_t val);  Set actual scale (needle position) value. ;  ; void SetScaleValue (Float_t val, Int_t damping);  Set actual scale (needle position) value. ;  ; void SetThresholdColors (EGlowColor col1, EGlowColor col2, EGlowColor col3);  ; void SetThresholds (Float_t th1=0.0, Float_t th2=0.0, Float_t th3=0.0);  ; void StepScale (Float_t step);  Increment/decrement scale (needle position) of ""step"" value. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGFrame;  TGFrame (const TGWindow *p=nullptr, UInt_t w=1, UInt_t h=1, UInt_t options=0, Pixel_t back=GetDefaultFrameBackground());  Create a TGFrame object. Options is an OR of the EFrameTypes. ;  ;  TGFrame (TGClient *c, Window_t id, const TGWindow *parent=nullptr);  Create a frame using an externally created window. ;  ;  ~TGFrame () override;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGSpeedo.html:3789,meter,meter,3789,doc/master/classTGSpeedo.html,https://root.cern,https://root.cern/doc/master/classTGSpeedo.html,1,['meter'],['meter']
Energy Efficiency,"object of the same class to the receiver object. ;  ; static Bool_t ConnectToClass (TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . #include <TMonitor.h>. Inheritance diagram for TMonitor:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EInterest. enum TMonitor::EInterest. EnumeratorkRead ; kWrite . Definition at line 54 of file TMonitor.h. Constructor & Destructor Documentation. ◆ TMonitor() [1/2]. TMonitor::TMonitor ; (; Bool_t ; mainloop = kTRUE). Create a monitor object. ; If mainloop is true the monitoring will be done in the main event loop. ; Definition at line 109 of file TMonitor.cxx. ◆ TMonitor() [2/2]. TMonitor::TMonitor ; (; const TMonitor & ; m). Copy constructor. ; Definition at line 123 of file TMonitor.cxx. ◆ ~TMonitor(). TMonitor::~TMonitor ; (; ). virtual . Cleanup the monitor object. Does not delete sockets being monitored. ; Definition at line 153 of file TMonitor.cxx. Member Function Documentation. ◆ Activate(). void TMonitor::Activate ; (; TSocket * ; sock). virtual . Activate a de-activated socket. ; Definition at line 250 of file TMonitor.cxx. ◆ ActivateAll(). void TMonitor::ActivateAll ; (; ). virtual . Activate all de-activated sockets. ; Definition at line 268 of file TMonitor.cxx. ◆ Add(). void TMonitor::Add ; (; TSocket * ; sock, . Int_t ; interest = kRead . ). virtual . Add socket to the monitor's active list. ; If interest=kRead then we want to monitor the socket for read readiness, if interest=kWrite then we mon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMonitor.html:16884,monitor,monitor,16884,doc/master/classTMonitor.html,https://root.cern,https://root.cern/doc/master/classTMonitor.html,1,['monitor'],['monitor']
Energy Efficiency,"object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:19935,allocate,allocate,19935,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,4,['allocate'],['allocate']
Energy Efficiency,"objects that are all of the same type. The format of a TClonesArray object is given in Format of the DATA for a TClonesArray object.; There are two great advantages in the use of TClonesArray over TObjArray when the objects all will be of the same class:. Memory for the objects will be allocated only once for the entire array, rather than the per-object allocation for TObjArray. This can be done because all the objects are the same size.; In the case of TObjArray, the stored objects are written sequentially. However, in a TClonesArray, by default, each object is split one level deep into its base class(es) and data members, and each of these members is written sequentially for all objects in the array before the next member is written. This has two advantages:; Greater compression can be achieved when similar data is consecutive.; The object's data members can easily be split into different TTree branches (TTrees are discussed below). TTree; A TTree is a highly specialized container class for efficient storage and retrieval of user data. The use of TTrees is discussed in detail in the Trees chapter of the Root Manual; Here we discuss in particular how a TTree is stored in a ROOTIO file.; A TTree object is split into one or more branches (class TBranch), each of which may have its own (sub)branches, recursively to any depth. Each TBranch contains an array of zero or more leaves (class TLeaf), each corresponding to a basic variable type or a class object that has not been split. The TLeaf object does not actually contain variable values, only information about the variables. The actual data on each branch is physically stored in basket objects (class TBasket). The user can set the basket size on a per TBranch basis. The default basket size is 32000 bytes. This should be viewed as an approximate number.; There is one TTree data record per file for each tree in the file, corresponding to a TTree class object. The TTree class object recursively contains TBranch objects, e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootio.html:13888,efficient,efficient,13888,doc/master/rootio.html,https://root.cern,https://root.cern/doc/master/rootio.html,1,['efficient'],['efficient']
Energy Efficiency,"obtained chi-square was 0.76732. Original spectrum. Fitted function. We have implemented the fitting function with matrix inversion based on Stiefel-Hestens method of the solution of the system of linear equations also for 2-dimensional data. The form of the function is as follows; char* Fit2Stiefel(float **source,; TSpectrumTwoDimFit* p,; int sizex,; int sizey);; This function fits the source spectrum. The calling program should fill in the input parameters of the two_dim_fit structure. The fitted parameters are written into structure pointed by two_dim_fit structure pointer and fitted data are written back into the source spectrum.; Function parameters:. source: pointer to the matrix of the source spectrum; p: pointer to the two_dim_fit structure pointer, see manual; sizex: length x of the source spectrum; sizey: length y of the source spectrum. The structure two_dim_fit is the same as in the awmi function. The parameters power, fit_taylor are not applicable for this function; The results for small number of fitted parameters are the same as with awmi function. However, it converges faster. The example for data given in Figure 5.6 (38 parameters) is presented in the following table:. # of iterations; Chi awmi; Chi-Stiefel. 1; 24.989; 10.415. 5; 20.546; 1.0553. 10; 6.256; 0.84383. 50; 1.0985; 0.64297. 100; 0.6571; 0.64297. 500; 0.65194; 0.64297. Again, Stiefel-Hestens method converges faster. However, its calculation is for this number of parameters takes approximately 3 times longer. For larger number of parameters the time needed to calculate the inversion grows with the cube of the number of fitted parameters. For example, the fit of large number of parameters (2068) for data in Figure 5.8 using awmi algorithm took about 12 hours (using 450 MHz PC). The calculation using matrix inversion method is not realizable in any reasonable time.; 6 TRANSFORMS; 6.1 1-DIMENSIONAL SPECTRA; Orthogonal transforms can be successfully used for the processing of nuclear spectra. T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:53938,power,power,53938,root/htmldoc/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html,1,['power'],['power']
Energy Efficiency,"ocated in the class.; This procedure is much faster than calling TClonesArray::Delete(). void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This is a simplified version of ExpandCreate used in the TTree mechanism. TObject * RemoveAt(Int_t idx); Remove object at index idx. TObject * Remove(TObject* obj); Remove object from array. void RemoveRange(Int_t idx1, Int_t idx2); Remove objects from index idx1 to idx2 included. void SetClass(const TClass *cl, Int_t s); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument s indicates an approximate number of objects; that will be entered in the array. If ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClonesArray.html:15722,allocate,allocated,15722,root/html526/TClonesArray.html,https://root.cern,https://root.cern/root/html526/TClonesArray.html,1,['allocate'],['allocated']
Energy Efficiency,"ocating colorcells to most used colors first,; and then approximating other colors with those allocated.; max_colors - maximum size of the colormap.; dither - number of bits to strip off the color data ( 0...7 ); opaque_threshold - alpha channel threshold at which pixel should be; treated as opaque. void HSV(UInt_t hue = 0, UInt_t radius = 360, Int_t H = 0, Int_t S = 0, Int_t V = 0, Int_t x = 0, Int_t y = 0, UInt_t width = 0, UInt_t height = 0); This function will tile original image to specified size with offsets; requested, and then it will go though it and adjust hue, saturation and; value of those pixels that have specific hue, set by affected_hue; affected_radius parameters. When affected_radius is greater then 180; entire image will be adjusted. Note that since grayscale colors have; no hue - the will not get adjusted. Only saturation and value will be; adjusted in gray pixels.; Hue is measured as an angle on a 360 degree circle, The following is; relationship of hue values to regular color names :; red - 0; yellow - 60; green - 120; cyan - 180; blue - 240; magenta - 300; red - 360. All the hue values in parameters will be adjusted to fall withing 0-360 range. void Gradient(UInt_t angle = 0, const char* colors = ""#FFFFFF #000000"", const char* offsets = 0, Int_t x = 0, Int_t y = 0, UInt_t width = 0, UInt_t height = 0); Render multipoint gradient inside rectangle of size (width, height); at position (x,y) within the existing image. angle Given in degrees. Default is 0. This is the; direction of the gradient. Currently the only supported; values are 0, 45, 90, 135, 180, 225, 270, 315. 0 means left; to right, 90 means top to bottom, etc. colors Whitespace-separated list of colors. At least two; colors are required. Each color in this list will be visited; in turn, at the intervals given by the offsets attribute. offsets Whitespace-separated list of floating point values; ranging from 0.0 to 1.0. The colors from the colors attribute; are given these offsets, and the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TASImage.html:33615,green,green,33615,root/html526/TASImage.html,https://root.cern,https://root.cern/root/html526/TASImage.html,7,['green'],['green']
Energy Efficiency,"ocessOptions ();  process the options specified by the user ;  ; void RRScalc (const Event &, std::vector< Float_t > *count);  ; void SetVolumeElement (void);  defines volume dimensions ;  ; void UpdateThis ();  update static this pointer ;  . Static Private Member Functions; static MethodPDERS *& GetMethodPDERSThreadLocal ();  . Private Attributes; std::vector< Float_t > fAverageRMS;  average RMS of signal and background ;  ; BinarySearchTree * fBinaryTree;  binary tree ;  ; std::vector< Float_t > * fDelta;  size of volume ;  ; Float_t fDeltaFrac;  fraction of RMS ;  ; Double_t fGaussSigma;  size of Gauss in adaptive volume ;  ; Double_t fGaussSigmaNorm;  size of Gauss in adaptive volume (normalised to dimensions) ;  ; Bool_t fInitializedVolumeEle;  is volume element initialized ? ;  ; Float_t fInitialScale;  initial scale for adaptive volume ;  ; enum TMVA::MethodPDERS::EKernelEstimator fKernelEstimator;  ; TString fKernelString;  ; Int_t fkNNMax;  max number of events in kNN tree ;  ; Int_t fkNNMin;  min number of events in kNN tree ;  ; Double_t fMax_distance;  maximum distance ;  ; Float_t fMaxVIterations;  maximum number of iterations to adapt volume size ;  ; Float_t fNEventsMax;  maximum number of events in adaptive volume ;  ; Float_t fNEventsMin;  minimum number of events in adaptive volume ;  ; Bool_t fNormTree;  binary-search tree is normalised ;  ; Double_t fNRegOut;  ; Bool_t fPrinted;  print ;  ; Float_t fScaleB;  weight for background events ;  ; Float_t fScaleS;  weight for signal events ;  ; std::vector< Float_t > * fShift;  volume center ;  ; TString fVolumeRange;  ; enum TMVA::MethodPDERS::EVolumeRangeMode fVRangeMode;  . Additional Inherited Members;  Public Types inherited from TMVA::MethodBase; enum  EWeightFileType { kROOT =0; , kTEXT; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSing",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodPDERS.html:31191,adapt,adaptive,31191,doc/master/classTMVA_1_1MethodPDERS.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodPDERS.html,6,['adapt'],"['adapt', 'adaptive']"
Energy Efficiency,"ock() ? mutex : nullptr;  ; #define R__COLLECTION_ITER_GUARD(collection);  ; #define R__COLLECTION_READ_GUARD();  ; #define R__COLLECTION_READ_LOCKGUARD(mutex)   ::ROOT::TReadLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_READ_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TReadLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_GUARD();  ; #define R__COLLECTION_WRITE_LOCKGUARD(mutex)   ::ROOT::TWriteLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TWriteLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__FOR_EACH(type, proc);  . Typedefs; template<typename T > ; using TRangeDynCast = ROOT::Detail::TRangeCast< T, true >;  TRangeDynCast is an adapter class that allows the typed iteration through a TCollection. ;  ; template<typename T > ; using ROOT::Detail::TRangeStaticCast = TRangeCast< T, false >;  TRangeStaticCast is an adapter class that allows the typed iteration through a TCollection. ;  . Functions; bool ROOT::Internal::ContaineeInheritsFrom (TClass *cl, TClass *base);  Return true if 'cl' inherits from 'base'. ;  ; const TCollection & ROOT::Internal::EmptyCollection ();  Return an empty collection for use with nullptr TRangeCast. ;  . Variables; R__EXTERN TVirtualMutex * gCollectionMutex;  ; const Bool_t kIterBackward = !kIterForward;  ; const Bool_t kIterForward = kTRUE;  . Macro Definition Documentation. ◆ R__COLL_COND_MUTEX. #define R__COLL_COND_MUTEX; (;  ; mutex);    this->IsUsingRWLock() ? mutex : nullptr. Definition at line 360 of file TCollection.h. ◆ R__COLLECTION_ITER_GUARD. #define R__COLLECTION_ITER_GUARD; (;  ; collection). Definition at line 129 of file TCollection.h. ◆ R__COLLECTION_READ_GUARD. #define R__COLLECTION_READ_GUARD; (; ). Definition at line 128 of file TCollection.h. ◆ R__COLLECTION_READ_LOCKGUARD. #define R__COLLECTION_READ_LOCKGUARD; (;  ; mute",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8h.html:2370,adapt,adapter,2370,doc/master/TCollection_8h.html,https://root.cern,https://root.cern/doc/master/TCollection_8h.html,1,['adapt'],['adapter']
Energy Efficiency,"ocumentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Development Run the tests. Running the ROOT battery of tests; Running all ROOT tests on at least a platform before sending a PR or before pushing anything to the ROOT repository is mandatory.; The ROOT continuous integration infrastructure allows to automatically check the PR also on a battery of platform, for example including macos and linux boxes.; In order to be able to run all tests, the simple steps below need to be followed; Prepare your development area and build ROOT; mkdir RootDevelopment; cd RootDevelopment; git clone https://github.com/root-project/root; git clone https://github.com/root-project/roottest; mkdir build; cd build; echo Note the cmake options; cmake -DCMAKE_BUILD_TYPE=Debug -Dtesting=ON -Droottest=ON ../root. Inspect and run the tests; From within the build directory. List all tests: ctest -N; List all test matching a regex: ctest -N -R myregex; Run all tests on N cores: ctest -j N. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. Ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/run-tests.html:1894,battery,battery,1894,d/run-tests.html,https://root.cern,https://root.cern/d/run-tests.html,1,['battery'],['battery']
Energy Efficiency,"ocumentation. ◆ AddPixmap(). Int_t TVirtualX::AddPixmap ; (; ULongptr_t ; pixid, . UInt_t ; w, . UInt_t ; h . ). virtual . Registers a pixmap created by TGLManager as a ROOT pixmap. ; Parameters. [in]pixidpixmap identifier ; [in]w,hthe width and height, which define the pixmap size . Reimplemented in TGCocoa, TGX11, and TGWin32.; Definition at line 561 of file TVirtualX.cxx. ◆ AddWindow(). Int_t TVirtualX::AddWindow ; (; ULongptr_t ; qwid, . UInt_t ; w, . UInt_t ; h . ). virtual . Registers a window created by Qt as a ROOT window. ; Parameters. [in]qwidwindow identifier ; [in]w,hthe width and height, which define the window size . Reimplemented in TGCocoa, TGX11, TGWin32, and TGWin32VirtualXProxy.; Definition at line 550 of file TVirtualX.cxx. ◆ AllocColor(). Bool_t TVirtualX::AllocColor ; (; Colormap_t ; cmap, . ColorStruct_t & ; color . ). virtual . Allocates a read-only colormap entry corresponding to the closest RGB value supported by the hardware. ; If no cell could be allocated it returns kFALSE, otherwise kTRUE.; The pixel value is set to default. Let system think we could allocate color.; Parameters. [in]cmapthe colormap ; [in]colorspecifies and returns the values actually used in the cmap . Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 113 of file TVirtualX.cxx. ◆ BeginModalSessionFor(). void TVirtualX::BeginModalSessionFor ; (; Window_t ; window). virtual . Start a modal session for a dialog window. ; Definition at line 2488 of file TVirtualX.cxx. ◆ Bell(). void TVirtualX::Bell ; (; Int_t ; percent). virtual . Sets the sound bell. Percent is loudness from -100% to 100%. ; Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 1517 of file TVirtualX.cxx. ◆ ChangeActivePointerGrab(). void TVirtualX::ChangeActivePointerGrab ; (; Window_t ; , . UInt_t ; , . Cursor_t ;  . ). virtual . Changes the specified dynamic parameters if the pointer is actively grabbed by the client and if the spe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:50496,allocate,allocated,50496,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,1,['allocate'],['allocated']
Energy Efficiency,"od, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Double_tPDK(Double_t a, Double_t b, Double_t c). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfBeta[3]betas of decaying particle; TLorentzVectorfDecPro[18]kinematics of the generated particles ; Double_tfMass[18]masses of particles; Int_tfNtnumber of decay particles; Double_tfTeCmTmtotal energy in the C.M. minus the total mass; Double_tfWtMaxmaximum weigth . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t PDK(Double_t a, Double_t b, Double_t c); the PDK function. TGenPhaseSpace(const TGenPhaseSpace& gen); copy constructor. Double_t Generate(); Generate a random final state.; The function returns the weigth of the current event.; The TLorentzVector of each decay product can be obtained using GetDecay(n). Note that Momentum, Energy units are Gev/C, GeV. TLorentzVector * GetDecay(Int_t n); return Lorentz vector corresponding to decay n. Bool_t SetDecay(TLorentzVector& P, Int_t nt, Double_t* mass, Option_t* opt = """"); input:; TLorentzVector &P: decay particle (Momentum, Energy units are Gev/C, GeV); Int_t nt: number of decay products; Double_t *mass: array of decay product masses; Option_t *opt: default -> constant cross section;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGenPhaseSpace.html:6011,energy,energy,6011,root/html528/TGenPhaseSpace.html,https://root.cern,https://root.cern/root/html528/TGenPhaseSpace.html,1,['energy'],['energy']
Energy Efficiency,"od, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Double_tPDK(Double_t a, Double_t b, Double_t c). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfBeta[3]betas of decaying particle; TLorentzVectorfDecPro[18]kinematics of the generated particles ; Double_tfMass[18]masses of particles; Int_tfNtnumber of decay particles; Double_tfTeCmTmtotal energy in the C.M. minus the total mass; Double_tfWtMaxmaximum weigth . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t PDK(Double_t a, Double_t b, Double_t c); the PDK function. TGenPhaseSpace(const TGenPhaseSpace& gen); copy constructor. Double_t Generate(); Generate a random final state.; The function returns the weigth of the current event.; The TLorentzVector of each decay product can be obtained using GetDecay(n). Note that Momentum, Energy units are Gev/C, GeV. TLorentzVector * GetDecay(Int_t n); return Lorentz vector corresponding to decay n. Bool_t SetDecay(TLorentzVector& P, Int_t nt, const Double_t* mass, Option_t* opt = """"); input:; TLorentzVector &P: decay particle (Momentum, Energy units are Gev/C, GeV); Int_t nt: number of decay products; Double_t *mass: array of decay product masses; Option_t *opt: default -> constant cross se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGenPhaseSpace.html:6086,energy,energy,6086,root/html530/TGenPhaseSpace.html,https://root.cern,https://root.cern/root/html530/TGenPhaseSpace.html,2,['energy'],['energy']
Energy Efficiency,"od, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Double_tPDK(Double_t a, Double_t b, Double_t c). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfBeta[3]betas of decaying particle; TLorentzVectorfDecPro[18]kinematics of the generated particles ; Double_tfMass[18]masses of particles; Int_tfNtnumber of decay particles; Double_tfTeCmTmtotal energy in the C.M. minus the total mass; Double_tfWtMaxmaximum weigth . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t PDK(Double_t a, Double_t b, Double_t c); the PDK function. TGenPhaseSpace(const TGenPhaseSpace& gen); copy constructor. TGenPhaseSpace& operator=(const TGenPhaseSpace& gen); Assignment operator. Double_t Generate(); Generate a random final state.; The function returns the weigth of the current event.; The TLorentzVector of each decay product can be obtained using GetDecay(n). Note that Momentum, Energy units are Gev/C, GeV. TLorentzVector * GetDecay(Int_t n); return Lorentz vector corresponding to decay n. Bool_t SetDecay(TLorentzVector& P, Int_t nt, const Double_t* mass, Option_t* opt = """"); input:; TLorentzVector &P: decay particle (Momentum, Energy units are Gev/C, GeV); Int_t nt: number of decay products; Double_t *mass:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGenPhaseSpace.html:6109,energy,energy,6109,root/html534/TGenPhaseSpace.html,https://root.cern,https://root.cern/root/html534/TGenPhaseSpace.html,1,['energy'],['energy']
Energy Efficiency,"ode that filters entries based on range. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > Redefine (std::string_view name, F expression, const ColumnNames_t &columns={});  Overwrite the value and/or type of an existing column. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > Redefine (std::string_view name, std::string_view expression);  Overwrite the value and/or type of an existing column. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > RedefineSlot (std::string_view name, F expression, const ColumnNames_t &columns={});  Overwrite the value and/or type of an existing column. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > RedefineSlotEntry (std::string_view name, F expression, const ColumnNames_t &columns={});  Overwrite the value and/or type of an existing column. ;  ; RResultPtr< T > Reduce (F f, std::string_view columnName, const T &redIdentity);  Execute a user-defined reduce operation on the values of a column. ;  ; RResultPtr< T > Reduce (F f, std::string_view columnName="""");  Execute a user-defined reduce operation on the values of a column. ;  ; RResultPtr< RCutFlowReport > Report ();  Gather filtering statistics. ;  ; RResultPtr< RInterface< RLoopManager > > Snapshot (std::string_view treename, std::string_view filename, const ColumnNames_t &columnList, const RSnapshotOptions &options=RSnapshotOptions());  Save selected columns to disk, in a new TTree treename in file filename. ;  ; RResultPtr< RInterface< RLoopManager > > Snapshot (std::string_view treename, std::string_view filename, const ColumnNames_t &columnList, const RSnapshotOptions &options=RSnapshotOptions());  Save selected columns to disk, in a new TTree treename in file filename. ;  ; RResultPtr< RInterface< RLoopManager > > Snapshot (std::string_view treename, std::string_view filename, std::initializer_list< std::string > columnList, const RSnapshotOptions &options=RSnapshotOptions());  Save selected columns to disk, in a new TTree treename in file filename. ;  ; RResultPtr< RInterface< RL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:96835,reduce,reduce,96835,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['reduce'],['reduce']
Energy Efficiency,"ode valid for RooAddPdf. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral defined by given scenario code. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events, which is either the sum of all coefficients; or the sum of the components extended terms, multiplied with the fraction that; is in the current range w.r.t the reference range. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fraction coefficients. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized context to efficiently generate toy events from RooAddPdfs; return RooAbsPdf::genContext(vars,prototype,auxProto,verbose) ; // WVE DEBUG. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Loop over components for plot sampling hints and merge them if there are multiple. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Loop over components for plot sampling hints and merge them if there are multiple. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooAddPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooAddPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddPdf.html:49008,efficient,efficiently,49008,root/html532/RooAddPdf.html,https://root.cern,https://root.cern/root/html532/RooAddPdf.html,1,['efficient'],['efficiently']
Energy Efficiency,"ode valid for RooAddPdf. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral defined by given scenario code. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events, which is either the sum of all coefficients; or the sum of the components extended terms, multiplied with the fraction that; is in the current range w.r.t the reference range. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fraction coefficients. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized context to efficiently generate toy events from RooAddPdfs; return RooAbsPdf::genContext(vars,prototype,auxProto,verbose) ; // WVE DEBUG. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Loop over components for plot sampling hints and merge them if there are multiple. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Loop over components for plot sampling hints and merge them if there are multiple. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooAddPdf with cache-and-track. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooAddPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooAddPdf(*this,newname) ; }. Bool_t forceAnalyt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddPdf.html:50559,efficient,efficiently,50559,root/html534/RooAddPdf.html,https://root.cern,https://root.cern/root/html534/RooAddPdf.html,3,['efficient'],['efficiently']
Energy Efficiency,"ode valid for RooAddPdf. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral defined by given scenario code. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events, which is either the sum of all coefficients; or the sum of the components extended terms, multiplied with the fraction that; is in the current range w.r.t the reference range. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fraction coefficients. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized context to efficiently generate toy events from RooAddPdfs; return RooAbsPdf::genContext(vars,prototype,auxProto,verbose) ; // WVE DEBUG. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Loop over components for plot sampling hints and merge them if there are multiple. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooAddPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooAddPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. Bool_t selfNormalized() const; P.d.f is self normalized. ExtendMode extendMode() const; Return extended mode capabilities. Double_t expectedEvents(const RooArgSet* nset) const. const RooArgList& pdfList() const; Return list of component p.d.fs. const RooArgList& coefList() const; Return li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddPdf.html:47405,efficient,efficiently,47405,root/html528/RooAddPdf.html,https://root.cern,https://root.cern/root/html528/RooAddPdf.html,2,['efficient'],['efficiently']
Energy Efficiency,"ode() was performed for the current point. Therefore, the first step is to convert the global current point and direction in the local reference frame of the current volume and to compute the distance to exit its shape from inside. The returned value is again compared to the maximum allowed step (the proposed one) and in case the distance is safe no other action is performed and the proposed step is approved. In case the boundary is closer, the computed distance is taken as maximum allowed step. For optimization purposed, for particles starting very close to the current volume boundary (less than 0.01 microns) and exiting the algorithm stops here.; After computing the distance to exit the current node, the distance to the daughter of the current volume which is crossed next is computed by TGeoManager::FindNextDaughterBoundary(). This computes the distance to all daughter candidates that can be possibly crossed by using volume voxelization. The algorithm is efficient in average only in case the number of daughters is greater than 4. For fewer nodes, a simple loop is performed and the minimum distance (from a point outside each shape) is taken and compared to the maximum allowed step. The step value is again updated if step<stepmax .; A special case is when the current node is declared as possibly overlapping with something else. If this is the case, the distance is computed for all possibly overlapping candidates, taking into account the overlapping priorities (see also: "" Overlapping volumes "").; The global matrix describing the next crossed physical node is systematically computed in case the value of the proposed step is negative. In this case, one can subsequently call TGeoManager::ComputeNormalFast() to get the normal vector to the crossed surface, after propagating the current point with the TGeoManager::GetStep() value. This propagation can be done like:; Double_t *current_point = gGeoManager->GetCurrentPoint();; Double_t *current_dir = gGeoManager->GetCurrent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:134491,efficient,efficient,134491,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,2,['efficient'],['efficient']
Energy Efficiency,"odel from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveTrackPropagator(const char* n = ""TEveTrackPropagator"", const char* t = """", TEveMagField* field = 0, Bool_t own_field = kTRUE); Default constructor. ~TEveTrackPropagator(); Destructor. void OnZeroRefCount(); Virtual from TEveRefBackPtr - track reference count has reached zero. void CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); Check reference count - virtual from TEveElement.; Must also take into account references from TEveRefBackPtr. void ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); Element-change notification.; Stamp all tracks as requiring display-list regeneration.; Virtual from TEveElement. void InitTrack(const TEveVectorD& v, Int_t charge); Initialize internal data-members for given particle parameters. void InitTrack(const TEveVectorF& v, Int_t charge); TEveVectorF wrapper. void ResetTrack(); Reset cache holding particle trajectory. Bool_t GoToVertex(TEveVectorD& v, TEveVectorD& p); Propagate particle with momentum p to vertex v. Bool_t GoToVertex(TEveVectorF& v, TEveVectorF& p); TEveVectorF wrapper. void GoToBounds(TEveVectorD& p); Propagate particle to bounds.; Return TRUE if hit bounds. void GoToBounds(TEveVectorF& p); TEveVectorF wrapper. void Update(const TEveVector4D& v, const TEveVectorD& p, Bool_t full_update = kFALSE, Bool_t enforce_max_step = kFALSE); Update helix / B-field projection state. void Step(const TEveVector4D& v, const TEveVectorD& p, TEveVector4D& vOut, TEveVectorD& pOut); Wrapper to step helix. void LoopToBounds(TEveVectorD& p); Propagate charged particle with momentum p to bounds.; It is expected that Update() with full-update was called before. Bool_t LoopToVertex(TEveVectorD& v, TEveVectorD& p); Propagate charged particle with momentum p to vertex v.; It is expected that Update() with full-upd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveTrackPropagator.html:25972,charge,charge,25972,root/html530/TEveTrackPropagator.html,https://root.cern,https://root.cern/root/html530/TEveTrackPropagator.html,2,['charge'],['charge']
Energy Efficiency,"odel from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveTrackPropagator(const char* n = ""TEveTrackPropagator"", const char* t = """", TEveMagField* field = 0, Bool_t own_field = kTRUE); Default constructor. ~TEveTrackPropagator(); Destructor. void OnZeroRefCount(); Virtual from TEveRefBackPtr - track reference count has reached zero. void CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); Check reference count - virtual from TEveElement.; Must also take into account references from TEveRefBackPtr. void ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); Element-change notification.; Stamp all tracks as requiring display-list regeneration.; Virtual from TEveElement. void InitTrack(const TEveVectorD& v, Int_t charge); Initialize internal data-members for given particle parameters. void InitTrack(const TEveVectorF& v, Int_t charge); TEveVectorF wrapper. void ResetTrack(); Reset cache holding particle trajectory. Int_t GetCurrentPoint() const; Get index of current point on track. Double_t GetTrackLength(Int_t start_point = 0, Int_t end_point = -1) const; Calculate track length from start_point to end_point.; If end_point is less than 0, distance to the end is returned. Bool_t GoToVertex(TEveVectorD& v, TEveVectorD& p); Propagate particle with momentum p to vertex v. Bool_t GoToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate particle with momentum p to line with start point s and vector r to the second point. Bool_t GoToVertex(TEveVectorF& v, TEveVectorF& p); TEveVectorF wrapper. Bool_t GoToLineSegment(const TEveVectorF& s, const TEveVectorF& r, TEveVectorF& p); TEveVectorF wrapper. void GoToBounds(TEveVectorD& p); Propagate particle to bounds.; Return TRUE if hit bounds. void GoToBounds(TEveVectorF& p); TEveVectorF wrapper. void Update(const TEveVector4D& v, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveTrackPropagator.html:27050,charge,charge,27050,root/html534/TEveTrackPropagator.html,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html,1,['charge'],['charge']
Energy Efficiency,"odel0.plotOn(frame, Components(p_h_bkg), LineColor(kRed));; model0.paramOn(frame);; ; sigData->plotOn(frame, MarkerColor(kBlue));; frame->Draw();; ; for (auto text : {; ""No template uncertainties"",; ""are taken into account."",; ""This leads to low errors"",; ""for the parameters A, since"",; ""the only source of errors"",; ""are the data statistics.""}) {; pt.AddText(text);; }; pt.DrawClone();; ; ; can->cd(2);; frame = x.frame(Title(""Barlow Beeston for Sig & Bkg separately""));; sumData.plotOn(frame);; model1.plotOn(frame, LineColor(kBlue), VisualizeError(*result1));; // Plot data again to show it on top of error bands:; sumData.plotOn(frame);; model1.plotOn(frame, LineColor(kBlue));; model1.plotOn(frame, Components(p_ph_sig1), LineColor(kAzure));; model1.plotOn(frame, Components(p_ph_bkg1), LineColor(kRed));; model1.paramOn(frame, Parameters(RooArgSet(Asig1, Abkg1)));; ; sigData->plotOn(frame, MarkerColor(kBlue));; frame->Draw();; ; pt.Clear();; for (auto text : {; ""With gamma parameters, the"",; ""signal & background templates"",; ""can adapt to the data."",; ""Note how the blue signal"",; ""template changes its shape."",; ""This leads to higher errors"",; ""of the scale parameters A.""}) {; pt.AddText(text);; }; pt.DrawClone();; ; can->cd(3);; frame = x.frame(Title(""Barlow Beeston light for (Sig+Bkg)""));; sumData.plotOn(frame);; model2.plotOn(frame, LineColor(kBlue), VisualizeError(*result2));; // Plot data again to show it on top of model0 error bands:; sumData.plotOn(frame);; model2.plotOn(frame, LineColor(kBlue));; model2.plotOn(frame, Components(p_ph_sig2), LineColor(kAzure));; model2.plotOn(frame, Components(p_ph_bkg2), LineColor(kRed));; model2.paramOn(frame, Parameters(RooArgSet(Asig2, Abkg2)));; ; sigData->plotOn(frame, MarkerColor(kBlue));; frame->Draw();; ; pt.Clear();; for (auto text : {; ""When signal and background"",; ""template share one gamma para-"",; ""meter per bin, they adapt less."",; ""The errors of the A parameters"",; ""also shrink slightly.""}) {; pt.AddText(text);; }; p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:6482,adapt,adapt,6482,doc/master/rf709__BarlowBeeston_8C.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html,1,['adapt'],['adapt']
Energy Efficiency,"odifying the returned list (in particular adding to it) can break invariant of THashTable so we need to clearly mark the list as not being allowed to be modified.; In TSeqCollection::Merge, we no longer delete the object in the case where the original collection is marked as a owner.; Global resources.; Several tweaks to if and when, resources held by the global ROOT object (TROOT, TApplication) are deleted. When the default TApplication is replaced by a user provide TApplication, do not call EndOfProcessCleanups and co. and thus do not delete TFiles, TSockets or TColors that have already been created. In EndOfProcessCleanups, we now delete the objects held in TROOT’s TDirectory part. If the libCling library is unloaded, this now induces an immediate tear down of the ROOT resources; consequently objects might be deleted sooner in the process tear down process on some platforms.; TObject instances allocated as part of an array and made part of a collection, as for example the TCanvas instances into the global list of instances, are not longer deleted if the content of the collection is deleted. Technically the element of the array are now treated by collections as if they have been allocated on the stack. This fixes the issue described at ROOT-7846.; Code Cleanups.; Several definition where moved from the global or ROOT namespace to the ROOT::Internal namespace as they are not intended to be used outside of ROOT, including: gROOTLocal and related functions, TSchemaHelper, TSchemaMatch, TSchemaType, RStl, ROOT::TROOTAllocator, TSchemaRuleProcessor, TStdBitsetHelper, TInitBehavior, TDefaultInitBehavior, DefineBehavior, THnBaseBrowsable, THnBaseBinIter, GenericShowMembers, TOperatorNewHelper and BranchProxy implementations classes.; Several definition where moved from the global or ROOT namespace to the ROOT::Details namespace as they are intended to be used in ‘expert’ level code and have a lower level of backward compatibility requirement. This includes TCollectionPro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:5747,allocate,allocated,5747,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['allocate'],['allocated']
Energy Efficiency,"odjet && goodbjet)"")\; .Define(""idx_untagged"", ""ROOT::VecOps::ArgMax(goodjet && !goodbjet)""); ; # Select events based on the jet kinematics and the scalar sum of the transverse momentum; # from the lepton, jets and met above 195 GeV; df[s] = df[s].Filter(""abs(jet_eta[idx_untagged]) > 1.5 && abs(jet_eta[idx_tagged] - jet_eta[idx_untagged]) > 1.5"")\; .Filter(""lep_pt[idx_lep] + jet_pt[idx_tagged] + jet_pt[idx_untagged] + met_et > 195000""); ; # Compute luminosity, scale factors and MC weights for simulated events; for s in samples:; if ""data"" in s:; df[s] = df[s].Define(""weight"", ""1.0""); else:; # The single top MC weights are either 1 or -1; if ""single"" in s: stop_norm = ""mcWeight / abs(mcWeight)""; else: stop_norm = ""mcWeight""; df[s] = df[s].Define(""weight"", ""scaleFactor_ELE * scaleFactor_MUON * scaleFactor_LepTRIGGER * scaleFactor_PILEUP * scaleFactor_BTAG * {} * {} / {} * {}"".format(stop_norm, xsecs[s], sumws[s], lumi)); ; # Reconstruct the top mass from the lepton, the missing transverse energy and the b-jet; ; # Just-in-time compile the function to compute the top mass from the constituents; ROOT.gInterpreter.Declare(""""""; float ComputeTopMass(float lep_pt, float lep_eta, float lep_phi, float lep_e, float jet_pt, float jet_eta, float jet_phi, float jet_e, float met_et, float met_phi); {; const ROOT::Math::PtEtaPhiEVector lep(lep_pt / 1000.0, lep_eta, lep_phi, lep_e / 1000.0);; const ROOT::Math::PtEtaPhiEVector met(met_et / 1000.0, 0, met_phi, met_et / 1000.0);; const ROOT::Math::PtEtaPhiEVector bjet(jet_pt / 1000.0, jet_eta, jet_phi, jet_e / 1000.0);; // Please note that we treat here the missing transverse energy as the neutrino, even though the z component is missing!; return (lep + met + bjet).M();; }; """"""); ; histos = {}; for s in samples:; df[s] = df[s].Define(""top_mass"", ""ComputeTopMass(lep_pt[idx_lep], lep_eta[idx_lep], lep_phi[idx_lep], lep_E[idx_lep], jet_pt[idx_tagged], jet_eta[idx_tagged], jet_phi[idx_tagged], jet_E[idx_tagged], met_et, met_phi)""); histos[s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:7104,energy,energy,7104,doc/master/df107__SingleTopAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html,1,['energy'],['energy']
Energy Efficiency,"oduct of two LorentzVector vectors (metric is -,-,-,+); Enable the product using any other LorentzVector implementing; the x(), y() , y() and t() member functions; \param q any LorentzVector implementing the x(), y() , z() and t(); member functions; \return the result of v.q of type according to the base scalar type of v. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar rho() const; { return fCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html:18338,energy,energy,18338,root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html,4,['energy'],['energy']
Energy Efficiency,"oduct of two LorentzVector vectors (metric is -,-,-,+); Enable the product using any other LorentzVector implementing; the x(), y() , y() and t() member functions; \param q any LorentzVector implementing the x(), y() , z() and t(); member functions; \return the result of v.q of type according to the base scalar type of v. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar rho() const; { return fCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html:17600,energy,energy,17600,root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html,4,['energy'],['energy']
Energy Efficiency,"odules |; Classes |; Enumerations ; Numerical IntegrationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for numerical integration of functions. ; These classes provide algorithms for integration of one-dimensional functions, with several adaptive and non-adaptive methods and for integration of multi-dimensional function using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Integration.html:1108,adapt,adaptive,1108,doc/master/group__Integration.html,https://root.cern,https://root.cern/doc/master/group__Integration.html,1,['adapt'],['adaptive']
Energy Efficiency,"of GUI events that have been replayed; TMutex*fMutex; TRecEvent*fNextEventThe next event that is going to be replayed (GUI event or commandline); TTimefPreviousEventTimeExecution time of the previously replayed event.; TRecorder*fRecorderReference to recorder (owner of this state) is kept in order to switch; Int_tfRegWinCounterCounter of registered windows when replaying; Bool_tfShowMouseCursorSpecifies if mouse cursor should be also replayed; TTimer*fTimerTimer used for replaying; Bool_tfWaitingForWindowSignalizes that we wait for a window to be registered in order; ULong64_tfWinWindow ID being currenty mapped; TTree*fWinTreeTTree with recorded windows (=registered during recording); Int_tfWinTreeEntriesNumber of registered windows during _recording_; TList*fWindowListList of TRecWinPair objects. Mapping of window IDs is stored here. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRecorderReplaying(const char* filename); Allocates all necessary data structures used for replaying; What is allocated here is deleted in destructor. Bool_t Initialize(TRecorder* r, Bool_t showMouseCursor, TRecorder::EReplayModes mode); Initialization of data structures for replaying.; Start of replaying. Return value:; - kTRUE = everything is OK and replaying has begun; - kFALSE = non existing or invalid log file, replaying has not started. void RegisterWindow(Window_t w); Creates mapping for the newly registered window w and adds this; mapping to fWindowList. Called by signal whenever a new window is registered during replaying. The new window ID is mapped to the old one with the same number in the; list of registered windows.; It means that 1st new window is mapped to the 1st original,; 2nd to the 2nd, Nth new to the Nth original. Bool_t RemapWindowReferences(); All references to the old windows (IDs) in fNextEvent are replaced by; new ones according to the mappings in fWindowList. Bool_t FilterEvent(TRecGuiEvent* e). Bool_t PrepareNextEvent()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRecorderReplaying.html:3595,allocate,allocated,3595,root/html528/TRecorderReplaying.html,https://root.cern,https://root.cern/root/html528/TRecorderReplaying.html,4,['allocate'],['allocated']
Energy Efficiency,"of controls within a process. In most UNIX systems, thread and process characteristics are grouped into a single entity called a process. Sometimes, threads are called ""lightweight processes’’.; Note: This introduction is adapted from the AIX 4.3 Programmer’s Manual.; 23.1 Threads and Processes; In traditional single-threaded process systems, a process has a set of properties. In multi-threaded systems, these properties are divided between processes and threads.; 23.1.1 Process Properties; A process in a multi-threaded system is the changeable entity. It must be considered as an execution frame. It has all traditional process attributes, such as:. Process ID, process group ID, user ID, and group ID; Environment; Working directory. A process also provides a common address space and common system resources:. File descriptors; Signal actions; Shared libraries; Inter-process communication tools (such as message queues, pipes, semaphores, or shared memory). 23.1.2 Thread Properties; A thread is the schedulable entity. It has only those properties that are required to ensure its independent flow of control. These include the following properties:. Stack; Scheduling properties (such as policy or priority); Set of pending and blocked signals; Some thread-specific data (TSD). An example of thread-specific data is the error indicator, errno. In multi-threaded systems, errno is no longer a global variable, but usually a subroutine returning a thread-specific errno value. Some other systems may provide other implementations of errno. With respect to ROOT, a thread specific data is for example the gPad pointer, which is treated in a different way, whether it is accessed from any thread or the main thread.; Threads within a process must not be considered as a group of processes (even though in Linux each thread receives an own process id, so that it can be scheduled by the kernel scheduler). All threads share the same address space. This means that two pointers having the same va",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1102089,schedul,schedulable,1102089,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['schedul'],['schedulable']
Energy Efficiency,"of nodes, used for search; 1517 std::vector<int> found_map(fDesc.size(), -1); ///<! mapping between nodeid - > foundid; 1518 ; 1519 // these are only selected nodes to produce hierarchy; 1520 ; 1521 found_desc.emplace_back(0);; 1522 found_desc[0].vis = fDesc[0].vis;; 1523 found_desc[0].name = fDesc[0].name;; 1524 found_desc[0].color = fDesc[0].color;; 1525 found_map[0] = 0;; 1526 ; 1527 ResetRndrInfos();; 1528 ; 1529 RGeomDrawing drawing;; 1530 bool has_shape = true;; 1531 ; 1532 ScanNodes(false, 0, [&, this](RGeomNode &node, std::vector<int> &stack, bool is_vis, int seqid) {; 1533 // select only nodes which should match; 1534 if (!match_func(node)); 1535 return true;; 1536 ; 1537 // add entries into hierarchy of found elements; 1538 int prntid = 0;; 1539 for (auto &s : stack) {; 1540 int chldid = fDesc[prntid].chlds[s];; 1541 if (found_map[chldid] <= 0) {; 1542 int newid = found_desc.size();; 1543 found_desc.emplace_back(newid); // potentially original id can be used here; 1544 found_map[chldid] = newid; // re-map into reduced hierarchy; 1545 ; 1546 found_desc.back().vis = fDesc[chldid].vis;; 1547 found_desc.back().name = fDesc[chldid].name;; 1548 found_desc.back().color = fDesc[chldid].color;; 1549 found_desc.back().material = fDesc[chldid].material;; 1550 }; 1551 ; 1552 auto pid = found_map[prntid];; 1553 auto cid = found_map[chldid];; 1554 ; 1555 // now add entry into childs lists; 1556 auto &pchlds = found_desc[pid].chlds;; 1557 if (std::find(pchlds.begin(), pchlds.end(), cid) == pchlds.end()); 1558 pchlds.emplace_back(cid);; 1559 ; 1560 prntid = chldid;; 1561 }; 1562 ; 1563 // no need to add visibles; 1564 if (!is_vis); 1565 return true;; 1566 ; 1567 drawing.visibles.emplace_back(node.id, seqid, stack);; 1568 ; 1569 // no need to transfer shape if it provided with main drawing list; 1570 // also no binary will be transported when too many matches are there; 1571 if (!send_rawdata || (node.sortid < fDrawIdCut)) {; 1572 // do not include render data; 1573 return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:47117,reduce,reduced,47117,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['reduce'],['reduced']
Energy Efficiency,"of the buffer into 'obj'. void ReadBuffer(TBuffer& b, void* obj, const TClass* onfileClass). void SetOnFileClass(TClass* cl); { fOnFileClass = cl; }. TClass* GetOnFileClass() const; { return fOnFileClass; }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); Set of functions to iterate easily throught the collection. CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE); typedef void (*CreateIterators_t)(void *collection, void **begin_arena, void **end_arena);; begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. Next_t GetFunctionNext(Bool_t read = kTRUE); typedef void* (*CopyIterator_t)(void **dest, const void *source);; Copy the iterator source, into dest. dest should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator is of that size or less, the iterator will be constructed in place in this location (new with placement); Otherwise the iterator will be allocated via a regular new.; The actual address of the iterator is returned in both case. DeleteIterator_t GetFunctionDeleteIterator(Bool_t read = kTRUE); typedef void* (*Next_t)(void *iter, const void *end);; iter and end should be pointers to respectively an iterator to be incremented and the result of collection.end(); If the iterator has not reached the end of the collection, 'Next' increment the iterator 'iter' and return 0 if; the iterator reached the end.; If ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGenCollectionProxy.html:9368,allocate,allocated,9368,root/html534/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html,1,['allocate'],['allocated']
Energy Efficiency,"of the buffer into 'obj'. void ReadBuffer(TBuffer& b, void* obj, const TClass* onfileClass). void SetOnFileClass(TClass* cl); { fOnFileClass = cl; }. TClass* GetOnFileClass() const; { return fOnFileClass; }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); Set of functions to iterate easily throught the collection. CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE); typedef void (*CreateIterators_t)(void *collection, void **begin_arena, void **end_arena);; begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. Next_t GetFunctionNext(Bool_t read = kTRUE); typedef void* (*CopyIterator_t)(void *dest, const void *source);; Copy the iterator source, into dest. dest should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator is of that size or less, the iterator will be constructed in place in this location (new with placement); Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest. DeleteIterator_t GetFunctionDeleteIterator(Bool_t read = kTRUE); typedef void* (*Next_t)(void *iter, const void *end);; iter and end should be pointers to respectively an iterator to be incremented and the result of collection.end(); If the iterator has not reached the end of the collection, 'Next' increment the iterator 'iter' and return 0 if; the iterator reached the end.; If the end",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGenCollectionProxy.html:8998,allocate,allocated,8998,root/html528/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html528/TGenCollectionProxy.html,3,['allocate'],['allocated']
Energy Efficiency,"oid P2X(Double_t *p, Double_t *x, Int_t nTest);; };. Whether the methods <classname>::X2P and <classname>::P2X should; be static or not, is up to the user. void MakePrincipals(); Perform the principal components analysis.; This is done in several stages in the TMatrix::EigenVectors method:; * Transform the covariance matrix into a tridiagonal matrix.; * Find the eigenvalues and vectors of the tridiagonal matrix. void MakeRealCode(const char* filename, const char* prefix, Option_t* option = """"); PRIVATE METHOD:; This is the method that actually generates the code for the; transformations to and from feature space and pattern space; It's called by TPrincipal::MakeCode and TPrincipal::MakeMethods. The options are: NONE so far. void P2X(const Double_t* p, Double_t* x, Int_t nTest); Calculate x as a function of nTest of the most significant; principal components p, and return it in x.; It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for x). void Print(Option_t* opt = ""MSE"") const; Print the statistics; Options are; M Print mean values of original data; S Print sigma values of original data; E Print eigenvalues of covariance matrix; V Print eigenvectors of covariance matrix; Default is MSE. void SumOfSquareResiduals(const Double_t* x, Double_t* s); PRIVATE METHOD:. /*; >; Calculates the sum of the square residuals, that is; . where; ; , is the; component of the principal vector, corresponding to; , the original data; I.e., the square distance to the space; spanned by eigenvectors.; . */; . void Test(Option_t* option = """"); Test the PCA, bye calculating the sum square of residuals; (see method SumOfSquareResiduals), and display the histogram. void X2P(const Double_t* x, Double_t* p); Calculate the principal components from the original data vector; x, and return it in p.; It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). const TMatri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPrincipal.html:16897,allocate,allocated,16897,root/html528/TPrincipal.html,https://root.cern,https://root.cern/root/html528/TPrincipal.html,6,['allocate'],['allocated']
Energy Efficiency,"oid SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TAttMarker::SetMarkerSizevirtual void SetMarkerSize(Size_t msize=1)Set the marker size.Definition TAttMarker.h:45; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TF11-Dim function classDefinition TF1.h:233; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TSpline3Class to create third splines to interpolate knots Arbitrary conditions can be introduced for first a...Definition TSpline.h:182; TSpline5Class to create quintic natural splines to interpolate knots Arbitrary conditions can be introduced f...Definition TSpline.h:238; TSpline::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TSpline.cxx:101; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definition TSystem.cxx:437; TTextBase class for several text objects.Definition TText.h:22; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; AuthorFederico Carminati ; Definition in file splines_test.C. tutorialsgraphssplines_test.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/splines__test_8C.html:5484,power,power,5484,doc/master/splines__test_8C.html,https://root.cern,https://root.cern/doc/master/splines__test_8C.html,1,['power'],['power']
Energy Efficiency,"oid TProof::SetPlayer ; (; TVirtualProofPlayer * ; player). protected . Set a new PROOF player. ; Definition at line 10199 of file TProof.cxx. ◆ SetPrintProgress(). void TProof::SetPrintProgress ; (; PrintProgress_t ; pp). inline . Definition at line 1046 of file TProof.h. ◆ SetProgressDialog(). void TProof::SetProgressDialog ; (; Bool_t ; on = kTRUE). Enable/Disable the graphic progress dialog. ; By default the dialog is enabled ; Definition at line 12509 of file TProof.cxx. ◆ SetQueryMode(). void TProof::SetQueryMode ; (; EQueryMode ; mode). Change query running mode to the one specified by 'mode'. ; Definition at line 6107 of file TProof.cxx. ◆ SetRealTimeLog(). void TProof::SetRealTimeLog ; (; Bool_t ; on = kTRUE). Switch ON/OFF the real-time logging facility. ; When this option is ON, log messages from processing are sent back as they come, instead of being sent back at the end in one go. This may help debugging or monitoring in some cases, but, depending on the amount of log, it may have significant consequencies on the load over the network, so it must be used with care. ; Definition at line 7096 of file TProof.cxx. ◆ SetRunStatus(). void TProof::SetRunStatus ; (; ERunStatus ; rst). inlineprivate . Definition at line 672 of file TProof.h. ◆ SetupWorkersEnv(). void TProof::SetupWorkersEnv ; (; TList * ; wrks, . Bool_t ; increasingpool = kFALSE . ). protected . Set up packages, loaded macros, include and lib paths ... ; Definition at line 1528 of file TProof.cxx. ◆ ShowCache(). void TProof::ShowCache ; (; Bool_t ; all = kFALSE). virtual . List contents of file cache. ; If all is true show all caches also on slaves. If everything is ok all caches are to be the same. ; Reimplemented in TProofLite.; Definition at line 7691 of file TProof.cxx. ◆ ShowData(). void TProof::ShowData ; (; ). virtual . List contents of the data directory in the sandbox. ; This is the place where files produced by the client queries are kept ; Reimplemented in TProofLite.; Definition at l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:147267,monitor,monitoring,147267,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['monitor'],['monitoring']
Energy Efficiency,"oid*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMultiDimFit&operator=(const TMultiDimFit&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = ""ps"") constMENU ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetBinVarX(Int_t nbbinvarx); voidSetBinVarY(Int_t nbbinvary); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMaxAngle(Double_t angle = 0); voidSetMaxFunctions(Int_t n); voidSetMaxPowers(const Int_t* powers); voidSetMaxStudy(Int_t n); voidSetMaxTerms(Int_t terms); voidSetMinAngle(Double_t angle = 1); voidSetMinRelativeError(Double_t error); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetPowerLimit(Double_t limit = 1e-3); virtual voidSetPowers(const Int_t* powers, Int_t terms); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMultiDimFit.html:19509,power,powers,19509,root/html530/TMultiDimFit.html,https://root.cern,https://root.cern/root/html530/TMultiDimFit.html,2,['power'],['powers']
Energy Efficiency,"oid*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMultiDimFit&operator=(const TMultiDimFit&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = ""ps"") constMENU ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetBinVarX(Int_t nbbinvarx); voidSetBinVarY(Int_t nbbinvary); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMaxAngle(Double_t angle = 0); voidSetMaxFunctions(Int_t n); voidSetMaxPowers(const Int_t* powers); voidSetMaxStudy(Int_t n); voidSetMaxTerms(Int_t terms); voidSetMinAngle(Double_t angle = 1); voidSetMinRelativeError(Double_t error); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetPowerLimit(Double_t limit = 1e-3); virtual voidSetPowers(const Int_t* powers, Int_t terms); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiDimFit.html:19766,power,powers,19766,root/html534/TMultiDimFit.html,https://root.cern,https://root.cern/root/html534/TMultiDimFit.html,1,['power'],['powers']
Energy Efficiency,"oidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(RooCmdArg arg1, RooCmdArg arg2 = RooCmdArg(), RooCmdArg arg3 = RooCmdArg(), RooCmdArg arg4 = RooCmdArg(), RooCmdArg arg5 = RooCmdArg(), RooCmdArg arg6 = RooCmdArg(), RooCmdArg arg7 = RooCmdArg(), RooCmdArg arg8 = RooCmdArg()); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTreeData.html:8396,reduce,reduce,8396,root/html526/RooTreeData.html,https://root.cern,https://root.cern/root/html526/RooTreeData.html,2,['reduce'],['reduce']
Energy Efficiency,"oidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooTreeData.html:8715,reduce,reduce,8715,root/html530/RooTreeData.html,https://root.cern,https://root.cern/root/html530/RooTreeData.html,1,['reduce'],['reduce']
Energy Efficiency,"oidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; RooTreeData(); RooTreeData(const RooTreeData&); RooTreeData(RooTreeData&&); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsData::setDefaultStorageType(RooAbsData::StorageType s); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOpt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTreeData.html:8952,reduce,reduce,8952,root/html602/RooTreeData.html,https://root.cern,https://root.cern/root/html602/RooTreeData.html,2,['reduce'],['reduce']
Energy Efficiency,"oidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsData::setDefaultStorageType(RooAbsData::StorageType s); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooTreeData.html:8935,reduce,reduce,8935,root/html534/RooTreeData.html,https://root.cern,https://root.cern/root/html534/RooTreeData.html,1,['reduce'],['reduce']
Energy Efficiency,"oidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooTreeData.html:8811,reduce,reduce,8811,root/html532/RooTreeData.html,https://root.cern,https://root.cern/root/html532/RooTreeData.html,1,['reduce'],['reduce']
Energy Efficiency,"oidTObject::MakeZombie(); TPolyMarker3D&operator=(const TPolyMarker3D&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tfLastPointThe index of the last filled point; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tfNNumber of allocated points; TStringfNameName of polymarker; TStringfOptionOptions; Float_t*fP[3*fN] Array of X,Y,Z coordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPolyMarker3D(); 3-D polymarker default constructor. TPolyMarker3D(Int_t n, Marker_t marker = 1, Option_t* option = """"); 3-D polymarker normal constructor with initialization to 0. TPolyMarker3D(Int_t n, Float_t* p, Marker_t marker = 1, Option_t* option = """"); 3-D polymarker constructor. Polymarker is initialized with p. TPolyMarker3D(Int_t n, Double_t* p, Marker_t marker = 1, Option_t* option = """"); 3-D polymarker constructor. Polymarker is initialized with p; (cast to float). TPolyMarker3D& operator=(const TPolyMarker3D& ); assignement operator. ~TPolyMarker3D(); 3-D polymarker destructor. TPolyMarker3D(const TPolyMarker3D& p); 3-D polymarker copy ctor. void Copy(TObject& polymarker) const; Copy polymarker to polymarker obj. Int_t Dis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPolyMarker3D.html:8197,allocate,allocated,8197,root/html602/TPolyMarker3D.html,https://root.cern,https://root.cern/root/html602/TPolyMarker3D.html,2,['allocate'],['allocated']
Energy Efficiency,"oidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tEvalControl(const Int_t* powers) const; virtual Double_tEvalFactor(Int_t p, Double_t x) const; virtual voidMakeCandidates(); virtual voidMakeCoefficientErrors(); virtual voidMakeCoefficients(); virtual voidMakeCorrelation(); virtual Double_tMakeGramSchmidt(Int_t function); virtual voidMakeNormalized(); virtual voidMakeParameterization(); virtual voidMakeRealCode(const char* filename, const char* classname, Option_t* option = """"); voidTObject::MakeZombie(); virtual Bool_tSelect(const Int_t* iv); virtual Bool_tTestFunction(Double_t squareResidual, Double_t dResidur). Data Members; public:. enum EMDFPolyType { kMonomials; kChebyshev; kLegendre; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfBinVarXNumber of bin in independent variables; Int_tfBinVarYNumber of bin in dependent variables; Double_tfChi2Chi square of fit; TVectorDfCoefficientsVector of the final coefficients; TVectorDfCoefficientsRMSVector of RMS of coefficients; Double_tfCorrelationCoeffMulti Correlation coefficient; TMatrix",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiDimFit.html:20718,power,powers,20718,root/html528/TMultiDimFit.html,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html,3,['power'],['powers']
Energy Efficiency,"oid ; ). privatevirtual . default initialization called by all constructors ; Implements TMVA::MethodBase.; Definition at line 177 of file MethodFisher.cxx. ◆ InitMatrices(). void TMVA::MethodFisher::InitMatrices ; (; void ; ). private . initialization method; creates global matrices and vectors ; Definition at line 285 of file MethodFisher.cxx. ◆ IsA(). virtual TClass * TMVA::MethodFisher::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::MethodBase.; Definition at line 154 of file MethodFisher.h. ◆ MakeClassSpecific(). void TMVA::MethodFisher::MakeClassSpecific ; (; std::ostream & ; fout, . const TString & ; className . ); const. protectedvirtual . write Fisher-specific classifier response ; Reimplemented from TMVA::MethodBase.; Definition at line 655 of file MethodFisher.cxx. ◆ PrintCoefficients(). void TMVA::MethodFisher::PrintCoefficients ; (; void ; ). display Fisher coefficients and discriminating power for each variable check maximum length of variable name ; Definition at line 557 of file MethodFisher.cxx. ◆ ProcessOptions(). void TMVA::MethodFisher::ProcessOptions ; (; ). privatevirtual . process user options ; Implements TMVA::MethodBase.; Definition at line 204 of file MethodFisher.cxx. ◆ ReadWeightsFromStream() [1/3]. virtual void TMVA::MethodBase::ReadWeightsFromStream ; (; std::istream & ; ). virtual . Implements TMVA::MethodBase. ◆ ReadWeightsFromStream() [2/3]. void TMVA::MethodFisher::ReadWeightsFromStream ; (; std::istream & ; i). virtual . read Fisher coefficients from weight file ; Implements TMVA::MethodBase.; Definition at line 609 of file MethodFisher.cxx. ◆ ReadWeightsFromStream() [3/3]. virtual void TMVA::MethodBase::ReadWeightsFromStream ; (; TFile & ; ). inlinevirtual . Reimplemented from TMVA::MethodBase.; Definition at line 266 of file MethodBase.h. ◆ ReadWeightsFromXML(). void TMVA::MethodFisher::ReadWeightsFromXML ; (; void * ; wghtnode). virtual . read Fisher coefficients from xml w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodFisher.html:38800,power,power,38800,doc/master/classTMVA_1_1MethodFisher.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodFisher.html,1,['power'],['power']
Energy Efficiency,"oint (1 - dimension) ;  ; bool Next (double *x);  Generate next quasi random numbers points. ;  ; double Rndm ();  Generate quasi random numbers between ]0,1[ 0 and 1 are excluded Function to be compatible with ROOT TRandom compatibility. ;  ; bool RndmArray (int n, double *array);  Generate an array of random numbers between ]0,1[ Function to preserve ROOT Trandom compatibility The array will be filled as x1,y1,z1,....x2,y2,z2,... ;  ; bool Skip (unsigned int n);  skip the next n number and jumb directly to the current state + n ;  ; std::string Type () const;  Return the type (name) of the used generator. ;  . Private Attributes; Engine fEngine;  . #include <Math/QuasiRandom.h>; Constructor & Destructor Documentation. ◆ QuasiRandom() [1/2]. template<class Engine > . ROOT::Math::QuasiRandom< Engine >::QuasiRandom ; (; unsigned int ; dimension = 1). inline . Create a QuasiRandom generator. ; Use default engine constructor. Engine will be initialized via Initialize() function in order to allocate resources ; Definition at line 70 of file QuasiRandom.h. ◆ QuasiRandom() [2/2]. template<class Engine > . ROOT::Math::QuasiRandom< Engine >::QuasiRandom ; (; const Engine & ; e, . unsigned int ; dimension = 1 . ). inlineexplicit . Create a QuasiRandom generator based on a provided generic engine. ; Engine will be initialized via Initialize() function in order to allocate resources ; Definition at line 80 of file QuasiRandom.h. ◆ ~QuasiRandom(). template<class Engine > . ROOT::Math::QuasiRandom< Engine >::~QuasiRandom ; (; ). inline . Destructor: call Terminate() function of engine to free any allocated resource. ; Definition at line 88 of file QuasiRandom.h. Member Function Documentation. ◆ EngineSize(). template<class Engine > . unsigned int ROOT::Math::QuasiRandom< Engine >::EngineSize ; (; ); const. inline . Return the size of the generator state. ; Definition at line 140 of file QuasiRandom.h. ◆ Name(). template<class Engine > . std::string ROOT::Math::QuasiRandom< Engine",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1QuasiRandom.html:2432,allocate,allocate,2432,doc/master/classROOT_1_1Math_1_1QuasiRandom.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1QuasiRandom.html,1,['allocate'],['allocate']
Energy Efficiency,"oint x using an adaptive backward difference algorithm with a step size h. ; The function is evaluated only at points less than x and at x itself. ; Definition at line 105 of file Derivator.cxx. ◆ EvalCentral() [1/2]. double ROOT::Math::Derivator::EvalCentral ; (; const IGenFunction & ; f, . double ; x, . double ; h = 1E-8 . ). static . Computes the numerical derivative of a function f at a point x using an adaptive central difference algorithm with a step size h. ; Definition at line 114 of file Derivator.cxx. ◆ EvalCentral() [2/2]. double ROOT::Math::Derivator::EvalCentral ; (; double ; x, . double ; h = 1E-8 . ); const. Computes the numerical derivative at a point x using an adaptive central difference algorithm with a step size h. ; Definition at line 97 of file Derivator.cxx. ◆ EvalForward() [1/2]. double ROOT::Math::Derivator::EvalForward ; (; const IGenFunction & ; f, . double ; x, . double ; h = 1E-8 . ). static . Computes the numerical derivative of a function f at a point x using an adaptive forward difference algorithm with a step size h. ; The function is evaluated only at points greater than x and at x itself ; Definition at line 118 of file Derivator.cxx. ◆ EvalForward() [2/2]. double ROOT::Math::Derivator::EvalForward ; (; double ; x, . double ; h = 1E-8 . ); const. Computes the numerical derivative at a point x using an adaptive forward difference algorithm with a step size h. ; The function is evaluated only at points greater than x and at x itself. ; Definition at line 101 of file Derivator.cxx. ◆ operator=(). Derivator & ROOT::Math::Derivator::operator= ; (; const Derivator & ; rhs). private . Definition at line 76 of file Derivator.cxx. ◆ Result(). double ROOT::Math::Derivator::Result ; (; ); const. return the result of the last derivative calculation ; Definition at line 152 of file Derivator.cxx. ◆ SetFunction() [1/2]. void ROOT::Math::Derivator::SetFunction ; (; const GSLFuncPointer & ; f, . void * ; p = nullptr . ). Set the function f for eva",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Derivator.html:9036,adapt,adaptive,9036,doc/master/classROOT_1_1Math_1_1Derivator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Derivator.html,1,['adapt'],['adaptive']
Energy Efficiency,"ojections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ;  ; TObject * clone (const char *newname) const override;  ; bool forceAnalyticalInt (const RooAbsArg &) const override;  ; double getActual (Int_t ibin);  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise that all integrals can be handled internally. ;  ; double getNominal (Int_t ibin) const;  ; double getNominalError (Int_t ibin) const;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &) const override;  Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ;  ; const RooArgList & paramList () const;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const override;  Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ;  ; void setActual (Int_t ibin, double newVal);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooParamHistFunc.html:2652,efficient,efficiently,2652,doc/master/classRooParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooParamHistFunc.html,1,['efficient'],['efficiently']
Energy Efficiency,"okDatadata used by this function; static Bool_tfgHasCustomNewDeletetrue if using ROOT's new/delete; static ULong_tfgHeapBeginbegin address of heap; static ULong_tfgHeapEndend address of heap; static size_tfgMaxBlockSizelargest block allocated; static ReAllocCFun_tfgReAllocCHookcustom ReAlloc with length check; static ReAllocFun_tfgReAllocHookcustom ReAlloc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void EnterStat(size_t size, void* p); Register a memory allocation operation. If desired one can trap an; allocation of a certain size in case one tries to find a memory; leak of that particular size. This function is only called via; the ROOT custom new operators. void RemoveStat(void* p); Register a memory free operation. This function is only called via; the custom ROOT delete operator. void * Alloc(size_t size); Allocate a block of memory, that later can be resized using; TStorage::ReAlloc(). void Dealloc(void* ptr); De-allocate block of memory, that was allocated via TStorage::Alloc(). void * ReAlloc(void* vp, size_t size); Reallocate (i.e. resize) block of memory. void * ReAlloc(void* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) block of memory. Checks if current size is; equal to oldsize. If not memory was overwritten. char * ReAllocChar(char* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of chars. Size and oldsize are; in number of chars. Int_t * ReAllocInt(Int_t* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of integers. Size and oldsize are; number of integers (not number of bytes). void * ObjectAlloc(size_t size); Used to allocate a TObject on the heap (via TObject::operator new()).; Directly after this routine one can call (in the TObject ctor); TStorage::IsOnHeap() to find out if the just created object is on; the heap. void * ObjectAlloc(size_t size, void* vp); Used to allocate a TObject on the heap (via TObject::operator new(size_t,void*)); in position vp. v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStorage.html:3639,allocate,allocate,3639,root/html528/TStorage.html,https://root.cern,https://root.cern/root/html528/TStorage.html,6,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"oken is found, kFALSE if not or if some inconsistency occurred. This method allows to loop over tokens in this way: TString myl = ""tok1 tok2|tok3"";; TString tok;; Ssiz_t from = 0;; while (myl.Tokenize(tok, from, ""[ |]"")) {; // Analyse tok; ...; }; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; int; more convenient of the other Tokenize method when saving the tokens is not needed. ; Definition at line 310 of file TRegexp.cxx. ◆ ToLower(). void TString::ToLower ; (; ). Change string to lower-case. ; Definition at line 1182 of file TString.cxx. ◆ ToUpper(). void TString::ToUpper ; (; ). Change string to upper case. ; Definition at line 1195 of file TString.cxx. ◆ UItoa(). TString TString::UItoa ; (; UInt_t ; value, . Int_t ; base . ). static . Converts a UInt_t (twice the range of an Int_t) to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). In case of error returns the ""!"" string. ; Definition at line 2119 of file TString.cxx. ◆ ULLtoa(). TString TString::ULLtoa ; (; ULong64_t ; value, . Int_t ; base . ). static . Converts a ULong64_t (twice the range of an Long64_t) to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). In case of error returns the ""!"" string. ; Definition at line 2171 of file TString.cxx. ◆ UnLink(). void TString::UnLink ; (; ); const. inlineprivate . Definition at line 263 of file TString.h. ◆ View(). std::string_view TString::View ; (; ); const. inline . Definition at line 452 of file TString.h. ◆ WriteString(). void TString::WriteString ; (; TBuffer & ; b, . const TString * ; a . ). static . Write TString object to buffer. ; Simplified version of TBuffer::WriteObject (does not keep track of mult",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTString.html:56453,adapt,adapted,56453,doc/v632/classTString.html,https://root.cern,https://root.cern/doc/v632/classTString.html,2,['adapt'],['adapted']
Energy Efficiency,"ol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html:6646,adapt,adaptive,6646,root/html528/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html,10,['adapt'],['adaptive']
Energy Efficiency,"ol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointers). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__IntegratorOneDim.html:6618,adapt,adaptive,6618,root/html604/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__IntegratorOneDim.html,2,['adapt'],['adaptive']
Energy Efficiency,"ol to find the minimum value of a multi-parameter function (the “\(\mbox{FCN}\)”) and analyze the shape of the function around the minimum. The principal application is foreseen for statistical analysis, working on chisquare or log-likelihood functions, to compute the best-fit parameter values and uncertainties, including correlations between the parameters. It is especially suited to handle difficult problems, including those which may require guidance in order to find the correct solution.; 1.2 What M is not intended to do; Although M will of course solve easy problems faster than complicated ones, it is not intended for the repeated solution of identically parametrized problems (such as track fitting in a detector) where a specialized program will in general be much more efficient.; 1.3 Further remarks; M was initially written in Fortran around 1975-1980 at CERN by Fred James @bib-MINUIT. Its main field of usage is statistical data analysis of experimental data recorded at CERN, but it is also used by people doing data analysis outside CERN or outside high energy physics (HEP). In 2002 Fred James started a project aiming to re-implement M in an object-oriented way using .; More information about recent developments, releases and installation can be obtained from the M homepage @bib-C++MINUIT.; The names of M applications are written in capital letters (e.g. \(\mbox{MIGRAD}\), \(\mbox{MINOS}\), \(\mbox{CONTOURS}\)), the corresponding names of the classes are written using sans-serif font type (MnMigrad, MnMinos, MnContours).; 2 Introduction: M basic concepts; [sec:intro]; 2.1 The organization of M; The M package acts on a multiparameter objective function which is called — for historical reasons — the \(\mbox{FCN}\) function (see [howto:fcn]). This function is usually a chisquared or a log–likelihood, but it could also be a mathematical function. The \(\mbox{FCN}\) function needs to be written in for which M defines the pure abstract base class FCNBase as interface",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:6709,energy,energy,6709,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['energy'],['energy']
Energy Efficiency,"olCorr = 1.0E-4, Bool_t verbose = kTRUE) const; Return true if this fit result is identical to other within tolerance 'tol' on fitted values; and tolerance 'tolCor' on correlation coefficients. RooFitResult* lastMinuitFit(const RooArgList& varList = RooArgList()); Import the results of the last fit performed by gMinuit, interpreting; the fit parameters as the given varList of parameters. void setCovarianceMatrix(TMatrixDSym& V); Store externally provided correlation matrix in this RooFitResult ;. TH2* correlationHist(const char* name = ""correlation_matrix"") const; Return TH2D of correlation matrix. const TMatrixDSym& covarianceMatrix() const; Return covariance matrix. TMatrixDSym reducedCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix (Note that Vred _is_ a simple sub-matrix of V,; row/columns are ordered to matched the convention given in input argument 'params'. TMatrixDSym conditionalCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix, which is calculated as; ___ -1; Vred = V22 = V11 - V12 * V22 * V21. Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; is the Shur complement of V22, calculated as shown above. (Note that Vred is _not_ a simple sub-matrix of V). const TMatrixDSym& correlationMatrix() const; Return correlation matrix ;. RooAbsPdf* createHessePdf(const RooArgSet& params) const; Return a p.d.f that represents the fit result as a multi-variate probability densisty; function on the floating fit parameters, including correlations. void SetName(const char* name); Change name of RooFitResult object. void SetNameTitle(const char* name, const char* title); Change name and title of RooFitResult object. void printName(ostream& os) const; Print name of fit result. void printTitle(ostream& os) const; Print title of fit result. void printClassNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFitResult.html:16156,reduce,reduced,16156,root/html602/RooFitResult.html,https://root.cern,https://root.cern/root/html602/RooFitResult.html,2,['reduce'],['reduced']
Energy Efficiency,"ol_t flag) -- Integrate function over range specified by X errors; rather than take value at bin center. Options to control flow of fit procedure. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataSet& data, RooCmdArg arg1, RooCmdArg arg2, 				 RooCmdArg arg3, RooCmdArg arg4, RooCmdArg arg5, 				 RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:74590,consumption,consumption,74590,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,1,['consumption'],['consumption']
Energy Efficiency,"ol_t flag) -- Integrate function over range specified by X errors; rather than take value at bin center. Options to control flow of fit procedure. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataSet& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsReal.html:75968,consumption,consumption,75968,root/html528/RooAbsReal.html,https://root.cern,https://root.cern/root/html528/RooAbsReal.html,6,['consumption'],['consumption']
Energy Efficiency,"ol_t TMath::Permute (Int_t n, Int_t *a);  Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinct adapted from CERNLIB routine PERMU. ;  ; constexpr Double_t TMath::Pi ();  \( \pi\) ;  ; constexpr Double_t TMath::PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t TMath::PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t TMath::Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t TMath::PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t TMath::Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Prob (Double_t chi2, Int_t ndf);  Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf). ;  ; constexpr Double_t TMath::Qe ();  Elementary charge in \( C \) . ;  ; constexpr Double_t TMath::QeUncertainty ();  Elementary charge uncertainty. ;  ; void TMath::Quantiles (Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob, Bool_t isSorted=kTRUE, Int_t *index=nullptr, Int_t type=7);  Computes sample quantiles, corresponding to the given probabilities. ;  ; Double_t TMath::QuietNaN ();  Returns a quiet NaN as defined by IEEE 754. ;  ; constexpr Double_t TMath::R ();  Universal gas constant ( \( Na K \)) in \( J K^{-1} mol^{-1} \) ;  ; constexpr Double_t TMath::RadToDeg ();  Conversion from radian to degree: \( \frac{180}{\pi} \). ;  ; constexpr Double_t TMath::Rgair ();  Dry Air Gas Constant (R / MWair) in \( J kg^{-1} K^{-1} \) ;  ; template<typename Ite",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h.html:15646,power,power,15646,doc/master/TMath_8h.html,https://root.cern,https://root.cern/doc/master/TMath_8h.html,1,['power'],['power']
Energy Efficiency,"olar); ROOT::Math::RhoZPhiPoint point based on rho,z,phi coordinates (cylindrical using z); ROOT::Math::RhoEtaPhiPoint point based on rho,eta,phi coordinates (cylindrical using eta instead of z). Vector3D; Type definitions for vectors in three dimensions, based on ROOT::Math::DisplacementVector3D, are defined by Math/Vector3D.h:. ROOT::Math::XYZVector vector based on x,y,z coordinates (cartesian); ROOT::Math::Polar3DVector vector based on r,theta,phi coordinates (polar); ROOT::Math::RhoZPhiVector vector based on rho, z,phi coordinates (cylindrical); ROOT::Math::RhoEtaPhiVector vector based on rho,eta,phi coordinates (cylindrical using eta instead of z). LorentzVector; Type definitions for Lorentz vectors in four dimensions, based on ROOT::Math::LorentzVector, are defined by Math/Vector4D.h:. ROOT::Math::XYZTVector vector based on x,y,z,t coordinates (cartesian); ROOT::Math::PtEtaPhiEVector vector based on pt (rho),eta,phi and E (t) coordinates; ROOT::Math::PtEtaPhiMVector vector based on pt (rho),eta,phi and M (t) coordinates; ROOT::Math::PxPyPzMVector vector based on px,py,pz and M (mass) coordinates; ROOT::Math::PxPyPzEVector vector based on px,py,pz and E (energy) coordinates. The metric used for any such LorentzVector is (-,-,-,+). Operations. Constructors and Assignment; A vector can be constructed from its coordinate representation:; ROOT::Math::PtEtaPhiMVector v1(10. /*pt*/, 0.1 /*eta*/, 0.24 /*phi*/, 5 /*M*/);; ROOT::Math::LorentzVectorClass describing a generic LorentzVector in the 4D space-time, using the specified coordinate system ...Definition LorentzVector.h:59; v1@ v1Definition rootcling_impl.cxx:3701; In addition, the vector classes can be constructed from any object that implements the accessors x(), y() and z(). This can be a vector using a different coordinate system, or even an object from a different package as long as it implements the required signatures. One such vector type is CLHEP's Hep3Vector:; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__GenVector.html:5726,energy,energy,5726,doc/master/group__GenVector.html,https://root.cern,https://root.cern/doc/master/group__GenVector.html,1,['energy'],['energy']
Energy Efficiency,"olled user data.; TEveVectorfVStart vertex.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveTrackPropagator(const char* n = ""TEveTrackPropagator"", const char* t = """", TEveMagField* field = 0, Bool_t own_field = kTRUE); Default constructor. ~TEveTrackPropagator(); Destructor. void OnZeroRefCount(); Virtual from TEveRefBackPtr - track reference count has reached zero. void CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); Check reference count - virtual from TEveElement.; Must also take into account references from TEveRefBackPtr. void ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); Element-change notification.; Stamp all tracks as requiring display-list regeneration.; Virtual from TEveElement. void InitTrack(TEveVector& v, Int_t charge); Initialize internal data-members for given particle parameters. void ResetTrack(); Reset cache holding particle trajectory. Bool_t GoToVertex(TEveVector& v, TEveVector& p); Propagate particle with momentum p to vertex v. void GoToBounds(TEveVector& p); Propagate particle to bounds.; Return TRUE if hit bounds. void Update(const TEveVector4& v, const TEveVector& p, Bool_t full_update = kFALSE, Bool_t enforce_max_step = kFALSE); Update helix / B-field projection state. void Step(const TEveVector4& v, const TEveVector& p, TEveVector4& vOut, TEveVector& pOut); Wrapper to step helix. void LoopToBounds(TEveVector& p); Propagate charged particle with momentum p to bounds.; It is expected that Update() with full-update was called before. Bool_t LoopToVertex(TEveVector& v, TEveVector& p); Propagate charged particle with momentum p to vertex v.; It is expected that Update() with full-update was called before. Bool_t LineToVertex(TEveVector& v); Propagate neutral particle to vertex v. void LineToBounds(TEv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveTrackPropagator.html:25574,charge,charge,25574,root/html528/TEveTrackPropagator.html,https://root.cern,https://root.cern/root/html528/TEveTrackPropagator.html,1,['charge'],['charge']
Energy Efficiency,"olor(Int_t color) Select line color by ROOT color code, default is blue . LineWidth(Int_t width) Select line with in pixels, default is 3 . FillStyle(Int_t style) Select fill style, default is not filled. If a filled style is selected, also use VLines() to add vertical downward lines at end of curve to ensure proper closure . FillColor(Int_t color) Select fill color by ROOT color code . Range(const char* name) Only draw curve in range defined by given name. Multiple comma-separated ranges can be given. An empty string """" or nullptr means to use the default range of the variable. . Range(double lo, double hi) Only draw curve in specified range . VLines() Add vertical lines to y=0 at end points of curve . Precision(double eps) Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. A higher precision will result in more and more densely spaced curve points. A negative precision value will disable adaptive point spacing and restrict sampling to the grid point of points defined by the binning of the plotted observable (recommended for expensive functions such as profile likelihoods) . Invisible(bool flag) Add curve to frame, but do not display. Useful in combination AddTo() . VisualizeError(const RooFitResult& fitres, double Z=1, bool linearMethod=true) Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma. The linear method is fast but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much) longer to calculate NoteTo include the uncertainty from the expected number of events, the Normalization() argument with ScaleType RooAbsReal::RelativeExpected has to be passed, e.g. pdf.plotOn(frame, VisualizeError(fitResult), Normalization(1.0, RooAbsReal::RelativeExpected));; RooAbsReal::RelativeExpected@ RelativeExpectedDefinition Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimultaneous.html:96411,adapt,adaptive,96411,doc/master/classRooSimultaneous.html,https://root.cern,https://root.cern/doc/master/classRooSimultaneous.html,2,['adapt'],['adaptive']
Energy Efficiency,"olors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].green = 235; colors[26].blue = 235;; 93 colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate memory for segments; 99 */; 100 ; 101 if (gSize3D.numSegs) {; 102 segs = (segment *) calloc (gSize3D.numSegs, sizeof (segment));; 103 if (!segs) {; 104 puts (""Unable to allocate memory for segments !"");; 105 ret = 0;; 106 }; 107 }; 108 ; 109 ; 110 /*; 111 * Allocate memory for polygons; 112 */; 113 ; 114 if (gSize3D.numPolys) {; 115 polys = (polygon *) calloc(gSize3D.numPolys, sizeof (polygon));; 116 if (!polys) {; 117 puts (""Unable to allocate memory for polygons !"");; 118 ret = 0;; 119 }; 120 }; 12",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/X3DBuffer_8c_source.html:3192,green,green,3192,doc/master/X3DBuffer_8c_source.html,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html,1,['green'],['green']
Energy Efficiency,olume ; Definition at line 179 of file MethodPDERS.h. ◆ fDeltaFrac. Float_t TMVA::MethodPDERS::fDeltaFrac. private . fraction of RMS ; Definition at line 185 of file MethodPDERS.h. ◆ fFcnCall. Int_t TMVA::MethodPDERS::fFcnCall. protected . Definition at line 113 of file MethodPDERS.h. ◆ fGaussSigma. Double_t TMVA::MethodPDERS::fGaussSigma. private . size of Gauss in adaptive volume ; Definition at line 186 of file MethodPDERS.h. ◆ fGaussSigmaNorm. Double_t TMVA::MethodPDERS::fGaussSigmaNorm. private . size of Gauss in adaptive volume (normalised to dimensions) ; Definition at line 187 of file MethodPDERS.h. ◆ fHelpVolume. Volume* TMVA::MethodPDERS::fHelpVolume. protected . Definition at line 112 of file MethodPDERS.h. ◆ fInitializedVolumeEle. Bool_t TMVA::MethodPDERS::fInitializedVolumeEle. private . is volume element initialized ? ; Definition at line 197 of file MethodPDERS.h. ◆ fInitialScale. Float_t TMVA::MethodPDERS::fInitialScale. private . initial scale for adaptive volume ; Definition at line 195 of file MethodPDERS.h. ◆ fKernelEstimator. enum TMVA::MethodPDERS::EKernelEstimator TMVA::MethodPDERS::fKernelEstimator. private . ◆ fKernelString. TString TMVA::MethodPDERS::fKernelString. private . Definition at line 149 of file MethodPDERS.h. ◆ fkNNMax. Int_t TMVA::MethodPDERS::fkNNMax. private . max number of events in kNN tree ; Definition at line 200 of file MethodPDERS.h. ◆ fkNNMin. Int_t TMVA::MethodPDERS::fkNNMin. private . min number of events in kNN tree ; Definition at line 199 of file MethodPDERS.h. ◆ fMax_distance. Double_t TMVA::MethodPDERS::fMax_distance. private . maximum distance ; Definition at line 202 of file MethodPDERS.h. ◆ fMaxVIterations. Float_t TMVA::MethodPDERS::fMaxVIterations. private . maximum number of iterations to adapt volume size ; Definition at line 194 of file MethodPDERS.h. ◆ fNEventsMax. Float_t TMVA::MethodPDERS::fNEventsMax. private . maximum number of events in adaptive volume ; Definition at line 193 of file MethodPDERS.h.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodPDERS.html:45769,adapt,adaptive,45769,doc/master/classTMVA_1_1MethodPDERS.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodPDERS.html,1,['adapt'],['adaptive']
Energy Efficiency,"olumns(2)); 892 ; 893# With keyword arguments:; 894params.printLatex(Sibling=initParams, Columns =2); 895\endcode; 896\htmlonly; 897</div>; 898\endhtmlonly; 899 ; 900\fn RooAbsCollection::printLatex(const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 901\brief \parblock \endparblock; 902\htmlonly; 903<div class=""pyrootbox"">; 904\endhtmlonly; 905## PyROOT; 906The RooAbsCollection::printLatex() function is pythonized with the command argument pythonization.; 907The keywords must correspond to the CmdArgs of the function.; 908\htmlonly; 909</div>; 910\endhtmlonly; 911 ; 912\class RooAbsData; 913\brief \parblock \endparblock; 914\htmlonly; 915<div class=""pyrootbox"">; 916\endhtmlonly; 917## PyROOT; 918Some member functions of RooAbsData that take a RooCmdArg as argument also support keyword arguments.; 919This applies to RooAbsData::plotOn, RooAbsData::createHistogram, RooAbsData::reduce, RooAbsData::statOn.; 920For example, the following code is equivalent in PyROOT:; 921\code{.py}; 922# Directly passing a RooCmdArg:; 923data.plotOn(frame, ROOT.RooFit.CutRange(""r1"")); 924 ; 925# With keyword arguments:; 926data.plotOn(frame, CutRange=""r1""); 927\endcode; 928\htmlonly; 929</div>; 930\endhtmlonly; 931 ; 932\fn RooAbsData::createHistogram(const char *name, const RooAbsRealLValue& xvar, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 933\brief \parblock \endparblock; 934\htmlonly; 935<div class=""pyrootbox"">; 936\endhtmlonly; 937## PyROOT; 938The RooAbsData::createHistogram() function is pythonized with the command argument pythonization.; 939The keywords must correspond to the CmdArgs of the function.; 940\htmlonly; 941</div>; 942\endhtmlonly; 943 ; 944\fn RooAbsData::plotOn(RooPlot* frame, const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/__roofit_8pyzdoc_source.html:45560,reduce,reduce,45560,doc/master/__roofit_8pyzdoc_source.html,https://root.cern,https://root.cern/doc/master/__roofit_8pyzdoc_source.html,1,['reduce'],['reduce']
Energy Efficiency,"om TProofPlayer; static THashList * fgDrawInputPars = 0;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . #include <TProofPlayer.h>. Inheritance diagram for TProofPlayerRemote:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TProofPlayerRemote(). TProofPlayerRemote::TProofPlayerRemote ; (; TProof * ; proof = 0). inline . Definition at line 313 of file TProofPlayer.h. ◆ ~TProofPlayerRemote(). TProofPlayerRemote::~TProofPlayerRemote ; (; ). override . Destructor. ; Definition at line 1899 of file TProofPlayer.cxx. Member Function Documentation. ◆ AddOutput(). void TProofPlayerRemote::AddOutput ; (; TList * ; out). overridevirtual . Incorporate the content of the received output list 'out' into the final output list fOutput. ; The latter is created if not existing. This method short cuts 'StoreOutput + MergeOutput' limiting the memory consumption. ; Reimplemented from TProofPlayer.; Definition at line 3507 of file TProofPlayer.cxx. ◆ AddOutputObject(). Int_t TProofPlayerRemote::AddOutputObject ; (; TObject * ; obj). overridevirtual . Incorporate the received object 'obj' into the output list fOutput. ; The latter is created if not existing. This method short cuts 'StoreOutput + MergeOutput' optimizing the memory consumption. Returns -1 in case of error, 1 if the object has been merged into another one (so that its ownership has not been taken and can be deleted), and 0 otherwise. ; Reimplemented from TProofPlayer.; Definition at line 3344 of file TProofPlayer.cxx. ◆ Class(). static TClass * TProofPlayerRemote::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TProofPlayerRemote::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TProofPlayerRemote::Class_Version ; (; ). inlinestaticconstexp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerRemote.html:26240,consumption,consumption,26240,doc/master/classTProofPlayerRemote.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerRemote.html,1,['consumption'],['consumption']
Energy Efficiency,"om TVirtualX.; Definition at line 6573 of file TGWin32.cxx. ◆ SetOpacity(). void TGWin32::SetOpacity ; (; Int_t ; percent). overridevirtual . Set opacity of a window. ; This image manipulation routine works by adding to a percent amount of neutral to each pixels RGB. Since it requires quite some additional color map entries is it only supported on displays with more than > 8 color planes (> 256 colors) ; Reimplemented from TVirtualX.; Definition at line 3958 of file TGWin32.cxx. ◆ SetPrimarySelectionOwner(). void TGWin32::SetPrimarySelectionOwner ; (; Window_t ; id). overridevirtual . Makes the window id the current owner of the primary selection. ; That is the window in which, for example some text is selected. ; Reimplemented from TVirtualX.; Definition at line 6828 of file TGWin32.cxx. ◆ SetRGB(). void TGWin32::SetRGB ; (; Int_t ; cindex, . Float_t ; r, . Float_t ; g, . Float_t ; b . ). overridevirtual . Set color intensities for given color index. ; cindex : color index r,g,b : red, green, blue intensities between 0.0 and 1.0 ; Reimplemented from TVirtualX.; Definition at line 4097 of file TGWin32.cxx. ◆ SetSelectionOwner(). Bool_t TGWin32::SetSelectionOwner ; (; Window_t ; owner, . Atom_t & ; sel . ). overridevirtual . Assigns owner of Clipboard. ; Reimplemented from TVirtualX.; Definition at line 7681 of file TGWin32.cxx. ◆ SetTextAlign(). void TGWin32::SetTextAlign ; (; Short_t ; talign = 11). overridevirtual . Set text alignment. ; txalh : horizontal text alignment txalv : vertical text alignment ; Reimplemented from TAttText.; Definition at line 4134 of file TGWin32.cxx. ◆ SetTextColor(). void TGWin32::SetTextColor ; (; Color_t ; cindex). overridevirtual . Set color index for text. ; Reimplemented from TAttText.; Definition at line 4194 of file TGWin32.cxx. ◆ SetTextFont() [1/2]. Int_t TGWin32::SetTextFont ; (; char * ; fontname, . ETextSetMode ; mode . ). overridevirtual . Set text font to specified name. ; mode : loading flag mode=0 : search if the font ex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32.html:112208,green,green,112208,doc/master/classTGWin32.html,https://root.cern,https://root.cern/doc/master/classTGWin32.html,1,['green'],['green']
Energy Efficiency,"ome major probability density functions in ROOT. ;  ; file  mathcoreStatFunc.py;   Example macro showing some major probability density functions in ROOT. ;  ; file  mathcoreVectorCollection.C;   Example showing how to write and read a std vector of ROOT::Math LorentzVector in a ROOT tree. ;  ; file  mathcoreVectorFloatIO.C;   Macro illustrating I/O with Lorentz Vectors of floats The dictionary for LorentzVector of float is not in the libMathCore, therefore is generated when parsed the file with CLING. ;  ; file  mathcoreVectorIO.C;   Example of I/O of a mathcore Lorentz Vectors in a Tree and comparison with a TLorentzVector. ;  ; file  mathGammaNormal.C;   Tutorial illustrating the use of TMath::GammaDist and TMath::LogNormal ;  ; file  mathLaplace.C;   Test the TMath::LaplaceDist and TMath::LaplaceDistI functions ;  ; file  mathmoreIntegration.C;   Example on the usage of the adaptive 1D integration algorithm of MathMore it calculates the numerically cumulative integral of a distribution (like in this case the BreitWigner) to execute the macro type it (you need to compile with AClic) ;  ; file  mathmoreIntegrationMultidim.C;   Example on the usage of the multidimensional integration algorithm of MathMore Please refer to the web documentation for further details: https://root.cern/manual/math/#numerical-integration To execute the macro type the following: ;  ; file  mathStudent.C;   Tutorial illustrating the use of the Student and F distributions ;  ; file  multidimSampling.C;   Example of sampling a multi-dim distribution using the DistSampler class NOTE: This tutorial must be run with ACLIC ;  ; file  multivarGaus.C;   Tutorial illustrating the multivariate gaussian random number generation ;  ; file  normalDist.C;   Tutorial illustrating the new statistical distributions functions (pdf, cdf and quantile) ;  ; file  normalDist.py;   Tutorial illustrating the new statistical distributions functions (pdf, cdf and quantile) ;  ; file  permute.C;   Tutorial illustrat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__math.html:3680,adapt,adaptive,3680,doc/master/group__tutorial__math.html,https://root.cern,https://root.cern/doc/master/group__tutorial__math.html,1,['adapt'],['adaptive']
Energy Efficiency,"omentum ---; 297 // apply momentum before computing the new gradient; 298 auto itPrevG = begin (m_prevGradients);; 299 auto itPrevGEnd = end (m_prevGradients);; 300 auto itLocWeight = begin (m_localWeights);; 301 for (; itPrevG != itPrevGEnd; ++itPrevG, ++itLocWeight); 302 {; 303 (*itPrevG) *= m_beta;; 304 (*itLocWeight) += (*itPrevG);; 305 }; 306 ; 307 E = fitnessFunction (passThrough, m_localWeights, m_localGradients);; 308// plotGradients (gradients);; 309// plotWeights (localWeights);; 310 ; 311 double alpha = gaussDouble (m_alpha, m_alpha/2.0);; 312// double alpha = m_alpha;; 313 ; 314 auto itG = begin (m_localGradients);; 315 auto itGEnd = end (m_localGradients);; 316 itPrevG = begin (m_prevGradients);; 317 double maxGrad = 0.0;; 318 for (; itG != itGEnd; ++itG, ++itPrevG); 319 {; 320 double currGrad = (*itG);; 321 double prevGrad = (*itPrevG);; 322 currGrad *= alpha;; 323 ; 324 //(*itPrevG) = m_beta * (prevGrad + currGrad);; 325 currGrad += prevGrad;; 326 (*itG) = currGrad;; 327 (*itPrevG) = currGrad;; 328 ; 329 if (std::fabs (currGrad) > maxGrad); 330 maxGrad = currGrad;; 331 }; 332 ; 333 if (maxGrad > 1); 334 {; 335 m_alpha /= 2;; 336 std::cout << ""\nlearning rate reduced to "" << m_alpha << std::endl;; 337 std::for_each (weights.begin (), weights.end (), [maxGrad](double& w); 338 {; 339 w /= maxGrad;; 340 });; 341 m_prevGradients.clear ();; 342 }; 343 else; 344 {; 345 auto itW = std::begin (weights);; 346 std::for_each (std::begin (m_localGradients), std::end (m_localGradients), [&itW](double& g); 347 {; 348 *itW += g;; 349 ++itW;; 350 });; 351 }; 352 ; 353 ++currentRepetition;; 354 }; 355 return E;; 356 }; 357 ; 358 ; 359 ; 360 ; 361 ; 362 ; 363 ; 364 ; 365 ; 366 ; 367 ; 368 ; 369 ; 370 ; 371 ; 372 ; 373 ; 374 ; 375 ; 376 ; 377/*! \brief sum of squares error function; 378 *; 379 *; 380 */; 381 template <typename ItOutput, typename ItTruth, typename ItDelta, typename InvFnc>; 382 double sumOfSquares (ItOutput itOutputBegin, ItOutput itOutputEnd, ItTruth itT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:10257,reduce,reduced,10257,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['reduce'],['reduced']
Energy Efficiency,"omepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTRealComplex. class TFFTRealComplex: public TVirtualFFT. TFFTRealComplex. One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes a real input/complex output discrete Fourier transform in 1 or more; dimensions. However, only out-of-place transforms are now supported for transforms; in more than 1 dimension. For detailed information about the computed transforms,; please refer to the FFTW manual. How to use it:; 1) Create an instance of TFFTRealComplex - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings (see function; comments for possible kind parameters); 3) Set the data (via SetPoints()or SetPoint() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints() or GetPoint() functions); 6) Repeat steps 3)-5) as needed; For a transform of the same size, but with different flags,; rerun the Init() function and continue with steps 3)-5). NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. Function Members (Methods); public:. TFFTRealComplex(); TFFTRealComplex(const TFFTRealComplex&); TFFTRealComplex(Int_t n, Bool_t inPlace); TFFTRealComplex(Int_t ndim, Int_t* n, Bool_t inPlace); virtual~TFFTRealComplex(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFFTRealComplex.html:825,allocate,allocate,825,root/html528/TFFTRealComplex.html,https://root.cern,https://root.cern/root/html528/TFFTRealComplex.html,4,['allocate'],['allocate']
Energy Efficiency,"omepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTRealComplex. class TFFTRealComplex: public TVirtualFFT. TFFTRealComplex. One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes a real input/complex output discrete Fourier transform in 1 or more; dimensions. However, only out-of-place transforms are now supported for transforms; in more than 1 dimension. For detailed information about the computed transforms,; please refer to the FFTW manual. How to use it:; 1) Create an instance of TFFTRealComplex - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings (see function; comments for possible kind parameters); 3) Set the data (via SetPoints()or SetPoint() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints() or GetPoint() functions); 6) Repeat steps 3)-5) as needed; For a transform of the same size, but with different flags,; rerun the Init() function and continue with steps 3)-5). NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. Function Members (Methods); public:. virtual~TFFTRealComplex(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFFTRealComplex.html:825,allocate,allocate,825,root/html602/TFFTRealComplex.html,https://root.cern,https://root.cern/root/html602/TFFTRealComplex.html,2,['allocate'],['allocate']
Energy Efficiency,"ompression algorithm (0=old zlib, 1=new zlib). Setting this to `0’ may be a security vulnerability.; Root.ZipMode: 1; Show where item is found in the specified path:; Root.ShowPath: false; Activate memory statistics.; Root.ObjectStat: 0; Global debug mode. When >0 turns on progressively more details debugging.; Root.Debug: 0; Root.Stacktrace: yes; Settings for X11 behaviour.; X11.Sync: no; X11.FindBestVisual: yes; Default editor in use.; Unix.*.Editor: vi; WinNT.*.Editor: notepad; Default 3d Viewer. By default 3-D views are shown in the pad, if the next line is activated, the default viewer will be OpenGL.; Viewer3D.DefaultDrawOption: ogl; Default Fitter (current choices are Minuit, Minuit2, Fumili and Fumili2).; Root.Fitter: Minuit; Specify list of file endings which TTabCom (TAB completion) should ignore.; TabCom.FileIgnore: .cpp:.h:.cmz; 28.6.1 TCanvas Specific Settings; Opaque move and resize show full pad during the operation instead of only the outline. Especially for resize you will need serious CPU power. UseScreenFactor=true means to size canvas according to size of screen, so a canvas still looks good on a low resolution laptop screen without having to change canvas size in macros.; Canvas.MoveOpaque: false; Canvas.ResizeOpaque: false; Canvas.UseScreenFactor: true; Hight color 2 is the red one.; Canvas.HighLightColor: 2; Next three settings are related to different user interface parts of canvas window. If they are set to true, the corresponding event status bar, tool bar, graphics editor will be activated by default.; Canvas.ShowEventStatus: false; Canvas.ShowToolBar: false; Canvas.ShowEditor: false; AutoExec allows TExec objects to be executed on mouse and key events.; Canvas.AutoExec: true; Canvas print directory is set to the current one by default:; Canvas.PrintDirectory .; Printer settings:; WinNT.*.Print.Command: AcroRd32.exe; #Unix.*.Print.Command: a2ps -P%p --landscape --columns=2 --margin=30 -rf8.0 %f; Print.Printer: 32-rb20-hp; Print.Directory: .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1256317,power,power,1256317,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['power'],['power']
Energy Efficiency,"omputes the complementary error function erfc(x). ; Erfc(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between x and infinity ; Definition at line 199 of file TMath.cxx. ◆ ErfcInverse(). Double_t TMath::ErfcInverse ; (; Double_t ; x). Returns the inverse of the complementary error function. ; x must be 0<x<2 implement using the quantile of the normal distribution instead of ErfInverse for better numerical precision for large x ; Definition at line 242 of file TMath.cxx. ◆ ErfInverse(). Double_t TMath::ErfInverse ; (; Double_t ; x). Returns the inverse error function. ; x must be <-1<x<1 ; Definition at line 208 of file TMath.cxx. ◆ EulerGamma(). constexpr Double_t TMath::EulerGamma ; (; ). constexpr . Euler-Mascheroni Constant. ; Definition at line 332 of file TMath.h. ◆ Even(). Bool_t TMath::Even ; (; Long_t ; a). inline . Returns true if a is even. ; Definition at line 113 of file TMathBase.h. ◆ Exp(). Double_t TMath::Exp ; (; Double_t ; x). inline . Returns the base-e exponential function of x, which is e raised to the power x. ; Definition at line 709 of file TMath.h. ◆ Factorial(). Double_t TMath::Factorial ; (; Int_t ; i). Computes factorial(n). ; Definition at line 252 of file TMath.cxx. ◆ FDist(). Double_t TMath::FDist ; (; Double_t ; F, . Double_t ; N, . Double_t ; M . ). Computes the density function of F-distribution (probability function, integral of density, is computed in FDistI). ; Parameters N and M stand for degrees of freedom of chi-squares mentioned above parameter F is the actual variable x of the density function p(x) and the point at which the density function is calculated. About F distribution:; F-distribution arises in testing whether two random samples have the same variance. It is the ratio of two chi-square distributions, with N and M degrees of freedom respectively, where each chi-square is first divided by it's number of degrees of freedom.; AuthorAnna Kreshuk ; Definition at line 2277 of file TMath.cxx. ◆ FDistI(). Double_t TMath::FDistI ; (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:39929,power,power,39929,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['power'],['power']
Energy Efficiency,"omputes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(IParamFunction & f, double x, const double * p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for one-dim parameteric function; at the point ( x,p[]) with respect the parameter p_ipar. double Eval(IParamMultiFunction & f, const double * x, const double * ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__Derivator.html:4810,adapt,adaptive,4810,root/html526/ROOT__Math__Derivator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__Derivator.html,1,['adapt'],['adaptive']
Energy Efficiency,"omputes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(ROOT::Math::IParamFunction& f, double x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for one-dim parameteric function; at the point ( x,p[]) with respect the parameter p_ipar. double Eval(ROOT::Math::IParamMultiFunction& f, const double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__Derivator.html:4810,adapt,adaptive,4810,root/html528/ROOT__Math__Derivator.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__Derivator.html,4,['adapt'],['adaptive']
Energy Efficiency,on TTree.h:244; TTree::kClassMismatch@ kClassMismatchDefinition TTree.h:237; TTree::kNeedDisableDecomposedObj@ kNeedDisableDecomposedObjDefinition TTree.h:245; TTree::kVoidPtr@ kVoidPtrDefinition TTree.h:242; TTree::kNoCheck@ kNoCheckDefinition TTree.h:243; TTree::kMatchConversionCollection@ kMatchConversionCollectionDefinition TTree.h:240; TTree::kMissingCompiledCollectionProxy@ kMissingCompiledCollectionProxyDefinition TTree.h:235; TTree::kMismatch@ kMismatchDefinition TTree.h:236; TTree::kMatchConversion@ kMatchConversionDefinition TTree.h:239; TTree::kInternalError@ kInternalErrorDefinition TTree.h:234; TTree::kDecomposedObjMask@ kDecomposedObjMaskDefinition TTree.h:246; TTree::kMatch@ kMatchDefinition TTree.h:238; TTree::kMissingBranch@ kMissingBranchDefinition TTree.h:233; TTree::kMakeClass@ kMakeClassDefinition TTree.h:241; TTree::fgBranchStylestatic Int_t fgBranchStyleOld/New branch style.Definition TTree.h:154; TTree::ResetBranchAddressesvirtual void ResetBranchAddresses()Tell all of our branches to drop their current objects and allocate new ones.Definition TTree.cxx:8075; TTree::fNfillInt_t fNfill! Local for EntryLoopDefinition TTree.h:110; TTree::SetNamevoid SetName(const char *name) overrideChange the name of this tree.Definition TTree.cxx:9205; TTree::GetCacheSizevirtual Long64_t GetCacheSize() constDefinition TTree.h:453; TTree::RegisterExternalFriendvirtual void RegisterExternalFriend(TFriendElement *)Record a TFriendElement that we need to warn when the chain switches to a new file (typically this is...Definition TTree.cxx:7957; TTree::fIndexTArrayI fIndexIndex of sorted values.Definition TTree.h:128; TTree::GetPacketSizevirtual Int_t GetPacketSize() constDefinition TTree.h:545; TTree::SetCacheSizevirtual Int_t SetCacheSize(Long64_t cachesize=-1)Set maximum size of the file cache .Definition TTree.cxx:8683; TTree::AddClonevoid AddClone(TTree *)Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when...Def,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:88405,allocate,allocate,88405,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['allocate'],['allocate']
Energy Efficiency,"on at line 448 of file TGColorDialog.cxx. Member Function Documentation. ◆ AllocColors(). void TGColorPick::AllocColors ; (; ). protected . Try to allocate first a palette of 64 colors. ; Used by the dithered version of the color maps. ; Definition at line 541 of file TGColorDialog.cxx. ◆ Class(). static TClass * TGColorPick::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGColorPick::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGColorPick::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 131 of file TGColorDialog.h. ◆ ColorSelected(). virtual void TGColorPick::ColorSelected ; (; Pixel_t ; col = 0). inlinevirtual . Definition at line 128 of file TGColorDialog.h. ◆ CreateDitheredImage(). void TGColorPick::CreateDitheredImage ; (; Pixmap_t ; image, . Int_t ; which . ). protected . Create a dithered version of the color map and lightness images for display modes with reduced number of colors. ; The Floyd-Steinberg error diffusion dithering algorithm is used. This routine is called in PseudoColor modes only. ; Definition at line 642 of file TGColorDialog.cxx. ◆ CreateImages(). void TGColorPick::CreateImages ; (; ). protected . Create colormap and color slider images. ; Definition at line 525 of file TGColorDialog.cxx. ◆ DeclFileName(). static const char * TGColorPick::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 131 of file TGColorDialog.h. ◆ DoRedraw(). void TGColorPick::DoRedraw ; (; ). overrideprotectedvirtual . Redraw the color pick widget. ; Reimplemented from TGWindow.; Definition at line 913 of file TGColorDialog.cxx. ◆ DrawHScursor(). void TGColorPick::DrawHScursor ; (; Int_t ; onoff). protected . Draw hue / saturation cursor. ; Definition at line 988 of file TGColorDialog.cxx. ◆ DrawLcursor(). void TGColorPick::DrawLcursor ; (; Int_t ; onoff)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGColorPick.html:32265,reduce,reduced,32265,doc/master/classTGColorPick.html,https://root.cern,https://root.cern/doc/master/classTGColorPick.html,1,['reduce'],['reduced']
Energy Efficiency,"on checking. In order to check a given point, CheckPoint(x,y,z) method of TGeoManager draws the daughters of the volume containing the point one level down, printing the path to the deepest physical node holding this point. It also computes the closest distance to any boundary. Random points. A method to check the validity of a given geometry is shooting random points. This can be called with the method TGeoVolume::RandomPoints() and it draws a volume with the current visualization settings. Random points are generated in the bounding box of the drawn volume. The points are drawn with the color of their deepest container. Only points inside visible nodes are drawn. Random rays. A ray tracing method can be called TGeoVolume::RandomRays(). This shoots rays from a given point in the local reference frame with random directions. The intersections with displayed nodes appear as segments having the color of the touched node.; 18.7 The Drawing Package; The modeller provides a powerful drawing package, supporting several different options of visualization. A library separated from the main one provides all functionality being linked with the underlying ROOT visualization system. This library is dynamically loaded by the plug-in manager only when drawing features are requested. The geometrical structures that can be visualized are volumes and volume hierarchies.; The main component of the visualization system is volume primitive painting in a ROOT pad. Starting from this one, several specific options or subsystems are available, like: X3D viewing using hidden line and surface removal algorithms, OpenGL viewing* or ray tracing.; The method TGeoManager::GetGeomPainter()loads the painting library in memory.; This is generally not needed since it is called automatically by TGeoVolume::Draw() as well as by few other methods setting visualization attributes.; 18.7.1 Drawing Volumes and Hierarchies of Volumes; The first thing one would like to do after building some geometry is to v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1004375,power,powerful,1004375,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['power'],['powerful']
Energy Efficiency,"on documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMonitor.html:11045,monitor,monitor,11045,root/html528/TMonitor.html,https://root.cern,https://root.cern/root/html528/TMonitor.html,6,['monitor'],['monitor']
Energy Efficiency,"on in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IGradientFunctionOneDim::BaseGrad, ROOT::Math::WrappedTF1::IGrad. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientOneDim(); doubleDerivative(double x) const; doubleDerivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidFdF(const double* x, double& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double * x, double & f, double * df). Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x ). Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double & f, double & df). Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more effi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IGradientOneDim.html:1860,efficient,efficient,1860,root/html526/ROOT__Math__IGradientOneDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IGradientOneDim.html,1,['efficient'],['efficient']
Energy Efficiency,"on in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IGradientFunctionOneDim::BaseGrad, ROOT::Math::WrappedTF1::IGrad. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientOneDim(); doubleDerivative(double x) const; doubleDerivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidFdF(const double* x, double& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x) const. Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is oft",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__IGradientOneDim.html:1862,efficient,efficient,1862,root/html534/ROOT__Math__IGradientOneDim.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientOneDim.html,1,['efficient'],['efficient']
Energy Efficiency,"on in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::WrappedTF1::IGrad, ROOT::Math::IGradientFunctionOneDim::BaseGrad. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientOneDim(); doubleDerivative(double x) const; doubleDerivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidFdF(const double* x, double& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x) const. Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is oft",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IGradientOneDim.html:1860,efficient,efficient,1860,root/html528/ROOT__Math__IGradientOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IGradientOneDim.html,3,['efficient'],['efficient']
Energy Efficiency,"on is only called via; the ROOT custom new operators. void RemoveStat(void* p); Register a memory free operation. This function is only called via; the custom ROOT delete operator. void * Alloc(size_t size); Allocate a block of memory, that later can be resized using; TStorage::ReAlloc(). void Dealloc(void* ptr); De-allocate block of memory, that was allocated via TStorage::Alloc(). void * ReAlloc(void* vp, size_t size); Reallocate (i.e. resize) block of memory. void * ReAlloc(void* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) block of memory. Checks if current size is; equal to oldsize. If not memory was overwritten. char * ReAllocChar(char* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of chars. Size and oldsize are; in number of chars. Int_t * ReAllocInt(Int_t* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of integers. Size and oldsize are; number of integers (not number of bytes). void * ObjectAlloc(size_t size); Used to allocate a TObject on the heap (via TObject::operator new()).; Directly after this routine one can call (in the TObject ctor); TStorage::IsOnHeap() to find out if the just created object is on; the heap. void * ObjectAlloc(size_t size, void* vp); Used to allocate a TObject on the heap (via TObject::operator new(size_t,void*)); in position vp. vp is already allocated (maybe on heap, maybe on; stack) so just return. void ObjectDealloc(void* vp); Used to deallocate a TObject on the heap (via TObject::operator delete()). void ObjectDealloc(void* vp, void* ptr); Used to deallocate a TObject on the heap (via TObject::operator delete(void*,void*)). void SetFreeHook(FreeHookFun_t func, void* data); Set a free handler. void SetReAllocHooks(ReAllocFun_t func1, ReAllocCFun_t func2); Set a custom ReAlloc handlers. This function is typically; called via a static object in the ROOT libNew.so shared library. void PrintStatistics(); Print memory usage statistics. void EnableStatistics(int size = -1, int ix = -1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStorage.html:4312,allocate,allocate,4312,root/html528/TStorage.html,https://root.cern,https://root.cern/root/html528/TStorage.html,3,['allocate'],['allocate']
Energy Efficiency,"on matrix and the; global correlation coefficients from the MINUIT memory buffer and; fill the internal arrays. Bool_t isIdentical(const RooFitResult& other, Double_t tol = 5.0000000000000002E-5, Double_t tolCorr = 1.0E-4, Bool_t verbose = kTRUE) const; Return true if this fit result is identical to other within tolerance 'tol' on fitted values; and tolerance 'tolCor' on correlation coefficients. RooFitResult* lastMinuitFit(const RooArgList& varList = RooArgList()); Import the results of the last fit performed by gMinuit, interpreting; the fit parameters as the given varList of parameters. void setCovarianceMatrix(TMatrixDSym& V); Store externally provided correlation matrix in this RooFitResult ;. TH2* correlationHist(const char* name = ""correlation_matrix"") const; Return TH2D of correlation matrix. const TMatrixDSym& covarianceMatrix() const; Return covariance matrix. TMatrixDSym reducedCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix (Note that Vred _is_ a simple sub-matrix of V,; row/columns are ordered to matched the convention given in input argument 'params'. TMatrixDSym conditionalCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix, which is calculated as; ___ -1; Vred = V22 = V11 - V12 * V22 * V21. Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; is the Shur complement of V22, calculated as shown above. (Note that Vred is _not_ a simple sub-matrix of V). const TMatrixDSym& correlationMatrix() const; Return correlation matrix ;. RooAbsPdf* createHessePdf(const RooArgSet& params) const; Return a p.d.f that represents the fit result as a multi-variate probability densisty; function on the floating fit parameters, including correlations. void SetName(const char* name); Change name of RooFitResult object. void SetNameTitle(const char* name, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFitResult.html:15850,reduce,reducedCovarianceMatrix,15850,root/html602/RooFitResult.html,https://root.cern,https://root.cern/root/html602/RooFitResult.html,4,['reduce'],"['reduced', 'reducedCovarianceMatrix']"
Energy Efficiency,"on that depends on external RooAbsReal objects ;  CRooParametricStepFunctionThe Parametric Step Function PDF is a binned distribution whose parameters are the heights of each bin ;  CRooParamHistFunc;  ►CRooPlotA RooPlot is a plot frame and a container for graphics objects within that frame ;  CDrawOpt;  CRooPlotableClass RooPotable is a base class for objects that can be inserted into RooPlots and take advantage of its internal normalization and axis range adjustment features ;  CRooPoissonPoisson pdf ;  CRooPolynomialRooPolynomial implements a polynomial p.d.f of the form ;  CRooPolyVarClass RooPolyVar is a RooAbsReal implementing a polynomial in terms of a list of RooAbsReal coefficients ;  CRooPrintableRooPlotable is a 'mix-in' base class that define the standard RooFit plotting and printing methods ;  CRooProdGenContextRooProdGenContext is an efficient implementation of the generator context specific for RooProdPdf PDFs ;  ►CRooProdPdfRooProdPdf is an efficient implementation of a product of PDFs of the form ;  CCacheElem;  ►CRooProductRooProduct a RooAbsReal implementation that represent the product of a given set of other RooAbsReal objects ;  CCacheElem;  CRooProfileLLClass RooProfileLL implements the profile likelihood estimator for a given likelihood and set of parameters of interest ;  ►CRooProjectedPdfClass RooProjectedPdf is a RooAbsPdf implementation that represent a projection of a given input p.d.f and the object returned by RooAbsPdf::createProjection ;  CCacheElem;  CRooProofDriverSelector;  CRooPullVarClass RooPullVar represents the pull of measurement w.r.t to true value using the measurement value and its error ;  CRooQuasiRandomGeneratorThis class generates the quasi-random (aka ""low discrepancy"") sequence for dimensions up to 12 using the Niederreiter base 2 algorithm described in Bratley, Fox, Niederreiter, ACM Trans ;  ►CRooRandomThis class provides a static interface for generating random numbers ;  CGuard;  ►CRooRandomizeParamMCSModuleRooRa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:123809,efficient,efficient,123809,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,2,['efficient'],['efficient']
Energy Efficiency,"on value for T by calling the appropriate `Reduce`; 1677 /// overload.; 1678 ///; 1679 /// ### Example usage:; 1680 /// ~~~{.cpp}; 1681 /// auto sumOfIntCol = d.Reduce([](int x, int y) { return x + y; }, ""intCol"");; 1682 /// ~~~; 1683 ///; 1684 /// This action is *lazy*: upon invocation of this method the calculation is; 1685 /// booked but not executed. Also see RResultPtr.; 1686 // clang-format on; 1687 template <typename F, typename T = typename TTraits::CallableTraits<F>::ret_type>; 1688 RResultPtr<T> Reduce(F f, std::string_view columnName = """"); 1689 {; 1690 static_assert(; 1691 std::is_default_constructible<T>::value,; 1692 ""reduce object cannot be default-constructed. Please provide an initialisation value (redIdentity)"");; 1693 return Reduce(std::move(f), columnName, T());; 1694 }; 1695 ; 1696 ////////////////////////////////////////////////////////////////////////////; 1697 /// \brief Execute a user-defined reduce operation on the values of a column.; 1698 /// \tparam F The type of the reduce callable. Automatically deduced.; 1699 /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; 1700 /// \param[in] f A callable with signature `T(T,T)`; 1701 /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; 1702 /// \param[in] redIdentity The reduced object of each thread is initialized to this value.; 1703 /// \return the reduced quantity wrapped in a RResultPtr.; 1704 ///; 1705 /// ### Example usage:; 1706 /// ~~~{.cpp}; 1707 /// auto sumOfIntColWithOffset = d.Reduce([](int x, int y) { return x + y; }, ""intCol"", 42);; 1708 /// ~~~; 1709 /// See the description of the first Reduce overload for more information.; 1710 template <typename F, typename T = typename TTraits::CallableTraits<F>::ret_type>; 1711 RResultPtr<T> Reduce(F f, std::string_view columnName, const T &redIdentity); 1712 {; 1713 return Aggregate(f, f, columnName, redIdentity);; 1714 }; 1715 ; 1716 //////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:95118,reduce,reduce,95118,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['reduce'],['reduce']
Energy Efficiency,"on with the SetData method.; In case the data size is not known, better using the default of zero or the next constructor later on.; The default interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continuous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The default interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id$ » Last generated: 2015-06-30 14:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__Interpolator.html:3164,efficient,efficient,3164,root/html602/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__Interpolator.html,1,['efficient'],['efficient']
Energy Efficiency,"on with the SetData method.; In case the data size is not known, better using the default of zero or the next constructor later on.; The default interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continuous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The default interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__Interpolator.html:3164,efficient,efficient,3164,root/html534/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__Interpolator.html,1,['efficient'],['efficient']
Energy Efficiency,"on with the SetData method.; In case the data size is not known, better using the default of zero or the next constructor later on.; The default interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continuous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The default interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__Interpolator.html:3164,efficient,efficient,3164,root/html604/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__Interpolator.html,1,['efficient'],['efficient']
Energy Efficiency,"on, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TVirtualPerfStats::EEventType { kUnDefined; kPacket; kStart; kStop; kFile; kFileOpen; kFileRead; kRate; kNumEventType; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Long64_tfBytesReadNumber of bytes read; Long64_tfBytesReadExtraNumber of bytes (overhead) of the readahead cache; Double_tfCompressTree compression factor ; Double_tfCpuTimeCpu time; Double_tfDiskTimeTime spent in pure raw disk IO; TFile*fFile!pointer to the file containing the Tree; TGraphErrors*fGraphIOpointer to the graph with IO data; TGraphErrors*fGraphTimepointer to the graph with timestamp info; TStringfHostInfoname of the host system, ROOT version and date; TText*fHostInfoTextGraphics Text object with the fHostInfo data; TStringfNamename of this TTreePerfStats; Int_tfNleavesNumber of leaves in the tree; TPaveText*fPavepointer to annotation pavetext; Int_tfReadCallsNumber of read calls; Int_tfReadaheadSizeReadahead cache size; Double_tfRealNormReal time scale factor for fGraphTime; Double_tfRealTimeReal time; TGaxis*fRealTimeAxispointer to TGaxis object showing real-time; TTree*fTree!pointer to the Tree being monitored; Int_tfTreeCacheSizeTTreeCache buffer size; Double_tfUnzipTimeTime spent uncompressing the data.; TStopwatch*fWatchTStopwatch pointer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreePerfStats(); default constructor (used when reading an object only). TTreePerfStats(const char* name, TTree* T); Create a TTree I/O perf stats object. ~TTreePerfStats(); Destructor. void Browse(TBrowser* b); Browse. Int_t DistancetoPrimitive(Int_t px, Int_t py); Return distance to one of the objects in the TTreePerfStats. void Draw(Option_t* opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreePerfStats.html:10303,monitor,monitored,10303,root/html530/TTreePerfStats.html,https://root.cern,https://root.cern/root/html530/TTreePerfStats.html,3,['monitor'],['monitored']
Energy Efficiency,"on; Int_tfYmaxlast fitted channel in y direction; Int_tfYminfirst fitted channel in y direction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSpectrum2Fit(); default constructor. TSpectrum2Fit(Int_t numberPeaks); numberPeaks: number of fitted peaks (must be greater than zero); the constructor allocates arrays for all fitted parameters (peak positions, amplitudes etc) and sets the member; variables to their default values. One can change these variables by member functions (setters) of TSpectrumFit class. . Shape function of the fitted; peaks contains the two-dimensional symmetrical Gaussian two one-dimensional; symmetrical Gaussian ridges as well as nonsymmetrical terms and background. ~TSpectrum2Fit(); destructor. Double_t Erfc(Double_t x). AUXILIARY FUNCTION. This function calculates error function of x. Double_t Derfc(Double_t x). AUXILIARY FUNCTION. This function calculates derivative of error function of x. Double_t Ourpowl(Double_t a, Int_t pw); power function. void StiefelInversion(Double_t** a, Int_t size). AUXILIARY FUNCTION. This function calculates solution of the system of linear equations.; The matrix a should have a dimension size*(size+4); The calling function should fill in the matrix, the column size should; contain vector y (right side of the system of equations). The result is; placed into size+1 column of the matrix.; according to sigma of peaks.; Function parameters:; -a-matrix with dimension size*(size+4) //; -size-number of rows of the matrix. Double_t Shape2(Int_t numOfFittedPeaks, Double_t x, Double_t y, const Double_t* parameter, Double_t sigmax, Double_t sigmay, Double_t ro, Double_t a0, Double_t ax, Double_t ay, Double_t txy, Double_t sxy, Double_t tx, Double_t ty, Double_t sx, Double_t sy, Double_t bx, Double_t by). AUXILIARY FUNCTION. This function calculates 2D peaks shape function (see manual); Function parameters:; -numOfFittedPeaks-number of fitted peaks; -x-channel in x-dimension; -y-c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Fit.html:22862,power,power,22862,root/html528/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html,4,['power'],['power']
Energy Efficiency,"onProxy__StagingCopyIterator(void *dest, const void *source); 1581{; 1582 *(void**)dest = *(void**)source;; 1583 return dest;; 1584}; 1585 ; 1586////////////////////////////////////////////////////////////////////////////////; 1587/// Nothing to do; 1588 ; 1589void TGenCollectionProxy__StagingDeleteSingleIterators(void *); 1590{; 1591}; 1592 ; 1593////////////////////////////////////////////////////////////////////////////////; 1594/// Nothing to do; 1595 ; 1596void TGenCollectionProxy__StagingDeleteTwoIterators(void *, void *); 1597{; 1598}; 1599 ; 1600 ; 1601////////////////////////////////////////////////////////////////////////////////; 1602/// See typedef void (*CreateIterators_t)(void *collection, void *&begin_arena, void *&end_arena);; 1603/// begin_arena and end_arena should contain the location of memory arena of size fgIteratorSize.; 1604/// If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); 1605/// Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena.; 1606 ; 1607TVirtualCollectionProxy::CreateIterators_t TGenCollectionProxy::GetFunctionCreateIterators(Bool_t read); 1608{; 1609 if (read) {; 1610 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1611 if ( (fProperties & kIsAssociative) && read); 1612 return TGenCollectionProxy__StagingCreateIterators;; 1613 }; 1614 ; 1615 if ( fFunctionCreateIterators ) return fFunctionCreateIterators;; 1616 ; 1617 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1618 ; 1619// fprintf(stderr,""GetFunctinCreateIterator for %s will give: "",fClass.GetClassName());; 1620// if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1621// fprintf(stderr,""vector/emulated iterator\n"");; 1622// else if ( (fProperties & kIsAssociative) && read); 1623// fprintf(stderr,""an associative read iterator\n"");; 1624// else; 1625",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:51818,allocate,allocated,51818,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"on_t Class_Version ();  ; static void Dealloc (void *ptr);  De-allocate block of memory, that was allocated via TStorage::Alloc(). ;  ; static const char * DeclFileName ();  ; static void EnableStatistics (int size=-1, int ix=-1);  Enable memory usage statistics gathering. ;  ; static void EnterStat (size_t size, void *p);  Register a memory allocation operation. ;  ; static Bool_t FilledByObjectAlloc (volatile const UInt_t *const member);  ; static FreeHookFun_t GetFreeHook ();  ; static void * GetFreeHookData ();  return static free hook data ;  ; static size_t GetMaxBlockSize ();  ; static Bool_t HasCustomNewDelete ();  return the has custom delete flag ;  ; static void * ObjectAlloc (size_t size);  Used to allocate a TObject on the heap (via TObject::operator new()). ;  ; static void * ObjectAlloc (size_t size, void *vp);  Used to allocate a TObject on the heap (via TObject::operator new(size_t,void*)) in position vp. ;  ; static void * ObjectAllocArray (size_t size);  Used to allocate array of TObject on the heap (via TObject::operator new[]()). ;  ; static void ObjectDealloc (void *vp);  Used to deallocate a TObject on the heap (via TObject::operator delete()). ;  ; static void ObjectDealloc (void *vp, void *ptr);  Used to deallocate a TObject on the heap (via TObject::operator delete(void*,void*)). ;  ; static void PrintStatistics ();  Print memory usage statistics. ;  ; static void * ReAlloc (void *vp, size_t size, size_t oldsize);  Reallocate (i.e. ;  ; static char * ReAllocChar (char *vp, size_t size, size_t oldsize);  Reallocate (i.e. ;  ; static Int_t * ReAllocInt (Int_t *vp, size_t size, size_t oldsize);  Reallocate (i.e. ;  ; static void RemoveStat (void *p);  Register a memory free operation. ;  ; static void SetCustomNewDelete ();  set the has custom delete flag ;  ; static void SetFreeHook (FreeHookFun_t func, void *data);  Set a free handler. ;  ; static void SetMaxBlockSize (size_t size);  ; static void SetReAllocHooks (ReAllocFun_t func1, ReAllocC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStorage.html:2698,allocate,allocate,2698,doc/master/classTStorage.html,https://root.cern,https://root.cern/doc/master/classTStorage.html,1,['allocate'],['allocate']
Energy Efficiency,"onadaptiveKDE; kAdaptiveKDE; };; enum EKernelBorder { kNoTreatment; kKernelRenorm; kSampleMirror; };. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the ; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE ; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.). const char* GetName() const; modified name (remove TMVA::). { return ""KDEKernel""; }. » Author: Asen Christov » Copyright (c) 2007: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__KDEKernel.html:2446,adapt,adaptive,2446,root/html534/TMVA__KDEKernel.html,https://root.cern,https://root.cern/root/html534/TMVA__KDEKernel.html,1,['adapt'],['adaptive']
Energy Efficiency,"onds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tTTree::fUpdateUpdate frequency for EntryLoop; TList*TTree::fUserInfopointer to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static Int_tTTree::fgBranchStyleOld/New branch style; static Long64_tTTree::fgMaxTreeSizeMaximum size of a file containg a Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNtuple(); Default constructor for Ntuple*-*-*-*-*-*-*-*-; *-* ==============================. TNtuple(const char* name, const char* title, const char* varlist, Int_t bufsize = 32000); Create an Ntuple*-*-; *-* ================; The parameter varlist describes the list of the ntuple variables; separated by a colon:; example: ""x:y:z:energy""; For each variable in the list a separate branch is created. NOTE:; -Use TTree to create branches with variables of different data types.; -Use TTree when the number of branches is large (> 100).; -. ~TNtuple(); Default destructor for an Ntuple*-*-*-*-*-*-; *-* ================================. void ResetBranchAddress(TBranch* ); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void ResetBranchAddresses(); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void Browse(TBrowser* b); Browse content of the ntuple. Int_t Fill(); -*-*Fill a Ntuple with current values in fArgs; *-* ==========================================; Note that this function is protected.; Currently called only by TChain::Merge. Int_t Fill(const Float_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNtuple.html:24423,energy,energy,24423,root/html528/TNtuple.html,https://root.cern,https://root.cern/root/html528/TNtuple.html,1,['energy'],['energy']
Energy Efficiency,"one(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(RooCmdArg arg1, RooCmdArg arg2 = RooCmdArg(), RooCmdArg arg3 = RooCmdArg(), RooCmdArg arg4 = RooCmdArg(), RooCmdArg arg5 = RooCmdArg(), RooCmdArg arg6 = RooCmdArg(), RooCmdArg arg7 = RooCmdArg(), RooCmdArg arg8 = RooCmdArg()); virtual voidreset(); voidTObject::ResetBit(UInt_t f); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsData.html:7897,reduce,reduce,7897,root/html526/RooAbsData.html,https://root.cern,https://root.cern/root/html526/RooAbsData.html,1,['reduce'],['reduce']
Energy Efficiency,"one(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_treleaseVars(RooAbsData*); virtual voidreset(); voidTObject::ResetBit(UInt_t f); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsData.html:8168,reduce,reduce,8168,root/html530/RooAbsData.html,https://root.cern,https://root.cern/root/html530/RooAbsData.html,1,['reduce'],['reduce']
Energy Efficiency,"one(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_treleaseVars(RooAbsData*); virtual voidreset(); voidTObject::ResetBit(UInt_t f); voidresetBuffers(); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; RooAbsData(); RooAbsData(const RooAbsData& other, const char* newname = 0); RooAbsData(const char* name, const char* title, const RooArgSet& vars, RooAbsDataStore* store = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsData.html:8295,reduce,reduce,8295,root/html602/RooAbsData.html,https://root.cern,https://root.cern/root/html602/RooAbsData.html,2,['reduce'],['reduce']
Energy Efficiency,"one(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_treleaseVars(RooAbsData*); virtual voidreset(); voidTObject::ResetBit(UInt_t f); voidresetBuffers(); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetDefaultStorageType(RooAbsData::StorageType s); voidsetDirtyProp(B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsData.html:8240,reduce,reduce,8240,root/html532/RooAbsData.html,https://root.cern,https://root.cern/root/html532/RooAbsData.html,2,['reduce'],['reduce']
Energy Efficiency,"one(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); virtual voidreset(); voidTObject::ResetBit(UInt_t f); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsData.html:7897,reduce,reduce,7897,root/html528/RooAbsData.html,https://root.cern,https://root.cern/root/html528/RooAbsData.html,1,['reduce'],['reduce']
Energy Efficiency,"onent (time, or energy for a 4-momentum vector) ;  ; Scalar e () const;  ; Scalar energy () const;  ; Scalar Et () const;  return the transverse energy ;  ; Scalar Et2 () const;  return the transverse energy squared ;  ; Scalar Eta () const;  pseudorapidity ;  ; Scalar eta () const;  ; Scalar Gamma () const;  Return Gamma scalar value. ;  ; template<class IT > ; void GetCoordinates (IT begin) const;  get internal data into 4 Scalars at *begin ;  ; template<class IT > ; void GetCoordinates (IT begin, IT end) const;  get internal data into 4 Scalars at *begin to *end ;  ; void GetCoordinates (Scalar &a, Scalar &b, Scalar &c, Scalar &d) const;  get internal data into 4 Scalar numbers ;  ; void GetCoordinates (Scalar dest[]) const;  get internal data into an array of 4 Scalar numbers ;  ; bool isLightlike (Scalar tolerance=100 *std::numeric_limits< Scalar >::epsilon()) const;  Determine if momentum-energy can represent a massless particle. ;  ; bool isSpacelike () const;  Determine if momentum-energy is spacelike, and represents a tachyon. ;  ; bool isTimelike () const;  Determine if momentum-energy can represent a physical massive particle. ;  ; Scalar M () const;  return magnitude (mass) using the (-,-,-,+) metric. ;  ; Scalar M2 () const;  return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2 (we use -,-,-,+ metric) ;  ; Scalar mag () const;  ; Scalar mag2 () const;  ; Scalar mass () const;  ; Scalar mass2 () const;  ; Scalar Mt () const;  return the transverse mass ;  ; Scalar mt () const;  ; Scalar Mt2 () const;  return the transverse mass squared ;  ; Scalar mt2 () const;  ; bool operator!= (const LorentzVector &rhs) const;  ; LorentzVector operator* (const Scalar &a) const;  product of a LorentzVector by a scalar quantity ;  ; LorentzVector & operator*= (Scalar a);  multiplication by a scalar quantity v *= a ;  ; LorentzVector operator+ () const;  ; template<class OtherLorentzVector > ; LorentzVector operator+ (const OtherLorentzVector &v2) const;  addit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzVector.html:4799,energy,energy,4799,doc/master/classROOT_1_1Math_1_1LorentzVector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzVector.html,1,['energy'],['energy']
Energy Efficiency,"onent; Analysis.; ; Determine ; as before.; ; Detetmine ; as before.; ; Use the result of the fit to determind ; .; ; Transform back to ; from ; , using; the result from the Principal Component Analysis.; . Testing the parameterization; . The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow).; ; The parameterization is then evaluated at every ; in the; test sample, and; . is evaluated. The relative error over the test sample; . should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced.; ; It's possible to use Minuit; [4] to further improve the fit, using the test sample.; . Christian Holm; November 2000, NBI; . Bibliography; 1. Philip R. Bevington and D. Keith Robinson.; Data Reduction and Error Analysis for the Physical Sciences.; McGraw-Hill, 2 edition, 1992.; 2. René Brun et al.; Mudifi.; Long writeup DD/75-23, CERN, 1980.; 3. Gene H. Golub and Charles F. van Loan.; Matrix Computations.; John Hopkins Univeristy Press, Baltimore, 3 edition, 1996.; 4. F. James.; Minuit.; Long writeup D506, CERN, 1998.; 5. H. Wind.; Function parameterization.; In Proceedings of the 1972 CERN Computing and Data Processing; School, volume 72-21 of Yellow report. CERN, 1972.; 6. H. Wind.; 1. principal component analysis, 2. pattern recognition for track; finding, 3. interpolation and functional representation.; Yellow report EP/81-12, CERN, 1981.; . */. Function Members (Methods); public:. TMultiDimFit(); TMul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiDimFit.html:12577,reduce,reduced,12577,root/html534/TMultiDimFit.html,https://root.cern,https://root.cern/root/html534/TMultiDimFit.html,2,['reduce'],['reduced']
Energy Efficiency,"onent; Analysis.; ; Determine ; as before.; ; Detetmine ; as before.; ; Use the result of the fit to determind ; .; ; Transform back to ; from ; , using; the result from the Principal Component Analysis.; . Testing the parameterization; . The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow).; ; The parameterization is then evaluated at every ; in the; test sample, and; . is evaluated. The relative error over the test sample; . should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced.; ; It's possible to use Minuit; [4] to further improve the fit, using the test sample.; . Christian Holm; November 2000, NBI; . Bibliography; 1. Philip R. Bevington and D. Keith Robinson.; Data Reduction and Error Analysis for the Physical Sciences.; McGraw-Hill, 2 edition, 1992.; 2. René Brun et al.; Mudifi.; Long writeup DD/75-23, CERN, 1980.; 3. Gene H. Golub and Charles F. van Loan.; Matrix Computations.; John Hopkins Univeristy Press, Baltimore, 3 edition, 1996.; 4. F. James.; Minuit.; Long writeup D506, CERN, 1998.; 5. H. Wind.; Function parameterization.; In Proceedings of the 1972 CERN Computing and Data Processing; School, volume 72-21 of Yellow report. CERN, 1972.; 6. H. Wind.; 1. principal component analysis, 2. pattern recognition for track; finding, 3. interpolation and functional representation.; Yellow report EP/81-12, CERN, 1981.; . */. Function Members (Methods); public:. virtual~TMultiDimFit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMultiDimFit.html:12577,reduce,reduced,12577,root/html602/TMultiDimFit.html,https://root.cern,https://root.cern/root/html602/TMultiDimFit.html,4,['reduce'],['reduced']
Energy Efficiency,"onesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. TClonesArray(); TClonesArray(const TClonesArray& tc); TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const TObject*, TObject*); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject*, Int_t); virtual voidAddAtAndExpand(TObject*, Int_t); virtual Int_tAddAtFree(TObject*); virtual voidAddBefore(const TObject*, TObject*); virtual voidAddFirst(TObject*); virtual voidAddLast(TObject*); TObject*AddrAt(Int_t idx); voidTCollection::AddVector(TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:4231,reduce,reduce,4231,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,2,['reduce'],['reduce']
Energy Efficiency,"onesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const TObject*, TObject*); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject*, Int_t); virtual voidAddAtAndExpand(TObject*, Int_t); virtual Int_tAddAtFree(TObject*); virtual voidAddBefore(const TObject*, TObject*); virtual voidAddFirst(TObject*); virtual voidAddLast(TObject*); TObject*AddrAt(Int_t idx); voidTCollection::AddVector(TObject* obj1); virtual TObject*TObjArray::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TObjArray::At(Int_t idx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClonesArray.html:4231,reduce,reduce,4231,root/html602/TClonesArray.html,https://root.cern,https://root.cern/root/html602/TClonesArray.html,1,['reduce'],['reduce']
Energy Efficiency,"onfigurations for the member wise looping routines ;  CTNestedIDs;  ►Nvecgeom;  ►Nwriter;  Cwriter;  C_x3d_data_;  C_x3d_sizeof_;  CAnyCollectionProxy;  CAnyCollectionStreamer;  CBalancerInfo;  Cbasic_string_view;  CBasicRNNLayerGeneric implementation ;  ►CBidirMMapPipeBidirMMapPipe creates a bidirectional channel between the current process and a child it forks ;  CPollEntryFor poll() interface ;  CBinaryOpPolicy;  CBinomialNeymanInterval;  CBinomialProbHelper;  Cclient_cert;  CColorStruct_t;  CCompareAsc;  CcompareBAasc;  CcompareBAdesc;  CCompareDesc;  CContDistFree functions adapter needed by UNURAN for onedimensional continuous distributions ;  CContextSmall helper to keep current directory context ;  CCpuInfo_t;  CDebuggingSamplerDebuggingSampler is a simple implementation of the DistributionCreator interface used for debugging ;  CDebuggingTestStatDebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging ;  CDiscrDistFree functions adapter needed by UNURAN for one-dimensional discrete distribution ;  CEvent_t;  CExceptionContext_t;  CFeldmanCousinsBinomialInterval;  CFeldmanCousinsSorter;  CFileStat_t;  CFontAttributes_t;  CFontMetrics_t;  CFoption_t;  Cfuncptr_and_voidptr_t;  CGcCache_t;  CGCValues_t;  Cgroup;  Ch1analysis;  Ch1analysisTreeReader;  Chash< std::experimental::basic_string_view< _CharT, _Traits > >;  CHelperOps;  CHEPEVT_DEFHEPEVT common block ;  CHit;  CHoption_tHistogram option structure ;  CHparam_tHistogram parameters structure ;  CJet;  CJetEvent;  CMemInfo_t;  Cmg_callbacks;  Cmg_client_cert;  Cmg_client_options;  Cmg_form_data_handler;  Cmg_header;  Cmg_option;  Cmg_request_info;  Cmg_response_info;  Cmg_server_ports;  Cmg_websocket_subprotocols;  CMultiDistFree functions adapter needed by UNURAN for multidimensional cont distribution ;  CMYSQL_BIND;  CMYSQL_STMT;  CNuMuToNuE_Oscillation;  ►CParamHistFunc;  CCacheElem;  CPassiveKeyGrab;  Cpasswd;  CPattern;  CPgSQL_Stmt_t;  CPictureAttributes_t;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:91948,adapt,adapter,91948,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,1,['adapt'],['adapter']
Energy Efficiency,"ong_t ; nElements, . void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5295 of file TClass.cxx. ◆ NewObject() [1/2]. TClass::ObjectPtr TClass::NewObject ; (; ENewType ; defConstructor = kClassNew, . Bool_t ; quiet = kFALSE . ); const. Definition at line 4992 of file TClass.cxx. ◆ NewObject() [2/2]. TClass::ObjectPtr TClass::NewObject ; (; void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5106 of file TClass.cxx. ◆ NewObjectArray() [1/2]. TClass::ObjectPtr TClass::NewObjectArray ; (; Long_t ; nElements, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated array of objects of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5209 of file TClass.cxx. ◆ NewObjectArray() [2/2]. TClass::ObjectPtr TClass::NewObjectArray ; (; Long_t ; nElements, . void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5310 of file TClass.cxx. ◆ operator=(). TClass & TClass::operator= ; (; const TClass & ; ). privatedelete . ◆ PostLoadCheck(). void TClass::PostLoadCheck ; (; ). virtual . Do the initialization that can only be done after the CINT dictionary has been fully populated and can not be delayed efficiently. ; Definition at line 5959 of file TClass.cxx. ◆ Property(). Long_t TClass::Property ; (; ); const. overridevirtual . Returns the properties of the TClass as a bit f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:107911,allocate,allocated,107911,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['allocate'],['allocated']
Energy Efficiency,"ong_t ; nElements, . void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5362 of file TClass.cxx. ◆ NewObject() [1/2]. TClass::ObjectPtr TClass::NewObject ; (; ENewType ; defConstructor = kClassNew, . Bool_t ; quiet = kFALSE . ); const. Definition at line 5059 of file TClass.cxx. ◆ NewObject() [2/2]. TClass::ObjectPtr TClass::NewObject ; (; void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5173 of file TClass.cxx. ◆ NewObjectArray() [1/2]. TClass::ObjectPtr TClass::NewObjectArray ; (; Long_t ; nElements, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated array of objects of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5276 of file TClass.cxx. ◆ NewObjectArray() [2/2]. TClass::ObjectPtr TClass::NewObjectArray ; (; Long_t ; nElements, . void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5377 of file TClass.cxx. ◆ operator=(). TClass & TClass::operator= ; (; const TClass & ; ). privatedelete . ◆ PostLoadCheck(). void TClass::PostLoadCheck ; (; ). virtual . Do the initialization that can only be done after the CINT dictionary has been fully populated and can not be delayed efficiently. ; Definition at line 6026 of file TClass.cxx. ◆ Property(). Long_t TClass::Property ; (; ); const. overridevirtual . Returns the properties of the TClass as a bit f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:107912,allocate,allocated,107912,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['allocate'],['allocated']
Energy Efficiency,"onitoring ; Definition at line 820 of file NeuralNet.h. ◆ cycle(). virtual void TMVA::DNN::Settings::cycle ; (; double ; progress, . TString ; text . ). inlinevirtual . Parameters. textadvance on the progress bar; progressthe new value; texta label . Definition at line 799 of file NeuralNet.h. ◆ drawSample(). virtual void TMVA::DNN::Settings::drawSample ; (; const std::vector< double > & ; , . const std::vector< double > & ; , . const std::vector< double > & ; , . double ;  . ). inlinevirtual . callback for monitoring and logging ; Definition at line 807 of file NeuralNet.h. ◆ dropFractions(). const std::vector< double > & TMVA::DNN::Settings::dropFractions ; (; ); const. inline . Definition at line 762 of file NeuralNet.h. ◆ dropRepetitions(). size_t TMVA::DNN::Settings::dropRepetitions ; (; ); const. inline . Definition at line 761 of file NeuralNet.h. ◆ endTestCycle(). virtual void TMVA::DNN::Settings::endTestCycle ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 805 of file NeuralNet.h. ◆ endTrainCycle(). virtual void TMVA::DNN::Settings::endTrainCycle ; (; double ; ). inlinevirtual . callback for monitoring and logging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 788 of file NeuralNet.h. ◆ exists(). bool TMVA::DNN::Settings::exists ; (; std::string ; histoName). inline . for monitoring ; Definition at line 825 of file NeuralNet.h. ◆ factorWeightDecay(). double TMVA::DNN::Settings::factorWeightDecay ; (; ); const. inline . get the weight-decay factor ; Definition at line 769 of file NeuralNet.h. ◆ hasConverged(). bool TMVA::DNN::Settings::hasConverged ; (; double ; testError). virtual . has this training converged already? ; check for convergence; Definition at line 485 of file NeuralNet.cxx. ◆ learningRate(). double TMVA::DNN::Settings::learningRate ; (; ); const. inline . get the learning rate ; Definition at line 771 of file NeuralNet.h. ◆ maxConv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:8126,monitor,monitoring,8126,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['monitor'],['monitoring']
Energy Efficiency,"only used in Makefiles. Using root-config instead of enumerating the libraries by hand allows you to link them in a platform independent way. Also, if ROOT library names change you will not need to change your Makefile.; A batch program that does not have a graphic display, which creates, fills, and saves histograms and trees, only needs to link the core libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, libTreePlayer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:22851,green,green,22851,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['green'],['green']
Energy Efficiency,"onnectToClass (TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . #include <TSysEvtHandler.h>. Inheritance diagram for TFileHandler:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ anonymous enum. anonymous enum. EnumeratorkRead ; kWrite . Definition at line 75 of file TSysEvtHandler.h. Constructor & Destructor Documentation. ◆ TFileHandler() [1/2]. TFileHandler::TFileHandler ; (; ). inlineprotected . Definition at line 72 of file TSysEvtHandler.h. ◆ TFileHandler() [2/2]. TFileHandler::TFileHandler ; (; int ; fd, . int ; mask . ). Create a file descriptor event handler. ; If mask=kRead then we want to monitor the file for read readiness, if mask=kWrite then we monitor the file for write readiness, if mask=kRead|kWrite then we monitor both read and write readiness. ; Definition at line 59 of file TSysEvtHandler.cxx. ◆ ~TFileHandler(). virtual TFileHandler::~TFileHandler ; (; ). inlinevirtual . Definition at line 78 of file TSysEvtHandler.h. Member Function Documentation. ◆ Add(). void TFileHandler::Add ; (; ). overridevirtual . Add file event handler to system file handler list. ; Implements TSysEvtHandler.; Definition at line 126 of file TSysEvtHandler.cxx. ◆ Class(). static TClass * TFileHandler::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TFileHandler::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TFileHandler::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 95 of file TSysEvtHandler.h. ◆ DeclFileName(). static const char * TFileHandler::DeclFileName ; (; ). inlinestatic . ReturnsName of the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileHandler.html:16833,monitor,monitor,16833,doc/master/classTFileHandler.html,https://root.cern,https://root.cern/doc/master/classTFileHandler.html,3,['monitor'],['monitor']
Energy Efficiency,"onnecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). For a description; of the arguments see the TProof ctor. Returns the number of started; master or slave servers, returns 0 in case of error, in which case; fValid remains false. Int_t GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); Set the sandbox path from ' Proof.Sandbox' or the alternative var 'rc'.; Use the existing setting or the default if nothing is found.; If 'assert' is kTRUE, make also sure that the path exists.; Return 0 on success, -1 on failure. void ParseConfigField(const char* config); The config file field may contain special instructions which need to be; parsed at the beginning, e.g. for debug runs with valgrind. Int_t AssertPath(const char* path, Bool_t writable); Make sure that 'path' exists; if 'writable' is kTRUE, make also sure; that the path is writable. void SetManager(TProofMgr* mgr); Set manager and schedule its destruction after this for clean; operations. Int_t AddWorkers(TList* wrks); Works on the master node only.; It starts workers on the machines in workerList and sets the paths,; packages and macros as on the master.; It is a subbstitute for StartSlaves(...); The code is mostly the master part of StartSlaves,; with the parallel startup removed. Int_t RemoveWorkers(TList* wrks); Used for shuting down the workres after a query is finished.; Sends each of the workers from the workerList, a kPROOF_STOP message.; If the workerList == 0, shutdown all the workers. Bool_t StartSlaves(Bool_t attach = kFALSE); Start up PROOF slaves. void Close(Option_t* option = """"); Close all open slave servers.; Client can decide to shutdown the remote session by passing option is 'S'; or 's'. Default for clients is detach, if supported. Masters always; shutdown the remote counterpart. TSlave * CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); Create a n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProof.html:34192,schedul,schedule,34192,root/html530/TProof.html,https://root.cern,https://root.cern/root/html530/TProof.html,2,['schedul'],['schedule']
Energy Efficiency,"ons |; Private Attributes |; List of all members ; ROOT::Fit::BinData Class ReferenceMath » MathCore » Fitting and Parameter Estimation » Fit Data Classes. ; Class describing the binned data sets : vectors of x coordinates, y values and optionally error on y values and error on coordinates The dimension of the coordinate is free There are 4 different options: . only coordinates and values (for binned likelihood fits) : kNoError; coordinate, values and error on values (for normal least square fits) : kValueError; coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError; coordinate, values, error on coordinates and asymmetric error on values : kAsymError. In addition there is the option to construct Bindata copying the data in (using the DataVector class) or using pointer to external data (DataWrapper) class. In general is found to be more efficient to copy the data. In case of really large data sets for limiting memory consumption then the other option can be used Specialized constructor exists for data up to 3 dimensions.; When the data are copying in the number of points can be set later (or re-set) using Initialize and the data are inserted one by one using the Add method. It is mandatory to set the size before using the Add method. ; Definition at line 52 of file BinData.h. Public Types; enum  ErrorType { kNoError; , kValueError; , kCoordError; , kAsymError; };  . Public Member Functions;  BinData (const BinData &rhs);  copy constructors ;  ;  BinData (const DataOptions &opt, const DataRange &range, unsigned int maxpoints=0, unsigned int dim=1, ErrorType err=kValueError);  constructor from options and range default is 1D and value errors ;  ;  BinData (const DataOptions &opt, unsigned int maxpoints=0, unsigned int dim=1, ErrorType err=kValueError);  constructor from option and default range ;  ;  BinData (unsigned int maxpoints=0, unsigned int dim=1, ErrorType err=kValueError);  constructor from dimension of point and ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1BinData.html:1189,consumption,consumption,1189,doc/master/classROOT_1_1Fit_1_1BinData.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1BinData.html,1,['consumption'],['consumption']
Energy Efficiency,"ons; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorOneDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegratorOneDimOptions(IOptions * extraOpts = 0); constructor using the default options; can pass a pointer to extra options (N.B. pointer will be managed by the class). virtual ~IntegratorOneDimOptions(); {}. IntegratorOneDimOptions(const IntegratorOneDimOptions & rhs); copy constructor. {}. void SetNPoints(unsigned int n); specific method for one-dim; set number of points rule; values of 1,2,3,4,5,6 corresponds to 15,21,31,41,51,61 and they are used in GSL adaptive; values > 6 corresponds to the actual points and they are used by teh GaussLegendre integrator. { fNCalls = n; }. unsigned int NPoints() const; maximum number of function calls. { return fNCalls; }. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultIntegrator(const char* name); static methods for setting and retrieving the default options. void SetDefaultAbsTolerance(double tol). void SetDefaultRelTolerance(double tol). void SetDefaultWKSize(unsigned int size). void SetDefaultNPoints(unsigned int n). std::string DefaultIntegrator(). IntegrationOneDim::Type DefaultIntegratorType(). double DefaultAbsTolerance(). double DefaultRelTolerance(). unsigned int DefaultWKSize(). unsigned int DefaultNPoints(). ROOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IntegratorOneDimOptions.html:3896,adapt,adaptive,3896,root/html602/ROOT__Math__IntegratorOneDimOptions.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IntegratorOneDimOptions.html,2,['adapt'],['adaptive']
Energy Efficiency,"onst RColumnElementBase & ; element, . DescriptorId_t ; physicalColumnId, . RPageAllocator & ; pageAlloc . ). static . Helper for unstreaming a page. ; This is commonly used in derived, concrete page sources. The implementation currently always makes a memory copy, even if the sealed page is uncompressed and in the final memory layout. The optimization of directly mapping pages is left to the concrete page source implementations. ; Definition at line 487 of file RPageStorage.cxx. ◆ UnzipCluster(). void ROOT::Experimental::Internal::RPageSource::UnzipCluster ; (; RCluster * ; cluster). Parallel decompression and unpacking of the pages in the given cluster. ; The unzipped pages are supposed to be preloaded in a page pool attached to the source. The method is triggered by the cluster pool's unzip thread. It is an optional optimization, the method can safely do nothing. In particular, the actual implementation will only run if a task scheduler is set. In practice, a task scheduler is set if implicit multi-threading is turned on. ; Definition at line 224 of file RPageStorage.cxx. ◆ UnzipClusterImpl(). void ROOT::Experimental::Internal::RPageSource::UnzipClusterImpl ; (; RCluster * ; cluster). protectedvirtual . Definition at line 230 of file RPageStorage.cxx. Member Data Documentation. ◆ fActivePhysicalColumns. RActivePhysicalColumns ROOT::Experimental::Internal::RPageSource::fActivePhysicalColumns. protected . The active columns are implicitly defined by the model fields or views. ; Definition at line 658 of file RPageStorage.hxx. ◆ fCounters. std::unique_ptr<RCounters> ROOT::Experimental::Internal::RPageSource::fCounters. protected . Definition at line 654 of file RPageStorage.hxx. ◆ fDescriptor. RNTupleDescriptor ROOT::Experimental::Internal::RPageSource::fDescriptor. private . Definition at line 603 of file RPageStorage.hxx. ◆ fDescriptorLock. std::shared_mutex ROOT::Experimental::Internal::RPageSource::fDescriptorLock. mutableprivate . Definition at line 604 of file ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html:20547,schedul,scheduler,20547,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,1,['schedul'],['scheduler']
Energy Efficiency,"onst RooAbsReal& offset, const char* unit = """"); Constructor with RooAbsRealLValue variable and RooAbsReal slope and offset. RooLinearVar(const RooLinearVar& other, const char* name = 0); Copy constructor. ~RooLinearVar(); Destructor. Double_t evaluate() const; Calculate current value of this object. void setVal(Double_t value); Assign given value to linear transformation: sets input variable to (value-offset)/slope; If slope is zerom an error message is printed and no assignment is made. Bool_t isJacobianOK(const RooArgSet& depList) const; Returns true if Jacobian term associated with current; expression tree is indeed constant. Double_t jacobian() const; Return value of Jacobian associated with the transformation. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream. RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE); Retrieve binning of this linear transformation. A RooLinearVar does not have its own; binnings but uses linearly transformed binnings of teh input variable. If a given; binning exists on the input variable, it will also exists on this linear transformation; and a binning adaptor object is created on the fly. const RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE) const; Const version of getBinning(). Bool_t hasBinning(const char* name) const; Returns true if binning with given name exists.If a given binning; exists on the input variable, it will also exists on this linear; transformation. TObject* clone(const char* newname) const; { return new RooLinearVar(*this,newname); }. » Last changed: Thu Sep 23 20:00:02 2010 » Last generated: 2010-09-23 20:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooLinearVar.html:39072,adapt,adaptor,39072,root/html528/RooLinearVar.html,https://root.cern,https://root.cern/root/html528/RooLinearVar.html,1,['adapt'],['adaptor']
Energy Efficiency,"onst RooArgSet &keepObsList);  Prepare dataset for use with cached constant terms listed in 'cacheList' of expression 'arg'. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) const;  Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ), where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1 as function of the frames variable. ;  ; virtual RooPlot * plotEffOn (RooPlot *frame, const RooAbsCategoryLValue &effCat, PlotOpt o) const;  Create and fill a histogram with the efficiency N[1] / ( N[1] + N[0] ), where N(1/0) is the number of data points with effCat=1 and effCat=0 as function of the frames variable. ;  ; virtual RooPlot * plotOn (RooPlot *frame, PlotOpt o) const;  Create and fill a histogram of the frame's variable and append it to the frame. ;  ; virtual std::unique_ptr< RooAbsData > reduceEng (const RooArgSet &varSubset, const RooFormulaVar *cutVar, const char *cutRange=nullptr, std::size_t nStart=0, std::size_t=std::numeric_limits< std::size_t >::max()) const =0;  ; virtual void resetCache ();  Internal method – Remove cached function values. ;  ; virtual void setArgStatus (const RooArgSet &set, bool active);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooArgSet _cachedVars;  ! External variables cached with this data set ;  ; std::unique_ptr< RooAbsDataStore > _dstore;  Data storage implementation. ;  ; std::unique_ptr< RooArgSet > _globalObservables;  Snapshot of global observables. ;  ; const TNamed * _namePtr = nullptr;  ! De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; std::map< std::string, RooAbsData * > _ownedComponents;  Owned external components. ;  ; RooArgSet _vars;  Dimensions of this data set. ;  ; StorageType storageType;  ;  Pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:30141,reduce,reduceEng,30141,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['reduce'],['reduceEng']
Energy Efficiency,"onst RooArgSet &keepObsList);  Prepare dataset for use with cached constant terms listed in 'cacheList' of expression 'arg'. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) const;  Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ), where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1 as function of the frames variable. ;  ; virtual RooPlot * plotEffOn (RooPlot *frame, const RooAbsCategoryLValue &effCat, PlotOpt o) const;  Create and fill a histogram with the efficiency N[1] / ( N[1] + N[0] ), where N(1/0) is the number of data points with effCat=1 and effCat=0 as function of the frames variable. ;  ; virtual RooPlot * plotOn (RooPlot *frame, PlotOpt o) const;  Create and fill a histogram of the frame's variable and append it to the frame. ;  ; virtual std::unique_ptr< RooAbsData > reduceEng (const RooArgSet &varSubset, const RooFormulaVar *cutVar, const char *cutRange=nullptr, std::size_t nStart=0, std::size_t=std::numeric_limits< std::size_t >::max()) const =0;  ; virtual void resetCache ();  Internal method – Remove cached function values. ;  ; virtual void setArgStatus (const RooArgSet &set, bool active);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from RooAbsData; RooArgSet _cachedVars;  ! External variables cached with this data set ;  ; std::unique_ptr< RooAbsDataStore > _dstore;  Data storage implementation. ;  ; std::unique_ptr< RooArgSet > _globalObservables;  Snapshot of global observables. ;  ; const TNamed * _namePtr = nullptr;  ! De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; std::map< std::string, RooAbsData * > _ownedComponents;  Owned external components. ;  ; RooArgSet _vars;  Dimensions of this data set. ;  ; Stora",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeData.html:26898,reduce,reduceEng,26898,doc/master/classRooTreeData.html,https://root.cern,https://root.cern/doc/master/classRooTreeData.html,1,['reduce'],['reduceEng']
Energy Efficiency,"onst RooArgSet* iset, RooAddModel::pRooArgList& compIntList, Int_t& code, const char* isetRangeName) const; Check if this configuration was created before. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral defined by given scenario code. Double_t expectedEvents(const RooArgSet* nset); Return the number of expected events, which is either the sum of all coefficients; or the sum of the components extended terms. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fraction coefficients. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized context to efficiently generate toy events from RooAddPdfs. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Direct generation is safe if all components say so. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Return pseud-code that indicates if all components can do internal generation (1) or not (0). void generateEvent(Int_t code); This function should never be called as RooAddModel implements a custom generator context. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooAddModel to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooAddModel(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. Bool_t selfNormalized() const; Model is self normalized when used as p.d.f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddModel.html:46982,efficient,efficiently,46982,root/html526/RooAddModel.html,https://root.cern,https://root.cern/root/html526/RooAddModel.html,1,['efficient'],['efficiently']
Energy Efficiency,"onst char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Public Attributes; TArray * fContent;  Bin content. ;  ; Int_t fCoordinateAllocationSize;  ! Size of the allocated coordinate buffer; -1 means none or fCoordinatesSize ;  ; Char_t * fCoordinates;  [fCoordinatesSize] compact bin coordinate buffer ;  ; Int_t fCoordinatesSize;  Size of the bin coordinate buffer. ;  ; Int_t fSingleCoordinateSize;  Size of a single bin coordinate. ;  ; TArrayD * fSumw2;  Bin errors. ;  . Private Member Functions;  THnSparseArrayChunk (const THnSparseArrayChunk &)=delete;  ; THnSparseArrayChunk & operator= (const THnSparseArrayChunk &)=delete;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnSparseArrayChunk.html:9834,allocate,allocated,9834,doc/master/classTHnSparseArrayChunk.html,https://root.cern,https://root.cern/doc/master/classTHnSparseArrayChunk.html,1,['allocate'],['allocated']
Energy Efficiency,"onst char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAtt3D; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; void FillTableOfCoSin (Double_t phi, Double_t angstep, Int_t n) const override;  Fill the table of cos and sin to prepare drawing. ;  ;  Protected Member Functions inherited from TPCON;  TPCON (const TPCON &);  copy constructor ;  ; virtual void MakeTableOfCoSin () const;  Make table of cosine and sine. ;  ; TPCON & operator= (const TPCON &);  assignment operator ;  ; void SetPoints (Double_t *points) const override;  Create PCON points. ;  ; virtual Bool_t SetSegsAndPols (TBuffer3D &buffer) const;  Set segments and polygons. ;  ;  Protected Member Functions inherited from TShape; virtual void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections) const;  We have to set kRawSize (unless already done) to allocate buffer space before kRaw can be filled. ;  ; Int_t GetBasicColor () const;  Get basic color. ;  ; Int_t ShapeDistancetoPrimitive (Int_t numPoints, Int_t px, Int_t py);  Distance to primitive. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPGON.html:17353,allocate,allocate,17353,doc/master/classTPGON.html,https://root.cern,https://root.cern/doc/master/classTPGON.html,1,['allocate'],['allocate']
Energy Efficiency,"onst char* str); Sends a string to master and workers and expect them to echo it back to; the client via a message. It is a special case of the generic Echo(); that works with TObjects. Returns -1 on error, the number of workers that; received the message on success. Int_t SendObject(const TObject* obj, TProof::ESlaves list = kActive); Send object to master or slave servers. Returns number of slaves object; was sent to, -1 in case of error. Int_t SendPrint(Option_t* option = """"); Send print command to master server. Returns number of slaves message; was sent to. Returns -1 in case of error. void SetLogLevel(Int_t level, UInt_t mask = TProofDebug::kAll); Set server logging level. void SetRealTimeLog(Bool_t on = kTRUE); Switch ON/OFF the real-time logging facility. When this option is; ON, log messages from processing are sent back as they come, instead of; being sent back at the end in one go. This may help debugging or monitoring; in some cases, but, depending on the amount of log, it may have significant; consequencies on the load over the network, so it must be used with care. Int_t SetParallelSilent(Int_t nodes, Bool_t random = kFALSE); Tell PROOF how many slaves to use in parallel. If random is TRUE a random; selection is done (if nodes is less than the available nodes).; Returns the number of parallel slaves. Returns -1 in case of error. Int_t SetParallel(Int_t nodes = -1, Bool_t random = kFALSE); Tell PROOF how many slaves to use in parallel. Returns the number of; parallel slaves. Returns -1 in case of error. Int_t GoMoreParallel(Int_t nWorkersToAdd); Add nWorkersToAdd workers to current list of workers. This function is; works on the master only, and only when an analysis is ongoing. A message; is sent back to the client when we go ""more"" parallel.; Returns -1 on error, number of total (not added!) workers on success. Int_t GoParallel(Int_t nodes, Bool_t accept = kFALSE, Bool_t random = kFALSE); Go in parallel mode with at most ""nodes"" slaves. Since the fSla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:67349,monitor,monitoring,67349,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,3,['monitor'],['monitoring']
Energy Efficiency,"onst noexcept;  Return a pointer to the vector's buffer, even if empty(). ;  ; pointer data () noexcept;  Return a pointer to the vector's buffer, even if empty(). ;  ; bool empty () const;  ; const_iterator end () const noexcept;  ; iterator end () noexcept;  ; reference front ();  ; const_reference front () const;  ; size_type max_size () const noexcept;  ; const_reverse_iterator rbegin () const noexcept;  ; reverse_iterator rbegin () noexcept;  ; const_reverse_iterator rend () const noexcept;  ; reverse_iterator rend () noexcept;  ; size_t size () const;  ; size_type size_in_bytes () const;  ;  Public Member Functions inherited from ROOT::Internal::VecOps::SmallVectorBase; size_t capacity () const noexcept;  ; bool empty () const;  ; void set_size (size_t N);  Set the array size to N, which the current array must have enough capacity for. ;  ; size_t size () const;  . Protected Member Functions;  SmallVectorTemplateCommon (size_t Size);  ; void grow_pod (size_t MinSize, size_t TSize);  ; bool isSmall () const;  Return true if this is a smallvector which has not had dynamic memory allocated for it. ;  ; void resetToSmall ();  Put this vector in a state of being small. ;  ;  Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorBase;  SmallVectorBase ()=delete;  ;  SmallVectorBase (void *FirstEl, size_t TotalCapacity);  ; void grow_pod (void *FirstEl, size_t MinSize, size_t TSize);  This is an implementation of the grow() method which only works on POD-like data types and is out of line to reduce code duplication. ;  ; bool Owns () const;  If false, the RVec is in ""memory adoption"" mode, i.e. it is acting as a view on a memory buffer it does not own. ;  . Private Types; using Base = SmallVectorBase;  . Private Member Functions; void * getFirstEl () const;  Find the address of the first element. ;  . Additional Inherited Members;  Static Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorBase; static void report_at_ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1VecOps_1_1SmallVectorTemplateCommon.html:2710,allocate,allocated,2710,doc/master/classROOT_1_1Internal_1_1VecOps_1_1SmallVectorTemplateCommon.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1VecOps_1_1SmallVectorTemplateCommon.html,1,['allocate'],['allocated']
Energy Efficiency,"onst. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar rho() const; { retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html:16136,energy,energy,16136,root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,1,['energy'],['energy']
Energy Efficiency,"onst. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar rho() const; { retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html:16136,energy,energy,16136,root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,1,['energy'],['energy']
Energy Efficiency,"onst; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TEveHit(); TEveHit(const TEveHit&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. UShort_tfDetIdCustom detector id.; Int_tfEvaLabelLabel of primary particle, ancestor of label.; Int_tfLabelLabel of particle that produced the hit.; UShort_tfSubdetIdCustom sub-detector id.; TEveVectorfVHit position.; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveMCTrack& operator=(const TEveHit& ); { *((TParticle*)this) = p; return *this; }. TEveHit(); Float_t charge; probably specific. {}. virtual ~TEveHit(); {}. » Last changed: root/eve:$Id$ » Last generated: 2015-06-02 13:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveHit.html:5936,charge,charge,5936,root/html602/TEveHit.html,https://root.cern,https://root.cern/root/html602/TEveHit.html,1,['charge'],['charge']
Energy Efficiency,"onst; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TEveHit(); TEveHit(const TEveHit&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. UShort_tfDetIdCustom detector id.; Int_tfEvaLabelLabel of primary particle, ancestor of label.; Int_tfLabelLabel of particle that produced the hit.; UShort_tfSubdetIdCustom sub-detector id.; TEveVectorfVHit position.; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveMCTrack& operator=(const TEveHit& ); { *((TParticle*)this) = p; return *this; }. TEveHit(); Float_t charge; probably specific. {}. virtual ~TEveHit(); {}. » Last changed: root/eve:$Id$ » Last generated: 2015-06-02 15:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEveHit.html:5936,charge,charge,5936,root/html604/TEveHit.html,https://root.cern,https://root.cern/root/html604/TEveHit.html,1,['charge'],['charge']
Energy Efficiency,"onstexpr Double_t TMath::Na ();  Avogadro constant (Avogadro's Number) in \( mol^{-1} \). ;  ; constexpr Double_t TMath::NaUncertainty ();  Avogadro constant (Avogadro's Number) uncertainty. ;  ; template<typename T > ; Int_t TMath::Nint (T x);  Round to nearest integer. Rounds half integers to the nearest even integer. ;  ; template<typename T > ; T * TMath::Normal2Plane (const T v1[3], const T v2[3], const T v3[3], T normal[3]);  Calculates a normal vector of a plane. ;  ; Double_t TMath::Normalize (Double_t v[3]);  Normalize a vector v in place. ;  ; Float_t TMath::Normalize (Float_t v[3]);  Normalize a vector v in place. ;  ; template<typename T > ; T TMath::NormCross (const T v1[3], const T v2[3], T out[3]);  Calculates the Normalized Cross Product of two vectors. ;  ; Double_t TMath::NormQuantile (Double_t p);  Computes quantiles for standard normal distribution N(0, 1) at probability p. ;  ; Bool_t TMath::Permute (Int_t n, Int_t *a);  Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinct adapted from CERNLIB routine PERMU. ;  ; constexpr Double_t TMath::Pi ();  \( \pi\) ;  ; constexpr Double_t TMath::PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t TMath::PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t TMath::Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t TMath::PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t TMath::Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Prob (Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h.html:14749,adapt,adapted,14749,doc/master/TMath_8h.html,https://root.cern,https://root.cern/doc/master/TMath_8h.html,1,['adapt'],['adapted']
Energy Efficiency,"ontainer object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooCmdArgNamed container for two doubles, two integers two object points and three string pointers that can be...Definition RooCmdArg.h:26; RooCurve::WingModeWingModeDefinition RooCurve.h:39; RooCurve::Extended@ ExtendedDefinition RooCurve.h:39; RooDataHistContainer class to hold N-dimensional binned data.Definition RooDataHist.h:40; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDerivativeRepresents the first, second, or third order derivative of any RooAbsReal as calculated (numerically)...Definition RooDerivative.h:30; RooFitResultRooFitResult is a container class to hold the input and output of a PDF fit to a dataset.Definition RooFitResult.h:40; RooFit::Detail::CodeSquashContextA class to maintain the context for squashing of RooFit models into code.Definition CodeSquashContext.h:42; RooFit::EvalContextDefinition EvalContext.h:84; RooFunctorLightweight interface adaptor that exports a RooAbsPdf as a functor.Definition RooFunctor.h:25; RooLinkedListCollection class for internal use, storing a collection of RooAbsArg pointers in a doubly linked list...Definition RooLinkedList.h:44; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooRealBindingLightweight interface adaptor that binds a RooAbsReal object to a subset of its servers and present i...Definition RooRealBinding.h:30; RooRealSumFuncDefinition RooRealSumFunc.h:26; RooRealSumPdfImplements a PDF constructed from a sum of functions:Definition RooRealSumPdf.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooStringViewThe RooStringView is a wrapper around a C-style string that can also be constructed from a std::strin...Definition RooStringView.h:27; RooVectorDataStor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8h_source.html:56287,adapt,adaptor,56287,doc/master/RooAbsReal_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html,1,['adapt'],['adaptor']
Energy Efficiency,"ontal string then the rotation is applied on the alignment variables. SetRotation and LayoutGlyphs should have been called before. ; Definition at line 1203 of file TGWin32.cxx. ◆ AllocColor() [1/2]. Bool_t TGWin32::AllocColor ; (; Colormap_t ; cmap, . ColorStruct_t & ; color . ). overridevirtual . Find and allocate a color cell according to the color values specified in the ColorStruct_t. ; If no cell could be allocated it returns kFALSE, otherwise kTRUE. ; Reimplemented from TVirtualX.; Definition at line 5756 of file TGWin32.cxx. ◆ AllocColor() [2/2]. Bool_t TGWin32::AllocColor ; (; GdkColormap * ; cmap, . GdkColor * ; color . ). protected . Allocate color in colormap. ; If we are on an <= 8 plane machine we will use XAllocColor. If we are on a >= 15 (15, 16 or 24) plane true color machine we will calculate the pixel value using: for 15 and 16 bit true colors have 6 bits precision per color however only the 5 most significant bits are used in the color index. Except for 16 bits where green uses all 6 bits. I.e.: 15 bits = rrrrrgggggbbbbb 16 bits = rrrrrggggggbbbbb for 24 bits each r, g and b are represented by 8 bits.; Since all colors are set with a max of 65535 (16 bits) per r, g, b we just right shift them by 10, 11 and 10 bits for 16 planes, and (10, 10, 10 for 15 planes) and by 8 bits for 24 planes. Returns kFALSE in case color allocation failed. ; Definition at line 1159 of file TGWin32.cxx. ◆ Bell(). void TGWin32::Bell ; (; Int_t ; percent). overridevirtual . Sets the sound bell. Percent is loudness from -100% to 100%. ; Reimplemented from TVirtualX.; Definition at line 6307 of file TGWin32.cxx. ◆ ChangeActivePointerGrab(). void TGWin32::ChangeActivePointerGrab ; (; Window_t ; win, . UInt_t ; mask, . Cursor_t ; cur . ). overridevirtual . Changes the active cursor of the specified window. ; Reimplemented from TVirtualX.; Definition at line 7644 of file TGWin32.cxx. ◆ ChangeGC(). void TGWin32::ChangeGC ; (; GContext_t ; gc, . GCValues_t * ; gval . ). overrid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32.html:54596,green,green,54596,doc/master/classTGWin32.html,https://root.cern,https://root.cern/doc/master/classTGWin32.html,1,['green'],['green']
Energy Efficiency,"ontent and errors are zero, are excluded. TGraph2D(const char* name, const char* title, Int_t n, Double_t* x, Double_t* y, Double_t* z); Graph2D constructor with name, title and three vectors of doubles as input.; name : name of 2D graph (avoid blanks); title : 2D graph title; if title is of the form ""stringt;stringx;stringy;stringz""; the 2D graph title is set to stringt, the x axis title to stringx,; the y axis title to stringy,etc. TGraph2D(Int_t n); Graph2D constructor. The arrays fX, fY and fZ should be filled via; calls to SetPoint. TGraph2D(const char* filename, const char* format = ""%lg %lg %lg"", Option_t* option = """"); Graph2D constructor reading input from filename; filename is assumed to contain at least three columns of numbers. TGraph2D(const TGraph2D& ); Graph2D copy constructor. ~TGraph2D(); TGraph2D destructor. TGraph2D& operator=(const TGraph2D& ); Graph2D operator ""="". void Build(Int_t n); Creates the 2D graph basic data structure. void Clear(Option_t* option = """"); Free all memory allocated by this object. void DirectoryAutoAdd(TDirectory* ); Perform the automatic addition of the graph to the given directory. Note this function is called in place when the semantic requires; this object to be added to a directory (I.e. when being read from; a TKey or being Cloned). Int_t DistancetoPrimitive(Int_t px, Int_t py); Computes distance from point px,py to a graph. void Draw(Option_t* option = """"); Specific drawing options can be used to paint a TGraph2D:. ""TRI"" : The Delaunay triangles are drawn using filled area.; An hidden surface drawing technique is used. The surface is; painted with the current fill area color. The edges of each; triangles are painted with the current line color.; ""TRIW"" : The Delaunay triangles are drawn as wire frame; ""TRI1"" : The Delaunay triangles are painted with color levels. The edges; of each triangles are painted with the current line color.; ""TRI2"" : the Delaunay triangles are painted with color levels.; ""P"" : Draw a marker a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraph2D.html:18924,allocate,allocated,18924,root/html528/TGraph2D.html,https://root.cern,https://root.cern/root/html528/TGraph2D.html,2,['allocate'],['allocated']
Energy Efficiency,"ontent on internal data structure see convention for numbering bins in TH1::GetBin. ;  ; void SetBins (const Int_t *nbins, const Double_t *range);  ;  Protected Member Functions inherited from TH1D; void UpdateBinContent (Int_t bin, Double_t content) override;  Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ;  Protected Member Functions inherited from TH1;  TH1 ();  Histogram default constructor. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins);  Constructor for variable bin size histograms using an input array of type double. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Float_t *xbins);  Constructor for variable bin size histograms using an input array of type float. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup);  Constructor for fix bin size histograms. ;  ; virtual Int_t AutoP2FindLimits (Double_t min, Double_t max);  Buffer-based estimate of the histogram range using the power of 2 algorithm. ;  ; Int_t AxisChoice (Option_t *axis) const;  Choose an axis according to ""axis"". ;  ; virtual void DoFillN (Int_t ntimes, const Double_t *x, const Double_t *w, Int_t stride=1);  Internal method to fill histogram content from a vector called directly by TH1::BufferEmpty. ;  ; virtual Double_t DoIntegral (Int_t ix1, Int_t ix2, Int_t iy1, Int_t iy2, Int_t iz1, Int_t iz2, Double_t &err, Option_t *opt, Bool_t doerr=kFALSE) const;  Internal function compute integral and optionally the error between the limits specified by the bin number values working for all histograms (1D, 2D and 3D) ;  ; virtual Bool_t FindNewAxisLimits (const TAxis *axis, const Double_t point, Double_t &newMin, Double_t &newMax);  finds new limits for the axis so that point is within the range and the limits are compatible with the previous ones (see TH1::Merge). ;  ; UInt_t GetAxisLabelStatus () const;  Internal function used in TH1::Fill to see ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile.html:48576,power,power,48576,doc/master/classTProfile.html,https://root.cern,https://root.cern/doc/master/classTProfile.html,1,['power'],['power']
Energy Efficiency,"ooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsData.html:15787,reduce,reduce,15787,root/html534/RooAbsData.html,https://root.cern,https://root.cern/root/html534/RooAbsData.html,6,['reduce'],"['reduce', 'reduced']"
Energy Efficiency,"ooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); voidcacheValidEntries(); Int_tcalcTreeIndex() const; voidcalculatePartialBinVolume(const RooArgSet& dimSet) const; Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidimportDHistSet(const RooArgList& vars, RooCategory& indexCat, map<std::string,RooDataHist*> dmap, Double_t initWgt); voidimportTH1(const RooArgList& vars, TH1& histo, Double_t initWgt); voidimportTH1Set(const RooArgList& vars, RooCategory& indexCat, map<std::string,TH1*> hmap, Double_t initWgt); voidinitialize(const char* binningName = 0, Bool_t fillTree = kTRUE); Double_tinterpolateDim(RooRealVar& dim, const RooAbsBinning* binning, Double_t xval, Int_t intOrder, Bool_t correctForBinSize, Bool_t cdfBoundaries); voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); voidRooDirItem::removeFromDir(TObject* obj); virtual voidRooAbsData::resetCache(); voidsetAllWeights(Double_t value); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataHist.html:15580,reduce,reduceEng,15580,root/html526/RooDataHist.html,https://root.cern,https://root.cern/root/html526/RooDataHist.html,1,['reduce'],['reduceEng']
Energy Efficiency,"ooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Utility function for plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and UInt_t; branch in that order. If any of these are found the buffer for; that branch is set to a correctly typed conversion buffer in this; RooRealVar. A flag is set that will cause copyCache to copy the; object value from the appropriate conversion buffer instead of; the _value buffer. void fillTreeBranch(TTree& t); Fill the tree branch that associated with ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:55515,adapt,adaptor,55515,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,3,['adapt'],['adaptor']
Energy Efficiency,"ooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Utility function for plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToVStore(RooVectorDataStore& vstore). void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and UInt_t; branch in that order. If any of these are found the buffer for; that branch is set to a correctly typed conversion buffer in this; RooRealVar. A flag is set that will cause copyCache to copy the; object value from the appropriate conversion buffer instead of; the _value buff",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsReal.html:57030,adapt,adaptor,57030,root/html532/RooAbsReal.html,https://root.cern,https://root.cern/root/html532/RooAbsReal.html,4,['adapt'],['adaptor']
Energy Efficiency,"ooArgSet* iset, RooAddModel::pRooArgList& compIntList, Int_t& code, const char* isetRangeName) const; Check if this configuration was created before. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral defined by given scenario code. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events, which is either the sum of all coefficients; or the sum of the components extended terms. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fraction coefficients. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized context to efficiently generate toy events from RooAddPdfs. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Direct generation is safe if all components say so. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Return pseud-code that indicates if all components can do internal generation (1) or not (0). void generateEvent(Int_t code); This function should never be called as RooAddModel implements a custom generator context. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooAddModel to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooAddModel(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. Bool_t selfNormalized() const; Model is self normalized when used as p.d.f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddModel.html:47656,efficient,efficiently,47656,root/html528/RooAddModel.html,https://root.cern,https://root.cern/root/html528/RooAddModel.html,6,['efficient'],['efficiently']
Energy Efficiency,"ooCmdArg & ; arg8 = {} . ); const. Create a reduced copy of this dataset. ; The caller takes ownership of the returned dataset; The following optional named arguments are accepted . SelectVars(const RooArgSet& vars) Only retain the listed observables in the output dataset . Cut(const char* expression) Only retain event surviving the given cut expression. . Cut(const RooFormulaVar& expr) Only retain event surviving the given cut formula. . CutRange(const char* name) Only retain events inside range with given name. Multiple CutRange arguments may be given to select multiple ranges. Note that this will also consider the variables that are not selected by SelectVars(). . EventRange(int lo, int hi) Only retain events with given sequential event numbers . Name(const char* name) Give specified name to output dataset . Title(const char* name) Give specified title to output dataset . Definition at line 399 of file RooAbsData.cxx. ◆ reduce() [5/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const RooFormulaVar & ; cutVar); const. Create a subset of the data set by applying the given cut on the data points. ; The 'cutVar' formula variable is used to select the subset of data points to be retained in the reduced data collection. ; Definition at line 485 of file RooAbsData.cxx. ◆ reduceEng(). virtual std::unique_ptr< RooAbsData > RooAbsData::reduceEng ; (; const RooArgSet & ; varSubset, . const RooFormulaVar * ; cutVar, . const char * ; cutRange = nullptr, . std::size_t ; nStart = 0, . std::size_t ; = std::numeric_limits< std::size_t >::max() . ); const. protectedpure virtual . Implemented in RooDataHist, and RooDataSet. ◆ reset(). void RooAbsData::reset ; (; ). virtual . Reimplemented in RooDataHist.; Definition at line 330 of file RooAbsData.cxx. ◆ resetBuffers(). void RooAbsData::resetBuffers ; (; ). Definition at line 2344 of file RooAbsData.cxx. ◆ resetCache(). void RooAbsData::resetCache ; (; ). protectedvirtual . Internal method – Remove cached function value",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:64657,reduce,reduce,64657,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['reduce'],['reduce']
Energy Efficiency,"ooDataSet ds2(""ds2"", ""ds2"", RooArgSet(x, y, z), Import(*tree), Cut(""y+z<0""));; ds2.Print();; ; // I m p o r t i n g i n t e g e r T T r e e b r a n c h e s; // ---------------------------------------------------------------; ; // Import integer tree branch as RooRealVar; RooRealVar i(""i"", ""i"", 0, 5);; RooDataSet ds3(""ds3"", ""ds3"", RooArgSet(i, x), Import(*tree));; ds3.Print();; ; // Define category i; RooCategory icat(""i"", ""i"");; icat.defineType(""State0"", 0);; icat.defineType(""State1"", 1);; ; // Import integer tree branch as RooCategory (only events with i==0 and i==1; // will be imported as those are the only defined states); RooDataSet ds4(""ds4"", ""ds4"", RooArgSet(icat, x), Import(*tree));; ds4.Print();; ; // I m p o r t m u l t i p l e R o o D a t a S e t s i n t o a R o o D a t a S e t; // ----------------------------------------------------------------------------------------; ; // Create three RooDataSets in (y,z); std::unique_ptr<RooAbsData> dsA{ds2.reduce({x, y}, ""z<-5"")};; std::unique_ptr<RooAbsData> dsB{ds2.reduce({x, y}, ""abs(z)<5"")};; std::unique_ptr<RooAbsData> dsC{ds2.reduce({x, y}, ""z>5"")};; ; // Create a dataset that imports contents of all the above datasets mapped by index category c; RooDataSet dsABC{""dsABC"", ""dsABC"", RooArgSet(x, y), Index(c), Import(""SampleA"", *dsA),; Import(""SampleB"", *dsB), Import(""SampleC"", *dsC)};; ; dsABC.Print();; }; ; TH1 *makeTH1(const char *name, double mean, double sigma); {; // Create ROOT TH1 filled with a Gaussian distribution; ; TH1D *hh = new TH1D(name, name, 100, -10, 10);; for (int i = 0; i < 1000; i++) {; hh->Fill(gRandom->Gaus(mean, sigma));; }; return hh;; }; ; TTree *makeTTree(); {; // Create ROOT TTree filled with a Gaussian distribution in x and a uniform distribution in y; ; TTree *tree = new TTree(""tree"", ""tree"");; double *px = new double;; double *py = new double;; double *pz = new double;; Int_t *pi = new Int_t;; tree->Branch(""x"", px, ""x/D"");; tree->Branch(""y"", py, ""y/D"");; tree->Branch(""z"", pz, ""z/D"");;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf401__importttreethx_8C.html:3267,reduce,reduce,3267,doc/master/rf401__importttreethx_8C.html,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8C.html,1,['reduce'],['reduce']
Energy Efficiency,"ooLagrangianMorphFunc.cxx. ◆ init(). void RooLagrangianMorphFunc::init ; (; ). private . initialise inputs required for the morphing function ; Definition at line 1910 of file RooLagrangianMorphFunc.cxx. ◆ insert(). void RooLagrangianMorphFunc::insert ; (; RooWorkspace * ; ws). ◆ IsA(). TClass * RooLagrangianMorphFunc::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsReal.; Definition at line 257 of file RooLagrangianMorphFunc.h. ◆ isBinnedDistribution(). bool RooLagrangianMorphFunc::isBinnedDistribution ; (; const RooArgSet & ; obs); const. overridevirtual . check if this PDF is a binned distribution in the given observable ; Reimplemented from RooAbsReal.; Definition at line 2922 of file RooLagrangianMorphFunc.cxx. ◆ isCouplingUsed(). bool RooLagrangianMorphFunc::isCouplingUsed ; (; const char * ; couplname). check if there is any morphing power provided for the given coupling morphing power is provided as soon as any two samples provide different, non-zero values for this coupling ; Definition at line 2634 of file RooLagrangianMorphFunc.cxx. ◆ isParameterConstant(). bool RooLagrangianMorphFunc::isParameterConstant ; (; const char * ; paramname); const. return true if the parameter with the given name is set constant, false otherwise ; Definition at line 2412 of file RooLagrangianMorphFunc.cxx. ◆ isParameterUsed(). bool RooLagrangianMorphFunc::isParameterUsed ; (; const char * ; paramname); const. check if there is any morphing power provided for the given parameter morphing power is provided as soon as any two samples provide different, non-zero values for this parameter ; Definition at line 2613 of file RooLagrangianMorphFunc.cxx. ◆ makeRatio(). std::unique_ptr< RooRatio > RooLagrangianMorphFunc::makeRatio ; (; const char * ; name, . const char * ; title, . RooArgList & ; nr, . RooArgList & ; dr . ). static . Return the RooRatio form of products and denominators of morphing functions. ; Definition at l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLagrangianMorphFunc.html:85698,power,power,85698,doc/master/classRooLagrangianMorphFunc.html,https://root.cern,https://root.cern/doc/master/classRooLagrangianMorphFunc.html,2,['power'],['power']
Energy Efficiency,"ooParamHistFunc(const char* name, const char* title, const RooAbsArg& x, RooDataHist& dh, Bool_t paramRelative = kTRUE); Populate x with observables. RooParamHistFunc(const char* name, const char* title, RooDataHist& dh, const RooParamHistFunc& paramSource, Bool_t paramRelative = kTRUE). RooParamHistFunc(const RooParamHistFunc& other, const char* name = 0). Double_t evaluate() const. Double_t getActual(Int_t ibin). void setActual(Int_t ibin, Double_t newVal). Double_t getNominal(Int_t ibin) const. Double_t getNominalError(Int_t ibin) const. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implement analytical integrations by doing appropriate weighting from component integrals; functions to integrators of components. RooParamHistFunc(); {}. TObject* clone(const char* newname) const; { return new RooParamHistFunc(*this,newname); }. virtual ~RooParamHistFunc(); { }. Bool_t isBinnedDistribution(const RooArgSet& ) const; { return kTRUE ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; { return kTRUE ; }. const RooArgList& paramList() const; { return _p ; }. » Last changed: Tue Jun 2 15:32:51 2015 » Last generated: 2015-06-02 15:32; This",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooParamHistFunc.html:38681,efficient,efficiently,38681,root/html604/RooParamHistFunc.html,https://root.cern,https://root.cern/root/html604/RooParamHistFunc.html,1,['efficient'],['efficiently']
Energy Efficiency,"ooParamHistFunc(const char* name, const char* title, const RooAbsArg& x, RooDataHist& dh, Bool_t paramRelative = kTRUE); Populate x with observables. RooParamHistFunc(const char* name, const char* title, RooDataHist& dh, const RooParamHistFunc& paramSource, Bool_t paramRelative = kTRUE). RooParamHistFunc(const RooParamHistFunc& other, const char* name = 0). Double_t evaluate() const. Double_t getActual(Int_t ibin). void setActual(Int_t ibin, Double_t newVal). Double_t getNominal(Int_t ibin) const. Double_t getNominalError(Int_t ibin) const. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implement analytical integrations by doing appropriate weighting from component integrals; functions to integrators of components. RooParamHistFunc(); {}. TObject* clone(const char* newname) const; { return new RooParamHistFunc(*this,newname); }. virtual ~RooParamHistFunc(); { }. Bool_t isBinnedDistribution(const RooArgSet& ) const; { return kTRUE ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; { return kTRUE ; }. const RooArgList& paramList() const; { return _p ; }. » Last changed: Tue Jun 30 14:34:46 2015 » Last generated: 2015-06-30 14:34; Thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooParamHistFunc.html:38681,efficient,efficiently,38681,root/html602/RooParamHistFunc.html,https://root.cern,https://root.cern/root/html602/RooParamHistFunc.html,1,['efficient'],['efficiently']
Energy Efficiency,"ooParamHistFunc(const char* name, const char* title, const RooAbsArg& x, RooDataHist& dh, Bool_t paramRelative = kTRUE); Populate x with observables. RooParamHistFunc(const char* name, const char* title, RooDataHist& dh, const RooParamHistFunc& paramSource, Bool_t paramRelative = kTRUE). RooParamHistFunc(const RooParamHistFunc& other, const char* name = 0). Double_t evaluate() const. Double_t getActual(Int_t ibin). void setActual(Int_t ibin, Double_t newVal). Double_t getNominal(Int_t ibin) const. Double_t getNominalError(Int_t ibin) const. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implement analytical integrations by doing appropriate weighting from component integrals; functions to integrators of components. RooParamHistFunc(); {}. TObject* clone(const char* newname) const; { return new RooParamHistFunc(*this,newname); }. virtual ~RooParamHistFunc(); { }. Bool_t isBinnedDistribution(const RooArgSet& ) const; { return kTRUE ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; { return kTRUE ; }. const RooArgList& paramList() const; { return _p ; }. » Last changed: Tue Mar 10 17:18:21 2015 » Last generated: 2015-03-10 17:18; Thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooParamHistFunc.html:37171,efficient,efficiently,37171,root/html534/RooParamHistFunc.html,https://root.cern,https://root.cern/root/html534/RooParamHistFunc.html,1,['efficient'],['efficiently']
Energy Efficiency,"ooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents.; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool; TNamed*RooAbsCollection::_structureTag! Structure tag; TNamed*RooAbsCollection::_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooArgSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void* operator new(size_t bytes, void* ptr); Overloaded new operator with placement does not guarante that all; RooArgSets allocated with new have a unique address, but uses the global; operator. void operator delete(void* ptr); Memory is owned by pool, we need to do nothing to release it. RooArgSet(); Default constructor. RooArgSet(const RooArgList& list); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. RooArgSet(const RooArgList& list, const RooAbsArg* var1); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. RooArgSet(const char* name); Empty set constructor. RooArgSet(const RooArgSet& set1, const RooArgSet& set2, const char* name = """"); Construct a set from two existing sets. RooArgSet(const RooAbsArg& var1, const char* name = """"); Constructor for set containing 1 initial object. RooArgSet(const RooAbsArg& var1, const RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooArgSet.html:16094,allocate,allocated,16094,root/html602/RooArgSet.html,https://root.cern,https://root.cern/root/html602/RooArgSet.html,2,['allocate'],['allocated']
Energy Efficiency,"ooPrintable::printAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); static RooDataSet*read(const char* filename, const RooArgList& variables, const char* opts = """", const char* commonPath = """", const char* indexCatName = 0); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(RooCmdArg arg1, RooCmdArg arg2 = RooCmdArg(), RooCmdArg arg3 = RooCmdArg(), RooCmdArg arg4 = RooCmdArg(), RooCmdArg arg5 = RooCmdArg(), RooCmdArg arg6 = RooCmdArg(), RooCmdArg arg7 = RooCmdArg(), RooCmdArg arg8 = RooCmdArg()); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MEN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataSet.html:9855,reduce,reduce,9855,root/html526/RooDataSet.html,https://root.cern,https://root.cern/root/html526/RooDataSet.html,1,['reduce'],['reduce']
Energy Efficiency,"ooPrintable::printAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); static RooDataSet*read(const char* filename, const RooArgList& variables, const char* opts = """", const char* commonPath = """", const char* indexCatName = 0); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyPro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDataSet.html:10108,reduce,reduce,10108,root/html530/RooDataSet.html,https://root.cern,https://root.cern/root/html530/RooDataSet.html,1,['reduce'],['reduce']
Energy Efficiency,"ooPrintable::printAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); static RooDataSet*read(const char* filename, const RooArgList& variables, const char* opts = """", const char* commonPath = """", const char* indexCatName = 0); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; RooDataSet(); RooDataSet(const RooDataSet& other, const char* newname = 0); RooDataSet(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0); RooDataSet(const char* name, const char* title, RooDataS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataSet.html:9183,reduce,reduce,9183,root/html602/RooDataSet.html,https://root.cern,https://root.cern/root/html602/RooDataSet.html,2,['reduce'],['reduce']
Energy Efficiency,"ooPrintable::printAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); static RooDataSet*read(const char* filename, const RooArgList& variables, const char* opts = """", const char* commonPath = """", const char* indexCatName = 0); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDataSet.html:10204,reduce,reduce,10204,root/html532/RooDataSet.html,https://root.cern,https://root.cern/root/html532/RooDataSet.html,2,['reduce'],['reduce']
Energy Efficiency,"ooPrintable::printAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); static RooDataSet*read(const char* filename, const RooArgList& variables, const char* opts = """", const char* commonPath = """", const char* indexCatName = 0); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t flag); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDataSet.html:9911,reduce,reduce,9911,root/html528/RooDataSet.html,https://root.cern,https://root.cern/root/html528/RooDataSet.html,1,['reduce'],['reduce']
Energy Efficiency,"ool_t GetRnrReferences () const;  ; EStepper_e GetStepper () const;  ; Double_t GetTrackLength (Int_t start_point=0, Int_t end_point=-1) const;  Calculate track length from start_point to end_point. ;  ; virtual void GoToBounds (TEveVectorD &p);  Propagate particle to bounds. ;  ; void GoToBounds (TEveVectorF &p);  TEveVectorF wrapper. ;  ; virtual Bool_t GoToLineSegment (const TEveVectorD &s, const TEveVectorD &r, TEveVectorD &p);  Propagate particle with momentum p to line with start point s and vector r to the second point. ;  ; Bool_t GoToLineSegment (const TEveVectorF &s, const TEveVectorF &r, TEveVectorF &p);  TEveVectorF wrapper. ;  ; virtual Bool_t GoToVertex (TEveVectorD &v, TEveVectorD &p);  Propagate particle with momentum p to vertex v. ;  ; Bool_t GoToVertex (TEveVectorF &v, TEveVectorF &p);  TEveVectorF wrapper. ;  ; void InitTrack (const TEveVectorD &v, Int_t charge);  Initialize internal data-members for given particle parameters. ;  ; void InitTrack (const TEveVectorF &v, Int_t charge);  TEveVectorF wrapper. ;  ; Bool_t IntersectPlane (const TEveVectorD &p, const TEveVectorD &point, const TEveVectorD &normal, TEveVectorD &itsect);  Find intersection of currently propagated track with a plane. ;  ; TClass * IsA () const override;  ; void OnZeroRefCount () override;  Virtual from TEveRefBackPtr - track reference count has reached zero. ;  ; void PrintMagField (Double_t x, Double_t y, Double_t z) const;  ; TMarker & RefFVAtt ();  ; TMarker & RefPMAtt ();  ; TMarker & RefPTBAtt ();  ; void ResetTrack ();  Reset cache holding particle trajectory. ;  ; void SetDelta (Double_t x);  Set maximum error and rebuild tracks. ;  ; void SetEditPathMarks (Bool_t x);  ; void SetFitCluster2Ds (Bool_t x);  Set 2D-cluster fitting and rebuild tracks. ;  ; void SetFitDaughters (Bool_t x);  Set daughter creation point fitting and rebuild tracks. ;  ; void SetFitDecay (Bool_t x);  Set decay fitting and rebuild tracks. ;  ; void SetFitLineSegments (Bool_t x);  Set line segm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveTrackPropagator.html:5402,charge,charge,5402,doc/master/classTEveTrackPropagator.html,https://root.cern,https://root.cern/doc/master/classTEveTrackPropagator.html,1,['charge'],['charge']
Energy Efficiency,"oordSystem > . constexpr ROOT::Math::PxPyPzM4D< ScalarType >::PxPyPzM4D ; (; const CoordSystem & ; v). inlineexplicitconstexpr . construct from any 4D coordinate system class implementing X(), Y(), X() and M() ; Definition at line 78 of file PxPyPzM4D.h. ◆ PxPyPzM4D() [4/4]. template<class ScalarType = double> . ROOT::Math::PxPyPzM4D< ScalarType >::PxPyPzM4D ; (; const PxPyPzM4D< ScalarType > & ; v). inline . copy constructor ; Definition at line 87 of file PxPyPzM4D.h. Member Function Documentation. ◆ E(). template<class ScalarType = double> . Scalar ROOT::Math::PxPyPzM4D< ScalarType >::E ; (; ); const. inline . Energy. ; Definition at line 160 of file PxPyPzM4D.h. ◆ E2(). template<class ScalarType = double> . Scalar ROOT::Math::PxPyPzM4D< ScalarType >::E2 ; (; ); const. inline . energy squared ; Definition at line 189 of file PxPyPzM4D.h. ◆ Et(). template<class ScalarType = double> . Scalar ROOT::Math::PxPyPzM4D< ScalarType >::Et ; (; ); const. inline . transverse energy ; Definition at line 241 of file PxPyPzM4D.h. ◆ Et2(). template<class ScalarType = double> . Scalar ROOT::Math::PxPyPzM4D< ScalarType >::Et2 ; (; ); const. inline . transverse energy squared ; Definition at line 232 of file PxPyPzM4D.h. ◆ Eta(). template<class ScalarType = double> . Scalar ROOT::Math::PxPyPzM4D< ScalarType >::Eta ; (; ); const. inline . pseudorapidity ; Definition at line 260 of file PxPyPzM4D.h. ◆ GetCoordinates() [1/2]. template<class ScalarType = double> . void ROOT::Math::PxPyPzM4D< ScalarType >::GetCoordinates ; (; Scalar & ; px, . Scalar & ; py, . Scalar & ; pz, . Scalar & ; m . ); const. inline . get internal data into 4 Scalar numbers ; Definition at line 140 of file PxPyPzM4D.h. ◆ GetCoordinates() [2/2]. template<class ScalarType = double> . void ROOT::Math::PxPyPzM4D< ScalarType >::GetCoordinates ; (; Scalar ; dest[]); const. inline . get internal data into an array of 4 Scalar numbers ; Definition at line 126 of file PxPyPzM4D.h. ◆ M(). template<class ScalarType = doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1PxPyPzM4D.html:6050,energy,energy,6050,doc/master/classROOT_1_1Math_1_1PxPyPzM4D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1PxPyPzM4D.html,1,['energy'],['energy']
Energy Efficiency,"oordinate to PDF. ; Definition at line 2399 of file TPDF.cxx. Member Data Documentation. ◆ fAlpha. Float_t TPDF::fAlpha. protected . Per cent of transparency. ; Definition at line 36 of file TPDF.h. ◆ fAlphas. std::vector<float> TPDF::fAlphas. protected . List of alpha values used. ; Definition at line 37 of file TPDF.h. ◆ fBlue. Float_t TPDF::fBlue. protected . Per cent of blue. ; Definition at line 35 of file TPDF.h. ◆ fCompress. Bool_t TPDF::fCompress. protected . True when fBuffer must be compressed. ; Definition at line 50 of file TPDF.h. ◆ fgLineCap. Int_t TPDF::fgLineCap = 0. staticprotected . Appearance of line caps. ; Definition at line 54 of file TPDF.h. ◆ fgLineJoin. Int_t TPDF::fgLineJoin = 0. staticprotected . Appearance of joining lines. ; Definition at line 53 of file TPDF.h. ◆ fgObjectIsOpen. Bool_t TPDF::fgObjectIsOpen = kFALSE. staticprotected . Indicates if an object is open. ; Definition at line 55 of file TPDF.h. ◆ fGreen. Float_t TPDF::fGreen. protected . Per cent of green. ; Definition at line 34 of file TPDF.h. ◆ fLineScale. Float_t TPDF::fLineScale. protected . Line width scale factor. ; Definition at line 44 of file TPDF.h. ◆ fNbObj. Int_t TPDF::fNbObj {0}. protected . Number of objects. ; Definition at line 47 of file TPDF.h. ◆ fNbPage. Int_t TPDF::fNbPage. protected . Number of pages. ; Definition at line 48 of file TPDF.h. ◆ fObjPos. Int_t* TPDF::fObjPos {nullptr}. protected . Objects position. ; Definition at line 45 of file TPDF.h. ◆ fObjPosSize. Int_t TPDF::fObjPosSize {0}. protected . Real size of fObjPos. ; Definition at line 46 of file TPDF.h. ◆ fPageFormat. Int_t TPDF::fPageFormat. protected . Page format (A4, Letter etc ...) ; Definition at line 41 of file TPDF.h. ◆ fPageNotEmpty. Bool_t TPDF::fPageNotEmpty. protected . True if the current page is not empty. ; Definition at line 49 of file TPDF.h. ◆ fPageOrientation. Int_t TPDF::fPageOrientation. protected . Page orientation (Portrait, Landscape) ; Definition at line 42 of file TP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPDF.html:41505,green,green,41505,doc/master/classTPDF.html,https://root.cern,https://root.cern/doc/master/classTPDF.html,1,['green'],['green']
Energy Efficiency,"oost.h. ◆ fBoostNum. UInt_t TMVA::MethodBoost::fBoostNum. private . Number of times the classifier is boosted. ; Definition at line 153 of file MethodBoost.h. ◆ fBoostType. TString TMVA::MethodBoost::fBoostType. private . string specifying the boost type ; Definition at line 154 of file MethodBoost.h. ◆ fBoostWeight. Double_t TMVA::MethodBoost::fBoostWeight. private . the weight used to boost the next classifier ; Definition at line 182 of file MethodBoost.h. ◆ fBTrainBgdMVAHist. std::vector< TH1* > TMVA::MethodBoost::fBTrainBgdMVAHist. private . Definition at line 174 of file MethodBoost.h. ◆ fBTrainSigMVAHist. std::vector< TH1* > TMVA::MethodBoost::fBTrainSigMVAHist. private . Definition at line 173 of file MethodBoost.h. ◆ fDataSetManager. DataSetManager* TMVA::MethodBoost::fDataSetManager. private . DSMTEST. ; Definition at line 193 of file MethodBoost.h. ◆ fDetailedMonitoring. Bool_t TMVA::MethodBoost::fDetailedMonitoring. private . produce detailed monitoring histograms (boost-wise) ; Definition at line 157 of file MethodBoost.h. ◆ fHistoricBoolOption. Bool_t TMVA::MethodBoost::fHistoricBoolOption. private . historic variable, only needed for ""CompatibilityOptions"" ; Definition at line 195 of file MethodBoost.h. ◆ fHistoricOption. TString TMVA::MethodBoost::fHistoricOption. private . historic variable, only needed for ""CompatibilityOptions"" ; Definition at line 194 of file MethodBoost.h. ◆ fMethodError. Double_t TMVA::MethodBoost::fMethodError. private . estimation of the level error of the classifier ; Definition at line 183 of file MethodBoost.h. ◆ fMonitorBoostedMethod. Bool_t TMVA::MethodBoost::fMonitorBoostedMethod. private . monitor the MVA response of every classifier ; Definition at line 167 of file MethodBoost.h. ◆ fMonitorTree. TTree* TMVA::MethodBoost::fMonitorTree. private . tree to monitor values during the boosting ; Definition at line 181 of file MethodBoost.h. ◆ fMVAvalues. std::vector<Float_t>* TMVA::MethodBoost::fMVAvalues. private . mva valu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBoost.html:43655,monitor,monitoring,43655,doc/master/classTMVA_1_1MethodBoost.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBoost.html,1,['monitor'],['monitoring']
Energy Efficiency,"oot[] stack_ptr->Solve();; Here we have a Quad pointer that has been initialized with the address of a stack object. Be very careful if you take the address of stack objects. As we shall see soon, they are deleted automatically, which could leave you with an illegal pointer. Using it will corrupt and may as well crash the program!; It is time to look at the destruction of objects. A destructor is a special C++ function that releases resources for (or destroys) an object of a class. It is the opposite of a constructor that creates the object of a class when it is called. The compiler will provide a destructor that does nothing if none is provided. We will add one to our Quad class so that we can see when it is called. The class names the destructor but with a prefix ~ which is the C++ one’s complement i.e. bit wise complement, and hence has destruction overtones! We declare it in the .h file and define it in the .cxx file. It does not do much except print out that it has been called (still a useful debug technique despite today’s powerful debuggers!).; Now run root, load the Quad class and create a heap object:; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; To delete the object:; root[] delete my_objptr;; root[] my_objptr = 0;; You should see the print out from its destructor. Setting the pointer to zero afterwards is not strictly necessary (and Cling does it automatically), but the object is no more accessible, and any attempt to use the pointer again will, as has already been stated, cause grief. So much for heap objects, but how are stack objects deleted? In C++, a stack object is deleted as soon as control leaves the innermost compound statement that encloses it. Therefore, it is singularly futile to do something like:; root[] { Quad my_object(1.,2.,-3.); }; Cling does not follow this rule; if you type in the above line, you will not see the destructor message. As explained in the Script lesson, you can load in compound statements, which would",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:253671,power,powerful,253671,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['power'],['powerful']
Energy Efficiency,"op(); virtual voidRooAbsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); voidremoveSelfFromDir(); virtual voidreset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; RooDataHist(); RooDataHist(const RooDataHist& other, const char* newname = 0); RooDataHist(const char* name, const char* title, const RooArgSet& vars, const char* binningName = 0); RooDataHist(const char* name, const char* title, const RooArgSet& vars, const RooAbsData& data, Double_t initWgt = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataHist.html:8687,reduce,reduce,8687,root/html602/RooDataHist.html,https://root.cern,https://root.cern/root/html602/RooDataHist.html,4,['reduce'],['reduce']
Energy Efficiency,"operator has been made private. Use Close() to properly; terminate a TMapFile (also done via the TROOT dtor). void InitDirectory(); Create the directory associated to this mapfile. void Add(const TObject* obj, const char* name = """"); Add an object to the list of objects to be stored in shared memory.; To place the object actually into shared memory call Update(). void Update(TObject* obj = 0); Update an object (or all objects, if obj == 0) in shared memory. TObject * Remove(TObject* obj, Bool_t lock); Remove object from shared memory. Returns pointer to removed; object if successful, 0 otherwise. TObject * Remove(const char* name, Bool_t lock); Remove object by name from shared memory. Returns pointer to removed; object if successful, 0 otherwise. void RemoveAll(); Remove all objects from shared memory. TObject * Get(const char* name, TObject* retObj = 0); Return pointer to object retrieved from shared memory. The object must; be deleted after use. If delObj is a pointer to a previously allocated; object it will be deleted. Returns 0 in case object with the given; name does not exist. void CreateSemaphore(Int_t pid = 0); Create semaphore used for synchronizing access to shared memory. void DeleteSemaphore(); Delete the semaphore. Int_t AcquireSemaphore(); Acquire semaphore. Returns 0 if OK, -1 on error. Int_t ReleaseSemaphore(); Release semaphore. Returns 0 if OK, -1 on error. void Close(Option_t* option = """"); Close a mapped file. First detach mapped memory then close file.; No member functions of a TMapFile that was opened in write mode; may be called after Close() (this includes, of course, ""delete"" which; would call the dtors). The option=""dtor"" is only used when called; via the ~TMapFile. TMapFile * FindShadowMapFile(); Returns shadow map file. void Print(Option_t* option = """") const; Print some info about the mapped file. Bool_t IsFolder() const; Returns kTRUE in case object is a folder (i.e. contains browsable lists). void Browse(TBrowser* b); Browse contents ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMapFile.html:11508,allocate,allocated,11508,root/html528/TMapFile.html,https://root.cern,https://root.cern/root/html528/TMapFile.html,6,['allocate'],['allocated']
Energy Efficiency,"opriate cells is done when the bin is added; to the histogram. To do this, AddBin() calls the; AddBinToPartition() method.; This method adds the input bin to the partitioning matrix. The number of partition cells per axis can be specified in the constructor.; If it is not specified, the default value of 25 along each axis will be; assigned. This value was chosen because it is small enough to avoid slowing; down AddBin(), while being large enough to enhance Fill() by a considerable; amount. Regardless of how it is initialized at construction time, it can be; changed later with the ChangePartition() method.; ChangePartition() deletes the; old partition matrix and generates a new one with the specified number of cells; on each axis. The optimum number of partition cells per axis changes with the number of; times Fill() will be called. Although partitioning greatly speeds up; filling, it also adds a constant time delay into the code. When Fill(); is to be called many times, it is more efficient to divide the histogram into; a large number cells. However, if the histogram is to be filled only a few; times, it is better to divide into a small number of cells.; . Function Members (Methods); public:. TH2Poly(); TH2Poly(const TH2Poly&); TH2Poly(const char* name, const char* title, Double_t xlow, Double_t xup, Double_t ylow, Double_t yup); TH2Poly(const char* name, const char* title, Int_t nX, Double_t xlow, Double_t xup, Int_t nY, Double_t ylow, Double_t yup); virtual~TH2Poly(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAdd(const TH1* h1, Double_t c1); virtual Bool_tAdd(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual Bool_tAdd(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1); Int_tAddBin(TObject* poly); Int_tAddBin(Int_t n, const Double_t* x, const Double_t* y); Int_tAddBin(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTH1::AddBinContent(Int_t bin); virtual voidTH1::AddBinContent(Int_t bin, Double_t w); s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH2Poly.html:5040,efficient,efficient,5040,root/html534/TH2Poly.html,https://root.cern,https://root.cern/root/html534/TH2Poly.html,1,['efficient'],['efficient']
Energy Efficiency,"opriate cells is done when the bin is added; to the histogram. To do this, AddBin() calls the; AddBinToPartition() method.; This method adds the input bin to the partitioning matrix. The number of partition cells per axis can be specified in the constructor.; If it is not specified, the default value of 25 along each axis will be; assigned. This value was chosen because it is small enough to avoid slowing; down AddBin(), while being large enough to enhance Fill() by a considerable; amount. Regardless of how it is initialized at construction time, it can be; changed later with the ChangePartition() method.; ChangePartition() deletes the; old partition matrix and generates a new one with the specified number of cells; on each axis. The optimum number of partition cells per axis changes with the number of; times Fill() will be called. Although partitioning greatly speeds up; filling, it also adds a constant time delay into the code. When Fill(); is to be called many times, it is more efficient to divide the histogram into; a large number cells. However, if the histogram is to be filled only a few; times, it is better to divide into a small number of cells.; . Function Members (Methods); public:. TH2Poly(); TH2Poly(const TH2Poly&); TH2Poly(const char* name, const char* title, Double_t xlow, Double_t xup, Double_t ylow, Double_t yup); TH2Poly(const char* name, const char* title, Int_t nX, Double_t xlow, Double_t xup, Int_t nY, Double_t ylow, Double_t yup); virtual~TH2Poly(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(const TH1* h1, Double_t c1); virtual voidAdd(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual voidAdd(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1); Int_tAddBin(TObject* poly); Int_tAddBin(Int_t n, const Double_t* x, const Double_t* y); Int_tAddBin(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTH1::AddBinContent(Int_t bin); virtual voidTH1::AddBinContent(Int_t bin, Double_t w); static ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TH2Poly.html:5091,efficient,efficient,5091,root/html530/TH2Poly.html,https://root.cern,https://root.cern/root/html530/TH2Poly.html,2,['efficient'],['efficient']
Energy Efficiency,"opriate cells is done when the bin is added; to the histogram. To do this, AddBin() calls the; AddBinToPartition() method.; This method adds the input bin to the partitioning matrix. The number of partition cells per axis can be specified in the constructor.; If it is not specified, the default value of 25 along each axis will be; assigned. This value was chosen because it is small enough to avoid slowing; down AddBin(), while being large enough to enhance Fill() by a considerable; amount. Regardless of how it is initialized at construction time, it can be; changed later with the ChangePartition() method.; ChangePartition() deletes the; old partition matrix and generates a new one with the specified number of cells; on each axis. The optimum number of partition cells per axis changes with the number of; times Fill() will be called. Although partitioning greatly speeds up; filling, it also adds a constant time delay into the code. When Fill(); is to be called many times, it is more efficient to divide the histogram into; a large number cells. However, if the histogram is to be filled only a few; times, it is better to divide into a small number of cells.; . Function Members (Methods); public:. TH2Poly(); TH2Poly(const TH2Poly&); TH2Poly(const char* name, const char* title, Double_t xlow, Double_t xup, Double_t ylow, Double_t yup); TH2Poly(const char* name, const char* title, Int_t nX, Double_t xlow, Double_t xup, Int_t nY, Double_t ylow, Double_t yup); virtual~TH2Poly(); voidTObject::AbstractMethod(const char* method) const; virtual voidTH1::Add(const TH1* h1, Double_t c1 = 1); virtual voidTH1::Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual voidTH1::Add(const TH1* h, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1)MENU ; Int_tAddBin(TObject* poly); Int_tAddBin(Int_t n, const Double_t* x, const Double_t* y); Int_tAddBin(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTH1::AddBinContent(Int_t bin); virtual voidTH1::AddBinContent(Int_t bi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH2Poly.html:5091,efficient,efficient,5091,root/html528/TH2Poly.html,https://root.cern,https://root.cern/root/html528/TH2Poly.html,1,['efficient'],['efficient']
Energy Efficiency,"opriate cells is done when the bin is added; to the histogram. To do this, AddBin() calls the; AddBinToPartition() method.; This method adds the input bin to the partitioning matrix. The number of partition cells per axis can be specified in the constructor.; If it is not specified, the default value of 25 along each axis will be; assigned. This value was chosen because it is small enough to avoid slowing; down AddBin(), while being large enough to enhance Fill() by a considerable; amount. Regardless of how it is initialized at construction time, it can be; changed later with the ChangePartition() method.; ChangePartition() deletes the; old partition matrix and generates a new one with the specified number of cells; on each axis. The optimum number of partition cells per axis changes with the number of; times Fill() will be called. Although partitioning greatly speeds up; filling, it also adds a constant time delay into the code. When Fill(); is to be called many times, it is more efficient to divide the histogram into; a large number cells. However, if the histogram is to be filled only a few; times, it is better to divide into a small number of cells.; . Function Members (Methods); public:. virtual~TH2Poly(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAdd(const TH1* h1, Double_t c1); virtual Bool_tAdd(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual Bool_tAdd(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1); Int_tAddBin(TObject* poly); Int_tAddBin(Int_t n, const Double_t* x, const Double_t* y); Int_tAddBin(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTH1::AddBinContent(Int_t bin); virtual voidTH1::AddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2Poly.html:5040,efficient,efficient,5040,root/html602/TH2Poly.html,https://root.cern,https://root.cern/root/html602/TH2Poly.html,2,['efficient'],['efficient']
Energy Efficiency,"opriate cells is done when the bin is added; to the histogram. To do this, AddBin() calls the; AddBinToPartition() method.; This method adds the input bin to the partitioning matrix. The number of partition cells per axis can be specified in the constructor.; If it is not specified, the default value of 25 along each axis will be; assigned. This value was chosen because it is small enough to avoid slowing; down AddBin(), while being large enough to enhance Fill() by a considerable; amount. Regardless of how it is initialized at construction time, it can be; changed later with the ChangePartition() method.; ChangePartition() deletes the; old partition matrix and generates a new one with the specified number of cells; on each axis. The optimum number of partition cells per axis changes with the number of; times Fill() will be called. Although partitioning greatly speeds up; filling, it also adds a constant time delay into the code. When Fill(); is to be called many times, it is more efficient to divide the histogram into; a large number cells. However, if the histogram is to be filled only a few; times, it is better to divide into a small number of cells.; . Function Members (Methods); public:. virtual~TH2PolyBin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearContent(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2PolyBin.html:5053,efficient,efficient,5053,root/html602/TH2PolyBin.html,https://root.cern,https://root.cern/root/html602/TH2PolyBin.html,2,['efficient'],['efficient']
Energy Efficiency,"opyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Implementation file for class UnBinData; 12 ; 13#include ""Fit/UnBinData.h""; 14#include ""Math/Error.h""; 15 ; 16#include <cassert>; 17#include <cmath>; 18 ; 19namespace ROOT {; 20 ; 21 namespace Fit {; 22 ; 23/// copy constructor; 24UnBinData::UnBinData(const UnBinData & rhs) :; 25 FitData(rhs),; 26 fWeighted(rhs.fWeighted); 27{}; 28 ; 29///assignment operator; 30UnBinData & UnBinData::operator= ( const UnBinData & rhs ); 31{; 32 FitData::operator=( rhs );; 33 fWeighted = rhs.fWeighted;; 34 return *this;; 35}; 36 ; 37 ; 38 } // end namespace Fit; 39 ; 40} // end namespace ROOT; 41 ; Error.h; UnBinData.h; ROOT::Fit::FitDataBase class for all the fit data types: Stores the coordinates and the DataOptions.Definition FitData.h:56; ROOT::Fit::FitData::operator=FitData & operator=(const FitData &rhs)Definition FitData.cxx:218; ROOT::Fit::UnBinDataClass describing the un-binned data sets (just x coordinates values) of any dimensions.Definition UnBinData.h:46; ROOT::Fit::UnBinData::operator=UnBinData & operator=(const UnBinData &)assignment operatorDefinition UnBinData.cxx:30; ROOT::Fit::UnBinData::fWeightedbool fWeightedDefinition UnBinData.h:293; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int maxpoints=0, unsigned int dim=1, bool isWeighted=false)constructor from dimension of point and max number of points (to pre-allocate vector)Definition UnBinData.h:54; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)Definition HFitImpl.cxx:133; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. mathmathcoresrcUnBinData.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:41 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/UnBinData_8cxx_source.html:1840,allocate,allocate,1840,doc/master/UnBinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/UnBinData_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,or Abstract base class for numeric event generator algorithms; RooAbsOptTestStatistic Abstract base class for optimized test statistics; RooAbsPdf Abstract PDF with normalization support; RooAbsPdf::GenSpec ; RooAbsProxy Abstract proxy interface; RooAbsReal Abstract real-valued variable; RooAbsRealLValue Abstract modifiable real-valued object; RooAbsRootFinder Abstract interface for 1-dim real-valued function root finders; RooAbsSelfCachedPdf Abstract base class for self-caching p.d.f.s; RooAbsSelfCachedReal Abstract base class for self-caching functions; RooAbsString Abstract string-valued variable; RooAbsStudy Abstract base class for RooStudyManager modules; RooAbsTestStatistic Abstract base class for real-valued test statistics; RooAcceptReject Context for generating a dataset from a PDF; RooAdaptiveGaussKronrodIntegrator1D 1-dimensional adaptive Gauss-Kronrod numerical integration engine; RooAdaptiveIntegratorND N-dimensional adaptive integration (interface to MathCore integrator); RooAddGenContext Specialized context for generating a dataset from a RooAddPdf; RooAddModel Resolution model representing a sum of resolution models; RooAddPdf PDF representing a sum of PDFs; RooAddition Sum of RooAbsReal objects; RooArgList Ordered list of RooAbsArg objects; RooArgProxy Abstract proxy for RooAbsArg objects; RooArgSet Set of RooAbsArg objects; RooArgusBG Argus background shape PDF; RooBCPEffDecay B Mixing decay PDF; RooBCPGenDecay B decay time distribution with CP violation; RooBDecay P.d.f of general description of B decay time distribution; RooBMixDecay B Mixing decay PDF; RooBernstein Bernstein polynomial PDF; RooBifurGauss Bifurcated Gaussian PDF; RooBinning Generic binning specification; RooBinningCategory RealVar-to-Category function defined by bin boundaries on input var; RooBlindTools Root implementation of BlindTools; RooBreitWigner Breit Wigner PDF; RooBrentRootFinder Abstract interface for 1-dim real-valued function root finders; RooBukinPdf Variation of No,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:25082,adapt,adaptive,25082,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,4,['adapt'],['adaptive']
Energy Efficiency,"or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.95, bool norm = true) const. get confidence intervals for an array of n points x.; stride1 indicates the stride in the coordinate space while stride2 the stride in dimension space.; For 1-dim points : stride1=1, stride2=1; for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the array ci; cl is the desired confidedence interval value; norm is a flag to control if the inte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Fit__FitResult.html:9108,allocate,allocates,9108,root/html530/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html530/ROOT__Fit__FitResult.html,3,['allocate'],['allocates']
Energy Efficiency,"or MacOS X, using Cocoa and Quartz 2D ;  CTGColorDialog;  CTGColorFrame;  CTGColorPalette;  CTGColorPick;  CTGColorPopup;  CTGColorSelect;  CTGColumnLayout;  CTGComboBox;  CTGComboBoxPopup;  CTGCommandPlugin;  CTGCompositeFrame;  CTGContainer;  CTGDimension;  CTGDMAssignmentHelper;  CTGDMLBaseTGDMMapHelper;  CTGDMLParse;  CTGDMLRefl;  ►CTGDMLWrite;  CNameLst;  CStructLst;  CXyz;  CTGDMMapHelper;  CTGDNDManager;  CTGDockableFrame;  CTGDockButton;  CTGDockHideButton;  CTGDoubleHSlider;  CTGDoubleSlider;  CTGDoubleVSlider;  CTGDragWindow;  CTGedEditor;  ►CTGedFrame;  CTGedSubFrame;  CTGedMarkerPopup;  CTGedMarkerSelect;  CTGedNameFrame;  CTGedPatternFrame;  CTGedPatternPopup;  CTGedPatternSelect;  CTGedPatternSelector;  CTGedPopup;  CTGedSelect;  ►CTGenCollectionProxyProxy around an arbitrary container, which implements basic functionality and iteration ;  CMethodSmall helper to execute (compiler) generated function for the access to STL or other containers ;  CMethod0;  CStreamHelperHelper class to facilitate I/O ;  CTStagingSmall helper to stage the content of an associative container when reading and before inserting it in the actual collection ;  CValueSmall helper to describe the Value_type or the key_type of an STL container ;  CTGenCollectionStreamer;  CTGeneratorThe interface to various event generators ;  ►CTGenericCollectionIterator;  CRegularIterator;  CVectorIterator;  ►CTGenericTable;  Citerator;  CTGenPhaseSpaceUtility class to generate n-body event, with constant cross-section (default) or with Fermi energy dependence (opt=""Fermi"") ;  CTGeoArb8An arbitrary trapezoid with less than 8 vertices standing on ;  CTGeoAttVisualization and tracking attributes for volumes and nodes ;  ►CTGeoBatemanSol;  CBtCoef_t;  CTGeoBBoxBox class ;  CTGeoBBoxEditor;  ►CTGeoBoolNodeBase class for Boolean operations between two shapes ;  CThreadData_t;  CTGeoBranchArrayAn array of daughter indices making a geometry path ;  CTGeoBuilderUtility class for creating geometry objects.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:141407,energy,energy,141407,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,2,['energy'],['energy']
Energy Efficiency,"or THnSparse<ArrayF>): bin content held by a Float_t,; THnSparseL (typedef for THnSparse<ArrayL>): bin content held by a Long_t,; THnSparseI (typedef for THnSparse<ArrayI>): bin content held by an Int_t,; THnSparseS (typedef for THnSparse<ArrayS>): bin content held by a Short_t,; THnSparseC (typedef for THnSparse<ArrayC>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension; the number of bins, the minimal, and the maximal value on the dimension's; axis. A TH2 h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnSparse hs(""hs"", ""hs"", 2, bins, min, max);. * Filling; A THnSparse is filled just like a regular histogram, using; THnSparse::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram.; Bins are allocated as needed; the status of the allocation can be observed; by GetSparseFractionBins(), GetSparseFractionMem(). * Fast Bin Content Access; When iterating over a THnSparse one should only look at filled bins to save; processing time. The number of filled bins is returned by; THnSparse::GetNbins(); the bin content for each (linear) bin number can; be retrieved by THnSparse::GetBinContent(linidx, (Int_t*)coord).; After the call, coord will contain the bin coordinate of each axis for the bin; with linear index linidx. A possible call would be; cout << hs.GetBinContent(0, coord);; cout <<"" is the content of bin [x = "" << coord[0] ""; << "" | y = "" << coord[1] << ""]"" << endl;. * Efficiency; TH1 and TH2 are generally faster than THnSparse for one and two dimensional; distributions. THnSparse becomes competitive for a sparsely filled TH3; with large numbers of bins per dimension. The tutorial hist/sparsehist.C; shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins""; starting with a TH3 with 30 bins per dimension. Using a THnSp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THnSparse.html:1850,allocate,allocated,1850,root/html528/THnSparse.html,https://root.cern,https://root.cern/root/html528/THnSparse.html,3,['allocate'],['allocated']
Energy Efficiency,"or background during the training. Training of a decision tree is the process to define the ""cut criteria"" for each node. The training starts with the root node. Here one takes the full training event sample and selects the variable and corresponding cut value that gives the best separation between signal and background at this stage. Using this cut criterion, the sample is then divided into two subsamples, a signal-like (right) and a background-like (left) sample. Two new nodes are then created for each of the two sub-samples and they are constructed using the same mechanism as described for the root node. The devision is stopped once a certain node has reached either a minimum number of events, or a minimum or maximum signal purity. These leave nodes are then called ""signal"" or ""background"" if they contain more signal respective background events from the training sample. Boosting:; The idea behind adaptive boosting (AdaBoost) is, that signal events from the training sample, that end up in a background node (and vice versa) are given a larger weight than events that are in the correct leave node. This results in a re-weighed training event sample, with which then a new decision tree can be developed. The boosting can be applied several times (typically 100-500 times) and one ends up with a set of decision trees (a forest). Gradient boosting works more like a function expansion approach, where each tree corresponds to a summand. The parameters for each summand (tree) are determined by the minimization of a error function (binomial log- likelihood for classification and Huber loss for regression). A greedy algorithm is used, which means, that only one tree is modified at a time, while the other trees stay fixed. Bagging:; In this particular variant of the Boosted Decision Trees the boosting is not done on the basis of previous training results, but by a simple stochastic re-sampling of the initial training event sample. Random Trees:; Similar to the ""Random Forests"" ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:2178,adapt,adaptive,2178,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['adapt'],['adaptive']
Energy Efficiency,"or cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.95, bool norm = true) const. get confidence intervals for an array of n points x.; stride1 indicates the stride in the coordinate space while stride2 the stride in dimension space.; For 1-dim points : stride1=1, stride2=1; for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the array ci; cl is the desired confidedence interval value; norm is a flag to control if the inte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__FitResult.html:8788,allocate,allocates,8788,root/html528/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__FitResult.html,1,['allocate'],['allocates']
Energy Efficiency,or numeric event generator algorithms; RooAbsOptTestStatistic Abstract base class for optimized test statistics; RooAbsPdf Abstract PDF with normalization support; RooAbsPdf::GenSpec Generation specification; RooAbsProxy Abstract proxy interface; RooAbsReal Abstract real-valued variable; RooAbsRealLValue Abstract modifiable real-valued object; RooAbsRootFinder Abstract interface for 1-dim real-valued function root finders; RooAbsSelfCachedPdf Abstract base class for self-caching p.d.f.s; RooAbsSelfCachedReal Abstract base class for self-caching functions; RooAbsString Abstract string-valued variable; RooAbsStudy Abstract base class for RooStudyManager modules; RooAbsTestStatistic Abstract base class for real-valued test statistics; RooAcceptReject Context for generating a dataset from a PDF; RooAdaptiveGaussKronrodIntegrator1D 1-dimensional adaptive Gauss-Kronrod numerical integration engine; RooAdaptiveIntegratorND N-dimensional adaptive integration (interface to MathCore integrator); RooAddGenContext Specialized context for generating a dataset from a RooAddPdf; RooAddModel Resolution model representing a sum of resolution models; RooAddPdf PDF representing a sum of PDFs; RooAddition Sum of RooAbsReal objects; RooArgList Ordered list of RooAbsArg objects; RooArgProxy Abstract proxy for RooAbsArg objects; RooArgSet Set of RooAbsArg objects; RooArgusBG Argus background shape PDF; RooBCPEffDecay B Mixing decay PDF; RooBCPGenDecay B decay time distribution with CP violation; RooBDecay P.d.f of general description of B decay time distribution; RooBMixDecay B Mixing decay PDF; RooBernstein Bernstein polynomial PDF; RooBifurGauss Bifurcated Gaussian PDF; RooBinIntegrator 1-dimensional numerical integration engine; RooBinnedGenContext Specialized context for generating a dataset from a binned pdf; RooBinning Generic binning specification; RooBinningCategory RealVar-to-Category function defined by bin boundaries on input var; RooBlindTools Root implementation of BlindTools,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:26525,adapt,adaptive,26525,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,8,['adapt'],['adaptive']
Energy Efficiency,or numeric event generator algorithms; RooAbsOptTestStatistic Abstract base class for optimized test statistics; RooAbsPdf Abstract PDF with normalization support; RooAbsPdf::GenSpec Generation specification; RooAbsProxy Abstract proxy interface; RooAbsReal Abstract real-valued variable; RooAbsRealLValue Abstract modifiable real-valued object; RooAbsRootFinder Abstract interface for 1-dim real-valued function root finders; RooAbsSelfCachedPdf Abstract base class for self-caching p.d.f.s; RooAbsSelfCachedReal Abstract base class for self-caching functions; RooAbsString Abstract string-valued variable; RooAbsStudy Abstract base class for RooStudyManager modules; RooAbsTestStatistic Abstract base class for real-valued test statistics; RooAcceptReject Context for generating a dataset from a PDF; RooAdaptiveGaussKronrodIntegrator1D 1-dimensional adaptive Gauss-Kronrod numerical integration engine; RooAdaptiveIntegratorND N-dimensional adaptive integration (interface to MathCore integrator); RooAddGenContext Specialized context for generating a dataset from a RooAddPdf; RooAddModel Resolution model representing a sum of resolution models; RooAddPdf PDF representing a sum of PDFs; RooAddition Sum of RooAbsReal objects; RooArgList Ordered list of RooAbsArg objects; RooArgProxy Abstract proxy for RooAbsArg objects; RooArgSet Set of RooAbsArg objects; RooArgusBG Argus background shape PDF; RooBCPEffDecay B Mixing decay PDF; RooBCPGenDecay B decay time distribution with CP violation; RooBDecay P.d.f of general description of B decay time distribution; RooBMixDecay B Mixing decay PDF; RooBernstein Bernstein polynomial PDF; RooBifurGauss Bifurcated Gaussian PDF; RooBinning Generic binning specification; RooBinningCategory RealVar-to-Category function defined by bin boundaries on input var; RooBlindTools Root implementation of BlindTools; RooBreitWigner Breit Wigner PDF; RooBrentRootFinder Abstract interface for 1-dim real-valued function root finders; RooBukinPdf Variation of No,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:26150,adapt,adaptive,26150,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,2,['adapt'],['adaptive']
Energy Efficiency,"or once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:2424,allocate,allocate,2424,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,4,['allocate'],['allocate']
Energy Efficiency,"or over cached variables; RooArgSetRooAbsDataStore::_cachedVars; Int_t_curIndex! Index associated with current event; RooAbsDataStore*_curStore! Datastore associated with current event; map<Int_t,RooAbsDataStore*>_dataMap; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; RooCategory*_indexCat; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; Bool_t_ownComps!; RooArgSetRooAbsDataStore::_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCompositeDataStore(). RooCompositeDataStore(const char* name, const char* title, const RooArgSet& vars, RooCategory& indexCat, map<string,RooAbsDataStore*> inputData); Convert map by label to map by index for more efficient internal use. RooCompositeDataStore(const RooCompositeDataStore& other, const char* newname = 0); Convert map by label to map by index for more efficient internal use. RooCompositeDataStore(const RooCompositeDataStore& other, const RooArgSet& vars, const char* newname = 0); Update index category pointer, if it is contained in input argument vars. ~RooCompositeDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); Forward recalculate request to all subsets. Bool_t hasFilledCache() const. void forceCacheUpdate(). Int_t fill(); Forward fill request to appropriate subset. Double_t sumEntries() const; Forward fill request to appropriate subset. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='idx') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight() const. Double_t weight(Int_t index) const. Double_t weightError(RooAbsData::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCompositeDataStore.html:11293,efficient,efficient,11293,root/html602/RooCompositeDataStore.html,https://root.cern,https://root.cern/root/html602/RooCompositeDataStore.html,2,['efficient'],['efficient']
Energy Efficiency,"or to another RooAbsFunc ;  CRooSecondMomentRooSecondMoment represents the first, second, or third order derivative of any RooAbsReal as calculated (numerically) by the MathCore Richardson derivator class ;  CRooSegmentedIntegrator1DRooSegmentedIntegrator1D implements an adaptive one-dimensional numerical integration algorithm ;  CRooSegmentedIntegrator2DRooSegmentedIntegrator2D implements an adaptive one-dimensional numerical integration algorithm ;  CRooSentinelRooSentinel is a special purposes singleton class that terminates all other RooFit singleton services when the process exists ;  CRooSetPairRooSetPair is a utility class that stores a pair of RooArgSets ;  CRooSetProxyRooSetProxy is the concrete proxy for RooArgSet objects ;  CRooSharedPropertiesClass RooSharedProperties is the base class for shared properties that can be stored in RooSharedPropertiesList ;  CRooSharedPropertiesListClass RooSharedPropertiesList maintains the properties of RooRealVars and RooCategories that are clones of each other ;  CRooSimGenContextRooSimGenContext is an efficient implementation of the generator context specific for RooSimultaneous PDFs when generating more than one of the component pdfs ;  CRooSimPdfBuilder;  CRooSimSplitGenContextRooSimSplitGenContext is an efficient implementation of the generator context specific for RooSimultaneous PDFs when generating more than one of the component pdfs ;  ►CRooSimultaneousRooSimultaneous facilitates simultaneous fitting of multiple PDFs to subsets of a given dataset ;  CCacheElem;  ►CRooSimWSTool;  CBuildConfig;  CMultiBuildConfig;  CObjBuildConfig;  CObjSplitRule;  CSimWSIFace;  CSplitRule;  CRooSpHarmonicImplementation of the so-called real spherical harmonics, using the orthonormal normalization, which are related to spherical harmonics as: ; \[ Y_{l0} = Y_l^0 (m=0) \\ Y_{lm} = \frac{1}{\sqrt{2}} \left( Y_l^m + (-1)^m Y_l^{-m} \right) (m>0) \\ Y_{lm} = \frac{1}{i\sqrt{2}} \left( Y_l^{|m|} - (-1)^{|m|} Y_l^{-|m|} \right) (m<0) \].",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:104681,efficient,efficient,104681,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,8,['efficient'],['efficient']
Energy Efficiency,"or v in place. ;  ; Float_t Normalize (Float_t v[3]);  Normalize a vector v in place. ;  ; template<typename T > ; T NormCross (const T v1[3], const T v2[3], T out[3]);  Calculates the Normalized Cross Product of two vectors. ;  ; Double_t NormQuantile (Double_t p);  Computes quantiles for standard normal distribution N(0, 1) at probability p. ;  ; Bool_t Odd (Long_t a);  Returns true if a is odd. ;  ; Bool_t Permute (Int_t n, Int_t *a);  Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinct adapted from CERNLIB routine PERMU. ;  ; constexpr Double_t Pi ();  \( \pi\) ;  ; constexpr Double_t PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t Prob (Double_t chi2, Int_t ndf);  Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf). ;  ; constexpr Double_t Qe ();  Elementary charge in \( C \) . ;  ; constexpr Double_t QeUncertainty ();  Elementary charge uncertainty. ;  ; void Quantiles (Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob, Bool_t isSorted=kTRUE, Int_t *index=nullptr, Int_t type=7);  Computes sample quantiles, corresponding to the given probabilities. ;  ; Double_t QuietNaN ();  Returns a quiet NaN as defined by IEEE 754. ;  ; constexpr Double_t R ();  Uni",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:17069,power,power,17069,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['power'],['power']
Energy Efficiency,"or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *= haar_t;; VerifyMatrixIdentity(unit,hth);; VerifyMatrixIdentity(unit,hht);; VerifyMatrixIdentity(unit,hht1);. 4. Accessing row/col/diagonal of a matrix without much fuss; (and without moving a lot of stuff around):. TMatrixD m(n,n); TVectorD v(n); TMatrixDDiag(m) += 4;; v = TMatrixDRow(m,0);; TMatrixDColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;; Note, constructing of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTBase_double_.html:4342,efficient,efficient,4342,root/html528/TMatrixTBase_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTBase_double_.html,12,['efficient'],['efficient']
Energy Efficiency,"or(ROOT::Math::IntegrationOneDim::Type type, double absTol, double relTol, unsigned int size, int rule). private:. ROOT::Math::IntegratorOneDimIntegratorOneDim(const ROOT::Math::IntegratorOneDim&); ROOT::Math::IntegratorOneDim&operator=(const ROOT::Math::IntegratorOneDim&). Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fFuncpointer to owned function; ROOT::Math::VirtualIntegratorOneDim*fIntegratorpointer to integrator interface class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetFunction( Function & f). double Integral(const ROOT::Math::IGenFunction& f, double a, double b). double Integral(double a, double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). IntegratorOneDim(ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, unsigned int rule = 0); constructors. Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html:4664,adapt,adaptive,4664,root/html528/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html,4,['adapt'],['adaptive']
Energy Efficiency,"or, since we have recognized a limited need for modeling the functionality of a 4D point.; 13.12.1.3 Generic Coordinate System; The vector classes are based on a generic type of coordinate system, expressed as a template parameter of the class. Various classes exist to describe the various coordinates systems:; 2D coordinate system classes:. ROOT::Math::Cartesian2D, based on (x,y);; ROOT::Math::Polar2D, based on (r,phi);. 3D coordinate system classes:. ROOT::Math::Cartesian3D, based on (x,y,z);; ROOT::Math::Polar3D, based on (r,theta,phi);; ROOT::Math::Cylindrical3D, based on (rho,z,phi); ROOT::Math::CylindricalEta3D, based on (rho,eta,phi), where eta is the pseudo-rapidity;. 4D coordinate system classes:. ROOT::Math::PxPyPzE4D, based on based on (px,py,pz,E);; ROOT::Math::PxPyPzM4D, based on based on (px,py,pz,M);; ROOT::Math::PtEtaPhiE4D, based on based on (pt,eta,phi,E);; ROOT::Math::PtEtaPhiM4D, based on based on (pt,eta,phi,M);. Users can define the vectors according to the coordinate type, which is the most efficient for their use. Transformations between the various coordinate systems are available through copy constructors or the assignment (=) operator. For maximum flexibility and minimize memory allocation, the coordinate system classes are templated on the scalar type. To avoid exposing templated parameter to the users, typedefs are defined for all types of vectors based on doubles. See in the examples for all the possible types of vector classes, which can be constructed by users with the available coordinate system types.; 13.12.1.4 Coordinate System Tag; The 2D and 3D points and vector classes can be associated to a tag defining the coordinate system. This can be used to distinguish between vectors of different coordinate systems like global or local vectors. The coordinate system tag is a template parameter of the ROOT::Math::DisplacementVector3D and ROOT::Math::PositionVector3D (and also for 2D classes). A default tag exists for users who do not need",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:721999,efficient,efficient,721999,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['efficient'],['efficient']
Energy Efficiency,"or. Double_t evaluate() const; Calculate current value of this object. void setVal(Double_t value); Assign given value to linear transformation: sets input variable to (value-offset)/slope; If slope is zerom an error message is printed and no assignment is made. Bool_t isJacobianOK(const RooArgSet& depList) const; Returns true if Jacobian term associated with current; expression tree is indeed constant. Double_t jacobian() const; Return value of Jacobian associated with the transformation. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream. RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE); Retrieve binning of this linear transformation. A RooLinearVar does not have its own; binnings but uses linearly transformed binnings of teh input variable. If a given; binning exists on the input variable, it will also exists on this linear transformation; and a binning adaptor object is created on the fly. const RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE) const; Const version of getBinning(). std::list<std::string> getBinningNames() const; Get a list of all binning names. An empty name implies the default binning.; A 0 pointer should be passed to getBinning in this case. Bool_t hasBinning(const char* name) const; Returns true if binning with given name exists.If a given binning; exists on the input variable, it will also exists on this linear; transformation. RooLinearVar(); Constructors, assignment etc. {}. TObject* clone(const char* newname) const; { return new RooLinearVar(*this,newname); }. » Last changed: Tue Jun 2 15:31:50 2015 » Last generated: 2015-06-02 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooLinearVar.html:43552,adapt,adaptor,43552,root/html604/RooLinearVar.html,https://root.cern,https://root.cern/root/html604/RooLinearVar.html,1,['adapt'],['adaptor']
Energy Efficiency,"or= ; (; const TGeoBranchArray & ; other). Assignment. Not valid anymore. Use TGeoBranchArray::MakeCopy instead. ; Definition at line 169 of file TGeoBranchArray.cxx. ◆ operator==(). Bool_t TGeoBranchArray::operator== ; (; const TGeoBranchArray & ; other); const. Is equal operator. ; Definition at line 208 of file TGeoBranchArray.cxx. ◆ operator>(). Bool_t TGeoBranchArray::operator> ; (; const TGeoBranchArray & ; other); const. Is equal operator. ; Definition at line 230 of file TGeoBranchArray.cxx. ◆ operator>=(). Bool_t TGeoBranchArray::operator>= ; (; const TGeoBranchArray & ; other); const. Is equal operator. ; Definition at line 252 of file TGeoBranchArray.cxx. ◆ Print(). void TGeoBranchArray::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print branch information. ; Reimplemented from TObject.; Definition at line 376 of file TGeoBranchArray.cxx. ◆ ReleaseInstance(). void TGeoBranchArray::ReleaseInstance ; (; TGeoBranchArray * ; obj). static . Releases the space allocated for the object. ; Definition at line 126 of file TGeoBranchArray.cxx. ◆ SizeOf() [1/2]. size_t TGeoBranchArray::SizeOf ; (; ); const. inline . Definition at line 74 of file TGeoBranchArray.h. ◆ SizeOf() [2/2]. static size_t TGeoBranchArray::SizeOf ; (; size_t ; maxlevel). inlinestatic . Definition at line 66 of file TGeoBranchArray.h. ◆ SizeOfInstance(). static size_t TGeoBranchArray::SizeOfInstance ; (; size_t ; maxlevel). inlinestatic . Definition at line 69 of file TGeoBranchArray.h. ◆ Sort(). void TGeoBranchArray::Sort ; (; Int_t ; n, . TGeoBranchArray ** ; array, . Int_t * ; index, . Bool_t ; down = kTRUE . ). static . Sorting of an array of branch array pointers. ; Definition at line 386 of file TGeoBranchArray.cxx. ◆ Streamer(). void TGeoBranchArray::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGeoBranchArray::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBranchArray.html:21884,allocate,allocated,21884,doc/master/classTGeoBranchArray.html,https://root.cern,https://root.cern/doc/master/classTGeoBranchArray.html,1,['allocate'],['allocated']
Energy Efficiency,"orBase)];; 201 alignas(T) char FirstEl[sizeof(T)];; 202};; 203 ; 204/// This is the part of SmallVectorTemplateBase which does not depend on whether the type T is a POD.; 205template <typename T>; 206class R__CLING_PTRCHECK(off) SmallVectorTemplateCommon : public SmallVectorBase {; 207 using Base = SmallVectorBase;; 208 ; 209 /// Find the address of the first element. For this pointer math to be valid; 210 /// with small-size of 0 for T with lots of alignment, it's important that; 211 /// SmallVectorStorage is properly-aligned even for small-size of 0.; 212 void *getFirstEl() const; 213 {; 214 return const_cast<void *>(reinterpret_cast<const void *>(reinterpret_cast<const char *>(this) +; 215 offsetof(SmallVectorAlignmentAndSize<T>, FirstEl)));; 216 }; 217 // Space after 'FirstEl' is clobbered, do not add any instance vars after it.; 218 ; 219protected:; 220 SmallVectorTemplateCommon(size_t Size) : Base(getFirstEl(), Size) {}; 221 ; 222 void grow_pod(size_t MinSize, size_t TSize) { Base::grow_pod(getFirstEl(), MinSize, TSize); }; 223 ; 224 /// Return true if this is a smallvector which has not had dynamic; 225 /// memory allocated for it.; 226 bool isSmall() const { return this->fBeginX == getFirstEl(); }; 227 ; 228 /// Put this vector in a state of being small.; 229 void resetToSmall(); 230 {; 231 this->fBeginX = getFirstEl();; 232 // from the original LLVM implementation:; 233 // FIXME: Setting fCapacity to 0 is suspect.; 234 this->fSize = this->fCapacity = 0;; 235 }; 236 ; 237public:; 238 // note that fSize is a _signed_ integer, but we expose it as an unsigned integer for consistency with STL containers; 239 // as well as backward-compatibility; 240 using size_type = size_t;; 241 using difference_type = ptrdiff_t;; 242 using value_type = T;; 243 using iterator = T *;; 244 using const_iterator = const T *;; 245 ; 246 using const_reverse_iterator = std::reverse_iterator<const_iterator>;; 247 using reverse_iterator = std::reverse_iterator<iterator>;; 248 ; 249 usin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:7766,allocate,allocated,7766,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['allocate'],['allocated']
Energy Efficiency,"orMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IntegratorMultiDim&); ROOT::Math::IntegratorMultiDim&operator=(const ROOT::Math::IntegratorMultiDim&). Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionMultiDim>fFuncpointer to owned function; ROOT::Math::VirtualIntegratorMultiDim*fIntegratorpointer to multi-dimensional integrator base class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorMultiDim.html:2742,adapt,adaptive,2742,root/html528/ROOT__Math__IntegratorMultiDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorMultiDim.html,4,['adapt'],['adaptive']
Energy Efficiency,"orType etype = Poisson) const; virtual Double_tweightSquared() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tallClientsCached(RooAbsArg*, const RooArgSet&); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); virtual RooAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tcorrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidoptimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum ErrorType { Poisson; SumW2; None; Auto; Expected; };; enum StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsData.html:13322,reduce,reduceEng,13322,root/html534/RooAbsData.html,https://root.cern,https://root.cern/root/html534/RooAbsData.html,1,['reduce'],['reduceEng']
Energy Efficiency,"orType etype = Poisson) const; virtual Double_tweightSquared() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tallClientsCached(RooAbsArg*, const RooArgSet&); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); virtual RooAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tcorrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidoptimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. static RooAbsData::ErrorTypeAuto; static RooAbsData::ErrorTypeExpected; static RooAbsData::ErrorTypeNone; static RooAbsData::ErrorTypePoisson; static RooAbsData::ErrorTypeSumW2; static RooAbsData::StorageTypeTree; static RooAbsData::Storag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsData.html:13526,reduce,reduceEng,13526,root/html602/RooAbsData.html,https://root.cern,https://root.cern/root/html602/RooAbsData.html,2,['reduce'],['reduceEng']
Energy Efficiency,"or[] ; (; Int_t ; rown); const. inline . Definition at line 181 of file TMatrixTSparse.h. ◆ Randomize(). template<class Element > . TMatrixTBase< Element > & TMatrixTSparse< Element >::Randomize ; (; Element ; alpha, . Element ; beta, . Double_t & ; seed . ). overridevirtual . randomize matrix element values ; Reimplemented from TMatrixTBase< Element >.; Definition at line 2568 of file TMatrixTSparse.cxx. ◆ RandomizePD(). template<class Element > . TMatrixTSparse< Element > & TMatrixTSparse< Element >::RandomizePD ; (; Element ; alpha, . Element ; beta, . Double_t & ; seed . ). virtual . randomize matrix element values but keep matrix symmetric positive definite ; Definition at line 2615 of file TMatrixTSparse.cxx. ◆ ReduceSparseMatrix(). template<class Element > . Int_t TMatrixTSparse< Element >::ReduceSparseMatrix ; (; Int_t ; nr, . Int_t * ; row, . Int_t * ; col, . Element * ; data . ). protected . Sum matrix entries corresponding to the same matrix element (i,j). ; The reduced extries remain dangling. It is assumed that the arrays row, col and data are sorted with DoubleLexSort. Note that the input arrays are not passed as const since they will be modified ! ; Definition at line 1328 of file TMatrixTSparse.cxx. ◆ ResizeTo() [1/3]. template<class Element > . TMatrixTBase< Element > & TMatrixTSparse< Element >::ResizeTo ; (; const TMatrixTSparse< Element > & ; m). inline . Definition at line 127 of file TMatrixTSparse.h. ◆ ResizeTo() [2/3]. template<class Element > . TMatrixTBase< Element > & TMatrixTSparse< Element >::ResizeTo ; (; Int_t ; nrows, . Int_t ; ncols, . Int_t ; nr_nonzeros = -1 . ). overridevirtual . Set size of the matrix to nrows x ncols with nr_nonzeros non-zero entries if nr_nonzeros > 0 . ; New dynamic elements are created, the overlapping part of the old ones are copied to the new structures, then the old elements are deleted. ; Implements TMatrixTBase< Element >.; Definition at line 1733 of file TMatrixTSparse.cxx. ◆ ResizeTo() [3/3]. template<c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixTSparse.html:48792,reduce,reduced,48792,doc/master/classTMatrixTSparse.html,https://root.cern,https://root.cern/doc/master/classTMatrixTSparse.html,1,['reduce'],['reduced']
Energy Efficiency,"orage::ObjectAlloc ; (; size_t ; sz). static . Used to allocate a TObject on the heap (via TObject::operator new()). ; Directly after this routine one can call (in the TObject ctor) TStorage::FilledByObjectAlloc() to find out if the just created object is on the heap. This technique is necessary as there is one stack per thread and we can not rely on comparison with the current stack memory position. ; Definition at line 291 of file TStorage.cxx. ◆ ObjectAlloc() [2/2]. void * TStorage::ObjectAlloc ; (; size_t ; size, . void * ; vp . ). static . Used to allocate a TObject on the heap (via TObject::operator new(size_t,void*)) in position vp. ; vp is already allocated (maybe on heap, maybe on stack) so just return. ; Definition at line 314 of file TStorage.cxx. ◆ ObjectAllocArray(). void * TStorage::ObjectAllocArray ; (; size_t ; sz). static . Used to allocate array of TObject on the heap (via TObject::operator new[]()). ; Unlike the 'singular' ObjectAlloc, we do not mark those object has being allocated on the heap as they can not be individually deleted. ; Definition at line 303 of file TStorage.cxx. ◆ ObjectDealloc() [1/2]. void TStorage::ObjectDealloc ; (; void * ; vp). static . Used to deallocate a TObject on the heap (via TObject::operator delete()). ; Definition at line 322 of file TStorage.cxx. ◆ ObjectDealloc() [2/2]. void TStorage::ObjectDealloc ; (; void * ; vp, . void * ; ptr . ). static . Used to deallocate a TObject on the heap (via TObject::operator delete(void*,void*)). ; Definition at line 331 of file TStorage.cxx. ◆ PrintStatistics(). void TStorage::PrintStatistics ; (; ). static . Print memory usage statistics. ; Definition at line 368 of file TStorage.cxx. ◆ ReAlloc(). void * TStorage::ReAlloc ; (; void * ; ovp, . size_t ; size, . size_t ; oldsize . ). static . Reallocate (i.e. ; resize) block of memory. Checks if current size is equal to oldsize. If not memory was overwritten. ; Definition at line 183 of file TStorage.cxx. ◆ ReAllocChar(). char * T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStorage.html:8071,allocate,allocated,8071,doc/master/classTStorage.html,https://root.cern,https://root.cern/doc/master/classTStorage.html,1,['allocate'],['allocated']
Energy Efficiency,"order to make easier material and mixture creation, one can use the pre-built table of elements owned by TGeoManager class:; TGeoElementTable *table = gGeoManager->GetElementTable();; TGeoElement *element1 = table->GetElement(Int_t Z);; TGeoElement *element2 = table->FindElement(""Copper"");; Int_tint Int_tDefinition RtypesCore.h:45; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoElementTableTable of elements.Definition TGeoElement.h:398; TGeoElementTable::GetElementTGeoElement * GetElement(Int_t z)Definition TGeoElement.h:435; TGeoElementTable::FindElementTGeoElement * FindElement(const char *name) constSearch an element by symbol or full name Exact matching.Definition TGeoElement.cxx:1334; TGeoElementBase class for chemical elements.Definition TGeoElement.h:36; TGeoManager::GetElementTableTGeoElementTable * GetElementTable()Returns material table. Creates it if not existing.Definition TGeoManager.cxx:3624; Materials made of single elements can be defined by their atomic mass (A), charge (Z) and density (rho). One can also create a material by specifying the element that it is made of. Optionally the radiation and absorption lengths can be also provided; otherwise they can be computed on-demand [G3]. The class representing them is TGeoMaterial:; TGeoMaterial(const char *name,Double_t a,Double_t z,; Double_t density, Double_t radlen=0,Double_t intlen=0);; TGeoMaterial(const char *name, TGeoElement *elem,; Double_t density);; TGeoMaterial(const char* name, Double_t a, Double_t z,; Double_t rho,; TGeoMaterial::EGeoMaterialState state,; Double_t temperature = STP_temperature,; Double_t pressure = STP_pressure); a#define a(i)Definition RSha256.hxx:99; Double_tdouble Double_tDefinition RtypesCore.h:59; namechar name[80]Definition TGX11.cxx:110; STP_temperaturestatic const Double_t STP_temperatureDefinition TGeoMaterial.h:31; STP_pressurestatic const Double_t STP_pressureDefinition TGeoMaterial.h:32; TGeoMaterialBase class describing materia",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Materials__classes.html:2211,charge,charge,2211,doc/master/group__Materials__classes.html,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html,1,['charge'],['charge']
Energy Efficiency,"order { kNoTreatment; kKernelRenorm; kSampleMirror; };. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the ; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE ; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.). const char* GetName() const; modified name (remove TMVA::). { return ""KDEKernel""; }. » Author: Asen Christov » Copyright (c) 2007: *; » Last changed: root/tmva $Id: KDEKernel.h 29195 2009-06-24 10:39:49Z brun $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__KDEKernel.html:2427,adapt,adaptive,2427,root/html528/TMVA__KDEKernel.html,https://root.cern,https://root.cern/root/html528/TMVA__KDEKernel.html,1,['adapt'],['adaptive']
Energy Efficiency,"ored. ;  ; virtual void Activate (TSocket *sock);  Activate a de-activated socket. ;  ; virtual void ActivateAll ();  Activate all de-activated sockets. ;  ; virtual void Add (TSocket *sock, Int_t interest=kRead);  Add socket to the monitor's active list. ;  ; virtual void DeActivate (TSocket *sock);  De-activate a socket. ;  ; virtual void DeActivateAll ();  De-activate all activated sockets. ;  ; Int_t GetActive (Long_t timeout=-1) const;  Return number of sockets in the active list. ;  ; Int_t GetDeActive () const;  Return number of sockets in the de-active list. ;  ; TList * GetListOfActives () const;  Returns a list with all active sockets. ;  ; TList * GetListOfDeActives () const;  Returns a list with all de-active sockets. ;  ; void Interrupt ();  ; TClass * IsA () const override;  ; Bool_t IsActive (TSocket *s) const;  Check if socket 's' is in the active list. ;  ; virtual void Ready (TSocket *sock);  Emit signal when some socket is ready. ;  ; virtual void Remove (TSocket *sock);  Remove a socket from the monitor. ;  ; virtual void RemoveAll ();  Remove all sockets from the monitor. ;  ; void ResetInterrupt ();  ; TSocket * Select ();  Return pointer to socket for which an event is waiting. ;  ; TSocket * Select (Long_t timeout);  Return pointer to socket for which an event is waiting. ;  ; Int_t Select (TList *rdready, TList *wrready, Long_t timeout);  Return numbers of sockets that are ready for reading or writing. ;  ; virtual void SetInterest (TSocket *sock, Int_t interest=kRead);  Set interest mask for socket sock to interest. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMonitor.html:2332,monitor,monitor,2332,doc/master/classTMonitor.html,https://root.cern,https://root.cern/doc/master/classTMonitor.html,1,['monitor'],['monitor']
Energy Efficiency,"orflow.keras.layers import Input, Dense; ; model = Sequential(); model.add(Dense(64, activation=""relu"", input_dim=7)); model.add(Dense(64, activation=""relu"")); model.add(Dense(64, activation=""relu"")); model.add(Dense(64, activation=""relu"")); model.add(Dense(2, activation=""sigmoid"")); model.compile(loss=""binary_crossentropy"", optimizer=Adam(learning_rate=0.001), weighted_metrics=[""accuracy""]); model.save(""model_higgs.h5""); model.summary(); ; if not os.path.exists(""model_higgs.h5""):; raise FileNotFoundError(""Error creating Keras model file - skip using Keras""); else:; # book PyKeras method only if Keras model could be created; ROOT.Info(""TMVA_Higgs_Classification"", ""Booking Deep Learning keras model""); factory.BookMethod(; loader,; TMVA.Types.kPyKeras,; ""PyKeras"",; H=True,; V=False,; VarTransform=None,; FilenameModel=""model_higgs.h5"",; FilenameTrainedModel=""trained_model_higgs.h5"",; NumEpochs=20,; BatchSize=100,; ); # GpuOptions=""allow_growth=True"",; # ) # needed for RTX NVidia card and to avoid TF allocates all GPU memory; ; ; ## Train Methods; ; # Here we train all the previously booked methods.; ; factory.TrainAllMethods(); ## Test all methods; ; # Now we test and evaluate all methods using the test data set; factory.TestAllMethods(); ; factory.EvaluateAllMethods(); ; # after we get the ROC curve and we display; ; c1 = factory.GetROCCurve(loader); c1.Draw(); # at the end we close the output file which contains the evaluation result of all methods and it can be used by TMVAGUI; # to display additional plots; ; outputFile.Close(); TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:67656,allocate,allocates,67656,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['allocate'],['allocates']
Energy Efficiency,"orm(const float *fSource,; float; *fDest);  ; This function transforms the; source spectrum according to the given input parameters. Transformed data are; written into dest spectrum. Before the Transform function is called the class; must be created by constructor and the type of the transform as well as some; other parameters must be set using a set of setter functions.;  ; Member variables of; TSpectrumTransform class:; �fSource-pointer; to the vector of source spectrum. Its length should be equal to the �fSize�; parameter except for inverse FOURIER, FOUR-WALSH, FOUR-HAAR transforms. These; need �2*fSize� length to supply real and imaginary coefficients. ������������������; fDest-pointer; to the vector of destination spectrum. Its length should be equal to the; �fSize� parameter except for inverse FOURIER, FOUR-WALSH, FOUR-HAAR transforms.; These need �2*fSize� length to store real and imaginary coefficients. ; ������� fSize-basic length; of the source and dest spectrum. It should be power; of 2.; fType-type of transform; ����������� Classic transforms:; ����������������������� kTransformHaar. ����������������������� kTransformWalsh. ����������������������� kTransformCos. ����������������������� kTransformSin. ����������������������� kTransformFourier. ����������������������� kTransformHartey. ����������� Mixed transforms:; ����������������������� kTransformFourierWalsh. ����������������������� kTransformFourierHaar. ����������������������� kTransformWalshHaar. ����������������������� kTransformCosWalsh. ����������������������� kTransformCosHaar. ����������������������� kTransformSinWalsh. ����������������������� kTransformSinHaar. fDirection-direction-transform; direction (forward, inverse); ����������������������� kTransformForward. ����������������������� kTransformInverse. fDegree-applies; only for mixed transforms [2], [3], [4]. ; ����������������; �Allowed range� . ; References:; [1] C.V. Hampton, B. Lian, Wm. C.; McHarris: Fast-Fourier-transform spectral en",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrumTransform.html:13258,power,power,13258,root/html528/TSpectrumTransform.html,https://root.cern,https://root.cern/root/html528/TSpectrumTransform.html,4,['power'],['power']
Energy Efficiency,"ormap[64][3]colormap; Pixel_tfPixel[64]pixel values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorPick(const TGWindow* p = 0, Int_t w = 1, Int_t h = 1, Int_t id = -1); TGColorPick constructor.; TGColorPick is a widget which allows a color to be picked from HLS space.; It consists of two elements: a color map window from where the user can; select the hue and saturation level of a color, and a slider to select; color's lightness. ~TGColorPick(); TGColorPick destructor. Bool_t HandleButton(Event_t* event); Handle mouse button events in color pick widget. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in color pick widget. void CreateImages(); Create colormap and color slider images. void AllocColors(); Try to allocate first a palette of 64 colors. Used by the dithered; version of the color maps. void FreeColors(); Free allocated colors. void CreateDitheredImage(Pixmap_t image, Int_t which); Create a dithered version of the color map and lightness images for; display modes with reduced number of colors. The Floyd-Steinberg error; diffusion dithering algorithm is used.; This routine is called in PseudoColor modes only. void InitImages(); Initialize color palette and slider images. void SetSliderColor(); Set slider colors. void SetColor(Pixel_t color); Position the slider cursor on right color position. void UpdateCurrentColor(); Assign the current cursor position as currently selected color. void DoRedraw(); Redraw the color pick widget. void SetHScursor(Int_t x, Int_t y); Set hue / saturation cursor position. void SetLcursor(Int_t z); Set lightness slider cursor position. void DrawHScursor(Int_t onoff); Draw hue / saturation cursor. void DrawLcursor(Int_t onoff); Draw lightness slider cursor. Pixel_t GetCurrentColor() const. void ColorSelected(Pixel_t col = 0); { Emit(""ColorSelected(Pixel_t)"", col ? col : GetCurrentColor()); }. » Author: Bertrand Bellenot + Fons Rademakers 22/08/02 » Copyright (C) 199",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGColorPick.html:19828,reduce,reduced,19828,root/html528/TGColorPick.html,https://root.cern,https://root.cern/root/html528/TGColorPick.html,4,['reduce'],['reduced']
Energy Efficiency,"ormap[64][3]colormap; Pixel_tfPixel[64]pixel values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorPick(const TGWindow* p = 0, Int_t w = 1, Int_t h = 1, Int_t id = -1); TGColorPick constructor.; TGColorPick is a widget which allows a color to be picked from HLS space.; It consists of two elements: a color map window from where the user can; select the hue and saturation level of a color, and a slider to select; color's lightness. ~TGColorPick(); TGColorPick destructor. Bool_t HandleButton(Event_t* event); Handle mouse button events in color pick widget. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in color pick widget. void CreateImages(); Create colormap and color slider images. void AllocColors(); Try to allocate first a palette of 64 colors. Used by the dithered; version of the color maps. void FreeColors(); Free allocated colors. void CreateDitheredImage(Pixmap_t image, Int_t which); Create a dithered version of the color map and lightness images for; display modes with reduced number of colors. The Floyd-Steinberg error; diffusion dithering algorithm is used.; This routine is called in PseudoColor modes only. void InitImages(); Initialize color palette and slider images. void SetSliderColor(); Set slider colors. void SetColor(Pixel_t color); Position the slider cursor on right color position. void UpdateCurrentColor(); Assign the current cursor position as currently selected color. void DoRedraw(); Redraw the color pick widget. void SetHScursor(Int_t x, Int_t y); Set hue / saturation cursor position. void SetLcursor(Int_t z); Set lightness slider cursor position. void DrawHScursor(Int_t onoff); Draw hue / saturation cursor. void DrawLcursor(Int_t onoff); Draw lightness slider cursor. TGColorPalette& operator=(const TGColorPick& ). Pixel_t GetCurrentColor() const. void ColorSelected(Pixel_t col = 0); { Emit(""ColorSelected(Pixel_t)"", col ? col : GetCurrentColor()); }. TGColorPick(const TGWindow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGColorPick.html:20793,reduce,reduced,20793,root/html602/TGColorPick.html,https://root.cern,https://root.cern/root/html602/TGColorPick.html,2,['reduce'],['reduced']
Energy Efficiency,"ors = (TObjArray*) gROOT->GetListOfColors();; 1835 ; 1836 if (nd >= 0) {; 1837 TColor *colord = (TColor*)colors->At(nd);; 1838 colord->TNamed::SetName(TString::Format(""%s_dark"",fName.Data()).Data());; 1839 }; 1840 ; 1841 if (nb >= 0) {; 1842 TColor *colorb = (TColor*)colors->At(nb);; 1843 colorb->TNamed::SetName(TString::Format(""%s_bright"",fName.Data()).Data());; 1844 }; 1845}; 1846 ; 1847 ; 1848////////////////////////////////////////////////////////////////////////////////; 1849/// Initialize this color and its ""dark"" and ""bright"" associated colors.; 1850 ; 1851void TColor::SetRGB(Float_t r, Float_t g, Float_t b); 1852{; 1853 TColor::InitializeColors();; 1854 fRed = r;; 1855 fGreen = g;; 1856 fBlue = b;; 1857 ; 1858 if (fRed < 0) return;; 1859 ; 1860 RGBtoHLS(r, g, b, fHue, fLight, fSaturation);; 1861 SetTitle(AsHexString());; 1862 ; 1863 Int_t nplanes = 16;; 1864 if (gVirtualX) gVirtualX->GetPlanes(nplanes);; 1865 if (nplanes == 0) nplanes = 16;; 1866 ; 1867 // allocate color now (can be delayed when we have a large colormap); 1868#ifndef R__WIN32; 1869 if (nplanes < 15); 1870#endif; 1871 Allocate();; 1872 ; 1873 // change the dark and bright associated colors if they exist; 1874 Float_t dr, dg, db, lr, lg, lb;; 1875 ; 1876 // get the list of all defined colors; 1877 auto colors = (TObjArray*) gROOT->GetListOfColors();; 1878 ; 1879 // set dark color; 1880 Int_t nd = GetColorByName(TString::Format(""%s_dark"",GetName()).Data());; 1881 if (nd >= 0) {; 1882 HLStoRGB(fHue, 0.7f*fLight, fSaturation, dr, dg, db);; 1883 TColor *colord = (TColor*)colors->At(nd);; 1884 if (nplanes > 8) colord->SetRGB(dr, dg, db);; 1885 else colord->SetRGB(0.3f,0.3f,0.3f);; 1886 colord->SetTitle(colord->AsHexString());; 1887 }; 1888 ; 1889 // set bright color; 1890 Int_t nb = GetColorByName(TString::Format(""%s_bright"",GetName()).Data());; 1891 if (nb >= 0) {; 1892 HLStoRGB(fHue, 1.2f*fLight, fSaturation, lr, lg, lb);; 1893 TColor *colorb = (TColor*)colors->At(nb);; 1894 if (nplanes > 8) color",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:66527,allocate,allocate,66527,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"ors); 2951{; 2952 if (maxcolors == 0) {; 2953 ncolors = 0;; 2954 maxcolors = 100;; 2955 orgcolors = (ULong_t*) ::operator new(maxcolors*sizeof(ULong_t));; 2956 }; 2957 ; 2958 for (int i = 0; i < ncolors; i++); 2959 if (pixel == orgcolors[i]) return;; 2960 ; 2961 if (ncolors >= maxcolors) {; 2962 orgcolors = (ULong_t*) TStorage::ReAlloc(orgcolors,; 2963 maxcolors*2*sizeof(ULong_t), maxcolors*sizeof(ULong_t));; 2964 maxcolors *= 2;; 2965 }; 2966 ; 2967 orgcolors[ncolors++] = pixel;; 2968}; 2969 ; 2970////////////////////////////////////////////////////////////////////////////////; 2971/// Get RGB values for orgcolors, add percent neutral to the RGB and; 2972/// allocate fNewColors.; 2973 ; 2974void TGX11::MakeOpaqueColors(Int_t percent, ULong_t *orgcolors, Int_t ncolors); 2975{; 2976 if (ncolors == 0) return;; 2977 ; 2978 RXColor *xcol = new RXColor[ncolors];; 2979 ; 2980 int i;; 2981 for (i = 0; i < ncolors; i++) {; 2982 xcol[i].pixel = orgcolors[i];; 2983 xcol[i].red = xcol[i].green = xcol[i].blue = 0;; 2984 xcol[i].flags = DoRed | DoGreen | DoBlue;; 2985 }; 2986 QueryColors(fColormap, xcol, ncolors);; 2987 ; 2988 UShort_t add = percent * kBIGGEST_RGB_VALUE / 100;; 2989 ; 2990 Int_t val;; 2991 for (i = 0; i < ncolors; i++) {; 2992 val = xcol[i].red + add;; 2993 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 2994 xcol[i].red = (UShort_t) val;; 2995 val = xcol[i].green + add;; 2996 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 2997 xcol[i].green = (UShort_t) val;; 2998 val = xcol[i].blue + add;; 2999 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 3000 xcol[i].blue = (UShort_t) val;; 3001 if (!AllocColor(fColormap, &xcol[i])); 3002 Warning(""MakeOpaqueColors"", ""failed to allocate color %hd, %hd, %hd"",; 3003 xcol[i].red, xcol[i].green, xcol[i].blue);; 3004 // assumes that in case of failure xcol[i].pixel is not changed; 3005 }; 3006 ; 3007 gCws->fNewColors = new ULong_t[ncolors];; 3008 gCws->fNcolors = ncolors;; 3009 ; 3010 for (i = 0; i < ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:99368,green,green,99368,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"ors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Double_t exL, Double_t exH, Double_t eyL1, Double_t eyH1, Double_t eyL2=0., Double_t eyH2=0., Double_t eyL3=0., Double_t eyH3=0.)Set ex and ey values for point pointed by the mouse.Definition TGraphMultiErrors.cxx:1793; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::SetFillColorAlphavirtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2051; TGraphMultiErrors::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TGraphMultiErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1504; TGraphMultiErrors::Dividevoid Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1481; TGraphMultiErrors::TGraphMultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH)Set error e ey values.Definition TGraphMultiErrors.cxx:1973; TGraphMultiErrors::SetSumErrorsModevirtual void SetSumErro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:78552,adapt,adapted,78552,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,2,['adapt'],['adapted']
Energy Efficiency,"ors.cxx:184; TGraphErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin !...Definition TGraphErrors.cxx:532; TGraphErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with errors from the collection to this graph.Definition TGraphErrors.cxx:682; TGraphErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphErrors.cxx:510; TGraphErrors::TGraphErrorsTGraphErrors()TGraphErrors default constructor.Definition TGraphErrors.cxx:69; TGraphErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:647; TGraphErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphErrors.cxx:722; TGraphErrors::Applyvoid Apply(TF1 *f) overrideApply function to all the data points .Definition TGraphErrors.cxx:396; TGraphErrors::CtorAllocateBool_t CtorAllocate()Constructor allocate.Definition TGraphErrors.cxx:557; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::AllocateArraysDouble_t ** AllocateArrays(Int_t Narrays, Int_t arraySize)Allocate arrays.Definition TGraph.cxx:598; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TVectorTTVectorT.Definition TVectorT.h:27; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; exDouble_t ex[n]Definition legend1.C:17. histhistincTGraphErrors.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8h_source.html:10722,allocate,allocate,10722,doc/master/TGraphErrors_8h_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html,1,['allocate'],['allocate']
Energy Efficiency,"orts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as float) from the I/O buffer.; Returns the number of doubles read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Double32_t encoding at TBufferFile::WriteDouble32. Int_t ReadStaticArray(Bool_t* b); Read array of bools from the I/O buffer. Returns the number of bools; read. Int_t ReadStaticArray(Char_t* c); Read array of characters from the I/O buffer. Returns the number of; characters read. Int_t ReadStaticArray(Short_t* h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBufferFile.html:28043,allocate,allocated,28043,root/html528/TBufferFile.html,https://root.cern,https://root.cern/root/html528/TBufferFile.html,6,['allocate'],['allocated']
Energy Efficiency,"os, . RooRealVar * ; obs . ); const. Definition at line 2320 of file RooDataHist.cxx. ◆ printMultiline(). void RooDataHist::printMultiline ; (; std::ostream & ; os, . Int_t ; content, . bool ; verbose = false, . TString ; indent = """" . ); const. overridevirtual . Print the details on the dataset contents. ; Reimplemented from RooAbsData.; Definition at line 2299 of file RooDataHist.cxx. ◆ printValue(). void RooDataHist::printValue ; (; std::ostream & ; os); const. overridevirtual . Print value of the dataset, i.e. the sum of weights contained in the dataset. ; Reimplemented from RooPrintable.; Definition at line 2252 of file RooDataHist.cxx. ◆ reduceEng(). std::unique_ptr< RooAbsData > RooDataHist::reduceEng ; (; const RooArgSet & ; varSubset, . const RooFormulaVar * ; cutVar, . const char * ; cutRange = nullptr, . std::size_t ; nStart = 0, . std::size_t ; nStop = std::numeric_limits<std::size_t>::max() . ); const. overrideprotectedvirtual . Implementation of RooAbsData virtual method that drives the RooAbsData::reduce() methods. ; Implements RooAbsData.; Definition at line 916 of file RooDataHist.cxx. ◆ registerWeightArraysToDataStore(). void RooDataHist::registerWeightArraysToDataStore ; (; ); const. private . Hand over pointers to our weight arrays to the data store implementation. ; Definition at line 2413 of file RooDataHist.cxx. ◆ removeSelfFromDir(). void RooDataHist::removeSelfFromDir ; (; ). inline . Definition at line 164 of file RooDataHist.h. ◆ reset(). void RooDataHist::reset ; (; ). overridevirtual . Reset all bin weights to zero. ; Reimplemented from RooAbsData.; Definition at line 2158 of file RooDataHist.cxx. ◆ set() [1/4]. void RooDataHist::set ; (; const RooArgSet & ; row, . double ; wgt, . double ; wgtErr = -1. . ). Set a bin content. ; Parameters. [in]rowCoordinates to compute the bin from. ; [in]wgtNew bin content. ; [in]wgtErrOptional error of the bin content. . Definition at line 1791 of file RooDataHist.cxx. ◆ set() [2/4]. void RooDataHist::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:74286,reduce,reduce,74286,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['reduce'],['reduce']
Energy Efficiency,"ossible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL) Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6) lower rules are indicated for singular functions while higher for smooth functions to get better accuracies; NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions ; Definition at line 123 of file Integrator.h. ◆ IntegratorOneDim() [2/4]. ROOT::Math::IntegratorOneDim::IntegratorOneDim ; (; const IGenFunction & ; f, . IntegrationOneDim::Type ; type = IntegrationOneDim::kDEFAULT, . double ; absTol = -1, . double ; relTol = -1, . unsigned int ; size = 0, . int ; rule = 0 . ). inlineexplicit . Constructor of one dimensional Integrator passing a function interface. ; Parameters. fintegration function (1D interface). It is copied inside ; typeintegration type (adaptive, non-adaptive, etc..) ; absToldesired absolute tolerance. The algorithm will stop when either the absolute OR the relative tolerance are satisfied. ; relToldesired relative tolerance ; sizemaximum number of sub-intervals ; ruleGauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When no values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions ; Definition at line 142 of file Integrator.h. ◆ IntegratorOneDim() [3/4]. template<class Function > . ROOT::Math::IntegratorOneDim::IntegratorOneDim ; (; Function & ; f, . IntegrationOneDim::Type ; type = IntegrationOneDim::kDEFAULT, . double ; absTol = -1, . double ; relTol = -1, . unsigned int ; size = 0, . int ; rule = 0 . ). inlineexplicit . Template Constructor of one dimensional Integrator passing a generic function object. ; Parameters. fintegration function (any C++ callable object implementing operator()(double x) ; typeintegration type (adaptive, non-adap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html:9177,adapt,adaptive,9177,doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html,2,['adapt'],['adaptive']
Energy Efficiency,ostScript::fFX. protected . Definition at line 35 of file TPostScript.h. ◆ fFY. Float_t TPostScript::fFY. protected . Definition at line 36 of file TPostScript.h. ◆ fgLineCap. Int_t TPostScript::fgLineCap = 0. staticprotected . Appearance of line caps. ; Definition at line 81 of file TPostScript.h. ◆ fgLineJoin. Int_t TPostScript::fgLineJoin = 0. staticprotected . Appearance of joining lines. ; Definition at line 80 of file TPostScript.h. ◆ fGreen. Float_t TPostScript::fGreen. protected . Per cent of green. ; Definition at line 49 of file TPostScript.h. ◆ fIXzone. Int_t TPostScript::fIXzone. protected . Current zone along X. ; Definition at line 55 of file TPostScript.h. ◆ fIYzone. Int_t TPostScript::fIYzone. protected . Current zone along Y. ; Definition at line 56 of file TPostScript.h. ◆ fLastCellBlue. Int_t TPostScript::fLastCellBlue. protected . Last blue value. ; Definition at line 75 of file TPostScript.h. ◆ fLastCellGreen. Int_t TPostScript::fLastCellGreen. protected . Last green value. ; Definition at line 74 of file TPostScript.h. ◆ fLastCellRed. Int_t TPostScript::fLastCellRed. protected . Last red value. ; Definition at line 73 of file TPostScript.h. ◆ fLineScale. Float_t TPostScript::fLineScale. protected . Line width scale factor. ; Definition at line 51 of file TPostScript.h. ◆ fMarkerSizeCur. Float_t TPostScript::fMarkerSizeCur. protected . current transformed value of marker size ; Definition at line 57 of file TPostScript.h. ◆ fMaxLines. Int_t TPostScript::fMaxLines. protected . Maximum number of lines in a PS array. ; Definition at line 72 of file TPostScript.h. ◆ fMaxsize. Float_t TPostScript::fMaxsize. protected . Largest dimension of X and Y. ; Definition at line 47 of file TPostScript.h. ◆ fMode. Int_t TPostScript::fMode. protected . PostScript mode. ; Definition at line 61 of file TPostScript.h. ◆ fNbCellLine. Int_t TPostScript::fNbCellLine. protected . Number of boxes in the current line. ; Definition at line 71 of file TPostScript.h. ◆ fNbC,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPostScript.html:54924,green,green,54924,doc/master/classTPostScript.html,https://root.cern,https://root.cern/doc/master/classTPostScript.html,1,['green'],['green']
Energy Efficiency,"ostream & ; os); const. overridevirtual . Print title of fit result. ; Reimplemented from RooPrintable.; Definition at line 1400 of file RooFitResult.cxx. ◆ printValue(). void RooFitResult::printValue ; (; std::ostream & ; os); const. overridevirtual . Print the value of the fit result, i.e.g the status, minimized FCN, edm and covariance quality code. ; Reimplemented from RooPrintable.; Definition at line 1428 of file RooFitResult.cxx. ◆ randomizePars(). const RooArgList & RooFitResult::randomizePars ; (; ); const. Generate random perturbations of the final parameters using the covariance matrix. ; Return a list of floating parameter values that are perturbed from the final fit values by random amounts sampled from the covariance matrix.; The returned object is overwritten with each call and belongs to the RooFitResult. Uses the ""square root method"" to decompose the covariance matrix, which makes inverting it unnecessary. ; Definition at line 336 of file RooFitResult.cxx. ◆ reducedCovarianceMatrix(). TMatrixDSym RooFitResult::reducedCovarianceMatrix ; (; const RooArgList & ; params); const. Return a reduced covariance matrix (Note that Vred is a simple sub-matrix of V, row/columns are ordered to matched the convention given in input argument 'params'. ; Definition at line 1124 of file RooFitResult.cxx. ◆ setConstParList(). void RooFitResult::setConstParList ; (; const RooArgList & ; list). Fill the list of constant parameters. ; Definition at line 136 of file RooFitResult.cxx. ◆ setCovarianceMatrix(). void RooFitResult::setCovarianceMatrix ; (; TMatrixDSym & ; V). Store externally provided correlation matrix in this RooFitResult ;. ; Definition at line 1052 of file RooFitResult.cxx. ◆ setCovQual(). void RooFitResult::setCovQual ; (; Int_t ; val). inline . Definition at line 169 of file RooFitResult.h. ◆ setEDM(). void RooFitResult::setEDM ; (; double ; val). inline . Definition at line 167 of file RooFitResult.h. ◆ setFinalParList(). void RooFitResult::setFinalParLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFitResult.html:36043,reduce,reducedCovarianceMatrix,36043,doc/master/classRooFitResult.html,https://root.cern,https://root.cern/doc/master/classRooFitResult.html,1,['reduce'],['reducedCovarianceMatrix']
Energy Efficiency,"ot be retrieved in this case . GSLDerivator * fDerivator;  ; int Status () const;  return the error status of the last derivative calculation ;  ; double Result () const;  return the result of the last derivative calculation ;  ; double Error () const;  return the estimate of the absolute error of the last derivative calculation ;  ; static double Eval (const IGenFunction &f, double x, double h=1E-8);  Computes the numerical derivative of a function f at a point x. ;  ; static double EvalCentral (const IGenFunction &f, double x, double h=1E-8);  Computes the numerical derivative of a function f at a point x using an adaptive central difference algorithm with a step size h. ;  ; static double EvalForward (const IGenFunction &f, double x, double h=1E-8);  Computes the numerical derivative of a function f at a point x using an adaptive forward difference algorithm with a step size h. ;  ; static double EvalBackward (const IGenFunction &f, double x, double h=1E-8);  Computes the numerical derivative of a function f at a point x using an adaptive backward difference algorithm with a step size h. ;  ; static double Eval (const IMultiGenFunction &f, const double *x, unsigned int icoord=0, double h=1E-8);  Evaluate the partial derivative of a multi-dim function with respect coordinate x_icoord at the point x[]. ;  ; static double Eval (IParamFunction &f, double x, const double *p, unsigned int ipar=0, double h=1E-8);  Evaluate the derivative with respect a parameter for one-dim parameteric function at the point ( x,p[]) with respect the parameter p_ipar. ;  ; static double Eval (IParamMultiFunction &f, const double *x, const double *p, unsigned int ipar=0, double h=1E-8);  Evaluate the derivative with respect a parameter for a multi-dim parameteric function at the point ( x[],p[]) with respect the parameter p_ipar. ;  . #include <Math/Derivator.h>; Member Typedef Documentation. ◆ GSLFuncPointer. typedef double(* ROOT::Math::Derivator::GSLFuncPointer) (double, void *). signa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Derivator.html:3359,adapt,adaptive,3359,doc/master/classROOT_1_1Math_1_1Derivator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Derivator.html,1,['adapt'],['adaptive']
Energy Efficiency,"ot contains relative path below current directory. ;  . Protected Attributes; std::queue< std::shared_ptr< THttpCallArg > > fArgs;  ! submitted arguments ;  ; std::string fCors;  ! CORS: sets Access-Control-Allow-Origin header for ProcessRequest responses ;  ; std::string fCorsCredentials;  ! CORS: add Access-Control-Allow-Credentials: true response header ;  ; std::string fDefaultPage;  ! file name for default page name ;  ; std::string fDefaultPageCont;  ! content of default html page ;  ; std::string fDrawPage;  ! file name for drawing of single element ;  ; std::string fDrawPageCont;  ! content of draw html page ;  ; TList fEngines;  ! engines which runs http server ;  ; TString fJSROOT;  ! location of external JSROOT files ;  ; TString fJSROOTSYS;  ! location of local JSROOT files ;  ; std::map< std::string, std::string > fLocations;  ! list of local directories, which could be accessed via server ;  ; Long_t fMainThrdId {0};  ! id of the thread for processing requests ;  ; std::mutex fMutex;  ! mutex to protect list with arguments ;  ; Bool_t fOwnThread {kFALSE};  ! true when specialized thread allocated for processing requests ;  ; Long_t fProcessingThrdId {0};  ! id of the thread where events are recently processing ;  ; std::unique_ptr< TRootSniffer > fSniffer;  ! sniffer provides access to ROOT objects hierarchy ;  ; Bool_t fTerminated {kFALSE};  ! termination flag, disables all requests processing ;  ; std::thread fThrd;  ! own thread ;  ; std::unique_ptr< THttpTimer > fTimer;  ! timer used to access main thread ;  ; TString fTopName {""ROOT""};  ! name of top folder, default - ""ROOT"" ;  ; std::vector< std::shared_ptr< THttpWSHandler > > fWSHandlers;  ! list of WS handlers ;  ; std::mutex fWSMutex;  ! mutex to protect WS handler lists ;  ; Bool_t fWSOnly {kFALSE};  ! when true, handle only websockets / longpoll engine ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpServer.html:17986,allocate,allocated,17986,doc/master/classTHttpServer.html,https://root.cern,https://root.cern/doc/master/classTHttpServer.html,1,['allocate'],['allocated']
Energy Efficiency,"ot the inverse; 348 if (fWrapped); 349 return 1.0 / eval;; 350 else; 351 return (eval != 0.0) ? eval : 0.0;; 352 }; 353 ; 354 if ( fErrorType == kAsymError ) {; 355 // return inverse of 1/2(el + eh); 356 assert( !fDataErrorPtr && fDataErrorHighPtr && fDataErrorLowPtr );; 357 assert( fDataError.empty() );; 358 assert( fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 359 assert( fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 360 assert( fDataErrorLow.empty() == fDataErrorHigh.empty() );; 361 ; 362 double eh = fDataErrorHighPtr[ ipoint ];; 363 double el = fDataErrorLowPtr[ ipoint ];; 364 ; 365 return 2.0 / (el+eh);; 366 }; 367 ; 368 assert( fErrorType == kCoordError );; 369 // for coordinate error we store the error and not the inverse; 370 return 1.0 / fDataErrorPtr[ ipoint ];; 371 }; 372 ; 373 ; 374 /**; 375 retrieve at the same time a pointer to the coordinate data and the fit value; 376 More efficient than calling Coords(i) and Value(i); 377 */; 378 // not threadsafe, to be replaced with never constructs!; 379 // for example: just return std::array or std::vector, there's; 380 // is going to be only minor overhead in c++11.; 381 const double * GetPoint( unsigned int ipoint, double & value ) const; 382 {; 383 assert( ipoint < fMaxPoints );; 384 value = Value( ipoint );; 385 ; 386 return Coords( ipoint );; 387 }; 388 ; 389 /**; 390 returns a single coordinate error component of a point.; 391 This function is threadsafe in contrast to Coords(...); 392 and can easily get vectorized by the compiler in loops; 393 running over the ipoint-index.; 394 */; 395 double GetCoordErrorComponent( unsigned int ipoint, unsigned int icoord ) const; 396 {; 397 assert( ipoint < fMaxPoints );; 398 assert( icoord < fDim );; 399 assert( fCoordErrorsPtr.size() == fDim );; 400 assert( fCoordErrorsPtr[icoord] );; 401 assert( fCoordErrors.empty() || &fCoordErrors[icoord].front() == fCoordErrorsPtr[icoord] );; 402 ; 403 return fCoordErrorsPtr[i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:13167,efficient,efficient,13167,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,1,['efficient'],['efficient']
Energy Efficiency,"ot(""plot"");; TRFunctionImport lines(""lines"");; TRFunctionImport devnew(""dev.new"");; TRFunctionImport devoff(""dev.off"");; TRFunctionImport min(""min"");; TRFunctionImport max(""max"");; TRFunctionImport seq(""seq"");; TRFunctionImport predict(""predict"");; ; r<<""options(device='png')"";//enable plot in png file; ; ////////////////////////; //doing the procedure //; ////////////////////////; TRObject xdata = c(-2,-1.64,-1.33,-0.7,0,0.45,1.2,1.64,2.32,2.9);; TRObject ydata = c(0.699369,0.700462,0.695354,1.03905,1.97389,2.41143,1.91091,0.919576,-0.730975,-1.42001);; ; TRDataFrame data;; data[""xdata""]=xdata;; data[""ydata""]=ydata;; ; //fit = nls(ydata ~ p1*cos(p2*xdata) + p2*sin(p1*xdata), start=list(p1=1,p2=0.2)) <- R code; TRObject fit = nls(asformula(""ydata ~ p1*cos(p2*xdata) + p2*sin(p1*xdata)""),Label[""data""]=data, Label[""start""]=list(Label[""p1""]=1,Label[""p2""]=0.2));; print(summary(fit));; ; print(confint(fit));; ; devnew(""Fitting Regression"");; plot(xdata,ydata);; ; TRObject xgrid=seq(min(xdata),max(xdata),Label[""len""]=10);; lines(xgrid,predict(fit,xgrid),Label[""col""] = ""green"");; devoff();; }; c#define c(i)Definition RSha256.hxx:101; plotwinID h TVirtualViewer3D TVirtualGLPainter char TVirtualGLPainter plotDefinition TGWin32VirtualGLProxy.cxx:53; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TRInterface.h; FunctionDouble_t(* Function)(Double_t)Definition Functor.C:4; ROOT::R::TRDataFrameThis is a class to create DataFrames from ROOT to R.Definition TRDataFrame.h:176; ROOT::R::TRFunctionImportThis is a class to pass functions from ROOT to R.Definition TRFunctionImport.h:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1R_1_1TRFunctionImport.html:2242,green,green,2242,doc/master/classROOT_1_1R_1_1TRFunctionImport.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1R_1_1TRFunctionImport.html,1,['green'],['green']
Energy Efficiency,"otIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. void * New(void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated array of objects; of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void Destructor(void* obj, Bool_t dtorOnly = kFALSE); Explicitly call destructor for object. void DeleteArray(void* ary, Bool_t dtorOnly = kFALSE); Explicitly call operator delete[] for an array. void SetCanSplit(Int_t splitmode); Set the splitability of this class:; -1: Use the default calculation; 0: Disallow splitting; 1: Always allow splitting. void SetClassVersion(Version_t version); Private function. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassTable.cxx. Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the; I/O should us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TClass.html:36268,allocate,allocated,36268,root/html530/TClass.html,https://root.cern,https://root.cern/root/html530/TClass.html,5,['allocate'],['allocated']
Energy Efficiency,"otIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. void * New(void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated array of objects; of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void * NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). void Destructor(void* obj, Bool_t dtorOnly = kFALSE); Explicitly call destructor for object. void DeleteArray(void* ary, Bool_t dtorOnly = kFALSE); Explicitly call operator delete[] for an array. void SetClassVersion(Version_t version); Private function. Set the class version for the 'class' represented by; this TClass object. See the public interface:; ROOT::ResetClassVersion; defined in TClassTable.cxx. Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the; I/O should use the TClass checksum to distinguish the layout of the class. void SetCurrentStreamerInfo(TVirtualStreamerInfo* info); Set pointer to current TVirtualStrea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClass.html:32354,allocate,allocated,32354,root/html526/TClass.html,https://root.cern,https://root.cern/root/html526/TClass.html,2,['allocate'],['allocated']
Energy Efficiency,"oticError()` <td> Use the asymptotically correct approach to estimate errors in the presence of weights.; 1025 * This is slower but more accurate than `SumW2Error`. See also https://arxiv.org/abs/1911.01303).; 1026 This option even correctly implements the case of extended likelihood fits; 1027 (see this [writeup on extended weighted fits](https://root.cern/files/extended_weighted_fits.pdf) that complements the paper linked before).; 1028 * <tr><td> `PrefitDataFraction(double fraction)`; 1029 * <td> Runs a prefit on a small dataset of size fraction*(actual data size). This can speed up fits; 1030 * by finding good starting values for the parameters for the actual fit.; 1031 * \warning Prefitting may give bad results when used in binned analysis.; 1032 *; 1033 * <tr><th><th> Options to control informational output; 1034 * <tr><td> `Verbose(bool flag)` <td> Flag controls if verbose output is printed (NLL, parameter changes during fit).; 1035 * <tr><td> `Timer(bool flag)` <td> Time CPU and wall clock consumption of fit steps, off by default.; 1036 * <tr><td> `PrintLevel(Int_t level)` <td> Set Minuit print level (-1 to 3, default is 1). At -1 all RooFit informational messages are suppressed as well.; 1037 * See RooMinimizer::PrintLevel for the meaning of the levels.; 1038 * <tr><td> `Warnings(bool flag)` <td> Enable or disable MINUIT warnings (enabled by default); 1039 * <tr><td> `PrintEvalErrors(Int_t numErr)` <td> Control number of p.d.f evaluation errors printed per likelihood evaluation.; 1040 * A negative value suppresses output completely, a zero value will only print the error count per p.d.f component,; 1041 * a positive value will print details of each error up to `numErr` messages per p.d.f component.; 1042 * <tr><td> `Parallelize(Int_t nWorkers)` <td> Control global parallelization settings. Arguments 1 and above enable the use of RooFit's parallel minimization; 1043 * backend and uses the number given as the number of workers to use in the parallelization. -1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:49973,consumption,consumption,49973,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['consumption'],['consumption']
Energy Efficiency,"ou to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * If the objects are added using the placement new then the Clear must; deallocate the memory.; * If the objects are added using TClonesArray::ConstructedAt then the; heap-based memory can stay allocated and reused as the constructor is; not called for already constructed/added object.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TClonesArray.html:3860,allocate,allocate,3860,root/html604/TClonesArray.html,https://root.cern,https://root.cern/root/html604/TClonesArray.html,1,['allocate'],['allocate']
Energy Efficiency,"ou to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. TClonesArray(); TClonesArray(const TClonesArray& tc); TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:3860,allocate,allocate,3860,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,2,['allocate'],['allocate']
Energy Efficiency,"ou to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const TObject*, TObject*); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject*, Int_t); virtual voidAddAtAndEx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClonesArray.html:3860,allocate,allocate,3860,root/html602/TClonesArray.html,https://root.cern,https://root.cern/root/html602/TClonesArray.html,1,['allocate'],['allocate']
Energy Efficiency,"ouble Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(GSLFuncPointer f, void * p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(GSLFuncPointer f, void * p, const std::vector<double> & pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__GSLIntegrator.html:11026,efficient,efficient,11026,root/html526/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__GSLIntegrator.html,2,"['adapt', 'efficient']","['adapter', 'efficient']"
Energy Efficiency,"ouble Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__GSLIntegrator.html:11320,efficient,efficient,11320,root/html528/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__GSLIntegrator.html,12,"['adapt', 'efficient']","['adapter', 'efficient']"
Energy Efficiency,"ouble operator()(double x) constDefinition TF1.cxx:156; GFunc::fFunctionconst TF1 * fFunctionDefinition TF1.cxx:152; GFunc::fY0const double fY0Definition TF1.cxx:153; GFunc::GFuncGFunc(const TF1 *function, double y)Definition TF1.cxx:155; GInverseFuncNdimDefinition TF1.cxx:174; GInverseFuncNdim::GInverseFuncNdimGInverseFuncNdim(TF1 *function)Definition TF1.cxx:177; GInverseFuncNdim::fFunctionTF1 * fFunctionDefinition TF1.cxx:175; GInverseFuncNdim::operator()double operator()(const double *x) constDefinition TF1.cxx:179; GInverseFuncDefinition TF1.cxx:163; GInverseFunc::operator()double operator()(double x) constDefinition TF1.cxx:168; GInverseFunc::fFunctionconst TF1 * fFunctionDefinition TF1.cxx:164; GInverseFunc::GInverseFuncGInverseFunc(const TF1 *function)Definition TF1.cxx:166; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Math::AdaptiveIntegratorMultiDimClass for adaptive quadrature integration in multi-dimensions using rectangular regions.Definition AdaptiveIntegratorMultiDim.h:84; ROOT::Math::AdaptiveIntegratorMultiDim::Statusint Status() const overridereturn status of integrationDefinition AdaptiveIntegratorMultiDim.h:149; ROOT::Math::AdaptiveIntegratorMultiDim::Integraldouble Integral(const double *xmin, const double *xmax) overrideevaluate the integral with the previously given function between xmin[] and xmax[]Definition AdaptiveIntegratorMultiDim.h:119; ROOT::Math::AdaptiveIntegratorMultiDim::NEvalint NEval() const overridereturn number of function evaluations in calculating the integralDefinition AdaptiveIntegratorMultiDim.h:152; ROOT::Math::AdaptiveIntegratorMultiDim::RelErrordouble RelError() constreturn relative errorDefinition AdaptiveIntegratorMultiDim.h:137; ROOT::Math::BrentMinimizer1DUser class for performing function minimization.Definition BrentMinimizer1D.h:62; ROOT::Math::BrentMinimizer1D::SetFunctionvoid SetFunction(const ROOT::Math::I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:154035,adapt,adaptive,154035,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['adapt'],['adaptive']
Energy Efficiency,"ouble_t f6 = 1.42151175831644588870e-7;; 2507 Double_t f7 = 2.04426310338993978564e-15;; 2508 ; 2509 Double_t split1 = 0.425;; 2510 Double_t split2=5.;; 2511 Double_t konst1=0.180625;; 2512 Double_t konst2=1.6;; 2513 ; 2514 Double_t q, r, quantile;; 2515 q=p-0.5;; 2516 if (TMath::Abs(q)<split1) {; 2517 r=konst1-q*q;; 2518 quantile = q* (((((((a7 * r + a6) * r + a5) * r + a4) * r + a3); 2519 * r + a2) * r + a1) * r + a0) /; 2520 (((((((b7 * r + b6) * r + b5) * r + b4) * r + b3); 2521 * r + b2) * r + b1) * r + 1.);; 2522 } else {; 2523 if(q<0) r=p;; 2524 else r=1-p;; 2525 //error case; 2526 if (r<=0); 2527 quantile=0;; 2528 else {; 2529 r=TMath::Sqrt(-TMath::Log(r));; 2530 if (r<=split2) {; 2531 r=r-konst2;; 2532 quantile=(((((((c7 * r + c6) * r + c5) * r + c4) * r + c3); 2533 * r + c2) * r + c1) * r + c0) /; 2534 (((((((d7 * r + d6) * r + d5) * r + d4) * r + d3); 2535 * r + d2) * r + d1) * r + 1);; 2536 } else{; 2537 r=r-split2;; 2538 quantile=(((((((e7 * r + e6) * r + e5) * r + e4) * r + e3); 2539 * r + e2) * r + e1) * r + e0) /; 2540 (((((((f7 * r + f6) * r + f5) * r + f4) * r + f3); 2541 * r + f2) * r + f1) * r + 1);; 2542 }; 2543 if (q<0) quantile=-quantile;; 2544 }; 2545 }; 2546 return quantile;; 2547}; 2548 ; 2549////////////////////////////////////////////////////////////////////////////////; 2550/// Simple recursive algorithm to find the permutations of; 2551/// n natural numbers, not necessarily all distinct; 2552/// adapted from CERNLIB routine PERMU.; 2553/// The input array has to be initialised with a non descending; 2554/// sequence. The method returns kFALSE when; 2555/// all combinations are exhausted.; 2556 ; 2557Bool_t TMath::Permute(Int_t n, Int_t *a); 2558{; 2559 Int_t i,itmp;; 2560 Int_t i1=-1;; 2561 ; 2562 // find rightmost upward transition; 2563 for(i=n-2; i>-1; i--) {; 2564 if(a[i]<a[i+1]) {; 2565 i1=i;; 2566 break;; 2567 }; 2568 }; 2569 // no more upward transitions, end of the story; 2570 if(i1==-1) return kFALSE;; 2571 else {; 2572 // find",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:87547,adapt,adapted,87547,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['adapt'],['adapted']
Energy Efficiency,"ouble_t* err = 0, Double_t* errUpper = 0); return boosted MVA response. Double_t GetBoostROCIntegral(Bool_t , TMVA::Types::ETreeType , Bool_t CalcOverlapIntergral = kFALSE); Calculate the ROC integral of a single classifier or even the; whole boosted classifier. The tree type (training or testing; sample) is specified by 'eTT'. If tree type kTraining is set, the original training sample is; used to compute the ROC integral (original weights). - singleMethod - if kTRUE, return ROC integral of single (last; trained) classifier; if kFALSE, return ROC; integral of full classifier. - eTT - tree type (Types::kTraining / Types::kTesting). - CalcOverlapIntergral - if kTRUE, the overlap integral of the; signal/background MVA distributions; is calculated and stored in; 'fOverlap_integral'. void CalcMVAValues(); Calculate MVA values of current method fMethods.back() on; training sample. void SetBoostedMethodName(TString methodName); { fBoostedMethodName = methodName; }. Int_t GetBoostNum(); { return fBoostNum; }. TH1* GetMonitoringHist(Int_t histInd); gives the monitoring historgram from the vector according to index of the; histrogram added in the MonitorBoost function. { return (*fMonitorHist)[fDefaultHistNum+histInd]; }. void AddMonitoringHist(TH1* hist); { return fMonitorHist->push_back(hist); }. Types::EBoostStage GetBoostStage(); { return fBoostStage; }. void ClearAll(); clean up. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; print fit results. MethodBoost* SetStage(TMVA::Types::EBoostStage stage); { fBoostStage = stage; return this; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Or Cohen, Jan Therhaag, Eckhard von Toerne » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id: MethodBoost.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodBoost.html:21808,monitor,monitoring,21808,root/html530/TMVA__MethodBoost.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodBoost.html,1,['monitor'],['monitoring']
Energy Efficiency,"ouble_t> > vec, const Double_t quantile, const Double_t SumOfWeights = 0.); calculates the quantile of the distribution of the first pair entries weighted with the values in the second pair entries. Double_t GradBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt, UInt_t cls = 0); Calculate the desired response value for each region. Double_t GradBoostRegression(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); Implementation of M_TreeBoost using a Huber loss function as desribed by Friedman 1999. void InitGradBoost(vector<const TMVA::Event*>& ); initialize targets for first tree. Double_t TestTreeQuality(TMVA::DecisionTree* dt); test the tree quality.. in terms of Miscalssification. Double_t Boost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt, UInt_t cls = 0); apply the boosting alogrithim (the algorithm is selecte via the the ""option"" given; in the constructor. The return value is the boosting weight. void BoostMonitor(Int_t iTree); fills the ROCIntegral vs Itree from the testSample for the monitoring plots; during the training .. but using the testing events. Double_t AdaBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); the AdaBoost implementation.; a new training sample is generated by weighting; events that are misclassified by the decision tree. The weight; applied is w = (1-err)/err or more general:; w = ((1-err)/err)^beta; where err is the fraction of misclassified events in the tree ( <0.5 assuming; demanding the that previous selection was better than random guessing); and ""beta"" being a free parameter (standard: beta = 1) that modifies the; boosting. Double_t AdaCost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); the AdaCost boosting algorithm takes a simple cost Matrix (currently fixed for; all events... later could be modified to use individual cost matrices for each; events as in the original paper... true_signal true_bkg. sel_signal | Css Ctb_ss Cxx.. in the range [0,1]; sel_bkg | Cts_sb Cbb. and takes this into ac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodBDT.html:32873,monitor,monitoring,32873,root/html602/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodBDT.html,2,['monitor'],['monitoring']
Energy Efficiency,"ouble_tTQpSolverBase::fMutoltermination parameters; Double_tTQpSolverBase::fPhimerit function, defined as the sum of the complementarity gap; Double_t*TQpSolverBase::fPhi_history[fMaxit] history of values of phi obtained on all iterations to date; Double_t*TQpSolverBase::fPhi_min_history[fMaxit] the i-th entry of this array contains the minimum value of phi; Int_tfPrintlevelparameter in range [0,100] determines verbosity. (Higher value; Double_t*TQpSolverBase::fRnorm_history[fMaxit] history of values of residual norm obtained on all iterations to date; TQpVar*fStepstorage for step vectors; TQpLinSolverBase*TQpSolverBase::fSys; Double_tfTsigexponent in Mehrotra's centering parameter, which is usually. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMehrotraSolver(); Default constructor. TMehrotraSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); Constructor. TMehrotraSolver(const TMehrotraSolver& another); Copy constructor. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); Solve the quadratic programming problem as formulated through prob, store; the final solution in iterate->fX . Monitor the residuals during the iterations; through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); Print information about the optimization process and monitor the convergence; status of thye algorithm. ~TMehrotraSolver(); Deconstructor. TMehrotraSolver & operator=(const TMehrotraSolver& source); Assignment operator. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id$ » Last generated: 2015-03-14 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMehrotraSolver.html:8818,monitor,monitor,8818,root/html534/TMehrotraSolver.html,https://root.cern,https://root.cern/root/html534/TMehrotraSolver.html,1,['monitor'],['monitor']
Energy Efficiency,"ouble_tTQpSolverBase::fMutoltermination parameters; Double_tTQpSolverBase::fPhimerit function, defined as the sum of the complementarity gap; Double_t*TQpSolverBase::fPhi_history[fMaxit] history of values of phi obtained on all iterations to date; Double_t*TQpSolverBase::fPhi_min_history[fMaxit] the i-th entry of this array contains the minimum value of phi; Int_tfPrintlevelparameter in range [0,100] determines verbosity. (Higher value; Double_t*TQpSolverBase::fRnorm_history[fMaxit] history of values of residual norm obtained on all iterations to date; TQpVar*fStepstorage for step vectors; TQpLinSolverBase*TQpSolverBase::fSys; Double_tfTsigexponent in Mehrotra's centering parameter, which is usually. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMehrotraSolver(); Default constructor. TMehrotraSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); Constructor. TMehrotraSolver(const TMehrotraSolver& another); Copy constructor. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); Solve the quadratic programming problem as formulated through prob, store; the final solution in iterate->fX . Monitor the residuals during the iterations; through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); Print information about the optimization process and monitor the convergence; status of thye algorithm. ~TMehrotraSolver(); Deconstructor. TMehrotraSolver & operator=(const TMehrotraSolver& source); Assignment operator. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id$ » Last generated: 2015-06-02 16:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMehrotraSolver.html:9270,monitor,monitor,9270,root/html604/TMehrotraSolver.html,https://root.cern,https://root.cern/root/html604/TMehrotraSolver.html,1,['monitor'],['monitor']
Energy Efficiency,"ouble_tTQpSolverBase::fMutoltermination parameters; Double_tTQpSolverBase::fPhimerit function, defined as the sum of the complementarity gap; Double_t*TQpSolverBase::fPhi_history[fMaxit] history of values of phi obtained on all iterations to date; Double_t*TQpSolverBase::fPhi_min_history[fMaxit] the i-th entry of this array contains the minimum value of phi; Int_tfPrintlevelparameter in range [0,100] determines verbosity. (Higher value; Double_t*TQpSolverBase::fRnorm_history[fMaxit] history of values of residual norm obtained on all iterations to date; TQpVar*fStepstorage for step vectors; TQpLinSolverBase*TQpSolverBase::fSys; Double_tfTsigexponent in Mehrotra's centering parameter, which is usually. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMehrotraSolver(); Default constructor. TMehrotraSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); Constructor. TMehrotraSolver(const TMehrotraSolver& another); Copy constructor. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); Solve the quadratic programming problem as formulated through prob, store; the final solution in iterate->fX . Monitor the residuals during the iterations; through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); Print information about the optimization process and monitor the convergence; status of thye algorithm. ~TMehrotraSolver(); Deconstructor. TMehrotraSolver & operator=(const TMehrotraSolver& source); Assignment operator. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id$ » Last generated: 2015-06-30 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMehrotraSolver.html:9270,monitor,monitor,9270,root/html602/TMehrotraSolver.html,https://root.cern,https://root.cern/root/html602/TMehrotraSolver.html,1,['monitor'],['monitor']
Energy Efficiency,"ough the `RSampleInfo`; // class; auto df_analysis =; df.DefinePerSample(""xsecs"", [](unsigned int slot, const RSampleInfo &id) { return id.GetD(""xsecs""); }); .DefinePerSample(""lumi"", [](unsigned int slot, const RSampleInfo &id) { return id.GetD(""lumi""); }); .DefinePerSample(""sumws"", [](unsigned int slot, const RSampleInfo &id) { return id.GetD(""sumws""); }); .DefinePerSample(""sample_category"",; [](unsigned int slot, const RSampleInfo &id) { return id.GetS(""sample_category""); }); // Apply an MC correction for the ZZ decay due to missing gg->ZZ process; .DefinePerSample(""scale"",; [](unsigned int slot, const ROOT::RDF::RSampleInfo &id) {; return id.Contains(""mc_363490.llll.4lep.root"") ? 1.3f : 1.0f;; }); // Select electron or muon trigger; .Filter(""trigE || trigM""); // Select events with exactly four good leptons conserving charge and lepton numbers; // Note that all collections are RVecs and good_lep is the mask for the good leptons.; // The lepton types are PDG numbers and set to 11 or 13 for an electron or muon; // irrespective of the charge.; .Define(""good_lep"",; ""abs(lep_eta) < 2.5 && lep_pt > 5000 && lep_ptcone30 / lep_pt < 0.3 && lep_etcone20 / lep_pt < 0.3""); .Filter(""Sum(good_lep) == 4""); .Filter(""Sum(lep_charge[good_lep]) == 0""); .Define(""goodlep_sumtypes"", ""Sum(lep_type[good_lep])""); .Filter(""goodlep_sumtypes == 44 || goodlep_sumtypes == 52 || goodlep_sumtypes == 48""); // Apply additional cuts depending on lepton flavour; .Filter(; ""GoodElectronsAndMuons(lep_type[good_lep], lep_pt[good_lep], lep_eta[good_lep], lep_phi[good_lep], ""; ""lep_E[good_lep], lep_trackd0pvunbiased[good_lep], lep_tracksigd0pvunbiased[good_lep], lep_z0[good_lep])""); // Create new columns with the kinematics of good leptons; .Define(""goodlep_pt"", ""lep_pt[good_lep]""); .Define(""goodlep_eta"", ""lep_eta[good_lep]""); .Define(""goodlep_phi"", ""lep_phi[good_lep]""); .Define(""goodlep_E"", ""lep_E[good_lep]""); .Define(""goodlep_type"", ""lep_type[good_lep]""); // Select leptons with high transverse momentum;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:5403,charge,charge,5403,doc/master/df106__HiggsToFourLeptons_8C.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html,1,['charge'],['charge']
Energy Efficiency,"ould be able to; : make this choice by giving appropriate weights for either terms.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : I. TUNING OF RULE ENSEMBLE:; : ; : ␛[1mForestType ␛[0m: Recommended is to use the default ""AdaBoost"".; : ␛[1mnTrees ␛[0m: More trees leads to more rules but also slow; : performance. With too few trees the risk is; : that the rule ensemble becomes too simple.; : ␛[1mfEventsMin ␛[0m; : ␛[1mfEventsMax ␛[0m: With a lower min, more large trees will be generated; : leading to more complex rules.; : With a higher max, more small trees will be; : generated leading to more simple rules.; : By changing this range, the average complexity; : of the rule ensemble can be controlled.; : ␛[1mRuleMinDist ␛[0m: By increasing the minimum distance between; : rules, fewer and more diverse rules will remain.; : Initially it is a good idea to keep this small; : or zero and let the fitting do the selection of; : rules. In order to reduce the ensemble size,; : the value can then be increased.; : ; : II. TUNING OF THE FITTING:; : ; : ␛[1mGDPathEveFrac ␛[0m: fraction of events in path evaluation; : Increasing this fraction will improve the path; : finding. However, a too high value will give few; : unique events available for error estimation.; : It is recommended to use the default = 0.5.; : ␛[1mGDTau ␛[0m: cutoff parameter tau; : By default this value is set to -1.0.; : This means that the cut off parameter is; : automatically estimated. In most cases; : this should be fine. However, you may want; : to fix this value if you already know it; : and want to reduce on training time.; : ␛[1mGDTauPrec ␛[0m: precision of estimated tau; : Increase this precision to find a more; : optimum cut-off parameter.; : ␛[1mGDNStep ␛[0m: number of steps in path search; : If the number of steps is too small, then; : the program will give a warning message.; : ; : III. WARNING MESSAGES; : ; : ␛[1mRisk(i+1)>=Risk(i) in path␛[0m; : ␛[1mChaotic behaviour of ri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:54995,reduce,reduce,54995,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['reduce'],['reduce']
Energy Efficiency,"ould be called from ctors after fNpoints has been set Note: This function should be called only from the constructor since it does not delete previously existing arrays. ;  ; Bool_t DoMerge (const TGraph *tg) override;  Protected function to perform the merge operation of a graph with multiple asymmetric errors. ;  ; void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) override;  Set zero values for point arrays in the range [begin, end]. ;  ; void SwapPoints (Int_t pos1, Int_t pos2) override;  Swap points. ;  ; void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) override;  Update the fX, fY, fExL, fExH, fEyL and fEyH arrays with the sorted values. ;  ;  Protected Member Functions inherited from TGraph; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void SaveHistogramAndFunctions (std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option);  Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes. ;  ; Double_t ** ShrinkAndCopy (Int_t size, Int_t iend);  if size*2 <= fMaxSize allocate new arrays of size points, copy points [0,oend). ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; std::vector< TAttFill > fAttFill;  The AttFill attributes of the different errors. ;  ; std::vector< TAttLine > fAttLine;  The AttLine attributes of the different errors. ;  ; Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphMultiErrors.html:41324,allocate,allocate,41324,doc/master/classTGraphMultiErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphMultiErrors.html,1,['allocate'],['allocate']
Energy Efficiency,"ours = contours->GetSize();; TList *list = (TList*)contours->At(i);. Where i is a contour number, and list contains a list of; TGraph objects.; For one given contour, more than one disjoint polyline may be generated.; The number of TGraphs per contour is given by:. list->GetSize();. To access the first graph in the list one should do:. TGraph *gr1 = (TGraph*)list->First();. The following example shows how to use this functionality. Picture; Source. // Getting Contours From TH2D; // Author: Josh de Bever; // CSI Medical Physics Group; // The University of Western Ontario; // London, Ontario, Canada; // Date: Oct. 22, 2004; // Modified by O.Couet (Nov. 26, 2004). TCanvas *ContourList(){. const Double_t PI = TMath::Pi();. TCanvas* c = new TCanvas(""c"",""Contour List"",0,0,600,600);; c->SetRightMargin(0.15);; c->SetTopMargin(0.15);. Int_t i, j, TotalConts;. Int_t nZsamples = 80;; Int_t nPhiSamples = 80;. Double_t HofZwavelength = 4.0; // 4 meters; Double_t dZ = HofZwavelength/(Double_t)(nZsamples - 1);; Double_t dPhi = 2*PI/(Double_t)(nPhiSamples - 1);. TArrayD z(nZsamples);; TArrayD HofZ(nZsamples);; TArrayD phi(nPhiSamples);; TArrayD FofPhi(nPhiSamples);. // Discretized Z and Phi Values; for ( i = 0; i < nZsamples; i++) {; z[i] = (i)*dZ - HofZwavelength/2.0;; HofZ[i] = SawTooth(z[i], HofZwavelength);; }. for(Int_t i=0; i < nPhiSamples; i++){; phi[i] = (i)*dPhi;; FofPhi[i] = sin(phi[i]);; }. // Create Histogram; TH2D *HistStreamFn = new TH2D(""HstreamFn"",; ""#splitline{Histogram with negative and positive contents. Six contours are defined.}{It is plotted with options CONT LIST to retrieve the contours points in TGraphs}"",; nZsamples, z[0], z[nZsamples-1], nPhiSamples, phi[0], phi[nPhiSamples-1]);. // Load Histogram Data; for (Int_t i = 0; i < nZsamples; i++) {; for(Int_t j = 0; j < nPhiSamples; j++){; HistStreamFn->SetBinContent(i,j, HofZ[i]*FofPhi[j]);; }; }. gStyle->SetPalette(1);; gStyle->SetOptStat(0);; gStyle->SetTitleW(0.99);; gStyle->SetTitleH(0.08);. Double_t contou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:36689,meter,meters,36689,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,4,['meter'],['meters']
Energy Efficiency,"ourses » Introductory Tutorials Accessing a TTree With a TBrowser. Now, with the TFile still open, let's do some interactive work. Start the ROOT Browser by typing:; root[1] new TBrowser(). Something like this should appear:. Figure 2: Example of TBrowser at start-up time; On the left, in the ""ROOT Files"" folder, you can find the ROOT file you have opened and our EventTree. If you see EventTree;1 and EventTree: they are identical. The first one is the tree on disk, the second the one in memory. Click your way through the tree.; Draw the ""fPosZ"" values from the browser. You should obtain a result looking like this:. Figure 3: Distribution of ""fPosZ"" values; This graph is called a histogram: it counts occurrences, combining neighboring values into ""bins"". In this case we have 100 equally sized bins (the ""steps""), ranging from x=-74 to x=102. You can tell that there were about 500 particles with a fPosZ value around -11. Histograms are a very common way to visualize data, e.g. in high energy physics.; Now close the browser, quit and restart ROOT (to make sure everybody starts from the same point).; . ‹ Meet a TTree; up; Using TTree::Draw() to access a TTree ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/accessing-ttree-tbrowser.html:2884,energy,energy,2884,d/accessing-ttree-tbrowser.html,https://root.cern,https://root.cern/d/accessing-ttree-tbrowser.html,1,['energy'],['energy']
Energy Efficiency,"ovedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoHelix&operator=(const TGeoHelix&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidResetStep(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCharge(Int_t charge); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); voidSetHelixStep(Double_t hstep); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetXYcurvature(Double_t curvature); virtual voidShowMembers(TMemberInspector& insp); voidStep(Double_t step); Double_tStepToPlane(Double_t* point, Double_t* norm); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidUpdateHelix(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoHelix.html:5521,charge,charge,5521,root/html530/TGeoHelix.html,https://root.cern,https://root.cern/root/html530/TGeoHelix.html,2,['charge'],['charge']
Energy Efficiency,"overridename of 1D integratorDefinition IntegratorOptions.cxx:203; ROOT::Math::IntegratorOneDimUser Class for performing numerical integration of a function in one dimension.Definition Integrator.h:98; ROOT::Math::IntegratorOneDim::SetAbsTolerancevoid SetAbsTolerance(double absTolerance)set the desired absolute ErrorDefinition Integrator.h:441; ROOT::Math::IntegratorOneDim::GetNamestatic std::string GetName(IntegrationOneDim::Type)static function to get a string from the enumerationDefinition Integrator.cxx:66; ROOT::Math::IntegratorOneDim::SetFunctionvoid SetFunction(const IGenFunction &f, bool copy=false)set one dimensional function for 1D integrationDefinition Integrator.h:202; ROOT::Math::IntegratorOneDim::Integraldouble Integral(const IGenFunction &f)evaluate the Integral of a function f over the infinite interval (-inf,+inf)Definition Integrator.h:258; ROOT::Math::IntegratorOneDim::IntegratorOneDimIntegratorOneDim(IntegrationOneDim::Type type=IntegrationOneDim::kDEFAULT, double absTol=-1, double relTol=-1, unsigned int size=0, unsigned int rule=0)Constructor of one dimensional Integrator, default type is adaptive.Definition Integrator.h:123; ROOT::Math::IntegratorOneDim::IntegralCauchydouble IntegralCauchy(const IGenFunction &f, double a, double b, double c)evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,...Definition Integrator.h:340; ROOT::Math::IntegratorOneDim::operator()double operator()(double x)define operator() for IntegralLowDefinition Integrator.h:386; ROOT::Math::IntegratorOneDim::SetRelTolerancevoid SetRelTolerance(double relTolerance)set the desired relative ErrorDefinition Integrator.h:435; ROOT::Math::IntegratorOneDim::fIntegratorVirtualIntegratorOneDim * fIntegratorpointer to integrator interface classDefinition Integrator.h:474; ROOT::Math::IntegratorOneDim::Namestd::string Name() constreturn name of integratorDefinition Integrator.h:459; ROOT::Math::IntegratorOneDim::GetIntegratorVirtualIntegrat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Integrator_8h_source.html:24103,adapt,adaptive,24103,doc/master/Integrator_8h_source.html,https://root.cern,https://root.cern/doc/master/Integrator_8h_source.html,1,['adapt'],['adaptive']
Energy Efficiency,"ow supports fits with RooFit’s faster BatchMode().; Lower memory footprint. If weight errors are not needed, RooDataHist now allocates only 40% of the memory that the old implementation used. Fix bin volume correction logic in RooDataHist::sum(); The public member function RooDataHist::sum() has three overloads. Two of these overloads accept a sumSet parameter to not sum over all variables. These two overloads previously behaved inconsistently when the correctForBinSize or inverseBinCor flags were set. If you use the RooDataHist::sum() function in you own classes, please check that it can still be used with its new logic. The new and corrected bin correction behaviour is:. correctForBinSize: multiply counts in each bin by the bin volume corresponding to the variables in sumSet; inverseBinCor: divide counts in each bin by the bin volume corresponding to the variables not in sumSet. New fully parametrised Crystal Ball shape class; So far, the Crystal Ball distribution has been represented in RooFit only by the RooCBShape class, which has a Gaussian core and a single power-law tail on one side. This release introduces RooCrystalBall, which implements some common generalizations of the Crystal Ball shape:. symmetric or asymmetric power-law tails on both sides; different width parameters for the left and right sides of the Gaussian core. The new RooCrystalBall class can substitute the RooDSCBShape and RooSDSCBShape, which were passed around in the community.; 2D Graphics Libraries. Add the method AddPointto TGraph(x,y) and TGraph2D(x,y,z), equivalent to SetPoint(g->GetN(),x,y)and SetPoint(g->GetN(),x,y,z); Option E0 draws error bars and markers are drawn for bins with 0 contents. Now, combined with options E1 and E2, it avoids error bars clipping.; Fix TAxis::ChangeLabel for vertical axes and 3D plots. Networking Libraries; Multithreaded support for FastCGI; Now when THttpServer creates FastCGI engine, 10 worker threads used to process requests received via FastCGI channe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:25614,power,power-law,25614,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['power'],['power-law']
Energy Efficiency,"ow to use the ""parallel world"" feature to assign highest navigation priority to some physical paths in geometry. ; void align();; ; //______________________________________________________________________________; void parallel_world(Bool_t usepw=kTRUE, Bool_t useovlp=kTRUE); {; // web geometry display does not support ""parallel world"" feature; gROOT->SetWebDisplay(""off"");; ; TGeoManager *geom = new TGeoManager(""parallel_world"", ""Showcase for prioritized physical paths"");; TGeoMaterial *matV = new TGeoMaterial(""Vac"", 0,0,0);; TGeoMedium *medV = new TGeoMedium(""MEDVAC"",1,matV);; TGeoMaterial *matAl = new TGeoMaterial(""Al"", 26.98,13,2.7);; TGeoMedium *medAl = new TGeoMedium(""MEDAL"",2,matAl);; TGeoMaterial *matSi = new TGeoMaterial(""Si"", 28.085,14,2.329);; TGeoMedium *medSi = new TGeoMedium(""MEDSI"",3,matSi);; TGeoVolume *top = gGeoManager->MakeBox(""TOP"",medV,100,400,1000);; gGeoManager->SetTopVolume(top);; ; // Shape for the support block; TGeoBBox *sblock = new TGeoBBox(""sblock"", 20,10,2);; // The volume for the support; TGeoVolume *support = new TGeoVolume(""block"",sblock, medAl);; support->SetLineColor(kGreen);; ; // Shape for the sensor to be prioritized in case of overlap; TGeoBBox *ssensor = new TGeoBBox(""sensor"", 19,9,0.2);; // The volume for the sensor; TGeoVolume *sensor = new TGeoVolume(""sensor"",ssensor, medSi);; sensor->SetLineColor(kRed);; ; // Chip assembly of support+sensor; TGeoVolumeAssembly *chip = new TGeoVolumeAssembly(""chip"");; chip->AddNode(support, 1);; chip->AddNode(sensor,1, new TGeoTranslation(0,0,-2.1));; ; // A ladder that normally sags; TGeoBBox *sladder = new TGeoBBox(""sladder"", 20,300,5);; // The volume for the ladder; TGeoVolume *ladder = new TGeoVolume(""ladder"",sladder, medAl);; ladder->SetLineColor(kBlue);; ; // Add nodes; top->AddNode(ladder,1);; for (Int_t i=0; i<10; i++); top->AddNode(chip, i+1, new TGeoTranslation(0, -225.+50.*i, 10));; ; gGeoManager->CloseGeometry();; TGeoParallelWorld *pw = nullptr;; if (usepw) pw = gGeoManager->Cr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/parallel__world_8C.html:1841,sensor,sensor,1841,doc/master/parallel__world_8C.html,https://root.cern,https://root.cern/doc/master/parallel__world_8C.html,2,['sensor'],['sensor']
Energy Efficiency,"owMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidTGLManip::CalcDrawScale(const TGLBoundingBox& box, const TGLCamera& camera, Double_t& base, TGLVector3* axis) const; const UChar_t*TGLManip::ColorFor(UInt_t widget) const; TGLManip&TGLManip::operator=(const TGLManip&). Data Members; protected:. Bool_tTGLManip::fActive! manipulator is active?; TPointTGLManip::fFirstMouse! first (start) mouse position (in WINDOW coords); TPointTGLManip::fLastMouse! last (latest) mouse position (in WINDOW coords); UInt_tTGLManip::fSelectedWidget! active width (axis) component; TGLPhysicalShape*TGLManip::fShape! manipulated shape. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLTransManip(); Construct translation manipulator not bound to any physical shape. TGLTransManip(TGLPhysicalShape* shape); Construct translation manipulator, attached to supplied TGLViewer; 'viewer', bound to TGLPhysicalShape 'shape'. ~TGLTransManip(); Destory the translation manipulator. void Draw(const TGLCamera& camera) const; Draw translation manipulator - tubes with arrow heads, in local axes of; attached shape, in red(X), green(Y) and blue(Z), with white center sphere.; If selected widget (mouse over) this is drawn in active colour (yellow). Bool_t HandleMotion(const Event_t& event, const TGLCamera& camera); Handle mouse motion over manipulator - if active (selected; widget) translate physical along selected widget (axis) of the; manipulator, so it tracks mouse action. Returns kTRUE if redraw; required kFALSE otherwise. TGLTransManip(). » Author: Richard Maunder 16/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLTransManip.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLTransManip.html:2551,green,green,2551,root/html528/TGLTransManip.html,https://root.cern,https://root.cern/root/html528/TGLTransManip.html,1,['green'],['green']
Energy Efficiency,"owMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidTGLManip::CalcDrawScale(const TGLBoundingBox& box, const TGLCamera& camera, Double_t& base, TGLVector3* axis) const; const UChar_t*TGLManip::ColorFor(UInt_t widget) const; TGLManip&TGLManip::operator=(const TGLManip&). Data Members; protected:. Bool_tTGLManip::fActive! manipulator is active?; TPointTGLManip::fFirstMouse! first (start) mouse position (in WINDOW coords); TPointTGLManip::fLastMouse! last (latest) mouse position (in WINDOW coords); UInt_tTGLManip::fSelectedWidget! active width (axis) component; TGLPhysicalShape*TGLManip::fShape! manipulated shape. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLTransManip(); Construct translation manipulator not bound to any physical shape. TGLTransManip(TGLPhysicalShape* shape); Construct translation manipulator, attached to supplied TGLViewer; 'viewer', bound to TGLPhysicalShape 'shape'. ~TGLTransManip(); Destory the translation manipulator. void Draw(const TGLCamera& camera) const; Draw translation manipulator - tubes with arrow heads, in local axes of; attached shape, in red(X), green(Y) and blue(Z), with white center sphere.; If selected widget (mouse over) this is drawn in active colour (yellow). Bool_t HandleMotion(const Event_t& event, const TGLCamera& camera); Handle mouse motion over manipulator - if active (selected; widget) translate physical along selected widget (axis) of the; manipulator, so it tracks mouse action. Returns kTRUE if redraw; required kFALSE otherwise. TGLTransManip(). » Author: Richard Maunder 16/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLTransManip.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGLTransManip.html:2551,green,green,2551,root/html530/TGLTransManip.html,https://root.cern,https://root.cern/root/html530/TGLTransManip.html,1,['green'],['green']
Energy Efficiency,"owMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidTGLManip::CalcDrawScale(const TGLBoundingBox& box, const TGLCamera& camera, Double_t& base, TGLVector3* axis) const; const UChar_t*TGLManip::ColorFor(UInt_t widget) const; TGLManip&TGLManip::operator=(const TGLManip&). Data Members; protected:. Bool_tTGLManip::fActive! manipulator is active?; TPointTGLManip::fFirstMouse! first (start) mouse position (in WINDOW coords); TPointTGLManip::fLastMouse! last (latest) mouse position (in WINDOW coords); UInt_tTGLManip::fSelectedWidget! active width (axis) component; TGLPhysicalShape*TGLManip::fShape! manipulated shape. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLTransManip(); Construct translation manipulator not bound to any physical shape. TGLTransManip(TGLPhysicalShape* shape); Construct translation manipulator, attached to supplied TGLViewer; 'viewer', bound to TGLPhysicalShape 'shape'. ~TGLTransManip(); Destory the translation manipulator. void Draw(const TGLCamera& camera) const; Draw translation manipulator - tubes with arrow heads, in local axes of; attached shape, in red(X), green(Y) and blue(Z), with white center sphere.; If selected widget (mouse over) this is drawn in active colour (yellow). Bool_t HandleMotion(const Event_t& event, const TGLCamera& camera); Handle mouse motion over manipulator - if active (selected; widget) translate physical along selected widget (axis) of the; manipulator, so it tracks mouse action. Returns kTRUE if redraw; required kFALSE otherwise. TGLTransManip(). » Author: Richard Maunder 16/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLTransManip.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLTransManip.html:2551,green,green,2551,root/html532/TGLTransManip.html,https://root.cern,https://root.cern/root/html532/TGLTransManip.html,1,['green'],['green']
Energy Efficiency,"owerlaw"", x, RooConst(1.0), a};; std::unique_ptr<RooAbsData> powerlawData{generateBinnedAsimov(powerlaw, x, 10000)};; ; // Again, if you do a vanilla fit, you'll get a bias; std::unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins());; std::unique_ptr<RooFitResult> fit4{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit4->Print();; disableBinIntegrator(powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, the pdf is not evaluated at the; // bin centers, but numerically integrated over each bin and divided by the; // bin width. The parameter for IntegrateBins() is the required precision; // for the numeric integrals. This is computationally expensive, but the; // bias is now not a problem anymore.; std::unique_ptr<RooFitResult> fit5{; powerlaw.fitTo(*powerlawData, IntegrateBins(1e-3), Save(), PrintLevel(-1), SumW2Error(false))};; fit5->Print();; ; // Improving numerical stability; // -----------------------------; ; // There is one more problem with binned fits that is related to the binning; // effects because often, a binned fit is affected by both problems.; //; // The issue is numerical stability for fits with a greatly different number; // of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; // the NLL, where \f[n\f] is the number of observations",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:5163,power,powerlawData,5163,doc/master/rf614__binned__fit__problems_8C.html,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html,2,['power'],"['powerlaw', 'powerlawData']"
Energy Efficiency,"owever, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers).; ; One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5].; ; There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if; . where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out).; . Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see 2.3).; ; The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the modified Gram-Schmidt; orthogonalisation algorithm [5] [3] to the; functions , we can evaluate the contribution to the reduction of; from each function in turn, and we may delay the actual inversion; of the curvature-matrix; (TMultiDimFit::MakeGramSchmidt).; ; So we are let to consider an matrix ; , an; element of which is given by; .    with. (3). where labels the rows in the training sample and labels; functions of variables, and . That is, is; the term (or function) numbered evaluated at the data point; . We have to normalise ; to for this to; succeed [5]; (TMultiDimFit::MakeNormalized). We then define a; matrix ; o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiDimFit.html:4754,reduce,reduce,4754,root/html534/TMultiDimFit.html,https://root.cern,https://root.cern/root/html534/TMultiDimFit.html,6,['reduce'],['reduce']
Energy Efficiency,"p ctor. See THashTable for a description of the arguments. ;  ; virtual ~TMap ();  TMap dtor. ;  ; void Add (TObject *key, TObject *value);  Add a (key,value) pair to the map. ;  ; void Add (TObject *obj) override;  This function may not be used (but we need to provide it since it is a pure virtual in TCollection). ;  ; Float_t AverageCollisions () const;  Return the ratio of entries vs occupied slots. ;  ; Int_t Capacity () const;  Return number of slots in the hashtable. ;  ; void Clear (Option_t *option="""") override;  Remove all (key,value) pairs from the map. ;  ; Int_t Collisions (const char *keyname) const;  Returns the number of collisions for a key with a certain name (i.e. ;  ; Int_t Collisions (TObject *key) const;  Returns the number of collisions for a key (i.e. ;  ; void Delete (Option_t *option="""") override;  Remove all (key,value) pairs from the map AND delete the keys when they are allocated on the heap. ;  ; void DeleteAll ();  Remove all (key,value) pairs from the map AND delete the keys AND values when they are allocated on the heap. ;  ; Bool_t DeleteEntry (TObject *key);  Remove (key,value) pair with key from the map. ;  ; void DeleteKeys ();  ; void DeleteValues ();  Remove all (key,value) pairs from the map AND delete the values when they are allocated on the heap. ;  ; TObject * FindObject (const char *keyname) const override;  Check if a (key,value) pair exists with keyname as name of the key. ;  ; TObject * FindObject (const TObject *key) const override;  Check if a (key,value) pair exists with key as key. ;  ; TObject ** GetObjectRef (const TObject *obj) const override;  ; const THashTable * GetTable () const;  ; TObject * GetValue (const char *keyname) const;  Returns a pointer to the value associated with keyname as name of the key. ;  ; TObject * GetValue (const TObject *key) const;  Returns a pointer to the value associated with key. ;  ; TClass * IsA () const override;  ; Bool_t IsOwnerValue () const;  ; TIterator * MakeIterator (Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMap.html:2730,allocate,allocated,2730,doc/master/classTMap.html,https://root.cern,https://root.cern/doc/master/classTMap.html,1,['allocate'],['allocated']
Energy Efficiency,"p, Double_t initWgt, Bool_t doDensityCorrection); Import data from given set of TH1/2/3 into this RooDataHist. The category indexCat labels the sources; in the constructed RooDataHist. The stl map provides the mapping between the indexCat state labels; and the import source. void importDHistSet(const RooArgList& vars, RooCategory& indexCat, map<std::string,RooDataHist*> dmap, Double_t initWgt); Import data from given set of TH1/2/3 into this RooDataHist. The category indexCat labels the sources; in the constructed RooDataHist. The stl map provides the mapping between the indexCat state labels; and the import source. void adjustBinning(const RooArgList& vars, TH1& href, Int_t* offset = 0); Adjust binning specification on first and optionally second and third; observable to binning in given reference TH1. Used by constructors; that import data from an external TH1. void initialize(const char* binningName = 0, Bool_t fillTree = kTRUE); Initialization procedure: allocate weights array, calculate; multipliers needed for N-space to 1-dim array jump table,; and fill the internal tree with all bin center coordinates. RooDataHist(const RooDataHist& other, const char* newname = 0); Copy constructor. RooDataHist(const char* name, const char* title, RooDataHist* h, const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t copyCache); Constructor of a data hist from (part of) an existing data hist. The dimensions; of the data set are defined by the 'vars' RooArgSet, which can be identical; to 'dset' dimensions, or a subset thereof. Reduced dimensions will be projected; in the output data hist. The optional 'cutVar' formula variable can used to; select the subset of bins to be copied. For most uses the RooAbsData::reduce() wrapper function, which uses this constructor,; is the most convenient way to create a subset of an existing data. RooAbsData* cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDataHist.html:25420,allocate,allocate,25420,root/html528/RooDataHist.html,https://root.cern,https://root.cern/root/html528/RooDataHist.html,3,['allocate'],['allocate']
Energy Efficiency,"p, Double_t initWgt, Bool_t doDensityCorrection); Import data from given set of TH1/2/3 into this RooDataHist. The category indexCat labels the sources; in the constructed RooDataHist. The stl map provides the mapping between the indexCat state labels; and the import source. void importDHistSet(const RooArgList& vars, RooCategory& indexCat, map<std::string,RooDataHist*> dmap, Double_t initWgt); Import data from given set of TH1/2/3 into this RooDataHist. The category indexCat labels the sources; in the constructed RooDataHist. The stl map provides the mapping between the indexCat state labels; and the import source. void adjustBinning(const RooArgList& vars, TH1& href, Int_t* offset = 0); Adjust binning specification on first and optionally second and third; observable to binning in given reference TH1. Used by constructors; that import data from an external TH1. void initialize(const char* binningName = 0, Bool_t fillTree = kTRUE); Initialization procedure: allocate weights array, calculate; multipliers needed for N-space to 1-dim array jump table,; and fill the internal tree with all bin center coordinates. void checkBinBounds() const. RooDataHist(const RooDataHist& other, const char* newname = 0); Copy constructor. RooDataHist(const char* name, const char* title, RooDataHist* h, const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t copyCache); Constructor of a data hist from (part of) an existing data hist. The dimensions; of the data set are defined by the 'vars' RooArgSet, which can be identical; to 'dset' dimensions, or a subset thereof. Reduced dimensions will be projected; in the output data hist. The optional 'cutVar' formula variable can used to; select the subset of bins to be copied. For most uses the RooAbsData::reduce() wrapper function, which uses this constructor,; is the most convenient way to create a subset of an existing data. RooAbsData* cacheClone(const RooAbsArg* newCacheOwner, const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataHist.html:26853,allocate,allocate,26853,root/html534/RooDataHist.html,https://root.cern,https://root.cern/root/html534/RooDataHist.html,1,['allocate'],['allocate']
Energy Efficiency,"p->SetWindowSize(ww, wh);; 2182}; 2183 ; 2184////////////////////////////////////////////////////////////////////////////////; 2185/// Set the canvas scale in centimeters.; 2186///; 2187/// This information is used by PostScript to set the page size.; 2188///; 2189/// \param[in] xsize size of the canvas in centimeters along X; 2190/// \param[in] ysize size of the canvas in centimeters along Y; 2191///; 2192/// if xsize and ysize are not equal to 0, then the scale factors will; 2193/// be computed to keep the ratio ysize/xsize independently of the canvas; 2194/// size (parts of the physical canvas will be unused).; 2195///; 2196/// if xsize = 0 and ysize is not zero, then xsize will be computed; 2197/// to fit to the current canvas scale. If the canvas is resized,; 2198/// a new value for xsize will be recomputed. In this case the aspect; 2199/// ratio is not preserved.; 2200///; 2201/// if both xsize = 0 and ysize = 0, then the scaling is automatic.; 2202/// the largest dimension will be allocated a size of 20 centimeters.; 2203 ; 2204void TCanvas::Size(Float_t xsize, Float_t ysize); 2205{; 2206 fXsizeUser = xsize;; 2207 fYsizeUser = ysize;; 2208 ; 2209 Resize();; 2210}; 2211 ; 2212////////////////////////////////////////////////////////////////////////////////; 2213/// Show canvas; 2214 ; 2215void TCanvas::Show(); 2216{; 2217 if (fCanvasImp); 2218 fCanvasImp->Show();; 2219}; 2220 ; 2221////////////////////////////////////////////////////////////////////////////////; 2222/// Stream a class object.; 2223 ; 2224void TCanvas::Streamer(TBuffer &b); 2225{; 2226 UInt_t R__s, R__c;; 2227 if (b.IsReading()) {; 2228 Version_t v = b.ReadVersion(&R__s, &R__c);; 2229 gPad = this;; 2230 fCanvas = this;; 2231 if (v>7) b.ClassBegin(TCanvas::IsA());; 2232 if (v>7) b.ClassMember(""TPad"");; 2233 TPad::Streamer(b);; 2234 gPad = this;; 2235 //restore the colors; 2236 auto colors = dynamic_cast<TObjArray *>(fPrimitives->FindObject(""ListOfColors""));; 2237 if (colors) {; 2238 auto root_colo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:70554,allocate,allocated,70554,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"p.step = 0.1;; gstep.destep = 0;; gstep.nmec = 0;; gstep.pid = 0;. //transport particles; for (Int_t i=0; i<10000; i++) {; //generate a new particle if necessary (Geant3 emulation); if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1;; if (gRandom->Rndm() < 0.5) charge = -1;; gstep.pid += 1;; gstep.vect[0] = 0;; gstep.vect[1] = 0;; gstep.vect[2] = 0;; gstep.vect[3] = px/p;; gstep.vect[4] = py/p;; gstep.vect[5] = pz/p;; gstep.vect[6] = p*charge;; gstep.getot = TMath::Sqrt(p*p + mass*mass);; gstep.gekin = gstep.getot - mass;; newParticle = kFALSE;; }; // fill the Tree with current step parameters; t2.Fill();. //transport particle in magnetic field (Geant3 emulation); helixStep(gstep.step, gstep.vect, vout);; //make one step; //apply energy loss; gstep.destep = gstep.step*gRandom->Gaus(0.0002,0.00001);; gstep.gekin -= gstep.destep;; gstep.getot = gstep.gekin + mass;; gstep.vect[6]= charge*TMath::Sqrt(gstep.getot*gstep.getot; - mass*mass);; gstep.vect[0] = vout[0];; gstep.vect[1] = vout[1];; gstep.vect[2] = vout[2];; gstep.vect[3] = vout[3];; gstep.vect[4] = vout[4];; gstep.vect[5] = vout[5];; gstep.nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0; l<gstep.nmec; l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) newParticle = kTRUE;; }; //save the Tree header. The file will be automatically; // closed when going out of the function scope; t2.Write();; }; 12.15.1.1 Adding a Branch with a Fixed Length Array; At first, we create a tree and create branches for a subset of variables in the C structureGctrak_t. Then we add several types of branches. The first branch reads seven floating-point values beginning at the address of 'gstep.vect'. You do not need to specify &gstep.vect, because in C and C++ the array variable holds the address of the first element.; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:564327,charge,charge,564327,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['charge'],['charge']
Energy Efficiency,"p: A += A * B ) More...;  ; class  Polar2D;  Class describing a polar 2D coordinate system based on r and phi Phi is restricted to be in the range [-PI,PI) More...;  ; class  Polar3D;  Class describing a polar coordinate system based on r, theta and phi Phi is restricted to be in the range [-PI,PI) More...;  ; class  Polynomial;  Parametric Function class describing polynomials of order n. More...;  ; class  PositionVector2D;  Class describing a generic position vector (point) in 2 dimensions. More...;  ; class  PositionVector3D;  Class describing a generic position vector (point) in 3 dimensions. More...;  ; class  PtEtaPhiE4D;  Class describing a 4D cylindrical coordinate system using Pt , Phi, Eta and E (or rho, phi, eta , T) The metric used is (-,-,-,+). More...;  ; class  PtEtaPhiM4D;  Class describing a 4D cylindrical coordinate system using Pt , Phi, Eta and M (mass) The metric used is (-,-,-,+). More...;  ; class  PxPyPzE4D;  Class describing a 4D cartesian coordinate system (x, y, z, t coordinates) or momentum-energy vectors stored as (Px, Py, Pz, E). More...;  ; class  PxPyPzM4D;  Class describing a 4D coordinate system or momentum-energy vectors stored as (Px, Py, Pz, M). More...;  ; class  QuasiRandom;  User class for MathMore random numbers template on the Engine type. More...;  ; class  Quaternion;  Rotation class with the (3D) rotation represented by a unit quaternion (u, i, j, k). More...;  ; class  Random;  Documentation for the Random class. More...;  ; class  RandomFunctions;  ; class  RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >;  Specialized implementation of the Random functions based on the GSL library. More...;  ; class  RandomFunctionsImpl;  Definition of the generic implementation class for the RandomFunctions. More...;  ; class  RandomFunctionsImpl< TRandomEngine >;  Implementation class for the RandomFunction for all the engined that derives from TRandomEngine class, which defines an interface which has TRandomEngine::Rndm()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:26574,energy,energy,26574,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['energy'],['energy']
Energy Efficiency,"p; vector<vector<Double_t> >*_weights!; vector<vector<Double_t> >_weights0; vector<vector<Double_t> >_weights1; Double_t_widthFactor; vector<Double_t>_x; vector<Double_t>_x0; vector<Double_t>_x1; vector<Double_t>_x2; vector<Double_t>_xDatHi; vector<Double_t>_xDatHi3s; vector<Double_t>_xDatLo; vector<Double_t>_xDatLo3s; vector<Double_t>_xVarHi; vector<Double_t>_xVarHiM3s; vector<Double_t>_xVarHiP3s; vector<Double_t>_xVarLo; vector<Double_t>_xVarLoM3s; vector<Double_t>_xVarLoP3s; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNDKeysPdf(const char* name, const char* title, const RooArgList& varList, RooDataSet& data, TString options = ""a"", Double_t rho = 1, Double_t nSigma = 3, Bool_t rotate = kTRUE); Construct N-dimensional kernel estimation p.d.f. in observables 'varList'; from dataset 'data'. Options can be. 'a' = Use adaptive kernels (width varies with local event density); 'm' = Mirror data points over observable boundaries. Improves modeling; behavior at edges for distributions that are not close to zero; at edge; 'd' = Debug flag; 'v' = Verbose flag. The parameter rho (default = 1) provides an overall scale factor that can; be applied to the bandwith calculated for each kernel. The nSigma parameter; determines the size of the box that is used to search for contributing kernels; around a given point in observable space. The nSigma parameters is used; in case of non-adaptive bandwidths and for the 1st non-adaptive pass for; the calculation of adaptive keys p.d.f.s. The optional weight arguments allows to specify an observable or function; expression in observables that specifies the weight of each event. RooNDKeysPdf(const char* name, const char* title, RooAbsReal& x, RooDataSet& data, RooNDKeysPdf::Mirror mirror = NoMirror, Double_t rho = 1, Double_t nSigma = 3, Bool_t rotate = kTRUE); Backward compatibility constructor for (1-dim) RooKeysPdf. I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNDKeysPdf.html:43543,adapt,adaptive,43543,root/html528/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html528/RooNDKeysPdf.html,3,['adapt'],['adaptive']
Energy Efficiency,"p; vector<vector<Double_t> >*_weights!; vector<vector<Double_t> >_weights0; vector<vector<Double_t> >_weights1; Double_t_widthFactor; vector<Double_t>_x; vector<Double_t>_x0; vector<Double_t>_x1; vector<Double_t>_x2; vector<Double_t>_xDatHi; vector<Double_t>_xDatHi3s; vector<Double_t>_xDatLo; vector<Double_t>_xDatLo3s; vector<Double_t>_xVarHi; vector<Double_t>_xVarHiM3s; vector<Double_t>_xVarHiP3s; vector<Double_t>_xVarLo; vector<Double_t>_xVarLoM3s; vector<Double_t>_xVarLoP3s; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNDKeysPdf(const char* name, const char* title, const RooArgList& varList, RooDataSet& data, TString options = ""a"", Double_t rho = 1, Double_t nSigma = 3, Bool_t rotate = kTRUE); Construct N-dimensional kernel estimation p.d.f. in observables 'varList'; from dataset 'data'. Options can be. 'a' = Use adaptive kernels (width varies with local event density); 'm' = Mirror data points over observable boundaries. Improves modeling; behavior at edges for distributions that are not close to zero; at edge; 'd' = Debug flag; 'v' = Verbose flag. The parameter rho (default = 1) provides an overall scale factor that can; be applied to the bandwith calculated for each kernel. The nSigma parameter; determines the size of the box that is used to search for contributing kernels; around a given point in observable space. The nSigma parameters is used; in case of non-adaptive bandwidths and for the 1st non-adaptive pass for; the calculation of adaptive keys p.d.f.s. The optional weight arguments allows to specify an observable or function; expression in observables that specifies the weight of each event. RooNDKeysPdf(const char* name, const char* title, const RooArgList& varList, RooDataSet& data, const TVectorD& rho, TString options = ""a"", Double_t nSigma = 3, Bool_t rotate = kTRUE); Constructor. RooNDKeysPdf(const char* name, const char* title,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNDKeysPdf.html:48995,adapt,adaptive,48995,root/html602/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html602/RooNDKeysPdf.html,2,['adapt'],['adaptive']
Energy Efficiency,"pRef ; (; const char * ; branchname, . TClass * ; ptrClass, . EDataType ; datatype, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Same as TTree::Branch but automatic detection of the class name. ; See alsoTTree::Branch for other details. ; Definition at line 1695 of file TTree.cxx. ◆ BranchOld(). TBranch * TTree::BranchOld ; (; const char * ; name, . const char * ; classname, . void * ; addobj, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 1 . ). virtual . Create a new TTree BranchObject. ; Build a TBranchObject for an object of class classname. addobj is the address of a pointer to an object of class classname. IMPORTANT: classname must derive from TObject. The class dictionary must be available (ClassDef in class header).; This option requires access to the library where the corresponding class is defined. Accessing one single data member in the object implies reading the full object. See the next Branch constructor for a more efficient storage in case the entry consists of arrays of identical objects.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file; IMPORTANT NOTE about branch names:; And in general, in case two or more master branches contain subbranches with identical names, one must add a ""."" (dot) character at the end of the master branch name. This will force the name of the subbranches to be of the form master.subbranch instead of simply subbranch. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches B1 and B2 corresponding to objects of the same class MyClass, one can do: tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; bufsize is the buffer size in bytes for this branch The default value is 32000 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:93040,efficient,efficient,93040,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['efficient'],['efficient']
Energy Efficiency,"pan< const double > getWeightBatch (std::size_t first, std::size_t len) const override;  Get the weights of the events in the range [first, first+len). ;  ; bool hasFilledCache () const override;  ; RooCategory * index ();  ; TClass * IsA () const override;  ; bool isWeighted () const override;  ; void loadValues (const RooAbsDataStore *tds, const RooFormulaVar *select=nullptr, const char *rangeName=nullptr, std::size_t nStart=0, std::size_t nStop=std::numeric_limits< std::size_t >::max()) override;  ; RooAbsDataStore * merge (const RooArgSet &allvars, std::list< RooAbsDataStore * > dstoreList) override;  ; Int_t numEntries () const override;  ; void recalculateCache (const RooArgSet *, Int_t, Int_t, Int_t, bool) override;  Forward recalculate request to all subsets. ;  ; std::unique_ptr< RooAbsDataStore > reduce (RooStringView name, RooStringView title, const RooArgSet &vars, const RooFormulaVar *cutVar, const char *cutRange, std::size_t nStart, std::size_t nStop) override;  ; void reset () override;  ; void resetBuffers () override;  ; void resetCache () override;  ; void setArgStatus (const RooArgSet &set, bool active) override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; double sumEntries () const override;  Forward fill request to appropriate subset. ;  ; double weight () const override;  ; virtual double weight () const=0;  ; double weight (Int_t index) const;  ; void weightError (double &lo, double &hi, RooAbsData::ErrorType etype=RooAbsData::Poisson) const override;  ; double weightError (RooAbsData::ErrorType etype=RooAbsData::Poisson) const override;  ;  Public Member Functions inherited from RooAbsDataStore;  RooAbsDataStore ();  ;  RooAbsDataStore (const RooAbsDataStore &other, const char *newname=nullptr);  ;  RooAbsDataStore (const RooAbsDataStore &other, const RooArgSet &vars, const char *newname=nullptr);  ;  RooAbsDataStore (RooStringView name, RooStr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCompositeDataStore.html:3816,reduce,reduce,3816,doc/master/classRooCompositeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooCompositeDataStore.html,1,['reduce'],['reduce']
Energy Efficiency,"param[in] epsabs Specified absolute accuracy.; 2822/// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; 2823/// In case the maximum function called is reached the algorithm will stop earlier without having reached; 2824/// the desired accuracy; 2825///; 2826/// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; 2827/// \param[out] nfnevl number of function evaluations performed.; 2828/// \param[out] ifail; 2829/// \parblock; 2830/// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; 2831///; 2832/// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; 2833/// specified value of maxpts.; 2834///; 2835/// 3 n<2 or n>15; 2836/// \endparblock; 2837///; 2838/// Method:; 2839///; 2840/// The default method used is the Genz-Mallik adaptive multidimensional algorithm; 2841/// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); 2842///; 2843/// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); 2844/// to different integrators.; 2845/// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; 2846/// Possible methods are : Vegas, Miser or Plain; 2847/// IN case of MC integration the accuracy is determined by the number of function calls, one should be; 2848/// careful not to use a too large value of maxpts; 2849///; 2850 ; 2851Double_t TF1::IntegralMultiple(Int_t n, const Double_t *a, const Double_t *b, Int_t maxpts, Double_t epsrel, Double_t epsabs, Double_t &relerr, Int_t &nfnevl, Int_t &ifail); 2852{; 2853 ROOT::Math::WrappedMultiFunction<TF1 &> wf1(*this, n);; 2854 ; 2855 double result = 0;; 2856 if (epsrel <= 0) epsrel = ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerance();; 2857 if (epsabs <= 0) epsabs = ROOT::Math::IntegratorMultiDimOptions:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:108202,adapt,adaptive,108202,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['adapt'],['adaptive']
Energy Efficiency,"parameter for 2D peaks (relative amplitude of tail), for details see html manual and references; Double_tfTyCalccalculated value of t parameter for 1D ridges in y direction; Double_tfTyErrerror value of t parameter for 1D ridges in y direction; Double_tfTyInitinitial value of t parameter for 1D ridges in y direction (relative amplitude of tail), for details see html manual and references; Double_t*fVolume[fNPeaks] array of calculated volumes of 2D peaks, output parameters; Double_t*fVolumeErr[fNPeaks] array of volumes errors of 2D peaks, output parameters; Int_tfXmaxlast fitted channel in x direction; Int_tfXminfirst fitted channel in x direction; Int_tfYmaxlast fitted channel in y direction; Int_tfYminfirst fitted channel in y direction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSpectrum2Fit(); default constructor. TSpectrum2Fit(Int_t numberPeaks); numberPeaks: number of fitted peaks (must be greater than zero); the constructor allocates arrays for all fitted parameters (peak positions, amplitudes etc) and sets the member; variables to their default values. One can change these variables by member functions (setters) of TSpectrumFit class. . Shape function of the fitted; peaks contains the two-dimensional symmetrical Gaussian two one-dimensional; symmetrical Gaussian ridges as well as nonsymmetrical terms and background. ~TSpectrum2Fit(); destructor. Double_t Erfc(Double_t x). AUXILIARY FUNCTION. This function calculates error function of x. Double_t Derfc(Double_t x). AUXILIARY FUNCTION. This function calculates derivative of error function of x. Double_t Ourpowl(Double_t a, Int_t pw); power function. void StiefelInversion(Double_t** a, Int_t size). AUXILIARY FUNCTION. This function calculates solution of the system of linear equations.; The matrix a should have a dimension size*(size+4); The calling function should fill in the matrix, the column size should; contain vector y (right side of the system of equations).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Fit.html:22190,allocate,allocates,22190,root/html528/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html,4,['allocate'],['allocates']
Energy Efficiency,"parameters. void Reset(Option_t* option = """"); Reset a branch. Existing buffers are deleted.; Entries, max and min are reset. void SetAddress(void* addobj); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the AutoDelete bit. This function can be used to instruct Root in TBranchObject::ReadBasket; to not delete the object referenced by a branchobject before reading a; new entry. By default, the object is deleted.; If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then object->Streamer called.; If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; This can be done in Streamer itself.; If this branch has sub-branches, the function sets autodel for these; branches as well.; We STRONGLY suggest to activate this option by default when you create; the top level branch. This will make the read phase more efficient; because it minimizes the numbers of new/delete operations.; Once this option has been set and the Tree is written to a file, it is; not necessary to specify the option again when reading, unless you; want to set the opposite mode. void SetBasketSize(Int_t buffsize); Reset basket size for all subbranches of this branch. void Streamer(TBuffer& b); Stream an object of class TBranchObject. void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void UpdateAddress(); Update branch addresses if a new object was created. const char* GetClassName() const; { return fClassName.Data(); }. const char* GetObjClassName(); { return fClassName.Data(); }. » Author: Rene Brun 11/02/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchObject.h 37168 2010-12-02 02:34:55Z pcanal $ » Last generated: 2010-12-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBranchObject.html:15058,efficient,efficient,15058,root/html528/TBranchObject.html,https://root.cern,https://root.cern/root/html528/TBranchObject.html,1,['efficient'],['efficient']
Energy Efficiency,"parameters. void Reset(Option_t* option = """"); Reset a branch. Existing buffers are deleted.; Entries, max and min are reset. void SetAddress(void* addobj); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the AutoDelete bit. This function can be used to instruct Root in TBranchObject::ReadBasket; to not delete the object referenced by a branchobject before reading a; new entry. By default, the object is deleted.; If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then object->Streamer called.; If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; This can be done in Streamer itself.; If this branch has sub-branches, the function sets autodel for these; branches as well.; We STRONGLY suggest to activate this option by default when you create; the top level branch. This will make the read phase more efficient; because it minimizes the numbers of new/delete operations.; Once this option has been set and the Tree is written to a file, it is; not necessary to specify the option again when reading, unless you; want to set the opposite mode. void SetBasketSize(Int_t buffsize); Reset basket size for all subbranches of this branch. void Streamer(TBuffer& b); Stream an object of class TBranchObject. void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void UpdateAddress(); Update branch addresses if a new object was created. const char* GetClassName() const; { return fClassName.Data(); }. const char* GetObjClassName(); { return fClassName.Data(); }. » Author: Rene Brun 11/02/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchObject.h 39635 2011-06-09 15:37:27Z pcanal $ » Last generated: 2011-07-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBranchObject.html:16061,efficient,efficient,16061,root/html530/TBranchObject.html,https://root.cern,https://root.cern/root/html530/TBranchObject.html,1,['efficient'],['efficient']
Energy Efficiency,"parse (const TMatrixTSparse< Element > &a, EMatrixCreatorsOp2 op, const TMatrixT< Element > &b);  Create a matrix applying a specific operation to two prototypes. ;  ;  TMatrixTSparse (const TMatrixTSparse< Element > &a, EMatrixCreatorsOp2 op, const TMatrixTSparse< Element > &b);  Create a matrix applying a specific operation to two prototypes. ;  ;  TMatrixTSparse (const TMatrixTSparse< Element > &another);  ;  TMatrixTSparse (EMatrixCreatorsOp1 op, const TMatrixTSparse< Element > &prototype);  Create a matrix applying a specific operation to the prototype. ;  ;  TMatrixTSparse (Int_t nrows, Int_t ncols);  Space is allocated for row/column indices and data, but the sparse structure information has still to be set ! ;  ;  TMatrixTSparse (Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t *rowptr, Int_t *col, Element *data);  Space is allocated for row/column indices and data. ;  ;  TMatrixTSparse (Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros, Int_t *row, Int_t *col, Element *data);  Space is allocated for row/column indices and data. ;  ;  TMatrixTSparse (Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros=0);  Space is allocated for row/column indices and data, but the sparse structure information has still to be set ! ;  ;  ~TMatrixTSparse () override;  ; TClass * Class ();  ; void Clear (Option_t *="""") override;  ; Element ColNorm () const override;  Column matrix norm, MAX{ SUM{ |M(i,j)|, over i}, over j}. ;  ; void ExtractRow (Int_t row, Int_t col, Element *v, Int_t n=-1) const override;  Store in array v, n matrix elements of row rown starting at column coln. ;  ; const Int_t * GetColIndexArray () const override;  ; Int_t * GetColIndexArray () override;  ; void GetMatrix2Array (Element *data, Option_t *="""") const override;  Copy matrix data to array . It is assumed that array is of size >= fNelems. ;  ; const Element * GetMatrixArray () const override;  ; Element * GetMatrixArray () over",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixTSparse.html:6685,allocate,allocated,6685,doc/master/classTMatrixTSparse.html,https://root.cern,https://root.cern/doc/master/classTMatrixTSparse.html,1,['allocate'],['allocated']
Energy Efficiency,"parse::fBinsTExMap fBins! Filled binsDefinition THnSparse.h:42; THnSparse::GetBinLong64_t GetBin(const Double_t *x) const overrideDefinition THnSparse.h:97; THnSparse::CreateSparsestatic THnSparse * CreateSparse(const char *name, const char *title, const THnBase *hn, Int_t chunkSize=1024 *16)Definition THnSparse.h:82; THnSparse::ProjectionTHnSparse * Projection(Int_t ndim, const Int_t *dim, Option_t *option="""") constDefinition THnSparse.h:154; THnSparse::fBinsContinuedTExMap fBinsContinued! Filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1)Definition THnSparse.h:43; THnSparse::AddBinContentvoid AddBinContent(const Int_t *idx, Double_t v=1.)Forwards to THnBase::AddBinContent().Definition THnSparse.h:113; THnSparse::Reservevoid Reserve(Long64_t nbins) overrideInitialize storage for nbins.Definition THnSparse.cxx:689; THnSparse::fChunkSizeInt_t fChunkSizeNumber of entries for each chunk.Definition THnSparse.h:39; THnSparse::Sumw2void Sumw2() overrideEnable calculation of errors.Definition THnSparse.cxx:948; THnSparse::GetNbinsLong64_t GetNbins() const overrideDefinition THnSparse.h:93; THnSparse::CreateIterROOT::Internal::THnBaseBinIter * CreateIter(Bool_t respectAxisRange) const overrideCreate an iterator over all filled bins of a THnSparse.Definition THnSparse.cxx:896; THnSparse::SetFilledBinsvoid SetFilledBins(Long64_t nbins) overrideDefinition THnSparse.h:94; THnSparse::GetBinIndexForCurrentBinLong64_t GetBinIndexForCurrentBin(Bool_t allocate)Return the index for fCurrentBinIndex.Definition THnSparse.cxx:789; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; bool; double; int; xDouble_t x[n]Definition legend1.C:17; h1TH1F * h1Definition legend1.C:5; v@ vDefinition rootcling_impl.cxx:3699; groupDefinition TWinNTSystem.h:50. histhistincTHnSparse.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8h_source.html:18465,allocate,allocate,18465,doc/master/THnSparse_8h_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html,1,['allocate'],['allocate']
Energy Efficiency,"passes: on first pass, get required message; 6868 * length.; 6869 * On second pass, actually print the message. */; 6870 va_copy(ap_copy, ap);; 6871 len = vsnprintf_impl(NULL, 0, fmt, ap_copy);; 6872 va_end(ap_copy);; 6873 ; 6874 if (len < 0) {; 6875 /* C runtime is not standard compliant, vsnprintf() returned -1.; 6876 * Switch to alternative code path that uses incremental; 6877 * allocations.; 6878 */; 6879 va_copy(ap_copy, ap);; 6880 len = alloc_vprintf2(out_buf, fmt, ap_copy);; 6881 va_end(ap_copy);; 6882 ; 6883 } else if ((size_t)(len) >= prealloc_size) {; 6884 /* The pre-allocated buffer not large enough. */; 6885 /* Allocate a new buffer. */; 6886 *out_buf = (char *)mg_malloc((size_t)(len) + 1);; 6887 if (!*out_buf) {; 6888 /* Allocation failed. Return -1 as ""out of memory"" error. */; 6889 return -1;; 6890 }; 6891 /* Buffer allocation successful. Store the string there. */; 6892 va_copy(ap_copy, ap);; 6893 IGNORE_UNUSED_RESULT(; 6894 vsnprintf_impl(*out_buf, (size_t)(len) + 1, fmt, ap_copy));; 6895 va_end(ap_copy);; 6896 ; 6897 } else {; 6898 /* The pre-allocated buffer is large enough.; 6899 * Use it to store the string and return the address. */; 6900 va_copy(ap_copy, ap);; 6901 IGNORE_UNUSED_RESULT(; 6902 vsnprintf_impl(prealloc_buf, prealloc_size, fmt, ap_copy));; 6903 va_end(ap_copy);; 6904 *out_buf = prealloc_buf;; 6905 }; 6906 ; 6907 return len;; 6908}; 6909 ; 6910 ; 6911#if defined(GCC_DIAGNOSTIC); 6912/* Enable format-nonliteral warning again. */; 6913#pragma GCC diagnostic pop; 6914#endif; 6915 ; 6916 ; 6917static int; 6918mg_vprintf(struct mg_connection *conn, const char *fmt, va_list ap); 6919{; 6920 char mem[MG_BUF_LEN];; 6921 char *buf = NULL;; 6922 int len;; 6923 ; 6924 if ((len = alloc_vprintf(&buf, mem, sizeof(mem), fmt, ap)) > 0) {; 6925 len = mg_write(conn, buf, (size_t)len);; 6926 }; 6927 if (buf != mem) {; 6928 mg_free(buf);; 6929 }; 6930 ; 6931 return len;; 6932}; 6933 ; 6934 ; 6935int; 6936mg_printf(struct mg_connection *conn, const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:199764,allocate,allocated,199764,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['allocate'],['allocated']
Energy Efficiency,"passes: on first pass, get required message; 6869 * length.; 6870 * On second pass, actually print the message. */; 6871 va_copy(ap_copy, ap);; 6872 len = vsnprintf_impl(NULL, 0, fmt, ap_copy);; 6873 va_end(ap_copy);; 6874 ; 6875 if (len < 0) {; 6876 /* C runtime is not standard compliant, vsnprintf() returned -1.; 6877 * Switch to alternative code path that uses incremental; 6878 * allocations.; 6879 */; 6880 va_copy(ap_copy, ap);; 6881 len = alloc_vprintf2(out_buf, fmt, ap_copy);; 6882 va_end(ap_copy);; 6883 ; 6884 } else if ((size_t)(len) >= prealloc_size) {; 6885 /* The pre-allocated buffer not large enough. */; 6886 /* Allocate a new buffer. */; 6887 *out_buf = (char *)mg_malloc((size_t)(len) + 1);; 6888 if (!*out_buf) {; 6889 /* Allocation failed. Return -1 as ""out of memory"" error. */; 6890 return -1;; 6891 }; 6892 /* Buffer allocation successful. Store the string there. */; 6893 va_copy(ap_copy, ap);; 6894 IGNORE_UNUSED_RESULT(; 6895 vsnprintf_impl(*out_buf, (size_t)(len) + 1, fmt, ap_copy));; 6896 va_end(ap_copy);; 6897 ; 6898 } else {; 6899 /* The pre-allocated buffer is large enough.; 6900 * Use it to store the string and return the address. */; 6901 va_copy(ap_copy, ap);; 6902 IGNORE_UNUSED_RESULT(; 6903 vsnprintf_impl(prealloc_buf, prealloc_size, fmt, ap_copy));; 6904 va_end(ap_copy);; 6905 *out_buf = prealloc_buf;; 6906 }; 6907 ; 6908 return len;; 6909}; 6910 ; 6911 ; 6912#if defined(GCC_DIAGNOSTIC); 6913/* Enable format-nonliteral warning again. */; 6914#pragma GCC diagnostic pop; 6915#endif; 6916 ; 6917 ; 6918static int; 6919mg_vprintf(struct mg_connection *conn, const char *fmt, va_list ap); 6920{; 6921 char mem[MG_BUF_LEN];; 6922 char *buf = NULL;; 6923 int len;; 6924 ; 6925 if ((len = alloc_vprintf(&buf, mem, sizeof(mem), fmt, ap)) > 0) {; 6926 len = mg_write(conn, buf, (size_t)len);; 6927 }; 6928 if (buf != mem) {; 6929 mg_free(buf);; 6930 }; 6931 ; 6932 return len;; 6933}; 6934 ; 6935 ; 6936int; 6937mg_printf(struct mg_connection *conn, const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:199796,allocate,allocated,199796,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['allocate'],['allocated']
Energy Efficiency,"pe = double> . Scalar ROOT::Math::PxPyPzM4D< ScalarType >::Mag ; (; ); const. inline . Definition at line 184 of file PxPyPzM4D.h. ◆ Mag2(). template<class ScalarType = double> . Scalar ROOT::Math::PxPyPzM4D< ScalarType >::Mag2 ; (; ); const. inline . Definition at line 182 of file PxPyPzM4D.h. ◆ Mt(). template<class ScalarType = double> . Scalar ROOT::Math::PxPyPzM4D< ScalarType >::Mt ; (; ); const. inline . transverse mass ; Definition at line 216 of file PxPyPzM4D.h. ◆ Mt2(). template<class ScalarType = double> . Scalar ROOT::Math::PxPyPzM4D< ScalarType >::Mt2 ; (; ); const. inline . transverse mass squared ; Definition at line 211 of file PxPyPzM4D.h. ◆ Negate(). template<class ScalarType = double> . void ROOT::Math::PxPyPzM4D< ScalarType >::Negate ; (; ). inline . negate the 4-vector - Note that the energy cannot be negate (would need an additional data member) therefore negate will work only on the spatial components. ; One would need to use negate only with vectors having the energy as data members ; Definition at line 305 of file PxPyPzM4D.h. ◆ operator!=(). template<class ScalarType = double> . bool ROOT::Math::PxPyPzM4D< ScalarType >::operator!= ; (; const PxPyPzM4D< ScalarType > & ; rhs); const. inline . Definition at line 329 of file PxPyPzM4D.h. ◆ operator=() [1/2]. template<class ScalarType = double> . template<class AnyCoordSystem > . PxPyPzM4D & ROOT::Math::PxPyPzM4D< ScalarType >::operator= ; (; const AnyCoordSystem & ; v). inline . construct from any 4D coordinate system class implementing X(), Y(), X() and M() ; Definition at line 107 of file PxPyPzM4D.h. ◆ operator=() [2/2]. template<class ScalarType = double> . PxPyPzM4D & ROOT::Math::PxPyPzM4D< ScalarType >::operator= ; (; const PxPyPzM4D< ScalarType > & ; v). inline . assignment operator ; Definition at line 93 of file PxPyPzM4D.h. ◆ operator==(). template<class ScalarType = double> . bool ROOT::Math::PxPyPzM4D< ScalarType >::operator== ; (; const PxPyPzM4D< ScalarType > & ; rhs); const. inline",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1PxPyPzM4D.html:8494,energy,energy,8494,doc/master/classROOT_1_1Math_1_1PxPyPzM4D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1PxPyPzM4D.html,1,['energy'],['energy']
Energy Efficiency,"pe. Double_t Derpa(Double_t sigma, Double_t t, Double_t b). AUXILIARY FUNCTION. This function calculates derivative of the area of peak; according to its amplitude.; Function parameters:; -sigma-sigma of peak; -t-relative amplitudes; -b-slope. Double_t Derpsigma(Double_t a, Double_t t, Double_t b). AUXILIARY FUNCTION. This function calculates derivative of the area of peak; according to sigma of peaks.; Function parameters:; -a-amplitude of peak; -t-relative amplitudes; -b-slope. Double_t Derpt(Double_t a, Double_t sigma, Double_t b). AUXILIARY FUNCTION. This function calculates derivative of the area of peak; according to t parameter.; Function parameters:; -sigma-sigma of peak; -t-relative amplitudes; -b-slope. Double_t Derpb(Double_t a, Double_t sigma, Double_t t, Double_t b). AUXILIARY FUNCTION. This function calculates derivative of the area of peak; according to b parameter.; Function parameters:; -sigma-sigma of peak; -t-relative amplitudes; -b-slope. Double_t Ourpowl(Double_t a, Int_t pw); power function. void FitAwmi(Double_t* source). ONE-DIMENSIONAL FIT FUNCTION; ALGORITHM WITHOUT MATRIX INVERSION; This function fits the source spectrum. The calling program should; fill in input parameters of the TSpectrumFit class; The fitted parameters are written into; TSpectrumFit class output parameters and fitted data are written into; source spectrum. Function parameters:; source-pointer to the vector of source spectrum. . Fitting; Goal: to estimate; simultaneously peak shape parameters in spectra with large number of peaks; �        ; peaks can be fitted separately, each peak (or multiplets) in a region or; together all peaks in a spectrum. To fit separately each peak one needs to; determine the fitted region. However it can happen that the regions of; neighboring peaks are overlapping. Then the results of fitting are very poor.; On the other hand, when fitting together all peaks found in a� spectrum, one; needs to have a method that is� stable (converges) and fas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrumFit.html:19926,power,power,19926,root/html602/TSpectrumFit.html,https://root.cern,https://root.cern/root/html602/TSpectrumFit.html,2,['power'],['power']
Energy Efficiency,"pe. Double_t Derpa(Double_t sigma, Double_t t, Double_t b). AUXILIARY FUNCTION. This function calculates derivative of the area of peak; according to its amplitude.; Function parameters:; -sigma-sigma of peak; -t-relative amplitudes; -b-slope. Double_t Derpsigma(Double_t a, Double_t t, Double_t b). AUXILIARY FUNCTION. This function calculates derivative of the area of peak; according to sigma of peaks.; Function parameters:; -a-amplitude of peak; -t-relative amplitudes; -b-slope. Double_t Derpt(Double_t a, Double_t sigma, Double_t b). AUXILIARY FUNCTION. This function calculates derivative of the area of peak; according to t parameter.; Function parameters:; -sigma-sigma of peak; -t-relative amplitudes; -b-slope. Double_t Derpb(Double_t a, Double_t sigma, Double_t t, Double_t b). AUXILIARY FUNCTION. This function calculates derivative of the area of peak; according to b parameter.; Function parameters:; -sigma-sigma of peak; -t-relative amplitudes; -b-slope. Double_t Ourpowl(Double_t a, Int_t pw); power function. void FitAwmi(float* source). ONE-DIMENSIONAL FIT FUNCTION; ALGORITHM WITHOUT MATRIX INVERSION; This function fits the source spectrum. The calling program should; fill in input parameters of the TSpectrumFit class; The fitted parameters are written into; TSpectrumFit class output parameters and fitted data are written into; source spectrum. Function parameters:; source-pointer to the vector of source spectrum. . Fitting; Goal: to estimate; simultaneously peak shape parameters in spectra with large number of peaks; �        ; peaks can be fitted separately, each peak (or multiplets) in a region or; together all peaks in a spectrum. To fit separately each peak one needs to; determine the fitted region. However it can happen that the regions of; neighboring peaks are overlapping. Then the results of fitting are very poor.; On the other hand, when fitting together all peaks found in a� spectrum, one; needs to have a method that is� stable (converges) and fast e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrumFit.html:18912,power,power,18912,root/html528/TSpectrumFit.html,https://root.cern,https://root.cern/root/html528/TSpectrumFit.html,4,['power'],['power']
Energy Efficiency,"pe. When performances are important, it is then recommended to use the NONADAPTIVE type in case of smooth functions or ADAPTIVE with a lower Gauss-Kronrod rule.; For detailed description on GSL integration algorithms see the GSL Manual. ; Definition at line 98 of file Integrator.h. Public Types; typedef IntegrationOneDim::Type Type;  . Public Member Functions;  IntegratorOneDim (const IGenFunction &f, IntegrationOneDim::Type type=IntegrationOneDim::kDEFAULT, double absTol=-1, double relTol=-1, unsigned int size=0, int rule=0);  Constructor of one dimensional Integrator passing a function interface. ;  ; template<class Function > ;  IntegratorOneDim (Function &f, IntegrationOneDim::Type type=IntegrationOneDim::kDEFAULT, double absTol=-1, double relTol=-1, unsigned int size=0, int rule=0);  Template Constructor of one dimensional Integrator passing a generic function object. ;  ;  IntegratorOneDim (IntegrationOneDim::Type type=IntegrationOneDim::kDEFAULT, double absTol=-1, double relTol=-1, unsigned int size=0, unsigned int rule=0);  Constructor of one dimensional Integrator, default type is adaptive. ;  ; virtual ~IntegratorOneDim ();  destructor (will delete contained pointers) ;  ; double Error () const;  return the estimate of the absolute Error of the last Integral calculation ;  ; VirtualIntegratorOneDim * GetIntegrator ();  return a pointer to integrator object ;  ; double Integral ();  evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with Integrator::SetFunction method. ;  ; double Integral (const IGenFunction &f);  evaluate the Integral of a function f over the infinite interval (-inf,+inf) ;  ; double Integral (const IGenFunction &f, const std::vector< double > &pts);  evaluate the Integral of a function f with known singular points over the defined Integral (a,b) ;  ; double Integral (const IGenFunction &f, double a, double b);  evaluate the Integral of a function f over the defined interval (a,b) ;  ; double Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html:2636,adapt,adaptive,2636,doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html,1,['adapt'],['adaptive']
Energy Efficiency,"pectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<const TMVA::Event*>& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName). void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*>& ). const Event* Transform(const TMVA::Event*const , Int_t cls) const. const Event* InverseTransform(const TMVA::Event*const , Int_t cls) const. void SetEnabled(Bool_t e); accessors. { fEnabled = e; }. void SetNormalise(Bool_t n); { fNormalise = n; }. Bool_t IsEnabled() const; { return fEnabled; }. Bool_t IsCreated() const; { return fCreated; }. Bool_t IsNormalised() const; { return fNormalise; }. vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__VariableTransformBase.html:10843,adapt,adapt,10843,root/html602/TMVA__VariableTransformBase.html,https://root.cern,https://root.cern/root/html602/TMVA__VariableTransformBase.html,2,['adapt'],['adapt']
Energy Efficiency,"pector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLFBO(); voidUnbind(); voidUnbindTexture(). protected:. UInt_tCreateAndAttachColorTexture(); UInt_tCreateAndAttachRenderBuffer(Int_t format, Int_t type); voidInitMultiSample(); voidInitStandard(). private:. TGLFBO&operator=(const TGLFBO&); TGLFBO(const TGLFBO&). Data Members; protected:. UInt_tfColorTexture; UInt_tfDepthBuffer; UInt_tfFrameBuffer; Int_tfH; Float_tfHScale; Bool_tfIsRescaled; UInt_tfMSColorBuffer; Int_tfMSCoverageSamples; UInt_tfMSFrameBuffer; Int_tfMSSamples; Int_tfReqH; Int_tfReqW; Int_tfW; Float_tfWScale; static Bool_tfgMultiSampleNAWarned; static Bool_tfgRescaleToPow2. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLFBO(); Constructor. ~TGLFBO(); Destructor. void Init(int w, int h, int ms_samples = 0); Acquire GL resources for given width, height and number of; multi-sampling samples. void Release(); Release the allocated GL resources. void Bind(); Bind the frame-buffer object. void Unbind(); Unbind the frame-buffer object. void BindTexture(); Bind texture. void UnbindTexture(); Unbind texture. void SetAsReadBuffer(). void InitStandard(). void InitMultiSample(). UInt_t CreateAndAttachRenderBuffer(Int_t format, Int_t type). UInt_t CreateAndAttachColorTexture(); Initialize color-texture and attach it to current FB. Bool_t GetRescaleToPow2(); Return state of fgRescaleToPow2 static member. void SetRescaleToPow2(Bool_t r); Set state of fgRescaleToPow2 static member.; Default is kTRUE as this works better on older hardware, especially ATI. TGLFBO(const TGLFBO& ). TGLFBO& operator=(const TGLFBO& ). Int_t GetW() const; { return fW; }. Int_t GetH() const; { return fH; }. Int_t GetReqW() const; { return fReqW; }. Int_t GetReqH() const; { return fReqH; }. Int_t GetMSSamples() const; { return fMSSamples; }. Int_t GetMSCoverageSamples() const; { return fMSCoverageSamples; }. Float_t GetWScale() const; {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLFBO.html:2032,allocate,allocated,2032,root/html604/TGLFBO.html,https://root.cern,https://root.cern/root/html604/TGLFBO.html,1,['allocate'],['allocated']
Energy Efficiency,"pectrum2Transform. class TSpectrum2Transform: public TObject. THIS CLASS CONTAINS 2-DIMENSIONAL ORTHOGONAL TRANSFORM FUNCTIONS. These functions were written by:; Miroslav Morhac; Institute of Physics; Slovak Academy of Sciences; Dubravska cesta 9, 842 28 BRATISLAVA; SLOVAKIA. email:fyzimiro@savba.sk, fax:+421 7 54772479. The original code in C has been repackaged as a C++ class by R.Brun. The algorithms in this class have been published in the following; references:. [1] C.V. Hampton, B. Lian, Wm. C. McHarris: Fast-Fourier-transform; spectral enhancement techniques for gamma-ray spectroscopy.NIM A353; (1994) 280-284.; [2] Morhac M., Matousek V., New adaptive Cosine-Walsh transform and; its application to nuclear data compression, IEEE Transactions on; Signal Processing 48 (2000) 2693.; [3] Morhac M., Matousek V., Data compression using new fast adaptive; Cosine-Haar transforms, Digital Signal Processing 8 (1998) 63.; [4] Morhac M., Matousek V.: Multidimensional nuclear data compression; using fast adaptive Walsh-Haar transform. Acta Physica Slovaca 51; (2001) 307. Function Members (Methods); public:. TSpectrum2Transform(); TSpectrum2Transform(const TSpectrum2Transform&); TSpectrum2Transform(Int_t sizeX, Int_t sizeY); virtual~TSpectrum2Transform(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Transform.html:1273,adapt,adaptive,1273,root/html528/TSpectrum2Transform.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Transform.html,4,['adapt'],['adaptive']
Energy Efficiency,"pectrum2Transform. class TSpectrum2Transform: public TObject. THIS CLASS CONTAINS 2-DIMENSIONAL ORTHOGONAL TRANSFORM FUNCTIONS. These functions were written by:; Miroslav Morhac; Institute of Physics; Slovak Academy of Sciences; Dubravska cesta 9, 842 28 BRATISLAVA; SLOVAKIA. email:fyzimiro@savba.sk, fax:+421 7 54772479. The original code in C has been repackaged as a C++ class by R.Brun. The algorithms in this class have been published in the following; references:. [1] C.V. Hampton, B. Lian, Wm. C. McHarris: Fast-Fourier-transform; spectral enhancement techniques for gamma-ray spectroscopy.NIM A353; (1994) 280-284.; [2] Morhac M., Matousek V., New adaptive Cosine-Walsh transform and; its application to nuclear data compression, IEEE Transactions on; Signal Processing 48 (2000) 2693.; [3] Morhac M., Matousek V., Data compression using new fast adaptive; Cosine-Haar transforms, Digital Signal Processing 8 (1998) 63.; [4] Morhac M., Matousek V.: Multidimensional nuclear data compression; using fast adaptive Walsh-Haar transform. Acta Physica Slovaca 51; (2001) 307. Function Members (Methods); public:. virtual~TSpectrum2Transform(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidEnhance(const Double_t** fSource, Double_t** fDest); virtual voidTObject::Error(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum2Transform.html:1297,adapt,adaptive,1297,root/html602/TSpectrum2Transform.html,https://root.cern,https://root.cern/root/html602/TSpectrum2Transform.html,2,['adapt'],['adaptive']
Energy Efficiency,"per; 3575 case 110:; 3576 {; 3577 Double_t red[9] = { 0./255., 25./255., 50./255., 79./255., 110./255., 145./255., 181./255., 201./255., 254./255.};; 3578 Double_t green[9] = { 0./255., 16./255., 30./255., 46./255., 63./255., 82./255., 101./255., 124./255., 179./255.};; 3579 Double_t blue[9] = { 0./255., 12./255., 21./255., 29./255., 39./255., 49./255., 61./255., 74./255., 103./255.};; 3580 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3581 }; 3582 break;; 3583 ; 3584 // Gist Earth; 3585 case 111:; 3586 {; 3587 Double_t red[9] = { 0./255., 13./255., 30./255., 44./255., 72./255., 120./255., 156./255., 200./255., 247./255.};; 3588 Double_t green[9] = { 0./255., 36./255., 84./255., 117./255., 141./255., 153./255., 151./255., 158./255., 247./255.};; 3589 Double_t blue[9] = { 0./255., 94./255., 100./255., 82./255., 56./255., 66./255., 76./255., 131./255., 247./255.};; 3590 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3591 }; 3592 break;; 3593 ; 3594 // Viridis; 3595 case 112:; 3596 {; 3597 Double_t red[9] = { 26./255., 51./255., 43./255., 33./255., 28./255., 35./255., 74./255., 144./255., 246./255.};; 3598 Double_t green[9] = { 9./255., 24./255., 55./255., 87./255., 118./255., 150./255., 180./255., 200./255., 222./255.};; 3599 Double_t blue[9] = { 30./255., 96./255., 112./255., 114./255., 112./255., 101./255., 72./255., 35./255., 0./255.};; 3600 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3601 }; 3602 break;; 3603 ; 3604 // Cividis; 3605 case 113:; 3606 {; 3607 Double_t red[9] = { 0./255., 5./255., 65./255., 97./255., 124./255., 156./255., 189./255., 224./255., 255./255.};; 3608 Double_t green[9] = { 32./255., 54./255., 77./255., 100./255., 123./255., 148./255., 175./255., 203./255., 234./255.};; 3609 Double_t blue[9] = { 77./255., 110./255., 107./255., 111./255., 120./255., 119./255., 111./255., 94./255., 70./255.};; 3610 Idx = TColor::CreateGradientColorTable(9, s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:143321,green,green,143321,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"per;  CTGDMLParseThis class contains the implementation of the GDML parser associated to all the supported GDML elements ;  CTGDMLReflThis class is a helper class for TGDMLParse ;  ►CTGDMLWriteThis class contains implementation of converting ROOT's gGeoManager geometry to GDML file ;  CNameLst;  CStructLst;  CXyz;  CTGDMMapHelper;  CTGDNDManager;  CTGDockableFrame;  CTGDockButton;  CTGDockHideButton;  CTGDoubleHSlider;  CTGDoubleSlider;  CTGDoubleVSlider;  CTGDragWindow;  CTGedEditor;  ►CTGedFrame;  CTGedSubFrame;  CTGedMarkerPopup;  CTGedMarkerSelect;  CTGedNameFrame;  CTGedPatternFrame;  CTGedPatternPopup;  CTGedPatternSelect;  CTGedPatternSelector;  CTGedPopup;  CTGedSelect;  ►CTGenCollectionProxyProxy around an arbitrary container, which implements basic functionality and iteration ;  CMethodSmall helper to execute (compiler) generated function for the access to STL or other containers ;  CMethod0;  CStreamHelperHelper class to facilitate I/O ;  CTStagingSmall helper to stage the content of an associative container when reading and before inserting it in the actual collection ;  CValueSmall helper to describe the Value_type or the key_type of an STL container ;  CTGenCollectionStreamer;  CTGeneratorThe interface to various event generators ;  ►CTGenericCollectionIterator;  CRegularIterator;  CVectorIterator;  ►CTGenericTable;  Citerator;  CTGenPhaseSpaceUtility class to generate n-body event, with constant cross-section (default) or with Fermi energy dependence (opt=""Fermi"") ;  CTGeoArb8An arbitrary trapezoid with less than 8 vertices standing on two parallel planes perpendicular to Z axis ;  CTGeoAttVisualization and tracking attributes for volumes and nodes ;  ►CTGeoBatemanSol;  CBtCoef_t;  CTGeoBBoxBox class ;  CTGeoBBoxEditorEditor for a TGeoBBox ;  ►CTGeoBoolNodeBase class for Boolean operations between two shapes ;  CThreadData_t;  CTGeoBranchArrayAn array of daughter indices making a geometry path ;  CTGeoBuilderUtility class for creating geometry objects.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:157118,energy,energy,157118,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,3,['energy'],['energy']
Energy Efficiency,"pera instead. Directories;  dictionary;  . Files;  basic.C;   Read data from an ascii file and create a root file with an histogram and an ntuple. ;  ;  basic2.C;   Create can ntuple reading data from an ascii file. ;  ;  bill.C;   Benchmark comparing row-wise and column-wise storage performance ;  ;  cernbuild.C;   Read data (CERN staff) from an ascii file and create a root file with a Tree. ;  ;  cernstaff.C;   Playing with a Tree containing variables of type character ;  ;  circular.C;   Example of a circular Tree ;  ;  clonesA_Event.C;  Example to write & read a Tree built with a complex class inheritance tree. ;  ;  clonesA_Event.cxx;  ;  clonesA_Event.h;  ;  copytree.C;   Copy a subset of a Tree to a new Tree ;  ;  copytree2.C;   Copy a subset of a Tree to a new Tree, one branch in a separate file. ;  ;  copytree3.C;   Example of Root macro to copy a subset of a Tree to a new Tree, selecting entries. ;  ;  drawsparse.C;   Convert a THnSparse to a TTree using efficient iteration through the THnSparse and draw a THnSparse using TParallelCoord. ;  ;  h1analysis.C;   Example of analysis class for the H1 data. ;  ;  h1analysis.h;  ;  h1analysisProxy.C;  Example of analysis class for the H1 data using code generated by MakeProxy. ;  ;  h1analysisProxy.h;  ;  h1analysisProxyCut.C;  ;  h1analysisTreeReader.C;  H1 analysis example expressed in terms of TTreeReader (see h1analysis.C). ;  ;  h1analysisTreeReader.h;  ;  h1chain.C;   Creates a TChain to be used by the h1analysis.C class the symbol H1 must point to a directory where the H1 data sets have been installed. ;  ;  hsimpleProxy.C;   Used by hsimpleProxyDriver.C. ;  ;  hsimpleProxyDriver.C;   This is the driver of the hsimpleProxy example. ;  ;  hsimpleReader.C;   TTreeReader simplest example. ;  ;  htest.C;   Save histograms in Tree branches ;  ;  hvector.C;   Write and read STL vectors in a tree. ;  ;  JetEvent.cxx;  ;  JetEvent.h;  ;  jets.C;  Usage of a Tree using the JetEvent class. ;  ;  ntuple1.C;   Simple ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html:1239,efficient,efficient,1239,doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html,https://root.cern,https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html,1,['efficient'],['efficient']
Energy Efficiency,"perator when comparing to another RooAbsArg.; Only functional when the other arg is a RooAbsReal. TString getTitle(Bool_t appendUnit = kFALSE) const; Return this variable's title string. If appendUnit is true and; this variable has units, also append a string "" (<unit>)"". Double_t getVal(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Int_t numEvalErrorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Implements the actual analy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsReal.html:33117,efficient,efficient,33117,root/html530/RooAbsReal.html,https://root.cern,https://root.cern/root/html530/RooAbsReal.html,1,['efficient'],['efficient']
Energy Efficiency,"performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; 995For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; 996Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; 997should be preferred for performance-critical applications.; 998 ; 999Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; 1000See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case.; 1001 ; 1002Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; 1003before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs.; 1004 ; 1005Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See [Activating RDataFrame execution logs](\ref rdf-logging).; 1006 ; 1007### Memory usage; 1008 ; 1009There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:57122,reduce,reduce,57122,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['reduce'],['reduce']
Energy Efficiency,"pha));; 691 } else {; 692 term1 = a * sig / (1.0 - n) * (1.0 / (std::pow(b - tmin, n - 1.0)) - 1.0 / (std::pow(n / absAlpha, n - 1.0)));; 693 }; 694 ; 695 double term2 = sig * sqrtPiOver2 * (approxErf(tmax / sqrt2) - approxErf(-absAlpha / sqrt2));; 696 ; 697 result += term1 + term2;; 698 }; 699 ; 700 if (result == 0); 701 return 1.E-300;; 702 return result;; 703}; 704 ; 705inline double bernsteinIntegral(double xlo, double xhi, double xmin, double xmax, double *coefs, int nCoefs); 706{; 707 double xloScaled = (xlo - xmin) / (xmax - xmin);; 708 double xhiScaled = (xhi - xmin) / (xmax - xmin);; 709 ; 710 int degree = nCoefs - 1; // n+1 polys of degree n; 711 double norm = 0.;; 712 ; 713 for (int i = 0; i <= degree; ++i) {; 714 // for each of the i Bernstein basis polynomials; 715 // represent it in the 'power basis' (the naive polynomial basis); 716 // where the integral is straight forward.; 717 double temp = 0.;; 718 for (int j = i; j <= degree; ++j) { // power basis≈ß; 719 double binCoefs = binomial(degree, j) * binomial(j, i);; 720 double oneOverJPlusOne = 1. / (j + 1.);; 721 double powDiff = std::pow(xhiScaled, j + 1.) - std::pow(xloScaled, j + 1.);; 722 temp += std::pow(-1., j - i) * binCoefs * powDiff * oneOverJPlusOne;; 723 }; 724 temp *= coefs[i]; // include coeff; 725 norm += temp; // add this basis's contribution to total; 726 }; 727 ; 728 return norm * (xmax - xmin);; 729}; 730 ; 731} // namespace MathFuncs; 732 ; 733} // namespace Detail; 734 ; 735} // namespace RooFit; 736 ; 737#endif; PdfFuncMathCore.h; ProbFuncMathCore.h; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; S0#define S0(x)Definition RSha256.hxx:88; S1#define S1(x)Definition RSha256.hxx:89; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; e#define e(i)Definition RSha256.hxx:103; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; resultOption_t Option_t TPoint TPoint const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MathFuncs_8h_source.html:23905,power,power,23905,doc/master/MathFuncs_8h_source.html,https://root.cern,https://root.cern/doc/master/MathFuncs_8h_source.html,1,['power'],['power']
Energy Efficiency,"plate<class ScalarType > . ROOT::Math::PtEtaPhiM4D< ScalarType >::PtEtaPhiM4D ; (; Scalar ; pt, . Scalar ; eta, . Scalar ; phi, . Scalar ; mass . ). inline . Constructor from pt, eta, phi, mass values. ; Definition at line 71 of file PtEtaPhiM4D.h. ◆ PtEtaPhiM4D() [3/4]. template<class ScalarType > . template<class CoordSystem > . constexpr ROOT::Math::PtEtaPhiM4D< ScalarType >::PtEtaPhiM4D ; (; const CoordSystem & ; c). inlineexplicitconstexpr . Generic constructor from any 4D coordinate system implementing Pt(), Eta(), Phi() and M() ; Definition at line 82 of file PtEtaPhiM4D.h. ◆ PtEtaPhiM4D() [4/4]. template<class ScalarType > . ROOT::Math::PtEtaPhiM4D< ScalarType >::PtEtaPhiM4D ; (; const PtEtaPhiM4D< ScalarType > & ; v). inline . copy constructor ; Definition at line 91 of file PtEtaPhiM4D.h. Member Function Documentation. ◆ E(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiM4D< ScalarType >::E ; (; ); const. inline . Energy (timelike component of momentum-energy 4-vector) ; Definition at line 198 of file PtEtaPhiM4D.h. ◆ E2(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiM4D< ScalarType >::E2 ; (; ); const. inline . energy squared ; Definition at line 189 of file PtEtaPhiM4D.h. ◆ Et(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiM4D< ScalarType >::Et ; (; ); const. inline . transverse energy ; Definition at line 250 of file PtEtaPhiM4D.h. ◆ Et2(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiM4D< ScalarType >::Et2 ; (; ); const. inline . transverse energy squared ; Definition at line 241 of file PtEtaPhiM4D.h. ◆ Eta(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiM4D< ScalarType >::Eta ; (; ); const. inline . Definition at line 142 of file PtEtaPhiM4D.h. ◆ GetCoordinates() [1/2]. template<class ScalarType > . void ROOT::Math::PtEtaPhiM4D< ScalarType >::GetCoordinates ; (; Scalar & ; pt, . Scalar & ; eta, . Scalar & ; phi, . Scalar & ; mass . ); const. inline . get internal data into 4 Scalar numbers",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1PtEtaPhiM4D.html:5978,energy,energy,5978,doc/master/classROOT_1_1Math_1_1PtEtaPhiM4D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1PtEtaPhiM4D.html,1,['energy'],['energy']
Energy Efficiency,"play help text; TRootIOCtor ; TRootSecContext Class providing host specific authentication information; TRootSniffer Sniffer of ROOT objects; TRootSnifferScanRec Scan record for objects sniffer; TRootSnifferStore structure for results store of objects sniffer; TRootSnifferStoreJson json results store of objects sniffer; TRootSnifferStoreXml xml results store of objects sniffer; TRotMatrix Rotation Matrix for 3-D geometry objects; TRotation Rotations of TVector3 objects; TS3HTTPRequest Create generic HTTP request for Amazon S3 and Google Storage services; TS3WebFile Read a ROOT file from a S3 server; TSAXParser SAX Parser; TSPHE SPHE shape; TSPlot class to disentangle signal from background; TSQLClassColumnInfo Keeps information about single column in class table; TSQLClassInfo Keeps the table information relevant for one class; TSQLColumnData Single SQL column data.; TSQLColumnInfo Summury information about column from SQL table; TSQLFile ROOT TFile interface to SQL database; TSQLMonitoringWriter Sending monitoring data to a SQL DB; TSQLObjectData Keeps the data requested from the SQL server for an object.; TSQLObjectDataPool XML object keeper class; TSQLObjectInfo Info (classname, version) about object in database; TSQLResult SQL query result; TSQLRow One row of an SQL query result; TSQLServer Connection to SQL server; TSQLStatement SQL statement; TSQLStructure Table/structure description used internally by YBufferSQL.; TSQLTableData Collection of columns data for single SQL table; TSQLTableInfo Summury information about SQL table; TSSLSocket ; TSVDUnfold Data unfolding using Singular Value Decomposition (hep-ph/9509307); TSVG SVG driver; TSecContext Class providing host specific authentication information; TSecContextCleanup Update the remote authentication table; TSelVerifyDataSet PROOF selector for parallel dataset verification; TSelector A utility class for tree and object processing; TSelectorCint A utility class for tree and object processing (interpreted vers",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:123858,monitor,monitoring,123858,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,2,['monitor'],['monitoring']
Energy Efficiency,"playCreationvoid ReplayCreation(const TGeoVolume *other)Recreate the content of the other volume without pointer copying.Definition TGeoVolume.cxx:1292; TGeoVolume::WeightDouble_t Weight(Double_t precision=0.01, Option_t *option=""va"")Estimate the weight of a volume (in kg) with SIGMA(M)/M better than PRECISION.Definition TGeoVolume.cxx:2501; TGeoVolume::fNumberInt_t fNumberoption - if anyDefinition TGeoVolume.h:55; TGeoVolume::CreateThreadDatavirtual void CreateThreadData(Int_t nthreads)Definition TGeoVolume.cxx:435; TGeoVolume::GetByteCountvirtual Int_t GetByteCount() constget the total size in bytes for this volumeDefinition TGeoVolume.cxx:2204; TGeoVolume::ContainsBool_t Contains(const Double_t *point) constDefinition TGeoVolume.h:104; TGeoVolume::AddNodevirtual TGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:975; TGeoVolume::OptimizeVoxelsBool_t OptimizeVoxels()Perform an extensive sampling to find which type of voxelization is most efficient.Definition TGeoVolume.cxx:1247; TGeoVolume::Browsevoid Browse(TBrowser *b) overrideHow to browse a volume.Definition TGeoVolume.cxx:535; TGeoVolume::SetCylVoxelsvoid SetCylVoxels(Bool_t flag=kTRUE)Definition TGeoVolume.h:218; TGeoVolume::SetCurrentPointvoid SetCurrentPoint(Double_t x, Double_t y, Double_t z)Set the current tracking point.Definition TGeoVolume.cxx:2059; TGeoVolume::Paintvoid Paint(Option_t *option="""") overridepaint volumeDefinition TGeoVolume.cxx:1267; TGeoVolume::SetVisOnlyvoid SetVisOnly(Bool_t flag=kTRUE) overrideSet visibility for leaves.Definition TGeoVolume.cxx:2393; TGeoVolume::fGeoManagerTGeoManager * fGeoManagerDefinition TGeoVolume.h:51; TGeoVolume::LegoPlotTH2F * LegoPlot(Int_t ntheta=20, Double_t themin=0., Double_t themax=180., Int_t nphi=60, Double_t phimin=0., Double_t phimax=360., Double_t rmin=0., Double_t rmax=9999999, Option_t *option="""")Generate a lego plot fot the top volume, acco",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8h_source.html:35265,efficient,efficient,35265,doc/master/TGeoVolume_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8h_source.html,1,['efficient'],['efficient']
Energy Efficiency,"ple numerical value, return its type (see TDataType). void * At(UInt_t idx); Return the address of the value at index 'idx'. void Clear(const char* opt = """"); Clear the container. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete). void Commit(void* ). char * operator[](UInt_t idx) const; { return (char*)(const_cast<TVirtualCollectionProxy*>(this))->At(idx); }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE); Copy the iterator source, into dest. dest should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator is of that size or less, the iterator will be constructed in place in this location (new with placement); Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest. Next_t GetFunctionNext(Bool_t read = kTRUE); iter and end should be pointers to respectively an iterator to be incremented and the result of collection.end(); If the iterator has not reached the end of the collection, 'Next' increment the iterator 'iter' and return 0 if; the iterator reached the end.; If the end was not reached, 'Next' returns the address of the content pointed to by the iterator before the; incrementation ; if the co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualCollectionProxy.html:5415,allocate,allocated,5415,root/html528/TVirtualCollectionProxy.html,https://root.cern,https://root.cern/root/html528/TVirtualCollectionProxy.html,3,['allocate'],['allocated']
Energy Efficiency,"ple numerical value, return its type (see TDataType). void * At(UInt_t idx); Return the address of the value at index 'idx'. void Clear(const char* opt = """"); Clear the container. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete). void Commit(void* ). char * operator[](UInt_t idx) const; { return (char*)(const_cast<TVirtualCollectionProxy*>(this))->At(idx); }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE); Copy the iterator source, into dest. dest should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator is of that size or less, the iterator will be constructed in place in this location (new with placement); Otherwise the iterator will be allocated via a regular new.; The actual address of the iterator is returned in both case. Next_t GetFunctionNext(Bool_t read = kTRUE); iter and end should be pointers to respectively an iterator to be incremented and the result of collection.end(); If the iterator has not reached the end of the collection, 'Next' increment the iterator 'iter' and return 0 if; the iterator reached the end.; If the end was not reached, 'Next' returns the address of the content pointed to by the iterator before the; incrementation ; if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualCollectionProxy.html:5526,allocate,allocated,5526,root/html534/TVirtualCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TVirtualCollectionProxy.html,1,['allocate'],['allocated']
Energy Efficiency,"plementation of the DistributionCreator interface used for debugging ;  CDebuggingTestStatDebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging ;  CDiscrDistFree functions adapter needed by UNURAN for one-dimensional discrete distribution ;  CEvent_t;  CExceptionContext_t;  CFeldmanCousinsBinomialInterval;  CFeldmanCousinsSorter;  CFileStat_t;  CFontAttributes_t;  CFontMetrics_t;  CFoption_t;  Cfuncptr_and_voidptr_t;  CGcCache_t;  CGCValues_t;  Cgroup;  Ch1analysis;  Ch1analysisTreeReader;  Chash< std::experimental::basic_string_view< _CharT, _Traits > >;  CHelperOps;  CHEPEVT_DEFHEPEVT common block ;  CHit;  CHoption_tHistogram option structure ;  CHparam_tHistogram parameters structure ;  CJet;  CJetEvent;  CMemInfo_t;  Cmg_callbacks;  Cmg_client_cert;  Cmg_client_options;  Cmg_form_data_handler;  Cmg_header;  Cmg_option;  Cmg_request_info;  Cmg_response_info;  Cmg_server_ports;  Cmg_websocket_subprotocols;  CMultiDistFree functions adapter needed by UNURAN for multidimensional cont distribution ;  CMYSQL_BIND;  CMYSQL_STMT;  CNuMuToNuE_Oscillation;  ►CParamHistFunc;  CCacheElem;  CPassiveKeyGrab;  Cpasswd;  CPattern;  CPgSQL_Stmt_t;  CPictureAttributes_t;  ►CPiecewiseInterpolation;  CCacheElem;  CPoint_t;  CProcInfo_t;  CProofServEnv_t;  Cpthread_cond_t;  CPybins_tPythia6 common block Pybins ;  CPydat1_tPythia6 common block Pydat1 ;  CPydat2_tPythia6 common block Pydat2 ;  CPydat3_tPythia6 common block Pydat3 ;  CPydat4_tPythia6 common block Pydat4 ;  CPydatr_tPythia6 common block Pydatr ;  CPyint1_tPythia6 common block Pyint1 ;  CPyint2_tPythia6 common block Pyint2 ;  CPyint3_tPythia6 common block Pyint3 ;  CPyint4_tPythia6 common block Pyint4 ;  CPyint5_tPythia6 common block Pyint5 ;  CPyint6_tPythia6 common block Pyint6 ;  CPyint7_tPythia6 common block Pyint7 ;  CPyint8_tPythia6 common block Pyint8 ;  CPyint9_tPythia6 common block Pyint9 ;  CPyints_tPythia6 common block Pyints ;  CPyjets_tPythia6 common block Pyje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:92725,adapt,adapter,92725,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,1,['adapt'],['adapter']
Energy Efficiency,"plots below.; For PDFs that have larger curvatures, the RooBinSamplingPdf can be used. It integrates the PDF in each bin using an adaptive integrator. This usually requires 21 times more function evaluations, but significantly reduces biases due to better sampling of the PDF. The integrator can be accessed from the outside using integrator(). This can be used to change the integration rules, so less/more function evaluations are performed. The target precision of the integrator can be set in the constructor. How to use it; There are two ways to use this class:; Manually wrap a PDF: RooBinSamplingPdf binSampler(""<name>"", ""title"", <binned observable of PDF>, <original PDF> [, <precision for integrator>]);; binSampler.fitTo(data);; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; RooBinSamplingPdfThe RooBinSamplingPdf is supposed to be used as an adapter between a continuous PDF and a binned dist...Definition RooBinSamplingPdf.h:28; RooBinSamplingPdf::integratorstd::unique_ptr< ROOT::Math::IntegratorOneDim > & integrator() constDirect access to the unique_ptr holding the integrator that's used to sample the bins.Definition RooBinSamplingPdf.cxx:278; RooBinSamplingPdf::observableconst RooAbsReal & observable() constDefinition RooBinSamplingPdf.h:111; When a PDF is wrapped with a RooBinSamplingPDF, just use the bin sampling PDF instead of the original one for fits or plotting etc. NoteThe binning will be taken from the observable. Make sure that this binning is the same as the one of the dataset that should be fit. Use RooRealVar::setBinning() to adapt it. Instruct test statistics to carry out this wrapping automatically: pdf.fitTo(data, IntegrateBins(<precision>));; RooAbsPdf::fitToRooFit::OwningPtr< RooFitResult > fitTo(RooAbsData &data, CmdArgs_t const &... cmdArgs)Fit PDF to given dataset.Definition RooAbsPdf.h:1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:1777,adapt,adapter,1777,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,1,['adapt'],['adapter']
Energy Efficiency,"plotting features; frame1 = x.frame(Name=""xframe"", Title=""Red Curve / SumW2 Histo errors"", Bins=20); frame2 = x.frame(Name=""xframe"", Title=""Dashed Curve / No XError bars"", Bins=20); frame3 = x.frame(Name=""xframe"", Title=""Filled Curve / Blue Histo"", Bins=20); frame4 = x.frame(Name=""xframe"", Title=""Partial Range / Filled Bar chart"", Bins=20); ; # Data plotting styles; # ---------------------------------------; ; # Use sqrt(sum(weights^2)) error instead of Poisson errors; data.plotOn(frame1, DataError=""SumW2""); ; # Remove horizontal error bars; data.plotOn(frame2, XErrorSize=0); ; # Blue markers and error bors; data.plotOn(frame3, MarkerColor=""b"", LineColor=""b""); ; # Filled bar chart; data.plotOn(frame4, DrawOption=""B"", DataError=None, XErrorSize=0, FillColor=""kGray""); ; # Function plotting styles; # -----------------------------------------------; ; # Change line color to red; gauss.plotOn(frame1, LineColor=""r""); ; # Change line style to dashed; gauss.plotOn(frame2, LineStyle=""--""); ; # Filled shapes in green color; gauss.plotOn(frame3, MoveToBack=True, DrawOption=""F"", FillColor=""kOrange""); ; #; gauss.plotOn(frame4, Range=(-8, 3), LineColor=""m""); ; c = ROOT.TCanvas(""rf107_plotstyles"", ""rf107_plotstyles"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.6); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame4.GetYaxis().SetTitleOffset(1.6); frame4.Draw(); ; c.SaveAs(""rf107_plotstyles.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_gaussData) Summation contains a RooNLLVar, u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf107__plotstyles_8py.html:1911,green,green,1911,doc/master/rf107__plotstyles_8py.html,https://root.cern,https://root.cern/doc/master/rf107__plotstyles_8py.html,1,['green'],['green']
Energy Efficiency,"pointer to an STL container.; 5438 Error(""SetAddress"", ""Embedded pointer to an STL container given a zero address for branch '%s'"", GetName());; 5439 }; 5440 }; 5441 }; 5442 } else if (fType == 41) {; 5443 // -- We are an STL container sub-branch.; 5444 // Initialize fCollProxy.; 5445 GetCollectionProxy();; 5446 // We are not at top-level branch.; 5447 fObject = fAddress;; 5448 } else if (fID < 0) {; 5449 // -- We are a top-level branch.; 5450 char** pp = (char**) fAddress;; 5451 if (pp && *pp) {; 5452 // -- Caller provided an i/o buffer for us to use.; 5453 fObject = *pp;; 5454 } else {; 5455 // -- Caller did not provide an i/o buffer for us to use, we must make one for ourselves.; 5456 if (clOfBranch) {; 5457 if (!pp) {; 5458 // -- Caller wants us to own the object.; 5459 SetBit(kDeleteObject);; 5460 }; 5461 fObject = (char*) clOfBranch->New();; 5462 if (pp) {; 5463 *pp = fObject;; 5464 } else {; 5465 fAddress = (char*) &fObject;; 5466 }; 5467 } else {; 5468 Error(""SetAddress"", ""I have no TClass for branch %s, so I cannot allocate an I/O buffer!"", GetName());; 5469 if (pp) {; 5470 fObject = nullptr;; 5471 *pp = nullptr;; 5472 }; 5473 }; 5474 }; 5475 } else {; 5476 // -- We are *not* a top-level branch.; 5477 fObject = fAddress;; 5478 }; 5479 ; 5480 if (!info) {; 5481 // FIXME: We need and error message here, no streamer info, so cannot set offsets.; 5482 return;; 5483 }; 5484 ; 5485 // We do this only once because it depends only on; 5486 // the type of our object, not on its address.; 5487 if (!fInitOffsets) {; 5488 InitializeOffsets();; 5489 }; 5490 ; 5491 // We are split, recurse down to our sub-branches.; 5492 //; 5493 // FIXME: This is a tail recursion, we burn stack.; 5494 Int_t nbranches = fBranches.GetEntriesFast();; 5495 for (Int_t i = 0; i < nbranches; ++i) {; 5496 TBranch *abranch = (TBranch*) fBranches.UncheckedAt(i);; 5497 // FIXME: This is a tail recursion!; 5498 if (fBranchOffset[i] != TStreamerInfo::kMissing && !(implied && abranch->TestBit(kAddress",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:203184,allocate,allocate,203184,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"points. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCutG(); TCutG default constructor. TCutG(const TCutG& cutg); TCutG copy constructor. TCutG(const char* name, Int_t n); TCutG normal constructor. TCutG(const char* name, Int_t n, const Float_t* x, const Float_t* y); TCutG normal constructor. TCutG(const char* name, Int_t n, const Double_t* x, const Double_t* y); TCutG normal constructor. ~TCutG(); TCutG destructor. TCutG & operator=(const TCutG& ); Assignment operator. Double_t Area() const; Compute the area inside this TCutG; The algorithm uses Stoke's theorem over the border of the closed polygon.; Just as a reminder: Stoke's theorem reduces a surface integral; to a line integral over the border of the surface integral. void Center(Double_t& cx, Double_t& cy) const; Compute the center x,y of this TCutG; The algorithm uses Stoke's theorem over the border of the closed polygon.; Just as a reminder: Stoke's theorem reduces a surface integral; to a line integral over the border of the surface integral. Double_t IntegralHist(TH2* h, Option_t* option = """") const; Compute the integral of 2-d histogram h for all bins inside the cut; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x and in y. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetObjectX(TObject* obj); Set the X object (and delete the previous one if any). void SetObjectY(TObject* obj); Set the Y object (and delete the previous one if any). void SetVarX(const char* varx); Set X variable. void SetVarY(const char* vary); Set Y variable. void Streamer(TBuffer& ); Stream an object of class TCutG. TObject * GetObjectX() const; {return fObjectX;}. TObject * GetObjectY() const; {return fObjectY;}. const char * GetVarX() const; {return fVarX.Data();}. const char * GetVarY() const; {return fVarY.Data();}. » Author: Rene Brun 16/05/97 » Copyri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCutG.html:17393,reduce,reduces,17393,root/html534/TCutG.html,https://root.cern,https://root.cern/root/html534/TCutG.html,3,['reduce'],['reduces']
Energy Efficiency,"polar coordinate system based on r, theta and phi Phi is restricted to be in the range [-PI,PI) More...;  ; class  ROOT::Math::PositionVector2D< CoordSystem, Tag >;  Class describing a generic position vector (point) in 2 dimensions. More...;  ; class  ROOT::Math::PositionVector3D< CoordSystem, Tag >;  Class describing a generic position vector (point) in 3 dimensions. More...;  ; class  ROOT::Math::PtEtaPhiE4D< ScalarType >;  Class describing a 4D cylindrical coordinate system using Pt , Phi, Eta and E (or rho, phi, eta , T) The metric used is (-,-,-,+). More...;  ; class  ROOT::Math::PtEtaPhiM4D< ScalarType >;  Class describing a 4D cylindrical coordinate system using Pt , Phi, Eta and M (mass) The metric used is (-,-,-,+). More...;  ; class  ROOT::Math::PxPyPzE4D< ScalarType >;  Class describing a 4D cartesian coordinate system (x, y, z, t coordinates) or momentum-energy vectors stored as (Px, Py, Pz, E). More...;  ; class  ROOT::Math::PxPyPzM4D< ScalarType >;  Class describing a 4D coordinate system or momentum-energy vectors stored as (Px, Py, Pz, M). More...;  ; class  ROOT::Math::Quaternion;  Rotation class with the (3D) rotation represented by a unit quaternion (u, i, j, k). More...;  ; class  ROOT::Math::Rotation3D;  Rotation class with the (3D) rotation represented by a 3x3 orthogonal matrix. More...;  ; class  ROOT::Math::RotationX;  Rotation class representing a 3D rotation about the X axis by the angle of rotation. More...;  ; class  ROOT::Math::RotationY;  Rotation class representing a 3D rotation about the Y axis by the angle of rotation. More...;  ; class  ROOT::Math::RotationZ;  Rotation class representing a 3D rotation about the Z axis by the angle of rotation. More...;  ; class  ROOT::Math::RotationZYX;  Rotation class with the (3D) rotation represented by angles describing first a rotation of an angle phi (yaw) about the Z axis, followed by a rotation of an angle theta (pitch) about the Y axis, followed by a third rotation of an angle psi (roll) a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__GenVector.html:13468,energy,energy,13468,doc/master/group__GenVector.html,https://root.cern,https://root.cern/doc/master/group__GenVector.html,1,['energy'],['energy']
Energy Efficiency,"port integer tree branch as RooRealVar; RooRealVar i(""i"", ""i"", 0, 5);; RooDataSet ds3(""ds3"", ""ds3"", RooArgSet(i, x), Import(*tree));; ds3.Print();; ; // Define category i; RooCategory icat(""i"", ""i"");; icat.defineType(""State0"", 0);; icat.defineType(""State1"", 1);; ; // Import integer tree branch as RooCategory (only events with i==0 and i==1; // will be imported as those are the only defined states); RooDataSet ds4(""ds4"", ""ds4"", RooArgSet(icat, x), Import(*tree));; ds4.Print();; ; // I m p o r t m u l t i p l e R o o D a t a S e t s i n t o a R o o D a t a S e t; // ----------------------------------------------------------------------------------------; ; // Create three RooDataSets in (y,z); std::unique_ptr<RooAbsData> dsA{ds2.reduce({x, y}, ""z<-5"")};; std::unique_ptr<RooAbsData> dsB{ds2.reduce({x, y}, ""abs(z)<5"")};; std::unique_ptr<RooAbsData> dsC{ds2.reduce({x, y}, ""z>5"")};; ; // Create a dataset that imports contents of all the above datasets mapped by index category c; RooDataSet dsABC{""dsABC"", ""dsABC"", RooArgSet(x, y), Index(c), Import(""SampleA"", *dsA),; Import(""SampleB"", *dsB), Import(""SampleC"", *dsC)};; ; dsABC.Print();; }; ; TH1 *makeTH1(const char *name, double mean, double sigma); {; // Create ROOT TH1 filled with a Gaussian distribution; ; TH1D *hh = new TH1D(name, name, 100, -10, 10);; for (int i = 0; i < 1000; i++) {; hh->Fill(gRandom->Gaus(mean, sigma));; }; return hh;; }; ; TTree *makeTTree(); {; // Create ROOT TTree filled with a Gaussian distribution in x and a uniform distribution in y; ; TTree *tree = new TTree(""tree"", ""tree"");; double *px = new double;; double *py = new double;; double *pz = new double;; Int_t *pi = new Int_t;; tree->Branch(""x"", px, ""x/D"");; tree->Branch(""y"", py, ""y/D"");; tree->Branch(""z"", pz, ""z/D"");; tree->Branch(""i"", pi, ""i/I"");; for (int i = 0; i < 100; i++) {; *px = gRandom->Gaus(0, 3);; *py = gRandom->Uniform() * 30 - 15;; *pz = gRandom->Gaus(0, 5);; *pi = i % 3;; tree->Fill();; }; return tree;; }; c#define c(i)Definition RS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf401__importttreethx_8C.html:3395,reduce,reduce,3395,doc/master/rf401__importttreethx_8C.html,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8C.html,1,['reduce'],['reduce']
Energy Efficiency,"post request; Long_tfPostDataLength! length of binary data; TStringfQuery! additional arguments; TStringfRequestHeader! complete header, provided with request; TStringfTopName! top item name; TStringfUserName! authenticated user name (if any); Int_tfZipping! indicate if content should be zipped. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THttpCallArg(); constructor. ~THttpCallArg(); destructor. TString AccessHeader(TString& buf, const char* name, const char* value = 0, Bool_t doing_set = kFALSE); method used to get or set http header in the string buffer; Header has following format:; field1 : value1\r\n; field2 : value2\r\n; Such format corresponds to header format in HTTP requests. TString CountHeader(const TString& buf, Int_t number = -1111) const; method used to counter number of headers or returns name of specified header. void SetPostData(void* data, Long_t length); set data, posted with the request; buffer should be allocated with malloc(length+1) call,; while last byte will be set to 0; Than one could use post data as null-terminated string. void SetBinData(void* data, Long_t length); set binary data, which will be returned as reply body. void SetPathAndFileName(const char* fullpath); set complete path of requested http element; For instance, it could be ""/folder/subfolder/get.bin""; Here ""/folder/subfolder/"" is element path and ""get.bin"" requested file.; One could set path and file name separately. TString GetHeader(const char* name); return specified header. void AddHeader(const char* name, const char* value); Set name: value pair to reply header; Content-Type field handled separately - one should use SetContentType() method; Content-Length field cannot be set at all;. void FillHttpHeader(TString& buf, const char* header = 0); fill HTTP header. Bool_t CompressWithGzip(); compress reply data with gzip compression. Bool_t IsBinData() const. THttpCallArg(). void SetMethod(const char* method); these methods used t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/THttpCallArg.html:8801,allocate,allocated,8801,root/html604/THttpCallArg.html,https://root.cern,https://root.cern/root/html604/THttpCallArg.html,1,['allocate'],['allocated']
Energy Efficiency,"post request; Long_tfPostDataLength! length of binary data; TStringfQuery! additional arguments; TStringfRequestHeader! complete header, provided with request; TStringfTopName! top item name; TStringfUserName! authenticated user name (if any); Int_tfZipping! indicate if content should be zipped. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THttpCallArg(); constructor. ~THttpCallArg(); destructor. TString AccessHeader(TString& buf, const char* name, const char* value = 0, Bool_t doing_set = kFALSE); method used to get or set http header in the string buffer; Header has following format:; field1 : value1\r\n; field2 : value2\r\n; Such format corresponds to header format in HTTP requests. TString CountHeader(const TString& buf, Int_t number = -1111) const; method used to counter number of headers or returns name of specified header. void SetPostData(void* data, Long_t length); set data, posted with the request; buffer should be allocated with malloc(length+1) call,; while last byte will be set to 0; Than one could use post data as null-terminated string. void SetBinData(void* data, Long_t length); set binary data, which will be returned as reply body. void SetPathAndFileName(const char* fullpath); set complete path of requested http element; For instance, it could be ""/folder/subfolder/get.bin""; Here ""/folder/subfolder/"" is element path and ""get.bin"" requested file.; One could set path and file name separately. TString GetHeader(const char* name); return specified header. void AddHeader(const char* name, const char* value); Set name: value pair to reply header; Content-Type field handled separately - one should use SetContentType() method; Content-Length field cannot be set at all;. void FillHttpHeader(TString& buf, const char* header = 0); fill HTTP header. Bool_t CompressWithGzip(); compress reply data with gzip compression. Bool_t IsBinData() const. void SetMethod(const char* method); these methods used to set http reque",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THttpCallArg.html:8308,allocate,allocated,8308,root/html534/THttpCallArg.html,https://root.cern,https://root.cern/root/html534/THttpCallArg.html,1,['allocate'],['allocated']
Energy Efficiency,"pp}; 1011/// auto TopClass = TClass::GetClass(""Top"");; 1012/// auto ptr = (Top*) key->ReadObjectAny( TopClass );; 1013/// if (ptr==0) printError(""the object stored in the key is not of the expected type\n"");; 1014/// ~~~; 1015/// The object associated to this key is read from the file into memory.; 1016/// Once the key structure is read (via Streamer) the class identifier; 1017/// of the object is known.; 1018/// Using the class identifier we find the TClass object for this class.; 1019/// A TClass object contains a full description (i.e. dictionary) of the; 1020/// associated class. In particular the TClass object can create a new; 1021/// object of the class type it describes. This new object now calls its; 1022/// Streamer function to rebuilt itself.; 1023 ; 1024void *TKey::ReadObjectAny(const TClass* expectedClass); 1025{; 1026 TBufferFile bufferRef(TBuffer::kRead, fObjlen+fKeylen);; 1027 if (!bufferRef.Buffer()) {; 1028 Error(""ReadObj"", ""Cannot allocate buffer: fObjlen = %d"", fObjlen);; 1029 return 0;; 1030 }; 1031 if (GetFile()==0) return 0;; 1032 bufferRef.SetParent(GetFile());; 1033 bufferRef.SetPidOffset(fPidOffset);; 1034 ; 1035 std::unique_ptr<char []> compressedBuffer;; 1036 auto storeBuffer = fBuffer;; 1037 if (fObjlen > fNbytes-fKeylen) {; 1038 compressedBuffer.reset(new char[fNbytes]);; 1039 fBuffer = compressedBuffer.get();; 1040 ReadFile(); //Read object structure from file; 1041 memcpy(bufferRef.Buffer(),fBuffer,fKeylen);; 1042 } else {; 1043 fBuffer = bufferRef.Buffer();; 1044 ReadFile(); //Read object structure from file; 1045 }; 1046 fBuffer = storeBuffer;; 1047 ; 1048 // get version of key; 1049 bufferRef.SetBufferOffset(sizeof(fNbytes));; 1050 Version_t kvers = bufferRef.ReadVersion();; 1051 ; 1052 bufferRef.SetBufferOffset(fKeylen);; 1053 TClass *cl = TClass::GetClass(fClassName.Data());; 1054 TClass *clOnfile = 0;; 1055 if (!cl) {; 1056 Error(""ReadObjectAny"", ""Unknown class %s"", fClassName.Data());; 1057 return 0;; 1058 }; 1059 Int_t baseOffs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TKey_8cxx_source.html:36849,allocate,allocate,36849,doc/master/TKey_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"pr bool HasCallOp (char);  ; template<typename T > ; constexpr auto HasCallOp (int) -> decltype(&T::operator(), true);  ; template<class ArrayL , class ArrayR > ; bool operator_equal_impl (ArrayL const &lhs, size_t const lhs_size, ArrayR const &rhs, size_t const rhs_size);  . Detailed Description; Special implementation of ROOT::RRangeCast for TCollection, including a check that the cast target type inherits from TObject and a new constructor that takes the TCollection by pointer. ; Template Parameters. TThe new type to convert to. ; isDynamicIf true, dynamic_cast is used, otherwise static_cast is used. . Typedef Documentation. ◆ make_indices. template<size_t Start, size_t Last, size_t Step = 1> . using ROOT::Detail::make_indices = typedef typename make_indices_< Start, Last, Step >::type. Definition at line 148 of file span.hxx. ◆ TRangeStaticCast. template<typename T > . using ROOT::Detail::TRangeStaticCast = typedef TRangeCast<T, false>. TRangeStaticCast is an adapter class that allows the typed iteration through a TCollection. ; This requires the collection to contain elements of the type requested (or a derived class). Any deviation from this expectation will only be caught/reported by an assert in debug builds.; This is best used with a TClonesArray, for other cases prefered TRangeDynCast.; The typical use is: for(auto bcl : TRangeStaticCast<TBaseClass>( *tbaseClassClonesArrayPtr )) {; ... use bcl as a TBaseClass*; }; for(auto bcl : TRangeStaticCast<TBaseClass>( tbaseClassClonesArrayPtr )) {; ... use bcl as a TBaseClass*; }; a#define a(i)Definition RSha256.hxx:99; ROOT::Detail::TRangeCastDefinition TCollection.h:311; TBaseClassEach class (see TClass) has a linked list of its base class(es).Definition TBaseClass.h:33; Template Parameters. TThe new type to convert to. . Definition at line 337 of file TCollection.h. Function Documentation. ◆ HasBeenDeleted(). R__ALWAYS_INLINE bool ROOT::Detail::HasBeenDeleted ; (; const TObject * ; obj). Check if the TObject's me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Detail.html:3319,adapt,adapter,3319,doc/master/namespaceROOT_1_1Detail.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Detail.html,2,['adapt'],['adapter']
Energy Efficiency,"pressed in the base; specified (range=2-36), i.e. {0,1} for base 2, {0-9,a-f,A-F} for base 16,; {0-9,a-z,A-Z} for base 36. Returns false in case string length is 0 or; string contains other characters. Int_t Atoi() const; Return integer value of string.; Valid strings include only digits and whitespace (see IsDigit()),; i.e. ""123456"", ""123 456"" and ""1 2 3 4 56"" are all valid; integer strings whose Atoi() value is 123456. Long64_t Atoll() const; Return long long value of string.; Valid strings include only digits and whitespace (see IsDigit()),; i.e. ""123456"", ""123 456"" and ""1 2 3 4 56"" are all valid; integer strings whose Atoll() value is 123456. Double_t Atof() const; Return floating-point value contained in string.; Examples of valid strings are:; 64320; 64 320; 6 4 3 2 0; 6.4320 6,4320; 6.43e20 6.43E20 6,43e20; 6.43e-20 6.43E-20 6,43e-20. TString Itoa(Int_t value, Int_t base); Converts an Int_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; Usage: the following statement produce the same output, namely ""1111""; cout << TString::Itoa(15,2) ;; cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; In case of error returns the ""!"" string. TString UItoa(UInt_t value, Int_t base); Converts a UInt_t (twice the range of an Int_t) to a TString with respect; to the base specified (2-36). Thus it is an enhanced version of sprintf; (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString LLtoa(Long64_t value, Int_t base); Converts a Long64_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString ULLtoa(ULong64_t value, Int_t base); Converts a ULon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TString.html:18037,adapt,adapted,18037,root/html534/TString.html,https://root.cern,https://root.cern/root/html534/TString.html,1,['adapt'],['adapted']
Energy Efficiency,"pressed in the base; specified (range=2-36), i.e. {0,1} for base 2, {0-9,a-f,A-F} for base 16,; {0-9,a-z,A-Z} for base 36. Returns false in case string length is 0 or; string contains other characters. Int_t Atoi() const; Return integer value of string.; Valid strings include only digits and whitespace (see IsDigit()),; i.e. ""123456"", ""123 456"" and ""1 2 3 4 56"" are all valid; integer strings whose Atoi() value is 123456. Long64_t Atoll() const; Return long long value of string.; Valid strings include only digits and whitespace (see IsDigit()),; i.e. ""123456"", ""123 456"" and ""1 2 3 4 56"" are all valid; integer strings whose Atoll() value is 123456. Double_t Atof() const; Return floating-point value contained in string.; Examples of valid strings are:; 64320; 64 320; 6 4 3 2 0; 6.4320 6,4320; 6.43e20 6.43E20 6,43e20; 6.43e-20 6.43E-20 6,43e-20. TString Itoa(Int_t value, Int_t base); Converts an Int_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; Usage: the following statement produce the same output, namely ""1111""; std::cout << TString::Itoa(15,2) ;; std::cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; std::cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; In case of error returns the ""!"" string. TString UItoa(UInt_t value, Int_t base); Converts a UInt_t (twice the range of an Int_t) to a TString with respect; to the base specified (2-36). Thus it is an enhanced version of sprintf; (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString LLtoa(Long64_t value, Int_t base); Converts a Long64_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString ULLtoa(ULong64_t value, Int_t base); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TString.html:18349,adapt,adapted,18349,root/html602/TString.html,https://root.cern,https://root.cern/root/html602/TString.html,2,['adapt'],['adapted']
Energy Efficiency,"product of two LorentzVector vectors (metric is -,-,-,+); Enable the product using any other LorentzVector implementing; the x(), y() , y() and t() member functions; \param q any LorentzVector implementing the x(), y() , z() and t(); member functions; \return the result of v.q of type according to the base scalar type of v. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar rho() const; { return fCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html:19178,energy,energy,19178,root/html528/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,4,['energy'],['energy']
Energy Efficiency,"product of two LorentzVector vectors (metric is -,-,-,+); Enable the product using any other LorentzVector implementing; the x(), y() , y() and t() member functions; \param q any LorentzVector implementing the x(), y() , z() and t(); member functions; \return the result of v.q of type according to the base scalar type of v. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar rho() const; { return fCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html:17572,energy,energy,17572,root/html528/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,4,['energy'],['energy']
Energy Efficiency,"protected . Push a new rendering style onto the stack. ; tag - Tag for this style. Normally the end-tag such as </h3> or </em>. style - The style to push ; Definition at line 66 of file TGHtmlSizer.cxx. ◆ RadioChanged(). void TGHtml::RadioChanged ; (; const char * ; name, . const char * ; val . ). virtual . Emit RadioChanged() signal. ; Definition at line 1313 of file TGHtml.cxx. ◆ Redraw(). void TGHtml::Redraw ; (; ). protected . This routine is invoked in order to redraw all or part of the HTML widget. ; This might happen because the display has changed, or in response to an expose event. In all cases, though, this routine is called by an idle handler. ; Definition at line 544 of file TGHtml.cxx. ◆ RedrawArea(). void TGHtml::RedrawArea ; (; int ; left, . int ; top, . int ; right, . int ; bottom . ). protected . If any part of the screen needs to be redrawn, then call this routine with the values of a box (in window coordinates) that needs to be redrawn. ; This routine will schedule an idle handler to do the redraw.; The box coordinates are relative to the clipping window (fCanvas). ; Definition at line 789 of file TGHtml.cxx. ◆ RedrawBlock(). void TGHtml::RedrawBlock ; (; TGHtmlBlock * ; p). protected . Redraw the TGHtmlBlock given. ; Definition at line 866 of file TGHtml.cxx. ◆ RedrawEverything(). void TGHtml::RedrawEverything ; (; ). protected . Call this routine to force the entire widget to be redrawn. ; Definition at line 877 of file TGHtml.cxx. ◆ RedrawText(). void TGHtml::RedrawText ; (; int ; y). protected . Call this routine to cause all of the rendered HTML at the virtual canvas coordinate of Y and beyond to be redrawn. ; Definition at line 887 of file TGHtml.cxx. ◆ ResetBlocks(). void TGHtml::ResetBlocks ; (; ). inline . Definition at line 978 of file TGHtml.h. ◆ ResetLayoutContext(). void TGHtml::ResetLayoutContext ; (; ). protected . Reset the main layout context in the main widget. ; This happens before we redo the layout, or just before deleting the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtml.html:82845,schedul,schedule,82845,doc/master/classTGHtml.html,https://root.cern,https://root.cern/doc/master/classTGHtml.html,1,['schedul'],['schedule']
Energy Efficiency,"pt user interface.; Any registered object can be requested and displayed in the browser.; There are many benefits of such approach:; * standard http interface to ROOT application; * no any temporary ROOT files when access data; * user interface running in all browsers. Starting HTTP server. To start http server, at any time create instance; of the THttpServer class like:; serv = new THttpServer(""http:8080"");. This will starts civetweb-based http server with http port 8080.; Than one should be able to open address ""http://localhost:8080""; in any modern browser (IE, Firefox, Chrome) and browse objects,; created in application. By default, server can access files,; canvases and histograms via gROOT pointer. All such objects; can be displayed with JSROOT graphics. At any time one could register other objects with the command:. TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);. If objects content is changing in the application, one could; enable monitoring flag in the browser - than objects view; will be regularly updated. More information: http://root.cern.ch/drupal/content/users-guide. Function Members (Methods); public:. THttpServer(const char* engine = ""civetweb:8080""); virtual~THttpServer(); voidTObject::AbstractMethod(const char* method) const; voidAddLocation(const char* prefix, const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Bool_tCreateEngine(const char* engine); Bool_tCreateItem(const char* fullname, const char* title); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THttpServer.html:1454,monitor,monitoring,1454,root/html534/THttpServer.html,https://root.cern,https://root.cern/root/html534/THttpServer.html,1,['monitor'],['monitoring']
Energy Efficiency,"ptimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:17930,allocate,allocated,17930,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,8,['allocate'],['allocated']
Energy Efficiency,"ption_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. UShort_tfDetIdCustom detector id.; Int_tfEvaLabelLabel of primary particle, ancestor of label.; Int_tfLabelLabel of particle that produced the hit.; UShort_tfSubdetIdCustom sub-detector id.; TEveVectorfVHit position. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveMCTrack& operator=(const TEveHit& ); { *((TParticle*)this) = p; return *this; }. TEveHit(); Float_t charge; probably specific. {}. virtual ~TEveHit(); {}. » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveHit.html:5483,charge,charge,5483,root/html534/TEveHit.html,https://root.cern,https://root.cern/root/html534/TEveHit.html,1,['charge'],['charge']
Energy Efficiency,"ptions(const Option_t* option, TString& plotOpt, TString& drawOpt); Sets User defined drawing options. void GetOptions(string optionType, string option); Gets User defined KDE construction options. void AssureOptions(); Sets missing construction options to default ones. void CheckOptions(Bool_t isUserDefinedKernel = kFALSE); Sets User global options. void SetKernelType(TKDE::EKernelType kern); Sets User option for the choice of kernel estimator. void SetIteration(TKDE::EIteration iter); Sets User option for fixed or adaptive iteration. void SetMirror(TKDE::EMirror mir); Sets User option for mirroring the data. void SetBinning(TKDE::EBinning ); Sets User option for binning the weights. void SetNBins(UInt_t nbins); Sets User option for number of bins. void SetUseBinsNEvents(UInt_t nEvents); Sets User option for the minimum number of events for allowing automatic binning. void SetTuneFactor(Double_t rho); Factor which can be used to tune the smoothing.; It is used as multiplicative factor for the fixed and adaptive bandwidth.; A value < 1 will reproduce better the tails but oversmooth the peak; while a factor > 1 will overestimate the tail. void SetRange(Double_t xMin, Double_t xMax); Sets minimum range value and maximum range value. void SetUseBins(); Sets User option for using binned weights. void SetMirror(); Sets the mirroring. void SetData(const Double_t* data); Sets the data events input sample or bin centres for binned option and computes basic estimators. void InitFromNewData(); re-initialize when new data have been filled in TKDE; re-compute kernel quantities and mean and sigma. void SetMirroredEvents(); Mirrors the data. void SetMean(); Computes input data's mean. void SetSigma(Double_t R); Computes input data's sigma. void SetKernel(); Sets the kernel density estimator. void SetKernelFunction(TKDE::KernelFunction_Ptr kernfunc = 0); Sets kernel estimator. void SetCanonicalBandwidths(); Sets the canonical bandwidths according to the kernel type. void SetKernelS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TKDE.html:13395,adapt,adaptive,13395,root/html602/TKDE.html,https://root.cern,https://root.cern/root/html602/TKDE.html,1,['adapt'],['adaptive']
Energy Efficiency,"ptions(const Option_t* option, TString& plotOpt, TString& drawOpt); Sets User defined drawing options. void GetOptions(string optionType, string option); Gets User defined KDE construction options. void AssureOptions(); Sets missing construction options to default ones. void CheckOptions(Bool_t isUserDefinedKernel = kFALSE); Sets User global options. void SetKernelType(TKDE::EKernelType kern); Sets User option for the choice of kernel estimator. void SetIteration(TKDE::EIteration iter); Sets User option for fixed or adaptive iteration. void SetMirror(TKDE::EMirror mir); Sets User option for mirroring the data. void SetBinning(TKDE::EBinning ); Sets User option for binning the weights. void SetNBins(UInt_t nbins); Sets User option for number of bins. void SetUseBinsNEvents(UInt_t nEvents); Sets User option for the minimum number of events for allowing automatic binning. void SetTuneFactor(Double_t rho); Factor which can be used to tune the smoothing.; It is used as multiplicative factor for the fixed and adaptive bandwidth.; A value < 1 will reproduce better the tails but oversmooth the peak; while a factor > 1 will overestimate the tail. void SetRange(Double_t xMin, Double_t xMax); Sets minimum range value and maximum range value. void SetUseBins(); Sets User option for using binned weights. void SetMirror(); Sets the mirroring. void SetData(const Double_t* data, const Double_t* weights); Sets the data events input sample or bin centres for binned option and computes basic estimators. void InitFromNewData(); re-initialize when new data have been filled in TKDE; re-compute kernel quantities and mean and sigma. void SetMirroredEvents(); Mirrors the data. void SetMean(); Computes input data's mean. void SetSigma(Double_t R); Computes input data's sigma. void SetKernel(); Sets the kernel density estimator. void SetKernelFunction(TKDE::KernelFunction_Ptr kernfunc = 0). void SetCanonicalBandwidths(); Sets the canonical bandwidths according to the kernel type. void SetKerne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TKDE.html:13638,adapt,adaptive,13638,root/html604/TKDE.html,https://root.cern,https://root.cern/root/html604/TKDE.html,1,['adapt'],['adaptive']
Energy Efficiency,"ptions:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1., Double_t xMax = 0.). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.94999999999999996); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Returns the indices (bins) for the binned weights. Double_t UpperConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise upper estimated density. Double_t LowerConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise lower estimated density. Double_t GetBias(Double_t x) const; Returns the pointwise approximate estimated density bias. Double_t GetError(Double_t x) const; Returns the pointwise sigma of estimated density. void CheckKernelValidity(); Checks if kernel has unit integral, mu = 0 and positive finite sigma conditions. Double_t ComputeKernelL2Norm() const; Computes the kernel's L2 norm. Double_t ComputeKernelSigma2() const; Computes the kernel's sigma squared. Double_t ComputeKernelMu() const; Computes the kernel's mu. Double_t ComputeKernelIntegral() const; Computes the kernel's integral which ought to be unity. Double_t ComputeMidspread(); Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TKDE.html:17286,adapt,adaptive,17286,root/html602/TKDE.html,https://root.cern,https://root.cern/root/html602/TKDE.html,1,['adapt'],['adaptive']
Energy Efficiency,"ptions:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1., Double_t xMax = 0.). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.94999999999999996); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Returns the indices (bins) for the binned weights. Double_t UpperConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise upper estimated density. Double_t LowerConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise lower estimated density. Double_t GetBias(Double_t x) const; Returns the pointwise approximate estimated density bias. Double_t GetError(Double_t x) const; Returns the pointwise sigma of estimated density. void CheckKernelValidity(); Checks if kernel has unit integral, mu = 0 and positive finite sigma conditions. Double_t ComputeKernelL2Norm() const; Computes the kernel's L2 norm. Double_t ComputeKernelSigma2() const; Computes the kernel's sigma squared. Double_t ComputeKernelMu() const; Computes the kernel's mu. Double_t ComputeKernelIntegral() const; Computes the kernel's integral which ought to be unity. void ComputeDataStats(); in cas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TKDE.html:17706,adapt,adaptive,17706,root/html604/TKDE.html,https://root.cern,https://root.cern/root/html604/TKDE.html,1,['adapt'],['adaptive']
Energy Efficiency,"ptiveKDE; static TMVA::KDEKernel::EKernelTypekNone; static TMVA::KDEKernel::EKernelBorderkSampleMirror. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.). const char* GetName() const; modified name (remove TMVA::). { return ""KDEKernel""; }. » Author: Asen Christov » Copyright (c) 2007: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__KDEKernel.html:2643,adapt,adaptive,2643,root/html604/TMVA__KDEKernel.html,https://root.cern,https://root.cern/root/html604/TMVA__KDEKernel.html,1,['adapt'],['adaptive']
Energy Efficiency,"ptiveKDE; static TMVA::KDEKernel::EKernelTypekNone; static TMVA::KDEKernel::EKernelBorderkSampleMirror. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.). const char* GetName() const; modified name (remove TMVA::). { return ""KDEKernel""; }. » Author: Asen Christov » Copyright (c) 2007: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__KDEKernel.html:2635,adapt,adaptive,2635,root/html602/TMVA__KDEKernel.html,https://root.cern,https://root.cern/root/html602/TMVA__KDEKernel.html,1,['adapt'],['adaptive']
Energy Efficiency,"ptr};  [fNevBuf] Offset of entries in fBuffer(TKey); generated at runtime. ;  ; bool fHeaderOnly {false};  True when only the basket header must be read/written. ;  ; UChar_t fIOBits {0};  !IO feature flags. Serialized in custom portion of streamer to avoid forward compat issues unless needed. ;  ; Int_t fLast {0};  Pointer to last used byte in basket. ;  ; Int_t fLastWriteBufferSize [3] = {0,0,0};  ! Size of the buffer last three buffers we wrote it to disk ;  ; Int_t fNevBuf {0};  Number of entries in basket. ;  ; Int_t fNevBufSize {0};  Length in Int_t of fEntryOffset OR fixed length of each entry if fEntryOffset is null! ;  ; UChar_t fNextBufferSizeRecord {0};  ! Index into fLastWriteBufferSize of the last buffer written to disk ;  ; bool fOwnsCompressedBuffer {false};  ! Whether or not we own the compressed buffer. ;  ; bool fReadEntryOffset {false};  !Set to true if offset array was read from a file. ;  ; bool fResetAllocation {false};  ! True if last reset re-allocated the memory ;  ;  Protected Attributes inherited from TKey; char * fBuffer;  Object buffer. ;  ; TBuffer * fBufferRef;  Pointer to the TBuffer object. ;  ; TString fClassName;  Object Class name. ;  ; Short_t fCycle;  Cycle number. ;  ; TDatime fDatime;  Date/Time of insertion in file. ;  ; Short_t fKeylen;  Number of bytes for the key itself. ;  ; Int_t fLeft;  Number of bytes left in current segment. ;  ; TDirectory * fMotherDir;  !pointer to mother directory ;  ; Int_t fNbytes;  Number of bytes for the object on file. ;  ; Int_t fObjlen;  Length of uncompressed object in bytes. ;  ; UShort_t fPidOffset;  !Offset to be added to the pid index in this key/buffer. This is actually saved in the high bits of fSeekPdir ;  ; Long64_t fSeekKey;  Location of object on file. ;  ; Long64_t fSeekPdir;  Location of parent directory on file. ;  ; Int_t fVersion;  Key version identifier. ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions;  TBasket ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBasket.html:18756,allocate,allocated,18756,doc/master/classTBasket.html,https://root.cern,https://root.cern/doc/master/classTBasket.html,1,['allocate'],['allocated']
Energy Efficiency,"ptr};  [fNevBuf] Offset of entries in fBuffer(TKey); generated at runtime. ;  ; bool fHeaderOnly {false};  True when only the basket header must be read/written. ;  ; UChar_t fIOBits {0};  !IO feature flags. Serialized in custom portion of streamer to avoid forward compat issues unless needed. ;  ; Int_t fLast {0};  Pointer to last used byte in basket. ;  ; Int_t fLastWriteBufferSize [3] = {0,0,0};  ! Size of the buffer last three buffers we wrote it to disk ;  ; Int_t fNevBuf {0};  Number of entries in basket. ;  ; Int_t fNevBufSize {0};  Length in Int_t of fEntryOffset OR fixed length of each entry if fEntryOffset is null! ;  ; UChar_t fNextBufferSizeRecord {0};  ! Index into fLastWriteBufferSize of the last buffer written to disk ;  ; bool fOwnsCompressedBuffer {false};  ! Whether or not we own the compressed buffer. ;  ; bool fReadEntryOffset {false};  !Set to true if offset array was read from a file. ;  ; bool fResetAllocation {false};  ! True if last reset re-allocated the memory ;  ;  Protected Attributes inherited from TKey; char * fBuffer;  Object buffer. ;  ; TBuffer * fBufferRef;  Pointer to the TBuffer object. ;  ; TString fClassName;  Object Class name. ;  ; Short_t fCycle;  Cycle number. ;  ; TDatime fDatime;  Date/Time of insertion in file. ;  ; Short_t fKeylen;  Number of bytes for the key itself. ;  ; Int_t fLeft;  Number of bytes left in current segment. ;  ; TDirectory * fMotherDir;  !pointer to mother directory ;  ; Int_t fNbytes;  Number of bytes for the object on file. ;  ; Int_t fObjlen;  Length of uncompressed object in bytes. ;  ; UShort_t fPidOffset;  !Offset to be added to the pid index in this key/buffer. This is actually saved in the high bits of fSeekPdir ;  ; Long64_t fSeekKey;  Location of object on file. ;  ; Long64_t fSeekPdir;  Location of parent directory on file. ;  ; Int_t fVersion;  Key version identifier. ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions;  TBasketS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBasketSQL.html:18019,allocate,allocated,18019,doc/master/classTBasketSQL.html,https://root.cern,https://root.cern/doc/master/classTBasketSQL.html,1,['allocate'],['allocated']
Energy Efficiency,"pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IParametricGradFunctionOneDim::BaseGradFunc, ROOT::Math::IGradFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionOneDim&operator=(const ROOT::Math::IGradientFunctionOneDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientFunctionOneDim(). Virtual Destructor (no operations). {}. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__IGradientFunctionOneDim.html:2237,efficient,efficient,2237,root/html534/ROOT__Math__IGradientFunctionOneDim.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientFunctionOneDim.html,1,['efficient'],['efficient']
Energy Efficiency,"put space. This class uses the ROOT FFT interface to the (free) FFTW3 package (www.fftw.org), and requires that your ROOT installation is compiled with the fftw3=ON (default). Instructions for manually installing fftw below.; Note that the performance in terms of speed and stability of RooFFTConvPdf is vastly superior to that of RooNumConvPdf.; An important feature of FFT convolutions is that the observable is assumed to be cyclical. This is correct for cyclical observables such as angles, but does not hold in general. For non-cyclical variables, wrap-around artifacts may be encountered, e.g. if the PDF is zero at xMin and non-zero at xMax. A rising tail may appear at xMin. This is inevitable when using FFTs. A distribution with 3 bins therefore looks like: ... 0 1 2 0 1 2 0 1 2 ...; Therefore, if bins 0 and 2 are not equal, the FFT sees a cyclical function with a step at the 2|0 boundary, which causes artifacts in Fourier space.; The spillover or discontinuity can be reduced or eliminated by introducing a buffer zone in the FFT calculation. If this feature is activated (on by default), the sampling array for the FFT calculation is extended in both directions, and padded with the lowest/highest bin. Example: original: -5 -4 -3 -2 -1 0 +1 +2 +3 +4 +5; add buffer zones: U U -5 -4 -3 -2 -1 0 +1 +2 +3 +4 +5 O O; rotate: 0 +1 +2 +3 +4 +5 O O U U -5 -4 -3 -2 -1; zonesDefinition zones.py:1; The buffer bins are stripped away when the FFT output values are transferred back to the p.d.f cache. The default buffer size is 10% of the observable domain size, and can be changed with the setBufferFraction() member function.; The RooFFTConvPdf uses caching inherited from a RooAbsCachedPdf. If it is evaluated for a particular value of x, the FFT and convolution is calculated for all bins in the observable space for the given choice of parameters, which are also stored in the cache. Subsequent evaluations for different values of the convolution observable and identical parameters will",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:1847,reduce,reduced,1847,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['reduce'],['reduced']
Energy Efficiency,"puters. The main design goals for the PROOF system are:; Transparency : there should be as little difference as possible between a local ROOT based analysis session and a remote parallel PROOF session, both being interactive and giving the same results.; Scalability : the basic architecture should not put any implicit limitations on the number of computers that can be used in parallel.; Adaptability : the system should be able to adapt itself to variations in the remote environment (changing load on the cluster nodes, network interruptions, etc.).; Being an extension of the ROOT system, PROOF is designed to work on objects in ROOT data stores, though, for the time being, it mainly addresses the case of TTree based object collections.; PROOF is primarily meant as an interactive alternative to batch systems for Central Analysis Facilities and departmental workgroups (Tier-2’s). However, thanks to a multi-tier architecture allowing multiple levels of masters, it can be easily adapted to wide range virtual clusters distributed over geographically separated domains and heterogeneous machines (GRIDs).; While pure interactivity might not always be possible when performing a complicated analysis on a very large data set, PROOF still tries to give the user the interactive experience with something we call “interactive batch”. With “interactive batch” the user can start very long running queries, disconnect the client and at any time, any location and from any computer reconnect to the query to monitor its progress or retrieve the results. This feature gives it a distinct advantage over purely batch based solutions, that only provide an answer once all sub-jobs have been finished. The Multi-tier structure of a PROOF cluster. Details about the PROOF system and the way to use it can be found at 1; The PROOF development is a joint effort between CERN and MIT.; 25 Writing a Graphical User Interface. The ROOT GUI classes support an extensive and rich set of widgets with the Window",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1126191,adapt,adapted,1126191,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['adapt'],['adapted']
Energy Efficiency,"p}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar tolerance = 100 * std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar rho() const; { return fCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html:15287,energy,energy,15287,root/html602/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,4,['energy'],['energy']
Energy Efficiency,"p}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar tolerance = 100 * std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar rho() const; { return fCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html:15287,energy,energy,15287,root/html602/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,4,['energy'],['energy']
Energy Efficiency,"quence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. TObject * ConstructedAt(Int_t idx); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, it is the callers; responsability to insure that the object is returned to a known state,; usually by calling the Clear method on the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Cle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:18445,allocate,allocate,18445,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,4,['allocate'],['allocate']
Energy Efficiency,"r &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Private Member Functions; MsgLogger & Log () const;  . Private Attributes; Float_t fFineFactor;  fine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function ;  ; TH1F * fFirstIterHist;  histogram to be filled in the hidden iteration ;  ; Bool_t fHiddenIteration;  Defines if whats currently running is the. ;  ; TH1F * fHist;  copy of input histogram ;  ; EKernelIter fIter;  iteration number ;  ; EKernelBorder fKDEborder;  The method to take care about ""border"" effects. ;  ; TF1 * fKernel_integ;  the integral of the Kernel function ;  ; MsgLogger * fLogger;  ! message logger ;  ; Float_t fLowerEdge;  the lower edge of the PDF ;  ; Float_t fSigma;  Width of the Kernel function. ;  ; TH1F * fSigmaHist;  contains the Sigmas Widths for adaptive KDE ;  ; Float_t fUpperEdge;  the upper edge of the PDF ;  . #include <TMVA/KDEKernel.h>; Member Enumeration Documentation. ◆ EKernelBorder. enum TMVA::KDEKernel::EKernelBorder. EnumeratorkNoTreatment ; kKernelRenorm ; kSampleMirror . Definition at line 56 of file KDEKernel.h. ◆ EKernelIter. enum TMVA::KDEKernel::EKernelIter. EnumeratorkNonadaptiveKDE ; kAdaptiveKDE . Definition at line 55 of file KDEKernel.h. ◆ EKernelType. enum TMVA::KDEKernel::EKernelType. EnumeratorkNone ; kGauss . Definition at line 54 of file KDEKernel.h. Constructor & Destructor Documentation. ◆ KDEKernel(). TMVA::KDEKernel::KDEKernel ; (; EKernelIter ; kiter = kNonadaptiveKDE, . const TH1 * ; hist = nullptr, . Float_t ; lower_edge = 0., . Float_t ; upper_edge = 1., . EKernelBorder ; kborder = kNoTreatment, . Float_t ; FineFactor = 1. . ). constructor sanity check ; Definition at line 49 of file KDEKernel.cxx. ◆ ~KDEKernel(). TMVA::KDEKernel::~KDEKernel ; (; void ; ). virtual . destructor ; Definition at line",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1KDEKernel.html:2284,adapt,adaptive,2284,doc/master/classTMVA_1_1KDEKernel.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1KDEKernel.html,1,['adapt'],['adaptive']
Energy Efficiency,"r &var, double order, double offset, const char *cutSpec=nullptr, const char *cutRange=nullptr) const;  Return the 'order'-ed moment of observable 'var' in this dataset. ;  ; const TNamed * namePtr () const;  De-duplicated pointer to this object's name. ;  ; virtual Int_t numEntries () const;  Return number of entries in dataset, i.e., count unweighted entries. ;  ; RooAbsData & operator= (const RooAbsData &other);  ; void Print (Option_t *options=nullptr) const override;  This method must be overridden when a class wants to print itself. ;  ; void printClassName (std::ostream &os) const override;  Print class name of dataset. ;  ; void printName (std::ostream &os) const override;  Print name of dataset. ;  ; void printTitle (std::ostream &os) const override;  Print title of dataset. ;  ; void RecursiveRemove (TObject *obj) override;  If one of the TObject we have a referenced to is deleted, remove the reference. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const char *cut) const;  Create a subset of the data set by applying the given cut on the data points. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooArgSet &varSubset, const char *cut=nullptr) const;  Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooArgSet &varSubset, const RooFormulaVar &cutVar) const;  Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  Create a reduced copy of this dataset. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooFormulaVar &cutVar) const;  Create a subset of the data set by applying the given cut on the data points",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:18330,reduce,reduce,18330,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['reduce'],['reduce']
Energy Efficiency,"r *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TRandom::SetSeedvirtual void SetSeed(ULong_t seed=0)Set the random generator seed.Definition TRandom.cxx:615; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TRandom::Rannorvirtual void Rannor(Float_t &a, Float_t &b)Return 2 numbers distributed following a gaussian with mean=0 and sigma=1.Definition TRandom.cxx:507; TSystem::ProcessEventsvirtual Bool_t ProcessEvents()Process pending events (GUI, timers, sockets).Definition TSystem.cxx:416; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::Fillvirtual Int_t Fill()Fill all branches.Definition TTree.cxx:4603; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8385; TTree::BranchTBranch * Branch(const char *name, T *obj, Int_t bufsize=32000, Int_t splitlevel=99)Add a new branch, and infer the data type from the type of obj being passed.Definition TTree.h:353; TTree::LoadTreevirtual Long64_t LoadTree(Long64_t entry)Set current entry.Definition TTree.cxx:6473; TTree::ResetBranchAddressesvirtual void ResetBranchAddresses()Tell all of our branches to drop their current objects and allocate new ones.Definition TTree.cxx:8075; c1return c1Definition legend1.C:41; AuthorThe ROOT Team ; Definition in file hvector.C. tutorialstreehvector.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hvector_8C.html:5844,allocate,allocate,5844,doc/master/hvector_8C.html,https://root.cern,https://root.cern/doc/master/hvector_8C.html,1,['allocate'],['allocate']
Energy Efficiency,"r *uri);  ; virtual void MouseOver (const char *uri);  ; void MoveVertically (TGHtmlElement *p, TGHtmlElement *pLast, int dy);  Move all elements in the given list vertically by the amount dy. ;  ; int ParseText (char *text, const char *index=nullptr);  Appends (or insert at the specified position) the given HTML text to the end of any HTML text that may have been inserted by prior calls to this command. ;  ; void PrintList (TGHtmlElement *first, TGHtmlElement *last);  Print a list of tokens. ;  ; virtual TGFrame * ProcessApplet (TGHtmlInput *);  ; virtual int ProcessFrame ();  ; Bool_t ProcessMessage (Longptr_t, Longptr_t, Longptr_t) override;  Process messages (GUI events) in the html widget. ;  ; virtual char * ProcessScript (TGHtmlScript *);  ; virtual int ProcessToken (TGHtmlElement *, const char *, int);  ; virtual void RadioChanged (const char *name, const char *val);  Emit RadioChanged() signal. ;  ; void ResetBlocks ();  ; virtual char * ResolveUri (const char *uri);  This function resolves the specified URI and returns the result in a newly allocated string. ;  ; void SaveFileAs ();  Save file. ;  ; void SavePrimitive (std::ostream &out, Option_t *="""") override;  Save a html widget as a C++ statement(s) on output stream out. ;  ; void SetBaseUri (const char *uri);  Sets base URI. ;  ; void SetRuleRelief (int relief);  Sets relief mode of html rule. ;  ; void SetTableRelief (int relief);  Sets relief mode of html table. ;  ; virtual void SubmitClicked (const char *val);  Emit SubmitClicked() signal. ;  ; TGHtmlElement * TableDimensions (TGHtmlTable *pStart, int lineWidth);  pStart points to a <table>. ;  ; TGString * TableText (TGHtmlTable *pTable, int flags);  Return text and images from a table as lists. ;  ; void UnderlineLinks (int onoff);  Set/reset html links underline. ;  ;  Public Member Functions inherited from TGView;  TGView (const TGWindow *p=nullptr, UInt_t w=1, UInt_t h=1, Int_t id=-1, UInt_t xMargin=0, UInt_t yMargin=0, UInt_t options=kSunken",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtml.html:5223,allocate,allocated,5223,doc/master/classTGHtml.html,https://root.cern,https://root.cern/doc/master/classTGHtml.html,1,['allocate'],['allocated']
Energy Efficiency,"r . ReturnsVersion of this class ; Definition at line 254 of file TTreeViewer.h. ◆ CloseWindow(). void TTreeViewer::CloseWindow ; (; ). overridevirtual . Close and delete main frame. ; We get here in response to ALT+F4 or a window manager close command. To terminate the application when this happens override this method and call gApplication->Terminate(0) or make a connection to this signal (if after the slot this method should not be called call DontCallClose() in the slot). By default the window will be deleted. ; Reimplemented from TGMainFrame. ◆ Cut(). const char * TTreeViewer::Cut ; (; ). private . ◆ DeclFileName(). static const char * TTreeViewer::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 254 of file TTreeViewer.h. ◆ Delete(). void TTreeViewer::Delete ; (; Option_t * ; option). inlineoverridevirtual . Delete this object. ; Typically called as a command via the interpreter. Normally use ""delete"" operator when object has been allocated on the heap. ; Reimplemented from TGFrame.; Definition at line 213 of file TTreeViewer.h. ◆ Dimension(). Int_t TTreeViewer::Dimension ; (; ). private . ◆ DoError(). void TTreeViewer::DoError ; (; int ; level, . const char * ; location, . const char * ; fmt, . va_list ; va . ); const. overrideprivatevirtual . Interface to ErrorHandler (protected). ; Reimplemented from TObject. ◆ DoRefresh(). void TTreeViewer::DoRefresh ; (; ). ◆ EditExpression(). void TTreeViewer::EditExpression ; (; ). ◆ Empty(). void TTreeViewer::Empty ; (; ). ◆ EmptyAll(). void TTreeViewer::EmptyAll ; (; ). ◆ EmptyBrackets(). const char * TTreeViewer::EmptyBrackets ; (; const char * ; name). private . ◆ En(). const char * TTreeViewer::En ; (; Int_t ; n). private . ◆ Ex(). const char * TTreeViewer::Ex ; (; ). private . ◆ ExecuteCommand(). void TTreeViewer::ExecuteCommand ; (; const char * ; command, . bool ; fast = false . ). ◆ ExecuteDraw(). void TTreeViewer::ExecuteDraw ; (; ). ◆ ExecuteSpid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeViewer.html:51469,allocate,allocated,51469,doc/master/classTTreeViewer.html,https://root.cern,https://root.cern/doc/master/classTTreeViewer.html,1,['allocate'],['allocated']
Energy Efficiency,"r = 0); return boosted MVA response. Double_t GetBoostROCIntegral(Bool_t , TMVA::Types::ETreeType , Bool_t CalcOverlapIntergral = kFALSE); Calculate the ROC integral of a single classifier or even the; whole boosted classifier. The tree type (training or testing; sample) is specified by 'eTT'. If tree type kTraining is set, the original training sample is; used to compute the ROC integral (original weights). - singleMethod - if kTRUE, return ROC integral of single (last; trained) classifier; if kFALSE, return ROC; integral of full classifier. - eTT - tree type (Types::kTraining / Types::kTesting). - CalcOverlapIntergral - if kTRUE, the overlap integral of the; signal/background MVA distributions; is calculated and stored in; 'fOverlap_integral'. void CalcMVAValues(); Calculate MVA values of current method fMethods.back() on; training sample. void MonitorBoost(TMVA::Types::EBoostStage stage, UInt_t methodIdx = 0); fill various monitoring histograms from information of the individual classifiers that; have been boosted.; of course.... this depends very much on the individual classifiers, and so far, only for; Decision Trees, this monitoring is actually implemented. void SetBoostedMethodName(TString methodName); { fBoostedMethodName = methodName; }. Int_t GetBoostNum(); { return fBoostNum; }. void ClearAll(); clean up. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; print fit results. MethodBase* CurrentMethod(); {return fCurrentMethod;}. UInt_t CurrentMethodIdx(); training a single classifier. {return fCurrentMethodIdx;}. Double_t CalcMethodWeight(); calculate weight of single method. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Or Cohen, Jan Therhaag, Eckhard von Toerne » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodBoost.html:22433,monitor,monitoring,22433,root/html534/TMVA__MethodBoost.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodBoost.html,1,['monitor'],['monitoring']
Energy Efficiency,"r >;  CexponentToMultiplier< -128, center >;  CexponentToMultiplier< -256, center >;  CexponentToMultiplier< -384, center >;  CexponentToMultiplier< -512, center >;  CexponentToMultiplier< -640, center >;  CexponentToMultiplier< -768, center >;  CexponentToMultiplier< -896, center >;  CexponentToMultiplier< center, center >;  CexponentToMultiplier<-1024, center >;  CFeldmanCousinsBinomialInterval;  CFeldmanCousinsSorter;  CFileStat_t;  CFontAttributes_t;  CFontMetrics_t;  CFoption_t;  CFUMILI2;  Cfuncptr_and_voidptr_t;  CGaussFunction;  CGcCache_t;  CGCValues_t;  Cgroup;  CGSL_BFGS;  CGSL_BFGS2;  CGSL_FR;  CGSL_NLS;  CGSL_PR;  Chash< std::experimental::basic_string_view< _CharT, _Traits > >;  CHelperOps;  CHEPEVT_DEF;  CHoption_tHistogram option structure ;  CHparam_tHistogram parameters structure ;  CisEqualType;  CisEqualType< T, T >;  CLINEAR;  CMainWindow;  CMandel;  CMandelBase;  CMemInfo_t;  Cmg_callbacks;  ►Cmg_request_info;  Cmg_header;  CMINUIT2;  CMultiDistFree functions adapter needed by UNURAN for multidimensional cont distribution ;  CMYSQL_BIND;  CMYSQL_STMT;  ►CParamHistFunc;  CCacheElem;  CPassiveKeyGrab;  Cpasswd;  CPgSQL_Stmt_t;  CPictureAttributes_t;  ►CPiecewiseInterpolation;  CCacheElem;  CPoint_t;  CProcInfo_t;  CProgressWriter;  CProofServEnv_t;  Cpthread_cond_t;  CPybins_t;  CPydat1_t;  CPydat2_t;  CPydat3_t;  CPydat4_t;  CPydatr_t;  CPyint1_t;  CPyint2_t;  CPyint3_t;  CPyint4_t;  CPyint5_t;  CPyint6_t;  CPyint7_t;  CPyint8_t;  CPyint9_t;  CPyints_t;  CPyjets_t;  CPymssm_t;  CPypars_t;  CPyssmt_t;  CPysubs_t;  CQuartzImage;  CQuartzPixmap;  CQuartzView;  CQuartzWindow;  CRectangle_t;  CRedirectHandle_t;  Credirguard;  Crng_state_st;  CRoo1DMomentMorphFunction1-dimensional morph function between a list of input functions (varlist) as a function of one input parameter (m) ;  CRoo1DTable;  CRoo2DKeysPdfTwo-dimensional kernel estimation PDF ;  ►CRoo2DMomentMorphFunction2-dimensional morph function between a list of function-numbers as a function ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:78457,adapt,adapter,78457,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['adapt'],['adapter']
Energy Efficiency,"r Double_t TMath::Qe ; (; ). constexpr . Elementary charge in \( C \) . ; Definition at line 339 of file TMath.h. ◆ QeUncertainty(). constexpr Double_t TMath::QeUncertainty ; (; ). constexpr . Elementary charge uncertainty. ; Definition at line 346 of file TMath.h. ◆ Quantiles(). void TMath::Quantiles ; (; Int_t ; n, . Int_t ; nprob, . Double_t * ; x, . Double_t * ; quantiles, . Double_t * ; prob, . Bool_t ; isSorted = kTRUE, . Int_t * ; index = nullptr, . Int_t ; type = 7 . ). Computes sample quantiles, corresponding to the given probabilities. ; Parameters. [in]xthe data sample ; [in]nits size ; [out]quantilescomputed quantiles are returned in there ; [in]probprobabilities where to compute quantiles ; [in]nprobsize of prob array ; [in]isSortedis the input array x sorted ? ; [in]indexparameter index ; [in]typemethod to compute (from 1 to 9). NOTE:; When the input is not sorted, an array of integers of size n needs to be allocated. It can be passed by the user in parameter index, or, if not passed, it will be allocated inside the function. Following types are provided:. Discontinuous:; type=1 - inverse of the empirical distribution function; type=2 - like type 1, but with averaging at discontinuities; type=3 - SAS definition: nearest even order statistic. Piecewise linear continuous:; In this case, sample quantiles can be obtained by linear interpolation between the k-th order statistic and p(k). -type=4 - linear interpolation of empirical cdf, p(k)=k/n;; type=5 - a very popular definition, p(k) = (k-0.5)/n;; type=6 - used by Minitab and SPSS, p(k) = k/(n+1);; type=7 - used by S-Plus and R, p(k) = (k-1)/(n-1);; type=8 - resulting sample quantiles are approximately median unbiased regardless of the distribution of x. p(k) = (k-1/3)/(n+1/3);; type=9 - resulting sample quantiles are approximately unbiased, when the sample comes from Normal distribution. p(k)=(k-3/8)/(n+1/4);. default type = 7. References:. Hyndman, R.J and Fan, Y, (1996) ""Sample quantiles in statistica",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:74294,allocate,allocated,74294,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['allocate'],['allocated']
Energy Efficiency,"r Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parameters. ;  ; virtual std::list< double > * binBoundaries (RooAbsRealLValue &obs, double xlo, double xhi) const;  Retrieve bin boundaries if this distribution is binned in obs. ;  ; RooFit::OwningPtr< RooAbsFunc > bindVars (const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) const;  Create an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order). ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a \( \chi^2 \) fit to given histogram. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooLinkedList &cmdList);  Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataSet &xydata, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a 2-D \( \chi^2 \) fit using a series of x ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCBShape.html:14764,adapt,adaptor,14764,doc/master/classRooCBShape.html,https://root.cern,https://root.cern/doc/master/classRooCBShape.html,13,['adapt'],['adaptor']
Energy Efficiency,"r Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parameters. ;  ; virtual std::list< double > * binBoundaries (RooAbsRealLValue &obs, double xlo, double xhi) const;  Retrieve bin boundaries if this distribution is binned in obs. ;  ; RooFit::OwningPtr< RooAbsFunc > bindVars (const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) const;  Create an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order). ;  ; virtual std::string buildCallToAnalyticIntegral (Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) const;  This function defines the analytical integral translation for the class. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a \( \chi^2 \) fit to given histogram. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooLinkedList &cmdList);  Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataSet &xydata, const RooCmdArg &arg1={}, const RooCmdArg &arg2={},",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBreitWigner.html:14134,adapt,adaptor,14134,doc/master/classRooBreitWigner.html,https://root.cern,https://root.cern/doc/master/classRooBreitWigner.html,18,['adapt'],['adaptor']
Energy Efficiency,"r ROOT::Math::PtEtaPhiE4D< ScalarType >::PtEtaPhiE4D ; (; const CoordSystem & ; c). inlineexplicitconstexpr . Generic constructor from any 4D coordinate system implementing Pt(), Eta(), Phi() and E() ; Definition at line 79 of file PtEtaPhiE4D.h. ◆ PtEtaPhiE4D() [4/4]. template<class ScalarType > . ROOT::Math::PtEtaPhiE4D< ScalarType >::PtEtaPhiE4D ; (; const PtEtaPhiE4D< ScalarType > & ; v). inline . copy constructor ; Definition at line 88 of file PtEtaPhiE4D.h. Member Function Documentation. ◆ E(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiE4D< ScalarType >::E ; (; ); const. inline . Definition at line 135 of file PtEtaPhiE4D.h. ◆ Et(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiE4D< ScalarType >::Et ; (; ); const. inline . transverse energy ; transverse energy ; Definition at line 233 of file PtEtaPhiE4D.h. ◆ Et2(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiE4D< ScalarType >::Et2 ; (; ); const. inline . transverse energy squared ; Definition at line 241 of file PtEtaPhiE4D.h. ◆ Eta(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiE4D< ScalarType >::Eta ; (; ); const. inline . Definition at line 133 of file PtEtaPhiE4D.h. ◆ GetCoordinates() [1/2]. template<class ScalarType > . void ROOT::Math::PtEtaPhiE4D< ScalarType >::GetCoordinates ; (; Scalar & ; pt, . Scalar & ; eta, . Scalar & ; phi, . Scalar & ; e . ); const. inline . get internal data into 4 Scalar numbers ; Definition at line 125 of file PtEtaPhiE4D.h. ◆ GetCoordinates() [2/2]. template<class ScalarType > . void ROOT::Math::PtEtaPhiE4D< ScalarType >::GetCoordinates ; (; Scalar ; dest[]); const. inline . get internal data into an array of 4 Scalar numbers ; Definition at line 112 of file PtEtaPhiE4D.h. ◆ M(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiE4D< ScalarType >::M ; (; ); const. inline . invariant mass ; Definition at line 186 of file PtEtaPhiE4D.h. ◆ M2(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiE4D< ScalarType ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1PtEtaPhiE4D.html:5581,energy,energy,5581,doc/master/classROOT_1_1Math_1_1PtEtaPhiE4D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1PtEtaPhiE4D.html,1,['energy'],['energy']
Energy Efficiency,"r a top-level branch) or kObject(p|P) here.; 5298 if ((fStreamerType != -1) &&; 5299 (fStreamerType != TVirtualStreamerInfo::kObjectp) &&; 5300 (fStreamerType != TVirtualStreamerInfo::kObjectP)) {; 5301 Error(""SetAddress"", ""TClonesArray with fStreamerType: %d"", fStreamerType);; 5302 } else if (fStreamerType == -1) {; 5303 // -- We are a top-level branch.; 5304 TClonesArray** pp = (TClonesArray**) fAddress;; 5305 if (!*pp) {; 5306 // -- Caller wants us to allocate the clones array, but they will own it.; 5307 *pp = new TClonesArray(fClonesClass);; 5308 }; 5309 fObject = (char*) *pp;; 5310 } else {; 5311 // -- We are a pointer to a TClonesArray.; 5312 // Note: We do this so that the default constructor,; 5313 // or the i/o constructor can be lazy.; 5314 TClonesArray** pp = (TClonesArray**) fAddress;; 5315 if (!*pp) {; 5316 // -- Caller wants us to allocate the clones array, but they will own it.; 5317 *pp = new TClonesArray(fClonesClass);; 5318 }; 5319 fObject = (char*) *pp;; 5320 }; 5321 }; 5322 } else {; 5323 // -- We have been given a zero address, allocate for top-level only.; 5324 if (fStreamerType == TVirtualStreamerInfo::kObject) {; 5325 // -- We are *not* a top-level branch and we are *not* a pointer to a TClonesArray.; 5326 // Case of an embedded TClonesArray.; 5327 Error(""SetAddress"", ""Embedded TClonesArray given a zero address for branch '%s'"", GetName());; 5328 } else {; 5329 // -- We are either a top-level branch or we are a subbranch which is a pointer to a TClonesArray.; 5330 // Streamer type should be -1 (for a top-level branch) or kObject(p|P) here.; 5331 if ((fStreamerType != -1) &&; 5332 (fStreamerType != TVirtualStreamerInfo::kObjectp) &&; 5333 (fStreamerType != TVirtualStreamerInfo::kObjectP)) {; 5334 Error(""SetAddress"", ""TClonesArray with fStreamerType: %d"", fStreamerType);; 5335 } else if (fStreamerType == -1) {; 5336 // -- We are a top-level branch.; 5337 // Idea: Consider making a zero address not allocate.; 5338 SetBit(kDeleteObject);; 5339 f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:196800,allocate,allocate,196800,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"r cached variables; RooArgSetRooAbsDataStore::_cachedVars; Int_t_curIndex! Index associated with current event; RooAbsDataStore*_curStore! Datastore associated with current event; map<Int_t,RooAbsDataStore*>_dataMap; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; RooCategory*_indexCat; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; Bool_t_ownComps! ; RooArgSetRooAbsDataStore::_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCompositeDataStore(). RooCompositeDataStore(const char* name, const char* title, const RooArgSet& vars, RooCategory& indexCat, map<std::string,RooAbsDataStore*> inputData); Convert map by label to map by index for more efficient internal use. RooCompositeDataStore(const RooCompositeDataStore& other, const char* newname = 0); Convert map by label to map by index for more efficient internal use. RooCompositeDataStore(const RooCompositeDataStore& other, const RooArgSet& vars, const char* newname = 0); Update index category pointer, if it is contained in input argument vars. ~RooCompositeDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Forward fill request to appropriate subset. Double_t sumEntries() const; Forward fill request to appropriate subset. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='idx') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight() const. Double_t weight(Int_t index) const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t isWeighted() const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCompositeDataStore.html:10195,efficient,efficient,10195,root/html532/RooCompositeDataStore.html,https://root.cern,https://root.cern/root/html532/RooCompositeDataStore.html,1,['efficient'],['efficient']
Energy Efficiency,"r cached variables; RooArgSetRooAbsDataStore::_cachedVars; Int_t_curIndex! Index associated with current event; RooAbsDataStore*_curStore! Datastore associated with current event; map<Int_t,RooAbsDataStore*>_dataMap; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; RooCategory*_indexCat; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; Bool_t_ownComps! ; RooArgSetRooAbsDataStore::_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCompositeDataStore(). RooCompositeDataStore(const char* name, const char* title, const RooArgSet& vars, RooCategory& indexCat, map<std::string,RooAbsDataStore*> inputData); Convert map by label to map by index for more efficient internal use. RooCompositeDataStore(const RooCompositeDataStore& other, const char* newname = 0); Convert map by label to map by index for more efficient internal use. RooCompositeDataStore(const RooCompositeDataStore& other, const RooArgSet& vars, const char* newname = 0); Update index category pointer, if it is contained in input argument vars. ~RooCompositeDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); Forward recalculate request to all subsets. Bool_t hasFilledCache() const. void forceCacheUpdate(). Int_t fill(); Forward fill request to appropriate subset. Double_t sumEntries() const; Forward fill request to appropriate subset. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='idx') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight() const. Double_t weight(Int_t index) const. Double_t weightError(RooAbsData::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCompositeDataStore.html:10298,efficient,efficient,10298,root/html534/RooCompositeDataStore.html,https://root.cern,https://root.cern/root/html534/RooCompositeDataStore.html,1,['efficient'],['efficient']
Energy Efficiency,"r call the destructor,; 5419 // either the code will be in a loaded library,; 5420 // or it will be interpreted, otherwise we fail; 5421 // because there is no destructor code at all.; 5422 if (dtorOnly) {; 5423 gCling->ClassInfo_Destruct(fClassInfo,p);; 5424 } else {; 5425 gCling->ClassInfo_Delete(fClassInfo,p);; 5426 }; 5427 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5428 // There is no dictionary at all, so this is an emulated; 5429 // class; however we do have the services of a collection proxy,; 5430 // so this is an emulated STL class.; 5431 GetCollectionProxy()->Destructor(p, dtorOnly);; 5432 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5433 // There is no dictionary at all and we do not have; 5434 // the services of a collection proxy available, so; 5435 // use the streamer info to approximate calling a; 5436 // destructor.; 5437 ; 5438 Bool_t inRepo = kTRUE;; 5439 Bool_t currentVersion = kFALSE;; 5440 ; 5441 // Was this object allocated through TClass?; 5442 Version_t objVer = -1;; 5443 {; 5444 R__LOCKGUARD2(fOVRMutex);; 5445 RepoCont_t::iterator iter = fObjectVersionRepository.find(p);; 5446 if (iter == fObjectVersionRepository.end()) {; 5447 // No, it wasn't, skip special version handling.; 5448 //Error(""Destructor2"", ""Attempt to delete unregistered object of class '%s' at address %p!"", GetName(), p);; 5449 inRepo = kFALSE;; 5450 } else {; 5451 //objVer = iter->second;; 5452 for (; (iter != fObjectVersionRepository.end()) && (iter->first == p); ++iter) {; 5453 objVer = iter->second;; 5454 if (objVer == fClassVersion) {; 5455 currentVersion = kTRUE;; 5456 break;; 5457 }; 5458 }; 5459 }; 5460 }; 5461 ; 5462 if (!inRepo || currentVersion) {; 5463 // The object was allocated using code for the same class version; 5464 // as is loaded now. We may proceed without worry.; 5465 TVirtualStreamerInfo* si = GetStreamerInfo();; 5466 if (si) {; 5467 si->Destructor(p, dtorOnly);; 5468 } else {; 5469 Error(""Destructor"", ""No streamer info availa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:208009,allocate,allocated,208009,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"r call the destructor,; 5486 // either the code will be in a loaded library,; 5487 // or it will be interpreted, otherwise we fail; 5488 // because there is no destructor code at all.; 5489 if (dtorOnly) {; 5490 gCling->ClassInfo_Destruct(fClassInfo,p);; 5491 } else {; 5492 gCling->ClassInfo_Delete(fClassInfo,p);; 5493 }; 5494 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5495 // There is no dictionary at all, so this is an emulated; 5496 // class; however we do have the services of a collection proxy,; 5497 // so this is an emulated STL class.; 5498 GetCollectionProxy()->Destructor(p, dtorOnly);; 5499 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5500 // There is no dictionary at all and we do not have; 5501 // the services of a collection proxy available, so; 5502 // use the streamer info to approximate calling a; 5503 // destructor.; 5504 ; 5505 Bool_t inRepo = kTRUE;; 5506 Bool_t currentVersion = kFALSE;; 5507 ; 5508 // Was this object allocated through TClass?; 5509 Version_t objVer = -1;; 5510 {; 5511 R__LOCKGUARD2(fOVRMutex);; 5512 RepoCont_t::iterator iter = fObjectVersionRepository.find(p);; 5513 if (iter == fObjectVersionRepository.end()) {; 5514 // No, it wasn't, skip special version handling.; 5515 //Error(""Destructor2"", ""Attempt to delete unregistered object of class '%s' at address %p!"", GetName(), p);; 5516 inRepo = kFALSE;; 5517 } else {; 5518 //objVer = iter->second;; 5519 for (; (iter != fObjectVersionRepository.end()) && (iter->first == p); ++iter) {; 5520 objVer = iter->second;; 5521 if (objVer == fClassVersion) {; 5522 currentVersion = kTRUE;; 5523 break;; 5524 }; 5525 }; 5526 }; 5527 }; 5528 ; 5529 if (!inRepo || currentVersion) {; 5530 // The object was allocated using code for the same class version; 5531 // as is loaded now. We may proceed without worry.; 5532 TVirtualStreamerInfo* si = GetStreamerInfo();; 5533 if (si) {; 5534 si->Destructor(p, dtorOnly);; 5535 } else {; 5536 Error(""Destructor"", ""No streamer info availa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:210760,allocate,allocated,210760,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"r convenience there are two more set functions SetPtEtaPhiE(pt,eta,phi,e);; and SetPtEtaPhiM(pt,eta,phi,m);. Arithmetic and comparison operators; The TLorentzVector class provides operators to add, subtract or; compare four-vectors:;   v3 = -v1;;   v1 = v2+v3;;   v1+= v3;;   v1 = v2 + v3;;   v1-= v3;;   if (v1 == v2) {...};   if(v1 != v3) {...}. Magnitude/Invariant mass, beta, gamma, scalar product; The scalar product of two four-vectors is calculated with the (-,-,-,+); metric,;    i.e.   s = v1*v2 = t1*t2-x1*x2-y1*y2-z1*z2; The magnitude squared mag2 of a four-vector is therfore:;           mag2; = v*v = t*t-x*x-y*y-z*z; It mag2 is negative mag = -Sqrt(-mag*mag). The member; functions are:;   Double_t s, s2;;   s  = v1.Dot(v2);     // scalar; product;   s  = v1*v2;         // scalar product;   s2 = v.Mag2();   or    s2 = v.M2();;   s  = v.Mag();         ; s  = v.M();; Since in case of momentum and energy the magnitude has the meaning of; invariant mass TLorentzVector provides the more meaningful aliases; M2() and M();; The member functions Beta() and Gamma() returns; beta and gamma = 1/Sqrt(1-beta*beta). Lorentz boost; A boost in a general direction can be parameterized with three parameters; which can be taken as the components of a three vector b = (bx,by,bz).; With;   x = (x,y,z) and gamma = 1/Sqrt(1-beta*beta) (beta being the module of vector b),; an arbitary active Lorentz boost transformation (from the rod frame; to the original frame) can be written as:;           x; = x' + (gamma-1)/(beta*beta) * (b*x') * b +; gamma * t' * b;           t; = gamma (t'+ b*x').; The member function Boost() performs a boost transformation; from the rod frame to the original frame. BoostVector() returns; a TVector3 of the spatial components divided by the time component:;   TVector3 b;;   v.Boost(bx,by,bz);;   v.Boost(b);;   b = v.BoostVector();   // b=(x/t,y/t,z/t). Rotations; There are four sets of functions to rotate the TVector3 component; of a TLorentzVector:. rotation aro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLorentzVector.html:4427,energy,energy,4427,root/html528/TLorentzVector.html,https://root.cern,https://root.cern/root/html528/TLorentzVector.html,6,['energy'],['energy']
Energy Efficiency,r for PROOF; TProofDrawEntryList A Selectoor to fill a TEntryList from TTree::Draw; TProofDrawEventList Tree drawing selector for PROOF; TProofDrawGraph Tree drawing selector for PROOF; TProofDrawHist Tree drawing selector for PROOF; TProofDrawListOfGraphs Tree drawing selector for PROOF; TProofDrawListOfGraphs::Point3D_t ; TProofDrawListOfPolyMarkers3D Tree drawing selector for PROOF; TProofDrawListOfPolyMarkers3D::Point4D_t ; TProofDrawPolyMarker3D Tree drawing selector for PROOF; TProofDrawProfile Tree drawing selector for PROOF; TProofDrawProfile2D Tree drawing selector for PROOF; TProofLimitsFinder Find and communicate best axis limits; TProofLite PROOF-Lite control class; TProofLog PROOF session log handler; TProofLogElem PROOF session log element; TProofMgr Abstract PROOF manager interface; TProofMgrLite XrdProofd PROOF manager interface; TProofMonSender Interface for PROOF monitoring; TProofMonSenderML Interface for PROOF monitoring; TProofMonSenderSQL Interface for PROOF monitoring; TProofNodeInfo Class describing a PROOF node; TProofNodes Node and worker information; TProofOutputFile Wrapper class to steer the merging of files produced on workers; TProofOutputList Output list specific TList derivation; TProofPerfAnalysis Set of tools to analyse the performance tree; TProofPlayer Basic PROOF player; TProofPlayerLite PROOF player running in PROOF-Lite; TProofPlayerLocal PROOF player running on client; TProofPlayerRemote PROOF player running on master server; TProofPlayerSlave PROOF player running on slave server; TProofPlayerSuperMaster PROOF player running on super master; TProofProgressDialog PROOF progress dialog; TProofProgressInfo Progress information; TProofProgressLog Class implementing a log graphic box; TProofProgressMemoryPlot PROOF progress memory plots; TProofProgressStatus Proof progress status class; TProofQueryResult Class describing a PROOF query; TProofResources Abstract class describing PROOF resources; TProofResourcesStatic Class to handle ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:122818,monitor,monitoring,122818,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,3,['monitor'],['monitoring']
Energy Efficiency,r for PROOF; TProofDrawEntryList A Selectoor to fill a TEntryList from TTree::Draw; TProofDrawEventList Tree drawing selector for PROOF; TProofDrawGraph Tree drawing selector for PROOF; TProofDrawHist Tree drawing selector for PROOF; TProofDrawListOfGraphs Tree drawing selector for PROOF; TProofDrawListOfGraphs::Point3D_t ; TProofDrawListOfPolyMarkers3D Tree drawing selector for PROOF; TProofDrawListOfPolyMarkers3D::Point4D_t ; TProofDrawPolyMarker3D Tree drawing selector for PROOF; TProofDrawProfile Tree drawing selector for PROOF; TProofDrawProfile2D Tree drawing selector for PROOF; TProofLimitsFinder Find and communicate best axis limits; TProofLite PROOF-Lite control class; TProofLog PROOF session log handler; TProofLogElem PROOF session log element; TProofMgr Abstract PROOF manager interface; TProofMgrLite XrdProofd PROOF manager interface; TProofMonSender Interface for PROOF monitoring; TProofMonSenderML Interface for PROOF monitoring; TProofMonSenderSQL Interface for PROOF monitoring; TProofNodeInfo Class describing a PROOF node; TProofNodes Node and worker information; TProofOutputFile Wrapper class to steer the merging of files produced on workers; TProofOutputList Output list specific TList derivation; TProofPlayer Basic PROOF player; TProofPlayerLite PROOF player running in PROOF-Lite; TProofPlayerLocal PROOF player running on client; TProofPlayerRemote PROOF player running on master server; TProofPlayerSlave PROOF player running on slave server; TProofPlayerSuperMaster PROOF player running on super master; TProofProgressDialog PROOF progress dialog; TProofProgressInfo Progress information; TProofProgressLog Class implementing a log graphic box; TProofProgressMemoryPlot PROOF progress memory plots; TProofProgressStatus Proof progress status class; TProofQueryResult Class describing a PROOF query; TProofResources Abstract class describing PROOF resources; TProofResourcesStatic Class to handle PROOF static config; TProofServ PROOF Server Application Interfac,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:118454,monitor,monitoring,118454,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,1,['monitor'],['monitoring']
Energy Efficiency,"r model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveJetCone(const Text_t* n = ""TEveJetCone"", const Text_t* t = """"); Constructor. void ComputeBBox(); Compute bounding-box of the data. TClass* ProjectedClass(const TEveProjection* p) const; Virtual from TEveProjectable, returns TEveJetConeProjected class. Int_t AddCone(Float_t eta, Float_t phi, Float_t cone_r, Float_t length = 0); Add jet cone.; parameters are :; * (eta,phi) : of the center/leading particle; * cone_r : cone radius in eta-phi space; * length : length of the cone; * if cylinder is set and length is adapted to cylinder.; - if length is given, it will be used as scalar factor; * if cylinder is not set, length is used as length of the cone; Return 0 on sucess. Int_t AddEllipticCone(Float_t eta, Float_t phi, Float_t reta, Float_t rphi, Float_t length = 0); Add jet cone.; parameters are :; * (eta,phi) : of the center/leading particle; * (reta, rphi) : radius of cone in eta-phi space; * length : length of the cone; * if cylinder is set and length is adapted to cylinder.; - if length is given, it will be used as scalar factor; * if cylinder is not set, length is used as length of the cone; Returns 0 on sucess. TEveVector CalcEtaPhiVec(Float_t eta, Float_t phi) const; Fill TEveVector with eta and phi, magnitude 1. TEveVector CalcBaseVec(Float_t eta, Float_t phi) const; Returns point on the base of the cone with given eta and phi. TEveVector CalcBaseVec(Float_t alpha) const; Returns point on the base of the cone with internal angle alpha:; alpha = 0 -> max eta, alpha = pi/2 -> max phi, ... Bool_t IsInTransitionRegion() const; Returns true if the cone is in barrel / endcap transition region. TEveJetCone(const TEveJetCone& ). TEveJetCone& operator=(const TEveJetCone& ). virtual ~TEveJetCone(); {}. void SetApex(const TEveVector& a); { fApex = a; }. void SetCylinder(Float_t r, Float_t z); { fLimits.Set(0, r, z); fThetaC = fLimits.Theta(); }. void SetRadius(F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveJetCone.html:23007,adapt,adapted,23007,root/html528/TEveJetCone.html,https://root.cern,https://root.cern/root/html528/TEveJetCone.html,4,['adapt'],['adapted']
Energy Efficiency,"r normalization integrals for MINUIT to succeed.; //; RooAbsReal::defaultIntegratorConfig()->setEpsAbs(1e-6);; RooAbsReal::defaultIntegratorConfig()->setEpsRel(1e-6);; ; // N u m e r i c i n t e g r a t i o n o f l a n d a u p d f; // ------------------------------------------------------------------; ; RooRealVar x(""x"", ""x"", -10, 10);; RooLandau landau(""landau"", ""landau"", x, 0.0, 0.1);; ; // Disable analytic integration from demonstration purposes; landau.forceNumInt(true);; ; // Activate debug-level messages for topic integration to be able to follow actions below; RooMsgService::instance().addStream(DEBUG, Topic(Integration));; ; // Calculate integral over landau with default choice of numeric integrator; std::unique_ptr<RooAbsReal> intLandau{landau.createIntegral(x)};; double val = intLandau->getVal();; cout << "" [1] int_dx landau(x) = "" << setprecision(15) << val << endl;; ; // S a m e w i t h c u s t o m c o n f i g u r a t i o n; // -----------------------------------------------------------; ; // Construct a custom configuration which uses the adaptive Gauss-Kronrod technique; // for closed 1D integrals; RooNumIntConfig customConfig(*RooAbsReal::defaultIntegratorConfig());; #ifdef R__HAS_MATHMORE; customConfig.method1D().setLabel(""RooAdaptiveGaussKronrodIntegrator1D"");; #else; Warning(""rf901_numintconfig"",""ROOT is built without Mathmore (GSL) support. Cannot use RooAdaptiveGaussKronrodIntegrator1D"");; #endif; ; // Calculate integral over landau with custom integral specification; std::unique_ptr<RooAbsReal> intLandau2{landau.createIntegral(x, NumIntConfig(customConfig))};; double val2 = intLandau2->getVal();; cout << "" [2] int_dx landau(x) = "" << val2 << endl;; ; // A d j u s t i n g d e f a u l t c o n f i g f o r a s p e c i f i c p d f; // -------------------------------------------------------------------------------------; ; // Another possibility: associate custom numeric integration configuration as default for object 'landau'; landau.setIntegratorConf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf901__numintconfig_8C.html:2604,adapt,adaptive,2604,doc/master/rf901__numintconfig_8C.html,https://root.cern,https://root.cern/doc/master/rf901__numintconfig_8C.html,1,['adapt'],['adaptive']
Energy Efficiency,"r of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TBuffer*TTree::fTransientBuffer! Pointer to the current transient buffer.; TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tTTree::fUpdateUpdate frequency for EntryLoop; TList*TTree::fUserInfopointer to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static Int_tTTree::fgBranchStyleOld/New branch style; static Long64_tTTree::fgMaxTreeSizeMaximum size of a file containg a Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNtupleD(); Default constructor for Ntuple*-*-*-*-*-*-*-*-; *-* ==============================. TNtupleD(const char* name, const char* title, const char* varlist, Int_t bufsize = 32000); Create an Ntuple*-*-; *-* ================; The parameter varlist describes the list of the ntuple variables; separated by a colon:; example: ""x:y:z:energy""; For each variable in the list a separate branch is created. NOTE:; -Use TTree to create branches with variables of different data types.; -Use TTree when the number of branches is large (> 100).; -. ~TNtupleD(); Default destructor for an Ntuple*-*-*-*-*-*-; *-* ================================. void ResetBranchAddress(TBranch* ); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void ResetBranchAddresses(); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void Browse(TBrowser* b); Browse content. Int_t Fill(); -*-*Fill a Ntuple with current values in fArgs; *-* ==========================================; Note that this function is protected.; Currently called only by TChain::Merge. Int_t Fill(const Double_t* x); Fill a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TNtupleD.html:25411,energy,energy,25411,root/html530/TNtupleD.html,https://root.cern,https://root.cern/root/html530/TNtupleD.html,3,['energy'],['energy']
Energy Efficiency,"r of sample names, used to build the morph func ;  ; RooAbsReal * getSampleWeight (const char *name);  retrieve the weight (prefactor) of a sample with the given name ;  ; double getScale ();  get energy scale of the EFT expansion ;  ; RooProduct * getSumElement (const char *name) const;  return the RooProduct that is the element of the RooRealSumPdfi corresponding to the given sample name ;  ; bool hasParameter (const char *paramname) const;  check if a parameter of the given name is contained in the list of known parameters ;  ; void insert (RooWorkspace *ws);  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override;  check if this PDF is a binned distribution in the given observable ;  ; bool isCouplingUsed (const char *couplname);  check if there is any morphing power provided for the given coupling morphing power is provided as soon as any two samples provide different, non-zero values for this coupling ;  ; bool isParameterConstant (const char *paramname) const;  return true if the parameter with the given name is set constant, false otherwise ;  ; bool isParameterUsed (const char *paramname) const;  check if there is any morphing power provided for the given parameter morphing power is provided as soon as any two samples provide different, non-zero values for this parameter ;  ; int nParameters () const;  return the number of parameters in this morphing function ;  ; int nPolynomials () const;  return the number of samples in this morphing function ;  ; int nSamples () const;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &, double, double) const override;  retrieve the sample Hint ;  ; void printCouplings () const;  print a set of couplings ;  ; void printEvaluation () const;  print the contributing samples and their respective weights ;  ; void printFlags () const;  print the flags and their current values ;  ; void printMetaArgs (std::ostream &os) const override;  Retrieve the matrix of coefficients.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLagrangianMorphFunc.html:9653,power,power,9653,doc/master/classRooLagrangianMorphFunc.html,https://root.cern,https://root.cern/doc/master/classRooLagrangianMorphFunc.html,2,['power'],['power']
Energy Efficiency,"r previous (smaller); 1301/// a given x; 1302///; 1303/// next = kTRUE : next larger; 1304/// next = kFALSE : previous smaller; 1305///; 1306/// Used by the autobin power of 2 algorithm; 1307 ; 1308inline Double_t TH1::AutoP2GetPower2(Double_t x, Bool_t next); 1309{; 1310 Int_t nn;; 1311 Double_t f2 = std::frexp(x, &nn);; 1312 return ((next && x > 0.) || (!next && x <= 0.)) ? std::ldexp(std::copysign(1., f2), nn); 1313 : std::ldexp(std::copysign(1., f2), --nn);; 1314}; 1315 ; 1316////////////////////////////////////////////////////////////////////////////////; 1317/// Auxiliary function to get the next power of 2 integer value larger then n; 1318///; 1319/// Used by the autobin power of 2 algorithm; 1320 ; 1321inline Int_t TH1::AutoP2GetBins(Int_t n); 1322{; 1323 Int_t nn;; 1324 Double_t f2 = std::frexp(n, &nn);; 1325 if (TMath::Abs(f2 - .5) > 0.001); 1326 return (Int_t)std::ldexp(1., nn);; 1327 return n;; 1328}; 1329 ; 1330////////////////////////////////////////////////////////////////////////////////; 1331/// Buffer-based estimate of the histogram range using the power of 2 algorithm.; 1332///; 1333/// Used by the autobin power of 2 algorithm.; 1334///; 1335/// Works on arguments (min and max from fBuffer) and internal inputs: fXmin,; 1336/// fXmax, NBinsX (from fXaxis), ...; 1337/// Result save internally in fXaxis.; 1338///; 1339/// Overloaded by TH2 and TH3.; 1340///; 1341/// Return -1 if internal inputs are inconsistent, 0 otherwise.; 1342 ; 1343Int_t TH1::AutoP2FindLimits(Double_t xmi, Double_t xma); 1344{; 1345 // We need meaningful raw limits; 1346 if (xmi >= xma); 1347 return -1;; 1348 ; 1349 THLimitsFinder::GetLimitsFinder()->FindGoodLimits(this, xmi, xma);; 1350 Double_t xhmi = fXaxis.GetXmin();; 1351 Double_t xhma = fXaxis.GetXmax();; 1352 ; 1353 // Now adjust; 1354 if (TMath::Abs(xhma) > TMath::Abs(xhmi)) {; 1355 // Start from the upper limit; 1356 xhma = TH1::AutoP2GetPower2(xhma);; 1357 xhmi = xhma - TH1::AutoP2GetPower2(xhma - xhmi);; 1358 } else {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:52549,power,power,52549,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['power'],['power']
Energy Efficiency,"r server responded. Int_t Ping(TProof::ESlaves list); Ping PROOF slaves. Returns the number of slaves that responded. void Touch(); Ping PROOF slaves. Returns the number of slaves that responded. void Print(Option_t* option = """") const; Print status of PROOF cluster. Int_t HandleOutputOptions(TString& opt, TString& target, Int_t action); Extract from opt information about output handling settings.; The understood keywords are:; of=<file>, outfile=<file> output file location; ds=<dsname>, dataset=<dsname> dataset name ('of' and 'ds' are; mutually exclusive,execution stops; if both are found); sft[=<opt>], savetofile[=<opt>] control saving to file. For 'mvf', the <opt> integer has the following meaning:; <opt> = <how>*10 + <force>; <force> = 0 save to file if memory threshold is reached; (the memory threshold is set by the cluster; admin); in case an output file is defined, the; files are merged at the end;; 1 save results to file.; <how> = 0 save at the end of the query; 1 save results after each packet (to reduce the; loss in case of crash). Setting 'ds' automatically sets 'mvf=1'; it is still possible to set 'mvf=11'; to save results after each packet. The separator from the next option is either a ' ' or a ';'. All recognized settings are removed from the input string opt.; If action == 0, set up the output file accordingly, if action == 1 clean related; output file settings.; If the final target file is local then 'target' is set to the final local path; when action == 0 and used to retrieve the file with TFile::Cp when action == 1. Output file settings are in the form. <previous_option>of=name <next_option>; <previous_option>outfile=name,...;<next_option>. The separator from the next option is either a ' ' or a ';'; Called interanally by TProof::Process. Returns 0 on success, -1 on error. void SetFeedback(TString& opt, TString& optfb, Int_t action); Extract from opt in optfb information about wanted feedback settings.; Feedback are removed from the input string ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:50056,reduce,reduce,50056,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,3,['reduce'],['reduce']
Energy Efficiency,"r split-class branch, base class branch, data member branch, or top-level branch. which do not have a branch count and are not a counter. ; Definition at line 4536 of file TBranchElement.cxx. ◆ ReadLeavesMemberBranchCount(). void TBranchElement::ReadLeavesMemberBranchCount ; (; TBuffer & ; b). protected . Read leaves into i/o buffers for this branch. ; For split-class branch, base class branch, data member branch, or top-level branch. which do have a branch count and are not a counter. ; Definition at line 4574 of file TBranchElement.cxx. ◆ ReadLeavesMemberCounter(). void TBranchElement::ReadLeavesMemberCounter ; (; TBuffer & ; b). protected . Read leaves into i/o buffers for this branch. ; For split-class branch, base class branch, data member branch, or top-level branch. which do not have a branch count and are a counter. ; Definition at line 4611 of file TBranchElement.cxx. ◆ ReleaseObject(). void TBranchElement::ReleaseObject ; (; ). protected . Delete any object we may have allocated on a previous call to SetAddress. ; Definition at line 4672 of file TBranchElement.cxx. ◆ Reset(). void TBranchElement::Reset ; (; Option_t * ; option = """"). overridevirtual . Reset a Branch. ; Existing i/o buffers are deleted. Entries, max and min are reset. ; Reimplemented from TBranch.; Definition at line 4752 of file TBranchElement.cxx. ◆ ResetAddress(). void TBranchElement::ResetAddress ; (; ). overridevirtual . Set branch address to zero and free all allocated memory. ; Reimplemented from TBranch.; Definition at line 4780 of file TBranchElement.cxx. ◆ ResetAfterMerge(). void TBranchElement::ResetAfterMerge ; (; TFileMergeInfo * ; info). overridevirtual . Reset a Branch after a Merge operation (drop data but keep customizations) ; Reimplemented from TBranch.; Definition at line 4767 of file TBranchElement.cxx. ◆ ResetDeleteObject(). void TBranchElement::ResetDeleteObject ; (; ). virtual . Release ownership of any allocated objects. ; Note: This interface was added so that clon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:64354,allocate,allocated,64354,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,1,['allocate'],['allocated']
Energy Efficiency,"r the qry-th query in fQueries. ;  ; Int_t SavePerfTree (const char *pf=0, const char *qref=0);  Save performance information from TPerfStats to file 'pf'. ;  ; void SendDataSetStatus (const char *msg, UInt_t n, UInt_t tot, Bool_t st);  Send or notify data set status. ;  ; Bool_t SendingLogToWindow () const;  ; void SendLogToWindow (Bool_t mode);  ; void SetActive (Bool_t=kTRUE);  ; virtual void SetAlias (const char *alias="""");  Set an alias for this session. ;  ; void SetDataPoolUrl (const char *url);  ; virtual Int_t SetDataSetTreeName (const char *dataset, const char *treename);  Set/Change the name of the default tree. ;  ; void SetDrawFeedbackOption (TDrawFeedback *f, Option_t *opt);  Set draw feedback option. ;  ; void SetInputDataFile (const char *datafile);  Set the file to be used to optimally distribute the input data objects. ;  ; void SetLogLevel (Int_t level, UInt_t mask=TProofDebug::kAll);  Set server logging level. ;  ; void SetManager (TProofMgr *mgr);  Set manager and schedule its destruction after this for clean operations. ;  ; void SetMaxDrawQueries (Int_t max);  Set max number of draw queries whose results are saved. ;  ; Int_t SetParallel (Int_t nodes=-1, Bool_t random=kFALSE);  Tell PROOF how many slaves to use in parallel. ;  ; void SetParameter (const char *par, const char *value);  Set input list parameter. ;  ; void SetParameter (const char *par, Double_t value);  Set an input list parameter. ;  ; void SetParameter (const char *par, Int_t value);  Set an input list parameter. ;  ; void SetParameter (const char *par, Long64_t value);  Set an input list parameter. ;  ; void SetParameter (const char *par, Long_t value);  Set an input list parameter. ;  ; void SetPerfTree (const char *pf=""perftree.root"", Bool_t withWrks=kFALSE);  Enable/Disable saving of the performance tree. ;  ; void SetPrintProgress (PrintProgress_t pp);  ; void SetProgressDialog (Bool_t on=kTRUE);  Enable/Disable the graphic progress dialog. ;  ; void SetQueryMode (EQueryM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:18065,schedul,schedule,18065,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,3,['schedul'],['schedule']
Energy Efficiency,r this branch.Definition TBranchElement.cxx:1646; TBranchElement::GetClonesNamevirtual const char * GetClonesName() constDefinition TBranchElement.h:188; TBranchElement::GetClassvirtual TClass * GetClass() constDefinition TBranchElement.h:187; TBranchElement::fMaximumInt_t fMaximumMaximum entries for a TClonesArray or variable array.Definition TBranchElement.h:80; TBranchElement::ReadLeavesMemberCountervoid ReadLeavesMemberCounter(TBuffer &b)Read leaves into i/o buffers for this branch.Definition TBranchElement.cxx:4611; TBranchElement::fBranchIDInt_t fBranchID! ID number assigned by a TRefTable.Definition TBranchElement.h:97; TBranchElement::FindLeafTLeaf * FindLeaf(const char *name) overrideFind the leaf corresponding to the name 'searchname'.Definition TBranchElement.cxx:1872; TBranchElement::fIteratorsTVirtualCollectionIterators * fIterators! holds the iterators when the branch is of fType==4.Definition TBranchElement.h:101; TBranchElement::ReleaseObjectvoid ReleaseObject()Delete any object we may have allocated on a previous call to SetAddress.Definition TBranchElement.cxx:4672; TBranchElement::fTargetClassTClassRef fTargetClass! Reference to the target in-memory classDefinition TBranchElement.h:91; TBranchElement::Browsevoid Browse(TBrowser *b) overrideBrowse the branch content.Definition TBranchElement.cxx:1032; TBranchElement::FillLeavesMemberBranchCountvoid FillLeavesMemberBranchCount(TBuffer &b)Write leaves into i/o buffers for this branch.Definition TBranchElement.cxx:1676; TBranchElement::EBranchElementTypeEBranchElementTypeDefinition TBranchElement.h:238; TBranchElement::kClonesNode@ kClonesNodeDefinition TBranchElement.h:246; TBranchElement::kClonesMemberNode@ kClonesMemberNodeDefinition TBranchElement.h:248; TBranchElement::kObjectNode@ kObjectNodeDefinition TBranchElement.h:245; TBranchElement::kSTLNode@ kSTLNodeDefinition TBranchElement.h:247; TBranchElement::kLeafNode@ kLeafNodeDefinition TBranchElement.h:239; TBranchElement::kSTLMemberNode@ kSTLMem,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8h_source.html:34186,allocate,allocated,34186,doc/master/TBranchElement_8h_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html,1,['allocate'],['allocated']
Energy Efficiency,"r this branch.Definition TBranchElement.cxx:1646; TBranchElement::GetClonesNamevirtual const char * GetClonesName() constDefinition TBranchElement.h:188; TBranchElement::GetClassvirtual TClass * GetClass() constDefinition TBranchElement.h:187; TBranchElement::fMaximumInt_t fMaximumMaximum entries for a TClonesArray or variable array.Definition TBranchElement.h:80; TBranchElement::ReadLeavesMemberCountervoid ReadLeavesMemberCounter(TBuffer &b)Read leaves into i/o buffers for this branch.Definition TBranchElement.cxx:4611; TBranchElement::fBranchIDInt_t fBranchID! ID number assigned by a TRefTable.Definition TBranchElement.h:97; TBranchElement::FindLeafTLeaf * FindLeaf(const char *name) overrideFind the leaf corresponding to the name 'searchname'.Definition TBranchElement.cxx:1872; TBranchElement::fIteratorsTVirtualCollectionIterators * fIterators! holds the iterators when the branch is of fType==4.Definition TBranchElement.h:101; TBranchElement::ReleaseObjectvoid ReleaseObject()Delete any object we may have allocated on a previous call to SetAddress.Definition TBranchElement.cxx:4672; TBranchElement::fTargetClassTClassRef fTargetClass! Reference to the target in-memory classDefinition TBranchElement.h:91; TBranchElement::Browsevoid Browse(TBrowser *b) overrideBrowse the branch content.Definition TBranchElement.cxx:1032; TBranchElement::FillLeavesMemberBranchCountvoid FillLeavesMemberBranchCount(TBuffer &b)Write leaves into i/o buffers for this branch.Definition TBranchElement.cxx:1676; TBranchElement::IsFolderbool IsFolder() const overrideReturn true if more than one leaf, false otherwise.Definition TBranchElement.cxx:3758; TBranchElement::SetMissingvirtual void SetMissing()Set offset of the object (to which the data member represented by this branch belongs) inside its con...Definition TBranchElement.cxx:5611; TBranchElement::fClonesNameTString fClonesNameName of class in TClonesArray (if any)Definition TBranchElement.h:62; TBranchElement::fBranchCountTBranchElement ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:268127,allocate,allocated,268127,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"r to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Double_tfAdaBoostBetaADA boost parameter, default is 1; vector<TH1*>fBTrainBgdMVAHist; vector<TH1*>fBTrainSigMVAHist; Double_tfBaggedSampleFractionrel.Size of bagged sample; UInt_tfBoostNumNumber of times the classifier is boosted; TStringfBoostTypestring specifying the boost type; Double_tfBoostWeightthe weight used to boost the next classifier; TStringfBoostedMethodNamedetails of the boosted classifier; TStringfBoostedMethodOptionsoptions; TStringfBoostedMethodTitletitle; TMVA::DataSetManager*fDataSetManagerDSMTEST; Bool_tfDetailedMonitoringproduce detailed monitoring histograms (boost-wise); Bool_tfHistoricBoolOptionhistoric variable, only needed for ""CompatibilityOptions""; TStringfHistoricOptionhistoric variable, only needed for ""CompatibilityOptions""; vector<Float_t>*fMVAvaluesmva values for the last trained method; Double_tfMethodErrorestimation of the level error of the classifier; Bool_tfMonitorBoostedMethodmonitor the MVA response of every classifier; TTree*fMonitorTreetree to monitor values during the boosting; Double_tfOverlap_integral; Double_tfROC_trainingroc integral of last trained method (on training sample); UInt_tfRandomSeedseed for random number generator used for bagging; vector<TH1*>fTestBgdMVAHist; vector<TH1*>fTestSigMVAHist; vector<TH1*>fTrainBgdMVAHist; vector<TH1*>fTrainSigMVAHist; TStringfTransformStringmin and max values for the classifier response. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodBoost(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null). MethodBoost(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = __null). ~MethodBoost( void ); d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodBoost.html:20032,monitor,monitoring,20032,root/html602/TMVA__MethodBoost.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodBoost.html,4,['monitor'],"['monitor', 'monitoring']"
Energy Efficiency,"r to the created sub-directory or to the top sub-directory of the hierarchy (in the above example, the returned TDirectory * always points to ""a""). ; Reimplemented from TDirectory.; Definition at line 1249 of file TDirectoryFile.cxx. ◆ OpenFile(). TFile * TDirectoryFile::OpenFile ; (; const char * ; name, . Option_t * ; option = """", . const char * ; ftitle = """", . Int_t ; compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, . Int_t ; netopt = 0 . ). overridevirtual . Interface to TFile::Open. ; Reimplemented from TDirectory.; Definition at line 1233 of file TDirectoryFile.cxx. ◆ operator=(). void TDirectoryFile::operator= ; (; const TDirectoryFile & ; ). privatedelete . ◆ Purge(). void TDirectoryFile::Purge ; (; Short_t ; nkeep = 1). overridevirtual . Purge lowest key cycles in a directory. ; By default, only the highest cycle of a key is kept. Keys for which the ""KEEP"" flag has been set are not removed. See TKey::Keep(). NOTE: This does not reduce the size of a TFile– the space is simply freed up to be overwritten. ; Reimplemented from TDirectory.; Definition at line 1290 of file TDirectoryFile.cxx. ◆ ReadAll(). void TDirectoryFile::ReadAll ; (; Option_t * ; opt = """"). overridevirtual . Read objects from a ROOT file directory into memory. ; If an object is already in memory, the memory copy is deleted and the object is again read from the file. If opt==""dirs"", only subdirectories will be read If opt==""dirs*"" complete directory tree will be read ; Reimplemented from TDirectory.; Definition at line 1326 of file TDirectoryFile.cxx. ◆ ReadKeys(). Int_t TDirectoryFile::ReadKeys ; (; Bool_t ; forceRead = kTRUE). overridevirtual . Read the linked list of keys. ; Every directory has a linked list (fKeys). This linked list has been written on the file via WriteKeys as a single data record.; It is interesting to call this function in the following situation. Assume another process1 is connecting this directory in Update mode; Process1 is adding/updating obje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDirectoryFile.html:42857,reduce,reduce,42857,doc/master/classTDirectoryFile.html,https://root.cern,https://root.cern/doc/master/classTDirectoryFile.html,1,['reduce'],['reduce']
Energy Efficiency,"r to the object carrying the function state; (for example the function object itself). virtual ~Derivator(); destructor. Derivator(const Derivator &); disable copying. void SetFunction(const ROOT::Math::IGenFunction& f). Template methods for generic functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1E-8) const. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__Derivator.html:3614,adapt,adaptive,3614,root/html526/ROOT__Math__Derivator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__Derivator.html,5,['adapt'],['adaptive']
Energy Efficiency,"r to; be fitted, and the new candidate function to be included in the; fit. By default it is 0, which automatically chooses another; selection criteria. See also; class description. void SetMinAngle(Double_t angle = 1); Set the min angle (in degrees) between a new candidate function; and the subspace spanned by the previously accepted; functions. See also; class description. void SetPowers(const Int_t* powers, Int_t terms); Define a user function. The input array must be of the form; (p11, ..., p1N, ... ,pL1, ..., pLN); Where N is the dimension of the data sample, L is the number of; terms (given in terms) and the first number, labels the term, the; second the variable. More information is given in the; class description. void SetPowerLimit(Double_t limit = 1e-3); Set the user parameter for the function selection. The bigger the; limit, the more functions are used. The meaning of this variable; is defined in the; class description. void SetMaxPowers(const Int_t* powers); Set the maximum power to be considered in the fit for each; variable. See also; class description. void SetMinRelativeError(Double_t error); Set the acceptable relative error for when sum of square; residuals is considered minimized. For a full account, refer to; the; class description. Bool_t TestFunction(Double_t squareResidual, Double_t dResidur); PRIVATE METHOD:; Test whether the currently considered function contributes to the; fit. See also; class description. TMultiDimFit(). void Draw(Option_t* = ""d""); { }. Double_t GetChi2() const; { return fChi2; }. const TMatrixD* GetCorrelationMatrix() const; { return &fCorrelationMatrix; }. const TVectorD* GetCoefficients() const; { return &fCoefficients; }. Double_t GetError() const; { return fError; }. Int_t* GetFunctionCodes() const; { return fFunctionCodes; }. const TMatrixD* GetFunctions() const; { return &fFunctions; }. TList* GetHistograms() const; { return fHistograms; }. Double_t GetMaxAngle() const; { return fMaxAngle; }. Int_t GetMaxFunctions(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiDimFit.html:34074,power,powers,34074,root/html528/TMultiDimFit.html,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html,6,['power'],"['power', 'powers']"
Energy Efficiency,"r to; be fitted, and the new candidate function to be included in the; fit. By default it is 0, which automatically chooses another; selection criteria. See also; class description. void SetMinAngle(Double_t angle = 1); Set the min angle (in degrees) between a new candidate function; and the subspace spanned by the previously accepted; functions. See also; class description. void SetPowers(const Int_t* powers, Int_t terms); Define a user function. The input array must be of the form; (p11, ..., p1N, ... ,pL1, ..., pLN); Where N is the dimension of the data sample, L is the number of; terms (given in terms) and the first number, labels the term, the; second the variable. More information is given in the; class description. void SetPowerLimit(Double_t limit = 1e-3); Set the user parameter for the function selection. The bigger the; limit, the more functions are used. The meaning of this variable; is defined in the; class description. void SetMaxPowers(const Int_t* powers); Set the maximum power to be considered in the fit for each; variable. See also; class description. void SetMinRelativeError(Double_t error); Set the acceptable relative error for when sum of square; residuals is considered minimized. For a full account, refer to; the; class description. Bool_t TestFunction(Double_t squareResidual, Double_t dResidur); PRIVATE METHOD:; Test whether the currently considered function contributes to the; fit. See also; class description. TMultiDimFit(). void Draw(Option_t* = ""d""); { }. Double_t GetChi2() const; { return fChi2; }. const TMatrixD* GetCorrelationMatrix() const; { return &fCorrelationMatrix; }. const TVectorD* GetCoefficients() const; { return &fCoefficients; }. const TVectorD* GetCoefficientsRMS() const; { return &fCoefficientsRMS; }. Double_t GetError() const; { return fError; }. Int_t* GetFunctionCodes() const; { return fFunctionCodes; }. const TMatrixD* GetFunctions() const; { return &fFunctions; }. TList* GetHistograms() const; { return fHistograms; }. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiDimFit.html:34419,power,powers,34419,root/html534/TMultiDimFit.html,https://root.cern,https://root.cern/root/html534/TMultiDimFit.html,2,['power'],"['power', 'powers']"
Energy Efficiency,"r viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodPDERS. class TMVA::MethodPDERS: public TMVA::MethodBase. /*; This is a generalization of the above Likelihood methods to Nvar; dimensions, where Nvar is the number of input variables; used in the MVA. If the multi-dimensional probability density functions; (PDFs) for signal and background were known, this method contains the entire; physical information, and is therefore optimal. Usually, kernel estimation; methods are used to approximate the PDFs using the events from the; training sample. ; A very simple probability density estimator (PDE) has been suggested; in hep-ex/0211019. The; PDE for a given test event is obtained from counting the (normalized); number of signal and background (training) events that occur in the; ""vicinity"" of the test event. The volume that describes ""vicinity"" is; user-defined. A search; method based on binary-trees is used to effectively reduce the; selection time for the range search. Three different volume definitions; are optional: . MinMax:; the volume is defined in each dimension with respect; to the full variable range found in the training sample. ; RMS:; the volume is defined in each dimensions with respect; to the RMS estimated from the training sample. ; Adaptive:; a volume element is defined in each dimensions with; respect to the RMS estimated from the training sample. The overall; scale of the volume element is then determined for each event so; that the total number of events confined in the volume be within; a user-defined range. The adaptive range search is used by default.; . Function Members (Methods); public:. virtual~MethodPDERS(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__MethodPDERS.html:1143,reduce,reduce,1143,root/html604/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDERS.html,1,['reduce'],['reduce']
Energy Efficiency,"r(Bool_t isfolder = kTRUE); If isfolder=kTRUE, the canvas can be browsed like a folder; by default a canvas is not browsable. void SetSelected(TObject* obj); Set selected canvas. void SetTitle(const char* title = """"); Set canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCanvas.html:46034,allocate,allocated,46034,root/html602/TCanvas.html,https://root.cern,https://root.cern/root/html602/TCanvas.html,2,['allocate'],['allocated']
Energy Efficiency,"r(Bool_t isfolder = kTRUE); If isfolder=kTRUE, the canvas can be browsed like a folder; by default a canvas is not browsable. void SetSelected(TObject* obj); Set selected canvas. void SetTitle(const char* title = """"); Set canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported.; gPad must exist (otherwise this call has no sense), and; either it's a gl-pad or we are on OS X with --enable-cocoa. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad di",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCanvas.html:45147,allocate,allocated,45147,root/html534/TCanvas.html,https://root.cern,https://root.cern/root/html534/TCanvas.html,1,['allocate'],['allocated']
Energy Efficiency,"r(Bool_t isfolder = kTRUE); If isfolder=kTRUE, the canvas can be browsed like a folder; by default a canvas is not browsable. void SetSelected(TObject* obj); Set selected canvas. void SetTitle(const char* title = """"); Set canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& b); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. TC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCanvas.html:43653,allocate,allocated,43653,root/html526/TCanvas.html,https://root.cern,https://root.cern/root/html526/TCanvas.html,4,['allocate'],['allocated']
Energy Efficiency,"r(Int_t iparam) constDefinition TF1.h:80; TF1Parameters::SetParNamevoid SetParName(Int_t iparam, const char *name)Definition TF1.h:122; TF1Parameters::operator=TF1Parameters & operator=(const TF1Parameters &rhs)Definition TF1.h:70; TF1Parameters::SetParametervoid SetParameter(Int_t iparam, Double_t value)Definition TF1.h:106; TF1Parameters::SetParametervoid SetParameter(const char *name, Double_t value)Definition TF1.h:118; TF1Parameters::TF1ParametersTF1Parameters(Int_t npar)Definition TF1.h:56; TF1Parameters::fParNamesstd::vector< std::string > fParNamesDefinition TF1.h:139; TF1Parameters::TF1ParametersTF1Parameters()Definition TF1.h:55; TF1Parameters::CheckIndexbool CheckIndex(Int_t i) constDefinition TF1.h:133; TF1Parameters::SetParNamesvoid SetParNames(Args &&... args)Set parameter names.Definition TF1.h:156; TF1Parameters::SetParametersvoid SetParameters(const Double_t *params)Definition TF1.h:111; TF1Parameters::GetParNumberInt_t GetParNumber(const char *name) constReturns the parameter number given a name not very efficient but list of parameters is typically smal...Definition TF1.cxx:3846; TF1Parameters::TF1ParametersTF1Parameters(const TF1Parameters &rhs)Definition TF1.h:65; TF1Parameters::GetParametersconst Double_t * GetParameters() constDefinition TF1.h:88; TF11-Dim function classDefinition TF1.h:233; TF1::fFunctorstd::unique_ptr< TF1FunctorPointer > fFunctor! Functor object to wrap any C++ callable objectDefinition TF1.h:287; TF1::GetMinimumXvirtual Double_t GetMinimumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the X value corresponding to the minimum value of the function on the (xmin,...Definition TF1.cxx:1823; TF1::GetMinimumvirtual Double_t GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the minimum value of the function on the (xmin, xmax) interval.Definition TF1.cxx:1696; TF1::GetXmaxvirtual Double_t GetXmax",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8h_source.html:45936,efficient,efficient,45936,doc/master/TF1_8h_source.html,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html,1,['efficient'],['efficient']
Energy Efficiency,"r(Long64_t entry) constDefinition TTree.h:455; TTree::GetBranchStatusvirtual bool GetBranchStatus(const char *branchname) constReturn status of branch with name branchname.Definition TTree.cxx:5380; TTree::fFriendLockStatusUInt_t fFriendLockStatus! Record which method is locking the friend recursionDefinition TTree.h:137; TTree::GetLeafImplvirtual TLeaf * GetLeafImpl(const char *branchname, const char *leafname)Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6098; TTree::fTotBytesLong64_t fTotBytesTotal number of bytes in all branches before compression.Definition TTree.h:86; TTree::FlushBasketsvirtual Int_t FlushBaskets(bool create_cluster=true) constWrite to disk all the basket that have not yet been individually written and create an event cluster ...Definition TTree.cxx:5129; TTree::GetDefaultEntryOffsetLenInt_t GetDefaultEntryOffsetLen() constDefinition TTree.h:459; TTree::fMaxClusterRangeInt_t fMaxClusterRange! Memory allocated for the cluster range.Definition TTree.h:96; TTree::Showvirtual void Show(Long64_t entry=-1, Int_t lenmax=20)Print values of all active leaves for entry.Definition TTree.cxx:9385; TTree::fEventListTEventList * fEventList! Pointer to event selection list (if one)Definition TTree.h:125; TTree::GetAutoSavevirtual Long64_t GetAutoSave() constDefinition TTree.h:448; TTree::StopCacheLearningPhasevirtual Int_t StopCacheLearningPhase()Stop the cache learning phase.Definition TTree.cxx:9474; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::fSortedBranchesstd::vector< std::pair< Long64_t, TBranch * > > fSortedBranches! Branches to be processed in parallel when IMT is on, sorted by average task timeDefinition TTree.h:144; TTree::SetCircularvirtual void SetCircular(Long64_t maxEntries)Enable/Disable circularity for this tree.Definition TTree.cxx:8892; TTree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:55629,allocate,allocated,55629,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['allocate'],['allocated']
Energy Efficiency,"r), fContent(cont),; 430 fSumw2(nullptr); 431{; 432 fCoordinateAllocationSize = fSingleCoordinateSize * cont->GetSize();; 433 fCoordinates = new Char_t[fCoordinateAllocationSize];; 434 if (errors) Sumw2();; 435}; 436 ; 437////////////////////////////////////////////////////////////////////////////////; 438/// Destructor; 439 ; 440THnSparseArrayChunk::~THnSparseArrayChunk(); 441{; 442 delete fContent;; 443 delete [] fCoordinates;; 444 delete fSumw2;; 445}; 446 ; 447////////////////////////////////////////////////////////////////////////////////; 448/// Create a new bin in this chunk; 449 ; 450void THnSparseArrayChunk::AddBin(Int_t idx, const Char_t* coordbuf); 451{; 452 // When streaming out only the filled chunk is saved.; 453 // When reading back only the memory needed for that filled part gets; 454 // allocated. We need to check whether the allowed chunk size is; 455 // bigger than the allocated size. If fCoordinateAllocationSize is; 456 // set to -1 this chunk has been allocated by the streamer and the; 457 // buffer allocation size is defined by [fCoordinatesSize]. In that; 458 // case we need to compare fCoordinatesSize to; 459 // fSingleCoordinateSize * fContent->GetSize(); 460 // to determine whether we need to expand the buffer.; 461 if (fCoordinateAllocationSize == -1 && fContent) {; 462 Int_t chunksize = fSingleCoordinateSize * fContent->GetSize();; 463 if (fCoordinatesSize < chunksize) {; 464 // need to re-allocate:; 465 Char_t *newcoord = new Char_t[chunksize];; 466 memcpy(newcoord, fCoordinates, fCoordinatesSize);; 467 delete [] fCoordinates;; 468 fCoordinates = newcoord;; 469 }; 470 fCoordinateAllocationSize = chunksize;; 471 }; 472 ; 473 memcpy(fCoordinates + idx * fSingleCoordinateSize, coordbuf, fSingleCoordinateSize);; 474 fCoordinatesSize += fSingleCoordinateSize;; 475}; 476 ; 477////////////////////////////////////////////////////////////////////////////////; 478/// Turn on support of errors; 479 ; 480void THnSparseArrayChunk::Sumw2(); 481{; 482 i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:16082,allocate,allocated,16082,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"r). ; The Poisson PDF is implemented by means of Euler's Gamma-function (for the factorial), so for any x integer argument it is the correct Poisson distribution. BUT for non-integer x values, it IS NOT equal to the Poisson distribution !. Definition at line 587 of file TMath.cxx. ◆ PoissonI(). Double_t TMath::PoissonI ; (; Double_t ; x, . Double_t ; par . ). Computes the Discrete Poisson distribution function for (x,par). ; This is a discrete and a non-smooth function. This function is equivalent to ROOT::Math::poisson_pdf. Definition at line 615 of file TMath.cxx. ◆ Power() [1/5]. Double_t TMath::Power ; (; Double_t ; x, . Double_t ; y . ). inline . Returns x raised to the power y. ; Definition at line 739 of file TMath.h. ◆ Power() [2/5]. Double_t TMath::Power ; (; Double_t ; x, . Int_t ; y . ). inline . Returns x raised to the power y. ; Definition at line 745 of file TMath.h. ◆ Power() [3/5]. LongDouble_t TMath::Power ; (; Long64_t ; x, . Long64_t ; y . ). inline . Returns x raised to the power y. ; Definition at line 733 of file TMath.h. ◆ Power() [4/5]. LongDouble_t TMath::Power ; (; LongDouble_t ; x, . Long64_t ; y . ). inline . Returns x raised to the power y. ; Definition at line 727 of file TMath.h. ◆ Power() [5/5]. LongDouble_t TMath::Power ; (; LongDouble_t ; x, . LongDouble_t ; y . ). inline . Returns x raised to the power y. ; Definition at line 721 of file TMath.h. ◆ Prob(). Double_t TMath::Prob ; (; Double_t ; chi2, . Int_t ; ndf . ). Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf). ; Calculations are based on the incomplete gamma function P(a,x), where a=ndf/2 and x=chi2/2.; P(a,x) represents the probability that the observed Chi-squared for a correct model should be less than the value chi2.; The returned probability corresponds to 1-P(a,x), which denotes the probability that an observed Chi-squared exceeds the value chi2 by chance, even for a correct model.; AuthorNvE 14-nov-1998 UU-SAP Utrech",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:72215,power,power,72215,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['power'],['power']
Energy Efficiency,"r). overridevirtual . Clear the canvases. ; Reimplemented from TObject.; Definition at line 181 of file TProofProgressMemoryPlot.cxx. ◆ DoAveragePlot(). TGraph * TProofProgressMemoryPlot::DoAveragePlot ; (; Int_t & ; max_el, . Int_t & ; min_el . ). protected . Create the average plots. ; Definition at line 381 of file TProofProgressMemoryPlot.cxx. ◆ DoAveragePlotOld(). TGraph * TProofProgressMemoryPlot::DoAveragePlotOld ; (; Int_t & ; max_el, . Int_t & ; min_el . ). protected . ◆ DoMasterPlot(). TGraph * TProofProgressMemoryPlot::DoMasterPlot ; (; TProofLogElem * ; ple). protected . a master or submaster log display without meaningful labels for now ; Definition at line 609 of file TProofProgressMemoryPlot.cxx. ◆ DoPlot(). void TProofProgressMemoryPlot::DoPlot ; (; ). Draw the plot from the logs. ; Definition at line 192 of file TProofProgressMemoryPlot.cxx. ◆ DoWorkerPlot(). TGraph * TProofProgressMemoryPlot::DoWorkerPlot ; (; TProofLogElem * ; ple). protected . Make a memory consumption graph for a worker. ; Definition at line 553 of file TProofProgressMemoryPlot.cxx. ◆ ParseLine(). Int_t TProofProgressMemoryPlot::ParseLine ; (; TString ; l, . Long64_t & ; v, . Long64_t & ; r, . Long64_t & ; e . ). protected . Extract from line 'l' the virtual memory 'v', the resident memory 'r' and the number of events 'e'. ; The line is assumed to be in the form ""... Memory 130868 virtual 31540 ... event 5550"" The fields are only filled if >= 0 . Return 0 on success, -1 if any of the values could not be filled (the output fields are not touched in such a case). ; Definition at line 507 of file TProofProgressMemoryPlot.cxx. ◆ Select(). void TProofProgressMemoryPlot::Select ; (; Int_t ; id). actions of select all/clear all button ; Definition at line 644 of file TProofProgressMemoryPlot.cxx. Member Data Documentation. ◆ fAllWorkers. TGSplitButton* TProofProgressMemoryPlot::fAllWorkers. protected . Definition at line 34 of file TProofProgressMemoryPlot.h. ◆ fAPlot. TMultiGraph* TPr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofProgressMemoryPlot.html:38948,consumption,consumption,38948,doc/master/classTProofProgressMemoryPlot.html,https://root.cern,https://root.cern/doc/master/classTProofProgressMemoryPlot.html,1,['consumption'],['consumption']
Energy Efficiency,"r* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. THnSparseArrayChunk*AddChunk(); voidTHnBase::AddInternal(const THnBase* h, Double_t c, Bool_t rebinned); Bool_tTHnBase::CheckConsistency(const THnBase* h, const char* tag) const; THnBase*THnBase::CloneEmpty(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; TH1*THnBase::CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; static THnBase*THnBase::CreateHnAny(const char* name, const char* title, const TH1* h1, Bool_t sparse, Int_t chunkSize = 1024 * 16); static THnBase*THnBase::CreateHnAny(const char* name, const char* title, const THnBase* hn, Bool_t sparse, Int_t chunkSize = 1024 * 16); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidFillBin(Long64_t bin, Double_t w); voidTHnBase::FillBinBase(Double_t w); voidFillExMap(); virtual TArray*GenerateArray() const; Long64_tGetBinIndexForCurrentBin(Bool_t allocate); THnSparseArrayChunk*GetChunk(Int_t idx) const; THnSparseCompactBinCoord*GetCompactCoord() const; voidTHnBase::Init(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis, Int_t chunkSize = 1024 * 16); virtual voidInitStorage(Int_t* nbins, Int_t chunkSize); voidTObject::MakeZombie(); Bool_tTHnBase::PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*THnBase::ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantNDim, Option_t* option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidReserve(Long64_t nbins); voidTHnBase::ResetBase(Option_t* option = """"); THnSparse(); THnSparse(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin, const Double_t* xmax, Int_t chunksize); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). private:. THnSparse&operator=(const THnSparse&); THnSparse(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THnSparse.html:14156,allocate,allocate,14156,root/html602/THnSparse.html,https://root.cern,https://root.cern/root/html602/THnSparse.html,2,['allocate'],['allocate']
Energy Efficiency,"r*URL() const; virtual voidTObject::UseCurrentStyle(); const char*Version() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TXMLDocument(const TXMLDocument&); TXMLDocument&operator=(const TXMLDocument&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TXMLNode*fRootNodethe root node ; _xmlDoc*fXMLDoclibxml xml doc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TXMLDocument(_xmlDoc* doc); TXMLDocument constructor. ~TXMLDocument(); TXMLDocument destructor.; Free the global variables that may; have been allocated by the parser. TXMLNode * GetRootNode() const; Returns the root element node. const char * Version() const; Returns the XML version string or 0 in case there is no document set. const char * Encoding() const; Returns external initial encoding, if any or 0 in case there is no; document set. const char * URL() const; Returns the URI for the document or 0 in case there is no document set. TXMLDocument(const TXMLDocument& ). TXMLDocument& operator=(const TXMLDocument& ). » Author: Jose Lo 12/4/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/xmlparser:$Id: TXMLDocument.h 21809 2008-01-22 16:11:46Z brun $ » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLDocument.html:5586,allocate,allocated,5586,root/html528/TXMLDocument.html,https://root.cern,https://root.cern/root/html528/TXMLDocument.html,1,['allocate'],['allocated']
Energy Efficiency,"r*URL() const; virtual voidTObject::UseCurrentStyle(); const char*Version() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TXMLDocument(const TXMLDocument&); TXMLDocument&operator=(const TXMLDocument&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TXMLNode*fRootNodethe root node ; _xmlDoc*fXMLDoclibxml xml doc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TXMLDocument(_xmlDoc* doc); TXMLDocument constructor. ~TXMLDocument(); TXMLDocument destructor.; Free the global variables that may; have been allocated by the parser. TXMLNode * GetRootNode() const; Returns the root element node. const char * Version() const; Returns the XML version string or 0 in case there is no document set. const char * Encoding() const; Returns external initial encoding, if any or 0 in case there is no; document set. const char * URL() const; Returns the URI for the document or 0 in case there is no document set. TXMLDocument(const TXMLDocument& ). TXMLDocument& operator=(const TXMLDocument& ). » Author: Jose Lo 12/4/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/xmlparser:$Id: TXMLDocument.h 21809 2008-01-22 16:11:46Z brun $ » Last generated: 2011-07-04 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXMLDocument.html:5655,allocate,allocated,5655,root/html530/TXMLDocument.html,https://root.cern,https://root.cern/root/html530/TXMLDocument.html,1,['allocate'],['allocated']
Energy Efficiency,"r*URL() const; virtual voidTObject::UseCurrentStyle(); const char*Version() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TXMLDocument(const TXMLDocument&); TXMLDocument&operator=(const TXMLDocument&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TXMLNode*fRootNodethe root node ; _xmlDoc*fXMLDoclibxml xml doc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TXMLDocument(_xmlDoc* doc); TXMLDocument constructor. ~TXMLDocument(); TXMLDocument destructor.; Free the global variables that may; have been allocated by the parser. TXMLNode * GetRootNode() const; Returns the root element node. const char * Version() const; Returns the XML version string or 0 in case there is no document set. const char * Encoding() const; Returns external initial encoding, if any or 0 in case there is no; document set. const char * URL() const; Returns the URI for the document or 0 in case there is no document set. TXMLDocument(const TXMLDocument& ). TXMLDocument& operator=(const TXMLDocument& ). » Author: Jose Lo 12/4/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/xmlparser:$Id: TXMLDocument.h 21809 2008-01-22 16:11:46Z brun $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXMLDocument.html:5655,allocate,allocated,5655,root/html532/TXMLDocument.html,https://root.cern,https://root.cern/root/html532/TXMLDocument.html,1,['allocate'],['allocated']
Energy Efficiency,"r. ; Definition at line 134 of file Derivator.cxx. ◆ Eval() [5/5]. double ROOT::Math::Derivator::Eval ; (; IParamMultiFunction & ; f, . const double * ; x, . const double * ; p, . unsigned int ; ipar = 0, . double ; h = 1E-8 . ). static . Evaluate the derivative with respect a parameter for a multi-dim parameteric function at the point ( x[],p[]) with respect the parameter p_ipar. ; Definition at line 143 of file Derivator.cxx. ◆ EvalBackward() [1/2]. double ROOT::Math::Derivator::EvalBackward ; (; const IGenFunction & ; f, . double ; x, . double ; h = 1E-8 . ). static . Computes the numerical derivative of a function f at a point x using an adaptive backward difference algorithm with a step size h. ; The function is evaluated only at points less than x and at x itself ; Definition at line 122 of file Derivator.cxx. ◆ EvalBackward() [2/2]. double ROOT::Math::Derivator::EvalBackward ; (; double ; x, . double ; h = 1E-8 . ); const. Computes the numerical derivative at a point x using an adaptive backward difference algorithm with a step size h. ; The function is evaluated only at points less than x and at x itself. ; Definition at line 105 of file Derivator.cxx. ◆ EvalCentral() [1/2]. double ROOT::Math::Derivator::EvalCentral ; (; const IGenFunction & ; f, . double ; x, . double ; h = 1E-8 . ). static . Computes the numerical derivative of a function f at a point x using an adaptive central difference algorithm with a step size h. ; Definition at line 114 of file Derivator.cxx. ◆ EvalCentral() [2/2]. double ROOT::Math::Derivator::EvalCentral ; (; double ; x, . double ; h = 1E-8 . ); const. Computes the numerical derivative at a point x using an adaptive central difference algorithm with a step size h. ; Definition at line 97 of file Derivator.cxx. ◆ EvalForward() [1/2]. double ROOT::Math::Derivator::EvalForward ; (; const IGenFunction & ; f, . double ; x, . double ; h = 1E-8 . ). static . Computes the numerical derivative of a function f at a point x using an adaptive ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Derivator.html:8044,adapt,adaptive,8044,doc/master/classROOT_1_1Math_1_1Derivator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Derivator.html,1,['adapt'],['adaptive']
Energy Efficiency,"r. Double_t evaluate() const; Calculate current value of this object. void setVal(Double_t value); Assign given value to linear transformation: sets input variable to (value-offset)/slope; If slope is zerom an error message is printed and no assignment is made. Bool_t isJacobianOK(const RooArgSet& depList) const; Returns true if Jacobian term associated with current; expression tree is indeed constant. Double_t jacobian() const; Return value of Jacobian associated with the transformation. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream. RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE); Retrieve binning of this linear transformation. A RooLinearVar does not have its own; binnings but uses linearly transformed binnings of teh input variable. If a given; binning exists on the input variable, it will also exists on this linear transformation; and a binning adaptor object is created on the fly. const RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE) const; Const version of getBinning(). std::list<std::string> getBinningNames() const; Get a list of all binning names. An empty name implies the default binning.; A 0 pointer should be passed to getBinning in this case. Bool_t hasBinning(const char* name) const; Returns true if binning with given name exists.If a given binning; exists on the input variable, it will also exists on this linear; transformation. RooLinearVar(); Constructors, assignment etc. {}. TObject* clone(const char* newname) const; { return new RooLinearVar(*this,newname); }. » Last changed: Tue Jun 30 14:33:47 2015 » Last generated: 2015-06-30 14:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLinearVar.html:43552,adapt,adaptor,43552,root/html602/RooLinearVar.html,https://root.cern,https://root.cern/root/html602/RooLinearVar.html,1,['adapt'],['adaptor']
Energy Efficiency,"r. Double_t evaluate() const; Calculate current value of this object. void setVal(Double_t value); Assign given value to linear transformation: sets input variable to (value-offset)/slope; If slope is zerom an error message is printed and no assignment is made. Bool_t isJacobianOK(const RooArgSet& depList) const; Returns true if Jacobian term associated with current; expression tree is indeed constant. Double_t jacobian() const; Return value of Jacobian associated with the transformation. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream. RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE); Retrieve binning of this linear transformation. A RooLinearVar does not have its own; binnings but uses linearly transformed binnings of teh input variable. If a given; binning exists on the input variable, it will also exists on this linear transformation; and a binning adaptor object is created on the fly. const RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE) const; Const version of getBinning(). std::list<std::string> getBinningNames() const; Get a list of all binning names. An empty name implies the default binning.; A 0 pointer should be passed to getBinning in this case. Bool_t hasBinning(const char* name) const; Returns true if binning with given name exists.If a given binning; exists on the input variable, it will also exists on this linear; transformation. RooLinearVar(); Constructors, assignment etc. {}. TObject* clone(const char* newname) const; { return new RooLinearVar(*this,newname); }. » Last changed: Tue Mar 10 17:17:33 2015 » Last generated: 2015-03-10 17:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooLinearVar.html:42207,adapt,adaptor,42207,root/html534/RooLinearVar.html,https://root.cern,https://root.cern/root/html534/RooLinearVar.html,1,['adapt'],['adaptor']
Energy Efficiency,"r.; 1290///; 1291/// NOTE that this is a static function. To call it, use;; 1292/// TH1::AddDirectory; 1293 ; 1294void TH1::AddDirectory(Bool_t add); 1295{; 1296 fgAddDirectory = add;; 1297}; 1298 ; 1299////////////////////////////////////////////////////////////////////////////////; 1300/// Auxiliary function to get the power of 2 next (larger) or previous (smaller); 1301/// a given x; 1302///; 1303/// next = kTRUE : next larger; 1304/// next = kFALSE : previous smaller; 1305///; 1306/// Used by the autobin power of 2 algorithm; 1307 ; 1308inline Double_t TH1::AutoP2GetPower2(Double_t x, Bool_t next); 1309{; 1310 Int_t nn;; 1311 Double_t f2 = std::frexp(x, &nn);; 1312 return ((next && x > 0.) || (!next && x <= 0.)) ? std::ldexp(std::copysign(1., f2), nn); 1313 : std::ldexp(std::copysign(1., f2), --nn);; 1314}; 1315 ; 1316////////////////////////////////////////////////////////////////////////////////; 1317/// Auxiliary function to get the next power of 2 integer value larger then n; 1318///; 1319/// Used by the autobin power of 2 algorithm; 1320 ; 1321inline Int_t TH1::AutoP2GetBins(Int_t n); 1322{; 1323 Int_t nn;; 1324 Double_t f2 = std::frexp(n, &nn);; 1325 if (TMath::Abs(f2 - .5) > 0.001); 1326 return (Int_t)std::ldexp(1., nn);; 1327 return n;; 1328}; 1329 ; 1330////////////////////////////////////////////////////////////////////////////////; 1331/// Buffer-based estimate of the histogram range using the power of 2 algorithm.; 1332///; 1333/// Used by the autobin power of 2 algorithm.; 1334///; 1335/// Works on arguments (min and max from fBuffer) and internal inputs: fXmin,; 1336/// fXmax, NBinsX (from fXaxis), ...; 1337/// Result save internally in fXaxis.; 1338///; 1339/// Overloaded by TH2 and TH3.; 1340///; 1341/// Return -1 if internal inputs are inconsistent, 0 otherwise.; 1342 ; 1343Int_t TH1::AutoP2FindLimits(Double_t xmi, Double_t xma); 1344{; 1345 // We need meaningful raw limits; 1346 if (xmi >= xma); 1347 return -1;; 1348 ; 1349 THLimitsFinder::GetLi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:52076,power,power,52076,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,2,['power'],['power']
Energy Efficiency,"r::Deriv2 ; (; double ; x); const. Return the second derivative of the interpolated function at point x. ; Definition at line 87 of file Interpolator.cxx. ◆ Eval(). double ROOT::Math::Interpolator::Eval ; (; double ; x); const. Return the interpolated value at point x. ; Definition at line 75 of file Interpolator.cxx. ◆ Integ(). double ROOT::Math::Interpolator::Integ ; (; double ; a, . double ; b . ); const. Return the Integral of the interpolated function over the range [a,b]. ; Definition at line 92 of file Interpolator.cxx. ◆ operator=() [1/2]. Interpolator & ROOT::Math::Interpolator::operator= ; (; const Interpolator & ; ). delete . ◆ operator=() [2/2]. Interpolator & ROOT::Math::Interpolator::operator= ; (; Interpolator && ; ). delete . ◆ SetData() [1/2]. bool ROOT::Math::Interpolator::SetData ; (; const std::vector< double > & ; x, . const std::vector< double > & ; y . ). Set the data vector ( x[] and y[] ) To be efficient, the size of the data must be the same of the value used in the constructor (ndata) If this is not the case a new re-initialization is performed with the new data size. ; Definition at line 68 of file Interpolator.cxx. ◆ SetData() [2/2]. bool ROOT::Math::Interpolator::SetData ; (; unsigned int ; ndata, . const double * ; x, . const double * ; y . ). Set the data vector ( x[] and y[] ) To be efficient, the size of the data must be the same of the value used when constructing the class (ndata) If this is not the case a new re-initialization is performed with the new data size. ; Definition at line 64 of file Interpolator.cxx. ◆ Type(). std::string ROOT::Math::Interpolator::Type ; (; ); const. Return the type of interpolation method. ; Definition at line 101 of file Interpolator.cxx. ◆ TypeGet(). std::string ROOT::Math::Interpolator::TypeGet ; (; ); const. Definition at line 97 of file Interpolator.cxx. Member Data Documentation. ◆ fInterp. GSLInterpolator* ROOT::Math::Interpolator::fInterp. private . Definition at line 138 of file Interpolator.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Interpolator.html:5402,efficient,efficient,5402,doc/master/classROOT_1_1Math_1_1Interpolator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Interpolator.html,1,['efficient'],['efficient']
Energy Efficiency,r::zScalar z() constDefinition LorentzVector.h:644; ROOT::Math::LorentzVector::RScalar R() constreturn the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) )Definition LorentzVector.h:310; ROOT::Math::LorentzVector::ScalarCoordSystem::Scalar ScalarDefinition LorentzVector.h:65; ROOT::Math::LorentzVector::P2Scalar P2() constreturn the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 )Definition LorentzVector.h:315; ROOT::Math::LorentzVector::Et2Scalar Et2() constreturn the transverse energy squaredDefinition LorentzVector.h:343; ROOT::Math::LorentzVector::mag2Scalar mag2() constDefinition LorentzVector.h:657; ROOT::Math::LorentzVector::LorentzVectorLorentzVector()default constructor of an empty vector (Px = Py = Pz = E = 0 )Definition LorentzVector.h:71; ROOT::Math::LorentzVector::energyScalar energy() constDefinition LorentzVector.h:664; ROOT::Math::LorentzVector::mtScalar mt() constDefinition LorentzVector.h:659; ROOT::Math::LorentzVector::isTimelikebool isTimelike() constDetermine if momentum-energy can represent a physical massive particle.Definition LorentzVector.h:528; ROOT::Math::LorentzVector::operator-=LorentzVector & operator-=(const OtherLorentzVector &q)Self subtraction of another Vector from this ( v-= q ) Enable the addition with any other LorentzVect...Definition LorentzVector.h:411; ROOT::Math::LorentzVector::PxScalar Px() constspatial X componentDefinition LorentzVector.h:279; ROOT::Math::LorentzVector::etaScalar eta() constDefinition LorentzVector.h:654; ROOT::Math::LorentzVector::MtScalar Mt() constreturn the transverse massDefinition LorentzVector.h:337; ROOT::Math::LorentzVector::xScalar x() constDefinition LorentzVector.h:642; ROOT::Math::LorentzVector::mass2Scalar mass2() constDefinition LorentzVector.h:666; ROOT::Math::LorentzVector::Dimensionunsigned int Dimension() constdimensionDefinition LorentzVector.h:269; ROOT::Math::LorentzVector::SetMLorentzVector< CoordSystem > & SetM(Scalar a)Definition LorentzVector.h:676; ROOT::Math::Lor,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:35959,energy,energy,35959,doc/master/GenVector_2LorentzVector_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html,1,['energy'],['energy']
Energy Efficiency,"r; 52\ingroup NTuple; 53\brief An RNTuple that is used to read data from storage; 54 ; 55An input ntuple provides data from storage as C++ objects. The ntuple model can be created from the data on storage; 56or it can be imposed by the user. The latter case allows users to read into a specialized ntuple model that covers; 57only a subset of the fields in the ntuple. The ntuple model is used when reading complete entries.; 58Individual fields can be read as well by instantiating a tree view.; 59 ; 60~~~ {.cpp}; 61#include <ROOT/RNTupleReader.hxx>; 62using ROOT::Experimental::RNTupleReader;; 63 ; 64#include <iostream>; 65 ; 66auto ntuple = RNTupleReader::Open(""myNTuple"", ""some/file.root"");; 67std::cout << ""myNTuple has "" << ntuple->GetNEntries() << "" entries\n"";; 68~~~; 69*/; 70// clang-format on; 71class RNTupleReader {; 72private:; 73 /// Set as the page source's scheduler for parallel page decompression if IMT is on; 74 /// Needs to be destructed after the pages source is destructed (an thus be declared before); 75 std::unique_ptr<Internal::RPageStorage::RTaskScheduler> fUnzipTasks;; 76 ; 77 std::unique_ptr<Internal::RPageSource> fSource;; 78 /// Needs to be destructed before fSource; 79 std::unique_ptr<RNTupleModel> fModel;; 80 /// We use a dedicated on-demand reader for Show() and Scan(). Printing data uses all the fields; 81 /// from the full model even if the analysis code uses only a subset of fields. The display reader; 82 /// is a clone of the original reader.; 83 std::unique_ptr<RNTupleReader> fDisplayReader;; 84 /// The ntuple descriptor in the page source is protected by a read-write lock. We don't expose that to the; 85 /// users of RNTupleReader::GetDescriptor(). Instead, if descriptor information is needed, we clone the; 86 /// descriptor. Using the descriptor's generation number, we know if the cached descriptor is stale.; 87 /// Retrieving descriptor data from an RNTupleReader is supposed to be for testing and information purposes,; 88 /// not on a ho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleReader_8hxx_source.html:2821,schedul,scheduler,2821,doc/master/RNTupleReader_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleReader_8hxx_source.html,1,['schedul'],['scheduler']
Energy Efficiency,"r; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNDKeysPdf(const char *name, const char *title,			 const RooArgList& varList, RooDataSet& data,			 TString options, Double_t rho, Double_t nSigma, Bool_t rotate); Construct N-dimensional kernel estimation p.d.f. in observables 'varList'; from dataset 'data'. Options can be. 'a' = Use adaptive kernels (width varies with local event density); 'm' = Mirror data points over observable boundaries. Improves modeling; behavior at edges for distributions that are not close to zero; at edge; 'd' = Debug flag; 'v' = Verbose flag. The parameter rho (default = 1) provides an overall scale factor that can; be applied to the bandwith calculated for each kernel. The nSigma parameter; determines the size of the box that is used to search for contributing kernels; around a given point in observable space. The nSigma parameters is used; in case of non-adaptive bandwidths and for the 1st non-adaptive pass for; the calculation of adaptive keys p.d.f.s. The optional weight arguments allows to specify an observable or function; expression in observables that specifies the weight of each event. RooNDKeysPdf(const char *name, const char *title, RooAbsReal& x, RooDataSet& data, Mirror mirror, Double_t rho, Double_t nSigma, Bool_t rotate); Backward compatibility constructor for (1-dim) RooKeysPdf. If you are a new user,; please use the first constructor form. RooNDKeysPdf(const char* name, const char* title, RooAbsReal& x, RooAbsReal& y, RooDataSet& data, TString options = ""a"", Double_t rho = 1.0, Double_t nSigma = 3, Bool_t rotate = kTRUE); Backward compatibility constructor for Roo2DKeysPdf. If you are a new user,; please use the first constructor form. RooNDKeysPdf(const RooNDKeysPdf& other, const char* name = 0); Constructor. ~RooNDKeysPdf(). createPdf(Bool_t firstCall = kTRUE) const; evaluation order of constructor. setOptions() const; set the configuration. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNDKeysPdf.html:43612,adapt,adaptive,43612,root/html526/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html526/RooNDKeysPdf.html,3,['adapt'],['adaptive']
Energy Efficiency,"rBase;  CTQpLinSolverDens;  CTQpLinSolverSparse;  CTQpProbBase;  CTQpProbDens;  CTQpProbSparse;  CTQpResidual;  CTQpSolverBase;  CTQpVar;  CTQRootApplication;  CTQRootCanvas;  CTQRootDialog;  CTQRootGuiFactory;  CTQtRootGuiFactory;  CTQuaternionQuaternion is a 4-component mathematic object quite convenient when dealing with space rotation (or reference frame transformation) ;  CTQueryDescription;  CTQueryResultA container class for query results ;  CTQueryResultManagerClass managing the query-result area ;  CTQUndoManagerRecorder of operations for undo and redo ;  CTrack;  CTRadialGradientDefine a radial color gradient ;  CTRandomThis is the base class for the ROOT Random number generators ;  CTRandom1The Ranlux Random number generator class ;  CTRandom2Random number generator class based on the maximally quidistributed combined Tausworthe generator by L'Ecuyer ;  CTRandom3Random number generator class based on M ;  CTRandomEngine;  CTRandomGen;  CTRangeDynCastTRangeDynCast is an adaptater class that allows the typed iteration through a TCollection ;  CTRatioPlotClass for displaying ratios, differences and fit residuals ;  CTRealDataManages the effective list of all data members for a given class ;  CTReaperTimer;  CTRecCmdEvent;  CTRecEvent;  CTRecExtraEvent;  CTRecGuiEvent;  CTRecorder;  CTRecorderInactive;  CTRecorderPaused;  CTRecorderRecording;  CTRecorderReplaying;  CTRecorderState;  CTRecWinPair;  CTRedirectOutputGuard;  CTRefPersistent Reference link to a TObject A TRef is a lightweight object pointing to any TObject ;  CTRefArrayAn array of references to TObjects ;  CTRefArrayIterIterator of object array ;  CTRefArrayProxyA container proxy, which allows to access references stored in a TRefArray from TTree::Draw ;  CTRefCntDefinitions for TRefCnt, base class for reference counted objects ;  CTRefProxy;  CTRefTableA TRefTable maintains the association between a referenced object and the parent object supporting this referenced object ;  CTRegexpRegular expre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:200270,adapt,adaptater,200270,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,3,['adapt'],['adaptater']
Energy Efficiency,"rF & ; s, . const TEveVectorF & ; r, . TEveVectorF & ; p . ). TEveVectorF wrapper. ; Definition at line 430 of file TEveTrackPropagator.cxx. ◆ GoToVertex() [1/2]. Bool_t TEveTrackPropagator::GoToVertex ; (; TEveVectorD & ; v, . TEveVectorD & ; p . ). virtual . Propagate particle with momentum p to vertex v. ; Definition at line 382 of file TEveTrackPropagator.cxx. ◆ GoToVertex() [2/2]. Bool_t TEveTrackPropagator::GoToVertex ; (; TEveVectorF & ; v, . TEveVectorF & ; p . ). TEveVectorF wrapper. ; Definition at line 419 of file TEveTrackPropagator.cxx. ◆ HelixIntersectPlane(). Bool_t TEveTrackPropagator::HelixIntersectPlane ; (; const TEveVectorD & ; p, . const TEveVectorD & ; point, . const TEveVectorD & ; normal, . TEveVectorD & ; itsect . ). protected . Intersect helix with a plane. ; Current position and argument p define the helix. ; Definition at line 859 of file TEveTrackPropagator.cxx. ◆ InitTrack() [1/2]. void TEveTrackPropagator::InitTrack ; (; const TEveVectorD & ; v, . Int_t ; charge . ). Initialize internal data-members for given particle parameters. ; Definition at line 324 of file TEveTrackPropagator.cxx. ◆ InitTrack() [2/2]. void TEveTrackPropagator::InitTrack ; (; const TEveVectorF & ; v, . Int_t ; charge . ). TEveVectorF wrapper. ; Definition at line 337 of file TEveTrackPropagator.cxx. ◆ IntersectPlane(). Bool_t TEveTrackPropagator::IntersectPlane ; (; const TEveVectorD & ; p, . const TEveVectorD & ; point, . const TEveVectorD & ; normal, . TEveVectorD & ; itsect . ). Find intersection of currently propagated track with a plane. ; Current track position is used as starting point.; Args:; p - track momentum to use for extrapolation; point - a point on a plane; normal - normal of the plane; itsect - output, point of intersection Returns:; kFALSE if intersection can not be found, kTRUE otherwise. . Definition at line 941 of file TEveTrackPropagator.cxx. ◆ IsA(). TClass * TEveTrackPropagator::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass descri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveTrackPropagator.html:52847,charge,charge,52847,doc/master/classTEveTrackPropagator.html,https://root.cern,https://root.cern/doc/master/classTEveTrackPropagator.html,1,['charge'],['charge']
Energy Efficiency,"rF& v, TEveVectorF& p); TEveVectorF wrapper. Bool_t GoToLineSegment(const TEveVectorF& s, const TEveVectorF& r, TEveVectorF& p); TEveVectorF wrapper. void GoToBounds(TEveVectorD& p); Propagate particle to bounds.; Return TRUE if hit bounds. void GoToBounds(TEveVectorF& p); TEveVectorF wrapper. void Update(const TEveVector4D& v, const TEveVectorD& p, Bool_t full_update = kFALSE, Bool_t enforce_max_step = kFALSE); Update helix / B-field projection state. void Step(const TEveVector4D& v, const TEveVectorD& p, TEveVector4D& vOut, TEveVectorD& pOut); Wrapper to step helix. void LoopToBounds(TEveVectorD& p); Propagate charged particle with momentum p to bounds.; It is expected that Update() with full-update was called before. Bool_t LoopToVertex(TEveVectorD& v, TEveVectorD& p); Propagate charged particle with momentum p to vertex v.; It is expected that Update() with full-update was called before. Bool_t LoopToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate charged particle with momentum p to line segment with point s and vector r to the second point.; It is expected that Update() with full-update was called before. Returns kFALSE if hits bounds. void DistributeOffset(const TEveVectorD& off, Int_t first_point, Int_t np, TEveVectorD& p); Distribute offset between first and last point index and rotate; momentum. Bool_t LineToVertex(TEveVectorD& v); Propagate neutral particle to vertex v. void LineToBounds(TEveVectorD& p); Propagatate neutral particle with momentum p to bounds. Bool_t HelixIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); Intersect helix with a plane. Current position and argument p define; the helix. Bool_t LineIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); Intersect line with a plane. Current position and argument p define; the line. Bool_t IntersectPlane(const TEveVectorD& p, const TEveVectorD& p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveTrackPropagator.html:28708,charge,charged,28708,root/html534/TEveTrackPropagator.html,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html,3,['charge'],['charged']
Energy Efficiency,"rIID(Int_t iid, Int_t newsize); voidExpandPIDs(Int_t numpids); Int_tFindPIDGUID(const char* guid) const; Int_tGetInternalIdxForPID(TProcessID* procid) const; Int_tGetInternalIdxForPID(Int_t pid) const; voidTObject::MakeZombie(). Data Members; public:. enum { kHaveWarnedReadingOld; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_t*fAllocSize![fNumPIDs] allocated size of array fParentIDs for each ProcessID; Int_tfDefaultSize!default size for a new PID array; vector<Int_t>fMapPIDtoInternal! cache of pid to index in fProcessGUIDs; Int_t*fN![fNumPIDs] current maximum number of IDs in array fParentIDs for each ProcessID; Int_tfNumPIDs!number of known ProcessIDs; TObject*fOwnerObject owning this TRefTable; Int_tfParentID!current parent ID in fParents (latest call to SetParent); Int_t**fParentIDs![fNumPIDs][fAllocSize] array of Parent IDs; TObjArray*fParentsarray of Parent objects (eg TTree branch) holding the referenced objects; vector<std::string>fProcessGUIDsUUIDs of TProcessIDs used in fParentIDs; Int_tfSizedummy for backward compatibility; UInt_tfUID!Current uid (set by TRef::GetObject); TProcessID*fUIDContext!TProcessID the current uid is referring to; static TRefTable*fgRefTablePointer to current TRefTable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRefTable(); Default constructor for I/O. TRefTable(TObject* owner, Int_t size); Create a TRefTable with initial size. ~TRefTable(); Destructor. Int_t Add(Int_t uid, TProcessID* context = 0); Add a new uid to the table.; we add a new pair (uid,fparent) to the map; This function is called by TObject::Streamer or TStreamerInfo::WriteBuffer. Int_t AddInternalIdxForPID(TProcessID* procid); Add the internal index for fProcessIDs, fAllocSize, etc given a PID. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRefTable.html:7264,allocate,allocated,7264,root/html528/TRefTable.html,https://root.cern,https://root.cern/root/html528/TRefTable.html,4,['allocate'],['allocated']
Energy Efficiency,"rInfo::kObject) ||; 5355 (fStreamerType == TVirtualStreamerInfo::kAny) ||; 5356 (fStreamerType == TVirtualStreamerInfo::kSTL)) {; 5357 // We are *not* a top-level branch and we are *not* a pointer to an STL container.; 5358 // Case of an embedded STL container.; 5359 // Note: We test for the kObject and kAny types to support; 5360 // the (unwise) choice of inheriting from an STL container.; 5361 fObject = fAddress;; 5362 } else {; 5363 // We are either a top-level branch or subbranch which is a pointer to an STL container.; 5364 // Streamer type should be -1 (for a top-level branch) or kSTLp here.; 5365 if ((fStreamerType != -1) && (fStreamerType != TVirtualStreamerInfo::kSTLp)) {; 5366 Error(""SetAddress"",; 5367 ""Branch %s is a split STL container (fStreamerType is: %d), the address can not be set directly."",; 5368 GetName(), fStreamerType);; 5369 } else if (fStreamerType == -1) {; 5370 // -- We are a top-level branch.; 5371 void** pp = (void**) fAddress;; 5372 if (!*pp) {; 5373 // -- Caller wants us to allocate the STL container, but they will own it.; 5374 *pp = proxy->New();; 5375 if (!(*pp)) {; 5376 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5377 // FIXME: Should we do this? Lots of other code wants; 5378 // fAddress to be zero if no fObject, but is; 5379 // that a good thing?; 5380 fAddress = nullptr;; 5381 ResetBit(kAddressSet);; 5382 }; 5383 }; 5384 fObject = (char*) *pp;; 5385 } else {; 5386 // -- We are a pointer to an STL container.; 5387 // Note: We do this so that the default constructor,; 5388 // or the i/o constructor can be lazy.; 5389 void** pp = (void**) fAddress;; 5390 if (!*pp) {; 5391 // -- Caller wants us to allocate the STL container, but they will own it.; 5392 *pp = proxy->New();; 5393 if (!(*pp)) {; 5394 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5395 // FIXME: Should we do this? Lots of other code wants; 5396 // fAddress to be zero if no fObject, but is; 539",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:199382,allocate,allocate,199382,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"rLorentzVector & q); ------ Operations combining two Lorentz vectors ------. scalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+); Enable the product using any other LorentzVector implementing; the x(), y() , y() and t() member functions; \param q any LorentzVector implementing the x(), y() , z() and t(); member functions; \return the result of v.q of type according to the base scalar type of v. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.The",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html:18248,energy,energy,18248,root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html,4,['energy'],['energy']
Energy Efficiency,"rLorentzVector & q); ------ Operations combining two Lorentz vectors ------. scalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+); Enable the product using any other LorentzVector implementing; the x(), y() , y() and t() member functions; \param q any LorentzVector implementing the x(), y() , z() and t(); member functions; \return the result of v.q of type according to the base scalar type of v. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.The",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html:17510,energy,energy,17510,root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html,4,['energy'],['energy']
Energy Efficiency,"r[""x""]<<TVectorD(n, x);; r[""y""]<<TVectorD(n, y);; //creating a R data frame; r<<""ds<-data.frame(x=x,y=y)"";; //fitting x and y to X^power using Nonlinear Least Squares; r<<""m <- nls(y ~ I(x^power),data = ds, start = list(power = 1),trace = T)"";; //getting the fitted value (power); Double_t power;; r[""summary(m)$coefficients[1]""]>>power;; ; TF1 *f_fitted=new TF1(""f_fitted"",""pow(x,[0])"",0,1);; f_fitted->SetParameter(0,power);; //plotting the fitted function; TGraph *gr3 = new TGraph(f_fitted);; gr3->SetMarkerColor(kGreen);; gr3->SetMarkerStyle(8);; gr3->SetMarkerSize(1);; ; mg->Add(gr3);; mg->Draw(""ap"");; ; //displaying basic results; TPaveText *pt = new TPaveText(0.1,0.6,0.5,0.9,""brNDC"");; pt->SetFillColor(18);; pt->SetTextAlign(12);; pt->AddText(""Fitting x^power "");; pt->AddText("" \""Blue\"" Points with gaussian noise to be fitted"");; pt->AddText("" \""Red\"" Known function x^3"");; TString fmsg;; fmsg.Form("" \""Green\"" Fitted function with power=%.4lf"",power);; pt->AddText(fmsg);; pt->Draw();; c1->Update();; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TVectorDTVectorT< Double_t > TVectorDDefinition TVectorDfwd.h:23; ROOT::R::TRInterfaceROOT R was implemented using the R Project library and the modules Rcpp and RInsideDefinition TRInterface.h:136; ROOT::R::TRInterface::Instancestatic TRInterface & Instance()static method to get an TRInterface instance referenceDefinition TRInterface.cxx:187; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TAttMarker::SetMarkerStylevirtual void SetMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1R_1_1TRInterface.html:3157,power,power,3157,doc/master/classROOT_1_1R_1_1TRInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1R_1_1TRInterface.html,1,['power'],['power']
Energy Efficiency,"r_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tfNumberShape number; TStringTNamed::fTitleobject title; Int_tfVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TShape(); Shape default constructor. TShape(const char* name, const char* title, const char* material); Shape normal constructor. TShape(const TShape& ); copy constructor. TShape& operator=(const TShape& ); assignement operator. ~TShape(); Shape default destructor. Int_t ShapeDistancetoPrimitive(Int_t numPoints, Int_t px, Int_t py); Distance to primitive. void Paint(Option_t* option = """"); This method is used only when a shape is painted outside a TNode. void SetPoints(Double_t* points) const; Set points. void Streamer(TBuffer& ); Stream an object of class TShape. void TransformPoints(Double_t* points, UInt_t NbPnts) const; Tranform points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections) const; We have to set kRawSize (unless already done) to allocate buffer space; before kRaw can be filled. Int_t GetBasicColor() const; Get basic solor. const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Stub to avoid forcing implementation at this stage. void SetName(const char* name); { }. TMaterial * GetMaterial() const; {return fMaterial;}. Int_t GetNumber() const; {return fNumber;}. Int_t GetVisibility() const; {return fVisibility;}. void SetVisibility(Int_t vis); {fVisibility = vis;}. » Author: Nenad Buncic 17/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-03-14 16:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TShape.html:8780,allocate,allocate,8780,root/html534/TShape.html,https://root.cern,https://root.cern/root/html534/TShape.html,1,['allocate'],['allocate']
Energy Efficiency,"ra arguments for THttpServer itself:. Name; Description. readonly, ro; use server in read-only mode (default). readwrite, rw; use server in read-write mode. global; let scan global directories for canvases and files (default). noglobal; disable scan of global directories. basic_sniffer; use basic TRootSniffer without support of hist, gpad, graph, tree classes. Example:; new THttpServer(""http:8080;ro;noglobal""); 1.2 Registering objects; At any time, one could register other objects with the command:; TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);; One should specify sub-folder name, where objects will be registered. If sub-folder name does not starts with slash /, than top-name folder /Objects/ will be prepended. At any time one could unregister objects:; serv->Unregister(gr);; THttpServer does not take ownership over registered objects - they should be deleted by user.; If the objects content is changing in the application, one could enable monitoring flag in the browser - then objects view will be regularly updated.; 1.3 Accessing file system; THttpServer provides partial access to the files from file system. First of all, JSROOT scripts and files can be accessed via “jsrootsys/” path like “http://localhost:8080/jsrootsys/modules/core.mjs”. Files from ROOT install directory can be get via “rootsys/” path like “http://localhost:8080/rootsys/icons/about.xpm”. Also files from current directory where ROOT is running can be accessed via “currentdir/” path like “http://localhost:8080/currentdir/file.txt”.; If necessary, one can add custom path as well, using THttpServer::AddLocation method:; serv->AddLocation(""mydir/"", ""/home/user/specials"");; Then files from that directory could be addressed via URL like “http://localhost:8080/mydir/myfile.root”; 1.4 Command interface; THttpServer class provide simple interface to invoke command from web browser. One just register command like:; serv->RegisterCommand(""/DoSomething"", ""SomeFuncti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:3888,monitor,monitoring,3888,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,1,['monitor'],['monitoring']
Energy Efficiency,"ra events (PaveLabels and Texts); TFile*fFileROOT file to store recorded events in; Bool_tfFilterEventPaveSpecial flag to filter events during the pave recording; Window_t*fFilteredIdsOnly when GUI for recorer is used: IDs of windows that creates that GUI.; Int_tfFilteredIdsCountOnly when GUI for recorder is used: Count of windows in GUI recorder; TRecGuiEvent*fGuiEventThe newest GUI event to be stored in TTree; TTree*fGuiTreeTTree with recorded GUI events; TTimer*fMouseTimerTimer used for recording mouse position; TRecorder*fRecorderReference to recorder (owner of this state) is kept in order to switch; Int_tfRegWinCounterCounter of registered ROOT windows.; TTimer*fTimerTimer used for recording; ULong64_tfWinThe newest registered window to be stored in TTree; TTree*fWinTreeTTree with registered windows. Class Charts. Inheritance Chart:. TRecorderState. ←; TRecorderRecording. Function documentation; TRecorderRecording(TRecorder* r, const char* filename, Option_t* option, Window_t* w, Int_t winCount); Initializes TRecorderRecording for recording; What is allocated here is deleted in destructor. ~TRecorderRecording(); Freeing of allocated memory. Bool_t StartRecording(); Connects appropriate signals and slots in order to gain all registered; windows and processed events in ROOT and then starts recording. void Stop(TRecorder* r, Bool_t guiCommand); Disconnects all slots and stopps recording. void RegisterWindow(Window_t w); This method is called when RegisteredWindow(Window_t) is emitted from; TGClient. void RecordCmdEvent(const char* line); Records commandline event (text and time) ans saves the previous; commandline event; This 1 event delay in saving ensures that the last commandline events; 'TRecorder::Stop' will be not stored. void RecordGuiEvent(Event_t* e, Window_t wid); Records GUI Event_t *e different from kConfigureNotify (they are; recorded in TRecorderRecording::RecordGuiCNEvent). It is called via signal-slot when an event is processed in; TGClient::Handle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecorderRecording.html:3602,allocate,allocated,3602,root/html602/TRecorderRecording.html,https://root.cern,https://root.cern/root/html602/TRecorderRecording.html,2,['allocate'],['allocated']
Energy Efficiency,"rabbing client window. ; Reimplemented from TVirtualX.; Definition at line 1872 of file GX11Gui.cxx. ◆ HasTTFonts(). Bool_t TGX11::HasTTFonts ; (; ); const. inlineoverridevirtual . Returns True when TrueType fonts are used. ; Reimplemented from TVirtualX.; Definition at line 186 of file TGX11.h. ◆ IconifyWindow(). void TGX11::IconifyWindow ; (; Window_t ; id). overridevirtual . Iconify the window. ; Reimplemented from TVirtualX.; Definition at line 330 of file GX11Gui.cxx. ◆ ImgPickPalette(). void TGX11::ImgPickPalette ; (; RXImage * ; image, . Int_t & ; ncol, . Int_t *& ; R, . Int_t *& ; G, . Int_t *& ; B . ). private . Returns in R G B the ncol colors of the palette used by the image. ; The image pixels are changed to index values in these R G B arrays. This produces a colormap with only the used colors (so even on displays with more than 8 planes we will be able to create GIF's when the image contains no more than 256 different colors). If it does contain more colors we will have to use GIFquantize to reduce the number of colors. The R G B arrays must be deleted by the caller. ; Definition at line 3331 of file TGX11.cxx. ◆ Init(). Bool_t TGX11::Init ; (; void * ; display). overridevirtual . Initialize X11 system. Returns kFALSE in case of failure. ; Reimplemented from TVirtualX.; Reimplemented in TGX11TTF.; Definition at line 342 of file TGX11.cxx. ◆ InitWindow(). Int_t TGX11::InitWindow ; (; ULong_t ; win). overridevirtual . Open window and return window number. ; Returns-1 if window initialization fails. ; Reimplemented from TVirtualX.; Definition at line 1301 of file TGX11.cxx. ◆ InternAtom(). Atom_t TGX11::InternAtom ; (; const char * ; atom_name, . Bool_t ; only_if_exist . ). overridevirtual . Return atom handle for atom_name. ; If it does not exist create it if only_if_exist is false. Atoms are used to communicate between different programs (i.e. window manager) via the X server. ; Reimplemented from TVirtualX.; Definition at line 900 of file GX11Gui.cxx. ◆ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGX11.html:87252,reduce,reduce,87252,doc/master/classTGX11.html,https://root.cern,https://root.cern/doc/master/classTGX11.html,1,['reduce'],['reduce']
Energy Efficiency,"rack = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);; ...; ...; }; ...; a.Clear(); // or a.Clear(""C"");; }; Note: the only supported way to add objects to a TClonesArray is via the new with placement method or the ConstructedAt method. The other Add() methods ofTObjArray and its base classes are not allowed.; Considering that a new/delete costs about 70 mus on a 300 MHz HP, O(10^9) new/deletes will save about 19 hours. NOTE 1; C/C++ offers the possibility of allocating and deleting memory. Forgetting to delete allocated memory is a programming error called a ""memory leak"", i.e. the memory of your process grows and eventually your program crashes. Even if you always delete the allocated memory, the recovered space may not be efficiently reused. The process knows that there are portions of free memory, but when you allocate it again, a fresh piece of memory is grabbed. Your program is free from semantic errors, but the total memory of your process still grows, because your program's memory is full of ""holes"" which reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in terms of CPU time.; Without entering into technical details, TClonesArray allows you to ""reuse"" the same portion of memory for new/delete avoiding memory fragmentation and memory growth and improving the performance by orders of magnitude. Every time the memory of the TClonesArray has to be reused, the Clear() method is used. To provide its benefits, each TClonesArray must be allocated once per process and disposed of (deleted) only when not needed any more.; So a job should see only one deletion for each TClonesArray, which should be Clear()ed during the job several times. Deleting a TClonesArray is a double waste. Not only you do not avoid memory fragmentation, but you worsen it because the TClonesArray itself is a rather heavy structure, and there is quite some code in the destructor, so you have more memory fragmentatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:2937,reduce,reduce,2937,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['reduce'],['reduce']
Energy Efficiency,"ract portions of the `RVec`. The content to be *taken*; 1482can be specified with an `RVec` of indices or an integer. If the integer is negative,; 1483elements will be picked starting from the end of the container:; 1484~~~{.cpp}; 1485RVecF vf {1.f, 2.f, 3.f, 4.f};; 1486auto vf_1 = Take(vf, {1, 3}); // The content is {2.f, 4.f}; 1487auto vf_2 = Take(vf, 2); // The content is {1.f, 2.f}; 1488auto vf_3 = Take(vf, -3); // The content is {2.f, 3.f, 4.f}; 1489~~~; 1490 ; 1491\anchor usagetdataframe; 1492## Usage in combination with RDataFrame; 1493RDataFrame leverages internally RVecs. Suppose to have a dataset stored in a; 1494TTree which holds these columns (here we choose C arrays to represent the; 1495collections, they could be as well std::vector instances):; 1496~~~{.bash}; 1497 nPart ""nPart/I"" An integer representing the number of particles; 1498 px ""px[nPart]/D"" The C array of the particles' x component of the momentum; 1499 py ""py[nPart]/D"" The C array of the particles' y component of the momentum; 1500 E ""E[nPart]/D"" The C array of the particles' Energy; 1501~~~; 1502Suppose you'd like to plot in a histogram the transverse momenta of all particles; 1503for which the energy is greater than 200 MeV.; 1504The code required would just be:; 1505~~~{.cpp}; 1506RDataFrame d(""mytree"", ""myfile.root"");; 1507auto cutPt = [](RVecD &pxs, RVecD &pys, RVecD &Es) {; 1508 auto all_pts = sqrt(pxs * pxs + pys * pys);; 1509 auto good_pts = all_pts[Es > 200.];; 1510 return good_pts;; 1511 };; 1512 ; 1513auto hpt = d.Define(""pt"", cutPt, {""px"", ""py"", ""E""}); 1514 .Histo1D(""pt"");; 1515hpt->Draw();; 1516~~~; 1517And if you'd like to express your selection as a string:; 1518~~~{.cpp}; 1519RDataFrame d(""mytree"", ""myfile.root"");; 1520auto hpt = d.Define(""pt"", ""sqrt(pxs * pxs + pys * pys)[E>200]""); 1521 .Histo1D(""pt"");; 1522hpt->Draw();; 1523~~~; 1524\anchor RVecdoxyref; 1525**/; 1526// clang-format on; 1527 ; 1528template <typename T>; 1529class R__CLING_PTRCHECK(off) RVec : public RVecN<T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:53552,energy,energy,53552,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['energy'],['energy']
Energy Efficiency,"racy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.0000000000000001E-9, double relTol = 1.0000000000000001E-9, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.0000000000000001E-9, double relTol = 1.0000000000000001E-9, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__AdaptiveIntegratorMultiDim.html:2415,adapt,adaptive,2415,root/html602/ROOT__Math__AdaptiveIntegratorMultiDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__AdaptiveIntegratorMultiDim.html,2,['adapt'],['adaptive']
Energy Efficiency,"racy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:2415,adapt,adaptive,2415,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,1,['adapt'],['adaptive']
Energy Efficiency,"radientCalculator;  Similar to the AnalyticalGradientCalculator, the ExternalInternalGradientCalculator supplies Minuit with an externally calculated gradient. More...;  ; class  FCNAdapter;  template wrapped class for adapting to FCNBase signature More...;  ; class  FCNBase;  Interface (abstract class) defining the function to be minimized, which has to be implemented by the user. More...;  ; class  FCNGradAdapter;  template wrapped class for adapting to FCNBase signature a IGradFunction More...;  ; class  FCNGradientBase;  ; class  FumiliBuilder;  Builds the FunctionMinimum using the Fumili method. More...;  ; class  FumiliChi2FCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  FumiliErrorUpdator;  In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. More...;  ; class  FumiliFCNAdapter;  template wrapped class for adapting to FumiliFCNBase signature More...;  ; class  FumiliFCNBase;  Extension of the FCNBase for the Fumili method. More...;  ; class  FumiliGradientCalculator;  Fumili gradient calculator using external gradient provided by FCN Note that the computed Hessian and G2 are an approximation valid for small residuals. More...;  ; class  FumiliMaximumLikelihoodFCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  FumiliMinimizer;  Instantiates the seed generator and Minimum builder for the Fumili minimization method. More...;  ; class  FumiliStandardChi2FCN;  Class implementing the standard chi square function, which is the sum of the squares of the figures-of-merit calculated for each measurement point, the individual figures-of-merit being: (the Value predicted by the model-measured Value)/standard deviation. More...;  ; class  FumiliStandardMaximumLikelihoodFCN;  Class implementing the Elements member function for the standard maximum likelihood method. More.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Minuit2.html:2501,adapt,adapting,2501,doc/v632/namespaceROOT_1_1Minuit2.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Minuit2.html,1,['adapt'],['adapting']
Energy Efficiency,"rage::Alloc(). void * ReAlloc(void* vp, size_t size); Reallocate (i.e. resize) block of memory. void * ReAlloc(void* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) block of memory. Checks if current size is; equal to oldsize. If not memory was overwritten. char * ReAllocChar(char* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of chars. Size and oldsize are; in number of chars. Int_t * ReAllocInt(Int_t* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of integers. Size and oldsize are; number of integers (not number of bytes). void * ObjectAlloc(size_t size); Used to allocate a TObject on the heap (via TObject::operator new()).; Directly after this routine one can call (in the TObject ctor); TStorage::IsOnHeap() to find out if the just created object is on; the heap. void * ObjectAlloc(size_t size, void* vp); Used to allocate a TObject on the heap (via TObject::operator new(size_t,void*)); in position vp. vp is already allocated (maybe on heap, maybe on; stack) so just return. void ObjectDealloc(void* vp); Used to deallocate a TObject on the heap (via TObject::operator delete()). void ObjectDealloc(void* vp, void* ptr); Used to deallocate a TObject on the heap (via TObject::operator delete(void*,void*)). void SetFreeHook(FreeHookFun_t func, void* data); Set a free handler. void SetReAllocHooks(ReAllocFun_t func1, ReAllocCFun_t func2); Set a custom ReAlloc handlers. This function is typically; called via a static object in the ROOT libNew.so shared library. void PrintStatistics(); Print memory usage statistics. void EnableStatistics(int size = -1, int ix = -1); Enable memory usage statistics gathering. Size is the size of the memory; block that should be trapped and ix is after how many such allocations; the trap should happen. ULong_t GetHeapBegin(); return begin of heap. ULong_t GetHeapEnd(); return end of heap. void * GetFreeHookData(); return static free hook data. Bool_t HasCustomNewDelete(); return the has custom del",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStorage.html:4671,allocate,allocated,4671,root/html528/TStorage.html,https://root.cern,https://root.cern/root/html528/TStorage.html,3,['allocate'],['allocated']
Energy Efficiency,"ramHistFunc::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 111 of file ParamHistFunc.h. ◆ isBinnedDistribution(). bool ParamHistFunc::isBinnedDistribution ; (; const RooArgSet & ; ); const. inlineoverridevirtual . Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ; Reimplemented from RooAbsReal.; Definition at line 62 of file ParamHistFunc.h. ◆ numBins(). Int_t ParamHistFunc::numBins ; (; ); const. inline . Definition at line 36 of file ParamHistFunc.h. ◆ paramList(). const RooArgList & ParamHistFunc::paramList ; (; ); const. inline . Definition at line 34 of file ParamHistFunc.h. ◆ plotSamplingHint(). std::list< double > * ParamHistFunc::plotSamplingHint ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ; Reimplemented from RooAbsReal.; Definition at line 686 of file ParamHistFunc.cxx. ◆ setConstant(). void ParamHistFunc::setConstant ; (; bool ; constant). Definition at line 233 of file ParamHistFunc.cxx. ◆ setParamConst(). void ParamHistFunc::setParamConst ; (; Int_t ; index, . bool ; varConst = true . ). Definition at line 227 of file ParamHistFunc.cxx. ◆ setShape(). void ParamHistFunc::setShape ; (; TH1 * ; shape). Definition at line 242 of file ParamHistFunc.cxx. ◆ Streamer(). void ParamHistFunc::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void ParamHistFunc::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 111 of file ParamHistFunc.h. ◆ translate(). void ParamHistFunc::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classParamHistFunc.html:72345,efficient,efficiently,72345,doc/master/classParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html,1,['efficient'],['efficiently']
Energy Efficiency,"rameters, vector<Double_t>& oldParameters, Double_t currentTemperature); voidGenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); TMVA::MsgLogger&Log() const; voidReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); voidSetDefaultScale(); Bool_tShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTemperature). Data Members; private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsepsilon; TMVA::IFitterTarget&fFitterTargetthe fitter target; Double_tfInitialTemperatureinitial temperature; enum EKernelTemperaturefKernelTemperature; TMVA::MsgLogger*fLoggermessage logger; Int_tfMaxCallsmaximum number of minimisation calls; Double_tfMinTemperaturemimimum temperature; Double_tfProgress; TRandom*fRandomrandom generator; const vector<TMVA::Interval*>&fRangesparameter ranges; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre); static TMVA::SimulatedAnnealing::EKernelTemperaturekDecreasingAdaptive; static TMVA::SimulatedAnnealing::EKernelTemperaturekGeo; static TMVA::SimulatedAnnealing::EKernelTemperaturekHomo; static TMVA::SimulatedAnnealing::EKernelTemperaturekIncreasingAdaptive; static TMVA::SimulatedAnnealing::EKernelTemperaturekLog; static TMVA::SimulatedAnnealing::EKernelTemperaturekSin; static TMVA::SimulatedAnnealing::EKernelTemperaturekSqrt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges); constructor. void SetOptions(Int_t maxCalls, Double_t initialTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__SimulatedAnnealing.html:2082,adapt,adaptive,2082,root/html602/TMVA__SimulatedAnnealing.html,https://root.cern,https://root.cern/root/html602/TMVA__SimulatedAnnealing.html,4,['adapt'],['adaptive']
Energy Efficiency,"rametricFunctionOneDim;  Specialized IParamFunction interface (abstract class) for one-dimensional parametric functions It is a derived class from ROOT::Math::IBaseFunctionOneDim and ROOT::Math::IBaseParam. More...;  ; class  IParametricGradFunctionMultiDimTempl;  Interface (abstract class) for parametric gradient multi-dimensional functions providing in addition to function evaluation with respect to the coordinates also the gradient with respect to the parameters, via the method ParameterGradient. More...;  ; class  IParametricGradFunctionOneDim;  Interface (abstract class) for parametric one-dimensional gradient functions providing in addition to function evaluation with respect the coordinates also the gradient with respect to the parameters, via the method ParameterGradient. More...;  ; class  IRootFinderMethod;  Interface for finding function roots of one-dimensional functions. More...;  ; class  KahanSum;  The Kahan summation is a compensated summation algorithm, which significantly reduces numerical errors when adding a sequence of finite-precision floating point numbers. More...;  ; class  KDTree;  ; class  LCGEngine;  ; class  LocalCoordinateSystemTag;  Tag for identifying vectors based on a local coordinate system. More...;  ; class  LorentzRotation;  Lorentz transformation class with the (4D) transformation represented by a 4x4 orthosymplectic matrix. More...;  ; class  LorentzVector;  Class describing a generic LorentzVector in the 4D space-time, using the specified coordinate system for the spatial vector part. More...;  ; class  LSResidualFunc;  LSResidualFunc class description. More...;  ; class  MathMoreLib;  ; class  MatRepStd;  Expression wrapper class for Matrix objects. More...;  ; class  MatRepSym;  MatRepSym Matrix storage representation for a symmetric matrix of dimension NxN This class is a template on the contained type and on the symmetric matrix size, N. More...;  ; class  MatrixMulOp;  Class for Matrix-Matrix multiplication. More...;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:19289,reduce,reduces,19289,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['reduce'],['reduces']
Energy Efficiency,"ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Double_tfAdaBoostBetaADA boost parameter, default is 1 ; vector<TH1*>fBTrainBgdMVAHist; vector<TH1*>fBTrainSigMVAHist; Double_tfBaggedSampleFractionrel.Size of bagged sample; UInt_tfBoostNumNumber of times the classifier is boosted; TStringfBoostTypestring specifying the boost type ; Double_tfBoostWeightthe weight used to boost the next classifier ; TStringfBoostedMethodNamedetails of the boosted classifier; TStringfBoostedMethodOptionsoptions; TStringfBoostedMethodTitletitle ; TMVA::DataSetManager*fDataSetManagerDSMTEST; Bool_tfDetailedMonitoringproduce detailed monitoring histograms (boost-wise); Bool_tfHistoricBoolOptionhistoric variable, only needed for ""CompatibilityOptions"" ; TStringfHistoricOptionhistoric variable, only needed for ""CompatibilityOptions"" ; vector<Float_t>*fMVAvaluesmva values for the last trained method; Double_tfMethodErrorestimation of the level error of the classifier ; Bool_tfMonitorBoostedMethodmonitor the MVA response of every classifier; TTree*fMonitorTreetree to monitor values during the boosting ; Double_tfOverlap_integral; Double_tfROC_trainingroc integral of last trained method (on training sample); UInt_tfRandomSeedseed for random number generator used for bagging; vector<TH1*>fTestBgdMVAHist; vector<TH1*>fTestSigMVAHist; vector<TH1*>fTrainBgdMVAHist; vector<TH1*>fTrainSigMVAHist; TStringfTransformStringmin and max values for the classifier response . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodBoost(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = NULL). MethodBoost(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = NULL). ~MethodBoost( void ); d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodBoost.html:18315,monitor,monitoring,18315,root/html534/TMVA__MethodBoost.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodBoost.html,2,['monitor'],"['monitor', 'monitoring']"
Energy Efficiency,"raphErrors.cxx:532; TGraphErrors::IsATClass * IsA() const overrideDefinition TGraphErrors.h:78; TGraphErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with errors from the collection to this graph.Definition TGraphErrors.cxx:682; TGraphErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphErrors.cxx:510; TGraphErrors::TGraphErrorsTGraphErrors()TGraphErrors default constructor.Definition TGraphErrors.cxx:69; TGraphErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:647; TGraphErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphErrors.cxx:722; TGraphErrors::Applyvoid Apply(TF1 *f) overrideApply function to all the data points .Definition TGraphErrors.cxx:396; TGraphErrors::CtorAllocateBool_t CtorAllocate()Constructor allocate.Definition TGraphErrors.cxx:557; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::Classstatic TClass * Class(); TGraph::AddPointvirtual void AddPoint(Double_t x, Double_t y)Append a new point to the graph.Definition TGraph.h:98; TGraph::fNpointsInt_t fNpointsNumber of points <= fMaxSize.Definition TGraph.h:46; TGraph::SetPointvirtual void SetPoint(Int_t i, Double_t x, Double_t y)Set x and y values for point number i.Definition TGraph.cxx:2342; TGraph::fMaxSizeInt_t fMaxSize!Current dimension of arrays fX and fYDefinition TGraph.h:45; TGraph::SaveHistogramAndFunctionsvoid SaveHistogramAndFunctions(std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option)Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes.Definition TGraph.cxx:2199; TGraph::fHistogramTH1F * fHistogramPointer to histogram used for drawing axis.Definition TGraph.h:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:36577,allocate,allocate,36577,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolors, Int_t *colors); if ncolors <= 0 a default palette (see below) of 50 colors; is defined. if ncolors == 1 && colors == 0, then; a Pretty Palette with a Spectrum Violet->Red is created. if ncolors > 50 and colors=0, the DeepSea palette is used.; (see TStyle::CreateGradientColorTable for more details). if ncolors > 0 and colors = 0, the default palette is used; with a maximum of ncolors. The default palette defines:; index 0->9 : ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAttImage.html:1386,allocate,allocated,1386,root/html526/TAttImage.html,https://root.cern,https://root.cern/root/html526/TAttImage.html,19,['allocate'],['allocated']
Energy Efficiency,"ray fElem; - j: the element number in the array of consecutive types; In the above example the class TAttLine has 3 consecutive data members; of the same type ""short"". Compile makes one single array of 3 elements.; To access the TStreamerElement for the second element; of this array, one can call:; TStreamerElement *el = GetStreamerElementReal(0,1);; const char* membername = el->GetName();; This function is typically called from TBuffer, TXmlBuffer. void InsertArtificialElements(const TObjArray* rules); Insert new members as expressed in the array of TSchemaRule(s). void ls(Option_t* option = """") const; List the TStreamerElement list and also the precomputed tables; if option contains the string ""incOrig"", also prints the original; (non-optimized elements in the list of compiled elements. void* New(void* obj = 0); An emulated object is created at address obj, if obj is null we; allocate memory for the object. void* NewArray(Long_t nElements, void* ary = 0); An array of emulated objects is created at address ary, if ary is null,; we allocate memory for the array. void DestructorImpl(void* p, Bool_t dtorOnly); Internal part of the destructor.; Destruct each of the datamembers in the same order; as the implicit destructor would. void Destructor(void* p, Bool_t dtorOnly = kFALSE); Emulated destructor for this class.; An emulated object is destroyed at address p.; Destruct each of the datamembers in the same order; as the implicit destructor would. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE); Destroy an array of emulated objects, with optional delete. void PrintValue(const char* name, char* pointer, Int_t i, Int_t len, Int_t lenmax = 1000) const; print value of element i in object at pointer; The function may be called in two ways:; -method1 len < 0; i is assumed to be the TStreamerElement number i in StreamerInfo; -method2 len >= 0; i is the type; address of variable is directly pointer.; len is the number of elements to be printed starting at pointer. void Prin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStreamerInfo.html:23086,allocate,allocate,23086,root/html534/TStreamerInfo.html,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html,3,['allocate'],['allocate']
Energy Efficiency,"rce = nullptr, . bool ; paramRelative = true . ). Definition at line 32 of file RooParamHistFunc.cxx. ◆ RooParamHistFunc() [3/3]. RooParamHistFunc::RooParamHistFunc ; (; const RooParamHistFunc & ; other, . const char * ; name = nullptr . ). Definition at line 62 of file RooParamHistFunc.cxx. Member Function Documentation. ◆ analyticalIntegralWN(). double RooParamHistFunc::analyticalIntegralWN ; (; Int_t ; code, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Implement analytical integrations by doing appropriate weighting from component integrals functions to integrators of components. ; Reimplemented from RooAbsReal.; Definition at line 212 of file RooParamHistFunc.cxx. ◆ binBoundaries(). std::list< double > * RooParamHistFunc::binBoundaries ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ; Reimplemented from RooAbsReal.; Definition at line 167 of file RooParamHistFunc.cxx. ◆ Class(). static TClass * RooParamHistFunc::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooParamHistFunc::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooParamHistFunc::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 63 of file RooParamHistFunc.h. ◆ clone(). TObject * RooParamHistFunc::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 30 of file RooParamHistFunc.h. ◆ DeclFileName(). static const char * RooParamHistFunc::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 63 of file RooParamHistFunc.h. ◆ evaluate(). doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooParamHistFunc.html:62125,efficient,efficiently,62125,doc/master/classRooParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooParamHistFunc.html,1,['efficient'],['efficiently']
Energy Efficiency,"rce > fSourceDefinition RNTupleReader.hxx:77; ROOT::Experimental::RNTupleReader::GetDirectAccessViewRNTupleDirectAccessView< T > GetDirectAccessView(std::string_view fieldName)Definition RNTupleReader.hxx:311; ROOT::Experimental::RNTupleReader::GetCollectionViewRNTupleCollectionView GetCollectionView(DescriptorId_t fieldId)Definition RNTupleReader.hxx:337; ROOT::Experimental::RNTupleReader::GetModelconst RNTupleModel & GetModel()Definition RNTupleReader.cxx:128; ROOT::Experimental::RNTupleReader::Openstatic std::unique_ptr< RNTupleReader > Open(std::string_view ntupleName, std::string_view storage, const RNTupleReadOptions &options=RNTupleReadOptions())Open an RNTuple for reading.Definition RNTupleReader.cxx:94; ROOT::Experimental::RNTupleReader::GetEntryRangeRNTupleGlobalRange GetEntryRange()Returns an iterator over the entry indices of the RNTuple.Definition RNTupleReader.hxx:246; ROOT::Experimental::RNTupleReader::fUnzipTasksstd::unique_ptr< Internal::RPageStorage::RTaskScheduler > fUnzipTasksSet as the page source's scheduler for parallel page decompression if IMT is on Needs to be destructe...Definition RNTupleReader.hxx:75; ROOT::Experimental::RNTupleReader::InitPageSourcevoid InitPageSource(bool enableMetrics)Definition RNTupleReader.cxx:46; ROOT::Experimental::RNTupleReader::GetViewRNTupleView< T > GetView(DescriptorId_t fieldId)Definition RNTupleReader.hxx:287; ROOT::Experimental::RNTupleReader::PrintInfovoid PrintInfo(const ENTupleInfo what=ENTupleInfo::kSummary, std::ostream &output=std::cout) constPrints a detailed summary of the ntuple, including a list of fields.Definition RNTupleReader.cxx:137; ROOT::Experimental::RNTupleReader::LoadEntryvoid LoadEntry(NTupleSize_t index)Analogous to Fill(), fills the default entry of the model.Definition RNTupleReader.hxx:219; ROOT::Experimental::RNTupleReader::fModelstd::unique_ptr< RNTupleModel > fModelNeeds to be destructed before fSource.Definition RNTupleReader.hxx:79; ROOT::Experimental::RNTupleReader::LoadEntr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleReader_8hxx_source.html:24461,schedul,scheduler,24461,doc/master/RNTupleReader_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleReader_8hxx_source.html,1,['schedul'],['scheduler']
Energy Efficiency,"rce,; TSpectrumOneDimFit *p,; int size);; This function fits the source spectrum. The calling program should fill in input parameters of the one_dim_fit structure The fitted parameters are written into structure pointed by one_dim_fit structure pointer and fitted data are written into source spectrum.; Function parameters:. source pointer to the vector of source spectrum; p pointer to the one_dim_fit structure pointer; size length of source spectrum. The one_dim_fit structure has the form:; class TSpectrumOneDimFit{. public:. int number_of_peaks; // input parameter, should be >0; int number_of_iterations; // input parameter, should be >0; int xmin; // first fitted channel; int xmax; // last fitted channel; double alpha; // convergence coefficient, input parameter, it should be; // positive number and <=1; double chi; // here the function returns resulting chi-square; int statistic_type; // type of statistics, possible values; // FIT1_OPTIM_CHI_COUNTS (chi square statistics with; // counts as weighting coefficients),; // FIT1_OPTIM_CHI_FUNC_VALUES (chi square statistics; // with function values as weighting coefficients); // FIT1_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values; // FIT1_ALPHA_HALVING,; // FIT1_ALPHA_OPTIMAL; int power; // possible values FIT1_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values; // FIT1_TAYLOR_ORDER_FIRST, FIT1_TAYLOR_ORDER_SECOND. double position_init[MAX_NUMBER_OF_PEAKS1]; // initial values of; // peaks positions, input parameters; double position_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values; // of fitted positions, output parameters; double position_err[MAX_NUMBER_OF_PEAKS1]; // position errors; bool fix_position[MAX_NUMBER_OF_PEAKS1]; // logical vector which allows to fix; // appropriate positions (not fit). However they; // are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks; // amplitudes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:39219,power,power,39219,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,1,['power'],['power']
Energy Efficiency,"rd declaration.; 4243 const cling::LookupHelper& lh = fInterpreter->getLookupHelper();; 4244 const clang::Type *type = nullptr;; 4245 const clang::Decl *decl; 4246 = lh.findScope(classname,; 4247 gDebug > 5 ? cling::LookupHelper::WithDiagnostics; 4248 : cling::LookupHelper::NoDiagnostics,; 4249 &type, /* intantiateTemplate= */ false );; 4250 if (!decl) {; 4251 std::string buf = TClassEdit::InsertStd(classname);; 4252 decl = lh.findScope(buf,; 4253 gDebug > 5 ? cling::LookupHelper::WithDiagnostics; 4254 : cling::LookupHelper::NoDiagnostics,; 4255 &type,false);; 4256 }; 4257 ; 4258 if (type) {; 4259 // If decl==0 and the type is valid, then we have a forward declaration.; 4260 if (!decl) {; 4261 // If we have a forward declaration for a class template instantiation,; 4262 // we want to ignore it if it was produced/induced by the call to; 4263 // findScope, however we can not distinguish those from the; 4264 // instantiation induce by 'soft' use (and thus also induce by the; 4265 // same underlying code paths); 4266 // ['soft' use = use not requiring a complete definition]; 4267 // So to reduce the amount of disruption to the existing code we; 4268 // would just ignore those for STL collection, for which we really; 4269 // need to have the compiled collection proxy (and thus the TClass; 4270 // bootstrap).; 4271 clang::ClassTemplateSpecializationDecl *tmpltDecl =; 4272 llvm::dyn_cast_or_null<clang::ClassTemplateSpecializationDecl>; 4273 (type->getAsCXXRecordDecl());; 4274 if (tmpltDecl && !tmpltDecl->getPointOfInstantiation().isValid()) {; 4275 // Since the point of instantiation is invalid, we 'guess' that; 4276 // the 'instantiation' of the forwarded type appended in; 4277 // findscope.; 4278 if (ROOT::TMetaUtils::IsSTLCont(*tmpltDecl)) {; 4279 // For STL Collection we return kUnknown.; 4280 return kUnknown;; 4281 }; 4282 }; 4283 }; 4284 TClingClassInfo tci(GetInterpreterImpl(), *type);; 4285 if (!tci.IsValid()) {; 4286 return kUnknown;; 4287 }; 4288 auto propertiesMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:165807,reduce,reduce,165807,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['reduce'],['reduce']
Energy Efficiency,"rd); ; return d; ; ; # Set up composed model gauss(x, m(y), s); # -----------------------------------------------------------------------; ; # Create observables; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); y = ROOT.RooRealVar(""y"", ""y"", -10, 10); ; # Create function f(y) = a0 + a1*y; a0 = ROOT.RooRealVar(""a0"", ""a0"", -0.5, -5, 5); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -1, 1); fy = ROOT.RooPolyVar(""fy"", ""fy"", y, [a0, a1]); ; # Creat gauss(x,f(y),s); sigma = ROOT.RooRealVar(""sigma"", ""width of gaussian"", 0.5, 0.1, 2.0); model = ROOT.RooGaussian(""model"", ""Gaussian with shifting mean"", x, fy, sigma); ; # Obtain fake external experimental dataset with values for x and y; expDataXY = makeFakeDataXY(); ; # Generate data from conditional p.d.f. model(x|y); # ---------------------------------------------------------------------------------------------; ; # Make subset of experimental data with only y values; expDataY = expDataXY.reduce({y}); ; # Generate 10000 events in x obtained from _conditional_ model(x|y) with y; # values taken from experimental data; data = model.generate({x}, ProtoData=expDataY); data.Print(); ; # Fit conditional p.d.f model(x|y) to data; # ---------------------------------------------------------------------------------------------; ; model.fitTo(expDataXY, ConditionalObservables={y}, PrintLevel=-1); ; # Project conditional p.d.f on x and y dimensions; # ---------------------------------------------------------------------------------------------; ; # Plot x distribution of data and projection of model x = 1/Ndata; # sum(data(y_i)) model(x;y_i); xframe = x.frame(); expDataXY.plotOn(xframe); model.plotOn(xframe, ProjWData=expDataY); ; # Speed up (and approximate) projection by using binned clone of data for; # projection; binnedDataY = expDataY.binnedClone(); model.plotOn(xframe, ProjWData=binnedDataY, LineColor=""c"", LineStyle="":""); ; # Show effect of projection with too coarse binning; (expDataY.get().find(""y"")).setBins(5); binnedDataY2 = expDataY.binnedCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf303__conditional_8py.html:1686,reduce,reduce,1686,doc/master/rf303__conditional_8py.html,https://root.cern,https://root.cern/doc/master/rf303__conditional_8py.html,1,['reduce'],['reduce']
Energy Efficiency,"rd. ;  ; OneDimMultiFunctionAdapter & operator= (const OneDimMultiFunctionAdapter &rhs);  . Private Attributes; unsigned int fCoord;  ; unsigned int fDim;  ; MultiFuncType fFunc;  ; bool fOwn;  ; const double * fParams;  ; double * fX;  . Additional Inherited Members;  Public Types inherited from ROOT::Math::IBaseFunctionOneDim; typedef IBaseFunctionOneDim BaseFunc;  . #include <Math/OneDimFunctionAdapter.h>. Inheritance diagram for ROOT::Math::OneDimMultiFunctionAdapter< MultiFuncType >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ OneDimMultiFunctionAdapter() [1/3]. template<class MultiFuncType = const ROOT::Math::IMultiGenFunction &> . ROOT::Math::OneDimMultiFunctionAdapter< MultiFuncType >::OneDimMultiFunctionAdapter ; (; MultiFuncType ; f, . const double * ; x, . unsigned int ; icoord = 0, . const double * ; p = nullptr . ). inline . Constructor from the function object , pointer to an external array of x values and coordinate we want to adapt. ; Definition at line 65 of file OneDimFunctionAdapter.h. ◆ OneDimMultiFunctionAdapter() [2/3]. template<class MultiFuncType = const ROOT::Math::IMultiGenFunction &> . ROOT::Math::OneDimMultiFunctionAdapter< MultiFuncType >::OneDimMultiFunctionAdapter ; (; MultiFuncType ; f, . unsigned int ; dim = 1, . unsigned int ; icoord = 0, . const double * ; p = nullptr . ). inline . Constructor from the function object , dimension of the function and and coordinate we want to adapt. ; The coordinate cached vector is created inside and eventually the values must be passed later with the SetX which will copy them ; Definition at line 81 of file OneDimFunctionAdapter.h. ◆ ~OneDimMultiFunctionAdapter(). template<class MultiFuncType = const ROOT::Math::IMultiGenFunction &> . ROOT::Math::OneDimMultiFunctionAdapter< MultiFuncType >::~OneDimMultiFunctionAdapter ; (; ). inlineoverride . Destructor (no operations) ; Definition at line 95 of file OneD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1OneDimMultiFunctionAdapter.html:3646,adapt,adapt,3646,doc/master/classROOT_1_1Math_1_1OneDimMultiFunctionAdapter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1OneDimMultiFunctionAdapter.html,1,['adapt'],['adapt']
Energy Efficiency,"rdErrorsPtr[i] = fCoordErrors[i].empty() ? nullptr : &fCoordErrors[i].front();; 283 }; 284 }; 285 // copy data error; 286 fDataError = rhs.fDataError;; 287 if (!fDataError.empty()) {; 288 assert(kValueError == fErrorType || kCoordError == fErrorType);; 289 fDataErrorPtr = &fDataError.front();; 290 }; 291 // copy the asymmetric data error; 292 fDataErrorHigh = rhs.fDataErrorHigh;; 293 fDataErrorLow = rhs.fDataErrorLow;; 294 // both error low and high should be empty or not; 295 assert( fDataErrorLow.empty() == fDataErrorHigh.empty()) ;; 296 if (!fDataErrorHigh.empty() && !fDataErrorLow.empty()) {; 297 assert(kAsymError == fErrorType);; 298 fDataErrorHighPtr = &fDataErrorHigh.front();; 299 fDataErrorLowPtr = &fDataErrorLow.front();; 300 }; 301 }; 302 ; 303 fpTmpCoordErrorVector= new double[ fDim ];; 304 ; 305 if ( HasBinEdges() ); 306 fpTmpBinEdgeVector = new double[ fDim ];; 307 ; 308 return *this;; 309 }; 310 ; 311 ; 312 /**; 313 preallocate a data set with given size , dimension and error type (to get the full point size); 314 If the data set already exists and it is having the compatible point size space for the new points; 315 is created in the data sets, while if not compatible the old data are erased and new space of; 316 new size is allocated.; 317 (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints); 318 */; 319 ; 320 void BinData::Append( unsigned int newPoints, unsigned int dim , ErrorType err ); 321 {; 322 assert( !fWrapped );; 323 assert( fMaxPoints == 0 || fWrapped == fData.empty() );; 324 ; 325 assert( kValueError == fErrorType || kCoordError == fErrorType ||; 326 kAsymError == fErrorType || kNoError == fErrorType );; 327 assert( fMaxPoints == 0 || fDataError.empty() || &fDataError.front() == fDataErrorPtr );; 328 assert( fMaxPoints == 0 || fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 329 assert( fMaxPoints == 0 || fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 330 assert( fMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:9145,allocate,allocated,9145,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"re reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void SetAddress(void* addobj); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the AutoDelete bit. This function can be used to instruct Root in TBranchObject::ReadBasket; to not delete the object referenced by a branchobject before reading a; new entry. By default, the object is deleted.; If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then object->Streamer called.; If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; This can be done in Streamer itself.; If this branch has sub-branches, the function sets autodel for these; branches as well.; We STRONGLY suggest to activate this option by default when you create; the top level branch. This will make the read phase more efficient; because it minimizes the numbers of new/delete operations.; Once this option has been set and the Tree is written to a file, it is; not necessary to specify the option again when reading, unless you; want to set the opposite mode. void SetBasketSize(Int_t buffsize); Reset basket size for all subbranches of this branch. void Streamer(TBuffer& ); Stream an object of class TBranchObject. void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void UpdateAddress(); Update branch addresses if a new object was created. TBranchObject(). const char* GetClassName() const; { return fClassName.Data(); }. const char* GetObjClassName(); { return fClassName.Data(); }. » Author: Rene Brun 11/02/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 15:38; This page has been automat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TBranchObject.html:16974,efficient,efficient,16974,root/html604/TBranchObject.html,https://root.cern,https://root.cern/root/html604/TBranchObject.html,1,['efficient'],['efficient']
Energy Efficiency,"re reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void SetAddress(void* addobj); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the AutoDelete bit. This function can be used to instruct Root in TBranchObject::ReadBasket; to not delete the object referenced by a branchobject before reading a; new entry. By default, the object is deleted.; If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then object->Streamer called.; If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; This can be done in Streamer itself.; If this branch has sub-branches, the function sets autodel for these; branches as well.; We STRONGLY suggest to activate this option by default when you create; the top level branch. This will make the read phase more efficient; because it minimizes the numbers of new/delete operations.; Once this option has been set and the Tree is written to a file, it is; not necessary to specify the option again when reading, unless you; want to set the opposite mode. void SetBasketSize(Int_t buffsize); Reset basket size for all subbranches of this branch. void Streamer(TBuffer& ); Stream an object of class TBranchObject. void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void UpdateAddress(); Update branch addresses if a new object was created. TBranchObject(). const char* GetClassName() const; { return fClassName.Data(); }. const char* GetObjClassName(); { return fClassName.Data(); }. » Author: Rene Brun 11/02/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-30 14:40; This page has been automat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBranchObject.html:16974,efficient,efficient,16974,root/html602/TBranchObject.html,https://root.cern,https://root.cern/root/html602/TBranchObject.html,1,['efficient'],['efficient']
Energy Efficiency,"re reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void SetAddress(void* addobj); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the AutoDelete bit. This function can be used to instruct Root in TBranchObject::ReadBasket; to not delete the object referenced by a branchobject before reading a; new entry. By default, the object is deleted.; If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then object->Streamer called.; If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; This can be done in Streamer itself.; If this branch has sub-branches, the function sets autodel for these; branches as well.; We STRONGLY suggest to activate this option by default when you create; the top level branch. This will make the read phase more efficient; because it minimizes the numbers of new/delete operations.; Once this option has been set and the Tree is written to a file, it is; not necessary to specify the option again when reading, unless you; want to set the opposite mode. void SetBasketSize(Int_t buffsize); Reset basket size for all subbranches of this branch. void Streamer(TBuffer& ); Stream an object of class TBranchObject. void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void UpdateAddress(); Update branch addresses if a new object was created. const char* GetClassName() const; { return fClassName.Data(); }. const char* GetObjClassName(); { return fClassName.Data(); }. » Author: Rene Brun 11/02/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-03-12 16:37; This page has been automatically generated.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBranchObject.html:16396,efficient,efficient,16396,root/html534/TBranchObject.html,https://root.cern,https://root.cern/root/html534/TBranchObject.html,1,['efficient'],['efficient']
Energy Efficiency,"re reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void SetAddress(void* addobj); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the AutoDelete bit. This function can be used to instruct Root in TBranchObject::ReadBasket; to not delete the object referenced by a branchobject before reading a; new entry. By default, the object is deleted.; If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then object->Streamer called.; If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; This can be done in Streamer itself.; If this branch has sub-branches, the function sets autodel for these; branches as well.; We STRONGLY suggest to activate this option by default when you create; the top level branch. This will make the read phase more efficient; because it minimizes the numbers of new/delete operations.; Once this option has been set and the Tree is written to a file, it is; not necessary to specify the option again when reading, unless you; want to set the opposite mode. void SetBasketSize(Int_t buffsize); Reset basket size for all subbranches of this branch. void Streamer(TBuffer& b); Stream an object of class TBranchObject. void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void UpdateAddress(); Update branch addresses if a new object was created. const char* GetClassName() const; { return fClassName.Data(); }. const char* GetObjClassName(); { return fClassName.Data(); }. » Author: Rene Brun 11/02/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchObject.h 39611 2011-06-08 19:35:17Z pcanal $ » Last generated: 2011-11-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBranchObject.html:16304,efficient,efficient,16304,root/html532/TBranchObject.html,https://root.cern,https://root.cern/root/html532/TBranchObject.html,1,['efficient'],['efficient']
Energy Efficiency,"re the bbox is comp...Definition TGeoVoxelFinder.cxx:2419; TGeoVoxelFinder::FindOverlapsvirtual void FindOverlaps(Int_t inode) constcreate the list of nodes for which the bboxes overlap with inode's bboxDefinition TGeoVoxelFinder.cxx:329; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TIterDefinition TCollection.h:235; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TKey::GetClassNamevirtual const char * GetClassName() constDefinition TKey.h:75; TKey::ReadObjvirtual TObject * ReadObj()To read a TObject* from the file.Definition TKey.cxx:759; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TMap::Addvoid Add(TObject *obj) overrideThis function may not be used (but we need to provide it since it is a pure virtual in TCollection).Definition TMap.cxx:54; TMap::GetValueTObject * GetValue(const char *keyname) constReturns a pointer to the value associated with keyname as name of the key.Definition TMap.cxx:236; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::fTitleTString fTitleDefinition TNamed.h:33; TNamed::fNameTString fNameDefinition TNamed.h:32; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:156955,efficient,efficient,156955,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['efficient'],['efficient']
Energy Efficiency,"re used.Definition TGX11.h:146; TGX11::SelectWindowvoid SelectWindow(Int_t wid) overrideSelect window to which subsequent output is directed.Definition TGX11.cxx:1958; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjStringCollectable string class.Definition TObjString.h:28; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPointDefinition TPoint.h:31; TStorage::Allocstatic void * Alloc(size_t size)Allocate a block of memory, that later can be resized using TStorage::ReAlloc().Definition TStorage.cxx:152; TStorage::Deallocstatic void Dealloc(void *ptr)De-allocate block of memory, that was allocated via TStorage::Alloc().Definition TStorage.cxx:170; TStorage::ReAllocstatic void * ReAlloc(void *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:183; TStringBasic string class.Definition TString.h:139; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TStyle::GetLineStyleStringconst char * GetLineStyleString(Int_t i=1) constReturn line style string (used by PostScript).Definition TStyle.cxx:1166; TVirtualXSemi-Abstract base class defining a generic interface to the underlying, low level,...Definition TVirtualX.h:46; TVirtualX::EDrawModeEDrawModeDefinition TVirtualX.h:49; TVirtualX::kXor@ kXorDefinition TVirtualX.h:49; TVirtualX::kCopy@ kCopyDefinition TVirtualX.h:49; TVirtualX::kInvert@ kInvertDefinition TVirtualX.h:49; TVirtualX::ETextModeETextModeDefinition TVirtualX.h:51; TVirtualX::kOpaque@ kOpaqueDefinition TVir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:159066,allocate,allocate,159066,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"re, bool isSimple, std::size_t nRepetitions=0);  The constructor creates the underlying column objects and connects them to either a sink or a source. ;  ; virtual ~RFieldBase ()=default;  ; virtual void AcceptVisitor (Detail::RFieldVisitor &visitor) const;  ; RSchemaIterator begin ();  ; RConstSchemaIterator begin () const;  ; RValue BindValue (std::shared_ptr< void > objPtr);  Creates a value from a memory location with an already constructed object. ;  ; RConstSchemaIterator cbegin () const;  ; RConstSchemaIterator cend () const;  ; std::unique_ptr< RFieldBase > Clone (std::string_view newName) const;  Copies the field and its sub fields using a possibly new name and a new, unconnected set of columns. ;  ; RBulk CreateBulk ();  The returned bulk is initially empty; RBulk::ReadBulk will construct the array of values. ;  ; template<> ; std::unique_ptr< void, typename RFieldBase::RCreateObjectDeleter< void >::deleter > CreateObject () const;  ; template<typename T > ; std::unique_ptr< T, typename RCreateObjectDeleter< T >::deleter > CreateObject () const;  Generates an object of the field type and allocates new initialized memory according to the type. ;  ; template<> ; std::unique_ptr< void, typename ROOT::Experimental::RFieldBase::RCreateObjectDeleter< void >::deleter > CreateObject () const;  ; RValue CreateValue ();  Generates an object of the field type and wraps the created object in a shared pointer and returns it an RValue connected to the field. ;  ; RSchemaIterator end ();  ; RConstSchemaIterator end () const;  ; virtual size_t GetAlignment () const =0;  As a rule of thumb, the alignment is equal to the size of the type. ;  ; RColumnRepresentations::Selection_t GetColumnRepresentatives () const;  Returns the fColumnRepresentative pointee or, if unset, the field's default representative. ;  ; const std::string & GetDescription () const;  Get the field's description. ;  ; const std::string & GetFieldName () const;  ; virtual std::uint32_t GetFieldVersion () ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html:3817,allocate,allocates,3817,doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,1,['allocate'],['allocates']
Energy Efficiency,"read-ahead cache. ;  ; Double_t fCompress;  Tree compression factor. ;  ; Double_t fCpuTime;  Cpu time. ;  ; Double_t fDiskTime;  Time spent in pure raw disk IO. ;  ; TFile * fFile;  ! Pointer to the file containing the Tree ;  ; TGraphErrors * fGraphIO;  Pointer to the graph with IO data. ;  ; TGraphErrors * fGraphTime;  Pointer to the graph with timestamp info. ;  ; TString fHostInfo;  Name of the host system, ROOT version and date. ;  ; TText * fHostInfoText;  Graphics Text object with the fHostInfo data. ;  ; TString fName;  Name of this TTreePerfStats. ;  ; Int_t fNleaves;  Number of leaves in the tree. ;  ; TPaveText * fPave;  Pointer to annotation pavetext. ;  ; Int_t fReadaheadSize;  Read-ahead cache size. ;  ; Int_t fReadCalls;  Number of read calls. ;  ; Double_t fRealNorm;  Real time scale factor for fGraphTime. ;  ; Double_t fRealTime;  Real time. ;  ; TGaxis * fRealTimeAxis;  Pointer to TGaxis object showing real-time. ;  ; TTree * fTree;  ! Pointer to the Tree being monitored ;  ; Int_t fTreeCacheSize;  TTreeCache buffer size. ;  ; Long64_t fUnzipInputSize;  Compressed bytes seen by the decompressor. ;  ; Long64_t fUnzipObjSize;  Uncompressed bytes produced by the decompressor. ;  ; Double_t fUnzipTime;  Time spent uncompressing the data. ;  ; TStopwatch * fWatch;  TStopwatch pointer. ;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TTreePerfStats.h>. Inheritance diagram for TTreePerfStats:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ BasketList_t. using TTreePerfStats::BasketList_t = std::vector<std::pair<TBranch*, std::vector<size_t> >>. Definition at line 48 of file TTreePerfStats.h. Constructor & Destructor Documentation. ◆ TTreePerfStats() [1/2]. TTreePerfStats::TTreePerfStats ; (; ). default constructor (used when reading an object only) ; Definition at line 107 of file TTreePerfSta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePerfStats.html:18753,monitor,monitored,18753,doc/master/classTTreePerfStats.html,https://root.cern,https://root.cern/doc/master/classTTreePerfStats.html,1,['monitor'],['monitored']
Energy Efficiency,"reading; } ///< is multithreading turned on?; 816 ; 817 ; 818 void pads (int numPads) { if (fMonitoring) fMonitoring->pads (numPads); } ///< preparation for monitoring; 819 void create (std::string histoName, int bins, double min, double max) { if (fMonitoring) fMonitoring->create (histoName, bins, min, max); } ///< for monitoring; 820 void create (std::string histoName, int bins, double min, double max, int bins2, double min2, double max2) { if (fMonitoring) fMonitoring->create (histoName, bins, min, max, bins2, min2, max2); } ///< for monitoring; 821 void addPoint (std::string histoName, double x) { if (fMonitoring) fMonitoring->addPoint (histoName, x); } ///< for monitoring; 822 void addPoint (std::string histoName, double x, double y) {if (fMonitoring) fMonitoring->addPoint (histoName, x, y); } ///< for monitoring; 823 void plot (std::string histoName, std::string options, int pad, EColor color) { if (fMonitoring) fMonitoring->plot (histoName, options, pad, color); } ///< for monitoring; 824 void clear (std::string histoName) { if (fMonitoring) fMonitoring->clear (histoName); } ///< for monitoring; 825 bool exists (std::string histoName) { if (fMonitoring) return fMonitoring->exists (histoName); return false; } ///< for monitoring; 826 ; 827 size_t convergenceCount () const { return m_convergenceCount; } ///< returns the current convergence count; 828 size_t maxConvergenceCount () const { return m_maxConvergenceCount; } ///< returns the max convergence count so far; 829 size_t minError () const { return m_minError; } ///< returns the smallest error so far; 830 ; 831 public:; 832 Timer m_timer; ///< timer for monitoring; 833 double m_minProgress; ///< current limits for the progress bar; 834 double m_maxProgress; ///< current limits for the progress bar; 835 ; 836 ; 837 size_t m_convergenceSteps; ///< number of steps without improvement to consider the DNN to have converged; 838 size_t m_batchSize; ///< mini-batch size; 839 size_t m_testRepetitions;; 840 double m_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:31354,monitor,monitoring,31354,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['monitor'],['monitoring']
Energy Efficiency,"ready filled. h3 = h1->GetAsymmetry(h2). then 'h3' is created and filled with the asymmetry between 'h1' and 'h2';; h1 and h2 are left intact. Note that it is the user's responsibility to manage the created histogram. code proposed by Jason Seely (seely@mit.edu) and adapted by R.Brun. clone the histograms so top and bottom will have the; correct dimensions:; Sumw2 just makes sure the errors will be computed properly; when we form sums and ratios below. Int_t GetDefaultBufferSize(); static function; return the default buffer size for automatic histograms; the parameter fgBufferSize may be changed via SetDefaultBufferSize. Bool_t GetDefaultSumw2(); static function; return kTRUE if TH1::Sumw2 must be called when creating new histograms.; see TH1::SetDefaultSumw2. Double_t GetEntries() const; return the current number of entries. Double_t GetEffectiveEntries() const; number of effective entries of the histogram,; i.e. the number of unweighted entries a histogram would need to; have the same statistical power as this histogram with possibly; weighted entries (i.e. <= TH1::GetEntries()). char * GetObjectInfo(Int_t px, Int_t py) const; Redefines TObject::GetObjectInfo.; Displays the histogram info (bin number, contents, integral up to bin; corresponding to cursor position px,py. TVirtualHistPainter * GetPainter(Option_t* option = """"); return pointer to painter; if painter does not exist, it is created. Int_t GetQuantiles(Int_t nprobSum, Double_t* q, const Double_t* probSum = 0); Compute Quantiles for this histogram; Quantile x_q of a probability distribution Function F is defined as. F(x_q) = q with 0 <= q <= 1. For instance the median x_0.5 of a distribution is defined as that value; of the random variable for which the distribution function equals 0.5:. F(x_0.5) = Probability(x < x_0.5) = 0.5. code from Eddy Offermann, Renaissance. input parameters; - this 1-d histogram (TH1F,D,etc). Could also be a TProfile; - nprobSum maximum size of array q and size of array probSum (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:83615,power,power,83615,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,3,['power'],['power']
Energy Efficiency,"reating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_BDT.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_BDT.class.C␛[0m; : TMVAC.root:/dataset/Method_BDT/BDT; Factory : Training finished; : ; Factory : Train method: RuleFit for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ RuleFit ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : This method uses a collection of so called rules to create a; : discriminating scoring function. Each rule consists of a series; : of cuts in parameter space. The ensemble of rules are created; : from a forest of decision trees, trained using the training data.; : Each node (apart from the root) corresponds to one rule.; : The scoring function is then obtained by linearly combining; : the rules. A fitting procedure is applied to find the optimum; : set of coefficients. The goal is to find a model with few rules; : but with a strong discriminating power.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : There are two important considerations to make when optimising:; : ; : 1. Topology of the decision tree forest; : 2. Fitting of the coefficients; : ; : The maximum complexity of the rules is defined by the size of; : the trees. Large trees will yield many complex rules and capture; : higher order correlations. On the other hand, small trees will; : lead to a smaller ensemble with simple rules, only capable of; : modeling simple structures.; : Several parameters exists for controlling the complexity of the; : rule ensemble.; : ; : The fitting procedure searches for a minimum using a gradient; : directed path. Apart from step size and number of steps, the; : evolution of the path is defined by a cut-off parameter, tau.; : This parameter is unknown and depends on the training data.; : A large value will tend to give large weights to a few rules.; : Similarly, a small value will lead to a large ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:52701,power,power,52701,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['power'],['power']
Energy Efficiency,"rec;  GD path: precision of estimated tau. ;  ; UInt_t fGDTauScan;  GD path: number of points to scan. ;  ; Double_t fGDValidEveFrac;  GD path: fraction of subsamples used for the fitting. ;  ; Double_t fLinQuantile;  quantile cut to remove outliers - see RuleEnsemble ;  ; Double_t fMaxFracNEve;  ditto max ;  ; Double_t fMinFracNEve;  min fraction of number events ;  ; Double_t fMinimp;  rule/linear: minimum importance ;  ; TString fModelTypeS;  rule ensemble: which model (rule,linear or both) ;  ; TTree * fMonitorNtuple;  pointer to monitor rule ntuple ;  ; Int_t fNCuts;  grid used in cut applied in node splitting ;  ; Double_t fNTCoefficient;  ntuple: rule coefficient ;  ; Double_t fNTImportance;  ntuple: rule importance ;  ; Int_t fNTNcuts;  ntuple: rule number of cuts ;  ; Int_t fNTNvars;  ntuple: rule number of vars ;  ; Double_t fNTPbb;  ntuple: rule P(tag b, true b) ;  ; Double_t fNTPbs;  ntuple: rule P(tag b, true s) ;  ; Double_t fNTPsb;  ntuple: rule P(tag s, true b) ;  ; Double_t fNTPss;  ntuple: rule P(tag s, true s) ;  ; Double_t fNTPtag;  ntuple: rule P(tag) ;  ; Int_t fNTrees;  number of trees in forest ;  ; Double_t fNTSSB;  ntuple: rule S/(S+B) ;  ; Double_t fNTSupport;  ntuple: rule support ;  ; Int_t fNTType;  ntuple: rule type (+1->signal, -1->bkg) ;  ; TMVA::DecisionTree::EPruneMethod fPruneMethod;  forest generation: method used for pruning - see DecisionTree ;  ; TString fPruneMethodS;  forest generation: prune method - see DecisionTree ;  ; Double_t fPruneStrength;  forest generation: prune strength - see DecisionTree ;  ; Int_t fRFNendnodes;  max number of rules (only Friedmans module) ;  ; Int_t fRFNrules;  max number of rules (only Friedmans module) ;  ; TString fRFWorkDir;  working directory from Friedmans module ;  ; RuleFit fRuleFit;  RuleFit instance. ;  ; TString fRuleFitModuleS;  which rulefit module to use ;  ; Double_t fRuleMinDist;  rule min distance - see RuleEnsemble ;  ; SeparationBase * fSepType;  the separation used in node s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodRuleFit.html:28778,monitor,monitor,28778,doc/master/classTMVA_1_1MethodRuleFit.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodRuleFit.html,1,['monitor'],['monitor']
Energy Efficiency,"recision should be at least 1e-7; # for normalization integrals for MINUIT to succeed.; #; ROOT.RooAbsReal.defaultIntegratorConfig().setEpsAbs(1e-6); ROOT.RooAbsReal.defaultIntegratorConfig().setEpsRel(1e-6); ; # N u m e r i c i n t e g r a t i o n o f l a n d a u p d f; # ------------------------------------------------------------------; ; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); landau = ROOT.RooLandau(""landau"", ""landau"", x, 0.0, 0.1); ; # Disable analytic integration from demonstration purposes; landau.forceNumInt(True); ; # Activate debug-level messages for topic integration to be able to follow; # actions below; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Integration); ; # Calculate integral over landau with default choice of numeric integrator; intLandau = landau.createIntegral({x}); val = intLandau.getVal(); print("" [1] int_dx landau(x) = "", val) # setprecision(15); ; # Same with custom configuration; # -----------------------------------------------------------; ; # Construct a custom configuration which uses the adaptive Gauss-Kronrod technique; # for closed 1D integrals; customConfig = ROOT.RooNumIntConfig(ROOT.RooAbsReal.defaultIntegratorConfig()); integratorGKNotExisting = customConfig.method1D().setLabel(""RooAdaptiveGaussKronrodIntegrator1D""); if integratorGKNotExisting:; print(""WARNING: RooAdaptiveGaussKronrodIntegrator is not existing because ROOT is built without Mathmore support""); ; # Calculate integral over landau with custom integral specification; intLandau2 = landau.createIntegral({x}, NumIntConfig=customConfig); val2 = intLandau2.getVal(); print("" [2] int_dx landau(x) = "", val2); ; # Adjusting default config for a specific pdf; # -------------------------------------------------------------------------------------; ; # Another possibility: associate custom numeric integration configuration; # as default for object 'landau'; landau.setIntegratorConfig(customConfig); ; # Calculate integral over landau custom numer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf901__numintconfig_8py.html:2310,adapt,adaptive,2310,doc/master/rf901__numintconfig_8py.html,https://root.cern,https://root.cern/doc/master/rf901__numintconfig_8py.html,1,['adapt'],['adaptive']
Energy Efficiency,"ree(""tree"",""treelibrated tree"");; Event *e = new Event;; ; // create a branch with energy; tree->Branch(""event"",&e);; ; // fill some events with random numbers; Int_t nevent=10000;; for (Int_t iev=0;iev<nevent;iev++) {; if (iev%1000==0) cout<<""Processing event ""<<iev<<""...""<<endl;; ; Float_t ea,eb;; gRandom->Rannor(ea,eb); // the two energies follow a gaus distribution; e->a.e=ea;; e->b.e=eb;; e->a.t=gRandom->Rndm(); // random; e->b.t=e->a.t + gRandom->Gaus(0.,.1); // identical to a.t but a gaussian; // 'resolution' was added with sigma .1; ; tree->Fill(); // fill the tree with the current event; }; ; // start the viewer; // here you can investigate the structure of your Event class; tree->StartViewer();; ; //gROOT->SetStyle(""Plain""); // uncomment to set a different style; ; // now draw some tree variables; TCanvas *c1 = new TCanvas();; c1->Divide(2,2);; c1->cd(1);; tree->Draw(""a.e""); //energy of det a; tree->Draw(""a.e"",""3*(-.2<b.e && b.e<.2)"",""same""); // same but with condition on energy b; scaled by 3; c1->cd(2);; tree->Draw(""b.e:a.e"","""",""colz""); // one energy against the other; c1->cd(3);; tree->Draw(""b.t"","""",""e""); // time of b with errorbars; tree->Draw(""a.t"","""",""same""); // overlay time of detector a; c1->cd(4);; tree->Draw(""b.t:a.t""); // plot time b again time a; ; cout<<endl;; cout<<""You can now examine the structure of your tree in the TreeViewer""<<endl;; cout<<endl;; }; ; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RSha256.hxx:99; Riostream.h; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; ClassImp#define ClassImp(name)Definition Rtypes.h:382; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TCanvas.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TStyle.h; TTree.h; TCanvasThe Canvas class.Definition TCanvas.h:23; TObjectMother of all ROOT objects.Definition TObject.h:41; TRandom::Gausvirtual Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree0_8C.html:2531,energy,energy,2531,doc/master/tree0_8C.html,https://root.cern,https://root.cern/doc/master/tree0_8C.html,1,['energy'],['energy']
Energy Efficiency,"ree::ResetAfterMerge(TFileMergeInfo *info); 8036{; 8037 fEntries = 0;; 8038 fNClusterRange = 0;; 8039 fTotBytes = 0;; 8040 fZipBytes = 0;; 8041 fSavedBytes = 0;; 8042 fFlushedBytes = 0;; 8043 fTotalBuffers = 0;; 8044 fChainOffset = 0;; 8045 fReadEntry = -1;; 8046 ; 8047 delete fTreeIndex;; 8048 fTreeIndex = nullptr;; 8049 ; 8050 Int_t nb = fBranches.GetEntriesFast();; 8051 for (Int_t i = 0; i < nb; ++i) {; 8052 TBranch* branch = (TBranch*) fBranches.UncheckedAt(i);; 8053 branch->ResetAfterMerge(info);; 8054 }; 8055 ; 8056 if (fBranchRef) {; 8057 fBranchRef->ResetAfterMerge(info);; 8058 }; 8059}; 8060 ; 8061////////////////////////////////////////////////////////////////////////////////; 8062/// Tell all of our branches to set their addresses to zero.; 8063///; 8064/// Note: If any of our branches own any objects, they are deleted.; 8065 ; 8066void TTree::ResetBranchAddress(TBranch *br); 8067{; 8068 if (br && br->GetTree()) {; 8069 br->ResetAddress();; 8070 }; 8071}; 8072 ; 8073////////////////////////////////////////////////////////////////////////////////; 8074/// Tell all of our branches to drop their current objects and allocate new ones.; 8075 ; 8076void TTree::ResetBranchAddresses(); 8077{; 8078 TObjArray* branches = GetListOfBranches();; 8079 Int_t nbranches = branches->GetEntriesFast();; 8080 for (Int_t i = 0; i < nbranches; ++i) {; 8081 TBranch* branch = (TBranch*) branches->UncheckedAt(i);; 8082 branch->ResetAddress();; 8083 }; 8084}; 8085 ; 8086////////////////////////////////////////////////////////////////////////////////; 8087/// Loop over tree entries and print entries passing selection. Interactive; 8088/// pagination break is on by default.; 8089///; 8090/// - If varexp is 0 (or """") then print only first 8 columns.; 8091/// - If varexp = ""*"" print all columns.; 8092///; 8093/// Otherwise a columns selection can be made using ""var1:var2:var3"".; 8094///; 8095/// \param firstentry first entry to scan; 8096/// \param nentries total number of entries to sc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:313677,allocate,allocate,313677,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"rees, RDataFrame::GetColumnNames might now returns multiple valid spellings for a given column. For example, leaf ""l"" under branch ""b"" might now be mentioned as ""l"" as well as ""b.l"", while only one of the two spellings might have been recognized before.; Certain RDF-related types in the ROOT::Detail and ROOT::Internal namespaces have been renamed, most notably RCustomColumn is now RDefine. This does not impact code that only makes use of entities in the public ROOT namespace, and should not impact downstream code unless it was patching or reusing internal RDataFrame types. Notable bug fixes and improvements. A critical issue has been fixed that could potentially result in wrong data being silently read in multi-thread runs when an input TChain contained more than one TTree coming from the same input file. More details are available at #7143.; The start-up time of event loops with large computation graphs with many just-in-time-compiled expressions (e.g. thousands of string Filters and Defines) has been greatly reduced. See the corresponding pull request for more details. The full list of bug fixes for this release is available below.; Distributed computing with RDataFrame; ROOT 6.24 introduces ROOT.RDF.Experimental.Distributed, an experimental python package that enhances RDataFrame with distributed computing capabilities. The new package allows distributing RDataFrame applications through one of the supported distributed backends. The package was designed so that different backends can be easily plugged in. Currently the Apache Spark backend is supported and support for Dask is coming soon. The backend submodules of this package expose their own RDataFrame objects. The only needed change in user code is to substitute ROOT.RDataFrame calls with such backend-specific RDataFrames. For example:; import ROOT. # Point RDataFrame calls to the Spark specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame. # It still accepts the same constructor ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:10344,reduce,reduced,10344,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['reduce'],['reduced']
Energy Efficiency,"renceTutorials » OpenGL tutorials. Detailed Description; Gradient fill with transparency and the ""SAME"" option. ; To use this macro you need OpenGL enabled in pad: either set OpenGL.CanvasPreferGL to 1 in $ROOTSYS/etc/system.rootrc; or call gStyle->SetCanvasPreferGL(kTRUE); before canvas created. ; //Includes for ACLiC (cling does not need them).; #include ""TColorGradient.h""; #include ""TCanvas.h""; #include ""TError.h""; #include ""TColor.h""; #include ""TStyle.h""; #include ""TH1F.h""; ; void grad2(bool gl = true); {; //Make sure canvas supports OpenGL.; gStyle->SetCanvasPreferGL(gl);; ; //2. Check that we have a canvas with an OpenGL support.; auto cnv = new TCanvas(""grad2"", ""gradient demo 2"", 100, 100, 800, 600);; if (!cnv->UseGL() && !cnv->IsWeb()); ::Warning(""grad2"", ""This macro requires either OpenGL or Web canvas to correctly handle gradient colors"");; ; //3. Custom colors:; // a) Custom semi-transparent red.; auto customRed = TColor::GetColor((Float_t) 1., 0., 0., 0.5);; ; // Custom semi-transparent green.; auto customGreen = TColor::GetColor((Float_t) 0., 1., 0., 0.5);; ; // 4. Linear gradient colors; // b) Gradient (from our semi-transparent red to ROOT's kOrange).; // Linear gradient is defined by: 1) angle in grad; // 2) colors (to interpolate between them),; // If necessary, TLinearGradient object can be retrieved and modified later; ; auto grad1 = TColor::GetLinearGradient(90., {customRed, kOrange});; ; //Vertical gradient fill.; auto grad2 = TColor::GetLinearGradient(90., {customGreen, kBlue});; ; auto hist = new TH1F(""a2"", ""b2"", 10, -2., 3.);; auto hist2 = new TH1F(""c3"", ""d3"", 10, -3., 3.);; hist->FillRandom(""landau"", 100000);; hist2->FillRandom(""gaus"", 100000);; ; hist->SetFillColor(grad1);; hist2->SetFillColor(grad2);; ; hist2->Draw();; hist->Draw(""SAME"");; }; Float_tfloat Float_tDefinition RtypesCore.h:57; kOrange@ kOrangeDefinition Rtypes.h:67; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; TColorGradient.h; TColor.h; TError.h; Warningvoid Warning(const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gl_2grad2_8C.html:1157,green,green,1157,doc/master/gl_2grad2_8C.html,https://root.cern,https://root.cern/doc/master/gl_2grad2_8C.html,1,['green'],['green']
Energy Efficiency,"renced objects.; 2328 ; 2329TBranch* TTree::BranchRef(); 2330{; 2331 if (!fBranchRef) {; 2332 fBranchRef = new TBranchRef(this);; 2333 }; 2334 return fBranchRef;; 2335}; 2336 ; 2337////////////////////////////////////////////////////////////////////////////////; 2338/// Create a new TTree BranchElement.; 2339///; 2340/// ## WARNING about this new function; 2341///; 2342/// This function is designed to replace the internal; 2343/// implementation of the old TTree::Branch (whose implementation; 2344/// has been moved to BranchOld).; 2345///; 2346/// NOTE: The 'Bronch' method supports only one possible calls; 2347/// signature (where the object type has to be specified; 2348/// explicitly and the address must be the address of a pointer).; 2349/// For more flexibility use 'Branch'. Use Bronch only in (rare); 2350/// cases (likely to be legacy cases) where both the new and old; 2351/// implementation of Branch needs to be used at the same time.; 2352///; 2353/// This function is far more powerful than the old Branch; 2354/// function. It supports the full C++, including STL and has; 2355/// the same behaviour in split or non-split mode. classname does; 2356/// not have to derive from TObject. The function is based on; 2357/// the new TStreamerInfo.; 2358///; 2359/// Build a TBranchElement for an object of class classname.; 2360///; 2361/// addr is the address of a pointer to an object of class; 2362/// classname. The class dictionary must be available (ClassDef; 2363/// in class header).; 2364///; 2365/// Note: See the comments in TBranchElement::SetAddress() for a more; 2366/// detailed discussion of the meaning of the addr parameter.; 2367///; 2368/// This option requires access to the library where the; 2369/// corresponding class is defined. Accessing one single data; 2370/// member in the object implies reading the full object.; 2371///; 2372/// By default the branch buffers are stored in the same file as the Tree.; 2373/// use TBranch::SetFile to specify a differe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:93076,power,powerful,93076,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['power'],['powerful']
Energy Efficiency,"resentation. Energy. { return std::sqrt(E2() ); }. Scalar T() const; { return E();}. Scalar P2() const. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Mag() const; { return M(); }. Scalar E2() const. energy squared. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { return Pt2();}. Scalar Pt() const. Transverse spatial component (P_perp or rho). { return std::sqrt(Perp2());}. Scalar Perp() const; { return Pt();}. Scalar Rho() const; { return Pt();}. Scalar Mt2() const. transverse mass squared. { return E2() - fZ*fZ; }. Scalar Mt() const. transverse mass. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html:6919,energy,energy,6919,root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html,5,['energy'],['energy']
Energy Efficiency,"resentation. Energy. { return std::sqrt(E2() ); }. Scalar T() const; { return E();}. Scalar P2() const. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Mag() const; { return M(); }. Scalar E2() const. energy squared. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { return Pt2();}. Scalar Pt() const. Transverse spatial component (P_perp or rho). { return std::sqrt(Perp2());}. Scalar Perp() const; { return Pt();}. Scalar Rho() const; { return Pt();}. Scalar Mt2() const. transverse mass squared. { return E2() - fZ*fZ; }. Scalar Mt() const. transverse mass. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<double>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<double>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<double>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<double>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_double_.html:6563,energy,energy,6563,root/html526/ROOT__Math__PxPyPzM4D_double_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_double_.html,5,['energy'],['energy']
Energy Efficiency,"resonances up to the Z mass. Note that the bump at 30 GeV is not a resonance but a trigger effect.; More details about the dataset can be found on the CERN Open Data portal. ; #include ""ROOT/RDataFrame.hxx""; #include ""ROOT/RDFHelpers.hxx""; #include ""ROOT/RVec.hxx""; #include ""TCanvas.h""; #include ""TH1D.h""; #include ""TLatex.h""; #include ""TStyle.h""; ; using namespace ROOT::VecOps;; ; void df102_NanoAODDimuonAnalysis(); {; // Enable multi-threading; ROOT::EnableImplicitMT();; ; // Create dataframe from NanoAOD files; ROOT::RDataFrame df(""Events"", ""root://eospublic.cern.ch//eos/opendata/cms/derived-data/AOD2NanoAODOutreachTool/""; ""Run2012BC_DoubleMuParked_Muons.root"");; ; // Add ProgressBar; ROOT::RDF::Experimental::AddProgressBar(df);; ; // For simplicity, select only events with exactly two muons and require opposite charge; auto df_2mu = df.Filter(""nMuon == 2"", ""Events with exactly two muons"");; auto df_os = df_2mu.Filter(""Muon_charge[0] != Muon_charge[1]"", ""Muons with opposite charge"");; ; // Compute invariant mass of the dimuon system; auto df_mass = df_os.Define(""Dimuon_mass"", InvariantMass<float>, {""Muon_pt"", ""Muon_eta"", ""Muon_phi"", ""Muon_mass""});; ; // Make histogram of dimuon mass spectrum. Note how we can set title and axis labels in one go; auto h = df_mass.Histo1D({""Dimuon_mass"", ""Dimuon mass;m_{#mu#mu} (GeV);N_{Events}"", 30000, 0.25, 300}, ""Dimuon_mass"");; ; // Request cut-flow report; auto report = df.Report();; ; // Produce plot; gStyle->SetOptStat(0); gStyle->SetTextFont(42);; auto c = new TCanvas(""c"", """", 800, 700);; c->SetLogx(); c->SetLogy();; ; h->GetXaxis()->SetTitleSize(0.04);; h->GetYaxis()->SetTitleSize(0.04);; h->DrawClone();; ; TLatex label; label.SetNDC(true);; label.DrawLatex(0.175, 0.740, ""#eta"");; label.DrawLatex(0.205, 0.775, ""#rho,#omega"");; label.DrawLatex(0.270, 0.740, ""#phi"");; label.DrawLatex(0.400, 0.800, ""J/#psi"");; label.DrawLatex(0.415, 0.670, ""#psi'"");; label.DrawLatex(0.485, 0.700, ""Y(1,2,3S)"");; label.DrawLatex(0.755, 0.680, ""Z""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html:1683,charge,charge,1683,doc/master/df102__NanoAODDimuonAnalysis_8C.html,https://root.cern,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html,1,['charge'],['charge']
Energy Efficiency,"ress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooCompositeDataStore.h>. Inheritance diagram for RooCompositeDataStore:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooCompositeDataStore() [1/4]. RooCompositeDataStore::RooCompositeDataStore ; (; ). Definition at line 49 of file RooCompositeDataStore.cxx. ◆ RooCompositeDataStore() [2/4]. RooCompositeDataStore::RooCompositeDataStore ; (; RooStringView ; name, . RooStringView ; title, . const RooArgSet & ; vars, . RooCategory & ; indexCat, . std::map< std::string, RooAbsDataStore * > const & ; inputData . ). Convert map by label to map by index for more efficient internal use. ; Definition at line 59 of file RooCompositeDataStore.cxx. ◆ RooCompositeDataStore() [3/4]. RooCompositeDataStore::RooCompositeDataStore ; (; const RooCompositeDataStore & ; other, . const char * ; newname = nullptr . ). Convert map by label to map by index for more efficient internal use. ; Definition at line 75 of file RooCompositeDataStore.cxx. ◆ RooCompositeDataStore() [4/4]. RooCompositeDataStore::RooCompositeDataStore ; (; const RooCompositeDataStore & ; other, . const RooArgSet & ; vars, . const char * ; newname = nullptr . ). Update index category pointer, if it is contained in input argument vars. ; Definition at line 89 of file RooCompositeDataStore.cxx. ◆ ~RooCompositeDataStore(). RooCompositeDataStore::~RooCompositeDataStore ; (; ). override . Destructor. ; Definition at line 111 of file RooCompositeDataStore.cxx. Member Function Documentation. ◆ addColumn(). RooAbsArg * RooCompositeDataStore::addColumn ; (; RooAbsArg & ; var, . bool ; ad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCompositeDataStore.html:20418,efficient,efficient,20418,doc/master/classRooCompositeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooCompositeDataStore.html,1,['efficient'],['efficient']
Energy Efficiency,"resses in host byte order; vector<TString>fAliaseslist of aliases; Int_tfFamilyaddress family; TStringfHostnamefully qualified hostname; Int_tfPortport through which we are connected. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TInetAddress(); Default ctor. Used in case of unknown host. Not a valid address. TInetAddress(const char* host, UInt_t addr, Int_t family, Int_t port = -1); Create TInetAddress. Private ctor. TInetAddress objects can only; be created via the friend classes TSystem, TServerSocket and TSocket.; Use the IsValid() method to check the validity of a TInetAddress. TInetAddress(const TInetAddress& adr); TInetAddress copy ctor. TInetAddress& operator=(const TInetAddress& rhs); TInetAddress assignment operator. UChar_t * GetAddressBytes() const; Returns the raw IP address in host byte order. The highest; order byte position is in addr[0]. To be prepared for 64-bit; IP addresses an array of bytes is returned.; User must delete allocated memory. const char * GetHostAddress(UInt_t addr); Returns the IP address string ""%d.%d.%d.%d"", use it to convert; alternative addresses obtained via GetAddresses().; Copy string immediately, it will be reused. Static function. const char * GetHostAddress() const; Returns the IP address string ""%d.%d.%d.%d"".; Copy string immediately, it will be reused. void Print(Option_t* option = """") const; Print internet address as string. void AddAddress(UInt_t addr); Add alternative address to list of addresses. void AddAlias(const char* alias); Add alias to list of aliases. void Streamer(TBuffer& ); Stream an object of class TInetAddress. virtual ~TInetAddress(); { }. UInt_t GetAddress() const; { return fAddresses[0]; }. const char * GetHostName() const; { return (const char *) fHostname; }. Int_t GetFamily() const; { return fFamily; }. Int_t GetPort() const; { return fPort; }. const AddressList_t & GetAddresses() const; { return fAddresses; }. const AliasList_t & GetAliases() const; { ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TInetAddress.html:6717,allocate,allocated,6717,root/html534/TInetAddress.html,https://root.cern,https://root.cern/root/html534/TInetAddress.html,1,['allocate'],['allocated']
Energy Efficiency,"resses in host byte order; vector<TString>fAliaseslist of aliases; Int_tfFamilyaddress family; TStringfHostnamefully qualified hostname; Int_tfPortport through which we are connected. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TInetAddress(); Default ctor. Used in case of unknown host. Not a valid address. TInetAddress(const char* host, UInt_t addr, Int_t family, Int_t port = -1); Create TInetAddress. Private ctor. TInetAddress objects can only; be created via the friend classes TSystem, TServerSocket and TSocket.; Use the IsValid() method to check the validity of a TInetAddress. TInetAddress(const TInetAddress& adr); TInetAddress copy ctor. TInetAddress& operator=(const TInetAddress& rhs); TInetAddress assignment operator. UChar_t * GetAddressBytes() const; Returns the raw IP address in host byte order. The highest; order byte position is in addr[0]. To be prepared for 64-bit; IP addresses an array of bytes is returned.; User must delete allocated memory. const char * GetHostAddress(UInt_t addr); Returns the IP address string ""%d.%d.%d.%d"", use it to convert; alternative addresses obtained via GetAddresses().; Copy string immediately, it will be reused. Static function. const char * GetHostAddress() const; Returns the IP address string ""%d.%d.%d.%d"".; Copy string immediately, it will be reused. void Print(Option_t* option = """") const; Print internet address as string. void AddAddress(UInt_t addr); Add alternative address to list of addresses. void AddAlias(const char* alias); Add alias to list of aliases. void Streamer(TBuffer& b); Stream an object of class TInetAddress. virtual ~TInetAddress(); { }. UInt_t GetAddress() const; { return fAddresses[0]; }. const char * GetHostName() const; { return (const char *) fHostname; }. Int_t GetFamily() const; { return fFamily; }. Int_t GetPort() const; { return fPort; }. const AddressList_t & GetAddresses() const; { return fAddresses; }. const AliasList_t & GetAliases() const; {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TInetAddress.html:6629,allocate,allocated,6629,root/html528/TInetAddress.html,https://root.cern,https://root.cern/root/html528/TInetAddress.html,3,['allocate'],['allocated']
Energy Efficiency,"ression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char* classname, Long64_t filepos); method used in all TKey constructor to initialize basic data fields; filepos is used to calculate correct version number of key; if filepos==-1, end of file position is used. void Browse(TBrowser* b); Read object from disk and call its Browse() method.; If object with same name already exist in memory delete it (like; TDirectoryFile::Get() is doing), except when the key references a; folder in which case we don't want to re-read the folder object; since it might contain new objects not yet saved. void Create(Int_t nbytes, TFile* f = 0); Create a TKey object of specified size; if externFile!=0, key will be allocated in specified file,; otherwise file of mother directory will be used. ~TKey(); TKey default destructor. void Delete(Option_t* option = """"); Delete an object from the file.; Note: the key is not deleted. You still have to call ""delete key"".; This is different from the behaviour of TObject::Delete()!. void DeleteBuffer(); Delete key buffer(s). Short_t GetCycle() const; Return cycle number associated to this key. TFile * GetFile() const; Returns file to which key belong. Short_t GetKeep() const; Returns the ""KEEP"" status. void FillBuffer(char*& buffer); Encode key header into output buffer. ULong_t Hash() const; This Hash function should redefine the default from TNamed. void IncrementPidOffset(UShort_t offset); Increment fPidOffset by 'offset'.; This offset is used when a key (or basket) is transfered from one file to; the other. In this case the TRef and TObject might have stored a pid; index (to retrieve TProcessIDs) which refered to their order on the; origin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TKey.html:11851,allocate,allocated,11851,root/html602/TKey.html,https://root.cern,https://root.cern/root/html602/TKey.html,2,['allocate'],['allocated']
Energy Efficiency,"ression using standard C++ functions/operators; Example a:; auto fa = new TF1(""fa"",""[0]*x*sin([1]*x)"",-3,3);; This creates a function of variable x with 2 parameters. The parameters must be initialized via:; fa->SetParameter(0,value_first_parameter);; fa->SetParameter(1,value_second_parameter);; Parameters may be given a name:; fa->SetParName(0,""Constant"");; Example b:; auto fb = new TF1(""fb"",""gaus(0)*expo(3)"",0,10);; gaus(0) is a substitute for [0]*exp(-0.5*((x-[1])/[2])**2) and (0) means start numbering parameters at 0. expo(3) is a substitute for exp([3]+[4]*x).; Case 2: inline expression using TMath functions with parameters; {; auto fb2 = new TF1(""fa3"",""TMath::Landau(x,[0],[1],0)"",-5,10);; fb2->SetParameters(0.2,1.3);; fb2->Draw();; }. 3 - A lambda expression with variables and parameters; Since6.00/00: TF1 supports using lambda expressions in the formula. This allows, by using a full C++ syntax the full power of lambda functions and still maintain the capability of storing the function in a file which cannot be done with function pointer or lambda written not as expression, but as code (see items below).; Example on how using lambda to define a sum of two functions. Note that is necessary to provide the number of parameters; TF1 f1(""f1"",""sin(x)"",0,10);; TF1 f2(""f2"",""cos(x)"",0,10);; TF1 fsum(""f1"",""[&](double *x, double *p){ return p[0]*f1(x) + p[1]*f2(x); }"",0,10,2);; TF11-Dim function classDefinition TF1.h:233; f1TF1 * f1Definition legend1.C:11. 4 - A general C function with parameters; Consider the macro myfunc.C below:; // Macro myfunc.C; Double_t myfunction(Double_t *x, Double_t *par); {; Float_t xx =x[0];; Double_t f = TMath::Abs(par[0]*sin(par[1]*xx)/xx);; return f;; }; void myfunc(); {; auto f1 = new TF1(""myfunc"",myfunction,0,10,2);; f1->SetParameters(2,1);; f1->SetParNames(""constant"",""coefficient"");; f1->Draw();; }; void myfit(); {; auto h1 = new TH1F(""h1"",""test"",100,0,10);; h1->FillRandom(""myfunc"",20000);; TF1 *f1 = (TF1 *)gROOT->GetFunction(""myfunc"");",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:2803,power,power,2803,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['power'],['power']
Energy Efficiency,"ressions. The returned string a the reduced expression where; all inline object creations have been executed and substituted; with the name of the created object. e.g. 'RooGaussian::g(x,m,s)' --> 'g'; '{x(-10,10),s} --> '{x,s}'. std::string processCompositeExpression(const char* arg); Process a single composite expression. e.g. 'A=RooGaussian::g[x,m,s]' --> 'A=g'; e.g. 'f[0,1]*RooGaussian::g[x,m,s]' --> 'f*g'; e.g. 'RooGaussian::g(x,y,s)|x' --> g|x'; e.g. '$MetaArg(RooGaussian::g[x,m,s],blah)' --> '$MetaArg(g,blah)'. std::string processSingleExpression(const char* arg); Process a single high-level expression. The returned string a the reduced; expression where all inline object creations have been executed and substituted; with the name of the created object. e.g. 'RooGaussian::g(x,m,s)' --> 'g'; e.g. 'x[-10,10]' --> 'x'. string processListExpression(const char* arg); Process a list of high-level expression. The returned string a the reduced; expression list where all inline object creations have been executed and substituted; with the name of the created object. E.g. '{x(-10,10),s} --> '{x,s}'. string processAliasExpression(const char* arg); Parse token. TClass* resolveClassName(const char* className). string varTag(string& func, vector<std::string>& args). string processCreateVar(string& func, vector<std::string>& args); Glue function between high-level syntax and low-level factory call to createVariable:; Process a parsed call to create a variable named 'func'. If initial token is non-numeric, a RooCategory will be created, and the args are interpreted; as either state names or 'name=id' assignments. Otherwise a RooRealvar is created and the; arg list is interpreted as follows:; If list has two args, these are interpreted as xmin,xmax; If list has three args, these are interpreted as xinit,xmin,xmax; If list has one arg, this is interpreted as xinit and the variable is set as constant. string processCreateArg(string& func, vector<std::string>& args); Glue functio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFactoryWSTool.html:17423,reduce,reduced,17423,root/html526/RooFactoryWSTool.html,https://root.cern,https://root.cern/root/html526/RooFactoryWSTool.html,5,['reduce'],['reduced']
Energy Efficiency,"ressions. The returned string a the reduced expression where; all inline object creations have been executed and substituted; with the name of the created object. e.g. 'RooGaussian::g(x,m,s)' --> 'g'; '{x(-10,10),s} --> '{x,s}'. std::string processCompositeExpression(const char* arg); Process a single composite expression. e.g. 'A=RooGaussian::g[x,m,s]' --> 'A=g'; e.g. 'f[0,1]*RooGaussian::g[x,m,s]' --> 'f*g'; e.g. 'RooGaussian::g(x,y,s)|x' --> g|x'; e.g. '$MetaArg(RooGaussian::g[x,m,s],blah)' --> '$MetaArg(g,blah)'. std::string processSingleExpression(const char* arg); Process a single high-level expression. The returned string a the reduced; expression where all inline object creations have been executed and substituted; with the name of the created object. e.g. 'RooGaussian::g(x,m,s)' --> 'g'; e.g. 'x[-10,10]' --> 'x'. string processListExpression(const char* arg); Process a list of high-level expression. The returned string a the reduced; expression list where all inline object creations have been executed and substituted; with the name of the created object. E.g. '{x(-10,10),s} --> '{x,s}'. string processAliasExpression(const char* arg); Parse token. TClass* resolveClassName(const char* className). string varTag(string& func, vector<string>& args). string processCreateVar(string& func, vector<string>& args); Glue function between high-level syntax and low-level factory call to createVariable:; Process a parsed call to create a variable named 'func'. If initial token is non-numeric, a RooCategory will be created, and the args are interpreted; as either state names or 'name=id' assignments. Otherwise a RooRealvar is created and the; arg list is interpreted as follows:; If list has two args, these are interpreted as xmin,xmax; If list has three args, these are interpreted as xinit,xmin,xmax; If list has one arg, this is interpreted as xinit and the variable is set as constant. string processCreateArg(string& func, vector<string>& args); Glue function between high-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFactoryWSTool.html:18920,reduce,reduced,18920,root/html602/RooFactoryWSTool.html,https://root.cern,https://root.cern/root/html602/RooFactoryWSTool.html,2,['reduce'],['reduced']
Energy Efficiency,"rest; this class has the same properties as TObjArray. To reduce the very large number of new and delete calls in large; loops like this (O(100000) x O(10000) times new/delete):. TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);. }. a.Delete();; }. One better uses a TClonesArray which reduces the number of; new/delete calls to only O(10000):. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);. }. a.Delete();; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method. The diffrent Add() methods of; TObjArray and its base classes are not allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offer the possibility to allocate and delete memory.; Forgetting to delete allocated memory is a programming error that originate ""leaks"",; i.e. the memory of your process grows and eventually your program crashes.; Even if you *always* delete the allocated memory, the recovered space may not be; efficiently reused. The process knows that there are portions of free memory,; but when you allocate it again, a fresh piece of memory is grabbed.; Your program is free from semantic errors, but the total memory of your process; still grows. Moreover your program's memory is full of ""holes"" which reduce the; efficiency of memory access, this is called ""memory fragmentation"".; Moreover new / delete are expensive operations in terms of CPU time. Without entering into technical details, the TClonesArray allow to ""reuse"" the; same portion of memory for new/delete avoiding memory fragmentation and memory; growth and improving by orders of magnitude the performance. Every time the; memory of the TClonesArray has to be reu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClonesArray.html:1493,allocate,allocate,1493,root/html528/TClonesArray.html,https://root.cern,https://root.cern/root/html528/TClonesArray.html,2,['allocate'],['allocate']
Energy Efficiency,"result. ; Reimplemented from RooPrintable.; Definition at line 1400 of file RooFitResult.cxx. ◆ printValue(). void RooFitResult::printValue ; (; std::ostream & ; os); const. overridevirtual . Print the value of the fit result, i.e.g the status, minimized FCN, edm and covariance quality code. ; Reimplemented from RooPrintable.; Definition at line 1428 of file RooFitResult.cxx. ◆ randomizePars(). const RooArgList & RooFitResult::randomizePars ; (; ); const. Generate random perturbations of the final parameters using the covariance matrix. ; Return a list of floating parameter values that are perturbed from the final fit values by random amounts sampled from the covariance matrix.; The returned object is overwritten with each call and belongs to the RooFitResult. Uses the ""square root method"" to decompose the covariance matrix, which makes inverting it unnecessary. ; Definition at line 336 of file RooFitResult.cxx. ◆ reducedCovarianceMatrix(). TMatrixDSym RooFitResult::reducedCovarianceMatrix ; (; const RooArgList & ; params); const. Return a reduced covariance matrix (Note that Vred is a simple sub-matrix of V, row/columns are ordered to matched the convention given in input argument 'params'. ; Definition at line 1124 of file RooFitResult.cxx. ◆ setConstParList(). void RooFitResult::setConstParList ; (; const RooArgList & ; list). Fill the list of constant parameters. ; Definition at line 136 of file RooFitResult.cxx. ◆ setCovarianceMatrix(). void RooFitResult::setCovarianceMatrix ; (; TMatrixDSym & ; V). Store externally provided correlation matrix in this RooFitResult ;. ; Definition at line 1052 of file RooFitResult.cxx. ◆ setCovQual(). void RooFitResult::setCovQual ; (; Int_t ; val). inline . Definition at line 169 of file RooFitResult.h. ◆ setEDM(). void RooFitResult::setEDM ; (; double ; val). inline . Definition at line 167 of file RooFitResult.h. ◆ setFinalParList(). void RooFitResult::setFinalParList ; (; const RooArgList & ; list). Fill the list of final va",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFitResult.html:36096,reduce,reducedCovarianceMatrix,36096,doc/master/classRooFitResult.html,https://root.cern,https://root.cern/doc/master/classRooFitResult.html,1,['reduce'],['reducedCovarianceMatrix']
Energy Efficiency,"ret_type> . RResultPtr< T > ROOT::RDF::RInterface< Proxied, DataSource >::Reduce ; (; F ; f, . std::string_view ; columnName = """" . ). inline . Execute a user-defined reduce operation on the values of a column. ; Template Parameters. FThe type of the reduce callable. Automatically deduced. ; TThe type of the column to apply the reduction to. Automatically deduced. . Parameters. [in]fA callable with signature T(T,T) ; [in]columnNameThe column to be reduced. If omitted, the first default column is used instead. . Returnsthe reduced quantity wrapped in a ROOT::RDF:RResultPtr.; A reduction takes two values of a column and merges them into one (e.g. by summing them, taking the maximum, etc). This action performs the specified reduction operation on all processed column values, returning a single value of the same type. The callable f must satisfy the general requirements of a processing function besides having signature T(T,T) where T is the type of column columnName.; The returned reduced value of each thread (e.g. the initial value of a sum) is initialized to a default-constructed T object. This is commonly expected to be the neutral/identity element for the specific reduction operation f (e.g. 0 for a sum, 1 for a product). If a default-constructed T does not satisfy this requirement, users should explicitly specify an initialization value for T by calling the appropriate Reduce overload. Example usage:; auto sumOfIntCol = d.Reduce([](int x, int y) { return x + y; }, ""intCol"");; This action is lazy: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr. ; Definition at line 1688 of file RInterface.hxx. ◆ Report(). template<typename Proxied , typename DataSource = void> . RResultPtr< RCutFlowReport > ROOT::RDF::RInterface< Proxied, DataSource >::Report ; (; ). inline . Gather filtering statistics. ; Returnsthe resulting RCutFlowReport instance wrapped in a RResultPtr.; Calling Report on the main RDataFrame object gathers stats fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:121176,reduce,reduced,121176,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['reduce'],['reduced']
Energy Efficiency,"return 0;; 212 }; 213 ; 214 void HandleReferencedTObject(TBuffer &buf, void *addr, const TConfiguration *config) {; 215 TBitsConfiguration *conf = (TBitsConfiguration*)config;; 216 UShort_t pidf;; 217 buf >> pidf;; 218 pidf += buf.GetPidOffset();; 219 TProcessID *pid = buf.ReadProcessID(pidf);; 220 if (pid!=0) {; 221 TObject *obj = (TObject*)( ((char*)addr) + conf->fObjectOffset);; 222 UInt_t gpid = pid->GetUniqueID();; 223 UInt_t uid;; 224 if (gpid>=0xff) {; 225 uid = obj->GetUniqueID() | 0xff000000;; 226 } else {; 227 uid = ( obj->GetUniqueID() & 0xffffff) + (gpid<<24);; 228 }; 229 obj->SetUniqueID(uid);; 230 pid->PutObjectWithID(obj);; 231 }; 232 }; 233 ; 234 template <>; 235 INLINE_TEMPLATE_ARGS Int_t ReadBasicType<BitsMarker>(TBuffer &buf, void *addr, const TConfiguration *config); 236 {; 237 UInt_t *x = (UInt_t*)( ((char*)addr) + config->fOffset );; 238 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 239 // Idea: This code really belongs inside TBuffer[File]; 240 const UInt_t isonheap = *x & TObject::kIsOnHeap; // Record how this instance was actually allocated.; 241 buf >> *x;; 242 *x |= isonheap | TObject::kNotDeleted; // by definition de-serialized object are not yet deleted.; 243 ; 244 if ((*x & kIsReferenced) != 0) {; 245 HandleReferencedTObject(buf,addr,config);; 246 }; 247 return 0;; 248 }; 249 ; 250 template <typename T>; 251 INLINE_TEMPLATE_ARGS Int_t WriteBasicType(TBuffer &buf, void *addr, const TConfiguration *config); 252 {; 253 T *x = (T *)(((char *)addr) + config->fOffset);; 254 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 255 buf << *x;; 256 return 0;; 257 }; 258 ; 259 INLINE_TEMPLATE_ARGS Int_t WriteTextTNamed(TBuffer &buf, void *addr, const TConfiguration *config); 260 {; 261 void *x = (void *)(((char *)addr) + config->fOffset);; 262 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 263 buf.StreamObject(x, TNamed::Class(), TNamed::Class());; 264 return 0;; 265 }; 266 ; 267 INLI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:8835,allocate,allocated,8835,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"return Pt();}. Scalar Mt2() const. transverse mass squared. { return E2() - fZ*fZ; }. Scalar Mt() const. transverse mass. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(Double32_t pt); ====== Set member functions for coordinates in other systems =======. void SetEta(Double32_t eta). void SetPhi(Double32_t phi). void SetE(Double32_t energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathco",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html:7724,energy,energy,7724,root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html,5,['energy'],['energy']
Energy Efficiency,"return ldexp(x, exp); }; 717 ; 718////////////////////////////////////////////////////////////////////////////////; 719/// Returns `x` raised to the power `y`.; 720 ; 721inline LongDouble_t TMath::Power(LongDouble_t x, LongDouble_t y); 722 { return std::pow(x,y); }; 723 ; 724////////////////////////////////////////////////////////////////////////////////; 725/// Returns `x` raised to the power `y`.; 726 ; 727inline LongDouble_t TMath::Power(LongDouble_t x, Long64_t y); 728 { return std::pow(x,(LongDouble_t)y); }; 729 ; 730////////////////////////////////////////////////////////////////////////////////; 731/// Returns `x` raised to the power `y`.; 732 ; 733inline LongDouble_t TMath::Power(Long64_t x, Long64_t y); 734 { return std::pow(x,y); }; 735 ; 736////////////////////////////////////////////////////////////////////////////////; 737/// Returns `x` raised to the power `y`.; 738 ; 739inline Double_t TMath::Power(Double_t x, Double_t y); 740 { return pow(x, y); }; 741 ; 742////////////////////////////////////////////////////////////////////////////////; 743/// Returns `x` raised to the power `y`.; 744 ; 745inline Double_t TMath::Power(Double_t x, Int_t y) {; 746#ifdef R__ANSISTREAM; 747 return std::pow(x, y);; 748#else; 749 return pow(x, (Double_t) y);; 750#endif; 751}; 752 ; 753////////////////////////////////////////////////////////////////////////////////; 754/// Returns the natural logarithm of `x`.; 755 ; 756inline Double_t TMath::Log(Double_t x); 757 { return log(x); }; 758 ; 759////////////////////////////////////////////////////////////////////////////////; 760/// Returns the common (base-10) logarithm of `x`.; 761 ; 762inline Double_t TMath::Log10(Double_t x); 763 { return log10(x); }; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Check if it is finite with a mask in order to be consistent in presence of; 767/// fast math.; 768/// Inspired from the CMSSW FWCore/Utilities package; 769 ; 770inline Int_t TMat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:27988,power,power,27988,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,1,['power'],['power']
Energy Efficiency,"rface.cxx:267; ROOT::Fit::InitGausvoid InitGaus(const ROOT::Fit::BinData &data, TF1 *f1)compute initial parameter for gaussian function given the fit data Set the sigma limits for zero top ...Definition HFitInterface.cxx:306; ROOT::Fit::EChisquareTypeEChisquareTypeDefinition HFitInterface.h:53; ROOT::Fit::EChisquareType::kPLikeRatio@ kPLikeRatio; ROOT::Fit::EChisquareType::kNeyman@ kNeyman; ROOT::Fit::EChisquareType::kPearson@ kPearson; ROOT::Math::Util::ToStringstd::string ToString(const T &val)Utility function for conversion to strings.Definition Util.h:50; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::EExecutionPolicy::kSequential@ kSequential; ROOT::EExecutionPolicy::kMultiThread@ kMultiThread; TMath::FiniteInt_t Finite(Double_t x)Check if it is finite with a mask in order to be consistent in presence of fast math.Definition TMath.h:770; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; Foption_tDefinition Foption.h:24; Foption_t::Rangeint RangeDefinition Foption.h:39; Foption_t::Nographint NographDefinition Foption.h:42; Foption_t::Quietint QuietDefinition Foption.h:29; Foption_t::Likeint LikeDefinition Foption.h:34; Foption_t::W1int W1Definition Foption.h:36; Foption_t::Gradientint GradientDefinition Foption.h:40; Foption_t::ExecPolicyROOT::EExecutionPolicy ExecPolicyDefinition Foption.h:52; Foption_t::StoreResultint StoreResultDefinition Foption.h:49; Foption_t::Nochisqint NochisqDefinition Foption.h:45; Foption_t::Robustint RobustDefinition Foption.h:48; Foption_t::hRobustdouble hRobustDefinition Foption.h:51; Foption_t::Plusint PlusDefinition Foption.h:43; Foption_t::Integralint IntegralDefinition Foption.h:44; Foption_t::Boundint BoundDefinition Foption.h:31; Foption_t::Nostoreint NostoreDefinition Foption.h:41; Foption_t::Moreint MoreDefinition Foption.h:38; Foption_t::PChi2int PChi2Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitImpl_8cxx_source.html:63229,power,power,63229,doc/master/HFitImpl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitImpl_8cxx_source.html,1,['power'],['power']
Energy Efficiency,"rfaces.; ; TH3 as color boxes - (TGLVoxelPainter); The supported option is:; ; ""GLCOL"" : TH3 is drawn using semi-transparent colored boxes.; See $ROOTSYS/tutorials/gl/glvox1.C.; ; TF3 (implicit function) - (TGLTF3Painter); The supported option is:; ; ""GLTF3"" : Draw a TF3.; ; Parametric surfaces - (TGLParametricPlot); $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric equations and; visualize the surface. Interaction with the plots. General information. All the interactions are implemented via standard methods DistancetoPrimitive and; ExecuteEvent. That's why all the interactions with the OpenGL plots are possible i; only when the mouse cursor is in the plot's area (the plot's area is the part of a the pad; occupied by gl-produced picture). If the mouse cursor is not above gl-picture,; the standard pad interaction is performed.; Selectable parts. Different parts of the plot can be selected:; ; xoz, yoz, xoy back planes:; When such a plane selected, it's highlighted in green if the dynamic slicing; by this plane is supported, and it's highlighted in red, if the dynamic slicing; is not supported.; The plot itself:; On surfaces, the selected surface is outlined in red. (TF3 and ISO are not; outlined). On lego plots, the selected bin is highlihted. The bin number and content are displayed in pad's status; bar. In box plots, the box or sphere is highlighted and the bin info is displayed in pad's status bar.; ; Rotation and zooming. Rotation:; ; When the plot is selected, it can be rotated by pressing and holding the left mouse button and move the cursor.; Zoom/Unzoom:; ; Mouse wheel or 'j', 'J', 'k', 'K' keys.; ; Panning. The selected plot can be moved in a pad's area by; pressing and holding the left mouse button and the shift key. Box cut; Surface, iso, box, TF3 and parametric painters support box cut by pressing the 'c' or; 'C' key when the mouse cursor is in a plot's area. That will display a transparent box,; cutting away part of the surface (or boxes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGLHistPainter.html:3147,green,green,3147,root/html530/TGLHistPainter.html,https://root.cern,https://root.cern/root/html530/TGLHistPainter.html,5,['green'],['green']
Energy Efficiency,"ri. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t WriteDataSet (const char *group, const char *user, const char *dsName, TFileCollection *dataset, UInt_t option=0, TMD5 *checksum=0);  Writes indicated dataset. ;  ;  Public Member Functions inherited from TDataSetManager;  TDataSetManager (const char *group=0, const char *user=0, const char *options=0);  Main constructor. ;  ;  ~TDataSetManager () override;  Destructor. ;  ; virtual Long64_t GetAvgFileSize () const;  ; virtual Long64_t GetGroupQuota (const char *group);  returns the quota a group is allowed to have ;  ; virtual TMap * GetGroupQuotaMap ();  ; virtual Long64_t GetGroupUsed (const char *group);  Returns the used space of that group. ;  ; virtual TMap * GetSubDataSets (const char *uri, const char *excludeservers);  Partition dataset 'ds' accordingly to the servers. ;  ; virtual void MonitorUsedSpace (TVirtualMonitoringWriter *monitoring);  Log info to the monitoring server. ;  ; Bool_t ParseUri (const char *uri, TString *dsGroup=0, TString *dsUser=0, TString *dsName=0, TString *dsTree=0, Bool_t onlyCurrent=kFALSE, Bool_t wildcards=kFALSE);  Parses a (relative) URI that describes a DataSet on the cluster. ;  ; Int_t ScanDataSet (const char *uri, const char *opt);  Scans the dataset indicated by 'uri' following the 'opts' directives. ;  ; void SetScanCounters (Int_t t=-1, Int_t o=-1, Int_t d=-1);  Update scan counters. ;  ; virtual void ShowDataSets (const char *uri=""*"", const char *opt="""");  Prints formatted information about the dataset 'uri'. ;  ; virtual void ShowQuota (const char *opt);  Display quota information. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManagerFile.html:3655,monitor,monitoring,3655,doc/master/classTDataSetManagerFile.html,https://root.cern,https://root.cern/doc/master/classTDataSetManagerFile.html,2,['monitor'],['monitoring']
Energy Efficiency,"ric fashion, thereby overwriting the part [row_lwb..row_lwb+nrows_source][row_lwb..row_lwb+nrows_source];. ; Implements TMatrixTBase< Element >.; Definition at line 686 of file TMatrixTSym.cxx. ◆ Shift(). template<class Element > . TMatrixTBase< Element > & TMatrixTSym< Element >::Shift ; (; Int_t ; row_shift, . Int_t ; col_shift . ). overridevirtual . Shift the row index by adding row_shift and the column index by adding col_shift, respectively. ; So [rowLwb..rowUpb][colLwb..colUpb] becomes [rowLwb+row_shift..rowUpb+row_shift][colLwb+col_shift..colUpb+col_shift] ; Reimplemented from TMatrixTBase< Element >.; Definition at line 756 of file TMatrixTSym.cxx. ◆ Similarity() [1/3]. template<class Element > . TMatrixTSym< Element > & TMatrixTSym< Element >::Similarity ; (; const TMatrixT< Element > & ; b). Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb) This is a similarity transform when B is orthogonal . ; It is more efficient than applying the actual multiplication because this routine realizes that the final matrix is symmetric . ; Definition at line 1099 of file TMatrixTSym.cxx. ◆ Similarity() [2/3]. template<class Element > . TMatrixTSym< Element > & TMatrixTSym< Element >::Similarity ; (; const TMatrixTSym< Element > & ; b). Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb) This is a similarity transform when B is orthogonal . ; It is more efficient than applying the actual multiplication because this routine realizes that the final matrix is symmetric . ; Definition at line 1190 of file TMatrixTSym.cxx. ◆ Similarity() [3/3]. template<class Element > . Element TMatrixTSym< Element >::Similarity ; (; const TVectorT< Element > & ; v); const. Calculate scalar v * (*this) * v^T. ; Definition at line 1292 of file TMatrixTSym.cxx. ◆ SimilarityT(). template<class Element > . TMatrixTSym< Element > & TMatrixTSym< Element >::SimilarityT ; (; const TMatrixT< Element > & ; n). Calculate B^T * (*this) * B , final matrix will be (ncolsb ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixTSym.html:43396,efficient,efficient,43396,doc/master/classTMatrixTSym.html,https://root.cern,https://root.cern/doc/master/classTMatrixTSym.html,1,['efficient'],['efficient']
Energy Efficiency,"ricTable(const TTableDescriptor& dsc, const char* name). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object. TGenericTable(const TTableDescriptor& dsc, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - ""TGenericTable""; n - The initial number of allocated rows. TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor * GetDescriptorPointer() const; { return fColDescriptors;}. void SetDescriptorPointer(TTableDescriptor* list); { fColDescriptors = list;}. void SetGenericType(); { TTable::SetType(GetDescriptorPointer()->GetName()); }. TGenericTable(); {SetType(""generic"");}. TGenericTable(const char* structName, const char* name); Create TGenericTable by C structure name provided. char * GetTable(Int_t i = 0) const; { return ((char *)GetArray())+i*GetRowSize();}. TTableDescriptor * GetTableDescriptors() const; { return GetDescriptorPointer();}. TTableDescriptor * GetRowDescriptors() const; { return GetDescriptorPointer();}. char & operator[](Int_t i); { assert(i>=0 && i < G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGenericTable.html:17333,allocate,allocated,17333,root/html528/TGenericTable.html,https://root.cern,https://root.cern/root/html528/TGenericTable.html,4,['allocate'],['allocated']
Energy Efficiency,"ricTable(const TTableDescriptor& dsc, const char* name). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object. TGenericTable(const TTableDescriptor& dsc, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - ""TGenericTable""; n - The initial number of allocated rows. TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor * GetDescriptorPointer() const; { return fColDescriptors;}. void SetDescriptorPointer(TTableDescriptor* list); { fColDescriptors = list;}. void SetGenericType(); { TTable::SetType(GetDescriptorPointer()->GetName()); }. iterator & operator=(const TGenericTable& ); { fRowSize = iter.fRowSize; fCurrentRow = iter.fCurrentRow; return *this;}. TGenericTable(); {SetType(""generic"");}. TGenericTable(const char* structName, const char* name); Create TGenericTable by C structure name provided. char * GetTable(Int_t i = 0) const; { return ((char *)GetArray())+i*GetRowSize();}. TTableDescriptor * GetTableDescriptors() const; { return GetDescriptorPointer();}. TTableDesc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGenericTable.html:18829,allocate,allocated,18829,root/html602/TGenericTable.html,https://root.cern,https://root.cern/root/html602/TGenericTable.html,2,['allocate'],['allocated']
Energy Efficiency,"rick by sampling the integral in the same way doesn't cancel out the; # bias completely. The average bias is canceled, but there are per-bin; # biases that remain. Still, this method has some value: it is cheaper than; # rigurously correcting the bias by integrating the pdf in each bin. So if; # you know your per-bin bias variations are small or performance is an; # issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins()); fit4 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit4.Print(); disableBinIntegrator(powerlaw); ; # To get rid of the binning effects in the general case, one can use the; # IntegrateBins() command argument. Now, the pdf is not evaluated at the; # bin centers, but numerically integrated over each bin and divided by the; # bin width. The parameter for IntegrateBins() is the required precision; # for the numeric integrals. This is computationally expensive, but the; # bias is now not a problem anymore.; fit5 = powerlaw.fitTo(powerlaw_data, IntegrateBins=1e-3, Save=True, PrintLevel=-1, SumW2Error=False); fit5.Print(); ; # Improving numerical stability; # -----------------------------; ; # There is one more problem with binned fits that is related to the binning; # effects because often, a binned fit is affected by both problems.; #; # The issue is numerical stability for fits with a greatly different number; # of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; # the NLL, where \f[n\f] is the number of observations in the bin, and; # \f[p\f] the predicted probability to have an event in that bin. The; # difference in the logarithms for each bin is small, but the difference in; # \f[n\f] can be orders of magnitudes! Therefore, when summing these terms,; # lots of numerical precision is lost for the bins with less events.; ; # We can study this with the example of an exponential plus a Gaussian. The; # Gaussian is only a faint signal in the tail of the exponential where; # t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:5380,power,powerlaw,5380,doc/master/rf614__binned__fit__problems_8py.html,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html,1,['power'],['powerlaw']
Energy Efficiency,"riedCols;; 540 delete[] variationTags;; 541 ; 542 delete wkJittedVariation;; 543 delete colRegister;; 544 delete prevNodeOnHeap;; 545 };; 546 ; 547 if (wkJittedVariation->expired()) {; 548 // The branch of the computation graph that needed this jitted variation went out of scope between the type; 549 // jitting was booked and the time jitting actually happened. Nothing to do other than cleaning up.; 550 doDeletes();; 551 return;; 552 }; 553 ; 554 const ColumnNames_t inputColNames(colsPtr, colsPtr + colsSize);; 555 std::vector<std::string> variedColNames(variedCols, variedCols + variedColsSize);; 556 std::vector<std::string> tags(variationTags, variationTags + variationTagsSize);; 557 ; 558 auto jittedVariation = wkJittedVariation->lock();; 559 ; 560 using Callable_t = std::decay_t<F>;; 561 using ColTypes_t = typename TTraits::CallableTraits<Callable_t>::arg_types;; 562 ; 563 auto ds = lm->GetDataSource();; 564 if (ds != nullptr); 565 AddDSColumns(inputColNames, *lm, *ds, ColTypes_t(), *colRegister);; 566 ; 567 // use unique_ptr<RDefineBase> instead of make_unique<NewCol_t> to reduce jit/compile-times; 568 std::unique_ptr<RVariationBase> newVariation{new RVariation<std::decay_t<F>, IsSingleColumn>(; 569 std::move(variedColNames), variationName, std::forward<F>(f), std::move(tags), jittedVariation->GetTypeName(),; 570 *colRegister, *lm, inputColNames)};; 571 jittedVariation->SetVariation(std::move(newVariation));; 572 ; 573 doDeletes();; 574}; 575 ; 576/// Convenience function invoked by jitted code to build action nodes at runtime; 577template <typename ActionTag, typename... ColTypes, typename PrevNodeType, typename HelperArgType>; 578void CallBuildAction(std::shared_ptr<PrevNodeType> *prevNodeOnHeap, const char **colsPtr, std::size_t colsSize,; 579 const unsigned int nSlots, std::shared_ptr<HelperArgType> *helperArgOnHeap,; 580 std::weak_ptr<RJittedAction> *wkJittedActionOnHeap, RColumnRegister *colRegister) noexcept; 581{; 582 // a helper to delete objects allocat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/InterfaceUtils_8hxx_source.html:25656,reduce,reduce,25656,doc/master/InterfaceUtils_8hxx_source.html,https://root.cern,https://root.cern/doc/master/InterfaceUtils_8hxx_source.html,1,['reduce'],['reduce']
Energy Efficiency,"riginal HTI to be alive. ~HypoTestInverter(); destructor (delete the HypoTestInverterResult). TestStatistic * GetTestStatistic() const; return the test statistic which is or will be used by the class. bool SetTestStatistic(RooStats::TestStatistic& stat); set the test statistic to use. void Clear(); delete contained result and graph. void CreateResults() const; create a new HypoTestInverterResult to hold all computed results. HypoTestInverterResult* GetInterval() const; Run a fixed scan or the automatic scan depending on the configuration; Return if needed a copy of the result object which will be managed by the user. HypoTestResult * Eval(RooStats::HypoTestCalculatorGeneric& hc, bool adaptive, double clsTarget) const; Run the Hypothesis test at a previous configured point; (internal function called by RunOnePoint). bool RunFixedScan(int nBins, double xMin, double xMax) const; Run a Fixed scan in npoints between min and max. bool RunOnePoint(double thisX, bool adaptive = false, double clTarget = -1) const; run only one point at the given POI value. bool RunLimit(double& limit, double& limitErr, double absTol = 0, double relTol = 0, const double* hint = 0) const; run an automatic scan until the desired accurancy is reached; Start by default from the full interval (min,max) of the POI and then via bisection find the line crossing; the target line; Optionally an hint can be provided and the scan will be done closer to that value; If by bisection the desired accuracy will not be reached a fit to the points is performed. SamplingDistribution * GetLowerLimitDistribution(bool rebuild = false, int nToys = 100); get the distribution of lower limit; if rebuild = false (default) it will re-use the results of the scan done; for obtained the observed limit and no extra toys will be generated; if rebuild a new set of B toys will be done and the procedure will be repeted; for each toy. SamplingDistribution * GetUpperLimitDistribution(bool rebuild = false, int nToys = 100); get the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HypoTestInverter.html:8770,adapt,adaptive,8770,root/html530/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html530/RooStats__HypoTestInverter.html,2,['adapt'],['adaptive']
Energy Efficiency,"rimer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome About ROOT. ROOT is a framework for data processing, born at CERN, at the heart of the research on high-energy physics. Every day, thousands of physicists use ROOT applications to analyze their data or to perform simulations. With ROOT you can:. Save data You can save your data (and any C++ object) in a compressed binary form in a ROOT file. The object format is also saved in the same file: the ROOT files are self-descriptive. Even in the case the source files describing the data model are not available, the information contained in a ROOT file is be always readable. ROOT provides a data structure, the tree, that is extremely powerful for fast access of huge amounts of data - orders of magnitude faster than accessing a normal file.; Access data Data saved into one or several ROOT files can be accessed from your PC, from the web and from large-scale file delivery systems used e.g. in the GRID. ROOT trees spread over several files can be chained and accessed as a unique object, allowing for loops over huge amounts of data.; Mine data Powerful mathematical and statistical tools are provided to operate on your data. The full power of a C++ application and of parallel processing is available for any kind of data manipulation. Data can also be generated following any statistical distribution and modeled, making it possible to simulate complex systems.; Publish results Results can be displayed with histograms, scatter plots, fitting functions. ROOT graphics may be adjusted real-time by few mouse clicks. Publication-quality figures can be saved in PDF or other formats.; Run interactively or build your own application You can use the Clin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/about-root.html:2479,power,powerful,2479,d/about-root.html,https://root.cern,https://root.cern/d/about-root.html,1,['power'],['powerful']
Energy Efficiency,"rincipal components p, and return it in x.; It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for x). void Print(Option_t* opt = ""MSE"") const; Print the statistics; Options are; M Print mean values of original data; S Print sigma values of original data; E Print eigenvalues of covariance matrix; V Print eigenvectors of covariance matrix; Default is MSE. void SumOfSquareResiduals(const Double_t* x, Double_t* s); PRIVATE METHOD:. /*; >; Calculates the sum of the square residuals, that is; . where; ; , is the; component of the principal vector, corresponding to; , the original data; I.e., the square distance to the space; spanned by eigenvectors.; . */; . void Test(Option_t* option = """"); Test the PCA, bye calculating the sum square of residuals; (see method SumOfSquareResiduals), and display the histogram. void X2P(const Double_t* x, Double_t* p); Calculate the principal components from the original data vector; x, and return it in p.; It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). const TMatrixD * GetCovarianceMatrix() const; {return &fCovarianceMatrix;}. const TVectorD * GetEigenValues() const; {return &fEigenValues;}. const TMatrixD * GetEigenVectors() const; {return &fEigenVectors;}. TList * GetHistograms() const; {return fHistograms;}. const TVectorD * GetMeanValues() const; {return &fMeanValues;}. const TVectorD * GetSigmas() const; {return &fSigmas;}. const TVectorD * GetUserData() const; {return &fUserData;}. Bool_t IsFolder() const; { return kTRUE;}. » Author: Christian Holm Christensen 1/8/2000 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id: TPrincipal.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPrincipal.html:17867,allocate,allocated,17867,root/html528/TPrincipal.html,https://root.cern,https://root.cern/root/html528/TPrincipal.html,1,['allocate'],['allocated']
Energy Efficiency,"rincipal components p, and return it in x.; It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for x). void Print(Option_t* opt = ""MSE"") const; Print the statistics; Options are; M Print mean values of original data; S Print sigma values of original data; E Print eigenvalues of covariance matrix; V Print eigenvectors of covariance matrix; Default is MSE. void SumOfSquareResiduals(const Double_t* x, Double_t* s); PRIVATE METHOD:. /*; >; Calculates the sum of the square residuals, that is; . where; ; , is the; component of the principal vector, corresponding to; , the original data; I.e., the square distance to the space; spanned by eigenvectors.; . */; . void Test(Option_t* option = """"); Test the PCA, bye calculating the sum square of residuals; (see method SumOfSquareResiduals), and display the histogram. void X2P(const Double_t* x, Double_t* p); Calculate the principal components from the original data vector; x, and return it in p.; It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). const TMatrixD * GetCovarianceMatrix() const; {return &fCovarianceMatrix;}. const TVectorD * GetEigenValues() const; {return &fEigenValues;}. const TMatrixD * GetEigenVectors() const; {return &fEigenVectors;}. TList * GetHistograms() const; {return fHistograms;}. const TVectorD * GetMeanValues() const; {return &fMeanValues;}. const TVectorD * GetSigmas() const; {return &fSigmas;}. const TVectorD * GetUserData() const; {return &fUserData;}. Bool_t IsFolder() const; { return kTRUE;}. » Author: Christian Holm Christensen 1/8/2000 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id: TPrincipal.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPrincipal.html:17936,allocate,allocated,17936,root/html530/TPrincipal.html,https://root.cern,https://root.cern/root/html530/TPrincipal.html,1,['allocate'],['allocated']
Energy Efficiency,"rincipal components p, and return it in x.; It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for x). void Print(Option_t* opt = ""MSE"") const; Print the statistics; Options are; M Print mean values of original data; S Print sigma values of original data; E Print eigenvalues of covariance matrix; V Print eigenvectors of covariance matrix; Default is MSE. void SumOfSquareResiduals(const Double_t* x, Double_t* s); PRIVATE METHOD:. /*; >; Calculates the sum of the square residuals, that is; . where; ; , is the; component of the principal vector, corresponding to; , the original data; I.e., the square distance to the space; spanned by eigenvectors.; . */; . void Test(Option_t* option = """"); Test the PCA, bye calculating the sum square of residuals; (see method SumOfSquareResiduals), and display the histogram. void X2P(const Double_t* x, Double_t* p); Calculate the principal components from the original data vector; x, and return it in p.; It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). const TMatrixD * GetCovarianceMatrix() const; {return &fCovarianceMatrix;}. const TVectorD * GetEigenValues() const; {return &fEigenValues;}. const TMatrixD * GetEigenVectors() const; {return &fEigenVectors;}. TList * GetHistograms() const; {return fHistograms;}. const TVectorD * GetMeanValues() const; {return &fMeanValues;}. const TVectorD * GetSigmas() const; {return &fSigmas;}. const TVectorD * GetUserData() const; {return &fUserData;}. Bool_t IsFolder() const; { return kTRUE;}. » Author: Christian Holm Christensen 1/8/2000 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id: TPrincipal.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPrincipal.html:17936,allocate,allocated,17936,root/html532/TPrincipal.html,https://root.cern,https://root.cern/root/html532/TPrincipal.html,1,['allocate'],['allocated']
Energy Efficiency,"rincipal::SumOfSquareResiduals ; (; const Double_t * ; x, . Double_t * ; s . ). virtual . Calculates the sum of the square residuals, that is. . \[; E_N = \sum_{i=0}^{P-1} \left(x_i - x^\prime_i\right)^2; \]. where \(x^\prime_i = \sum_{j=i}^N p_i e_{n_j}\) is the \(i^{\mbox{th}}\) component of the principal vector, corresponding to \(x_i\), the original data; I.e., the square distance to the space spanned by \(N\) eigenvectors. ; Definition at line 1183 of file TPrincipal.cxx. ◆ Test(). void TPrincipal::Test ; (; Option_t * ; option = """"). Test the PCA, bye calculating the sum square of residuals (see method SumOfSquareResiduals), and display the histogram. ; Definition at line 1205 of file TPrincipal.cxx. ◆ X2P(). void TPrincipal::X2P ; (; const Double_t * ; x, . Double_t * ; p . ). virtual . Calculate the principal components from the original data vector x, and return it in p. ; It's the users responsibility to make sure that both x and p are of the right size (i.e., memory must be allocated for p). ; Definition at line 1229 of file TPrincipal.cxx. Member Data Documentation. ◆ fCovarianceMatrix. TMatrixD TPrincipal::fCovarianceMatrix. protected . Covariance matrix. ; Definition at line 29 of file TPrincipal.h. ◆ fEigenValues. TVectorD TPrincipal::fEigenValues. protected . Eigenvalue vector of trans. ; Definition at line 32 of file TPrincipal.h. ◆ fEigenVectors. TMatrixD TPrincipal::fEigenVectors. protected . Eigenvector matrix of trans. ; Definition at line 31 of file TPrincipal.h. ◆ fHistograms. TList* TPrincipal::fHistograms. protected . List of histograms. ; Definition at line 40 of file TPrincipal.h. ◆ fIsNormalised. Bool_t TPrincipal::fIsNormalised. protected . Normalize matrix? ; Definition at line 42 of file TPrincipal.h. ◆ fMeanValues. TVectorD TPrincipal::fMeanValues. protected . Mean value over all data points. ; Definition at line 27 of file TPrincipal.h. ◆ fNumberOfDataPoints. Int_t TPrincipal::fNumberOfDataPoints. protected . Number of data points. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPrincipal.html:32918,allocate,allocated,32918,doc/master/classTPrincipal.html,https://root.cern,https://root.cern/doc/master/classTPrincipal.html,1,['allocate'],['allocated']
Energy Efficiency,"ring); 284 {; 285 create (""ROC"", 100, 0, 1, 100, 0, 1);; 286 create (""Significance"", 100, 0, 1, 100, 0, 3);; 287 create (""OutputSig"", 100, 0, 1);; 288 create (""OutputBkg"", 100, 0, 1);; 289 fMonitoring->ProcessEvents ();; 290 }; 291 }; 292 ; 293 /** \brief action to be done when the training cycle is ended (e.g. update some monitoring output); 294 *; 295 */; 296 void ClassificationSettings::endTrainCycle (double /*error*/) ; 297 {; 298 if (fMonitoring) fMonitoring->ProcessEvents ();; 299 }; 300 ; 301 /** \brief action to be done after the computation of a test sample (e.g. update some monitoring output); 302 *; 303 */; 304 void ClassificationSettings::testSample (double /*error*/, double output, double target, double weight); 305 {; 306 ; 307 m_output.push_back (output);; 308 m_targets.push_back (target);; 309 m_weights.push_back (weight);; 310 }; 311 ; 312 ; 313 /** \brief action to be done when the test cycle is started (e.g. update some monitoring output); 314 *; 315 */; 316 void ClassificationSettings::startTestCycle () ; 317 {; 318 m_output.clear ();; 319 m_targets.clear ();; 320 m_weights.clear ();; 321 }; 322 ; 323 /** \brief action to be done when the training cycle is ended (e.g. update some monitoring output); 324 *; 325 */; 326 void ClassificationSettings::endTestCycle () ; 327 {; 328 if (m_output.empty ()); 329 return;; 330 double minVal = *std::min_element (begin (m_output), end (m_output));; 331 double maxVal = *std::max_element (begin (m_output), end (m_output));; 332 const size_t numBinsROC = 1000;; 333 const size_t numBinsData = 100;; 334 ; 335 std::vector<double> truePositives (numBinsROC+1, 0);; 336 std::vector<double> falsePositives (numBinsROC+1, 0);; 337 std::vector<double> trueNegatives (numBinsROC+1, 0);; 338 std::vector<double> falseNegatives (numBinsROC+1, 0);; 339 ; 340 std::vector<double> x (numBinsData, 0);; 341 std::vector<double> datSig (numBinsData+1, 0);; 342 std::vector<double> datBkg (numBinsData+1, 0);; 343 ; 344 double binSizeROC =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8cxx_source.html:12007,monitor,monitoring,12007,doc/master/NeuralNet_8cxx_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8cxx_source.html,1,['monitor'],['monitoring']
Energy Efficiency,"ring,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooListProxy_x; Double_t_z; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const RooArgList& mu, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const RooFitResult& fr, Bool_t reduceToConditional = kTRUE). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TVectorD& mu, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const RooMultiVarGaussian& other, const char* name = 0). void syncMuVec() const. Double_t evaluate() const; Represent observables as vector. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Handle full integral here. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Special case: generate all observables. void initGenerator(Int_t code); Clear the GenData cache as its content is not invariant under changes in; the mu vector. void generateEvent(Int_t code); Retrieve generato",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMultiVarGaussian.html:46123,reduce,reduceToConditional,46123,root/html602/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html602/RooMultiVarGaussian.html,2,['reduce'],['reduceToConditional']
Energy Efficiency,"rint name of dataset. ;  ; void printTitle (std::ostream &os) const override;  Print title of dataset. ;  ; void RecursiveRemove (TObject *obj) override;  If one of the TObject we have a referenced to is deleted, remove the reference. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const char *cut) const;  Create a subset of the data set by applying the given cut on the data points. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooArgSet &varSubset, const char *cut=nullptr) const;  Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooArgSet &varSubset, const RooFormulaVar &cutVar) const;  Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  Create a reduced copy of this dataset. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooFormulaVar &cutVar) const;  Create a subset of the data set by applying the given cut on the data points. ;  ; virtual void reset ();  ; void resetBuffers ();  ; RooRealVar * rmsVar (const RooRealVar &var, const char *cutSpec=nullptr, const char *cutRange=nullptr) const;  Create a RooRealVar containing the RMS of observable 'var' in this dataset. ;  ; void setDirtyProp (bool flag);  Control propagation of dirty flags from observables in dataset. ;  ; void setGlobalObservables (RooArgSet const &globalObservables);  Sets the global observables stored in this data. ;  ; double sigma (const RooRealVar &var, const char *cutSpec=nullptr, const char *cutRange=nullptr) const;  ; double skewness (const RooRealVar &var, const char *cutSpec=nullptr, const char *cutRange=nullptr) const;  ; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataSet.html:15778,reduce,reduce,15778,doc/master/classRooDataSet.html,https://root.cern,https://root.cern/doc/master/classRooDataSet.html,2,['reduce'],"['reduce', 'reduced']"
Energy Efficiency,"rint name of dataset. ;  ; void printTitle (std::ostream &os) const override;  Print title of dataset. ;  ; void RecursiveRemove (TObject *obj) override;  If one of the TObject we have a referenced to is deleted, remove the reference. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const char *cut) const;  Create a subset of the data set by applying the given cut on the data points. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooArgSet &varSubset, const char *cut=nullptr) const;  Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooArgSet &varSubset, const RooFormulaVar &cutVar) const;  Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  Create a reduced copy of this dataset. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooFormulaVar &cutVar) const;  Create a subset of the data set by applying the given cut on the data points. ;  ; virtual void reset ();  ; void resetBuffers ();  ; RooRealVar * rmsVar (const RooRealVar &var, const char *cutSpec=nullptr, const char *cutRange=nullptr) const;  Create a RooRealVar containing the RMS of observable 'var' in this dataset. ;  ; void setDirtyProp (bool flag);  Control propagation of dirty flags from observables in dataset. ;  ; void setGlobalObservables (RooArgSet const &globalObservables);  Sets the global observables stored in this data. ;  ; void SetName (const char *name) override;  Set the name of the TNamed. ;  ; void SetNameTitle (const char *name, const char *title) override;  Set all the TNamed parameters (name and title). ;  ; double sigma (const RooReal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeData.html:8122,reduce,reduce,8122,doc/master/classRooTreeData.html,https://root.cern,https://root.cern/doc/master/classRooTreeData.html,4,['reduce'],"['reduce', 'reduced']"
Energy Efficiency,"rint name of dataset. ;  ; void printTitle (std::ostream &os) const override;  Print title of dataset. ;  ; void RecursiveRemove (TObject *obj) override;  If one of the TObject we have a referenced to is deleted, remove the reference. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const char *cut) const;  Create a subset of the data set by applying the given cut on the data points. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooArgSet &varSubset, const char *cut=nullptr) const;  Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooArgSet &varSubset, const RooFormulaVar &cutVar) const;  Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  Create a reduced copy of this dataset. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooFormulaVar &cutVar) const;  Create a subset of the data set by applying the given cut on the data points. ;  ; void resetBuffers ();  ; RooRealVar * rmsVar (const RooRealVar &var, const char *cutSpec=nullptr, const char *cutRange=nullptr) const;  Create a RooRealVar containing the RMS of observable 'var' in this dataset. ;  ; void setDirtyProp (bool flag);  Control propagation of dirty flags from observables in dataset. ;  ; void setGlobalObservables (RooArgSet const &globalObservables);  Sets the global observables stored in this data. ;  ; double sigma (const RooRealVar &var, const char *cutSpec=nullptr, const char *cutRange=nullptr) const;  ; double skewness (const RooRealVar &var, const char *cutSpec=nullptr, const char *cutRange=nullptr) const;  ; virtual RooFit::OwningPtr< TList >",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:18948,reduce,reduce,18948,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,2,['reduce'],"['reduce', 'reduced']"
Energy Efficiency,"rint();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; TGeoElementRNClass representing a radionuclidevoid TGeoManager::SetDefaultRootUnits() { if ( fgDefaultUnits == kRo...Definition TGeoElement.h:132; TGeoElementRN::Printvoid Print(Option_t *option="""") const overridePrint info about the element;.Definition TGeoElement.cxx:594; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; One can make materials or mixtures from radionuclides:; root[] TGeoMaterial *mat = new TGeoMaterial(""C14"", c14, 2.0);; The following properties of radionuclides can be currently accessed via getters in the TGeoElementRN class:; Atomic number and charge (from the base class TGeoElement). Isomeric number (ISO); ENDF code - following the convention: ENDF=10000*Z+100*A+ISO; Isomeric energy level [MeV]; Mass excess [MeV]; Half life [s]; Spin/Parity - can be retrieved with: TGeoElementRN::GetTitle(); Hynalation and ingestion toxicities; List of decays - TGeoElementRN::GetDecays(). The radioactive decays of a radionuclide are represented by the class TGeoDecayChannel and they are stored in a TObjArray. Decay provides:. Decay mode; Variation of isomeric number; Q value for the decay [GeV]; Parent element; Daughter element. Radionuclides are linked one to each other via their decays, until the last element in the decay chain which must be stable. One can iterate decay chains using the iterator TGeoElemIter:; root[] TGeoElemIter next(c14);; root[] TGeoElementRN *elem;; root[] while ((elem=next())) next.Print();; 6-C-014 (100% BetaMinus) T1/2=1.81e+11; 7-N-014 stable; N#define N; TGeoElemIterIterator for decay branches.Definition TGeoElement.h:358; T1#define T1Definition md5.inl:146; To create a radioactive material based on a radionuclide, one should use the constructor:; TGeoMaterial(const char *name, TGeoElement *elem,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Materials__classes.html:7656,energy,energy,7656,doc/master/group__Materials__classes.html,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html,1,['energy'],['energy']
Energy Efficiency,"rint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); static RooDataSet*read(const char* filename, const RooArgList& variables, const char* opts = """", const char* commonPath = """", const char* indexCatName = 0); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(RooCmdArg arg1, RooCmdArg arg2 = RooCmdArg(), RooCmdArg arg3 = RooCmdArg(), RooCmdArg arg4 = RooCmdArg(), RooCmdArg arg5 = RooCmdArg(), RooCmdArg arg6 = RooCmdArg(), RooCmdArg arg7 = RooCmdArg(), RooCmdArg arg8 = RooCmdArg()); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t flag); virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataSet.html:9807,reduce,reduce,9807,root/html526/RooDataSet.html,https://root.cern,https://root.cern/root/html526/RooDataSet.html,1,['reduce'],['reduce']
Energy Efficiency,"rint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); static RooDataSet*read(const char* filename, const RooArgList& variables, const char* opts = """", const char* commonPath = """", const char* indexCatName = 0); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDataSet.html:10060,reduce,reduce,10060,root/html530/RooDataSet.html,https://root.cern,https://root.cern/root/html530/RooDataSet.html,1,['reduce'],['reduce']
Energy Efficiency,"rint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); static RooDataSet*read(const char* filename, const RooArgList& variables, const char* opts = """", const char* commonPath = """", const char* indexCatName = 0); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; RooDataSet(); RooDataSet(const RooDataSet& other, const char* newname = 0); RooDataSet(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0); RooDataS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataSet.html:9135,reduce,reduce,9135,root/html602/RooDataSet.html,https://root.cern,https://root.cern/root/html602/RooDataSet.html,2,['reduce'],['reduce']
Energy Efficiency,"rint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); static RooDataSet*read(const char* filename, const RooArgList& variables, const char* opts = """", const char* commonPath = """", const char* indexCatName = 0); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDataSet.html:10156,reduce,reduce,10156,root/html532/RooDataSet.html,https://root.cern,https://root.cern/root/html532/RooDataSet.html,2,['reduce'],['reduce']
Energy Efficiency,"rint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); static RooDataSet*read(const char* filename, const RooArgList& variables, const char* opts = """", const char* commonPath = """", const char* indexCatName = 0); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDataSet.html:9863,reduce,reduce,9863,root/html528/RooDataSet.html,https://root.cern,https://root.cern/root/html528/RooDataSet.html,1,['reduce'],['reduce']
Energy Efficiency,"rintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(RooCmdArg arg1, RooCmdArg arg2 = RooCmdArg(), RooCmdArg arg3 = RooCmdArg(), RooCmdArg arg4 = RooCmdArg(), RooCmdArg arg5 = RooCmdArg(), RooCmdArg arg6 = RooCmdArg(), RooCmdArg arg7 = RooCmdArg(), RooCmdArg arg8 = RooCmdArg()); virtual voidreset(); voidTObject::ResetBit(UInt_t f); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* titl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsData.html:8089,reduce,reduce,8089,root/html526/RooAbsData.html,https://root.cern,https://root.cern/root/html526/RooAbsData.html,1,['reduce'],['reduce']
Energy Efficiency,"rintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_treleaseVars(RooAbsData*); virtual voidreset(); voidTObject::ResetBit(UInt_t f); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsData.html:8360,reduce,reduce,8360,root/html530/RooAbsData.html,https://root.cern,https://root.cern/root/html530/RooAbsData.html,1,['reduce'],['reduce']
Energy Efficiency,"rintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_treleaseVars(RooAbsData*); virtual voidreset(); voidTObject::ResetBit(UInt_t f); voidresetBuffers(); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; RooAbsData(); RooAbsData(const RooAbsData& other, const char* newname = 0); RooAbsData(const char* name, const char* title, const RooArgSet& vars, RooAbsDataStore* store = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetDefaultStorageType(RooAbsData::StorageType s); voidsetDirtyProp(Bool_t flag); vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsData.html:8487,reduce,reduce,8487,root/html602/RooAbsData.html,https://root.cern,https://root.cern/root/html602/RooAbsData.html,2,['reduce'],['reduce']
Energy Efficiency,"rintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_treleaseVars(RooAbsData*); virtual voidreset(); voidTObject::ResetBit(UInt_t f); voidresetBuffers(); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetDefaultStorageType(RooAbsData::StorageType s); voidsetDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsData.html:8432,reduce,reduce,8432,root/html532/RooAbsData.html,https://root.cern,https://root.cern/root/html532/RooAbsData.html,2,['reduce'],['reduce']
Energy Efficiency,"rintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); virtual voidreset(); voidTObject::ResetBit(UInt_t f); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsData.html:8089,reduce,reduce,8089,root/html528/RooAbsData.html,https://root.cern,https://root.cern/root/html528/RooAbsData.html,1,['reduce'],['reduce']
Energy Efficiency,"rite(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tWrite(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidDoError(int level, const char* location, const char* fmt, va_list va) const; voidMakeZombie(). Data Members; public:. enum EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. UInt_tfBitsbit field status word; UInt_tfUniqueIDobject unique identifier; static Long_tfgDtorOnlyobject for which to call dtor only (i.e. no delete); static Bool_tfgObjectStatif true keep track of objects in TObjectTable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TObject(); TObject constructor. It sets the two data words of TObject to their; initial values. The unique ID is set to 0 and the status word is; set depending if the object is created on the stack or allocated; on the heap. Depending on the ROOT environment variable ""Root.MemStat""; (see TEnv) the object is added to the global TObjectTable for; bookkeeping. TObject(const TObject& object); TObject copy ctor. TObject& operator=(const TObject& rhs); TObject assignment operator. void Copy(TObject& object) const; Copy this to obj. ~TObject(); TObject destructor. Removes object from all canvases and object browsers; if observer bit is on and remove from the global object table. void AppendPad(Option_t* option = """"); Append graphics object to current pad. In case no current pad is set; yet, create a default canvas with the name ""c1"". void Browse(TBrowser* b); Browse object. May be overridden for another default action. const char * ClassName() const; Returns name of class to which the object belongs. TObject * Clone(const char* newname = """") const; Make a clone of an object using the Streamer facility.; If the object derives from TNamed, this functi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TObject.html:5263,allocate,allocated,5263,root/html528/TObject.html,https://root.cern,https://root.cern/root/html528/TObject.html,4,['allocate'],['allocated']
Energy Efficiency,"rites multiple baskets to disk in parallel; 521 /// - TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; 522 /// - THx::Fit performs in parallel the evaluation of the objective function over the data; 523 /// - TMVA::DNN trains the deep neural networks in parallel; 524 /// - TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel; 525 ///; 526 /// EnableImplicitMT calls in turn EnableThreadSafety.; 527 /// The 'numthreads' parameter allows to control the number of threads to; 528 /// be used by the implicit multi-threading. However, this parameter is just; 529 /// a hint for ROOT: it will try to satisfy the request if the execution; 530 /// scenario allows it. For example, if ROOT is configured to use an external; 531 /// scheduler, setting a value for 'numthreads' might not have any effect.; 532 /// The maximum number of threads can be influenced by the environment; 533 /// variable `ROOT_MAX_THREADS`: `export ROOT_MAX_THREADS=2` will try to set; 534 /// the maximum number of active threads to 2, if the scheduling library; 535 /// (such as tbb) ""permits"".; 536 ///; 537 /// \note Use `DisableImplicitMT()` to disable multi-threading (some locks will remain in place as; 538 /// described in EnableThreadSafety()). `EnableImplicitMT(1)` creates a thread-pool of size 1.; 539 void EnableImplicitMT(UInt_t numthreads); 540 {; 541#ifdef R__USE_IMT; 542 if (ROOT::Internal::IsImplicitMTEnabledImpl()); 543 return;; 544 EnableThreadSafety();; 545 static void (*sym)(UInt_t) = (void(*)(UInt_t))Internal::GetSymInLibImt(""ROOT_TImplicitMT_EnableImplicitMT"");; 546 if (sym); 547 sym(numthreads);; 548 ROOT::Internal::IsImplicitMTEnabledImpl() = true;; 549#else; 550 ::Warning(""EnableImplicitMT"", ""Cannot enable implicit multi-threading with %d threads, please build ROOT with -Dimt=ON"", numthreads);; 551#endif; 552 }; 553 ; 554 ////////////////////////////////////////////////////////////////////////////////; 555 /// Disables th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:20218,schedul,scheduling,20218,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['schedul'],['scheduling']
Energy Efficiency,"rivate:. vector<double>fBinEdgevector containing the bin upper edge (coordinate will contain low edge) ; ROOT::Fit::DataVector*fDataVectorpointer to the copied in data vector; ROOT::Fit::DataWrapper*fDataWrapperpointer to the external data wrapper structure; unsigned intfDimcoordinate dimension; unsigned intfNPointsnumber of contained points in the data set (can be different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const DataOptions & opt, const DataRange & range, unsigned int maxpoints = 0, unsigned int dim = 1, ErrorType err = kValueError ). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double * dataX, const double * val, const double * ex , const double * eval ); constructurs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Fit__BinData.html:5927,allocate,allocate,5927,root/html526/ROOT__Fit__BinData.html,https://root.cern,https://root.cern/root/html526/ROOT__Fit__BinData.html,1,['allocate'],['allocate']
Energy Efficiency,"rivate:. vector<double>fBinEdgevector containing the bin upper edge (coordinate will contain low edge) ; ROOT::Fit::DataVector*fDataVectorpointer to the copied in data vector; ROOT::Fit::DataWrapper*fDataWrapperpointer to the external data wrapper structure; unsigned intfDimcoordinate dimension; unsigned intfNPointsnumber of contained points in the data set (can be different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double* dataX, const double* val, const double* ex, const double* eval); constructurs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__BinData.html:6006,allocate,allocate,6006,root/html528/ROOT__Fit__BinData.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__BinData.html,3,['allocate'],['allocate']
Energy Efficiency,"rivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double operator( const double * x); This class defines static methods with will be used to fill the gsl_monte_function used by GSL. See for examples the GSL online manual ; Definition at line 56 of file GSLMonteFunctionAdapter.h. Enumeration Type Documentation. ◆ Type. enum ROOT::Math::IntegrationMultiDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static option . kADAPTIVE adaptive multi-dimensional integration . kVEGAS MC integration. . kMISER MC integration. . kPLAIN MC integration. . Definition at line 47 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__MCIntegration.html:2093,adapt,adapting,2093,doc/master/group__MCIntegration.html,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html,2,['adapt'],"['adapting', 'adaptive']"
Energy Efficiency,"rix(Double_t* carr); Set transformation matrix from colum-major array. void SetTransMatrix(const TGeoMatrix& mat); Set transformation matrix from TGeo's matrix. Bool_t AcceptElement(TEveElement* el); Check if el can be added to this element. In the base-class version we only make sure the new child is not; equal to this. void AddElement(TEveElement* el); Add el to the list of children. void RemoveElement(TEveElement* el); Remove el from the list of children. void RemoveElementLocal(TEveElement* el); Perform additional local removal of el.; Called from RemoveElement() which does whole untangling.; Put into special function as framework-related handling of; element removal should really be common to all classes and; clearing of local structures happens in between removal; of list-tree-items and final removal.; If you override this, you should also override; RemoveElementsLocal(). void RemoveElementsInternal(); Remove all elements. This assumes removing of all elements can; be done more efficiently then looping over them and removing one; by one. This protected function performs the removal on the; level of TEveElement. void RemoveElements(); Remove all elements. This assumes removing of all elements can; be done more efficiently then looping over them and removing; them one by one. void RemoveElementsLocal(); Perform additional local removal of all elements.; See comment to RemoveElementlocal(TEveElement*). void ProjectChild(TEveElement* el, Bool_t same_depth = kTRUE); If this is a projectable, loop over all projected replicas and; add the projected image of child 'el' there. This is supposed to; be called after you add a child to a projectable after it has; already been projected.; You might also want to call RecheckImpliedSelections() on this; element or 'el'. If 'same_depth' flag is true, the same depth as for parent object; is used in every projection. Otherwise current depth of each; relevant projection-manager is used. void ProjectAllChildren(Bool_t same_depth = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveElement.html:24646,efficient,efficiently,24646,root/html528/TEveElement.html,https://root.cern,https://root.cern/root/html528/TEveElement.html,6,['efficient'],['efficiently']
Energy Efficiency,"rization _regularization=TMVA::DNN::EnumRegularization::NONE, MinimizerType _eMinimizerType=MinimizerType::fSteepest, double _learningRate=1e-5, double _momentum=0.3, int _repetitions=3, bool _multithreading=true);  c'tor ;  ; virtual ~Settings ();  d'tor ;  ; void addPoint (std::string histoName, double x);  for monitoring ;  ; void addPoint (std::string histoName, double x, double y);  for monitoring ;  ; size_t batchSize () const;  mini-batch size ;  ; void clear (std::string histoName);  for monitoring ;  ; virtual void computeResult (const Net &, std::vector< double > &);  callback for monitoring and logging ;  ; size_t convergenceCount () const;  returns the current convergence count ;  ; size_t convergenceSteps () const;  how many steps until training is deemed to have converged ;  ; void create (std::string histoName, int bins, double min, double max);  for monitoring ;  ; void create (std::string histoName, int bins, double min, double max, int bins2, double min2, double max2);  for monitoring ;  ; virtual void cycle (double progress, TString text);  ; virtual void drawSample (const std::vector< double > &, const std::vector< double > &, const std::vector< double > &, double);  callback for monitoring and logging ;  ; const std::vector< double > & dropFractions () const;  ; size_t dropRepetitions () const;  ; bool exists (std::string histoName);  for monitoring ;  ; double factorWeightDecay () const;  get the weight-decay factor ;  ; virtual bool hasConverged (double testError);  has this training converged already? ;  ; double learningRate () const;  get the learning rate ;  ; size_t maxConvergenceCount () const;  returns the max convergence count so far ;  ; size_t minError () const;  returns the smallest error so far ;  ; MinimizerType minimizerType () const;  which minimizer shall be used (e.g. SGD) ;  ; double momentum () const;  get the momentum (e.g. for SGD) ;  ; void pads (int numPads);  preparation for monitoring ;  ; void plot (std::string histoN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html:2403,monitor,monitoring,2403,doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,8,['monitor'],['monitoring']
Energy Efficiency,"rization regularization () const { return m_regularization; } ///< some regularization of the DNN is turned on?; 814 ; 815 bool useMultithreading () const { return m_useMultithreading; } ///< is multithreading turned on?; 816 ; 817 ; 818 void pads (int numPads) { if (fMonitoring) fMonitoring->pads (numPads); } ///< preparation for monitoring; 819 void create (std::string histoName, int bins, double min, double max) { if (fMonitoring) fMonitoring->create (histoName, bins, min, max); } ///< for monitoring; 820 void create (std::string histoName, int bins, double min, double max, int bins2, double min2, double max2) { if (fMonitoring) fMonitoring->create (histoName, bins, min, max, bins2, min2, max2); } ///< for monitoring; 821 void addPoint (std::string histoName, double x) { if (fMonitoring) fMonitoring->addPoint (histoName, x); } ///< for monitoring; 822 void addPoint (std::string histoName, double x, double y) {if (fMonitoring) fMonitoring->addPoint (histoName, x, y); } ///< for monitoring; 823 void plot (std::string histoName, std::string options, int pad, EColor color) { if (fMonitoring) fMonitoring->plot (histoName, options, pad, color); } ///< for monitoring; 824 void clear (std::string histoName) { if (fMonitoring) fMonitoring->clear (histoName); } ///< for monitoring; 825 bool exists (std::string histoName) { if (fMonitoring) return fMonitoring->exists (histoName); return false; } ///< for monitoring; 826 ; 827 size_t convergenceCount () const { return m_convergenceCount; } ///< returns the current convergence count; 828 size_t maxConvergenceCount () const { return m_maxConvergenceCount; } ///< returns the max convergence count so far; 829 size_t minError () const { return m_minError; } ///< returns the smallest error so far; 830 ; 831 public:; 832 Timer m_timer; ///< timer for monitoring; 833 double m_minProgress; ///< current limits for the progress bar; 834 double m_maxProgress; ///< current limits for the progress bar; 835 ; 836 ; 837 size_t m_convergenceS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:31178,monitor,monitoring,31178,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['monitor'],['monitoring']
Energy Efficiency,"rks are stable and performing for a large variety of ; : linear and non-linear classification problems. However, in contrast; : to (e.g.) boosted decision trees, the user is advised to reduce the ; : number of input variables that have only little discrimination power. ; : ; : In the tests we have carried out so far, the MLP and ROOT networks; : (TMlpANN, interfaced via TMVA) performed equally well, with however; : a clear speed advantage for the MLP. The Clermont-Ferrand neural ; : net (CFMlpANN) exhibited worse classification performance in these; : tests, which is partly due to the slow convergence of its training; : (at least 10k training cycles are required to achieve approximately; : competitive results).; : ; : ␛[1mOvertraining: ␛[0monly the TMlpANN performs an explicit separation of the; : full training sample into independent training and validation samples.; : We have found that in most high-energy physics applications the ; : available degrees of freedom (training events) are sufficient to ; : constrain the weights of the relatively simple architectures required; : to achieve good performance. Hence no overtraining should occur, and ; : the use of validation samples would only reduce the available training; : information. However, if the performance on the training sample is ; : found to be significantly better than the one found with the inde-; : pendent test sample, caution is needed. The results for these samples ; : are printed to standard output at the end of each training job.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The hidden layer architecture for all ANNs is defined by the option; : ""HiddenLayers=N+1,N,..."", where here the first hidden layer has N+1; : neurons and the second N neurons (and so on), and where N is the number ; : of input variables. Excessive numbers of hidden layers should be avoided,; : in favour of more neurons in the first hidden layer.; : ; : The number of cycles should be above 500. As said, if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:43066,energy,energy,43066,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['energy'],['energy']
Energy Efficiency,"rks only for 1-dimensional histograms . Definition at line 8062 of file TH1.cxx. ◆ AutoP2FindLimits(). Int_t TH1::AutoP2FindLimits ; (; Double_t ; xmi, . Double_t ; xma . ). protectedvirtual . Buffer-based estimate of the histogram range using the power of 2 algorithm. ; Used by the autobin power of 2 algorithm.; Works on arguments (min and max from fBuffer) and internal inputs: fXmin, fXmax, NBinsX (from fXaxis), ... Result save internally in fXaxis.; Overloaded by TH2 and TH3.; Return -1 if internal inputs are inconsistent, 0 otherwise. ; Definition at line 1343 of file TH1.cxx. ◆ AutoP2GetBins(). Int_t TH1::AutoP2GetBins ; (; Int_t ; n). inlinestaticprotected . Auxiliary function to get the next power of 2 integer value larger then n. ; Used by the autobin power of 2 algorithm ; Definition at line 1321 of file TH1.cxx. ◆ AutoP2GetPower2(). Double_t TH1::AutoP2GetPower2 ; (; Double_t ; x, . Bool_t ; next = kTRUE . ). inlinestaticprotected . Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ; next = kTRUE : next larger next = kFALSE : previous smaller; Used by the autobin power of 2 algorithm ; Definition at line 1308 of file TH1.cxx. ◆ AxisChoice(). Int_t TH1::AxisChoice ; (; Option_t * ; axis); const. protected . Choose an axis according to ""axis"". ; Definition at line 14 of file Haxis.cxx. ◆ Browse(). void TH1::Browse ; (; TBrowser * ; b). overridevirtual . Browse the Histogram object. ; Reimplemented from TObject.; Definition at line 762 of file TH1.cxx. ◆ BufferEmpty(). Int_t TH1::BufferEmpty ; (; Int_t ; action = 0). virtual . Fill histogram with all entries in the buffer. . action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint); action = 0 histogram is reset and filled from the buffer. When the histogram is filled from the buffer the value fBuffer[0] is set to a negative number (= - number of entries) When calling with action == 0 the histogram is NOT refilled when fBuffer[0] is < 0 W",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:82044,power,power,82044,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['power'],['power']
Energy Efficiency,"rkspace ; Double_t*_x! Current coordinate; Double_t_xmax! Upper integration bound; Double_t_xmin! Lower integration bound. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register this class with RooNumIntConfig as a possible choice of numeric; integrator for one-dimensional integrals over finite and infinite domains. RooAdaptiveGaussKronrodIntegrator1D(); Default constructor. RooAdaptiveGaussKronrodIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor taking a function binding and a configuration object. RooAdaptiveGaussKronrodIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor taking a function binding, an integration range and a configuration object. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor. Bool_t initialize(); Initialize integrator allocate buffers and setup GSL workspace. ~RooAdaptiveGaussKronrodIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Calculate and return integral at at given parameter values. RooAdaptiveGaussKronrodIntegrator1D(); Constructors, assignment etc. Bool_t setUseIntegrandLimits(Bool_t flag); If flag is true, intergration limits are taken from definition in input function binding. Bool_t canIntegrate1D() const; We can integrate 1-dimensional functions. Bool_t canIntegrate2D() const; We can not integrate 2-dimensional functions. Bool_t canIntegrateND() const; We can not int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAdaptiveGaussKronrodIntegrator1D.html:8958,allocate,allocate,8958,root/html526/RooAdaptiveGaussKronrodIntegrator1D.html,https://root.cern,https://root.cern/root/html526/RooAdaptiveGaussKronrodIntegrator1D.html,2,['allocate'],['allocate']
Energy Efficiency,"rlap with the old shape. The optional last argument nr_zeros is only relevant for sparse matrices. If supplied, it sets the number of non-zero elements. If it is smaller than the number overlapping with the old matrix, only the first (row-wise)nr_zeros are copied to the new matrix. Method; Descriptions. SetTol (Double_t tol); set the tolerance number. ResizeTo (Int_t nrows,Int_t ncols,; Int_t nr_nonzeros=-1); change matrix shape to nrows x ncols. Index will start at zero. ResizeTo(Int_t row_lwb,Int_t row_upb,; Int_t col_lwb,Int_t col_upb,; Int_t nr_nonzeros=-1); change matrix shape to; row_lwb:row_upb x col_lwb:col_upb. SetRowIndexArray (Int_t *data); for sparse matrices, set the row index. The array data should contains at leastfNrows+1 entries column lower-bound index. SetColIndexArray (Int_t *data); for sparse matrices, set the column index. The array data should contains at least fNelems entries. SetSparseIndex (Int_t nelems new); allocate memory for a sparse map of nelems_new elements and copy (if exists) at most nelems_new matrix elements over to the new structure. SetSparseIndex (const TMatrixDBase &a); copy the sparse map from matrix a Note that this can be a dense matrix!. SetSparseIndexAB (const TMatrixDSparse &a, const TMatrixDSparse &b); set the sparse map to the same of the map of matrix a and b. The second half of the table is only relevant for sparse matrices. These methods define the sparse structure. It should be clear that a call to any of these methods has to be followed by a SetMatrixArray (…) which will supply the matrix data, see the next chapter “Creating and Filling a Matrix”.; 14.3 Creating and Filling a Matrix; The matrix constructors are listed in the next table. In the simplest ones, only the number of rows and columns is given. In a slightly more elaborate version, one can define the row and column index range. Finally, one can also define the matrix data in the constructor. In Matrix Operators and Methods we will encounter more fancy co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:774263,allocate,allocate,774263,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['allocate'],['allocate']
Energy Efficiency,"rlapIntergral = kFALSE); Calculate the ROC integral of a single classifier or even the; whole boosted classifier. The tree type (training or testing; sample) is specified by 'eTT'. If tree type kTraining is set, the original training sample is; used to compute the ROC integral (original weights). - singleMethod - if kTRUE, return ROC integral of single (last; trained) classifier; if kFALSE, return ROC; integral of full classifier. - eTT - tree type (Types::kTraining / Types::kTesting). - CalcOverlapIntergral - if kTRUE, the overlap integral of the; signal/background MVA distributions; is calculated and stored in; 'fOverlap_integral'. void CalcMVAValues(); Calculate MVA values of current method fMethods.back() on; training sample. void MonitorBoost(TMVA::Types::EBoostStage stage, UInt_t methodIdx = 0); fill various monitoring histograms from information of the individual classifiers that; have been boosted.; of course.... this depends very much on the individual classifiers, and so far, only for; Decision Trees, this monitoring is actually implemented. MethodBoost(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null); constructors. void SetBoostedMethodName(TString methodName); { fBoostedMethodName = methodName; }. Int_t GetBoostNum(); { return fBoostNum; }. void ClearAll(); clean up. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; print fit results. MethodBase* CurrentMethod(); {return fCurrentMethod;}. UInt_t CurrentMethodIdx(); training a single classifier. {return fCurrentMethodIdx;}. Double_t CalcMethodWeight(); calculate weight of single method. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Or Cohen, Jan Therhaag, Eckhard von Toerne » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__MethodBoost.html:24157,monitor,monitoring,24157,root/html604/TMVA__MethodBoost.html,https://root.cern,https://root.cern/root/html604/TMVA__MethodBoost.html,1,['monitor'],['monitoring']
Energy Efficiency,"rlapIntergral = kFALSE); Calculate the ROC integral of a single classifier or even the; whole boosted classifier. The tree type (training or testing; sample) is specified by 'eTT'. If tree type kTraining is set, the original training sample is; used to compute the ROC integral (original weights). - singleMethod - if kTRUE, return ROC integral of single (last; trained) classifier; if kFALSE, return ROC; integral of full classifier. - eTT - tree type (Types::kTraining / Types::kTesting). - CalcOverlapIntergral - if kTRUE, the overlap integral of the; signal/background MVA distributions; is calculated and stored in; 'fOverlap_integral'. void CalcMVAValues(); Calculate MVA values of current method fMethods.back() on; training sample. void MonitorBoost(TMVA::Types::EBoostStage stage, UInt_t methodIdx = 0); fill various monitoring histograms from information of the individual classifiers that; have been boosted.; of course.... this depends very much on the individual classifiers, and so far, only for; Decision Trees, this monitoring is actually implemented. MethodBoost(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = __null); constructors. void SetBoostedMethodName(TString methodName); { fBoostedMethodName = methodName; }. Int_t GetBoostNum(); { return fBoostNum; }. void ClearAll(); clean up. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; print fit results. MethodBase* CurrentMethod(); {return fCurrentMethod;}. UInt_t CurrentMethodIdx(); training a single classifier. {return fCurrentMethodIdx;}. Double_t CalcMethodWeight(); calculate weight of single method. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Or Cohen, Jan Therhaag, Eckhard von Toerne » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:16; This page has been automatically generated. For comments or suggestions regarding the documentati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodBoost.html:24149,monitor,monitoring,24149,root/html602/TMVA__MethodBoost.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodBoost.html,1,['monitor'],['monitoring']
Energy Efficiency,"rnEncode(). void TPDF::PatternEncode ; (; ). Patterns encoding. ; Definition at line 2474 of file TPDF.cxx. ◆ PrintFast(). void TPDF::PrintFast ; (; Int_t ; nch, . const char * ; string = """" . ). overridevirtual . Fast version of Print. ; Reimplemented from TVirtualPS.; Definition at line 1857 of file TPDF.cxx. ◆ PrintStr(). void TPDF::PrintStr ; (; const char * ; string = """"). overridevirtual . Output the string str in the output buffer. ; Reimplemented from TVirtualPS.; Definition at line 1835 of file TPDF.cxx. ◆ Range(). void TPDF::Range ; (; Float_t ; xrange, . Float_t ; yrange . ). Set the range for the paper in centimetres. ; Definition at line 1876 of file TPDF.cxx. ◆ SetAlpha(). void TPDF::SetAlpha ; (; Float_t ; alpha = 1.). Set the alpha channel value. ; Definition at line 1886 of file TPDF.cxx. ◆ SetColor() [1/2]. void TPDF::SetColor ; (; Float_t ; r, . Float_t ; g, . Float_t ; b . ). overridevirtual . Set color with its R G B components: . r: % of red in [0,1]; g: % of green in [0,1]; b: % of blue in [0,1] . Implements TVirtualPS.; Definition at line 1927 of file TPDF.cxx. ◆ SetColor() [2/2]. void TPDF::SetColor ; (; Int_t ; color = 1). Set color with its color index. ; Definition at line 1906 of file TPDF.cxx. ◆ SetFillColor(). void TPDF::SetFillColor ; (; Color_t ; cindex = 1). overridevirtual . Set color index for fill areas. ; Reimplemented from TAttFill.; Definition at line 1979 of file TPDF.cxx. ◆ SetFillPatterns(). void TPDF::SetFillPatterns ; (; Int_t ; ipat, . Int_t ; color . ). Set the fill patterns (1 to 25) for fill areas. ; Definition at line 1987 of file TPDF.cxx. ◆ SetLineCap(). void TPDF::SetLineCap ; (; Int_t ; linecap = 0). Set the value of the global parameter TPDF::fgLineCap. ; This parameter determines the appearance of line caps in a PDF output. It takes one argument which may be:; 0 (butt caps); 1 (round caps); 2 (projecting caps) The default value is 0 (butt caps). To change the line cap behaviour just do: gStyle->SetCapLinePS(2);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPDF.html:34966,green,green,34966,doc/master/classTPDF.html,https://root.cern,https://root.cern/doc/master/classTPDF.html,1,['green'],['green']
Energy Efficiency,rnel0.data();; std::vector<float> fTensor_dense_2kernel0 = std::vector<float>(4096);; float * tensor_dense_2kernel0 = fTensor_dense_2kernel0.data();; std::vector<float> fTensor_dense_1bias0 = std::vector<float>(64);; float * tensor_dense_1bias0 = fTensor_dense_1bias0.data();; std::vector<float> fTensor_dense_4bias0 = std::vector<float>(2);; float * tensor_dense_4bias0 = fTensor_dense_4bias0.data();; std::vector<float> fTensor_dense_1kernel0 = std::vector<float>(4096);; float * tensor_dense_1kernel0 = fTensor_dense_1kernel0.data();; std::vector<float> fTensor_densebias0 = std::vector<float>(64);; float * tensor_densebias0 = fTensor_densebias0.data();; std::vector<float> fTensor_dense_2bias0 = std::vector<float>(64);; float * tensor_dense_2bias0 = fTensor_dense_2bias0.data();; std::vector<float> fTensor_densekernel0 = std::vector<float>(448);; float * tensor_densekernel0 = fTensor_densekernel0.data();; ; //--- declare and allocate the intermediate tensors; std::vector<float> fTensor_dense_4Sigmoid0 = std::vector<float>(2);; float * tensor_dense_4Sigmoid0 = fTensor_dense_4Sigmoid0.data();; std::vector<float> fTensor_dense_4Dense = std::vector<float>(2);; float * tensor_dense_4Dense = fTensor_dense_4Dense.data();; std::vector<float> fTensor_densebias0bcast = std::vector<float>(64);; float * tensor_densebias0bcast = fTensor_densebias0bcast.data();; std::vector<float> fTensor_dense_1bias0bcast = std::vector<float>(64);; float * tensor_dense_1bias0bcast = fTensor_dense_1bias0bcast.data();; std::vector<float> fTensor_dense_3bias0bcast = std::vector<float>(64);; float * tensor_dense_3bias0bcast = fTensor_dense_3bias0bcast.data();; std::vector<float> fTensor_dense_1Dense = std::vector<float>(64);; float * tensor_dense_1Dense = fTensor_dense_1Dense.data();; std::vector<float> fTensor_dense_1Relu0 = std::vector<float>(64);; float * tensor_dense_1Relu0 = fTensor_dense_1Relu0.data();; std::vector<float> fTensor_dense_2Dense = std::vector<float>(64);; float * tensor_dense_2Dense =,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__Inference_8py.html:5623,allocate,allocate,5623,doc/master/TMVA__SOFIE__Inference_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__Inference_8py.html,3,['allocate'],['allocate']
Energy Efficiency,"ro describing how to use the special mathematical functions taking full advantage of the precision and speed of the C99 compliant environments ;  mathcoreStatFunc.C Example macro showing some major probability density functions in ROOT ;  mathcoreVectorCollection.C Example showing how to write and read a std vector of ROOT::Math LorentzVector in a ROOT tree ;  mathcoreVectorFloatIO.C Macro illustrating I/O with Lorentz Vectors of floats The dictionary for LorentzVector of float is not in the libMathCore, therefore is generated when parsed the file with CINT ;  mathcoreVectorIO.C Example of I/O of a mathcore Lorentz Vectors in a Tree and comparison with a TLorentzVector ;  mathGammaNormal.C Tutorial illustrating the use of TMath::GammaDist and TMath::LogNormal ;  mathLaplace.C Test the TMath::LaplaceDist and TMath::LaplaceDistI functions ;  mathmoreIntegration.C Example on the usage of the adaptive 1D integration algorithm of MathMore it calculates the numerically cumulative integral of a distribution (like in this case the BreitWigner) to execute the macro type it (you need to compile with AClic) ;  mathStudent.C Tutorial illustrating the use of the Student and F distributions ;  multidimSampling.C Example of sampling a multi-dim distribution using the DistSampler class NOTE: This tutorial must be run with ACLIC ;  normalDist.C Tutorial illustrating the new statistical distributions functions (pdf, cdf and quantile) ;  permute.C Tutorial illustrating the use of TMath::Permute can be run with: ;  principal.C Principal Components Analysis (PCA) example ;  quantiles.C Demo for quantiles ;  quasirandom.C Example of generating quasi-random numbers ;  Rolke.C Example of the usage of the TRolke class The TRolke class computes the profile likelihood confidence limits for 7 different model assumptions on systematic/statistical uncertainties ;  testrandom.C Performance test of all the ROOT random generator (TRandom, TRandom1, TRandom2 and TRandom3) Tests the generator TRandom3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:131410,adapt,adaptive,131410,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['adapt'],['adaptive']
Energy Efficiency,"rom TAttFill; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAtt3D; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions;  TPCON (const TPCON &);  copy constructor ;  ; virtual void FillTableOfCoSin (Double_t phi, Double_t angstep, Int_t n) const;  Fill the table of cos and sin to prepare drawing. ;  ; virtual void MakeTableOfCoSin () const;  Make table of cosine and sine. ;  ; TPCON & operator= (const TPCON &);  assignment operator ;  ; void SetPoints (Double_t *points) const override;  Create PCON points. ;  ; virtual Bool_t SetSegsAndPols (TBuffer3D &buffer) const;  Set segments and polygons. ;  ;  Protected Member Functions inherited from TShape; virtual void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections) const;  We have to set kRawSize (unless already done) to allocate buffer space before kRaw can be filled. ;  ; Int_t GetBasicColor () const;  Get basic color. ;  ; Int_t ShapeDistancetoPrimitive (Int_t numPoints, Int_t px, Int_t py);  Distance to primitive. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Double_t * fCoTab;  Table of sin(fPhi1) .... sin(fPhil+fDphi1) ;  ; Float_t fDphi1;  ; Float_t * fDz;  ; Int_t fNdiv;  ; Int_t fNz;  ; Float_t fPhi1;  Table of cos(fPhi1) .... cos(fPhil+fDphi1) ;  ; Float_t * fRmax;  ; Float_t * fRmin;  ; Double_t * fSiTab;  ;  Protected Attributes inherited from TShape; TMaterial * fMaterial;  ; Int_t fNumber;  ; Int_t fVisibility;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPCON.html:16668,allocate,allocate,16668,doc/master/classTPCON.html,https://root.cern,https://root.cern/doc/master/classTPCON.html,1,['allocate'],['allocate']
Energy Efficiency,"rom TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns KTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. void * New(void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TClass.html:34769,allocate,allocated,34769,root/html530/TClass.html,https://root.cern,https://root.cern/root/html530/TClass.html,2,['allocate'],['allocated']
Energy Efficiency,"rom TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns kTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. void * New(void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClass.html:36885,allocate,allocated,36885,root/html534/TClass.html,https://root.cern,https://root.cern/root/html534/TClass.html,1,['allocate'],['allocated']
Energy Efficiency,"rom the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t *&c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t *&h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t *&ii); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t *&ll); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t *&ll); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t *&f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t *&d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as float) from the I/O buffer.; Returns the number of doubles read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Double32_t encoding at TBufferF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferFile.html:26387,allocate,allocated,26387,root/html526/TBufferFile.html,https://root.cern,https://root.cern/root/html526/TBufferFile.html,1,['allocate'],['allocated']
Energy Efficiency,"rom this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMonitor.html:10427,monitor,monitor,10427,root/html528/TMonitor.html,https://root.cern,https://root.cern/root/html528/TMonitor.html,18,['monitor'],['monitor']
Energy Efficiency,"rom versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2117/// In case of error returns the ""!"" string.; 2118 ; 2119TString TString::UItoa(UInt_t value, Int_t base); 2120{; 2121 std::string buf;; 2122 // check that the base if valid; 2123 if (base < 2 || base > 36) {; 2124 Error(""TString::UItoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2125 return (TString(""!""));; 2126 }; 2127 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2128 UInt_t quotient = value;; 2129 // Translating number to string with base:; 2130 do {; 2131 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ quotient % base ];; 2132 quotient /= base;; 2133 } while (quotient);; 2134 std::reverse(buf.begin(), buf.end());; 2135 return (TString(buf.data()));; 2136}; 2137 ; 2138////////////////////////////////////////////////////////////////////////////////; 2139/// Converts a Long64_t to a TString with respect to the base specified (2-36).; 2140/// Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; 2141/// http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2142/// In case of error returns the ""!"" string.; 2143 ; 2144TString TString::LLtoa(Long64_t value, Int_t base); 2145{; 2146 std::string buf;; 2147 // check that the base if valid; 2148 if (base < 2 || base > 36) {; 2149 Error(""TString::LLtoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2150 return (TString(""!""));; 2151 }; 2152 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2153 Long64_t quotient = value;; 2154 // Translating number to string with base:; 2155 do {; 2156 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ TMath::Abs(quotient % base) ];; 2157 quotient /= base;; 2158 } while (quotient);; 2159 // Append the negative sign; 2160 if (value < 0) buf += '-';; 2161 std::reverse(buf.begin(), buf.end());; 2162 return (TString(buf.data()));; 2163}; 2164 ; 2165////////////////////////////////////////////////////////////////////////////////; 2166//",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:67543,adapt,adapted,67543,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['adapt'],['adapted']
Energy Efficiency,"ronment. void ClearInputFiles(); Clear list containing macro files passed as program arguments.; This method is called from TRint::Run() to ensure that the macro; files are only executed the first time Run() is called. char * Argv(Int_t index) const; Return specified argument. void GetOptions(Int_t* argc, char** argv); Get and handle command line options. Arguments handled are removed; from the argument array. The following arguments are handled:; -b : run in batch mode without graphics; -x : exit on exception; -e expression: request execution of the given C++ expression.; -n : do not execute logon and logoff macros as specified in .rootrc; -q : exit after processing command line macro files; -l : do not show splash screen; The last three options are only relevant in conjunction with TRint.; The following help and info arguments are supported:; -? : print usage; -h : print usage; --help : print usage; -config : print ./configure options; -memstat : run with memory usage monitoring; In addition to the above options the arguments that are not options,; i.e. they don't start with - or + are treated as follows (and also removed; from the argument array):; <dir> is considered the desired working directory and available; via WorkingDirectory(), if more than one dir is specified the; first one will prevail; <file> if the file exists its added to the InputFiles() list; <file>.root are considered ROOT files and added to the InputFiles() list,; the file may be a remote file url; <macro>.C are considered ROOT macros and also added to the InputFiles() list; In TRint we set the working directory to the <dir>, the ROOT files are; connected, and the macros are executed. If your main TApplication is not; TRint you have to decide yourself what to do whith these options.; All specified arguments (also the ones removed) can always be retrieved; via the TApplication::Argv() method. void HandleIdleTimer(); Handle idle timeout. When this timer expires the registered idle command; will be ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TApplication.html:15450,monitor,monitoring,15450,root/html602/TApplication.html,https://root.cern,https://root.cern/root/html602/TApplication.html,2,['monitor'],['monitoring']
Energy Efficiency,"root.json --digest -o root.json; 1.9.1 Objects data access in JSON format; Request root.json implemented with TBufferJSON class. TBufferJSON generates such object representation, which could be directly used in JSROOT for drawing. root.json request returns either complete object or just object member like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/fTitle/root.json; The result will be: ""title"".; For the root.json request one could specify the ‘compact’ parameter, which allow to reduce the number of spaces and new lines without data lost. This parameter can have values from ‘0’ (no compression) till ‘3’ (no spaces and new lines at all). In addition, one can use simple compression algorithm for big arrays. If compact=‘10’, zero values in the begin and at the end of the array will be excluded. If compact=‘20’, similar values or large zero gaps in-between will be compressed. Such array compression support in JSROOT from version 4.8.2.; Usage of root.json request is about as efficient as binary root.bin request. Comparison of different request methods with TH2 histogram from hsimple.C shown in the table:. Request; Size. root.bin; 7672 bytes. root.bin.gz; 1582 bytes. root.json; 8570 bytes. root.json?compact=3; 6004 bytes. root.json?compact=23; 5216 bytes. root.json.gz?compact=23; 1855 bytes. One should remember that JSON representation always includes names of the data fields which are not present in the binary representation. Even then the size difference is negligible.; root.json used in JSROOT to request objects from THttpServer.; 1.9.2 Generating images out of objects; For the ROOT classes which are implementing Draw method (like TH1 or TGraph) one could produce images with requests: root.png, root.gif, root.jpeg. For example:; [shell] wget ""http://localhost:8080/Files/hsimple.root/hpx/root.png?w=500&h=500&opt=lego1"" -O lego1.png; For all such requests following parameters could be specified:. h - image height; w - image width; opt - draw options. 1.9.3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:16195,efficient,efficient,16195,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,1,['efficient'],['efficient']
Energy Efficiency,"ropagation schema:. The input layer contains as many neurons as input variables used in the MVA.; The output layer contains two neurons for the signal and background; event classes. In between the input and output layers are a variable number; of k hidden layers with arbitrary numbers of neurons. (While the; structure of the input and output layers is determined by the problem, the; hidden layers can be configured by the user through the option string; of the method booking.) ; As indicated in the sketch, all neuron inputs to a layer are linear; combinations of the neuron output of the previous layer. The transfer; from input to output within a neuron is performed by means of an ""activation; function"". In general, the activation function of a neuron can be; zero (deactivated), one (linear), or non-linear. The above example uses; a sigmoid activation function. The transfer function of the output layer; is usually linear. As a consequence: an ANN without hidden layer should; give identical discrimination power as a linear discriminant analysis (Fisher).; In case of one hidden layer, the ANN computes a linear combination of; sigmoid. ; The learning method used by the CFMlpANN is only stochastic.; */; . Function Members (Methods); public:. virtual~MethodCFMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html:1566,power,power,1566,root/html528/TMVA__MethodCFMlpANN.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html,6,['power'],['power']
Energy Efficiency,"ror called a ""memory leak"", i.e. the memory of your process grows and eventually your program crashes. Even if you always delete the allocated memory, the recovered space may not be efficiently reused. The process knows that there are portions of free memory, but when you allocate it again, a fresh piece of memory is grabbed. Your program is free from semantic errors, but the total memory of your process still grows, because your program's memory is full of ""holes"" which reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in terms of CPU time.; Without entering into technical details, TClonesArray allows you to ""reuse"" the same portion of memory for new/delete avoiding memory fragmentation and memory growth and improving the performance by orders of magnitude. Every time the memory of the TClonesArray has to be reused, the Clear() method is used. To provide its benefits, each TClonesArray must be allocated once per process and disposed of (deleted) only when not needed any more.; So a job should see only one deletion for each TClonesArray, which should be Clear()ed during the job several times. Deleting a TClonesArray is a double waste. Not only you do not avoid memory fragmentation, but you worsen it because the TClonesArray itself is a rather heavy structure, and there is quite some code in the destructor, so you have more memory fragmentation and slower code. NOTE 2; When investigating misuse of TClonesArray, please make sure of the following:. Use Clear() or Clear(""C"") instead of Delete(). This will improve program execution time.; TClonesArray object classes containing pointers allocate memory. To avoid causing memory leaks, special Clear(""C"") must be used for clearing TClonesArray. When option ""C"" is specified, ROOT automatically executes the Clear() method (by default it is empty contained in TObject). This method must be overridden in the relevant TClonesArray object class, implementin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:3446,allocate,allocated,3446,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['allocate'],['allocated']
Energy Efficiency,"rot set. ; Pressing the keys 'z' and 'u' will zoom and unzoom the picture near the mouse location, 'r' will reset to the default view.; Try it (in compiled mode!) with: root mandelbrot.C+. Details; when a mouse event occurs the myexec() function is called (by using AddExec). Depending on the pressed key, the mygenerate() function is called, with the proper arguments. Note the last_x and last_y variables that are used in myexec() to store the last pointer coordinates (px is not a pointer position in kKeyPress events).; ; #include <TStyle.h>; #include <TROOT.h>; #include <TH2.h>; #include <TComplex.h>; #include <TVirtualPad.h>; #include <TCanvas.h>; ; TH2F *last_histo = nullptr;; ; void mygenerate(double factor, double cen_x, double cen_y); {; printf(""Regenerating...\n"");; // resize histo:; if(factor>0); {; double dx=last_histo->GetXaxis()->GetXmax()-last_histo->GetXaxis()->GetXmin();; double dy=last_histo->GetYaxis()->GetXmax()-last_histo->GetYaxis()->GetXmin();; last_histo->SetBins(; last_histo->GetNbinsX(),; cen_x-factor*dx/2,; cen_x+factor*dx/2,; last_histo->GetNbinsY(),; cen_y-factor*dy/2,; cen_y+factor*dy/2; );; last_histo->Reset();; }; else; {; if(last_histo) delete last_histo;; // allocate first view...; last_histo = new TH2F(""h2"",; ""Mandelbrot [move mouse and press z to zoom, u to unzoom, r to reset]"",; 200,-2,2,200,-2,2);; last_histo->SetStats(false);; }; const int max_iter=50;; for(int bx=1;bx<=last_histo->GetNbinsX();bx++); for(int by=1;by<=last_histo->GetNbinsY();by++); {; double x=last_histo->GetXaxis()->GetBinCenter(bx);; double y=last_histo->GetYaxis()->GetBinCenter(by);; TComplex point( x,y);; TComplex z=point;; int iter=0;; while (z.Rho()<2){; z=z*z+point;; last_histo->Fill(x,y);; iter++;; if(iter>max_iter) break;; }; }; last_histo->SetContour(99);; last_histo->Draw(""colz"");; gPad->Modified();; gPad->Update();; printf(""Done.\n"");; }; ; void myexec(); {; // get event information; int event = gPad->GetEvent();; int px = gPad->GetEventX();; int py = gPad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/mandelbrot_8C.html:1494,allocate,allocate,1494,doc/master/mandelbrot_8C.html,https://root.cern,https://root.cern/doc/master/mandelbrot_8C.html,1,['allocate'],['allocate']
Energy Efficiency,"rotected Member Functions inherited from TArray; Bool_t BoundsOk (const char *where, Int_t at) const;  ; Bool_t OutOfBoundsError (const char *where, Int_t i) const;  Generate an out-of-bounds error. Always returns false. ;  ;  Static Protected Member Functions inherited from TH3; static TH1D * DoProject1D (const TH3 &h, const char *name, const char *title, const TAxis *projX, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 1D histogram ;  ; static TH2D * DoProject2D (const TH3 &h, const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 2D histogram ;  ;  Static Protected Member Functions inherited from TH1; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2);  Check histogram compatibility. ;  ; static bool CheckConsistentSubAxes (const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0);  Check that two sub axis are the same. ;  ; static bool CheckEqualAxes (const TAxis *a1, const TAxis *a2);  Check that the axis are the same. ;  ; static Bool_t RecomputeAxisLimits (TAxis &destAxis, const TAxis &anAxis);  Finds new limits for the axis for the Merge function. ;  ; static Bool_t SameLimitsAndNBins (const TAxis &axis1, const TAxis &axis2);  S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLTH3Composition.html:58496,power,power,58496,doc/master/classTGLTH3Composition.html,https://root.cern,https://root.cern/doc/master/classTGLTH3Composition.html,1,['power'],['power']
Energy Efficiency,"rotected:. Int_tfDegreedegree of mixed transform, applies only for Fourier-Walsh, Fourier-Haar, Walsh-Haar, Cosine-Walsh, Cosine-Haar, Sine-Walsh, Sine-Haar transforms; Int_tfDirectionforward or inverse transform; Double_tfEnhanceCoeffmultiplication coefficient applied in enhanced region;; Double_tfFilterCoeffvalue set in the filtered region; TStringTNamed::fNameobject identifier; Int_tfSizelength of transformed data; TStringTNamed::fTitleobject title; Int_tfTransformTypetype of transformation (Haar, Walsh, Cosine, Sine, Fourier, Hartley, Fourier-Walsh, Fourier-Haar, Walsh-Haar, Cosine-Walsh, Cosine-Haar, Sine-Walsh, Sine-Haar); Int_tfXmaxlast channel of filtered or enhanced region; Int_tfXminfirst channel of filtered or enhanced region. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TSpectrumTransform. Function documentation; TSpectrumTransform(); default constructor. TSpectrumTransform(Int_t size); the constructor creates TSpectrumTransform object. Its size must be > than zero and must be power of 2.; It sets default transform type to be Cosine transform. Transform parameters can be changed using setter functions. ~TSpectrumTransform(); destructor. void Haar(Double_t* working_space, Int_t num, Int_t direction). AUXILIARY FUNCION. This function calculates Haar transform of a part of data; Function parameters:; -working_space-pointer to vector of transformed data; -num-length of processed data; -direction-forward or inverse transform. void Walsh(Double_t* working_space, Int_t num). AUXILIARY FUNCION. This function calculates Walsh transform of a part of data; Function parameters:; -working_space-pointer to vector of transformed data; -num-length of processed data. void BitReverse(Double_t* working_space, Int_t num). AUXILIARY FUNCION. This function carries out bir-reverse reordering of data; Function parameters:; -working_space-pointer to vector of processed data; -num-length of processed data. void Fourier(Double_t* working_space, Int_t num, Int_t hartley,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrumTransform.html:9714,power,power,9714,root/html602/TSpectrumTransform.html,https://root.cern,https://root.cern/root/html602/TSpectrumTransform.html,2,['power'],['power']
Energy Efficiency,"rotectedvirtual . PRIVATE METHOD: This is the method that actually generates the code for the evaluation the parameterization on some point. ; It's called by TMultiDimFit::MakeCode and TMultiDimFit::MakeMethod.; The options are: NONE so far ; Definition at line 1963 of file TMultiDimFit.cxx. ◆ Print(). void TMultiDimFit::Print ; (; Option_t * ; option = ""ps""); const. overridevirtual . Print statistics etc. ; Options are P Parameters S Statistics C Coefficients R Result of parameterisation F Result of fit K Correlation Matrix M Pretty print formula ; Reimplemented from TObject.; Definition at line 2158 of file TMultiDimFit.cxx. ◆ Select(). Bool_t TMultiDimFit::Select ; (; const Int_t * ; iv). protectedvirtual . Selection method. ; User can override this method for specialized selection of acceptable functions in fit. Default is to select all. This message is sent during the build-up of the function candidates table once for each set of powers in variables. Notice, that the argument array contains the powers PLUS ONE. For example, to De select the function f = x1^2 * x2^4 * x3^5, this method should return kFALSE if given the argument { 3, 4, 6 } ; Definition at line 2365 of file TMultiDimFit.cxx. ◆ SetBinVarX(). void TMultiDimFit::SetBinVarX ; (; Int_t ; nbbinvarx). inline . Definition at line 195 of file TMultiDimFit.h. ◆ SetBinVarY(). void TMultiDimFit::SetBinVarY ; (; Int_t ; nbbinvary). inline . Definition at line 196 of file TMultiDimFit.h. ◆ SetMaxAngle(). void TMultiDimFit::SetMaxAngle ; (; Double_t ; ang = 0). Set the max angle (in degrees) between the initial data vector to be fitted, and the new candidate function to be included in the fit. ; By default it is 0, which automatically chooses another selection criteria. See also class description ; Definition at line 2377 of file TMultiDimFit.cxx. ◆ SetMaxFunctions(). void TMultiDimFit::SetMaxFunctions ; (; Int_t ; n). inline . Definition at line 198 of file TMultiDimFit.h. ◆ SetMaxPowers(). void TMultiDimFit::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:57377,power,powers,57377,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['power'],['powers']
Energy Efficiency,"round events:; fill histograms and smooth them; if decorrelation is required, compute; corresponding square-root matrices; the reference histograms require the correct boundaries. Since in Likelihood classification; the transformations are applied using both classes, also the corresponding boundaries; need to take this into account. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns the likelihood estimator for signal; fill a new Likelihood branch into the testTree. Double_t TransformLikelihoodOutput(Double_t ps, Double_t pb) const; returns transformed or non-transformed output. void WriteOptionsToStream(ostream& o, const TString& prefix) const; write options to stream. void AddWeightsXMLTo(void* parent) const; write weights to XML. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void WriteWeightsToStream(TFile& rf) const; write reference PDFs to ROOT file. void ReadWeightsFromXML(void* wghtnode); read weights from XML. void ReadWeightsFromStream(istream& istr); read weight info from file; nothing to do for this method. void ReadWeightsFromStream(TFile& istr); read reference PDF from ROOT file. void WriteMonitoringHistosToFile( void ); write histograms and PDFs to file for monitoring purposes. void MakeClassSpecificHeader(ostream& , const TString& = """") const; write specific header of the classifier (mostly include files). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodLikelihood.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-12-08 16:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodLikelihood.html:21303,monitor,monitoring,21303,root/html528/TMVA__MethodLikelihood.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodLikelihood.html,1,['monitor'],['monitoring']
Energy Efficiency,"rowse(0) instead.; This means TObject::Inspect() will be invoked indirectly. Int_t Compare(const TObject* obj) const; Compare two TCollection objects. Returns 0 when equal, -1 when this is; smaller and +1 when bigger (like strcmp()). void Draw(Option_t* option = """"); Draw all objects in this collection.; wildcarding supported, eg option=""xxx*"" draws only objects; with names xxx*. void Dump() const; Dump all objects in this collection. TObject * FindObject(const char *name); Find an object in this collection using its name. Requires a sequential; scan till the object has been found. Returns 0 if object with specified; name is not found. TObject * operator()(const char* name) const; Find an object in this collection by name. TObject * FindObject(const TObject *obj); Find an object in this collection using the object's IsEqual(); member function. Requires a sequential scan till the object has; been found. Returns 0 if object is not found.; Typically this function is overridden by a more efficient version; in concrete collection classes (e.g. THashTable). const char * GetName() const; Return name of this collection.; if no name, return the collection class name. Int_t GrowBy(Int_t delta) const; Increase the collection's capacity by delta slots. Bool_t IsArgNull(const char* where, const TObject* obj) const; Returns true if object is a null pointer. void ls(Option_t* option = """") const; List (ls) all objects in this collection.; Wildcarding supported, eg option=""xxx*"" lists only objects; with names xxx*. void Paint(Option_t* option = """"); Paint all objects in this collection. void PrintCollectionHeader(Option_t* option) const; Print the collection header. const char* GetCollectionEntryName(TObject* entry) const; For given collection entry return the string that is used to; identify the object and, potentially, perform wildcard/regexp; filtering on. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print the collection entry. void Print(Optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCollection.html:9280,efficient,efficient,9280,root/html526/TCollection.html,https://root.cern,https://root.cern/root/html526/TCollection.html,1,['efficient'],['efficient']
Energy Efficiency,"rpolation class based on GSL interpolation functions ;  CGSLMCIntegrationWorkspace;  CGSLMCIntegrator;  CGSLMinimizerGSLMinimizer class ;  CGSLMinimizer1DMinimizer for arbitrary one dimensional functions ;  CGSLMiserIntegrationWorkspaceWorkspace for MISER ;  CGSLMonteFunctionAdapter;  CGSLMonteFunctionWrapperWrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm ;  CGSLMultiFitGSLMultiFit, internal class for implementing GSL non linear least square GSL fitting ;  CGSLMultiFitFunctionAdapterClass for adapting a C++ functor class to C function pointers used by GSL MultiFit Algorithm The templated C++ function class must implement: ;  CGSLMultiFitFunctionWrapperWrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithm ;  CGSLMultiMinDerivFunctionWrapperWrapper for a multi-dimensional function with derivatives used in GSL multidim minimization algorithm ;  CGSLMultiMinFunctionAdapterClass for adapting any multi-dimension C++ functor class to C function pointers used by GSL MultiMin algorithms ;  CGSLMultiMinFunctionWrapperWrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithm ;  CGSLMultiMinimizerGSLMultiMinimizer class , for minimizing multi-dimensional function using derivatives ;  CGSLMultiRootBaseSolverGSLMultiRootBaseSolver, internal class for implementing GSL multi-root finders This is the base class for GSLMultiRootSolver (solver not using derivatives) and GSLMUltiRootDerivSolver (solver using derivatives) ;  CGSLMultiRootDerivFunctionWrapperWrapper to a multi-dim function with derivatives for multi roots algorithm ;  CGSLMultiRootDerivSolverGSLMultiRootDerivSolver, internal class for implementing GSL multi-root finders using derivatives ;  CGSLMultiRootFinderClass for Multidimensional root finding algorithms bassed on GSL ;  CGSLMultiRootFunctionAdapterClass for adapting a C++ functor class to C function pointers used by GSL Mul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:32116,adapt,adapting,32116,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,7,['adapt'],['adapting']
Energy Efficiency,"rray, and a separate ""fUniqueID"" value for each reference. For further information, see the above URL. Some useful container classes. TObjArray and TClonesArray; The TObjArray class can be used to support an array of objects. The objects need not be of the same type, but each object must be of a class type that inherits from TObject. We have already seen a specific example of the use of TObjArray, in the StreamerInfo record, where it is used to hold an array of TStreamerElement objects, each of which is of a class inheriting from TStreamerElement, which in turn inherits from TObject.; The TClonesArray class is a specialization of the TObjArray class for holding an array of objects that are all of the same type. The format of a TClonesArray object is given in Format of the DATA for a TClonesArray object.; There are two great advantages in the use of TClonesArray over TObjArray when the objects all will be of the same class:. Memory for the objects will be allocated only once for the entire array, rather than the per-object allocation for TObjArray. This can be done because all the objects are the same size.; In the case of TObjArray, the stored objects are written sequentially. However, in a TClonesArray, by default, each object is split one level deep into its base class(es) and data members, and each of these members is written sequentially for all objects in the array before the next member is written. This has two advantages:; Greater compression can be achieved when similar data is consecutive.; The object's data members can easily be split into different TTree branches (TTrees are discussed below). TTree; A TTree is a highly specialized container class for efficient storage and retrieval of user data. The use of TTrees is discussed in detail in the Trees chapter of the Root Manual; Here we discuss in particular how a TTree is stored in a ROOTIO file.; A TTree object is split into one or more branches (class TBranch), each of which may have its own (sub)branches",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootio.html:13167,allocate,allocated,13167,doc/master/rootio.html,https://root.cern,https://root.cern/doc/master/rootio.html,1,['allocate'],['allocated']
Energy Efficiency,"rray.h. ◆ MakeCopy(). TGeoBranchArray * TGeoBranchArray::MakeCopy ; (; const TGeoBranchArray & ; other). static . Make a copy of a branch array at the location (if indicated) ; Definition at line 81 of file TGeoBranchArray.cxx. ◆ MakeCopyAt(). TGeoBranchArray * TGeoBranchArray::MakeCopyAt ; (; const TGeoBranchArray & ; other, . void * ; addr . ). static . Make a copy of a branch array at the location (if indicated) ; Definition at line 101 of file TGeoBranchArray.cxx. ◆ MakeInstance(). TGeoBranchArray * TGeoBranchArray::MakeInstance ; (; size_t ; maxlevel). static . Make an instance of the class which allocates the node array. ; To be released using ReleaseInstance. If addr is non-zero, the user promised that addr contains at least that many bytes: size_t needed = SizeOf(maxlevel); ; Definition at line 51 of file TGeoBranchArray.cxx. ◆ MakeInstanceAt(). TGeoBranchArray * TGeoBranchArray::MakeInstanceAt ; (; size_t ; maxlevel, . void * ; addr . ). static . Make an instance of the class which allocates the node array. ; To be released using ReleaseInstance. If addr is non-zero, the user promised that addr contains at least that many bytes: size_t needed = SizeOf(maxlevel); ; Definition at line 69 of file TGeoBranchArray.cxx. ◆ operator!=(). Bool_t TGeoBranchArray::operator!= ; (; const TGeoBranchArray & ; other); const. Not equal operator. ; Definition at line 219 of file TGeoBranchArray.cxx. ◆ operator<(). Bool_t TGeoBranchArray::operator< ; (; const TGeoBranchArray & ; other); const. Is equal operator. ; Definition at line 241 of file TGeoBranchArray.cxx. ◆ operator<=(). Bool_t TGeoBranchArray::operator<= ; (; const TGeoBranchArray & ; other); const. Is equal operator. ; Definition at line 263 of file TGeoBranchArray.cxx. ◆ operator=(). TGeoBranchArray & TGeoBranchArray::operator= ; (; const TGeoBranchArray & ; other). Assignment. Not valid anymore. Use TGeoBranchArray::MakeCopy instead. ; Definition at line 169 of file TGeoBranchArray.cxx. ◆ operator==(). Bool_t TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBranchArray.html:20084,allocate,allocates,20084,doc/master/classTGeoBranchArray.html,https://root.cern,https://root.cern/doc/master/classTGeoBranchArray.html,1,['allocate'],['allocates']
Energy Efficiency,"rrayF > eyL, std::vector< TArrayF > eyH, Int_t m=kOnlyFirst);  TGraphMultiErrors normal constructor with np points and ne y-errors. ;  ;  TGraphMultiErrors (Int_t np, Int_t ne=1);  TGraphMultiErrors normal constructor with np points and ne y-errors. ;  ;  ~TGraphMultiErrors () override;  TGraphMultiErrors default destructor. ;  ; virtual void AddYError (Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr);  Add a new y error to the graph and fill it with the values from eyL and eyH ;  ; void Apply (TF1 *f) override;  Apply a function to all data points \( y = f(x,y) \). ;  ; virtual void BayesDivide (const TH1 *pass, const TH1 *total, Option_t *opt="""");  This function is only kept for backward compatibility. ;  ; void ComputeRange (Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const override;  Compute Range. ;  ; virtual void DeleteYError (Int_t e);  Deletes the y error with the index e. ;  ; void Divide (const TH1 *pass, const TH1 *total, Option_t *opt=""cp"");  This function was adapted from the TGraphAsymmErrors class. ;  ; virtual TAttFill * GetAttFill (Int_t e);  Get AttFill pointer for specified error dimension. ;  ; virtual TAttLine * GetAttLine (Int_t e);  Get AttLine pointer for specified error dimension. ;  ; Double_t GetErrorX (Int_t i) const override;  Get error on x coordinate for point i. ;  ; Double_t GetErrorXhigh (Int_t i) const override;  Get high error on x coordinate for point i. ;  ; Double_t GetErrorXlow (Int_t i) const override;  Get low error on x coordinate for point i. ;  ; Double_t GetErrorY (Int_t i) const override;  Get error on y coordinate for point i. ;  ; virtual Double_t GetErrorY (Int_t i, Int_t e) const;  Get error e on y coordinate for point i. ;  ; Double_t GetErrorYhigh (Int_t i) const override;  Get high error on y coordinate for point i. ;  ; virtual Double_t GetErrorYhigh (Int_t i, Int_t e) const;  Get high error e on y coordinate for point i. ;  ; Double_t GetErrorYlow (Int_t i) const override;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphMultiErrors.html:10197,adapt,adapted,10197,doc/master/classTGraphMultiErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphMultiErrors.html,1,['adapt'],['adapted']
Energy Efficiency,"rrayL64>): bin content held by a Long64_t,; 509- THnSparseI (typedef for THnSparseT<ArrayI>): bin content held by an Int_t,; 510- THnSparseS (typedef for THnSparseT<ArrayS>): bin content held by a Short_t,; 511- THnSparseC (typedef for THnSparseT<ArrayC>): bin content held by a Char_t,; 512 ; 513They take name and title, the number of dimensions, and for each dimension; 514the number of bins, the minimal, and the maximal value on the dimension's; 515axis. A TH2 h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; 516 ; 517 Int_t bins[2] = {10, 20};; 518 Double_t xmin[2] = {0., -5.};; 519 Double_t xmax[2] = {10., 5.};; 520 THnSparseD hs(""hs"", ""hs"", 2, bins, xmin, xmax);; 521 ; 522## Filling; 523A THnSparse is filled just like a regular histogram, using; 524THnSparse::Fill(x, weight), where x is a n-dimensional Double_t value.; 525To take errors into account, Sumw2() must be called before filling the; 526histogram.; 527 ; 528Bins are allocated as needed; the status of the allocation can be observed; 529by GetSparseFractionBins(), GetSparseFractionMem().; 530 ; 531## Fast Bin Content Access; 532When iterating over a THnSparse one should only look at filled bins to save; 533processing time. The number of filled bins is returned by; 534THnSparse::GetNbins(); the bin content for each (linear) bin number can; 535be retrieved by THnSparse::GetBinContent(linidx, (Int_t*)coord).; 536After the call, coord will contain the bin coordinate of each axis for the bin; 537with linear index linidx. A possible call would be; 538 ; 539 std::cout << hs.GetBinContent(0, coord);; 540 std::cout <<"" is the content of bin [x = "" << coord[0] ""; 541 << "" | y = "" << coord[1] << ""]"" << std::endl;; 542 ; 543## Efficiency; 544TH1 and TH2 are generally faster than THnSparse for one and two dimensional; 545distributions. THnSparse becomes competitive for a sparsely filled TH3; 546with large numbers of bins per dimension. The tutorial sparsehist.C; 547shows the turning point. On a AMD64 with 8GB me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:19113,allocate,allocated,19113,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"rrentVersion = kTRUE;; 5456 break;; 5457 }; 5458 }; 5459 }; 5460 }; 5461 ; 5462 if (!inRepo || currentVersion) {; 5463 // The object was allocated using code for the same class version; 5464 // as is loaded now. We may proceed without worry.; 5465 TVirtualStreamerInfo* si = GetStreamerInfo();; 5466 if (si) {; 5467 si->Destructor(p, dtorOnly);; 5468 } else {; 5469 Error(""Destructor"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct emulated object!"", GetName(), fClassVersion, p);; 5470 Error(""Destructor"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5471 Int_t i = fStreamerInfo->LowerBound();; 5472 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5473 Error(""Destructor"", ""fStreamerInfo->At(%d): %p"", i, fStreamerInfo->At(i));; 5474 if (fStreamerInfo->At(i) != nullptr) {; 5475 Error(""Destructor"", ""Doing Dump() ..."");; 5476 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5477 }; 5478 }; 5479 }; 5480 } else {; 5481 // The loaded class version is not the same as the version of the code; 5482 // which was used to allocate this object. The best we can do is use; 5483 // the TVirtualStreamerInfo to try to free up some of the allocated memory.; 5484 TVirtualStreamerInfo* si = (TVirtualStreamerInfo*) fStreamerInfo->At(objVer);; 5485 if (si) {; 5486 si->Destructor(p, dtorOnly);; 5487 } else {; 5488 Error(""Destructor"", ""No streamer info available for class '%s' version %d, cannot destruct object at addr: %p"", GetName(), objVer, p);; 5489 Error(""Destructor"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5490 Int_t i = fStreamerInfo->LowerBound();; 5491 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5492 Error(""Destructor2"", ""fStreamerInfo->At(%d): %p"", i, fStreamerInfo->At(i));; 5493 if (fStreamerInfo->At(i) != nullptr) {; 5494 // Do some debugging output.; 5495 Error(""Destructor2"", ""Doing Dump() ..."");; 5496 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5497 }; 5498 }; 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:209717,allocate,allocate,209717,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"rrentVersion = kTRUE;; 5523 break;; 5524 }; 5525 }; 5526 }; 5527 }; 5528 ; 5529 if (!inRepo || currentVersion) {; 5530 // The object was allocated using code for the same class version; 5531 // as is loaded now. We may proceed without worry.; 5532 TVirtualStreamerInfo* si = GetStreamerInfo();; 5533 if (si) {; 5534 si->Destructor(p, dtorOnly);; 5535 } else {; 5536 Error(""Destructor"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct emulated object!"", GetName(), fClassVersion, p);; 5537 Error(""Destructor"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5538 Int_t i = fStreamerInfo->LowerBound();; 5539 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5540 Error(""Destructor"", ""fStreamerInfo->At(%d): %p"", i, fStreamerInfo->At(i));; 5541 if (fStreamerInfo->At(i) != nullptr) {; 5542 Error(""Destructor"", ""Doing Dump() ..."");; 5543 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5544 }; 5545 }; 5546 }; 5547 } else {; 5548 // The loaded class version is not the same as the version of the code; 5549 // which was used to allocate this object. The best we can do is use; 5550 // the TVirtualStreamerInfo to try to free up some of the allocated memory.; 5551 TVirtualStreamerInfo* si = (TVirtualStreamerInfo*) fStreamerInfo->At(objVer);; 5552 if (si) {; 5553 si->Destructor(p, dtorOnly);; 5554 } else {; 5555 Error(""Destructor"", ""No streamer info available for class '%s' version %d, cannot destruct object at addr: %p"", GetName(), objVer, p);; 5556 Error(""Destructor"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5557 Int_t i = fStreamerInfo->LowerBound();; 5558 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5559 Error(""Destructor2"", ""fStreamerInfo->At(%d): %p"", i, fStreamerInfo->At(i));; 5560 if (fStreamerInfo->At(i) != nullptr) {; 5561 // Do some debugging output.; 5562 Error(""Destructor2"", ""Doing Dump() ..."");; 5563 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5564 }; 5565 }; 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:212468,allocate,allocate,212468,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"rror of a RooRealVar as a separate object. More...;  ; class  RooExpensiveObjectCache;  Singleton class that serves as repository for objects that are expensive to calculate. More...;  ; class  RooExtendedTerm;  A p.d.f with no observables that only introduces an extended ML term for a given number of expected events term when an extended ML is constructed. More...;  ; class  RooFactoryWSTool;  Implementation detail of the RooWorkspace. More...;  ; class  RooFFTConvPdf;  PDF for the numerical (FFT) convolution of two PDFs. More...;  ; class  RooFirstMoment;  ; class  RooFoamGenerator;  Generic Monte Carlo toy generator that implement the TFOAM sampling technique on any positively valued function. More...;  ; class  RooFormula;  Internally uses ROOT's TFormula to compute user-defined expressions of RooAbsArgs. More...;  ; class  RooFracRemainder;  Calculates the remainder fraction of a sum of RooAbsReal fraction, i.e (1 - sum_i a_i). More...;  ; class  RooFunctor;  Lightweight interface adaptor that exports a RooAbsPdf as a functor. More...;  ; class  RooGaussKronrodIntegrator1D;  Implements the Gauss-Kronrod integration algorithm. More...;  ; class  RooGenContext;  Implements a universal generator context for all RooAbsPdf classes that do not have or need a specialized generator context. More...;  ; class  RooGenericPdf;  Implementation of a probability density function that takes a RooArgList of servers and a C++ expression string defining how its value should be calculated from the given list of servers. More...;  ; class  RooGenFitStudy;  Abstract base class for RooStudyManager modules. More...;  ; class  RooGenProdProj;  General form of projected integral of product of PDFs, utility class for RooProdPdf. More...;  ; class  RooHist;  Graphical representation of binned data based on the TGraphAsymmErrors class. More...;  ; class  RooHistError;  Singleton class used to calculate the error bars for each bin of a RooHist object. More...;  ; class  RooHistFunc;  A real",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Roofitcore.html:10698,adapt,adaptor,10698,doc/master/group__Roofitcore.html,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html,1,['adapt'],['adaptor']
Energy Efficiency,"rrors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.95, bool norm = true) const. get confidence intervals for an array of n points x.; stride1 indicates the stride in the coordinate space while stride2 the stride in dimension space.; For 1-dim points : stride1=1, stride2=1; for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the array ci; cl is the desired confidedence interval value; norm is a flag to control if the intervals need to be normalized to the chi2/ndf value; By default the intervals are corrected using the chi2/ndf value of the fit if a chi2 fit is performed. void GetConfidenceIntervals(const ROOT::Fit::BinData& data, double* ci,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Fit__FitResult.html:9340,allocate,allocates,9340,root/html530/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html530/ROOT__Fit__FitResult.html,3,['allocate'],['allocates']
Energy Efficiency,"rs (Methods); public:. virtual~TGLFBO(); voidBind(); voidBindTexture(); static TClass*Class(); voidInit(int w, int h, int ms_samples = 0); virtual TClass*IsA() const; voidRelease(); voidSetAsReadBuffer(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLFBO(); voidUnbind(); voidUnbindTexture(). protected:. UInt_tCreateAndAttachColorTexture(); UInt_tCreateAndAttachRenderBuffer(Int_t format, Int_t type); voidInitMultiSample(); voidInitStandard(). private:. TGLFBO&operator=(const TGLFBO&); TGLFBO(const TGLFBO&). Data Members; protected:. UInt_tfColorTexture; UInt_tfDepthBuffer; UInt_tfFrameBuffer; Int_tfH; Float_tfHScale; Bool_tfIsRescaled; UInt_tfMSColorBuffer; Int_tfMSCoverageSamples; UInt_tfMSFrameBuffer; Int_tfMSSamples; Int_tfW; Float_tfWScale; static Bool_tfgMultiSampleNAWarned; static Bool_tfgRescaleToPow2. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLFBO(); Constructor. ~TGLFBO(); Destructor. void Init(int w, int h, int ms_samples = 0); Acquire GL resources for given width, height and number of; multi-sampling samples. void Release(); Release the allocated GL resources. void Bind(); Bind the frame-buffer object. void Unbind(); Unbind the frame-buffer object. void BindTexture(); Bind texture. void UnbindTexture(); Unbind texture. void SetAsReadBuffer(). void InitStandard(). void InitMultiSample(). UInt_t CreateAndAttachRenderBuffer(Int_t format, Int_t type). UInt_t CreateAndAttachColorTexture(); Initialize color-texture and attach it to current FB. TGLFBO(const TGLFBO& ). TGLFBO& operator=(const TGLFBO& ). » Author: Matevz Tadel, Aug 2009 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLFBO.html:1711,allocate,allocated,1711,root/html602/TGLFBO.html,https://root.cern,https://root.cern/root/html602/TGLFBO.html,1,['allocate'],['allocated']
Energy Efficiency,"rs ------. scalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+); Enable the product using any other LorentzVector implementing; the x(), y() , y() and t() member functions; \param q any LorentzVector implementing the x(), y() , z() and t(); member functions; \return the result of v.q of type according to the base scalar type of v. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html:19156,energy,energy,19156,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,1,['energy'],['energy']
Energy Efficiency,"rs ------. scalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+); Enable the product using any other LorentzVector implementing; the x(), y() , y() and t() member functions; \param q any LorentzVector implementing the x(), y() , z() and t(); member functions; \return the result of v.q of type according to the base scalar type of v. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html:17550,energy,energy,17550,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,1,['energy'],['energy']
Energy Efficiency,"rs, const RooFormulaVar* cutVar, const char* cutRange, int nStart, int nStop, Bool_t copyCache, const char* wgtVarName = 0); RooArgSetaddWgtVar(const RooArgSet& origVars, const RooAbsArg* wgtVar); Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); voidRooDirItem::appendToDir(TObject* obj, Bool_t forceMemoryResident = kFALSE); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); virtual RooAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); static voidcleanup(); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidinitialize(const char* wgtVarName); voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); voidRooDirItem::removeFromDir(TObject* obj); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataSet.html:16106,reduce,reduceEng,16106,root/html534/RooDataSet.html,https://root.cern,https://root.cern/root/html534/RooDataSet.html,1,['reduce'],['reduceEng']
Energy Efficiency,"rs.cxx:66. Performance considerations; To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible. For instance, Filter(""x > 0"") requires just-in-time compilation of the corresponding C++ logic, while the equivalent Filter([](float x) { return x > 0.; }, {""x""}) does not. Similarly, Histo1D(""x"") requires just-in-time compilation after the type of x is retrieved from the dataset, while Histo1D<float>(""x"") does not; the latter spelling should be preferred for performance-critical applications.; Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame. See Efficient analysis in Python for possible ways to speed up hot paths in this case.; Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations for all RDataFrame computation graphs before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs.; Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See Activating RDataFrame execution logs. Memory usage; There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies of the results are destroyed when the final result is produc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:50108,reduce,reduce,50108,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['reduce'],['reduce']
Energy Efficiency,"rse of a, a is unchanged; b = a.Invert();// invert a and set b = a; 17.3.6 Compound Rotations; The operator * has been implemented in a way that follows the mathematical notation of a product of the two matrices which describe the two consecutive rotations. Therefore, the second rotation should be placed first:; r = r2 * r1;; 17.3.7 Rotation of TVector3; The TRotation class provides an operator * which allows expressing a rotation of a TVector3 analog to the mathematical notation:; \[; \left|; \begin{array}{c}; x' \\; y' \\; z'; \end{array}; \right|; =; \left|; \begin{array}{ccc}; xx & xy & xz \\; yx & yy & yz \\; zx & zy & zz; \end{array}; \right|; \times; \left|; \begin{array}{c}; x \\; y \\; z; \end{array}; \right|; \]; TRotation r;; TVector3 v(1,1,1);; v = r * v;; You can also use the Transform() method or the operator *= of the TVector3 class:; TVector3 v;; TRotation r;; v.Transform(r);; 17.4 TLorentzVector; TLorentzVector is a general four-vector class, which can be used either for the description of position and time (x, y, z, t) or momentum and energy (px, py, pz, E).; 17.4.1 Declaration; TLorentzVector has been implemented as a set a TVector3 and a Double_t variable. By default, all components are initialized by zero.; TLorentzVector v1; // initialized by (0.,0.,0.,0.); TLorentzVector v2(1.,1.,1.,1.);; TLorentzVector v3(v1);; TLorentzVector v4(TVector3(1.,2.,3.),4.);; For backward compatibility there are two constructors from a Double_t and Float_t array.; 17.4.2 Access to Components; There are two sets of access functions to the components of a TLorentzVector: X(), Y(), Z(), T() and Px(), Py(), Pz() and E(). Both sets return the same values but the first set is more relevant for use where TLorentzVector describes a combination of position and time and the second set is more relevant where TLorentzVector describes momentum and energy:; Double_t xx =v.X();; ...; Double_t tt = v.T();; Double_t px = v.Px();; ...; Double_t ee = v.E();; The components of TLorentz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:866373,energy,energy,866373,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['energy'],['energy']
Energy Efficiency,"rse::FillExMap ; (; ). protected . We have been streamed; set up fBins. ; Definition at line 655 of file THnSparse.cxx. ◆ GenerateArray(). virtual TArray * THnSparse::GenerateArray ; (; ); const. protectedpure virtual . Implemented in THnSparseT< CONT >. ◆ GetBin() [1/6]. Long64_t THnSparse::GetBin ; (; const char * ; name[]); const. inlineoverridevirtual . Implements THnBase.; Definition at line 98 of file THnSparse.h. ◆ GetBin() [2/6]. Long64_t THnSparse::GetBin ; (; const char * ; name[], . Bool_t ; allocate = kTRUE . ). overridevirtual . Get the bin index for the n dimensional tuple addressed by ""name"", allocate one if it doesn't exist yet and ""allocate"" is true. ; Implements THnBase.; Definition at line 718 of file THnSparse.cxx. ◆ GetBin() [3/6]. Long64_t THnSparse::GetBin ; (; const Double_t * ; x); const. inlineoverridevirtual . Implements THnBase.; Definition at line 97 of file THnSparse.h. ◆ GetBin() [4/6]. Long64_t THnSparse::GetBin ; (; const Double_t * ; x, . Bool_t ; allocate = kTRUE . ). overridevirtual . Get the bin index for the n dimensional tuple x, allocate one if it doesn't exist yet and ""allocate"" is true. ; Implements THnBase.; Definition at line 702 of file THnSparse.cxx. ◆ GetBin() [5/6]. Long64_t THnSparse::GetBin ; (; const Int_t * ; idx); const. inlineoverridevirtual . Implements THnBase.; Definition at line 96 of file THnSparse.h. ◆ GetBin() [6/6]. Long64_t THnSparse::GetBin ; (; const Int_t * ; idx, . Bool_t ; allocate = kTRUE . ). overridevirtual . Get the bin index for the n dimensional coordinates coord, allocate one if it doesn't exist yet and ""allocate"" is true. ; Implements THnBase.; Definition at line 733 of file THnSparse.cxx. ◆ GetBinContent() [1/2]. Double_t THnSparse::GetBinContent ; (; const Int_t * ; idx); const. inline . Forwards to THnBase::GetBinContent() overload. ; Non-virtual, CINT-compatible replacement of a using declaration. ; Definition at line 121 of file THnSparse.h. ◆ GetBinContent() [2/2]. Double_t THnSparse::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnSparse.html:33731,allocate,allocate,33731,doc/master/classTHnSparse.html,https://root.cern,https://root.cern/doc/master/classTHnSparse.html,1,['allocate'],['allocate']
Energy Efficiency,"rse< Element >::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 215 of file TMatrixTSparse.h. ◆ Clear(). template<class Element > . void TMatrixTSparse< Element >::Clear ; (; Option_t * ; = """"). inlineoverridevirtual . Implements TMatrixTBase< Element >.; Definition at line 130 of file TMatrixTSparse.h. ◆ ColNorm(). template<class Element > . Element TMatrixTSparse< Element >::ColNorm. overridevirtual . Column matrix norm, MAX{ SUM{ |M(i,j)|, over i}, over j}. ; The norm is induced by the 1 vector norm. ; Reimplemented from TMatrixTBase< Element >.; Definition at line 2341 of file TMatrixTSparse.cxx. ◆ conservative_sparse_sparse_product_impl(). template<class Element > . void TMatrixTSparse< Element >::conservative_sparse_sparse_product_impl ; (; const TMatrixTSparse< Element > & ; lhs, . const TMatrixTSparse< Element > & ; rhs, . Int_t ; constr = 0 . ). protected . General Sparse Matrix Multiplication (SpMM). ; This code is an adaptation of Eigen SpMM implementation. This product is conservative, meaning that it preserves the symbolic non zeros. Given lhs, rhs, it computes this = rhs * lhs. Note, result matrix is only allocated when constr=1. ; Definition at line 552 of file TMatrixTSparse.cxx. ◆ DeclFileName(). template<class Element > . static const char * TMatrixTSparse< Element >::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 215 of file TMatrixTSparse.h. ◆ ExtractRow(). template<class Element > . void TMatrixTSparse< Element >::ExtractRow ; (; Int_t ; row, . Int_t ; col, . Element * ; v, . Int_t ; n = -1 . ); const. overridevirtual . Store in array v, n matrix elements of row rown starting at column coln. ; Reimplemented from TMatrixTBase< Element >.; Definition at line 509 of file TMatrixTSparse.cxx. ◆ GetColIndexArray() [1/2]. template<class Element > . const Int_t * TMatrixTSparse< Element >::GetColIndexArray. inlineoverridevirtual . Implements",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixTSparse.html:38891,adapt,adaptation,38891,doc/master/classTMatrixTSparse.html,https://root.cern,https://root.cern/doc/master/classTMatrixTSparse.html,1,['adapt'],['adaptation']
Energy Efficiency,"rsion_t Class_Version ();  ; static const char * DeclFileName ();  ; static Width_t GetMarkerLineWidth (Style_t style);  Internal helper function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  . Protected Member Functions;  TH1 ();  Histogram default constructor. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins);  Constructor for variable bin size histograms using an input array of type double. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Float_t *xbins);  Constructor for variable bin size histograms using an input array of type float. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup);  Constructor for fix bin size histograms. ;  ; virtual Int_t AutoP2FindLimits (Double_t min, Double_t max);  Buffer-based estimate of the histogram range using the power of 2 algorithm. ;  ; Int_t AxisChoice (Option_t *axis) const;  Choose an axis according to ""axis"". ;  ; virtual Int_t BufferFill (Double_t x, Double_t w);  accumulate arguments in buffer. ;  ; virtual void DoFillN (Int_t ntimes, const Double_t *x, const Double_t *w, Int_t stride=1);  Internal method to fill histogram content from a vector called directly by TH1::BufferEmpty. ;  ; virtual Double_t DoIntegral (Int_t ix1, Int_t ix2, Int_t iy1, Int_t iy2, Int_t iz1, Int_t iz2, Double_t &err, Option_t *opt, Bool_t doerr=kFALSE) const;  Internal function compute integral and optionally the error between the limits specified by the bin number values working for all histograms (1D, 2D and 3D) ;  ; virtual Bool_t FindNewAxisLimits (const TAxis *axis, const Double_t point, Double_t &newMin, Double_t &newMax);  finds new limits for the axis so that point is within the range and the limits are compatible with the previous ones (see TH1::Merg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:63680,power,power,63680,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['power'],['power']
Energy Efficiency,"rst FlushBaskets; TTree::Fill will replace fAutoFlush by the current value of fEntries. Calling this function with autof<0 is interesting when it is hard to estimate; the size of one entry. This value is also independent of the Tree. The Tree is initialized with fAutoFlush=-30000000, ie that, by default,; the first AutoFlush will be done when 30 MBytes of data are written to the file. CASE 3 : autof = 0. The AutoFlush mechanism is disabled. Flushing the buffers at regular intervals optimize the location of; consecutive entries on the disk. The value of autoflush determine a size in number of entries of; a cluster of baskets. If the value of autoflush is changed over time (this happens in; particular when fast merge files), we record the previous values; in the arrays fClusterRangeEnd and fClusterSize.; A range of entries where the size of the cluster of basket is; the same (i.e the value of AutoFlush was constant) is called; a ClusterRange. The 2 arrays have fNClusterRange active values and have; fMaxClusterRange allocated entries. fClusterRangeEnd contains the last entries number of a cluster range.; In particular this means that the 'next' cluster starts at fClusterRangeEnd[]+1; fClusterSize contains the size in number of entries of all the cluster; within the given range.; The last range (and the only one if fNClusterRange is zero) start at; fNClusterRange[fNClusterRange-1]+1 and ends at the end of the TTree. The; size of the cluster in this range is given by the value of fAutoFlush. For example printing the beginning and end of each the ranges can be done by:. Printf(""%-16s %-16s %-16s %5s"",; ""Cluster Range #"", ""Entry Start"", ""Last Entry"", ""Size"");; Int_t index= 0;; Long64_t clusterRangeStart = 0;; if (fNClusterRange) {; for( ; index < fNClusterRange; ++index) {; Printf(""%-16d %-16lld %-16lld %5lld"",; index, clusterRangeStart, fClusterRangeEnd[index], fClusterSize[index]);; clusterRangeStart = fClusterRangeEnd[index] + 1;; }; }; Printf(""%-16d %-16lld %-16lld %5ll",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:120640,allocate,allocated,120640,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,1,['allocate'],['allocated']
Energy Efficiency,"rt as numeric convolution calculated; this way is computationally intensive and prone to stability fitting problems. ; The preferred way to compute numeric convolutions is RooFFTConvPdf,; which calculates convolutions using Fourier Transforms (requires external free; FFTW3 package); ; RooNumConvPdf implements reasonable defaults that should convolve most; functions reasonably well, but results strongly depend on the shape of your; input PDFS so always check your result.; ; The default integration engine for the numeric convolution is the; adaptive Gauss-Kronrod method, which empirically seems the most robust; for this task. You can override the convolution integration settings via; the RooNumIntConfig object reference returned by the convIntConfig() member; function; ; By default the numeric convolution is integrated from -infinity to; +infinity through a x -> 1/x coordinate transformation of the; tails. For convolution with a very small bandwidth it may be; advantageous (for both CPU consumption and stability) if the; integration domain is limited to a finite range. The function; setConvolutionWindow(mean,width,scale) allows to set a sliding; window around the x value to be calculated taking a RooAbsReal; expression for an offset and a width to be taken around the x; value. These input expression can be RooFormulaVars or other; function objects although the 3d 'scale' argument 'scale'; multiplies the width RooAbsReal expression given in the 2nd; argument, allowing for an appropriate window definition for most; cases without need for a RooFormulaVar object: e.g. a Gaussian; resolution PDF do setConvolutionWindow(gaussMean,gaussSigma,5); Note that for a 'wide' Gaussian the -inf to +inf integration; may converge more quickly than that over a finite range!; ; The default numeric precision is 1e-7, i.e. the global default for; numeric integration but you should experiment with this value to; see if it is sufficient for example by studying the number of function; calls t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvPdf.html:1524,consumption,consumption,1524,root/html526/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html526/RooNumConvPdf.html,7,['consumption'],['consumption']
Energy Efficiency,"rt gets; 454 // allocated. We need to check whether the allowed chunk size is; 455 // bigger than the allocated size. If fCoordinateAllocationSize is; 456 // set to -1 this chunk has been allocated by the streamer and the; 457 // buffer allocation size is defined by [fCoordinatesSize]. In that; 458 // case we need to compare fCoordinatesSize to; 459 // fSingleCoordinateSize * fContent->GetSize(); 460 // to determine whether we need to expand the buffer.; 461 if (fCoordinateAllocationSize == -1 && fContent) {; 462 Int_t chunksize = fSingleCoordinateSize * fContent->GetSize();; 463 if (fCoordinatesSize < chunksize) {; 464 // need to re-allocate:; 465 Char_t *newcoord = new Char_t[chunksize];; 466 memcpy(newcoord, fCoordinates, fCoordinatesSize);; 467 delete [] fCoordinates;; 468 fCoordinates = newcoord;; 469 }; 470 fCoordinateAllocationSize = chunksize;; 471 }; 472 ; 473 memcpy(fCoordinates + idx * fSingleCoordinateSize, coordbuf, fSingleCoordinateSize);; 474 fCoordinatesSize += fSingleCoordinateSize;; 475}; 476 ; 477////////////////////////////////////////////////////////////////////////////////; 478/// Turn on support of errors; 479 ; 480void THnSparseArrayChunk::Sumw2(); 481{; 482 if (!fSumw2); 483 fSumw2 = new TArrayD(fContent->GetSize());; 484 // fill the structure with the current content; 485 for (Int_t bin=0; bin < fContent->GetSize(); bin++) {; 486 fSumw2->fArray[bin] = fContent->GetAt(bin);; 487 }; 488 ; 489}; 490 ; 491 ; 492/** \class THnSparse; 493 \ingroup Hist; 494 ; 495Efficient multidimensional histogram.; 496 ; 497Use a THnSparse instead of TH1 / TH2 / TH3 / array for histogramming when; 498only a small fraction of bins is filled. A 10-dimensional histogram with 10; 499bins per dimension has 10^10 bins; in a naive implementation this will not; 500fit in memory. THnSparse only allocates memory for the bins that have; 501non-zero bin content instead, drastically reducing both the memory usage; 502and the access time.; 503 ; 504To construct a THnSparse ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:16536,allocate,allocate,16536,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"rt of a type with regards to RNTuple I/O.; A new internal RNTupleMerger class has been added, enabling the merging of different page sources into one page sink. This also means that RNTuples can be merged through hadd.; Zero-copy bulk reading has been added, with extra optimizations for ROOT::RVec fields.; It is now possible to use the RNTupleView with an external address with type erasure, e.g.:; std::shared_ptr<void> data{new float()};; auto view = reader->GetView(""pt"", data);; This enables use cases such as reading one specific entry of one specific field into a previously allocated memory location.; Further integration with RDataFrame: it is now possible to create RDataFrame for chains of RNTuples. This addition also comes with improvements to the multi-threaded work scheduling.; Many additional bug fixes and improvements. Please, report any issues regarding the above mentioned features should you encounter them. RNTuple is still in pre-production. The on-disk format is scheduled to be finalized by the end of 2024. Thus, we appreciate feedback and suggestions for improvement.; Histogram Libraries. Implement the FLT_MAX mechanism for THStack::GetMaximum() and THStack::GetMiniumum().; Print a warning when the range given to TAxis::SetRange is invalid.; Fix projection name in TH3 as requested here. Parallelism. The ROOT::Experimental::TFuture template has been removed. RooFit Libraries; New CPU likelihood evaluation backend by default; The new vectorizing CPU evaluation backend is not the default for RooFit likelihoods. Likelihood minimization is now up to 10x faster on a single CPU core.; If you experience unexpected problems related to the likelihood evaluation, you can revert back to the old backend by passing RooFit::EvalBackend(""legacy"") to RooAbsPdf::fitTo() or RooAbsPdf::createNLL().; In case you observe any slowdowns with the new likelihood evaluation, please open a GitHub issue about this, as such a performance regression is considered a bug.; Asymptotical",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:7585,schedul,scheduled,7585,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['schedul'],['scheduled']
Energy Efficiency,"rth; 3585 case 111:; 3586 {; 3587 Double_t red[9] = { 0./255., 13./255., 30./255., 44./255., 72./255., 120./255., 156./255., 200./255., 247./255.};; 3588 Double_t green[9] = { 0./255., 36./255., 84./255., 117./255., 141./255., 153./255., 151./255., 158./255., 247./255.};; 3589 Double_t blue[9] = { 0./255., 94./255., 100./255., 82./255., 56./255., 66./255., 76./255., 131./255., 247./255.};; 3590 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3591 }; 3592 break;; 3593 ; 3594 // Viridis; 3595 case 112:; 3596 {; 3597 Double_t red[9] = { 26./255., 51./255., 43./255., 33./255., 28./255., 35./255., 74./255., 144./255., 246./255.};; 3598 Double_t green[9] = { 9./255., 24./255., 55./255., 87./255., 118./255., 150./255., 180./255., 200./255., 222./255.};; 3599 Double_t blue[9] = { 30./255., 96./255., 112./255., 114./255., 112./255., 101./255., 72./255., 35./255., 0./255.};; 3600 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3601 }; 3602 break;; 3603 ; 3604 // Cividis; 3605 case 113:; 3606 {; 3607 Double_t red[9] = { 0./255., 5./255., 65./255., 97./255., 124./255., 156./255., 189./255., 224./255., 255./255.};; 3608 Double_t green[9] = { 32./255., 54./255., 77./255., 100./255., 123./255., 148./255., 175./255., 203./255., 234./255.};; 3609 Double_t blue[9] = { 77./255., 110./255., 107./255., 111./255., 120./255., 119./255., 111./255., 94./255., 70./255.};; 3610 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3611 }; 3612 break;; 3613 ; 3614 default:; 3615 ::Error(""SetPalette"", ""Unknown palette number %d"", ncolors);; 3616 return;; 3617 }; 3618 paletteType = ncolors;; 3619 if (Idx>0) fgPalettesList.fArray[paletteType-51] = (Double_t)Idx;; 3620 else fgPalettesList.fArray[paletteType-51] = 0.;; 3621 if (alpha > 0.) fgPalettesList.fArray[paletteType-51] += alpha/10.0f;; 3622 return;; 3623 }; 3624 ; 3625 // set user defined palette; 3626 if (colors) {; 3627 fgPalette.Set(ncolors);; 36",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:143839,green,green,143839,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"rtual . List the TStreamerElement list and also the precomputed tables if option contains the string ""incOrig"", also prints the original (non-optimized elements in the list of compiled elements. ; Implements TVirtualStreamerInfo.; Definition at line 4684 of file TStreamerInfo.cxx. ◆ MatchLegacyCheckSum(). Bool_t TStreamerInfo::MatchLegacyCheckSum ; (; UInt_t ; checksum); const. Return true if the checksum passed as argument is one of the checksum value produced by the older checksum calculation algorithm. ; Definition at line 3270 of file TStreamerInfo.cxx. ◆ New(). void * TStreamerInfo::New ; (; void * ; obj = nullptr). overridevirtual . An emulated object is created at address obj, if obj is null we allocate memory for the object. ; Implements TVirtualStreamerInfo.; Definition at line 4769 of file TStreamerInfo.cxx. ◆ NewArray(). void * TStreamerInfo::NewArray ; (; Long_t ; nElements, . void * ; ary = nullptr . ). overridevirtual . An array of emulated objects is created at address ary, if ary is null, we allocate memory for the array. ; Implements TVirtualStreamerInfo.; Definition at line 4918 of file TStreamerInfo.cxx. ◆ NewInfo(). TVirtualStreamerInfo * TStreamerInfo::NewInfo ; (; TClass * ; cl). inlineoverridevirtual . Implements TVirtualStreamerInfo.; Definition at line 198 of file TStreamerInfo.h. ◆ operator=(). TStreamerInfo & TStreamerInfo::operator= ; (; const TStreamerInfo & ; ). privatedelete . ◆ PrintValue(). void TStreamerInfo::PrintValue ; (; const char * ; name, . char * ; pointer, . Int_t ; i, . Int_t ; len, . Int_t ; lenmax = 1000 . ); const. print value of element i in object at pointer The function may be called in two ways: -method1 len < 0 i is assumed to be the TStreamerElement number i in StreamerInfo -method2 len >= 0 i is the type address of variable is directly pointer. ; len is the number of elements to be printed starting at pointer. ; Definition at line 5159 of file TStreamerInfo.cxx. ◆ PrintValueAux(). void TStreamerInfo::PrintValueAu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerInfo.html:60313,allocate,allocate,60313,doc/master/classTStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTStreamerInfo.html,1,['allocate'],['allocate']
Energy Efficiency,"rtual, CINT-compatible replacement of a using declaration. ; Definition at line 121 of file THnSparse.h. ◆ GetBinContent() [2/2]. Double_t THnSparse::GetBinContent ; (; Long64_t ; idx, . Int_t * ; coord = nullptr . ); const. overridevirtual . Return the content of the filled bin number ""idx"". ; If coord is non-null, it will contain the bin's coordinates for each axis that correspond to the bin. ; Implements THnBase.; Definition at line 744 of file THnSparse.cxx. ◆ GetBinError2(). Double_t THnSparse::GetBinError2 ; (; Long64_t ; linidx); const. overridevirtual . Get square of the error of bin addressed by linidx as \(\sum weight^{2}\) If errors are not enabled (via Sumw2() or CalculateErrors()) return contents. ; Implements THnBase.; Definition at line 771 of file THnSparse.cxx. ◆ GetBinIndexForCurrentBin(). Long64_t THnSparse::GetBinIndexForCurrentBin ; (; Bool_t ; allocate). protected . Return the index for fCurrentBinIndex. ; If it doesn't exist then return -1, or allocate a new bin if allocate is set ; Definition at line 789 of file THnSparse.cxx. ◆ GetChunk(). THnSparseArrayChunk * THnSparse::GetChunk ; (; Int_t ; idx); const. inlineprotected . Definition at line 56 of file THnSparse.h. ◆ GetChunkSize(). Int_t THnSparse::GetChunkSize ; (; ); const. inline . Definition at line 88 of file THnSparse.h. ◆ GetCompactCoord(). THnSparseCompactBinCoord * THnSparse::GetCompactCoord ; (; ); const. protected . Return THnSparseCompactBinCoord object. ; Definition at line 838 of file THnSparse.cxx. ◆ GetNbins(). Long64_t THnSparse::GetNbins ; (; ); const. inlineoverridevirtual . Implements THnBase.; Definition at line 93 of file THnSparse.h. ◆ GetNChunks(). Int_t THnSparse::GetNChunks ; (; ); const. inline . Definition at line 89 of file THnSparse.h. ◆ GetSparseFractionBins(). Double_t THnSparse::GetSparseFractionBins ; (; ); const. Return the amount of filled bins over all bins. ; Definition at line 854 of file THnSparse.cxx. ◆ GetSparseFractionMem(). Double_t THnSparse::Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnSparse.html:35566,allocate,allocate,35566,doc/master/classTHnSparse.html,https://root.cern,https://root.cern/doc/master/classTHnSparse.html,2,['allocate'],['allocate']
Energy Efficiency,"rtualCollectionProxy *cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const;  ; TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions (Bool_t forCollection);  ; TStreamerInfoActions::TActionSequence * GetWriteObjectWiseActions ();  ; TStreamerInfoActions::TActionSequence * GetWriteTextActions ();  ; TClass * IsA () const override;  ; void ls (Option_t *option="""") const override;  List the TStreamerElement list and also the precomputed tables if option contains the string ""incOrig"", also prints the original (non-optimized elements in the list of compiled elements. ;  ; Bool_t MatchLegacyCheckSum (UInt_t checksum) const;  Return true if the checksum passed as argument is one of the checksum value produced by the older checksum calculation algorithm. ;  ; void * New (void *obj=nullptr) override;  An emulated object is created at address obj, if obj is null we allocate memory for the object. ;  ; void * NewArray (Long_t nElements, void *ary=nullptr) override;  An array of emulated objects is created at address ary, if ary is null, we allocate memory for the array. ;  ; TVirtualStreamerInfo * NewInfo (TClass *cl) override;  ; void PrintValue (const char *name, char *pointer, Int_t i, Int_t len, Int_t lenmax=1000) const;  print value of element i in object at pointer The function may be called in two ways: -method1 len < 0 i is assumed to be the TStreamerElement number i in StreamerInfo -method2 len >= 0 i is the type address of variable is directly pointer. ;  ; void PrintValueClones (const char *name, TClonesArray *clones, Int_t i, Int_t eoffset, Int_t lenmax=1000) const;  Print value of element i in a TClonesArray. ;  ; void PrintValueSTL (const char *name, TVirtualCollectionProxy *cont, Int_t i, Int_t eoffset, Int_t lenmax=1000) const;  Print value of element i in a TClonesArray. ;  ; template<class T > ; Int_t ReadBuffer (TBuffer &b, const T &arrptr, TCompInfo *const *const compinfo, Int_t first, Int_t last, Int_t narr=1, Int_t eoffset=0, Int_t mode=0);  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerInfo.html:11166,allocate,allocate,11166,doc/master/classTStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTStreamerInfo.html,1,['allocate'],['allocate']
Energy Efficiency,"ructure associated to color index cid. ;  ; void * GetGC (Int_t which) const;  Return desired Graphics Context (""which"" maps directly on gGCList[]). ;  ; void QueryColors (Colormap cmap, RXColor *colors, Int_t ncolors);  Returns the current RGB value for the pixel in the XColor structure. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; ULong_t fBlackPixel;  Value of black pixel in colormap. ;  ; Int_t fBlueDiv;  Blue value divider. ;  ; Int_t fBlueShift;  Bits to left shift blue. ;  ; Float_t fCharacterUpX;  Character Up vector along X. ;  ; Float_t fCharacterUpY;  Character Up vector along Y. ;  ; Colormap fColormap;  Default colormap, 0 if b/w. ;  ; Int_t fDepth;  Number of color planes. ;  ; void * fDisplay;  Pointer to display. ;  ; Int_t fGreenDiv;  Green value divider. ;  ; Int_t fGreenShift;  Bits to left shift green. ;  ; Bool_t fHasTTFonts;  True when TrueType fonts are used. ;  ; Bool_t fHasXft;  True when XftFonts are used. ;  ; Int_t fRedDiv;  Red value divider, -1 if no TrueColor visual. ;  ; Int_t fRedShift;  Bits to left shift red, -1 if no TrueColor visual. ;  ; Drawable fRootWin;  Root window used as parent of all windows. ;  ; Int_t fScreenNumber;  Screen number. ;  ; Int_t fTextAlign;  Text alignment (set in SetTextAlign) ;  ; Int_t fTextAlignH;  Text Alignment Horizontal. ;  ; Int_t fTextAlignV;  Text Alignment Vertical. ;  ; Float_t fTextMagnitude;  Text Magnitude. ;  ; Drawable fVisRootWin;  Root window with fVisual to be used to create GC's and XImages. ;  ; RVisual * fVisual;  Pointer to visual used by all windows. ;  ; ULong_t fWhitePixel;  Value of white pixel in colormap. ;  ;  Protected Attributes inherited from TVirtualX; EDrawMode fDrawMode;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inhe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGX11.html:47213,green,green,47213,doc/master/classTGX11.html,https://root.cern,https://root.cern/doc/master/classTGX11.html,1,['green'],['green']
Energy Efficiency,"rue; ds2 = ROOT.RooDataSet(""ds2"", ""ds2"", {x, y, z}, Import=tree, Cut=""y+z<0""); ds2.Print(); ; # Importing integer ROOT TTree branches; # ---------------------------------------------------------------; ; # Import integer tree branch as ROOT.RooRealVar; i = ROOT.RooRealVar(""i"", ""i"", 0, 5); ds3 = ROOT.RooDataSet(""ds3"", ""ds3"", {i, x}, Import=tree); ds3.Print(); ; # Define category i; icat = ROOT.RooCategory(""i"", ""i"", {""State0"": 0, ""State1"": 1}); ; # Import integer tree branch as ROOT.RooCategory (only events with i==0 and i==1; # will be imported as those are the only defined states); ds4 = ROOT.RooDataSet(""ds4"", ""ds4"", {icat, x}, Import=tree); ds4.Print(); ; # Import multiple RooDataSets into a RooDataSet; # ----------------------------------------------------------------------------------------; ; # Create three ROOT.RooDataSets in (y,z); dsA = ds2.reduce({x, y}, ""z<-5""); dsB = ds2.reduce({x, y}, ""abs(z)<5""); dsC = ds2.reduce({x, y}, ""z>5""); ; # Create a dataset that imports contents of all the above datasets mapped; # by index category c; dsABC = ROOT.RooDataSet(""dsABC"", ""dsABC"", {x, y}, Index=c, Import={""SampleA"": dsA, ""SampleB"": dsB, ""SampleC"": dsC}); ; dsABC.Print(); RooDataHist::dh[c,x] = 300 bins (2964 weights); RooDataHist::dh[c,x] = 300 bins (2964 weights); [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 35 out-of-range events; RooDataSet::ds[x,y] = 65 entries; [#1] INFO:D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf401__importttreethx_8py.html:3527,reduce,reduce,3527,doc/master/rf401__importttreethx_8py.html,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8py.html,1,['reduce'],['reduce']
Energy Efficiency,"ry call Update() also whenever the mapped object(s) change(s) call Update() to put a fresh copy in the shared memory. This extra step is necessary since it is not possible to share objects with virtual pointers between processes (the vtbl ptr points to the originators unique address space and can not be used by the consumer process(es)). Consumer processes can map the memory region from this file and access the objects stored in it via the Get() method (which returns a copy of the object stored in the shared memory with correct vtbl ptr set). Only objects of classes with a Streamer() member function defined can be shared.; I know the current implementation is not ideal (you need to copy to and from the shared memory file) but the main problem is with the class' virtual_table pointer. This pointer points to a table unique for every process. Therefore, different options are:; One could allocate an object directly in shared memory in the producer, but the consumer still has to copy the object from shared memory into a local object which has the correct vtbl pointer for that process (copy ctor's can be used for creating the local copy).; Another possibility is to only allow objects without virtual functions in shared memory (like simple C structs), or to forbid (how?) the consumer from calling any virtual functions of the objects in shared memory.; A last option is to copy the object internals to shared memory and copy them again from there. This is what is done in the TMapFile (using the object Streamer() to make a deep copy). Option 1) saves one copy, but requires solid copy ctor's (along the full inheritance chain) to rebuild the object in the consumer. Most classes don't provide these copy ctor's, especially not when objects contain collections, etc. 2) is too limiting or dangerous (calling accidentally a virtual function will segv). So since we have a robust Streamer mechanism I opted for 3). ; Definition at line 26 of file TMapFile.h. Public Types; enum  { kDefault",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMapFile.html:1513,allocate,allocate,1513,doc/master/classTMapFile.html,https://root.cern,https://root.cern/doc/master/classTMapFile.html,1,['allocate'],['allocate']
Energy Efficiency,"ry result. void ShowQueries(Option_t* opt = """"); Ask the master for the list of queries.; Options:; ""A"" show information about all the queries known to the; server, i.e. even those processed by other sessions; ""L"" show only information about queries locally available; i.e. already retrieved. If ""L"" is specified, ""A"" is; ignored.; ""F"" show all details available about queries; ""H"" print help menu; Default """". Bool_t IsDataReady(Long64_t& totalbytes, Long64_t& bytesready); See if the data is ready to be analyzed. void Interrupt(TProof::EUrgent type, TProof::ESlaves list = kActive); Send interrupt to master or slave servers. Int_t GetParallel() const; Returns number of slaves active in parallel mode. Returns 0 in case; there are no active slaves. Returns -1 in case of error. TList * GetListOfSlaveInfos(); Returns list of TSlaveInfo's. In case of error return 0. void Activate(TList* slaves = 0); Activate slave server list. void SetMonitor(TMonitor* mon = 0, Bool_t on = kTRUE); Activate (on == TRUE) or deactivate (on == FALSE) all sockets; monitored by 'mon'. Int_t BroadcastGroupPriority(const char* grp, Int_t priority, TList* workers); Broadcast the group priority to all workers in the specified list. Returns; the number of workers the message was successfully sent to.; Returns -1 in case of error. Int_t BroadcastGroupPriority(const char* grp, Int_t priority, TProof::ESlaves list = kAllUnique); Broadcast the group priority to all workers in the specified list. Returns; the number of workers the message was successfully sent to.; Returns -1 in case of error. void ResetMergePrg(); Reset the merge progress notificator. Int_t Broadcast(const TMessage& mess, TList* slaves); Broadcast a message to all slaves in the specified list. Returns; the number of slaves the message was successfully sent to.; Returns -1 in case of error. Int_t Broadcast(const TMessage& mess, TProof::ESlaves list = kActive); Broadcast a message to all slaves in the specified list (either; all slaves or on",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:38307,monitor,monitored,38307,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,6,['monitor'],['monitored']
Energy Efficiency,"ry(0);; Double_t params[4];; for (i = 0; i < background->GetEntries(); i++) {; background->GetEntry(i);; params[0] = msumf; params[1] = ptsumf;; params[2] = acolin; params[3] = acopl;; bg->Fill(mlp->Evaluate(0,params));; }; for (i = 0; i < signal->GetEntries(); i++) {; signal->GetEntry(i);; params[0] = msumf;; params[1] = ptsumf;; params[2] = acolin;; params[3] = acopl;; sig->Fill(mlp->Evaluate(0,params));; }; TCanvas *cv = new TCanvas(""NNout_cv"",""Neural net output"");; bg->SetFillStyle(3008);; bg->SetFillColor(kBlue);; sig->SetFillStyle(3003);; sig->SetFillColor(kRed);; bg->SetStats(0);; sig->SetStats(0);; bg->Draw();; sig->Draw(""same"");; TLegend *legend = new TLegend(.75,.80,.95,.95);; legend->AddEntry(bg,""Background(WW)"");; legend->AddEntry(sig,""Signal(Higgs)"");; legend->Draw();; The neural net output is then used to display the final difference between background and signal events. The figure “The neural net output” shows this plot. The neural net output. As it can be seen, this is a quite efficient technique. As mentioned earlier, neural networks are also used for fitting function. For some application with a cylindrical symmetry, a magnetic field simulation gives as output the angular component of the potential vector A, as well as the radial and z components of the B field.; One wants to fit those distributions with a function in order to plug them into the Geant simulation code. Polynomial fits could be tried, but it seems difficult to reach the desired precision over the full range. One could also use a spline interpolation between known points. In all cases, the resulting field would not be C-infinite.; An example of output (for Br) is shown. First the initial function can be seen as the target. Then, the resulting (normalized) neural net output. In order to ease the learning, the “normalize output” was used here. The initial amplitude can be recovered by multiplying by the original RMS and then shifting by the original mean. The original and the neural net",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:240596,efficient,efficient,240596,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['efficient'],['efficient']
Energy Efficiency,"ry; RooRealIntegral Real-valued function representing an integral over a RooAbsReal object; RooRealMPFE Multi-process front-end for parallel calculation of a real valued function ; RooRealProxy Proxy for a RooAbsReal object; RooRealSumPdf PDF constructed from a sum of (non-pdf) functions; RooRealVar Real-valued variable ; RooRealVarSharedProperties Shared properties of a RooRealVar clone set; RooRecursiveFraction Recursive fraction formula f1*(1-f2)*(1-f3) etc...; RooRefArray Helper class for proxy lists; RooRefCountList RooLinkedList with reference counting; RooResolutionModel Abstract Resolution Model; RooScaledFunc Function binding applying scaling to another function binding; RooSecondMoment Representation of moment in a RooAbsReal in a given RooRealVar; RooSegmentedIntegrator1D 1-dimensional piece-wise numerical integration engine; RooSegmentedIntegrator2D 2-dimensional piece-wise numerical integration engine; RooSentinel ; RooSetPair Utility class holding a pair of RooArgSet pointers; RooSetProxy Proxy class for a RooArgSet; RooSharedProperties Abstract interface for shared property implementations; RooSharedPropertiesList Manager for shared properties among clones of certain RooAbsArg-derived types; RooSimGenContext Context for efficiently generating a dataset from a RooSimultaneous PDF; RooSimPdfBuilder RooSimultaneous PDF Builder (obsolete); RooSimSplitGenContext Context for efficiently generating a dataset from a RooSimultaneous PDF; RooSimWSTool Workspace oriented tool for customized cloning of p.d.f. into a simultaneous p.d.f; RooSimWSTool::BuildConfig Build configuration object for RooSimWSTool; RooSimWSTool::MultiBuildConfig Build configuration object for RooSimWSTool with multiple prototype p.d.f.; RooSimWSTool::ObjBuildConfig Validated RooSimWSTool build configuration; RooSimWSTool::ObjSplitRule Validated RooSimWSTool split rule; RooSimWSTool::SplitRule Split rule specification for prototype p.d.f; RooSimultaneous Simultaneous operator p.d.f, functio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:43900,efficient,efficiently,43900,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,2,['efficient'],['efficiently']
Energy Efficiency,"ryTLegendEntry * AddEntry(const TObject *obj, const char *label="""", Option_t *option=""lpf"")Add a new entry to this legend.Definition TLegend.cxx:320; TLegend::SetNColumnsvoid SetNColumns(Int_t nColumns)Set the number of columns for the legend.Definition TLegend.cxx:606; TLegend::Drawvoid Draw(Option_t *option="""") overrideDraw this legend with its current attributes.Definition TLegend.cxx:425; TLegend::SetHeadervirtual void SetHeader(const char *header="""", Option_t *option="""")Sets the header, which is the ""title"" that appears at the top of the legend.Definition TLegend.cxx:1085; TLegend::DeleteEntryvirtual void DeleteEntry()Delete entry at the mouse position.Definition TLegend.cxx:413; TLegend::GetEntryTLegendEntry * GetEntry() constGet entry pointed to by the mouse.Definition TLegend.cxx:478; TLegend::Clearvoid Clear(Option_t *option="""") overrideClear all entries in this legend, including the header.Definition TLegend.cxx:379; TLegend::fEntrySeparationFloat_t fEntrySeparationSeparation between entries, as a fraction of The space allocated to one entry.Definition TLegend.h:74; TLegend::EditEntryAttMarkervirtual void EditEntryAttMarker()Edit the marker attributes for the entry pointed by the mouse.Definition TLegend.cxx:455; TLegend::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave this legend as C++ statements on output stream out to be used with the SaveAs ....Definition TLegend.cxx:1035; TLegend::EditEntryAttTextvirtual void EditEntryAttText()Edit the text attributes for the entry pointed by the mouse.Definition TLegend.cxx:466; TLegend::Paintvoid Paint(Option_t *option="""") overridePaint this legend with its current attributes.Definition TLegend.cxx:561; TLegend::GetNColumnsInt_t GetNColumns() constDefinition TLegend.h:52; TLegend::SetDefaultsvoid SetDefaults()Definition TLegend.h:61; TLegend::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideReset the legend entries pointing to ""obj"".Definition TLegend.cxx:1022; TLegend:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLegend_8cxx_source.html:48484,allocate,allocated,48484,doc/master/TLegend_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"r ; e . ). inline . Constructor from x, y , z , t values. ; Definition at line 62 of file PxPyPzE4D.h. ◆ PxPyPzE4D() [3/4]. template<class ScalarType = double> . template<class CoordSystem > . constexpr ROOT::Math::PxPyPzE4D< ScalarType >::PxPyPzE4D ; (; const CoordSystem & ; v). inlineexplicitconstexpr . construct from any vector or coordinate system class implementing x(), y() and z() and t() ; Definition at line 71 of file PxPyPzE4D.h. ◆ PxPyPzE4D() [4/4]. template<class ScalarType = double> . ROOT::Math::PxPyPzE4D< ScalarType >::PxPyPzE4D ; (; const PxPyPzE4D< ScalarType > & ; v). inline . copy constructor ; Definition at line 79 of file PxPyPzE4D.h. Member Function Documentation. ◆ E(). template<class ScalarType = double> . Scalar ROOT::Math::PxPyPzE4D< ScalarType >::E ; (; ); const. inline . Definition at line 124 of file PxPyPzE4D.h. ◆ Et(). template<class ScalarType = double> . Scalar ROOT::Math::PxPyPzE4D< ScalarType >::Et ; (; ); const. inline . transverse energy ; Definition at line 214 of file PxPyPzE4D.h. ◆ Et2(). template<class ScalarType = double> . Scalar ROOT::Math::PxPyPzE4D< ScalarType >::Et2 ; (; ); const. inline . transverse energy squared ; Definition at line 205 of file PxPyPzE4D.h. ◆ Eta(). template<class ScalarType = double> . Scalar ROOT::Math::PxPyPzE4D< ScalarType >::Eta ; (; ); const. inline . pseudorapidity ; Definition at line 233 of file PxPyPzE4D.h. ◆ GetCoordinates() [1/2]. template<class ScalarType = double> . void ROOT::Math::PxPyPzE4D< ScalarType >::GetCoordinates ; (; Scalar & ; px, . Scalar & ; py, . Scalar & ; pz, . Scalar & ; e . ); const. inline . get internal data into 4 Scalar numbers ; Definition at line 114 of file PxPyPzE4D.h. ◆ GetCoordinates() [2/2]. template<class ScalarType = double> . void ROOT::Math::PxPyPzE4D< ScalarType >::GetCoordinates ; (; Scalar ; dest[]); const. inline . get internal data into an array of 4 Scalar numbers ; Definition at line 102 of file PxPyPzE4D.h. ◆ M(). template<class ScalarType = doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1PxPyPzE4D.html:5320,energy,energy,5320,doc/master/classROOT_1_1Math_1_1PxPyPzE4D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1PxPyPzE4D.html,1,['energy'],['energy']
Energy Efficiency,"s !"");; 49 ret = 0;; 50 }; 51 }; 52 else return (0); /* if there are no points, return back */; 53 ; 54 ; 55 ; 56 /*; 57 * Allocate memory for colors; 58 */; 59 ; 60 colors = (Color *) calloc(28+4, sizeof (Color));; 61 if(!colors) {; 62 puts (""Unable to allocate memory for colors !"");; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/X3DBuffer_8c_source.html:2330,green,green,2330,doc/master/X3DBuffer_8c_source.html,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html,1,['green'],['green']
Energy Efficiency,"s ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  ;  Static Public Member Functions inherited from TGWidget; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; void AllocColors ();  Try to allocate first a palette of 64 colors. ;  ; void CreateDitheredImage (Pixmap_t image, Int_t which);  Create a dithered version of the color map and lightness images for display modes with reduced number of colors. ;  ; void CreateImages ();  Create colormap and color slider images. ;  ; void DoRedraw () override;  Redraw the color pick widget. ;  ; void DrawHScursor (Int_t onoff);  Draw hue / saturation cursor. ;  ; void DrawLcursor (Int_t onoff);  Draw lightness slider cursor. ;  ; void FreeColors ();  Free allocated colors. ;  ; void InitImages ();  Initialize color palette and slider images. ;  ; void SetHScursor (Int_t x, Int_t y);  Set hue / saturation cursor position. ;  ; void SetLcursor (Int_t z);  Set lightness slider cursor position. ;  ; void SetSliderColor ();  Set slider colors. ;  ; void UpdateCurrentColor ();  Assign the current cursor position as currently selected color. ;  ;  Protected Member Functions inherited from TGFrame; void DoRedraw () override;  Redraw the frame. ;  ; virtual void Draw3dRectangle (UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h);  Draw 3D rectangle on the frame border. ;  ; TString GetOptionString () const;  Returns a frame option string - used in SavePrimitive(). ;  ; const TGResourcePool * GetResourcePool () const;  ; void * GetSender () override;  ; virtual void StartGuiBuilding (Bool_t on=kTRUE);  Go into GUI building mode. ;  ;  Protected Member Functions inherited from TGWindow;  TGWindow (const TGWindow &tgw);  ;  TGWindow (Window_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGColorPick.html:23252,allocate,allocated,23252,doc/master/classTGColorPick.html,https://root.cern,https://root.cern/doc/master/classTGColorPick.html,1,['allocate'],['allocated']
Energy Efficiency,"s (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y; A: migration matrix (dimension ny x nx); x: unknown underlying distribution (dimension nx). Regularisation. tau: parameter, defining the regularisation strength; L: matrix of regularisation conditions (dimension nl x nx); x0: bias distribution. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. and chi**2 is minimized; (a) not constrained: minimisation is performed a function of x for fixed lambda=0; or; (b) constrained: minimisation is performed a function of x and lambda. This applies to a very large number of problems, where the measured; distribution y is a linear superposition of several Monte Carlo shapes; and the sum of these shapes gives the output distribution x. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documentation is available here:; http://www.desy.de/~sschmitt. References:. A nice overview of the method is given in:; The L-curve and Its Use in the Numerical Treatment of Inverse Problems; (2000) by P. C. Hansen, in Computational Inverse Problems in; Electrocardiology, ed. P. Johnston,; Advances in Computational Bioengineering; http://www.imm.dtu.dk/~pch/TR/Lcurve.ps; The relevant equations are (1), (2) for the unfolding; and (14) for the L-curve curvature definition. Related literature on unfolding",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfold.html:1428,reduce,reduce,1428,root/html528/TUnfold.html,https://root.cern,https://root.cern/root/html528/TUnfold.html,3,['reduce'],['reduce']
Energy Efficiency,s . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation Interfacing ROOT and Spark. Presently two ways are available to exploit the widely adopted Spark technology for carrying out ROOT based data analysis:. PyROOTSpark : offers the possibility to use a simple map reduce interface to run existing root code with a few changes on Spark resources. The key is to use the PyROOT inteface in combination with PySpark.; Spark-ROOT : offers the possibility to read ROOT files connecting the format directly to Spark's DataFrames/Datasets/RDDs. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/interfacing-root-and-spark.html:2086,reduce,reduce,2086,d/interfacing-root-and-spark.html,https://root.cern,https://root.cern/d/interfacing-root-and-spark.html,1,['reduce'],['reduce']
Energy Efficiency,"s ; // for each data subset designated by C states; RooSimultaneous* simPdf = builder.buildPdf(*config,&D) ;; . The above snippet of code demonstrates the concept of RooSimPdfBuilder:; the user defines a single 'prototype' PDF that defines the structure of all; PDF components of the RooSimultaneous PDF to be built. RooSimPdfBuilder ; then takes this prototype and replicates it as a component ; PDF for each state of the C index category.; . In the above example RooSimPdfBuilder; will first replicate k and s into ; k_C1,k_C2 and s_C1,s_C2, as prescribed in the; configuration. Then it will recursively replicate all PDF nodes that depend on; the 'split' parameter nodes: gauss into gauss_C1,C2, argus ; into argus_C1,C2 and finally pdf into pdf_C1,pdf_C2. ; When PDFs for all states of C have been replicated; they are assembled into a RooSimultaneous PDF, which is returned by the buildPdf(); method.; . Although in this very simple example the use of RooSimPdfBuilder doesn't; reduce the amount of code much, it is already easier to read and maintain; because there is no duplicate code. As the complexity of the RooSimultaneous; to be built increases, the advantages of RooSimPdfBuilder will become more and; more apparent.; ; Builder configuration rules for a single prototype PDF. Each builder configuration needs at minumum two lines, physModels and splitCats, which identify; the ingredients of the build. In this section we only explain the building rules for; builds from a single prototype PDF. In that case the physModels line always reads; . physModels = {pdfName}; . The second line, splitCats, indicates which categories are going to be used to ; differentiate the various subsets of the 'master' input data set. You can enter; a single category here, or multiple if necessary:; . splitCats = {catName} [{catName} ...]; . All listed splitcats must be RooCategories that appear in the dataset provided to; RooSimPdfBuilder::buildPdf(). The parameter splitting prescriptions, the essen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimPdfBuilder.html:3940,reduce,reduce,3940,root/html526/RooSimPdfBuilder.html,https://root.cern,https://root.cern/root/html526/RooSimPdfBuilder.html,7,['reduce'],['reduce']
Energy Efficiency,"s ; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance ; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorOneDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegratorOneDimOptions(IOptions * extraOpts = 0); constructor using the default options; can pass a pointer to extra options (N.B. pointer will be managed by the class). virtual ~IntegratorOneDimOptions(); {}. IntegratorOneDimOptions(const IntegratorOneDimOptions & rhs); copy constructor. {}. void SetNPoints(unsigned int n); specific method for one-dim; set number of points rule; values of 1,2,3,4,5,6 corresponds to 15,21,31,41,51,61 and they are used in GSL adaptive; values > 6 corresponds to the actual points and they are used by teh GaussLegendre integrator. { fNCalls = n; }. unsigned int NPoints() const; maximum number of function calls. { return fNCalls; }. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultIntegrator(const char* name); static methods for setting and retrieving the default options. void SetDefaultAbsTolerance(double tol). void SetDefaultRelTolerance(double tol). void SetDefaultWKSize(unsigned int size). void SetDefaultNPoints(unsigned int n). std::string DefaultIntegrator(). IntegrationOneDim::Type DefaultIntegratorType(). double DefaultAbsTolerance(). double DefaultRelTolerance(). unsigned int DefaultWKSize(). unsigned int DefaultNPoints(). ROOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorOneDimOptions.html:3667,adapt,adaptive,3667,root/html528/ROOT__Math__IntegratorOneDimOptions.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorOneDimOptions.html,4,['adapt'],['adaptive']
Energy Efficiency,"s = NULL;; 37 colors = NULL;; 38 segs = NULL;; 39 polys = NULL;; 40 ; 41 /*; 42 * Allocate memory for points; 43 */; 44 ; 45 if (gSize3D.numPoints) {; 46 points = (point *) calloc(gSize3D.numPoints, sizeof (point));; 47 if (!points) {; 48 puts (""Unable to allocate memory for points !"");; 49 ret = 0;; 50 }; 51 }; 52 else return (0); /* if there are no points, return back */; 53 ; 54 ; 55 ; 56 /*; 57 * Allocate memory for colors; 58 */; 59 ; 60 colors = (Color *) calloc(28+4, sizeof (Color));; 61 if(!colors) {; 62 puts (""Unable to allocate memory for colors !"");; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/X3DBuffer_8c_source.html:2049,green,green,2049,doc/master/X3DBuffer_8c_source.html,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html,1,['green'],['green']
Energy Efficiency,"s [saved to weight file]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName); standard constructor. ~VariableTransformBase(). void SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); select the variables/targets/spectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<const TMVA::Event*>& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName). void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*>& ). const Event* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__VariableTransformBase.html:10460,adapt,adapt,10460,root/html602/TMVA__VariableTransformBase.html,https://root.cern,https://root.cern/root/html602/TMVA__VariableTransformBase.html,2,['adapt'],['adapt']
Energy Efficiency,"s an essential part of the `TH2Poly`; 104class. It is implemented to speed up the filling of bins.; 105 ; 106With the brute force approach, the filling is done in the following way: An; 107iterator loops over all bins in the `TH2Poly` and invokes the; 108method `IsInside()` for each of them.; 109This method checks if the input location is in that bin. If the filling; 110coordinate is inside, the bin is filled. Looping over all the bin is; 111very slow.; 112 ; 113The alternative is to divide the histogram into virtual rectangular regions; 114called ""cells"". Each cell stores the pointers of the bins intersecting it.; 115When a coordinate is to be filled, the method finds which cell the coordinate; 116falls into. Since the cells are rectangular, this can be done very quickly.; 117It then only loops over the bins associated with that cell and calls `IsInside()`; 118only on that bins. This reduces considerably the number of bins on which `IsInside()`; 119is called and therefore speed up by a huge factor the filling compare to the brute force; 120approach where `IsInside()` is called for all bins.; 121 ; 122The addition of bins to the appropriate cells is done when the bin is added; 123to the histogram. To do this, `AddBin()` calls the; 124`AddBinToPartition()` method.; 125This method adds the input bin to the partitioning matrix.; 126 ; 127The number of partition cells per axis can be specified in the constructor.; 128If it is not specified, the default value of 25 along each axis will be; 129assigned. This value was chosen because it is small enough to avoid slowing; 130down AddBin(), while being large enough to enhance Fill() by a considerable; 131amount. Regardless of how it is initialized at construction time, it can be; 132changed later with the `ChangePartition()` method.; 133`ChangePartition()` deletes the; 134old partition matrix and generates a new one with the specified number of cells; 135on each axis.; 136 ; 137The optimum number of partition cells per axis c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2Poly_8cxx_source.html:5138,reduce,reduces,5138,doc/master/TH2Poly_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html,1,['reduce'],['reduces']
Energy Efficiency,"s and use them in a geometry; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; TGeoElementRNClass representing a radionuclidevoid TGeoManager::SetDefaultRootUnits() { if ( fgDefaultUnits == kRo...Definition TGeoElement.h:132; TGeoElementRN::Printvoid Print(Option_t *option="""") const overridePrint info about the element;.Definition TGeoElement.cxx:594; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; One can make materials or mixtures from radionuclides:; root[] TGeoMaterial *mat = new TGeoMaterial(""C14"", c14, 2.0);; The following properties of radionuclides can be currently accessed via getters in the TGeoElementRN class:; Atomic number and charge (from the base class TGeoElement). Isomeric number (ISO); ENDF code - following the convention: ENDF=10000*Z+100*A+ISO; Isomeric energy level [MeV]; Mass excess [MeV]; Half life [s]; Spin/Parity - can be retrieved with: TGeoElementRN::GetTitle(); Hynalation and ingestion toxicities; List of decays - TGeoElementRN::GetDecays(). The radioactive decays of a radionuclide are represented by the class TGeoDecayChannel and they are stored in a TObjArray. Decay provides:. Decay mode; Variation of isomeric number; Q value for the decay [GeV]; Parent element; Daughter element. Radionuclides are linked one to each other via their decays, until the last element in the decay chain which must be stable. One can iterate decay chains using the iterator TGeoElemIter:; root[] TGeoElemIter next(c14);; root[] TGeoElementRN *elem;; root[] while ((elem=next())) next.Print();; 6-C-014 (100% BetaMinus) T1/2=1.81e+11; 7-N-014 stable; N#define N; TGeoElemIterI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Materials__classes.html:7520,charge,charge,7520,doc/master/group__Materials__classes.html,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html,1,['charge'],['charge']
Energy Efficiency,"s as follows:; Int_t Search1General(float *spectrum,; int size,; float sigma,; int threshold,; bool markov,; int aver_window);; This function searches for peaks in the source spectrum. The number of found peaks and their positions are written into the structure pointed by the one_dim_peak structure pointer.; Function parameters:. spectrum: pointer to the vector of the source spectrum. This source spectrum is replaced by the new spectrum calculated using Markov chains method.; size: length of the source spectrum; sigma: sigma of searched peaks; threshold: threshold value for peaks selection; markov: logical variable. If it is set to true, then the source spectrum is first replaced by the new spectrum calculated using Markov chains method; aver_window: averaging window used in the calculation of Markov spectrum, applies only if the markov variable was set to true. The methods of peak searching are sensitive to the sigma. Usually the sigma value is known beforehand. It also changes only slightly with the energy. We have investigated as well the robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10 (see Figure 3.6). Robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10. We applied peak searching algorithm based on Markov approach. We changed sigma in the interval from 1 to 10. The spectra for averaging windows 3, 5, 10 are shown in Figure 3.7. Spectra for averaging windows 3, 5, 10. When we applied peak searching function to the Markov spectrum averaged with the window=10, we obtained correct estimate of all 10 peak positions for sigma=2,3,4,5,6,7,8. It was not the case when we made the same experiment with the original spectrum. For all sigmas some peaks were not discovered.; 3.2 2-DIMENSIONAL SPECTRA; The basic function of the 2-dimensional peak searching is described in details in [4]. It automatically identifies the peaks in a spectrum with the presence of the continuous b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:19363,energy,energy,19363,root/htmldoc/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html,1,['energy'],['energy']
Energy Efficiency,"s branch will contain the newest changes in ROOT we will later pull in to our feature branch.; Making your changes; Before implementing your changes, create a new branch that we will work on in isolation from master. In this case, we will name it histogram-race-condition-fix, but you may name it differently according to what your contribution will be.; git checkout -b histogram-race-condition-fix; After implementing your changes, add and commit your changes (More about how to use git here):; git add hist/hist/somefile.cxx; git commit -m ""Avoid race condition on Ubuntu 16.04""; git push --set-upstream origin histogram-race-condition-fix; Your changes are now in your forked repository on GitHub. We will now make the pull request.; Making the pull request on GitHub; If you go to https://github.com/<your GitHub username>/root, you will see a notification saying ""Your recently pushed branches: histogram-race-condition-fix (some minutes ago)"":. You can now hit the green ""Compare & pull request"" button which lets you create the pull request.; Fill in a reasonable description of what your new feature is, and hit ""Create pull request"". A project member will later initiate a build of your pull request and then review your pull request before giving feedback and in the end hopefully merge it. More about how what happens after submitting the pull request can be found in the contributing readme.; Pulling the last changes from upstream/master; Often, there might have been changes in the upstream/master repository that you want to have together with your new changes. This section will describe how to pull the new changes.; Add the ROOT repository upstream as a remote:; git remote add upstream https://github.com/root-project/root; Make sure you are on the master branch locally and pull the latest changes from upstream:; git checkout master; git pull upstream master; Go back to your local branch and rebase the last changes from master:; git checkout histogram-race-condition-fix; git ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/creating-pull-request.html:3229,green,green,3229,d/creating-pull-request.html,https://root.cern,https://root.cern/d/creating-pull-request.html,1,['green'],['green']
Energy Efficiency,"s branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are not a counter. void ReadLeavesMemberBranchCount(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do have a branch count and are not a counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); -- Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBranchElement.html:26760,allocate,allocated,26760,root/html528/TBranchElement.html,https://root.cern,https://root.cern/root/html528/TBranchElement.html,2,['allocate'],['allocated']
Energy Efficiency,"s cached with this data set; TDirectory*RooDirItem::_dir! Associated directory; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool ; RooArgSetRooAbsData::_varsDimensions of this data set; RooArgSet_varsNoWgtVars without weight variable ; RooRealVar*_wgtVarPointer to weight variable (if set) ; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooDataSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void operator delete(void* ptr); Memory is owned by pool, we need to do nothing to release it. RooDataSet(); Default constructor for persistence. RooDataSet(const char* name, const char* title, const RooArgSet& vars, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Construct an unbinned dataset from a RooArgSet defining the dimensions of the data space. Optionally, data; can be imported at the time of construction. This constructor takes the following optional arguments. Import(TTree*) -- Import contents of given T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDataSet.html:17658,allocate,allocated,17658,root/html530/RooDataSet.html,https://root.cern,https://root.cern/root/html530/RooDataSet.html,2,['allocate'],['allocated']
Energy Efficiency,"s dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsData.html:16036,reduce,reduce,16036,root/html528/RooAbsData.html,https://root.cern,https://root.cern/root/html528/RooAbsData.html,6,['reduce'],['reduce']
Energy Efficiency,"s dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsData.html:15938,reduce,reduce,15938,root/html526/RooAbsData.html,https://root.cern,https://root.cern/root/html526/RooAbsData.html,1,['reduce'],['reduce']
Energy Efficiency,"s efficient as binary root.bin request. Comparison of different request methods with TH1 object shown in the table:. Request; Size. root.bin; 1658 bytes. root.bin.gz; 782 bytes. root.json; 7555 bytes. root.json?compact=3; 5381 bytes. root.json.gz?compact=3; 1207 bytes. One should remember that JSON representation always includes names of the data fields which are not present in the binary representation. Even then the size difference is negligible.; root.json used in JSROOT to request objects from THttpServer.; 1.7.2 Generating images out of objects; For the ROOT classes which are implementing Draw method (like TH1 or TGraph) one could produce images with requests: root.png, root.gif, root.jpeg. For example:; wget ""http://localhost:8080/Files/hsimple.root/hpx/root.png?w=500&h=500&opt=lego1"" -O lego1.png; For all such requests one could specify following parameters:. h - image height; w - image width; opt - draw options. 1.7.3 Methods execution; By default THttpServer starts in monitoring (read-only) mode and therefore forbid any methods execution. One could specify read-write mode when server is started:; serv = new THttpServer(""http:8080;rw"");; Or one could disable read-only mode with the call:; serv->SetReadOnly(kFALSE);; Or one could allow access to the folder, object or specific object methods with:; serv->Restrict(""/Histograms"", ""allow=admin""); // allow full access for user with 'admin' accout ; serv->Restrict(""/Histograms/hist1"", ""allow=all""); // allow full access for all users ; serv->Restrict(""/Histograms/hist1"", ""allow_method=Rebin""); // allow only Rebin method ; ‘exe.json’ accepts following parameters: - method - name of method to execute - prototype - method prototype (see TClass::GetMethodWithPrototype for details) - compact - compact parameter, used to compress return value - _ret_object_ - name of the object which should be returned as result of method execution (used together with remote TTree::Draw call); Example of retrieving object title:; [shell] w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/HttpServer/HttpServer.html:12683,monitor,monitoring,12683,root/html534/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/html534/guides/HttpServer/HttpServer.html,1,['monitor'],['monitoring']
Energy Efficiency,s explicitly given by user; Long64_tfChainOffset! Offset of 1st entry of this Tree in a TChain; TList*fClones! List of cloned trees which share our addresses; Long64_t*fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tfDebug! Debug level; Long64_tfDebugMax! Last entry number to debug; Long64_tfDebugMin! First entry number to debug; Int_tfDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*fDirectory! Pointer to directory holding this tree; Long64_tfEntriesNumber of entries; TEntryList*fEntryList! Pointer to event selection list (if one); Long64_tfEstimateNumber of entries to estimate histogram limits; TEventList*fEventList! Pointer to event selection list (if one); Int_tfFileNumber! current file number (if file extensions); Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Long64_tfFlushedBytesNumber of autoflushed bytes; UInt_tfFriendLockStatus! Record which method is locking the friend recursion; TList*fFriendspointer to list of friend elements; TArrayIfIndexIndex of sorted values; TArrayDfIndexValuesSorted index values; TObjArrayfLeavesDirect pointers to individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tfMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tfMaxClusterRange! Memory allocated for the cluster range.; Long64_tfMaxEntriesMaximum number of entries in case of circular buffers; Long64_tfMaxEntryLoopMaximum number of entries to process; Long64_tfMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tfNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject id,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:33834,allocate,allocated,33834,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['allocate'],['allocated']
Energy Efficiency,"s for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. TMutex*fAMtxTo protect async msg queue; list<TXSockBuf*>fAQuelist of asynchronous messages; TSemaphorefASemControl access to conn async msg queue; Bool_tfAWaitkTRUE if waiting at the async msg queue; TSemaphorefAsynProcControl actions while processing async messages; TXSockBuf*fBufCurcurrent read buffer; TStringfBufferContainer for exchanging information; Int_tfByteCurcurrent position in the first buffer; Int_tfByteLeftbytes left in the first buffer; XrdProofConn*fConninstance of the underlying connection module; Bool_tfDontTimeoutIf true wait forever for incoming messages; TXHandler*fHandlerHandler of asynchronous events (input, error); TStringfHostRemote host; Bool_tfIForwardWhether the interrupt should be propagated; kXR_int32fILevHighest received interrupt; TMutex*fIMtxTo protect interrupt queue; Int_tfLogLevelLog level to be transmitted to servers; charfMode'e' (def) or 'i' (internal - proofsrv); Int_tfPid; Int_tfPortRemote port; Bool_tfRDInterruptTo interrupt waiting for messages; TObject*fReferenceGeneric object reference of this socket; kXR_int32fSendOptOptions for sending messages; Short_tfSessionIDproofsrv: remote ID of connected session; TStringfUserUsername used for login; Int_tfXrdProofdVersion; static Bool_tfgInitDoneAvoid initializing more than once; static TStringfgLocLocation string; static TXSockPipefgPipePipe for input monitoring; static TMutexfgSMtxTo protect spare list; static list<TXSockBuf*>fgSQuelist of spare buffers. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TSocket. XrdClientAbsUnsolMsgHandler. ←; TXSocket. ←. TXUnixSocket. Function documentation; void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protecte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXSocket.html:13096,monitor,monitoring,13096,root/html602/TXSocket.html,https://root.cern,https://root.cern/root/html602/TXSocket.html,1,['monitor'],['monitoring']
Energy Efficiency,"s for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. TMutex*fAMtxTo protect async msg queue; list<TXSockBuf*>fAQuelist of asynchronous messages; TSemaphorefASemControl access to conn async msg queue; Bool_tfAWaitkTRUE if waiting at the async msg queue; TSemaphorefAsynProcControl actions while processing async messages; TXSockBuf*fBufCurcurrent read buffer; TStringfBufferContainer for exchanging information; Int_tfByteCurcurrent position in the first buffer; Int_tfByteLeftbytes left in the first buffer; XrdProofConn*fConninstance of the underlying connection module; Bool_tfDontTimeoutIf true wait forever for incoming messages; TXHandler*fHandlerHandler of asynchronous events (input, error); TStringfHostRemote host; Bool_tfIForwardWhether the interrupt should be propagated; kXR_int32fILevHighest received interrupt; TMutex*fIMtxTo protect interrupt queue; Int_tfLogLevelLog level to be transmitted to servers; charfMode'e' (def) or 'i' (internal - proofsrv); Int_tfPid; Int_tfPortRemote port; Bool_tfRDInterruptTo interrupt waiting for messages; TObject*fReferenceGeneric object reference of this socket; kXR_int32fSendOptOptions for sending messages; Short_tfSessionIDproofsrv: remote ID of connected session; TStringfUserUsername used for login; Int_tfXrdProofdVersion; static Bool_tfgInitDoneAvoid initializing more than once; static TStringfgLocLocation string; static TXSockPipefgPipePipe for input monitoring; static TMutexfgSMtxTo protect spare list; static list<TXSockBuf*>fgSQuelist of spare buffers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). TXSocket(const char* url, Char_t mode = 'M', Int_t psi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TXSocket.html:13072,monitor,monitoring,13072,root/html604/TXSocket.html,https://root.cern,https://root.cern/root/html604/TXSocket.html,1,['monitor'],['monitoring']
Energy Efficiency,"s from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t *&ii); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t *&ll); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t *&ll); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t *&f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t *&d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as float) from the I/O buffer.; Returns the number of doubles read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Double32_t encoding at TBufferFile::WriteDouble32. Int_t ReadStaticArray(Bool_t *b); Read array of bools from the I/O buffer. Returns the number of bools; read. Int_t ReadStaticArray(Char_t *c); Read array of characters from the I/O buffer. Returns the number of; characters read. Int_t ReadStaticArray(Short_t *h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferFile.html:26749,allocate,allocated,26749,root/html526/TBufferFile.html,https://root.cern,https://root.cern/root/html526/TBufferFile.html,1,['allocate'],['allocated']
Energy Efficiency,"s from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as float) from the I/O buffer.; Returns the number of doubles read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Double32_t encoding at TBufferF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBufferFile.html:27681,allocate,allocated,27681,root/html528/TBufferFile.html,https://root.cern,https://root.cern/root/html528/TBufferFile.html,6,['allocate'],['allocated']
Energy Efficiency,"s gProof and sets gProof; to this instance. void InitMembers(); Default initializations. ~TProof(); Clean up PROOF environment. Int_t Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); Start the PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). For a description; of the arguments see the TProof ctor. Returns the number of started; master or slave servers, returns 0 in case of error, in which case; fValid remains false. void ParseConfigField(const char* config); The config file field may contain special instructions which need to be; parsed at the beginning, e.g. for debug runs with valgrind. Int_t AssertPath(const char* path, Bool_t writable); Make sure that 'path' exists; if 'writable' is kTRUE, make also sure; that the path is writable. void SetManager(TProofMgr* mgr); Set manager and schedule its destruction after this for clean; operations. Int_t AddWorkers(TList* wrks); Works on the master node only.; It starts workers on the machines in workerList and sets the paths,; packages and macros as on the master.; It is a subbstitute for StartSlaves(...); The code is mostly the master part of StartSlaves,; with the parallel startup removed. Int_t RemoveWorkers(TList* wrks); Used for shuting down the workres after a query is finished.; Sends each of the workers from the workerList, a kPROOF_STOP message.; If the workerList == 0, shutdown all the workers. Bool_t StartSlaves(Bool_t attach = kFALSE); Start up PROOF slaves. void Close(Option_t* option = """"); Close all open slave servers.; Client can decide to shutdown the remote session by passing option is 'S'; or 's'. Default for clients is detach, if supported. Masters always; shutdown the remote counterpart. TSlave * CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); Create a n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:33650,schedul,schedule,33650,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,1,['schedul'],['schedule']
Energy Efficiency,"s hierarchy: Used to describe 3D objects (“shapes”) - filled /added by negotiation with viewer via TVirtualViewer3D. A typical interaction between viewer and client using these, taken from TGeoPainter is:; TVirtualViewer3D * viewer = gPad->GetViewer3D();; // Does viewer prefer local frame positions?; Bool_t localFrame = viewer->PreferLocalFrame();; // Perform first fetch of buffer from the shape and try adding it to the viewer; const TBuffer3D &buffer = shape.GetBuffer3D(TBuffer3D::kCore |; TBuffer3D::kBoundingBox |; TBuffer3D::kShapeSpecific,; localFrame);; Int_t reqSections = viewer->AddObject(buffer, &addDaughters);. // If the viewer requires additional sections fetch from the shape; // (if possible) and add again; if (reqSections != TBuffer3D::kNone); shape.GetBuffer3D(reqSections, localFrame);; Together these allow clients to publish objects to any one of the 3D viewers free of viewer specific drawing code. They allow our simple x3d viewer, and considerably more sophisticated OpenGL one to both work with both geometry libraries (g3d and geom) efficiently.; In addition to external viewers, created in separate windows, this architecture is also used by internal TPad drawing when it requires 3D projections. Publishing to a viewer consists of the following steps:; 1- Create / obtain viewer handle.; 2- Begin scene on viewer.; 3- Fill mandatory parts of TBuffer3D describing object.; 4- Add to viewer.; 5- Fill optional parts of TBuffer3D as requested by viewer.; [ …. repeat 3/4/5 as required for other/child objects]; 6- End scene on viewer.; You should attach the top-level node of your external geometry (or the manager) to a TPad object using TObject::Draw(), and perform the publishing to the viewer in your object’s TObject::Paint() overloaded method. See “Scene Rebuilds”, and example scripts, for more details.; 9.13.4.1 Creating / Obtaining Viewer Handle; External viewers are bound to a TPad object (this may be removed as a requirement in the future). You can create o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:403442,efficient,efficiently,403442,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['efficient'],['efficiently']
Energy Efficiency,"s if necessary. ;  ; Int_t getBandWidthType () const;  ; double getMean (const char *axis) const;  ; void getOptions (void) const;  ; double getSigma (const char *axis) const;  ; TClass * IsA () const override;  ; Int_t loadDataSet (RooDataSet &data, TString options);  Loads a new data set into the class instance. ;  ; void PrintInfo (std::ostream &) const;  Prints out _p[_nPoints][_nPoints] indicating the domain limits. ;  ; void setOptions (TString options);  ; void setWidthScaleFactor (double widthScaleFactor);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeHistToFile (char *outputFile, const char *histName) const;  Plots the PDF as a histogram and saves it to a file, so that it can be loaded in as a Roo2DHist PDF in the future to save on calculation time. ;  ; void writeNTupleToFile (char *outputFile, const char *name) const;  Saves the data and calculated bandwidths to a file, as a record of what produced the PDF and to give a reduced data set in order to facilitate re-calculation in the future. ;  ; void writeToFile (char *outputFile, const char *name) const;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). ;  ; virtual RooAbsGenContext * autoGenContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, bool autoBinned=true, const char *binnedTag="""") const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRoo2DKeysPdf.html:2193,reduce,reduced,2193,doc/master/classRoo2DKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRoo2DKeysPdf.html,1,['reduce'],['reduced']
Energy Efficiency,"s into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do have a branch count and are not a counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBranchElement.html:30651,allocate,allocated,30651,root/html532/TBranchElement.html,https://root.cern,https://root.cern/root/html532/TBranchElement.html,4,['allocate'],['allocated']
Energy Efficiency,"s is performed in the default range. ; This make the shape of a RooAddModel explicitly dependent on the range of the observables. To allow a range independent definition of the fraction this function instructs RooAddModel to freeze its interpretation in the given named range. If the current normalization range is different from the reference range, the appropriate fraction coefficients are automatically calculated from the reference fractions using ratios of integrals. ; Definition at line 210 of file RooAddModel.cxx. ◆ forceAnalyticalInt(). bool RooAddModel::forceAnalyticalInt ; (; const RooAbsArg & ; ); const. inlineoverridevirtual . Reimplemented from RooAbsReal.; Definition at line 44 of file RooAddModel.h. ◆ genContext(). RooAbsGenContext * RooAddModel::genContext ; (; const RooArgSet & ; vars, . const RooDataSet * ; prototype = nullptr, . const RooArgSet * ; auxProto = nullptr, . bool ; verbose = false . ); const. overrideprotectedvirtual . Return specialized context to efficiently generate toy events from RooAddModels. ; Reimplemented from RooAbsPdf.; Definition at line 635 of file RooAddModel.cxx. ◆ generateEvent(). void RooAddModel::generateEvent ; (; Int_t ; code). overridevirtual . This function should never be called as RooAddModel implements a custom generator context. ; Reimplemented from RooAbsPdf.; Definition at line 682 of file RooAddModel.cxx. ◆ getAnalyticalIntegralWN(). Int_t RooAddModel::getAnalyticalIntegralWN ; (; RooArgSet & ; allDeps, . RooArgSet & ; analDeps, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Variant of getAnalyticalIntegral that is also passed the normalization set that should be applied to the integrand of which the integral is requested. ; For certain operator p.d.f it is useful to overload this function rather than analyticalIntegralWN() as the additional normalization information may be useful in determining a more efficient decomposition of the requested integral. ; Reimpl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:85545,efficient,efficiently,85545,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['efficient'],['efficiently']
Energy Efficiency,"s it is behind the screen; mode = 1 the box looks as it is in front of the screen; border is the border size in already pre-computed dark is the; color for the dark part of the frame light is the color for the light; part of the frame. void DrawPolyMarker(Int_t n, Float_t* x, Float_t* y); not used. void DrawPolyMarker(Int_t n, Double_t* x, Double_t* y); draw polymarker. void DrawPS(Int_t n, Double_t* xw, Double_t* yw); This function defines a path with xw and yw and draw it according the; value of nn:. If nn > 0 a line is drawn.; If nn < 0 a closed polygon is drawn. void DrawPS(Int_t n, Float_t* xw, Float_t* yw); not used. void DrawDashPolyLine(Int_t npoints, TPoint* pt, UInt_t nDash, const char* pDash, const char* col, UInt_t thick); draw dashed polyline. void NewPage(); new page. void Text(Double_t x, Double_t y, const char* string); Draw text. x: x position of the text; y: y position of the text. void Text(Double_t x, Double_t y, const wchar_t* string); Draw text. x: x position of the text; y: y position of the text. void CellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); cell array begin. void CellArrayFill(Int_t r, Int_t g, Int_t b); Cell array fill. void CellArrayEnd(); Cell array end. void SetColor(Float_t r, Float_t g, Float_t b); Set color with its R G B components. r: % of red in [0,1]; g: % of green in [0,1]; b: % of blue in [0,1]. Int_t XtoPixel(Double_t x); x to pixel. Int_t YtoPixel(Double_t y); y to pixel. void * GetStream() const; { return (void*)fImage; }. void SetType(Int_t type = -111); { fType = type; }. Int_t GetType() const; { return fType; }. TImage * GetImage() const; { return fImage; }. » Author: Valeriy Onuchin 29/04/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/postscript:$Id$ » Last generated: 2015-03-14 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TImageDump.html:13339,green,green,13339,root/html534/TImageDump.html,https://root.cern,https://root.cern/root/html534/TImageDump.html,1,['green'],['green']
Energy Efficiency,"s method must be overridden when a class wants to print itself. ;  ; void printArgs (std::ostream &os) const override;  Print arguments of fit result, i.e. the parameters of the fit. ;  ; void printClassName (std::ostream &os) const override;  Print class name of fit result. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Print fit result to stream 'os'. ;  ; void printName (std::ostream &os) const override;  Print name of fit result. ;  ; void printTitle (std::ostream &os) const override;  Print title of fit result. ;  ; void printValue (std::ostream &os) const override;  Print the value of the fit result, i.e.g the status, minimized FCN, edm and covariance quality code. ;  ; const RooArgList & randomizePars () const;  Generate random perturbations of the final parameters using the covariance matrix. ;  ; TMatrixDSym reducedCovarianceMatrix (const RooArgList &params) const;  Return a reduced covariance matrix (Note that Vred is a simple sub-matrix of V, row/columns are ordered to matched the convention given in input argument 'params'. ;  ; void setConstParList (const RooArgList &list);  Fill the list of constant parameters. ;  ; void setCovarianceMatrix (TMatrixDSym &V);  Store externally provided correlation matrix in this RooFitResult ;. ;  ; void setCovQual (Int_t val);  ; void setEDM (double val);  ; void setFinalParList (const RooArgList &list);  Fill the list of final values of the floating parameters. ;  ; void setInitParList (const RooArgList &list);  Fill the list of initial values of the floating parameters. ;  ; void setMinNLL (double val);  ; void SetName (const char *name) override;  Change name of RooFitResult object. ;  ; void SetNameTitle (const char *name, const char *title) override;  Change name and title of RooFitResult object. ;  ; void setNumInvalidNLL (Int_t val);  ; void setStatus (Int_t val);  ; void setStatusHistory (std::vector< std::pair< std::string, int > > &hist);  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFitResult.html:5262,reduce,reducedCovarianceMatrix,5262,doc/master/classRooFitResult.html,https://root.cern,https://root.cern/doc/master/classRooFitResult.html,2,['reduce'],"['reduced', 'reducedCovarianceMatrix']"
Energy Efficiency,"s required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. Recyling TBuffer3D ; Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free to destroy this object, or recycle it for the next; object if suitable. Function Members (Methods); public:. TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBuffer3D.html:8261,efficient,efficient,8261,root/html526/TBuffer3D.html,https://root.cern,https://root.cern/root/html526/TBuffer3D.html,5,['efficient'],['efficient']
Energy Efficiency,"s required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. Recyling TBuffer3D ; Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free to destroy this object, or recycle it for the next; object if suitable. Function Members (Methods); public:. virtual~TBuffer3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBuffer3D.html:8261,efficient,efficient,8261,root/html602/TBuffer3D.html,https://root.cern,https://root.cern/root/html602/TBuffer3D.html,2,['efficient'],['efficient']
Energy Efficiency,"s self-normalized, which means that no attempt is made to add a normalization term.Definition RooAbsPdf.h:207; RooAbsPdf::printMultilinevoid printMultiline(std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const overridePrint multi line detailed information of this RooAbsPdf.Definition RooAbsPdf.cxx:1100; RooAbsPdf::_traceCountInt_t _traceCountNumber of traces remaining to print.Definition RooAbsPdf.h:335; RooAbsPdf::canBeExtendedbool canBeExtended() constIf true, PDF can provide extended likelihood term.Definition RooAbsPdf.h:218; RooAbsPdf::_normRooAbsReal * _normDefinition RooAbsPdf.h:319; RooAbsPdf::setTraceCountervoid setTraceCounter(Int_t value, bool allNodes=false)Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'val...Definition RooAbsPdf.cxx:598; RooAbsPdf::prepareMultiGenGenSpec * prepareMultiGen(const RooArgSet &whatVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={})Prepare GenSpec configuration object for efficient generation of multiple datasets from identical spe...Definition RooAbsPdf.cxx:1299; RooAbsPdf::_errorCountInt_t _errorCountNumber of errors remaining to print.Definition RooAbsPdf.h:334; RooAbsPdf::CanNotBeExtended@ CanNotBeExtendedDefinition RooAbsPdf.h:212; RooAbsPdf::createExpectedEventsFuncvirtual std::unique_ptr< RooAbsReal > createExpectedEventsFunc(const RooArgSet *nset) constReturns an object that represents the expected number of events for a given normalization set,...Definition RooAbsPdf.cxx:2812; RooAbsPdf::paramOnvirtual RooPlot * paramOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})Add a box with parameter values (and errors) to the specified frame.Definition RooAbsPdf.cxx:2285;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:148541,efficient,efficient,148541,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['efficient'],['efficient']
Energy Efficiency,"s self-normalized, which means that no attempt is made to add a normalization term.Definition RooAbsPdf.h:207; RooAbsPdf::printMultilinevoid printMultiline(std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const overridePrint multi line detailed information of this RooAbsPdf.Definition RooAbsPdf.cxx:1100; RooAbsPdf::_traceCountInt_t _traceCountNumber of traces remaining to print.Definition RooAbsPdf.h:335; RooAbsPdf::canBeExtendedbool canBeExtended() constIf true, PDF can provide extended likelihood term.Definition RooAbsPdf.h:218; RooAbsPdf::_normRooAbsReal * _normDefinition RooAbsPdf.h:319; RooAbsPdf::setTraceCountervoid setTraceCounter(Int_t value, bool allNodes=false)Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'val...Definition RooAbsPdf.cxx:598; RooAbsPdf::prepareMultiGenGenSpec * prepareMultiGen(const RooArgSet &whatVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={})Prepare GenSpec configuration object for efficient generation of multiple datasets from identical spe...Definition RooAbsPdf.cxx:1299; RooAbsPdf::_errorCountInt_t _errorCountNumber of errors remaining to print.Definition RooAbsPdf.h:334; RooAbsPdf::ExtendModeExtendModeDefinition RooAbsPdf.h:212; RooAbsPdf::CanBeExtended@ CanBeExtendedDefinition RooAbsPdf.h:212; RooAbsPdf::MustBeExtended@ MustBeExtendedDefinition RooAbsPdf.h:212; RooAbsPdf::CanNotBeExtended@ CanNotBeExtendedDefinition RooAbsPdf.h:212; RooAbsPdf::_rawValuedouble _rawValueDefinition RooAbsPdf.h:318; RooAbsPdf::normRangeconst char * normRange() constDefinition RooAbsPdf.h:250; RooAbsPdf::createExpectedEventsFuncvirtual std::unique_ptr< RooAbsReal > createExpectedEventsFunc(const RooArgSet *nset) constReturns an object that represents the expected number of events for a given normalization set,...Definition RooAbsPdf.cxx:2812; RooAbsPdf::paramOnvirtual Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8h_source.html:26693,efficient,efficient,26693,doc/master/RooAbsPdf_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8h_source.html,1,['efficient'],['efficient']
Energy Efficiency,"s the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1.0E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1.0E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1.0E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1.0E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1.0E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(ROOT::Math::IParamFunction& f, double x, const double* p, unsigned int ipar = 0, double h = 1.0E-8). Evaluate the derivative with respect a parameter for one-dim parameteric function; at the point ( x,p[]) with respect the parameter p_ipar. double Eval(ROOT::Math::IParamMultiFunction& f, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__Derivator.html:4848,adapt,adaptive,4848,root/html602/ROOT__Math__Derivator.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__Derivator.html,2,['adapt'],['adaptive']
Energy Efficiency,"s to have nominal min and max values. RooArgList createParamSet(const string& , Int_t , Double_t , Double_t ); Create the list of RooRealVar; parameters which represent the; height of the histogram bins.; Store them in a list; _paramSet.add( createParamSet() );; Get the number of bins; in the nominal histogram. Int_t addVarSet(const RooArgList& vars). Int_t addParamSet(const RooArgList& params). Double_t evaluate() const. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implement analytical integrations by doing appropriate weighting from component integrals; functions to integrators of components. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. TObject* clone(const char* newname) const; { return new ParamHistFunc(*this, newname); }. const RooArgList& paramList() const; { return _paramSet ; }. Int_t numBins() const; { return _dataSet.numEntries(); }. const RooArgSet* get(Int_t masterIdx) const; { return _dataSet.get( masterIdx ) ; }. const RooArgSet* get(const RooArgSet& coord) const; { return _dataSet.get( coord ) ; }. double binVolume() const; { return _dataSet.binVolume(); }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; { return kTRUE ; }. Bool_t isBinnedDistribution(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ParamHistFunc.html:39485,efficient,efficiently,39485,root/html534/ParamHistFunc.html,https://root.cern,https://root.cern/root/html534/ParamHistFunc.html,3,['efficient'],['efficiently']
Energy Efficiency,"s very cluttered and useless. To improve the readability of the Parallel Coordinates output and to explore interactively the data set, many techniques are available. We have implemented a few in ROOT. First of all, in order to show better where the clusters on the various axes are, a 1D histogram is associated to each axis. These histograms (one per axis) are filled according to the number of lines passing through the bins. The histogram’s axis can be represented with colors or as bar charts. These histograms can be represented which colors (get from a palette according to the bin contents) or as bar charts. Both representations can be cumulated on the same plot. This technique allows seeing clearly where the clusters are on an individual axis but it does not give any hints about the correlations between the axes.; Avery simple technique allows to make the clusters appearing: Instead of painting solid lines we paint dotted lines. The cluttering of each individual line is reduced and the clusters show clearly as we can see on the next figure. The spacing between the dots is a parameter which can be adjusted in order to get the best results. Using dotted lines is a very simple method to reduce the cluttering. Interactivity is a very important aspect of the Parallel Coordinates plots. To really explore the data set it is essential to act directly with the events and the axes. For instance, changing the axes order may show clusters which were not visible in a different order. On the next figure the axes order has been changed interactively. We can see that many more clusters appear and all the “random spheres” we put in the data set are now clearly visible. Having moved the variables u,v,w after the variables x,y,z the correlation between these two sets of variables is clear also. Axis order is very important to show clusters. To pursue further data sets exploration we have implemented the possibility to define selections interactively. A selection is a set of ranges co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:613751,reduce,reduced,613751,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['reduce'],['reduced']
Energy Efficiency,"s volumeDefinition TGeoVolume.cxx:2347; TGeoVolume::SetNumbervoid SetNumber(Int_t number)Definition TGeoVolume.h:245; TGeoVolume::SetLineWidthvoid SetLineWidth(Width_t lwidth) overrideSet the line width.Definition TGeoVolume.cxx:2185; TGeoVolume::GetMediumTGeoMedium * GetMedium() constDefinition TGeoVolume.h:175; TGeoVolume::GetRefCountInt_t GetRefCount() constDefinition TGeoVolume.h:131; TGeoVolume::SortNodesvoid SortNodes()sort nodes by decreasing volume of the bounding box.Definition TGeoVolume.cxx:2080; TGeoVolume::Voxelizevoid Voxelize(Option_t *option)build the voxels for this volumeDefinition TGeoVolume.cxx:2464; TGeoVolume::IsRunTimeBool_t IsRunTime() constDefinition TGeoVolume.h:109; TGeoVolume::CreateThreadDatavirtual void CreateThreadData(Int_t nthreads)Definition TGeoVolume.cxx:435; TGeoVolume::GetByteCountvirtual Int_t GetByteCount() constget the total size in bytes for this volumeDefinition TGeoVolume.cxx:2204; TGeoVolume::OptimizeVoxelsBool_t OptimizeVoxels()Perform an extensive sampling to find which type of voxelization is most efficient.Definition TGeoVolume.cxx:1247; TGeoVolume::IsVolumeMultivirtual Bool_t IsVolumeMulti() constDefinition TGeoVolume.h:110; TGeoVolume::CountNodesInt_t CountNodes(Int_t nlevels=1000, Int_t option=0)Count total number of subnodes starting from this volume, nlevels down.Definition TGeoVolume.cxx:730; TGeoVolume::UnmarkSavedvoid UnmarkSaved()Reset SavePrimitive bits.Definition TGeoVolume.cxx:1699; TGeoVolume::SetFindervoid SetFinder(TGeoPatternFinder *finder)Definition TGeoVolume.h:244; TGeoVolume::GetNdaughtersInt_t GetNdaughters() constDefinition TGeoVolume.h:362; TGeoVolume::Grabvoid Grab()Definition TGeoVolume.h:136; TGeoVolume::Classstatic TClass * Class(); TGeoVolume::SetTransparencyvoid SetTransparency(Char_t transparency=0)Definition TGeoVolume.h:376; TGeoVolume::Releasevoid Release()Definition TGeoVolume.h:137; TGeoVolume::FindOverlapsvoid FindOverlaps() constloop all nodes marked as overlaps and find overlappin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:235107,efficient,efficient,235107,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['efficient'],['efficient']
Energy Efficiency,"s"");; ; // We must explicitly refer to x,y,c here to pass the values because; // d is not linked to them (as explained above); d.add(RooArgSet(x, y, c));; }; d.Print(""v"");; cout << endl;; ; // The get() function returns a pointer to the internal copy of the RooArgSet(x,y,c); // supplied in the constructor; const RooArgSet *row = d.get();; row->Print(""v"");; cout << endl;; ; // Get with an argument loads a specific data point in row and returns; // a pointer to row argset. get() always returns the same pointer, unless; // an invalid row number is specified. In that case a null ptr is returned; d.get(900)->Print(""v"");; cout << endl;; ; // R e d u c i n g , A p p e n d i n g a n d M e r g i n g; // -------------------------------------------------------------; ; // The reduce() function returns a new dataset which is a subset of the original; cout << endl << "">> d1 has only columns x,c"" << endl;; std::unique_ptr<RooAbsData> d1{d.reduce({x, c})};; d1->Print(""v"");; ; cout << endl << "">> d2 has only column y"" << endl;; std::unique_ptr<RooAbsData> d2{d.reduce({y})};; d2->Print(""v"");; ; cout << endl << "">> d3 has only the points with y>5.17"" << endl;; std::unique_ptr<RooAbsData> d3{d.reduce(""y>5.17"")};; d3->Print(""v"");; ; cout << endl << "">> d4 has only columns x,c for data points with y>5.17"" << endl;; std::unique_ptr<RooAbsData> d4{d.reduce({x, c}, ""y>5.17"")};; d4->Print(""v"");; ; // The merge() function adds two data set column-wise; cout << endl << "">> merge d2(y) with d1(x,c) to form d1(x,c,y)"" << endl;; static_cast<RooDataSet&>(*d1).merge(&static_cast<RooDataSet&>(*d2));; d1->Print(""v"");; ; // The append() function adds two datasets row-wise; cout << endl << "">> append data points of d3 to d1"" << endl;; static_cast<RooDataSet&>(*d1).append(static_cast<RooDataSet&>(*d3));; d1->Print(""v"");; ; // O p e r a t i o n s o n b i n n e d d a t a s e t s; // ---------------------------------------------------------; ; // A binned dataset can be constructed empty, from an unbinned",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf402__datahandling_8C.html:2574,reduce,reduce,2574,doc/master/rf402__datahandling_8C.html,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8C.html,1,['reduce'],['reduce']
Energy Efficiency,"s() const; Return the ratio of entries vs occupied slots. Int_t Capacity() const; Return number of slots in the hashtable. Use GetSize() to get the; number of objects stored in the TMap. void Clear(Option_t* option = """"); Remove all (key,value) pairs from the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool_t DeleteEntry(TObject* key); Remove (key,value) pair with key from the map. Returns true; if the key was found and removed, false otherwise.; The key and value objects are deleted if map is the owner; of keys and values respectively. TObject * FindObject(const char* keyname) const; Check if a (key,value) pair exists with keyname as name of the key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * FindObject(const TObject* key) const; Check if a (key,value) pair exists with key as key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Va",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMap.html:9802,allocate,allocated,9802,root/html528/TMap.html,https://root.cern,https://root.cern/root/html528/TMap.html,6,['allocate'],['allocated']
Energy Efficiency,"s());; 3335 br->SetAddress(addr);; 3336 // The copy does not own any object allocated by SetAddress().; 3337 if (br->InheritsFrom(TBranchElement::Class())) {; 3338 ((TBranchElement*) br)->ResetDeleteObject();; 3339 }; 3340 } else {; 3341 Warning(""CopyAddresses"", ""Could not find branch named '%s' in tree named '%s'"", branch->GetName(), tree->GetName());; 3342 }; 3343 }; 3344 }; 3345 ; 3346 // Copy branch addresses starting from leaves.; 3347 TObjArray* tleaves = tree->GetListOfLeaves();; 3348 Int_t ntleaves = tleaves->GetEntriesFast();; 3349 std::set<TLeaf*> updatedLeafCount;; 3350 for (Int_t i = 0; i < ntleaves; ++i) {; 3351 TLeaf* tleaf = (TLeaf*) tleaves->UncheckedAt(i);; 3352 TBranch* tbranch = tleaf->GetBranch();; 3353 TBranch* branch = GetBranch(tbranch->GetName());; 3354 if (!branch) {; 3355 continue;; 3356 }; 3357 TLeaf* leaf = branch->GetLeaf(tleaf->GetName());; 3358 if (!leaf) {; 3359 continue;; 3360 }; 3361 if (branch->TestBit(kDoNotProcess)) {; 3362 continue;; 3363 }; 3364 if (undo) {; 3365 // Now we know whether the address has been transfered; 3366 tree->ResetBranchAddress(tbranch);; 3367 } else {; 3368 TBranchElement *mother = dynamic_cast<TBranchElement*>(leaf->GetBranch()->GetMother());; 3369 bool needAddressReset = false;; 3370 if (leaf->GetLeafCount() && (leaf->TestBit(TLeaf::kNewValue) || !leaf->GetValuePointer() || (mother && mother->IsObjectOwner())) && tleaf->GetLeafCount()); 3371 {; 3372 // If it is an array and it was allocated by the leaf itself,; 3373 // let's make sure it is large enough for the incoming data.; 3374 if (leaf->GetLeafCount()->GetMaximum() < tleaf->GetLeafCount()->GetMaximum()) {; 3375 leaf->GetLeafCount()->IncludeRange( tleaf->GetLeafCount() );; 3376 updatedLeafCount.insert(leaf->GetLeafCount());; 3377 needAddressReset = true;; 3378 } else {; 3379 needAddressReset = (updatedLeafCount.find(leaf->GetLeafCount()) != updatedLeafCount.end());; 3380 }; 3381 }; 3382 if (needAddressReset && leaf->GetValuePointer()) {; 3383 if (leaf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:133514,allocate,allocated,133514,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"s(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Int_tfActWorkersNumebr of workers still active; Long64_tfBytesReadNumber of bytes read; Float_tfEffSessionsNumber of effective sessions running on the machines allocated to this session; Float_tfEvtRateIInstantaneous event rate; Float_tfInitTimeTime for initialization; Float_tfMBRateIInstantaneous byte read rate; Float_tfProcTimeTime for processing; Long64_tfProcessedNumber of events processed; Int_tfTotSessionsNumebr of PROOF sessions running currently on the clusters; Long64_tfTotalTotal number of events to process. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressInfo(Long64_t tot = 0, Long64_t proc = 0, Long64_t bytes = 0, Float_t initt = -1., Float_t proct = -1., Float_t evts = -1., Float_t mbs = -1., Int_t actw = 0, Int_t tsess = 0, Float_t esess = 0.); { }. virtual ~TProofProgressInfo(); { }. TProofInterruptHandler& operator=(const TProofProgressInfo& ). » Author: Fons Rademakers 13/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TProof.h 37396 2010-12-08 13:12:00Z rdm $ » Last generated: 2010-12-08 16:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofProgressInfo.html:5651,allocate,allocated,5651,root/html528/TProofProgressInfo.html,https://root.cern,https://root.cern/root/html528/TProofProgressInfo.html,1,['allocate'],['allocated']
Energy Efficiency,"s(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Int_tfActWorkersNumebr of workers still active; Long64_tfBytesReadNumber of bytes read; Float_tfEffSessionsNumber of effective sessions running on the machines allocated to this session; Float_tfEvtRateIInstantaneous event rate; Float_tfInitTimeTime for initialization; Float_tfMBRateIInstantaneous byte read rate; Float_tfProcTimeTime for processing; Long64_tfProcessedNumber of events processed; Int_tfTotSessionsNumebr of PROOF sessions running currently on the clusters; Long64_tfTotalTotal number of events to process. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressInfo(Long64_t tot = 0, Long64_t proc = 0, Long64_t bytes = 0, Float_t initt = -1., Float_t proct = -1., Float_t evts = -1., Float_t mbs = -1., Int_t actw = 0, Int_t tsess = 0, Float_t esess = 0.); { }. virtual ~TProofProgressInfo(); { }. TProofInterruptHandler& operator=(const TProofProgressInfo& ). » Author: Fons Rademakers 13/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TProof.h 39178 2011-05-13 10:30:30Z ganis $ » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general plea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofProgressInfo.html:5722,allocate,allocated,5722,root/html530/TProofProgressInfo.html,https://root.cern,https://root.cern/root/html530/TProofProgressInfo.html,1,['allocate'],['allocated']
Energy Efficiency,"s(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Int_tfActWorkersNumebr of workers still active; Long64_tfBytesReadNumber of bytes read; Float_tfEffSessionsNumber of effective sessions running on the machines allocated to this session; Float_tfEvtRateIInstantaneous event rate; Float_tfInitTimeTime for initialization; Float_tfMBRateIInstantaneous byte read rate; Float_tfProcTimeTime for processing; Long64_tfProcessedNumber of events processed; Int_tfTotSessionsNumebr of PROOF sessions running currently on the clusters; Long64_tfTotalTotal number of events to process. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressInfo(Long64_t tot = 0, Long64_t proc = 0, Long64_t bytes = 0, Float_t initt = -1., Float_t proct = -1., Float_t evts = -1., Float_t mbs = -1., Int_t actw = 0, Int_t tsess = 0, Float_t esess = 0.); { }. virtual ~TProofProgressInfo(); { }. TProofInterruptHandler& operator=(const TProofProgressInfo& ). » Author: Fons Rademakers 13/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TProof.h 39178 2011-05-13 10:30:30Z ganis $ » Last generated: 2011-11-03 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general plea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofProgressInfo.html:5722,allocate,allocated,5722,root/html532/TProofProgressInfo.html,https://root.cern,https://root.cern/root/html532/TProofProgressInfo.html,1,['allocate'],['allocated']
Energy Efficiency,"s) , and the ; coefficients , so that is minimal; (TMultiDimFit::FindParameterization).; ; Of course it's more than a little unlikely that will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when; . Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class.; . Limiting the Number of Terms; . As always when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms).; ; However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers).; ; One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5].; ; There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if; . where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out).; . Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly redu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiDimFit.html:3904,power,power,3904,root/html534/TMultiDimFit.html,https://root.cern,https://root.cern/root/html534/TMultiDimFit.html,3,['power'],['power']
Energy Efficiency,"s);  Factory method to creates an image palette of a specific typ. ;  ; static TImagePalette * CreateCOLPalette (Int_t nContours);  Factory method to creates an image palette for histogram plotting. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Public Attributes; UShort_t * fColorAlpha {nullptr};  [fNumPoints] alpha at each anchor point ;  ; UShort_t * fColorBlue {nullptr};  [fNumPoints] blue color at each anchor point ;  ; UShort_t * fColorGreen {nullptr};  [fNumPoints] green color at each anchor point ;  ; UShort_t * fColorRed {nullptr};  [fNumPoints] red color at each anchor point ;  ; UInt_t fNumPoints {0};  number of anchor points ;  ; Double_t * fPoints {nullptr};  [fNumPoints] value of each anchor point [0..1] ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTImagePalette.html:11537,green,green,11537,doc/master/classTImagePalette.html,https://root.cern,https://root.cern/doc/master/classTImagePalette.html,1,['green'],['green']
Energy Efficiency,"s)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; static TCollection::(anonymous)TCollection::kIsOwner. private:. TList**fContHash table (table of lists); Int_tfEntriesNumber of objects in table; Int_tfRehashLevelAverage collision rate which triggers rehash; Int_tfUsedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashTable object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehashlevel is the value at which a rehash will be triggered. I.e. when; the average size of the linked lists at a slot becomes longer than; rehashlevel then the hashtable will be resized and refilled to reduce; the collision rate to about 1. The higher the collision rate, i.e. the; longer the linked lists, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddBefore(const TObject* before, TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function.; If and only if 'before' is in the same bucket as obj, obj is added; in front of 'before' within the bucket's list. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THashTable.html:9476,reduce,reduce,9476,root/html602/THashTable.html,https://root.cern,https://root.cern/root/html602/THashTable.html,2,['reduce'],['reduce']
Energy Efficiency,"s, TBuffer &b);  ; void WritePrimitives (int nElements, TBuffer &b);  ;  Protected Member Functions inherited from TGenCollectionProxy; void CheckFunctions () const;  Check existence of function pointers. ;  ; virtual void DeleteItem (Bool_t force, void *ptr) const;  Call to delete/destruct individual item. ;  ; TGenCollectionProxy * Initialize (Bool_t silent) const;  Proxy initializer. ;  ; virtual TGenCollectionProxy * InitializeEx (Bool_t silent);  Proxy initializer. ;  . Protected Attributes; ReadBuffer_t fReadBufferFunc;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionStreamer.html:10272,allocate,allocate,10272,doc/master/classTGenCollectionStreamer.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionStreamer.html,1,['allocate'],['allocate']
Energy Efficiency,"s, normalized by the histograms contents. Interpolation; is applied if the RooHistFunc is configured to do that. Double_t totVolume() const; Return the total volume spanned by the observables of the RooDataHist. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistFunc can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used, only the integral; over all RooHistPdf observables is implemented. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. TObject* clone(const char* newname) const; { return new RooHistFunc(*this,newname); }. virtual ~RooHistFunc(); { }. RooDataHist& dataHist(); Return RooDataHist that is represented. const RooDataHist& dataHist() const; Return RooDataHist that is represented. void setInterpolationOrder(Int_t order); Set histogram interpolation order. Int_t getInterpolationOrder() const; Return histogram interpolation order. void setCdfBoundaries(Bool_t flag); Set use of special boundary conditions for c.d.f.s. Bool_t getCdfBoundaries() const; If true, special boundary conditions for c.d.f.s are used. Double_t totalVolume() const. » Last changed: Thu Sep 23 19:59:55 2010 » Last generated: 2010-09-23 19:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT suppo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooHistFunc.html:35189,efficient,efficiently,35189,root/html528/RooHistFunc.html,https://root.cern,https://root.cern/root/html528/RooHistFunc.html,1,['efficient'],['efficiently']
Energy Efficiency,"s, normalized by the histograms contents. Interpolation; is applied if the RooHistFunc is configured to do that. Double_t totVolume() const; Return the total volume spanned by the observables of the RooDataHist. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistFunc can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used, only the integral; over all RooHistPdf observables is implemented. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. void Streamer(TBuffer& b); Stream an object of class RooHistFunc. TObject* clone(const char* newname) const; { return new RooHistFunc(*this,newname); }. virtual ~RooHistFunc(); { }. RooDataHist& dataHist(); Return RooDataHist that is represented. const RooDataHist& dataHist() const; Return RooDataHist that is represented. void setInterpolationOrder(Int_t order); Set histogram interpolation order. Int_t getInterpolationOrder() const; Return histogram interpolation order. void setCdfBoundaries(Bool_t flag); Set use of special boundary conditions",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHistFunc.html:36385,efficient,efficiently,36385,root/html532/RooHistFunc.html,https://root.cern,https://root.cern/root/html532/RooHistFunc.html,1,['efficient'],['efficiently']
Energy Efficiency,"s, normalized by the histograms contents. Interpolation; is applied if the RooHistFunc is configured to do that. Double_t totVolume() const; Return the total volume spanned by the observables of the RooDataHist. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistFunc can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used, only the integral; over all RooHistPdf observables is implemented. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. void Streamer(TBuffer& b); Stream an object of class RooHistFunc. TObject* clone(const char* newname) const; { return new RooHistFunc(*this,newname); }. virtual ~RooHistFunc(); { }. RooDataHist& dataHist(); Return RooDataHist that is represented. const RooDataHist& dataHist() const; Return RooDataHist that is represented. void setInterpolationOrder(Int_t order); Set histogram interpolation order. Int_t getInterpolationOrder() const; Return histogram interpolation order. void setCdfBoundaries(Bool_t flag); Set use of special boundary conditions for c.d.f.s. Bool_t getCdfBoundaries() const; If true, special boundary conditions for c.d.f.s are used. Double_t totalVolume() const. » Last changed: Mon Jul 4 15:23:05 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooHistFunc.html:35706,efficient,efficiently,35706,root/html530/RooHistFunc.html,https://root.cern,https://root.cern/root/html530/RooHistFunc.html,1,['efficient'],['efficiently']
Energy Efficiency,"s. ;  ; void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) override;  Update the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values. ;  ;  Protected Member Functions inherited from TGraph; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void SaveHistogramAndFunctions (std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option);  Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes. ;  ; Double_t ** ShrinkAndCopy (Int_t size, Int_t iend);  if size*2 <= fMaxSize allocate new arrays of size points, copy points [0,oend). ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions; void addPoint (Axis_t binCenter, double y, double yscale, double exlow, double exhigh, double eylow, double eyhigh);  . Private Attributes; double _entries = 0.0;  Number of entries in histogram. ;  ; double _nominalBinWidth = 1.0;  Average bin width. ;  ; double _nSigma = 1.0;  Number of 'sigmas' error bars represent. ;  ; std::vector< double > _originalWeights;  The original bin weights that were passed to the RooHist::addBin functions before scaling and bin width correction. ;  ; double _rawEntries = 0.0;  Number of entries in source dataset. ;  . Friends; class RooPlot;  . Additional Inherited Members;  Public Types inherited from TGraph; enum  EStatusBits { ;   kNoStats = (1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHist.html:39170,allocate,allocate,39170,doc/master/classRooHist.html,https://root.cern,https://root.cern/doc/master/classRooHist.html,1,['allocate'],['allocate']
Energy Efficiency,"s. ;  ; void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) override;  Update the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values. ;  ;  Protected Member Functions inherited from TGraph; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void SaveHistogramAndFunctions (std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option);  Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes. ;  ; Double_t ** ShrinkAndCopy (Int_t size, Int_t iend);  if size*2 <= fMaxSize allocate new arrays of size points, copy points [0,oend). ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Double_t * fEXhigh {nullptr};  [fNpoints] array of X high errors ;  ; Double_t * fEXlow {nullptr};  [fNpoints] array of X low errors ;  ; Double_t * fEYhigh {nullptr};  [fNpoints] array of Y high errors ;  ; Double_t * fEYlow {nullptr};  [fNpoints] array of Y low errors ;  ;  Protected Attributes inherited from TGraph; TList * fFunctions;  Pointer to list of functions (fits and user) ;  ; TH1F * fHistogram;  Pointer to histogram used for drawing axis. ;  ; Double_t fMaximum;  Maximum value for plotting along y. ;  ; Int_t fMaxSize;  !Current dimension of arrays fX and fY ;  ; Double_t fMinimum;  Minimum value for plotting along y. ;  ; Int_t fNpoints;  Number of points <= fMaxSize. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphAsymmErrors.html:32732,allocate,allocate,32732,doc/master/classTGraphAsymmErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphAsymmErrors.html,1,['allocate'],['allocate']
Energy Efficiency,"s. Function documentation; TGeoHelix(); Dummy constructor. TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); Normal constructor. ~TGeoHelix(); Destructor. Double_t ComputeSafeStep(Double_t epsil = 9.9999999999999995E-7) const; Compute safe linear step that can be made such that the error; between linear-helix extrapolation is less than EPSIL. void InitPoint(Double_t x0, Double_t y0, Double_t z0); Initialize coordinates of a point on the helix. void InitPoint(Double_t* point); Set initial point on the helix. void InitDirection(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoHelix.html:9129,charge,charge,9129,root/html602/TGeoHelix.html,https://root.cern,https://root.cern/root/html602/TGeoHelix.html,4,['charge'],['charge']
Energy Efficiency,"s.size();; 551 for (unsigned i = 0; i < N; ++i) {; 552 if (!fValues[i].fIsActive); 553 continue;; 554 ; 555 int nbytes;; 556 switch (fValues[i].fType) {; 557 case ETypes::kInteger: fValues[i].fInteger = sqlite3_column_int64(fDataSet->fQuery, i); break;; 558 case ETypes::kReal: fValues[i].fReal = sqlite3_column_double(fDataSet->fQuery, i); break;; 559 case ETypes::kText:; 560 nbytes = sqlite3_column_bytes(fDataSet->fQuery, i);; 561 if (nbytes == 0) {; 562 fValues[i].fText = """";; 563 } else {; 564 fValues[i].fText = reinterpret_cast<const char *>(sqlite3_column_text(fDataSet->fQuery, i));; 565 }; 566 break;; 567 case ETypes::kBlob:; 568 nbytes = sqlite3_column_bytes(fDataSet->fQuery, i);; 569 fValues[i].fBlob.resize(nbytes);; 570 if (nbytes > 0) {; 571 std::memcpy(fValues[i].fBlob.data(), sqlite3_column_blob(fDataSet->fQuery, i), nbytes);; 572 }; 573 break;; 574 case ETypes::kNull: break;; 575 default: throw std::runtime_error(""Unhandled column type"");; 576 }; 577 }; 578 return true;; 579}; 580 ; 581////////////////////////////////////////////////////////////////////////////////////////////////; 582/// Almost a no-op, many slots can in fact reduce the performance due to thread synchronization.; 583void RSqliteDS::SetNSlots(unsigned int nSlots); 584{; 585 if (nSlots > 1) {; 586 ::Warning(""SetNSlots"", ""Currently the SQlite data source faces performance degradation in multi-threaded mode. ""; 587 ""Consider turning off IMT."");; 588 }; 589 fNSlots = nSlots;; 590}; 591 ; 592////////////////////////////////////////////////////////////////////////////////////////////////; 593/// Helper function to throw an exception if there is a fatal sqlite error, e.g. an I/O error.; 594void RSqliteDS::SqliteError(int errcode); 595{; 596 std::string errmsg = ""SQlite error: "";; 597#if SQLITE_VERSION_NUMBER < 3007015; 598 errmsg += std::to_string(errcode);; 599#else; 600 errmsg += sqlite3_errstr(errcode);; 601#endif; 602 throw std::runtime_error(errmsg);; 603}; 604 ; 605} // namespace RDF; 606",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RSqliteDS_8cxx_source.html:24209,reduce,reduce,24209,doc/master/RSqliteDS_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html,1,['reduce'],['reduce']
Energy Efficiency,"s: n_training_cycles = 5000, n_layers = 4. note that the number of hidden layers in the NN is: n_hidden_layers = n_layers - 2; since there is one input and one output layer. The number of nodes (neurons) is predefined to be:; n_nodes[i] = nvars + 1 - i (where i=1..n_layers); with nvars being the number of variables used in the NN. Hence, the default case is: n_neurons(layer 1 (input)) : nvars; n_neurons(layer 2 (hidden)): nvars-1; n_neurons(layer 3 (hidden)): nvars-1; n_neurons(layer 4 (out)) : 2; This artificial neural network usually needs a relatively large number of cycles to converge (8000 and more). Overtraining can be efficiently tested by comparing the signal and background output of the NN for the events that were used for training and an independent data sample (with equal properties). If the separation performance is significantly better for the training sample, the NN interprets statistical effects, and is hence overtrained. In this case, the number of cycles should be reduced, or the size of the training sample increased. ; Definition at line 130 of file MethodCFMlpANN.cxx. ◆ MethodCFMlpANN() [2/2]. TMVA::MethodCFMlpANN::MethodCFMlpANN ; (; DataSetInfo & ; theData, . const TString & ; theWeightFile . ). constructor from weight file ; Definition at line 149 of file MethodCFMlpANN.cxx. ◆ ~MethodCFMlpANN(). TMVA::MethodCFMlpANN::~MethodCFMlpANN ; (; void ; ). virtual . destructor ; Definition at line 269 of file MethodCFMlpANN.cxx. Member Function Documentation. ◆ AddWeightsXMLTo(). void TMVA::MethodCFMlpANN::AddWeightsXMLTo ; (; void * ; parent); const. virtual . write weights to xml file ; Implements TMVA::MethodBase.; Definition at line 537 of file MethodCFMlpANN.cxx. ◆ Class(). static TClass * TMVA::MethodCFMlpANN::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::MethodCFMlpANN::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::MethodCFMlpANN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodCFMlpANN.html:35749,reduce,reduced,35749,doc/master/classTMVA_1_1MethodCFMlpANN.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodCFMlpANN.html,1,['reduce'],['reduced']
Energy Efficiency,"s::NewArray ; (; Long_t ; nElements, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated array of objects of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5193 of file TClass.cxx. ◆ NewArray() [2/2]. void * TClass::NewArray ; (; Long_t ; nElements, . void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5295 of file TClass.cxx. ◆ NewObject() [1/2]. TClass::ObjectPtr TClass::NewObject ; (; ENewType ; defConstructor = kClassNew, . Bool_t ; quiet = kFALSE . ); const. Definition at line 4992 of file TClass.cxx. ◆ NewObject() [2/2]. TClass::ObjectPtr TClass::NewObject ; (; void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5106 of file TClass.cxx. ◆ NewObjectArray() [1/2]. TClass::ObjectPtr TClass::NewObjectArray ; (; Long_t ; nElements, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated array of objects of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5209 of file TClass.cxx. ◆ NewObjectArray() [2/2]. TClass::ObjectPtr TClass::NewObjectArray ; (; Long_t ; nElements, . void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5310 of file TClass.cxx. ◆ operator=(). TClass & TClass::operator= ; (; const TClass & ; ). privatedelete . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:107557,allocate,allocated,107557,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['allocate'],['allocated']
Energy Efficiency,"s::NewArray ; (; Long_t ; nElements, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated array of objects of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5260 of file TClass.cxx. ◆ NewArray() [2/2]. void * TClass::NewArray ; (; Long_t ; nElements, . void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5362 of file TClass.cxx. ◆ NewObject() [1/2]. TClass::ObjectPtr TClass::NewObject ; (; ENewType ; defConstructor = kClassNew, . Bool_t ; quiet = kFALSE . ); const. Definition at line 5059 of file TClass.cxx. ◆ NewObject() [2/2]. TClass::ObjectPtr TClass::NewObject ; (; void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5173 of file TClass.cxx. ◆ NewObjectArray() [1/2]. TClass::ObjectPtr TClass::NewObjectArray ; (; Long_t ; nElements, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated array of objects of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5276 of file TClass.cxx. ◆ NewObjectArray() [2/2]. TClass::ObjectPtr TClass::NewObjectArray ; (; Long_t ; nElements, . void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5377 of file TClass.cxx. ◆ operator=(). TClass & TClass::operator= ; (; const TClass & ; ). privatedelete . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:107558,allocate,allocated,107558,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['allocate'],['allocated']
Energy Efficiency,"s; Possible options:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.95); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Returns the indices (bins) for the binned weights. Double_t UpperConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise upper estimated density. Double_t LowerConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise lower estimated density. Double_t GetBias(Double_t x) const; Returns the pointwise approximate estimated density bias. Double_t GetError(Double_t x) const; Returns the pointwise sigma of estimated density. void CheckKernelValidity(); Checks if kernel has unit integral, mu = 0 and positive finite sigma conditions. Double_t ComputeKernelL2Norm() const; Computes the kernel's L2 norm. Double_t ComputeKernelSigma2() const; Computes the kernel's sigma squared. Double_t ComputeKernelMu() const; Computes the kernel's mu. Double_t ComputeKernelIntegral() const; Computes the kernel's integral which ought to be unity. Double_t ComputeMidspread(); Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKDE.html:16250,adapt,adaptive,16250,root/html528/TKDE.html,https://root.cern,https://root.cern/root/html528/TKDE.html,4,['adapt'],['adaptive']
Energy Efficiency,"s; complete source code as you receive it, in any medium, provided that; you conspicuously and appropriately publish on each copy an; appropriate copyright notice and disclaimer of warranty; keep intact; all the notices that refer to this License and to the absence of any; warranty; and distribute a copy of this License along with the; Library. You may charge a fee for the physical act of transferring a copy,; and you may at your option offer warranty protection in exchange for a; fee.; ; 2. You may modify your copy or copies of the Library or any portion; of it, thus forming a work based on the Library, and copy and; distribute such modifications or work under the terms of Section 1; above, provided that you also meet all of these conditions:. a) The modified work must itself be a software library. b) You must cause the files modified to carry prominent notices; stating that you changed the files and the date of any change. c) You must cause the whole of the work to be licensed at no; charge to all third parties under the terms of this License. d) If a facility in the modified Library refers to a function or a; table of data to be supplied by an application program that uses; the facility, other than as an argument passed when the facility; is invoked, then you must make a good faith effort to ensure that,; in the event an application does not supply such function or; table, the facility still operates, and performs whatever part of; its purpose remains meaningful. (For example, a function in a library to compute square roots has; a purpose that is entirely well-defined independent of the; application. Therefore, Subsection 2d requires that any; application-supplied function or table used by this function must; be optional: if the application does not supply it, the square; root function must still compute square roots.). These requirements apply to the modified work as a whole. If; identifiable sections of that work are not derived from the Library,; and can be re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/license.html:11250,charge,charge,11250,d/license.html,https://root.cern,https://root.cern/d/license.html,1,['charge'],['charge']
Energy Efficiency,"s; for i in range(1000):; x.setVal(i / 50 - 10); y.setVal(math.sqrt(1.0 * i)); if i % 2:; c.setLabel(""Plus""); else:; c.setLabel(""Minus""); ; # We must explicitly refer to x,y, here to pass the values because; # d is not linked to them (as explained above); if i < 3:; print(x, y, c); print(type(x)); d.add({x, y, c}); ; d.Print(""v""); print(""""); ; # The get() function returns a pointer to the internal copy of the RooArgSet(x,y,c); # supplied in the constructor; row = d.get(); row.Print(""v""); print(""""); ; # Get with an argument loads a specific data point in row and returns; # a pointer to row argset. get() always returns the same pointer, unless; # an invalid row number is specified. In that case a null ptr is returned; d.get(900).Print(""v""); print(""""); ; # Reducing, appending and merging; # -------------------------------------------------------------; ; # The reduce() function returns a dataset which is a subset of the; # original; print(""\n >> d1 has only columns x,c""); d1 = d.reduce({x, c}); d1.Print(""v""); ; print(""\n >> d2 has only column y""); d2 = d.reduce({y}); d2.Print(""v""); ; print(""\n >> d3 has only the points with y>5.17""); d3 = d.reduce(""y>5.17""); d3.Print(""v""); ; print(""\n >> d4 has only columns x, for data points with y>5.17""); d4 = d.reduce({x, c}, ""y>5.17""); d4.Print(""v""); ; # The merge() function adds two data set column-wise; print(""\n >> merge d2(y) with d1(x,c) to form d1(x,c,y)""); d1.merge(d2); d1.Print(""v""); ; # The append() function adds two datasets row-wise; print(""\n >> append data points of d3 to d1""); d1.append(d3); d1.Print(""v""); ; # Operations on binned datasets; # ---------------------------------------------------------; ; # A binned dataset can be constructed empty, an unbinned dataset, or; # from a ROOT native histogram (TH1,2,3); ; print("">> construct dh (binned) from d(unbinned) but only take the x and y dimensions, ""); print("">> the category 'c' will be projected in the filling process""); ; # The binning of real variables (like x,y) i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf402__datahandling_8py.html:2314,reduce,reduce,2314,doc/master/rf402__datahandling_8py.html,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8py.html,1,['reduce'],['reduce']
Energy Efficiency,"s; intermediate formula objects, use the equivalent constructor; accepting RooFormulaVar reference as cut specification. For most uses the RooAbsData::reduce() wrapper function, which; uses this constructor, is the most convenient way to create a; subset of an existing data. RooDataSet(const char *name, const char *title, RooDataSet *dset, 		 const RooArgSet& vars, const RooFormulaVar& cutVar, const char* wgtVarName); Constructor of a data set from (part of) an existing data; set. The dimensions of the data set are defined by the 'vars'; RooArgSet, which can be identical to 'dset' dimensions, or a; subset thereof. The 'cutVar' formula variable is used to select; the subset of data points to be copied. For subsets without; selection on the data points, or involving cuts operating; exclusively and directly on the data set dimensions, the; equivalent constructor with a string based cut expression is; recommended. For most uses the RooAbsData::reduce() wrapper function, which; uses this constructor, is the most convenient way to create a; subset of an existing data. RooDataSet(const char *name, const char *title, TTree *intree, 		 const RooArgSet& vars, const RooFormulaVar& cutVar, const char* wgtVarName); Constructor of a data set from (part of) an ROOT TTRee. The dimensions; of the data set are defined by the 'vars' RooArgSet. For each dimension; specified, the TTree must have a branch with the same name. For category; branches, this branch should contain the numeric index value. Real dimensions; can be constructed from either 'Double_t' or 'Float_t' tree branches. In the; latter case, an automatic conversion is applied. The 'cutVar' formula variable; is used to select the subset of data points to be copied.; For subsets without selection on the data points, or involving cuts; operating exclusively and directly on the data set dimensions, the equivalent; constructor with a string based cut expression is recommended. RooDataSet(const char *name, const char *title, TTree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataSet.html:21177,reduce,reduce,21177,root/html526/RooDataSet.html,https://root.cern,https://root.cern/root/html526/RooDataSet.html,1,['reduce'],['reduce']
Energy Efficiency,"s; otherwise, just call the iterator's destructor. ;  ; typedef void(* DeleteTwoIterators_t) (void *begin, void *end);  ; enum  EProperty { kIsAssociative = (1ULL << ( 2 )); , kIsEmulated = (1ULL << ( 3 )); , kNeedDelete = (1ULL << ( 4 )); , kCustomAlloc = (1ULL << ( 5 )); };  ; typedef void *(* Next_t) (void *iter, const void *end);  iter and end should be pointers to an iterator to be incremented and an iterator that points to the end of the collection, respectively. ;  ;  Static Public Attributes inherited from TVirtualCollectionProxy; static const Int_t fgIteratorArenaSize = 16;  The size of a small buffer that can be allocated on the stack to store iterator-specific information. ;  ;  Protected Types inherited from TGenCollectionProxy; typedef void *(* ArrIterfunc_t) (void *from, size_t size);  ; typedef void *(* Collectfunc_t) (void *from, void *to);  ; typedef ROOT::Detail::TCollectionProxyInfo::Environ< char[64]> Env_t;  ; typedef ROOT::Detail::TCollectionProxyInfo::EnvironBase EnvironBase_t;  ; typedef void *(* Feedfunc_t) (void *from, void *to, size_t size);  ; typedef std::vector< EnvironBase_t * > Proxies_t;  ; typedef void(* Sizing_t) (void *obj, size_t size);  ; typedef std::vector< TStaging * > Staged_t;  Collection of pre-allocated staged array for associative containers. ;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block fee",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEmulatedMapProxy.html:11243,allocate,allocated,11243,doc/master/classTEmulatedMapProxy.html,https://root.cern,https://root.cern/doc/master/classTEmulatedMapProxy.html,1,['allocate'],['allocated']
Energy Efficiency,"s; otherwise, just call the iterator's destructor. ;  ; typedef void(* DeleteTwoIterators_t) (void *begin, void *end);  ; enum  EProperty { kIsAssociative = (1ULL << ( 2 )); , kIsEmulated = (1ULL << ( 3 )); , kNeedDelete = (1ULL << ( 4 )); , kCustomAlloc = (1ULL << ( 5 )); };  ; typedef void *(* Next_t) (void *iter, const void *end);  iter and end should be pointers to an iterator to be incremented and an iterator that points to the end of the collection, respectively. ;  ;  Static Public Attributes inherited from TVirtualCollectionProxy; static const Int_t fgIteratorArenaSize = 16;  The size of a small buffer that can be allocated on the stack to store iterator-specific information. ;  ;  Protected Types inherited from TGenCollectionProxy; typedef void *(* ArrIterfunc_t) (void *from, size_t size);  ; typedef void *(* Collectfunc_t) (void *from, void *to);  ; typedef ROOT::Detail::TCollectionProxyInfo::Environ< char[64]> Env_t;  ; typedef ROOT::Detail::TCollectionProxyInfo::EnvironBase EnvironBase_t;  ; typedef void *(* Feedfunc_t) (void *from, void *to, size_t size);  ; typedef std::vector< EnvironBase_t * > Proxies_t;  ; typedef void(* Sizing_t) (void *obj, size_t size);  ; typedef std::vector< TStaging * > Staged_t;  Collection of pre-allocated staged array for associative containers. ;  ;  Protected Member Functions inherited from TGenCollectionProxy; void CheckFunctions () const;  Check existence of function pointers. ;  ; TGenCollectionProxy * Initialize (Bool_t silent) const;  Proxy initializer. ;  ; virtual TGenCollectionProxy * InitializeEx (Bool_t silent);  Proxy initializer. ;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenBitsetProxy.html:8955,allocate,allocated,8955,doc/master/classTGenBitsetProxy.html,https://root.cern,https://root.cern/doc/master/classTGenBitsetProxy.html,6,['allocate'],['allocated']
Energy Efficiency,"s; public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t); static TGenCollectionProxy::(anonymous)kBIT_ISSTRING; static TGenCollectionProxy::(anonymous)kBIT_ISTSTRING; static TGenCollectionProxy::(anonymous)kBOOL_t; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsAssociative; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsEmulated; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kNeedDelete. protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::Collectfunc_tfCollectMethod to collect objects from container; TGenCollectionProxy::ArrIterfunc_tfConstructContainer accessors: block construct; map<string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; TGenCollectionProxy::Sizing_tfDestructContainer accessors: block destruct; TGenCollectionProxy::EnvironBase_t*fEnvAddress of the currently proxied object; TGenCollectionProxy::Feedfunc_tfFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; TVirtualCollectionProxy::CopyIterator_tfFunctionCopyIterator; TVirtualCollectionProxy::CreateIterators_tfFunctionCreateIterators; TVirtualCollectionProxy::DeleteIterator_tfFunctionDeleteIterator; TVirtualCollectionProxy::DeleteTwoIterators_tfFunctionDeleteTwoIterators; TVirtualCollectionProxy::Next_tfFunctionNextIterator; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGenCollectionProxy.html:4713,allocate,allocate,4713,root/html602/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html602/TGenCollectionProxy.html,2,['allocate'],['allocate']
Energy Efficiency,"s=p_ph_bkg_set, LineColor=""r""); model0.paramOn(frame); ; sigData.plotOn(frame, MarkerColor=""b""); frame.Draw(); ; pt_text1 = [; ""No template uncertainties"",; ""are taken into account."",; ""This leads to low errors"",; ""for the parameters A, since"",; ""the only source of errors"",; ""are the data statistics."",; ]; for text in pt_text1:; pt.AddText(text); ; pt.DrawClone(); ; ; can.cd(2); frame = x.frame(Title=""Barlow Beeston for Sig & Bkg separately""); sumData.plotOn(frame); model1.plotOn(frame, LineColor=""b"", VisualizeError=result1); # Plot data again to show it on top of error bands:; sumData.plotOn(frame); model1.plotOn(frame, LineColor=""b""); p_ph_sig1_set = {p_ph_sig1}; p_ph_bkg1_set = {p_ph_bkg1}; model1.plotOn(frame, Components=p_ph_sig1_set, LineColor=""kAzure""); model1.plotOn(frame, Components=p_ph_bkg1_set, LineColor=""r""); model1.paramOn(frame, Parameters={Asig1, Abkg1}); ; sigData.plotOn(frame, MarkerColor=""b""); frame.Draw(); ; pt.Clear(); pt_text2 = [; ""With gamma parameters, the"",; ""signal & background templates"",; ""can adapt to the data."",; ""Note how the blue signal"",; ""template changes its shape."",; ""This leads to higher errors"",; ""of the scale parameters A."",; ]; ; for text in pt_text2:; pt.AddText(text); ; pt.DrawClone(); ; can.cd(3); frame = x.frame(Title=""Barlow Beeston light for (Sig+Bkg)""); sumData.plotOn(frame); model2.plotOn(frame, LineColor=""b"", VisualizeError=result2); # Plot data again to show it on top of model0 error bands:; sumData.plotOn(frame); model2.plotOn(frame, LineColor=""b""); p_ph_sig2_set = {p_ph_sig2}; p_ph_bkg2_set = {p_ph_bkg2}; model2.plotOn(frame, Components=p_ph_sig2_set, LineColor=""kAzure""); model2.plotOn(frame, Components=p_ph_bkg2_set, LineColor=""r""); model2.paramOn(frame, Parameters={Asig2, Abkg2}); ; sigData.plotOn(frame, MarkerColor=""b""); frame.Draw(); ; pt.Clear(); pt_text3 = [; ""When signal and background"",; ""template share one gamma para-"",; ""meter per bin, they adapt less."",; ""The errors of the A parameters"",; ""also shrink sl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8py.html:6032,adapt,adapt,6032,doc/master/rf709__BarlowBeeston_8py.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8py.html,1,['adapt'],['adapt']
Energy Efficiency,"sArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooEffProd(const char* name, const char* title, RooAbsPdf& pdf, RooAbsReal& efficiency); Constructor of a a production of p.d.f inPdf with efficiency; function inEff. RooEffProd(const RooEffProd& other, const char* name = 0); Copy constructor. ~RooEffProd(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Return p.d.f. value normalized over given set of observables. Double_t evaluate() const; Calculate and return 'raw' unnormalized value of p.d.f. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype, const RooArgSet* auxProto, Bool_t verbose) const; Return specialized generator context for RooEffProds that implements generation; in a more efficient way than can be done for generic correlated products. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return internal integration capabilities of the p.d.f. Given a set 'allVars' for which; integration is requested, returned the largest subset for which internal (analytical); integration is implemented (in argument analVars). The return value is a unique integer; code that identifies the integration configuration (integrated observables and range name). This implementation in RooEffProd catches all integrals without normalization and reroutes them; through a custom integration routine that properly accounts for the use of normalized p.d.f.; in the evaluate() expression, which breaks the default RooAbsPdf normalization handling. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooEffProd.html:42826,efficient,efficient,42826,root/html532/RooEffProd.html,https://root.cern,https://root.cern/root/html532/RooEffProd.html,4,['efficient'],['efficient']
Energy Efficiency,"sArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete(). void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClonesArray.html:14888,allocate,allocate,14888,root/html526/TClonesArray.html,https://root.cern,https://root.cern/root/html526/TClonesArray.html,1,['allocate'],['allocate']
Energy Efficiency,"sContainers()); 1214 SetVisLeaves();; 1215 if (option && option[0] > 0) {; 1216 painter->DrawVolume(this, option);; 1217 } else {; 1218 painter->DrawVolume(this, gEnv->GetValue(""Viewer3D.DefaultDrawOption"", """"));; 1219 }; 1220}; 1221 ; 1222////////////////////////////////////////////////////////////////////////////////; 1223/// draw only this volume; 1224 ; 1225void TGeoVolume::DrawOnly(Option_t *option); 1226{; 1227 if (IsAssembly()) {; 1228 Info(""DrawOnly"", ""Volume assemblies do not support this option."");; 1229 return;; 1230 }; 1231 if (gGeoManager != fGeoManager); 1232 gGeoManager = fGeoManager;; 1233 SetVisOnly();; 1234 TGeoAtt::SetVisRaytrace(kFALSE);; 1235 TVirtualGeoPainter *painter = fGeoManager->GetGeomPainter();; 1236 if (option && option[0] > 0) {; 1237 painter->DrawVolume(this, option);; 1238 } else {; 1239 painter->DrawVolume(this, gEnv->GetValue(""Viewer3D.DefaultDrawOption"", """"));; 1240 }; 1241}; 1242 ; 1243////////////////////////////////////////////////////////////////////////////////; 1244/// Perform an extensive sampling to find which type of voxelization is; 1245/// most efficient.; 1246 ; 1247Bool_t TGeoVolume::OptimizeVoxels(); 1248{; 1249 printf(""Optimizing volume %s ...\n"", GetName());; 1250 TVirtualGeoPainter *painter = fGeoManager->GetGeomPainter();; 1251 return painter->TestVoxels(this);; 1252}; 1253 ; 1254////////////////////////////////////////////////////////////////////////////////; 1255/// Print volume info; 1256 ; 1257void TGeoVolume::Print(Option_t *) const; 1258{; 1259 printf(""== Volume: %s type %s positioned %d times\n"", GetName(), ClassName(), fRefCount);; 1260 InspectShape();; 1261 InspectMaterial();; 1262}; 1263 ; 1264////////////////////////////////////////////////////////////////////////////////; 1265/// paint volume; 1266 ; 1267void TGeoVolume::Paint(Option_t *option); 1268{; 1269 TVirtualGeoPainter *painter = fGeoManager->GetGeomPainter();; 1270 painter->SetTopVolume(this);; 1271 // painter->Paint(option);; 1272 if (option &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:48404,efficient,efficient,48404,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['efficient'],['efficient']
Energy Efficiency,"sList.fArray[ncolors-51]-Idx);; 2962 Bool_t same_alpha = TMath::Abs(alpha-alphas) < 0.0001;; 2963 if (paletteType == ncolors && same_alpha) return; // The current palette is already this one.; 2964 fgPalette.Set(255); // High quality palettes have 255 entries; 2965 for (i=0;i<255;i++) fgPalette.fArray[i] = Idx+i;; 2966 paletteType = ncolors;; 2967 ; 2968 // restore the palette transparency if needed; 2969 if (alphas>0 && !same_alpha) {; 2970 TColor *ca;; 2971 for (i=0;i<255;i++) {; 2972 ca = gROOT->GetColor(Idx+i);; 2973 ca->SetAlpha(alpha);; 2974 }; 2975 fgPalettesList.fArray[paletteType-51] = (Double_t)Idx+alpha/10.;; 2976 }; 2977 return;; 2978 }; 2979 ; 2980 TColor::InitializeColors();; 2981 Double_t stops[9] = { 0.0000, 0.1250, 0.2500, 0.3750, 0.5000, 0.6250, 0.7500, 0.8750, 1.0000};; 2982 ; 2983 switch (ncolors) {; 2984 // Deep Sea; 2985 case 51:; 2986 {; 2987 Double_t red[9] = { 0./255., 9./255., 13./255., 17./255., 24./255., 32./255., 27./255., 25./255., 29./255.};; 2988 Double_t green[9] = { 0./255., 0./255., 0./255., 2./255., 37./255., 74./255., 113./255., 160./255., 221./255.};; 2989 Double_t blue[9] = { 28./255., 42./255., 59./255., 78./255., 98./255., 129./255., 154./255., 184./255., 221./255.};; 2990 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 2991 }; 2992 break;; 2993 ; 2994 // Grey Scale; 2995 case 52:; 2996 {; 2997 Double_t red[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 2998 Double_t green[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 2999 Double_t blue[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 3000 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3001 }; 3002 break;; 3003 ; 3004 // Dark Body Radiator; 3005 case 53:; 3006 {; 3007 Double_t red[9] = { 0./255., 45./255., 99./255., 156./255., 212./255., 230./255.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:111721,green,green,111721,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"sOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tTDecompBase::fColLwbColumn lower bound of decomposed matrix; Double_tTDecompBase::fConditionmatrix condition number; Double_tTDecompBase::fDet1determinant mantissa; Double_tTDecompBase::fDet2determinant exponent for powers of 2; Int_t*fIpiv[fNIpiv] row permutation index; Int_tfNIpivsize of row permutation index; Int_tTDecompBase::fRowLwbRow lower bound of decomposed matrix; Double_tTDecompBase::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1; TMatrixDfUdecomposed matrix so that a = u d u^T; static TDecompBase::EMatrixDecompStatTDecompBase::kCondition; static TDecompBase::EMatrixDecompStatTDecompBase::kDecomposed; static TDecompBase::EMatrixDecompStatTDecompBase::kDetermined; static TDecompBase::EMatrixDecompStatTDecompBase::kInit; static TDecompBase::EMatrixDecompStatTDecompBase::kMatrixSet; static TDecompBase::EMatrixDecompStatTDecompBase::kPatternSet; static TDecompBase::EMatrixDecompStatTDecompBase::kSingular; static TDecompBase::EMatrixDecompStatTDecompBase::kValuesSet; static TDecompBase::(anonymous)TDecompBase::kWorkMax. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecompBK(); Default constructor. TDecompBK(Int_t nrows); Constructor for (nrows x nrows) symmetric matrix. TDecompBK(Int_t row_lwb, Int_t row_upb); Constructor for ([row_lwb..row_upb] x [row_lwb..row_upb]) symmetric matrix. TDecompBK(const TMatrixDSym& m, Double_t tol = 0.); Constructor for symmetric matrix A. TDecompBK(const TDecompBK& another); Copy constructor. Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDecompBK.html:8499,power,powers,8499,root/html602/TDecompBK.html,https://root.cern,https://root.cern/root/html602/TDecompBK.html,2,['power'],['powers']
Energy Efficiency,"sRealLValue& variable, const RooAbsReal& slope, const RooAbsReal& offset, const char* unit = """"); Constructor with RooAbsRealLValue variable and RooAbsReal slope and offset. RooLinearVar(const RooLinearVar& other, const char* name = 0); Copy constructor. ~RooLinearVar(); Destructor. Double_t evaluate() const; Calculate current value of this object. void setVal(Double_t value); Assign given value to linear transformation: sets input variable to (value-offset)/slope; If slope is zerom an error message is printed and no assignment is made. Bool_t isJacobianOK(const RooArgSet& depList) const; Returns true if Jacobian term associated with current; expression tree is indeed constant. Double_t jacobian() const; Return value of Jacobian associated with the transformation. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream. RooAbsBinning& getBinning(const char* name, Bool_t verbose, Bool_t createOnTheFly); Retrieve binning of this linear transformation. A RooLinearVar does not have its own; binnings but uses linearly transformed binnings of teh input variable. If a given; binning exists on the input variable, it will also exists on this linear transformation; and a binning adaptor object is created on the fly. const RooAbsBinning& getBinning(const char* name, Bool_t verbose, Bool_t createOnTheFly); Const version of getBinning(). Bool_t hasBinning(const char* name) const; Returns true if binning with given name exists.If a given binning; exists on the input variable, it will also exists on this linear; transformation. TObject* clone(const char* newname) const; { return new RooLinearVar(*this,newname); }. » Last changed: Mon Dec 7 13:48:08 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooLinearVar.html:38810,adapt,adaptor,38810,root/html526/RooLinearVar.html,https://root.cern,https://root.cern/root/html526/RooLinearVar.html,1,['adapt'],['adaptor']
Energy Efficiency,"sTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance Chart:. TObject. ←; TVirtualMCStack. Function documentation; TVirtualMCStack(); {}. ~TVirtualMCStack(); {}. TVirtualMCStack(); Constructor. void PushTrack(Int_t toBeDone, Int_t parent, Int_t pdg, Double_t px, Double_t py, Double_t pz, Double_t e, Double_t vx, Double_t vy, Double_t vz, Double_t tof, Double_t polx, Double_t poly, Double_t polz, TMCProcess mech, Int_t& ntr, Double_t weight, Int_t is). Methods for stacking. Create a new particle and push into stack;; toBeDone - 1 if particles should go to tracking, 0 otherwise; parent - number of the parent track, -1 if track is primary; pdg - PDG encoding; px, py, pz - particle momentum [GeV/c]; e - total energy [GeV]; vx, vy, vz - position [cm]; tof - time of flight [s]; polx, poly, polz - polarization; mech - creator process VMC code; ntr - track number (is filled by the stack; weight - particle weight; is - generation status code. TParticle* PopPrimaryForTracking(Int_t i); The stack has to provide two pop mechanisms:; The first pop mechanism required.; Pop all particles with toBeDone = 1, both primaries and seconadies; The second pop mechanism required.; Pop only primary particles with toBeDone = 1, stacking of secondaries; is done by MC. void SetCurrentTrack(Int_t trackNumber). Set methods. Set the current track number. Int_t GetNtrack() const. Get methods. Total number of tracks. Int_t GetNprimary() const; Total number of primary tracks. TParticle* GetCurrentTrack() const; Current track particle. Int_t GetCurrentTrackNumber() const; Current track number. Int_t GetCurrentParentTrackNumber() const; Number of the parent of the current track. » Last changed: root/vmc:$Id$ » Last gen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualMCStack.html:7087,energy,energy,7087,root/html602/TVirtualMCStack.html,https://root.cern,https://root.cern/root/html602/TVirtualMCStack.html,2,['energy'],['energy']
Energy Efficiency,"sUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TGeoNode**fArray![fMaxLevel+1] Array of nodes; Int_tfLevelBranch depth; TGeoHMatrixfMatrixGlobal matrix (owned); Int_tfMaxLevelArray length; TGeoNode*fRealArray[1]Beginning address of the array of nodes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBranchArray(Int_t level); Constructor. Alocates the array with a size given by level. TGeoBranchArray * MakeInstance(size_t maxlevel); Make an instance of the class which allocates the node array. To be; released using ReleaseInstance. If addr is non-zero, the user promised that; addr contains at least that many bytes: size_t needed = SizeOf(maxlevel);. TGeoBranchArray * MakeInstanceAt(size_t maxlevel, void* addr); Make an instance of the class which allocates the node array. To be; released using ReleaseInstance. If addr is non-zero, the user promised that; addr contains at least that many bytes: size_t needed = SizeOf(maxlevel);. TGeoBranchArray * MakeCopy(const TGeoBranchArray& other); Make a copy of a branch array at the location (if indicated). TGeoBranchArray * MakeCopyAt(const TGeoBranchArray& other, void* addr); Make a copy of a branch array at the location (if indicated). void CopyTo(TGeoBranchArray* dest); Raw memcpy of the branch array content to an existing destination. void ReleaseInstance(TGeoBranchArray* obj); Releases the space allocated for the object. void UpdateArray(size_t nobj); Updates the internal add",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoBranchArray.html:7991,allocate,allocates,7991,root/html604/TGeoBranchArray.html,https://root.cern,https://root.cern/root/html604/TGeoBranchArray.html,1,['allocate'],['allocates']
Energy Efficiency,"s[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].green = 235; colors[26].blue = 235;; 93 colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate memory for segments; 99 */; 100 ; 101 if (gSize3D.numSegs) {; 102 segs = (segment *) calloc (gSize3D.numSegs, sizeof (segment));; 103 if (!segs) {; 104 puts (""Unable to allocate memory for segments !"");; 105 ret = 0;; 106 }; 107 }; 108 ; 109 ; 110 /*; 111 * Allocate memory for polygons; 112 */; 113 ; 114 if (gSize3D.numPolys) {; 115 polys = (polygon *) calloc(gSize3D.numPolys, sizeof (polygon));; 116 if (!polys) {; 117 puts (""Unable to allocate memory for polygons !"");; 118 ret = 0;; 119 }; 120 }; 121 ; 122 /*; 123 * In case of error, free allocated memory; 124 */; 125 ; 126 ; 127 if (!ret) {; 128 if (points) free (points);; 129 if (colors) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/X3DBuffer_8c_source.html:3336,green,green,3336,doc/master/X3DBuffer_8c_source.html,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html,1,['green'],['green']
Energy Efficiency,"s_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAtt3D; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Types; enum  EXYChecked { ;   kUncheckedXY; , kMalformedXY; , kConvexCCW; , kConvexCW; , ;   kConcaveCCW; , kConcaveCW. };  ; enum  EZChecked { ;   kUncheckedZ; , kMalformedZ; , kConvexIncZ; , kConvexDecZ; , ;   kConcaveIncZ; , kConcaveDecZ. };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; void CheckOrdering ();  Determine ordering over which to process points, segments, surfaces so that they render correctly. ;  ; void SetPoints (Double_t *points) const override;  Create TXTRU points in buffer order as expected by other methods (counterclockwise xy, increasing z) ;  ;  Protected Member Functions inherited from TShape; virtual void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections) const;  We have to set kRawSize (unless already done) to allocate buffer space before kRaw can be filled. ;  ; Int_t GetBasicColor () const;  Get basic color. ;  ; Int_t ShapeDistancetoPrimitive (Int_t numPoints, Int_t px, Int_t py);  Distance to primitive. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Int_t fNxy {0};  ; Int_t fNxyAlloc {0};  ; Int_t fNz {0};  ; Int_t fNzAlloc {0};  ; EXYChecked fPolygonShape {kUncheckedXY};  ; Float_t * fScale {nullptr};  ; Bool_t fSplitConcave {kFALSE};  ; Float_t * fX0 {nullptr};  ; Float_t * fXvtx {nullptr};  ; Float_t * fY0 {nullptr};  ; Float_t * fYvtx {nullptr};  ; Float_t * fZ {nullptr};  ; EZChecked fZOrdering {kUncheckedZ};  ;  Protected Attributes inherited from TShap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXTRU.html:19010,allocate,allocate,19010,doc/master/classTXTRU.html,https://root.cern,https://root.cern/doc/master/classTXTRU.html,1,['allocate'],['allocate']
Energy Efficiency,"sage via Error on case of problems, just return 0.; The constructor actually called here can be customized by using the rootcint pragma: #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass, this method will called the first of the following 3 constructors which exists and is public: MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted.; TRootIOCtorDefinition TRootIOCtor.h:33; When more than one pragma ioctortype is used, the first seen as priority For example with: #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order: MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. Definition at line 4978 of file TClass.cxx. ◆ New() [2/2]. void * TClass::New ; (; void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5091 of file TClass.cxx. ◆ NewArray() [1/2]. void * TClass::NewArray ; (; Long_t ; nElements, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated array of objects of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5193 of file TClass.cxx. ◆ NewArray() [2/2]. void * TClass::NewArray ; (; Long_t ; nElements, . void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5295 of file TClass.cxx. ◆ NewObject() [1/2]. TClass::ObjectPtr TClass::NewObject ; (; ENewType ; defConstructor = kClassNew, . Bool_t ; quiet = kFALSE . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:106344,allocate,allocated,106344,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['allocate'],['allocated']
Energy Efficiency,"sage via Error on case of problems, just return 0.; The constructor actually called here can be customized by using the rootcint pragma: #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass, this method will called the first of the following 3 constructors which exists and is public: MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted.; TRootIOCtorDefinition TRootIOCtor.h:33; When more than one pragma ioctortype is used, the first seen as priority For example with: #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order: MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. Definition at line 5045 of file TClass.cxx. ◆ New() [2/2]. void * TClass::New ; (; void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5158 of file TClass.cxx. ◆ NewArray() [1/2]. void * TClass::NewArray ; (; Long_t ; nElements, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated array of objects of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5260 of file TClass.cxx. ◆ NewArray() [2/2]. void * TClass::NewArray ; (; Long_t ; nElements, . void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5362 of file TClass.cxx. ◆ NewObject() [1/2]. TClass::ObjectPtr TClass::NewObject ; (; ENewType ; defConstructor = kClassNew, . Bool_t ; quiet = kFALSE . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:106345,allocate,allocated,106345,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['allocate'],['allocated']
Energy Efficiency,"sation of rectangular cuts performed by TMVA maximises "" << Endl;; 1729 Log() << ""the background rejection at given signal efficiency, and scans "" << Endl;; 1730 Log() << ""over the full range of the latter quantity. Three optimisation"" << Endl;; 1731 Log() << ""methods are optional: Monte Carlo sampling (MC), a Genetics"" << Endl;; 1732 Log() << ""Algorithm (GA), and Simulated Annealing (SA). GA and SA are"" << Endl;; 1733 Log() << ""expected to perform best."" << Endl;; 1734 Log() << Endl;; 1735 Log() << ""The difficulty to find the optimal cuts strongly increases with"" << Endl;; 1736 Log() << ""the dimensionality (number of input variables) of the problem."" << Endl;; 1737 Log() << ""This behavior is due to the non-uniqueness of the solution space.""<< Endl;; 1738 Log() << Endl;; 1739 Log() << gTools().Color(""bold"") << ""--- Performance optimisation:"" << gTools().Color(""reset"") << Endl;; 1740 Log() << Endl;; 1741 Log() << ""If the dimensionality exceeds, say, 4 input variables, it is "" << Endl;; 1742 Log() << ""advisable to scrutinize the separation power of the variables,"" << Endl;; 1743 Log() << ""and to remove the weakest ones. If some among the input variables"" << Endl;; 1744 Log() << ""can be described by a single cut (e.g., because signal tends to be"" << Endl;; 1745 Log() << ""larger than background), this can be indicated to MethodCuts via"" << Endl;; 1746 Log() << ""the \""Fsmart\"" options (see option string). Choosing this option"" << Endl;; 1747 Log() << ""reduces the number of requirements for the variable from 2 (min/max)"" << Endl;; 1748 Log() << ""to a single one (TMVA finds out whether it is to be interpreted as"" << Endl;; 1749 Log() << ""min or max)."" << Endl;; 1750 Log() << Endl;; 1751 Log() << gTools().Color(""bold"") << ""--- Performance tuning via configuration options:"" << gTools().Color(""reset"") << Endl;; 1752 Log() << """" << Endl;; 1753 Log() << bold << ""Monte Carlo sampling:"" << resbold << Endl;; 1754 Log() << """" << Endl;; 1755 Log() << ""Apart form the \""Fsmart\"" option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:68258,power,power,68258,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['power'],['power']
Energy Efficiency,"saved ...; 365 connection->Remove(this); // remove back reference; 366 if (connection->IsEmpty()) SafeDelete(connection);; 367 continue; // .. continue from saved link; 368 }; 369 }; 370 lnk = lnk->Next();; 371 }; 372 return return_value;; 373}; 374 ; 375////////////////////////////////////////////////////////////////////////////////; 376/// List signal name and list all connections in this signal list.; 377 ; 378void TQConnectionList::ls(Option_t *option) const; 379{; 380 std::cout << ""TQConnectionList:"" << ""\t"" << GetName() << std::endl;; 381 ((TQConnectionList*)this)->R__FOR_EACH(TQConnection,Print)(option);; 382}; 383 ; 384 ; 385////////////////////////////////////////////////////////////////////////////////; 386/// TQObject Constructor.; 387/// Comment:; 388/// - In order to minimize memory allocation fListOfSignals and; 389/// fListOfConnections are allocated only if it is neccesary; 390/// - When fListOfSignals/fListOfConnections are empty they will; 391/// be deleted; 392 ; 393TQObject::TQObject(); 394{; 395 fListOfSignals = nullptr;; 396 fListOfConnections = nullptr;; 397 fSignalsBlocked = kFALSE;; 398}; 399 ; 400////////////////////////////////////////////////////////////////////////////////; 401/// TQObject Destructor.; 402/// - delete all connections and signal list; 403 ; 404TQObject::~TQObject(); 405{; 406 if (!gROOT) return;; 407 ; 408 Destroyed(); // emit ""Destroyed()"" signal; 409 ; 410 if (fListOfSignals) {; 411 fListOfSignals->Delete();; 412 SafeDelete(fListOfSignals); // delete list of signals; 413 }; 414 ; 415 // loop over all connections and remove references to this object; 416 if (fListOfConnections) {; 417 TIter next_connection(fListOfConnections);; 418 TQConnection *connection;; 419 ; 420 while ((connection = (TQConnection*)next_connection())) {; 421 TIter next_list(connection);; 422 TQConnectionList *list;; 423 while ((list = (TQConnectionList*)next_list())) {; 424 list->Remove(connection);; 425 if (list->IsEmpty()) SafeDelete(list);; 426 }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TQObject_8cxx_source.html:12649,allocate,allocated,12649,doc/master/TQObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"scribing a polar 2D coordinate system based on r and phi Phi is restricted to be in the range [-PI,PI) More...;  ; class  ROOT::Math::Polar3D< T >;  Class describing a polar coordinate system based on r, theta and phi Phi is restricted to be in the range [-PI,PI) More...;  ; class  ROOT::Math::PositionVector2D< CoordSystem, Tag >;  Class describing a generic position vector (point) in 2 dimensions. More...;  ; class  ROOT::Math::PositionVector3D< CoordSystem, Tag >;  Class describing a generic position vector (point) in 3 dimensions. More...;  ; class  ROOT::Math::PtEtaPhiE4D< ScalarType >;  Class describing a 4D cylindrical coordinate system using Pt , Phi, Eta and E (or rho, phi, eta , T) The metric used is (-,-,-,+). More...;  ; class  ROOT::Math::PtEtaPhiM4D< ScalarType >;  Class describing a 4D cylindrical coordinate system using Pt , Phi, Eta and M (mass) The metric used is (-,-,-,+). More...;  ; class  ROOT::Math::PxPyPzE4D< ScalarType >;  Class describing a 4D cartesian coordinate system (x, y, z, t coordinates) or momentum-energy vectors stored as (Px, Py, Pz, E). More...;  ; class  ROOT::Math::PxPyPzM4D< ScalarType >;  Class describing a 4D coordinate system or momentum-energy vectors stored as (Px, Py, Pz, M). More...;  ; class  ROOT::Math::Quaternion;  Rotation class with the (3D) rotation represented by a unit quaternion (u, i, j, k). More...;  ; class  ROOT::Math::Rotation3D;  Rotation class with the (3D) rotation represented by a 3x3 orthogonal matrix. More...;  ; class  ROOT::Math::RotationX;  Rotation class representing a 3D rotation about the X axis by the angle of rotation. More...;  ; class  ROOT::Math::RotationY;  Rotation class representing a 3D rotation about the Y axis by the angle of rotation. More...;  ; class  ROOT::Math::RotationZ;  Rotation class representing a 3D rotation about the Z axis by the angle of rotation. More...;  ; class  ROOT::Math::RotationZYX;  Rotation class with the (3D) rotation represented by angles describing first a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__GenVector.html:13317,energy,energy,13317,doc/master/group__GenVector.html,https://root.cern,https://root.cern/doc/master/group__GenVector.html,1,['energy'],['energy']
Energy Efficiency,"se 71:; 3186 {; 3187 Double_t red[9] = { 22./255., 19./255., 19./255., 25./255., 35./255., 53./255., 88./255., 139./255., 210./255.};; 3188 Double_t green[9] = { 0./255., 32./255., 69./255., 108./255., 135./255., 159./255., 183./255., 198./255., 215./255.};; 3189 Double_t blue[9] = { 77./255., 96./255., 110./255., 116./255., 110./255., 100./255., 90./255., 78./255., 70./255.};; 3190 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3191 }; 3192 break;; 3193 ; 3194 // Brown Cyan; 3195 case 72:; 3196 {; 3197 Double_t red[9] = { 68./255., 116./255., 165./255., 182./255., 189./255., 180./255., 145./255., 111./255., 71./255.};; 3198 Double_t green[9] = { 37./255., 82./255., 135./255., 178./255., 204./255., 225./255., 221./255., 202./255., 147./255.};; 3199 Double_t blue[9] = { 16./255., 55./255., 105./255., 147./255., 196./255., 226./255., 232./255., 224./255., 178./255.};; 3200 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3201 }; 3202 break;; 3203 ; 3204 // CMYK; 3205 case 73:; 3206 {; 3207 Double_t red[9] = { 61./255., 99./255., 136./255., 181./255., 213./255., 225./255., 198./255., 136./255., 24./255.};; 3208 Double_t green[9] = { 149./255., 140./255., 96./255., 83./255., 132./255., 178./255., 190./255., 135./255., 22./255.};; 3209 Double_t blue[9] = { 214./255., 203./255., 168./255., 135./255., 110./255., 100./255., 111./255., 113./255., 22./255.};; 3210 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3211 }; 3212 break;; 3213 ; 3214 // Candy; 3215 case 74:; 3216 {; 3217 Double_t red[9] = { 76./255., 120./255., 156./255., 183./255., 197./255., 180./255., 162./255., 154./255., 140./255.};; 3218 Double_t green[9] = { 34./255., 35./255., 42./255., 69./255., 102./255., 137./255., 164./255., 188./255., 197./255.};; 3219 Double_t blue[9] = { 64./255., 69./255., 78./255., 105./255., 142./255., 177./255., 205./255., 217./255., 198./255.};; 3220 Idx = TColor::CreateGradientColor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:122898,green,green,122898,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"se 75:; 3226 {; 3227 Double_t red[9] = { 37./255., 102./255., 157./255., 188./255., 196./255., 214./255., 223./255., 235./255., 251./255.};; 3228 Double_t green[9] = { 37./255., 29./255., 25./255., 37./255., 67./255., 91./255., 132./255., 185./255., 251./255.};; 3229 Double_t blue[9] = { 37./255., 32./255., 33./255., 45./255., 66./255., 98./255., 137./255., 187./255., 251./255.};; 3230 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3231 }; 3232 break;; 3233 ; 3234 // Coffee; 3235 case 76:; 3236 {; 3237 Double_t red[9] = { 79./255., 100./255., 119./255., 137./255., 153./255., 172./255., 192./255., 205./255., 250./255.};; 3238 Double_t green[9] = { 63./255., 79./255., 93./255., 103./255., 115./255., 135./255., 167./255., 196./255., 250./255.};; 3239 Double_t blue[9] = { 51./255., 59./255., 66./255., 61./255., 62./255., 70./255., 110./255., 160./255., 250./255.};; 3240 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3241 }; 3242 break;; 3243 ; 3244 // Dark Rain Bow; 3245 case 77:; 3246 {; 3247 Double_t red[9] = { 43./255., 44./255., 50./255., 66./255., 125./255., 172./255., 178./255., 155./255., 157./255.};; 3248 Double_t green[9] = { 63./255., 63./255., 85./255., 101./255., 138./255., 163./255., 122./255., 51./255., 39./255.};; 3249 Double_t blue[9] = { 121./255., 101./255., 58./255., 44./255., 47./255., 55./255., 57./255., 44./255., 43./255.};; 3250 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3251 }; 3252 break;; 3253 ; 3254 // Dark Terrain; 3255 case 78:; 3256 {; 3257 Double_t red[9] = { 0./255., 41./255., 62./255., 79./255., 90./255., 87./255., 99./255., 140./255., 228./255.};; 3258 Double_t green[9] = { 0./255., 57./255., 81./255., 93./255., 85./255., 70./255., 71./255., 125./255., 228./255.};; 3259 Double_t blue[9] = { 95./255., 91./255., 91./255., 82./255., 60./255., 43./255., 44./255., 112./255., 228./255.};; 3260 Idx = TColor::CreateGradientColorTable(9, sto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:124993,green,green,124993,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"se =4; , ;   kTreeStructure =5. };  . Public Member Functions;  RooNonCPEigenDecay (const char *name, const char *title, RooRealVar &t, RooAbsCategory &tag, RooAbsReal &tau, RooAbsReal &dm, RooAbsReal &avgW, RooAbsReal &delW, RooAbsCategory &rhoQ, RooAbsReal &correctQ, RooAbsReal &a, RooAbsReal &C, RooAbsReal &delC, RooAbsReal &S, RooAbsReal &delS, const RooResolutionModel &model, DecayType type=DoubleSided);  ;  RooNonCPEigenDecay (const char *name, const char *title, RooRealVar &t, RooAbsCategory &tag, RooAbsReal &tau, RooAbsReal &dm, RooAbsReal &avgW, RooAbsReal &delW, RooAbsCategory &rhoQ, RooAbsReal &correctQ, RooAbsReal &wQ, RooAbsReal &a, RooAbsReal &C, RooAbsReal &delC, RooAbsReal &S, RooAbsReal &delS, const RooResolutionModel &model, DecayType type=DoubleSided);  ;  RooNonCPEigenDecay (const RooNonCPEigenDecay &other, const char *name=nullptr);  Copy constructor. ;  ;  RooNonCPEigenDecay (void);  ; TObject * clone (const char *newname) const override;  ; double coefAnalyticalIntegral (Int_t coef, Int_t code, const char *rangeName=nullptr) const override;  correct for the right/wrong charge... ;  ; double coefficient (Int_t basisIndex) const override;  ; void generateEvent (Int_t code) override;  Interface for generation of an event using the algorithm corresponding to the specified code. ;  ; Int_t getCoefAnalyticalIntegral (Int_t coef, RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const override;  Default implementation of function advertising integration capabilities. ;  ; Int_t getGenerator (const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) const override;  Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ;  ; void initGenerator (Int_t code) override;  Interface for one-time initialization to setup the generator for the specified code. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNonCPEigenDecay.html:3865,charge,charge,3865,doc/master/classRooNonCPEigenDecay.html,https://root.cern,https://root.cern/doc/master/classRooNonCPEigenDecay.html,1,['charge'],['charge']
Energy Efficiency,"se energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<double>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<double>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<double>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<double>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<double>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(double pt); ====== Set member functions for coordinates in other systems =======. void SetEta(double eta). void SetPhi(double phi). void SetE(double energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: PxPyPzM4D.h 30568 2009-10-06 07:17:59Z moneta $ » Last generated: 2009-12-07 13:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_double_.html:8138,energy,energy,8138,root/html526/ROOT__Math__PxPyPzM4D_double_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_double_.html,1,['energy'],['energy']
Energy Efficiency,"se energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<double>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<double>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<double>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<double>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<double>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(double pt); ====== Set member functions for coordinates in other systems =======. void SetEta(double eta). void SetPhi(double phi). void SetE(double energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: PxPyPzM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__PxPyPzM4D_double_.html:8138,energy,energy,8138,root/html528/ROOT__Math__PxPyPzM4D_double_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__PxPyPzM4D_double_.html,1,['energy'],['energy']
Energy Efficiency,"se energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<double>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<double>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<double>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<double>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<double>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(double pt); ====== Set member functions for coordinates in other systems =======. void SetEta(double eta). void SetPhi(double phi). void SetE(double energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: PxPyPzM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__PxPyPzM4D_double_.html:8140,energy,energy,8140,root/html530/ROOT__Math__PxPyPzM4D_double_.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__PxPyPzM4D_double_.html,1,['energy'],['energy']
Energy Efficiency,"se energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<double>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<double>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<double>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<double>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<double>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(double pt); ====== Set member functions for coordinates in other systems =======. void SetEta(double eta). void SetPhi(double phi). void SetE(double energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: PxPyPzM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html:8140,energy,energy,8140,root/html532/ROOT__Math__PxPyPzM4D_double_.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html,1,['energy'],['energy']
Energy Efficiency,"se of multi-configuration jobs it it also show the configuration matrix that can be used to select a contrete configuration. See the following figure: ; For each individual build (select one cell in the matrix) the following information is provided:. Status. Shows a summary of the build (changes, errors, warnings, git revision, test results, etc.); Changes. Shows the details about the changes since the last build.; Console Output/View as plain text. Shows the full log of the build including all the steps (checkout, configuration, build, running tests, etc.); Parsed Console Output. The same as previous but with warnings and errors selected.; Parameters. The parameters used for the job.; Environment variables. A table with all the environment variables defined for the job.; Test Result. An interface to the CTest tests results. All test, failing and not failing can be shown with their output. Starting and stopping jobs. New jobs can be launched at any time independently of their automatic scheduling (time based or triggered by changes in the GIT repository). This is done by selecting Build with Parameters from the selected project page. This only enabled when your are logged in. Typically the default parameters should be sufficient unless you want to launch a special job.; Jobs (single or multi-configuration) can be stopped by pressing the small cross in the job build history or in the job status page. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/how-use-root-jenkins.html:5231,schedul,scheduling,5231,d/how-use-root-jenkins.html,https://root.cern,https://root.cern/d/how-use-root-jenkins.html,1,['schedul'],['scheduling']
Energy Efficiency,"se the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete(). void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClonesArray.html:14403,allocate,allocate,14403,root/html526/TClonesArray.html,https://root.cern,https://root.cern/root/html526/TClonesArray.html,1,['allocate'],['allocate']
Energy Efficiency,"se the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClonesArray.html:17056,allocate,allocate,17056,root/html528/TClonesArray.html,https://root.cern,https://root.cern/root/html528/TClonesArray.html,2,['allocate'],['allocate']
Energy Efficiency,"se the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsData.html:16956,reduce,reduced,16956,root/html526/RooAbsData.html,https://root.cern,https://root.cern/root/html526/RooAbsData.html,1,['reduce'],['reduced']
Energy Efficiency,"se(). Int_t TBasket::ReadBasketBuffersUncompressedCase ; (; ). private . By-passing buffer unzipping has been requested and is possible (only 1 entry in this basket). ; Definition at line 358 of file TBasket.cxx. ◆ ReadBasketBuffersUnzip(). Int_t TBasket::ReadBasketBuffersUnzip ; (; char * ; buffer, . Int_t ; size, . bool ; mustFree, . TFile * ; file . ). private . We always create the TBuffer for the basket but it hold the buffer from the cache. ; Definition at line 380 of file TBasket.cxx. ◆ ReadBasketBytes(). Int_t TBasket::ReadBasketBytes ; (; Long64_t ; pos, . TFile * ; file . ). Read basket buffers in memory and cleanup. ; Read first bytes of a logical record starting at position pos return record length (first 4 bytes of record). ; Definition at line 698 of file TBasket.cxx. ◆ ReadResetBuffer(). void TBasket::ReadResetBuffer ; (; Int_t ; basketnumber). protectedvirtual . Reset the read basket TBuffer memory allocation if needed. ; This allows to reduce the number of memory allocation while avoiding to always use the maximum size. ; Definition at line 733 of file TBasket.cxx. ◆ ResetEntryOffset(). void TBasket::ResetEntryOffset ; (; ). private . Definition at line 441 of file TBasket.cxx. ◆ SetBranch(). void TBasket::SetBranch ; (; TBranch * ; branch). inline . Definition at line 148 of file TBasket.h. ◆ SetNevBufSize(). void TBasket::SetNevBufSize ; (; Int_t ; n). inline . Definition at line 149 of file TBasket.h. ◆ SetReadMode(). void TBasket::SetReadMode ; (; ). virtual . Set read mode of basket. ; Definition at line 925 of file TBasket.cxx. ◆ SetWriteMode(). void TBasket::SetWriteMode ; (; ). virtual . Set write mode of basket. ; Definition at line 934 of file TBasket.cxx. ◆ Streamer(). void TBasket::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a class object. ; Reimplemented from TObject.; Reimplemented in TBasketSQL.; Definition at line 943 of file TBasket.cxx. ◆ StreamerNVirtual(). void TBasket::StreamerNVirtual ; (; TBuffer & ; ClassDef_Stream",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBasket.html:28440,reduce,reduce,28440,doc/master/classTBasket.html,https://root.cern,https://root.cern/doc/master/classTBasket.html,1,['reduce'],['reduce']
Energy Efficiency,"seRegulatorzjh; TRandom3*TMVA::MethodANNBase::frgenrandom number generator for various uses. private:. TMVA::MethodMLP::EBPTrainingModefBPModebackprop learning mode (sequential or batch); Int_tfBatchSizebatch size, only matters if in batch learning mode; TStringfBpModeSbackprop learning mode option string (sequential or batch); boolfCalculateErrorscompute inverse hessian matrix at the end of the training; Double_tfDecayRatedecay rate for above learning rate; vector<std::pair<Float_t,Float_t> >*fDeviationsFromTargetsdeviation from the targets, event weight; Bool_tfEpochMoncreate and fill epoch-wise monitoring histograms (makes outputfile big!); Double_tfGA_SC_factorGA settings: SC_factor; Int_tfGA_SC_rateGA settings: SC_rate; Int_tfGA_SC_stepsGA settings: SC_steps; Int_tfGA_nstepsGA settings: number of steps; Int_tfGA_preCalcGA settings: number of pre-calc steps; Double_tfLastAlphaline search variable; Double_tfLearnRatelearning rate for synapse weight adjustments; Double_tfPriorzjh; vector<Double_t>fPriorDevzjh; Int_tfResetStepreset time (how often we clear hessian matrix); Float_tfSamplingEpochfraction of epochs where sampling is used; Float_tfSamplingFractionfraction of events which is sampled for training; Bool_tfSamplingTestingThe testing sample is sampled; Bool_tfSamplingTrainingThe training sample is sampled; Float_tfSamplingWeightchanging factor for event weights when sampling is turned on; Double_tfTauline search variable; Int_tfTestRatetest for overtraining performed at each #th epochs; TStringfTrainMethodStraining method option param; TMVA::MethodMLP::ETrainingMethodfTrainingMethodmethod of training, BP or GA; Int_tfUpdateLimitzjh; boolfUseRegulatorzjh; Float_tfWeightRangesuppress outliers for the estimator calculation; static const Bool_tfgPRINT_BATCHdebug flags; static const Int_tfgPRINT_ESTIMATOR_INCdebug flags; static const Bool_tfgPRINT_SEQdebug flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodMLP.html:21054,monitor,monitoring,21054,root/html530/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodMLP.html,3,['monitor'],['monitoring']
Energy Efficiency,"sed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) {; fIntegrator = CreateIntegrator(type, absTol, relTol, ncall);; SetFunction(f, dim);; }; destructor. IntegratorMultiDim(const ROOT::Math::IntegratorMultiDim& ); disable copy constructur and assignment operator. {}. IntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. double Integral(const ROOT::Math::IMultiGenFunction& f, const double* x",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorMultiDim.html:3990,adapt,adaptive,3990,root/html528/ROOT__Math__IntegratorMultiDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorMultiDim.html,6,['adapt'],['adaptive']
Energy Efficiency,"see html manual and references; Double_tfSigmaCalccalculated value of sigma parameter; Double_tfSigmaErrerror value of sigma parameter; Double_tfSigmaInitinitial value of sigma parameter; Int_tfStatisticTypetype of statistics, possible values kFitOptimChiCounts (chi square statistics with counts as weighting coefficients), kFitOptimChiFuncValues (chi square statistics with function values as weighting coefficients),kFitOptimMaxLikelihood; Double_tfTCalccalculated value of t parameter; Double_tfTErrerror value of t parameter; Double_tfTInitinitial value of t parameter (relative amplitude of tail), for details see html manual and references; TStringTNamed::fTitleobject title; Int_tfXmaxlast fitted channel; Int_tfXminfirst fitted channel. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TSpectrumFit. Function documentation; TSpectrumFit(); default constructor. TSpectrumFit(Int_t numberPeaks); numberPeaks: number of fitted peaks (must be greater than zero); the constructor allocates arrays for all fitted parameters (peak positions, amplitudes etc) and sets the member; variables to their default values. One can change these variables by member functions (setters) of TSpectrumFit class. . Shape function of the fitted; peaks is .  ;  ;  ;  ;  ;  ;  ;  . where a represents vector of; fitted parameters (positions p(j), amplitudes A(j), sigma, relative amplitudes; T, S and slope B).;  . ~TSpectrumFit(); destructor. Double_t Erfc(Double_t x). AUXILIARY FUNCTION. This function calculates error function of x. Double_t Derfc(Double_t x). AUXILIARY FUNCTION. This function calculates derivative of error function of x. Double_t Deramp(Double_t i, Double_t i0, Double_t sigma, Double_t t, Double_t s, Double_t b). AUXILIARY FUNCTION. This function calculates derivative of peak shape function (see manual); according to amplitude of peak.; Function parameters:; -i-channel; -i0-position of peak; -sigma-sigma of peak; -t, s-relative amplitudes; -b-slope. Double_t Deri0(Double_t i, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrumFit.html:14288,allocate,allocates,14288,root/html602/TSpectrumFit.html,https://root.cern,https://root.cern/root/html602/TSpectrumFit.html,2,['allocate'],['allocates']
Energy Efficiency,"seem to misinterpret ""backward compatibility"" (which means ""what used to work will continue to work"") with ""no change"" - but that might just have been your motivation to take the time for writing your feedback, so I don't complain :-) Given the relevance of your comments I decided to reply in a separate blog post.; Cheers, Axel. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:50 Permalink . Thank you for the very nice . Thank you for the very nice explanation of CINT vs cling issue. I did not know that Reflex relies on CINT. The proposed upgrade to cling sounds very promising indeed. By the way, we will also need to consider backward compatibility as experiments will still need to read data already recorded in 2010/2011. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:50 Permalink . Re: Backward Compatibility . Hi ROOT user,; Thanks for your comment! And yes, backward compatibility is key in this area. I will do all I can do reduce the amount of code we need to maintain only for backward compatibility reasons - e.g. Reflex can hopefully be removed instead of being rewired to tap the clang AST (i.e. the cling reflection database). But at the same time we will make sure that all data stored by the experiments remains readable (ideally even from 2001 :-).; This is mostly an issue of type names; CINT has some non-obvious (and non-standard compliant) naming conventions for types, and we must make sure that cling continues to understand them. Or we cannot read an edm::TaggedVector anymore (because CINT would have called it an edm::TaggedVector).; We plan to release a snapshot of ROOT using cling in the third quarter of 2012; we will really appreciate feedback on problems with reading old files - as you correctly pointed out this is one of the most crucial ingredients of this project.; Cheers, Axel. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:50 Permalink . Thank you for clarifying a . Thank you for clarifying a transition plan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:13607,reduce,reduce,13607,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['reduce'],['reduce']
Energy Efficiency,"sequence is that now when an object is stored in a split branch the rule is associtated with the branch of the last of the rule’s sources rather than the last of the object’s data member.; Properly support TStreamerInfo written by ROOT v4.00.; Fix the ordering of the keys in a TFile being written; in particular fixing the result of GetKey and FindKey which were no longer returning the lastest cycle for a TFile being written since v5.34/11. Networking Libraries; HTTP Server; Command Interface; One can now register an arbitrary command to the server, which become visible in the web browser. Then, when the item is clicked by the user, the command ends-up in a gROOT->ProcessLineSync() call.; Custom Properties; Custom properties can be configured for any item in the server. For example, one could configure an icon for each item visible in the browser. Or one could ‘hide’ any item from the user (but keep access with normal http requests). With such properties one could specify which item is drawn when web page is loaded, or configure monitoring. See tutorials/http/httpcontrol.C macro for more details.; Method Calls; Implement exe.json requests to be able to execute any method of registered objects. This request is used to provide remote TTree::Draw() functionality.; Misc; Correctly set ‘Cache-Control’ headers when replying to http requests. Better support of STL containers when converting objects into json with TBufferJSON class.; JavaScript ROOT. Several files can now be loaded simultaneously; Use d3.time.scale to display time scales; Implemented drag and drop to superimpose histograms or graphs; Allow selection of drawing option via context menu; Better support of touch devices; Provide simple layout, making it default; Allow to open ROOT files in online session (via url parameter); One could monitor simultaneously objects from server and root files; Implement ‘autocol’ draw option - when superimposing histograms, their line colors will be automatically assigned; Impleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:9297,monitor,monitoring,9297,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['monitor'],['monitoring']
Energy Efficiency,"ses are based on a generic type of coordinate system, expressed as a template parameter of the class. Various classes exist to describe the various coordinates systems:; 2D coordinate system classes:; ROOT::Math::Cartesian2D, based on (x,y) ;; ROOT::Math::Polar2D, based on (r, phi) ;. 3D coordinate system classes:; ROOT::Math::Cartesian3D, based on (x,y,z);; ROOT::Math::Polar3D, based on (r, theta, phi);; ROOT::Math::Cylindrical3D, based on (rho, z, phi); ROOT::Math::CylindricalEta3D, based on (rho, eta, phi);. 4D coordinate system classes:; ROOT::Math::PxPyPzE4D, based on based on (px,py,pz,E);; ROOT::Math::PxPyPzM4D, based on based on (px,py,pz,M);; ROOT::Math::PtEtaPhiE4D, based on based on (pt,eta,phi,E);; ROOT::Math::PtEtaPhiM4D, based on based on (pt,eta,phi,M);. The angle theta is defined between [0, \(\pi\)] and phi between [- \(\pi\), \(\pi\)]. The angles are expressed in radians. The eta component is known as pseudo-rapidity.; Users can define the Vectors according to the coordinate type which is most efficient for their use. Transformations between the various coordinate systems are available through copy constructors or the assignment operator =. The coordinate system classes are templated on the scalar type for maximum flexibility, and to minimize memory usage for some use cases. Coordinate System Tag; The 2D and 3D point and vector classes can be associated to a tag defining the coordinate system. This can be used to distinguish between vectors of different coordinate systems like global or local vectors. The coordinate system tag is a template parameter of the ROOT::Math::DisplacementVector3D (and ROOT::Math::DisplacementVector2D) and ROOT::Math::PositionVector3D (and ROOT::Math::PositionVector2D) classes. A default tag, ROOT::Math::DefaultCoordinateSystemTag, exists for users who don't need this functionality. Concrete Vector typedefs; To avoid exposing templated parameters to the users, typedefs are defined for all types of vectors based an doubles ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__GenVector.html:2626,efficient,efficient,2626,doc/master/group__GenVector.html,https://root.cern,https://root.cern/doc/master/group__GenVector.html,1,['efficient'],['efficient']
Energy Efficiency,"sh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » About Project Founders. Rene Brun ; ; Rene, a lifetime developer of ROOT. He joined CERN in 1973. While working with C. Rubbia at the ISR he developped the HBOOK package still in use today. In 1975 he followed Rubbia in the NA4 deep inelastic muon scattering experiment at the SPS where he was in charge of the simulation and reconstruction software and where GEANT1 and GEANT2 were created. In 1981, he joined OPAL at LEP, creating the GEANT3 detector simulation system, also pioneering the introduction of the first workstations like Apollos in Europe. In 1984 he coordinated the development of the PAW (Physics Analysis Workstation) data analysis system. Until 1994 he was in charge of the Application Software group in the computing division. In 1995, at a time when the majority of software gurus had decided to follow a dead-end line, he created the ROOT system while working for the NA49 heavy ion experiment at the SPS. Rene has led the ROOT project from 1995-2010.; ; . Fons Rademakers ; ; Fons received his Ph.D. in particle physics from the Univ. of Amsterdam in 1991 for his work on event displays and data analysis for the DELPHI experiment at CERN's LEP collider. Since then he has worked at CERN and been involved in designing and developing data analysis programs. In 1991 he joined the PAW project where he developed the column wise-ntuples (a column-oriented storage system) and PIAF, a parallel data analysis system. In 1995, while working as Linux evangelist for Hewlett-Packard at CERN, he started with Rene Brun the ROOT project and has been involved in all aspects of the system since then. In 2001 Fons joined the ALICE collaboration and has worked as software architect on the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/project-founders.html:2532,charge,charge,2532,d/project-founders.html,https://root.cern,https://root.cern/d/project-founders.html,1,['charge'],['charge']
Energy Efficiency,"sher criterium in node splitting ; Definition at line 208 of file DecisionTree.h. ◆ fMinNodeSize. Double_t TMVA::DecisionTree::fMinNodeSize. private . min fraction of training events in node ; Definition at line 215 of file DecisionTree.h. ◆ fMinSepGain. Double_t TMVA::DecisionTree::fMinSepGain. private . min number of separation gain to perform node splitting ; Definition at line 216 of file DecisionTree.h. ◆ fMinSize. Double_t TMVA::DecisionTree::fMinSize. private . min number of events in node ; Definition at line 214 of file DecisionTree.h. ◆ fMyTrandom. TRandom3* TMVA::DecisionTree::fMyTrandom. private . random number generator for randomised trees ; Definition at line 230 of file DecisionTree.h. ◆ fNCuts. Int_t TMVA::DecisionTree::fNCuts. private . number of grid point in variable cut scans ; Definition at line 206 of file DecisionTree.h. ◆ fNNodesBeforePruning. Int_t TMVA::DecisionTree::fNNodesBeforePruning. private . remember this one (in case of pruning, it allows to monitor the before/after ; Definition at line 222 of file DecisionTree.h. ◆ fNodePurityLimit. Double_t TMVA::DecisionTree::fNodePurityLimit. private . purity limit to decide whether a node is signal ; Definition at line 224 of file DecisionTree.h. ◆ fNvars. UInt_t TMVA::DecisionTree::fNvars. private . number of variables used to separate S and B ; Definition at line 205 of file DecisionTree.h. ◆ fPruneMethod. EPruneMethod TMVA::DecisionTree::fPruneMethod. private . method used for pruning ; Definition at line 221 of file DecisionTree.h. ◆ fPruneStrength. Double_t TMVA::DecisionTree::fPruneStrength. private . a parameter to set the ""amount"" of pruning..needs to be adjusted ; Definition at line 219 of file DecisionTree.h. ◆ fRandomisedTree. Bool_t TMVA::DecisionTree::fRandomisedTree. private . choose at each node splitting a random set of variables ; Definition at line 226 of file DecisionTree.h. ◆ fRegType. RegressionVariance* TMVA::DecisionTree::fRegType. private . the separation criteria used ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html:29240,monitor,monitor,29240,doc/master/classTMVA_1_1DecisionTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html,1,['monitor'],['monitor']
Energy Efficiency,"sibility(const std::vector< std::string > &path, bool on)Change visibility for specified element Returns true if changes was performed.Definition RGeomData.cxx:1850; ROOT::RGeomDescription::fSearchstd::string fSearch! search string in hierarchyDefinition RGeomData.hxx:255; ROOT::RGeomDescription::fSearchJsonstd::string fSearchJson! drawing json for searchDefinition RGeomData.hxx:256; ROOT::RGeomDescription::SavePrimitivevoid SavePrimitive(std::ostream &fs, const std::string &name)Save geometry configuration as C++ macro.Definition RGeomData.cxx:2143; ROOT::RGeomDescription::ClearAllPhysVisibilitybool ClearAllPhysVisibility()Reset all custom visibility settings.Definition RGeomData.cxx:2089; ROOT::RGeomDescription::MakeDrawingJsonstd::string MakeDrawingJson(RGeomDrawing &drawing, bool has_shapes=false)Produce JSON for the drawing If TGeoShape appears in the drawing, one has to keep typeinfo But in thi...Definition RGeomData.cxx:1826; ROOT::RGeomDescription::fActualLevelint fActualLevel! level can be reduced when selecting nodesDefinition RGeomData.hxx:259; ROOT::RGeomDescription::GetVolumeTGeoVolume * GetVolume(int nodeid)Get volume for specified nodeid If specific volume was configured, it will be returned for nodeid==0.Definition RGeomData.cxx:583; ROOT::RGeomDescription::GetNumNodesint GetNumNodes() constNumber of unique nodes in the geometry.Definition RGeomData.hxx:369; ROOT::RGeomDescription::ProduceDrawDatavoid ProduceDrawData()Collect all information required to draw geometry on the client This includes list of each visible no...Definition RGeomData.cxx:1358; ROOT::RGeomDescription::SetNSegmentsvoid SetNSegments(int n=0)Set number of segments for cylindrical shapes, if 0 - default value will be used.Definition RGeomData.hxx:342; ROOT::RGeomDescription::SetPhysNodeVisibilitybool SetPhysNodeVisibility(const std::vector< std::string > &path, bool on=true)Set visibility of physical node by path It overrules TGeo visibility flags - but only for specific ph...Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RGeomData_8cxx_source.html:79395,reduce,reduced,79395,doc/v632/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RGeomData_8cxx_source.html,1,['reduce'],['reduced']
Energy Efficiency,"sibility(const std::vector< std::string > &path, bool on)Change visibility for specified element Returns true if changes was performed.Definition RGeomData.cxx:1850; ROOT::RGeomDescription::fSearchstd::string fSearch! search string in hierarchyDefinition RGeomData.hxx:255; ROOT::RGeomDescription::fSearchJsonstd::string fSearchJson! drawing json for searchDefinition RGeomData.hxx:256; ROOT::RGeomDescription::SavePrimitivevoid SavePrimitive(std::ostream &fs, const std::string &name)Save geometry configuration as C++ macro.Definition RGeomData.cxx:2143; ROOT::RGeomDescription::ClearAllPhysVisibilitybool ClearAllPhysVisibility()Reset all custom visibility settings.Definition RGeomData.cxx:2089; ROOT::RGeomDescription::MakeDrawingJsonstd::string MakeDrawingJson(RGeomDrawing &drawing, bool has_shapes=false)Produce JSON for the drawing If TGeoShape appears in the drawing, one has to keep typeinfo But in thi...Definition RGeomData.cxx:1826; ROOT::RGeomDescription::fActualLevelint fActualLevel! level can be reduced when selecting nodesDefinition RGeomData.hxx:259; ROOT::RGeomDescription::GetVolumeTGeoVolume * GetVolume(int nodeid)Get volume for specified nodeid If specific volume was configured, it will be returned for nodeid==0.Definition RGeomData.cxx:583; ROOT::RGeomDescription::GetNumNodesint GetNumNodes() constNumber of unique nodes in the geometry.Definition RGeomData.hxx:371; ROOT::RGeomDescription::ProduceDrawDatavoid ProduceDrawData()Collect all information required to draw geometry on the client This includes list of each visible no...Definition RGeomData.cxx:1358; ROOT::RGeomDescription::SetNSegmentsvoid SetNSegments(int n=0)Set number of segments for cylindrical shapes, if 0 - default value will be used.Definition RGeomData.hxx:342; ROOT::RGeomDescription::SetPhysNodeVisibilitybool SetPhysNodeVisibility(const std::vector< std::string > &path, bool on=true)Set visibility of physical node by path It overrules TGeo visibility flags - but only for specific ph...Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:79396,reduce,reduced,79396,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,1,['reduce'],['reduced']
Energy Efficiency,"sification with 2 classes. ;  ; virtual TClass * IsA () const;  ; void PrintCuts (Double_t effS) const;  print cuts ;  ; void ProcessOptions ();  process user options. ;  ; virtual void ReadWeightsFromStream (std::istream &)=0;  ; void ReadWeightsFromStream (std::istream &i);  read the cuts from stream ;  ; virtual void ReadWeightsFromStream (TFile &);  ; void ReadWeightsFromXML (void *wghtnode);  read coefficients from xml weight file ;  ; void SetTestSignalEfficiency (Double_t effS);  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void TestClassification ();  nothing to test ;  ; void Train (void);  training method: here the cuts are optimised for the training sample ;  ; void WriteMonitoringHistosToFile (void) const;  write histograms and PDFs to file for monitoring purposes ;  ;  Public Member Functions inherited from TMVA::MethodBase;  MethodBase (const TString &jobName, Types::EMVA methodType, const TString &methodTitle, DataSetInfo &dsi, const TString &theOption="""");  standard constructor ;  ;  MethodBase (Types::EMVA methodType, DataSetInfo &dsi, const TString &weightFile);  constructor used for Testing + Application of the MVA, only (no training), using given WeightFiles ;  ; virtual ~MethodBase ();  destructor ;  ; void AddOutput (Types::ETreeType type, Types::EAnalysisType analysisType);  ; TDirectory * BaseDir () const;  returns the ROOT directory where info/histograms etc of the corresponding MVA method instance are stored ;  ; DataSet * Data () const;  ; DataSetInfo & DataInfo () const;  ; virtual void DeclareCompatibilityOptions ();  options that are used ONLY for the READER to ensure backward compatibility they are hence without any effect (the reader is only reading the training options that HAD been used at the training of the .xml weight file at hand ;  ; void DisableWriting (Bool_t setter);  ; Bool_t DoMulticlass () const;  ; Bool_t DoRegression () const;  ; void ExitFromTraining ();  ; Typ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html:5694,monitor,monitoring,5694,doc/master/classTMVA_1_1MethodCuts.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html,1,['monitor'],['monitoring']
Energy Efficiency,"sificationSettingsSettings for classificationused to distinguish between different function signatures.Definition NeuralNet.h:895; TMVA::DNN::ClassificationSettings::startTrainCyclevoid startTrainCycle()action to be done when the training cycle is started (e.g.Definition NeuralNet.cxx:281; TMVA::DNN::ClassificationSettings::testIterationvoid testIteration()callback for monitoring and logggingDefinition NeuralNet.h:930; TMVA::DNN::ClassificationSettings::endTrainCyclevoid endTrainCycle(double)action to be done when the training cycle is ended (e.g.Definition NeuralNet.cxx:296; TMVA::DNN::ClassificationSettings::endTestCyclevirtual void endTestCycle()action to be done when the training cycle is ended (e.g.Definition NeuralNet.cxx:326; TMVA::DNN::ClassificationSettings::m_pResultPatternContainerstd::vector< Pattern > * m_pResultPatternContainerDefinition NeuralNet.h:1009; TMVA::DNN::ClassificationSettings::setResultComputationvoid setResultComputation(std::string _fileNameNetConfig, std::string _fileNameResult, std::vector< Pattern > *_resultPatternContainer)preparation for monitoring outputDefinition NeuralNet.cxx:520; TMVA::DNN::ClassificationSettings::m_fileNameResultstd::string m_fileNameResultDefinition NeuralNet.h:1010; TMVA::DNN::ClassificationSettings::ClassificationSettingsClassificationSettings(TString name, size_t _convergenceSteps=15, size_t _batchSize=10, size_t _testRepetitions=7, double _factorWeightDecay=1e-5, EnumRegularization _regularization=EnumRegularization::NONE, size_t _scaleToNumEvents=0, MinimizerType _eMinimizerType=MinimizerType::fSteepest, double _learningRate=1e-5, double _momentum=0.3, int _repetitions=3, bool _useMultithreading=true)c'torDefinition NeuralNet.h:901; TMVA::DNN::ClassificationSettings::m_inputstd::vector< double > m_inputDefinition NeuralNet.h:995; TMVA::DNN::ClassificationSettings::m_significancesstd::vector< double > m_significancesDefinition NeuralNet.h:1001; TMVA::DNN::ClassificationSettings::m_sumOfSigWeightsdouble m_s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:51287,monitor,monitoring,51287,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['monitor'],['monitoring']
Energy Efficiency,"sigData.plotOn(frame, MarkerColor=""b""); frame.Draw(); ; pt.Clear(); pt_text2 = [; ""With gamma parameters, the"",; ""signal & background templates"",; ""can adapt to the data."",; ""Note how the blue signal"",; ""template changes its shape."",; ""This leads to higher errors"",; ""of the scale parameters A."",; ]; ; for text in pt_text2:; pt.AddText(text); ; pt.DrawClone(); ; can.cd(3); frame = x.frame(Title=""Barlow Beeston light for (Sig+Bkg)""); sumData.plotOn(frame); model2.plotOn(frame, LineColor=""b"", VisualizeError=result2); # Plot data again to show it on top of model0 error bands:; sumData.plotOn(frame); model2.plotOn(frame, LineColor=""b""); p_ph_sig2_set = {p_ph_sig2}; p_ph_bkg2_set = {p_ph_bkg2}; model2.plotOn(frame, Components=p_ph_sig2_set, LineColor=""kAzure""); model2.plotOn(frame, Components=p_ph_bkg2_set, LineColor=""r""); model2.paramOn(frame, Parameters={Asig2, Abkg2}); ; sigData.plotOn(frame, MarkerColor=""b""); frame.Draw(); ; pt.Clear(); pt_text3 = [; ""When signal and background"",; ""template share one gamma para-"",; ""meter per bin, they adapt less."",; ""The errors of the A parameters"",; ""also shrink slightly."",; ]; for text in pt_text3:; pt.AddText(text); pt.DrawClone(); ; ; print(""Asig [normal ] = {} +/- {}"".format(Asig0.getVal(), Asig0.getError())); print(""Asig [BB ] = {} +/- {}"".format(Asig1.getVal(), Asig1.getError())); print(""Asig [BBlight] = {} +/- {}"".format(Asig2.getVal(), Asig2.getError())); ; can.SaveAs(""rf709_BarlowBeeston.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char dep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8py.html:6910,meter,meter,6910,doc/master/rf709__BarlowBeeston_8py.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8py.html,2,"['adapt', 'meter']","['adapt', 'meter']"
Energy Efficiency,"signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; Bool_t HandleTimer (TTimer *timer) override;  Send feedback objects to client. ;  ; Int_t MakeSelector (const char *selfile);  Create the selector object and save the relevant files and binary information in the cache so that the worker can pick it up. ;  ; void SetupFeedback () override;  Setup reporting of feedback objects. ;  ;  Protected Member Functions inherited from TProofPlayerRemote; TProof * GetProof () const;  ; Bool_t HandleTimer (TTimer *timer) override;  Send feedback objects to client. ;  ; Int_t InitPacketizer (TDSet *dset, Long64_t nentries, Long64_t first, const char *defpackunit, const char *defpackdata);  Init the packetizer Return 0 on success (fPacketizer is correctly initialized), -1 on failure. ;  ; TList * MergeFeedback ();  Merge feedback lists. ;  ; Bool_t MergeOutputFiles ();  Merge output in files. ;  ; void NotifyMemory (TObject *obj);  Printout the memory record after merging object 'obj' This record is used by the memory monitor. ;  ; virtual Bool_t SendSelector (const char *selector_file);  Send the selector file(s) to master or worker nodes. ;  ; void SetLastMergingMsg (TObject *obj);  Set the message to be notified in case of exception. ;  ; void SetSelectorDataMembersFromOutputList ();  Set the selector's data members: find the mapping of data members to otuput list entries in the output list and apply it. ;  ; void SetupFeedback () override;  Setup reporting of feedback objects. ;  ; void StopFeedback () override;  Stop reporting of feedback objects. ;  ;  Protected Member Functions inherited from TProofPlayer; Int_t AssertSelector (const char *selector_file);  Make sure that a valid selector object Return -1 in case of problems, 0 otherwise. ;  ; Bool_t CheckMemUsage (Long64_t &mfreq, Bool_t &w80r, Bool_t &w80v, TString &wmsg);  Check the memory usage, if requested. ;  ; virtual Int_t DrawCanvas (TObject *obj);  Draw the object if it is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:21598,monitor,monitor,21598,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,1,['monitor'],['monitor']
Energy Efficiency,"silon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSparse<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t nr_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSparse_float_.html:17536,allocate,allocated,17536,root/html528/TMatrixTSparse_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_float_.html,4,['allocate'],['allocated']
Energy Efficiency,simple implementation of the DistributionCreator interface used for debugging ;  CDebuggingTestStatDebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging ;  CDiscrDistFree functions adapter needed by UNURAN for one-dimensional discrete distribution ;  CDUMMY;  CEditor;  CEvent_t;  CExceptionContext_t;  CFeldmanCousinsBinomialInterval;  CFeldmanCousinsSorter;  CFileStat_t;  CFontAttributes_t;  CFontMetrics_t;  CFoption_t;  CFUMILI2;  Cfuncptr_and_voidptr_t;  CGaussFunction;  CGcCache_t;  CGCValues_t;  Cgroup;  CGSL_BFGS;  CGSL_BFGS2;  CGSL_FR;  CGSL_NLS;  CGSL_PR;  Ch1analysis;  Ch1analysisTreeReader;  CHelperOps;  CHEPEVT_DEFHEPEVT common block ;  CHit;  CHoption_tHistogram option structure ;  CHparam_tHistogram parameters structure ;  CJet;  CJetEvent;  CLINEAR;  CMemInfo_t;  Cmg_callbacks;  Cmg_client_options;  Cmg_form_data_handler;  Cmg_option;  ►Cmg_request_info;  Cmg_header;  Cmg_server_ports;  CMINUIT2;  CMultiDistFree functions adapter needed by UNURAN for multidimensional cont distribution ;  CMYSQL_BIND;  CMYSQL_STMT;  CNuMuToNuE_Oscillation;  ►CParamHistFunc;  CCacheElem;  CPassiveKeyGrab;  Cpasswd;  CPattern;  CPgSQL_Stmt_t;  CPictureAttributes_t;  ►CPiecewiseInterpolation;  CCacheElem;  CPoint_t;  CProcInfo_t;  CProofServEnv_t;  Cpthread_cond_t;  CPybins_tPythia6 common block Pybins ;  CPydat1_tPythia6 common block Pydat1 ;  CPydat2_tPythia6 common block Pydat2 ;  CPydat3_tPythia6 common block Pydat3 ;  CPydat4_tPythia6 common block Pydat4 ;  CPydatr_tPythia6 common block Pydatr ;  CPyint1_tPythia6 common block Pyint1 ;  CPyint2_tPythia6 common block Pyint2 ;  CPyint3_tPythia6 common block Pyint3 ;  CPyint4_tPythia6 common block Pyint4 ;  CPyint5_tPythia6 common block Pyint5 ;  CPyint6_tPythia6 common block Pyint6 ;  CPyint7_tPythia6 common block Pyint7 ;  CPyint8_tPythia6 common block Pyint8 ;  CPyint9_tPythia6 common block Pyint9 ;  CPyints_tPythia6 common block Pyints ;  CPyjets_tPythia6 common block Pyje,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:82186,adapt,adapter,82186,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['adapt'],['adapter']
Energy Efficiency,"sing time. The number of filled bins is returned by; THnSparse::GetNbins(); the bin content for each (linear) bin number can; be retrieved by THnSparse::GetBinContent(linidx, (Int_t*)coord).; After the call, coord will contain the bin coordinate of each axis for the bin; with linear index linidx. A possible call would be; cout << hs.GetBinContent(0, coord);; cout <<"" is the content of bin [x = "" << coord[0] ""; << "" | y = "" << coord[1] << ""]"" << endl;. * Efficiency; TH1 and TH2 are generally faster than THnSparse for one and two dimensional; distributions. THnSparse becomes competitive for a sparsely filled TH3; with large numbers of bins per dimension. The tutorial hist/sparsehist.C; shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins""; starting with a TH3 with 30 bins per dimension. Using a THnSparse for a; one-dimensional histogram is only reasonable if it has a huge number of bins. * Projections; The dimensionality of a THnSparse can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THnSparse. See the Projection() members. To only project parts of the; histogram, call; THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);. * Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnSparse.html:3057,reduce,reduced,3057,root/html534/THnSparse.html,https://root.cern,https://root.cern/root/html534/THnSparse.html,1,['reduce'],['reduced']
Energy Efficiency,"sing time. The number of filled bins is returned by; THnSparse::GetNbins(); the bin content for each (linear) bin number can; be retrieved by THnSparse::GetBinContent(linidx, (Int_t*)coord).; After the call, coord will contain the bin coordinate of each axis for the bin; with linear index linidx. A possible call would be; cout << hs.GetBinContent(0, coord);; cout <<"" is the content of bin [x = "" << coord[0] ""; << "" | y = "" << coord[1] << ""]"" << endl;. * Efficiency; TH1 and TH2 are generally faster than THnSparse for one and two dimensional; distributions. THnSparse becomes competitive for a sparsely filled TH3; with large numbers of bins per dimension. The tutorial hist/sparsehist.C; shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins""; starting with a TH3 with 30 bins per dimension. Using a THnSparse for a; one-dimensional histogram is only reasonable if it has a huge number of bins. * Projections; The dimensionality of a THnSparse can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THnSparse. See the Projection() members. To only project parts of the; histogram, call; THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);; See the important remark in THnSparse::IsInRange() when excluding under-; and overflow bins!. * Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THnSparse.html:3050,reduce,reduced,3050,root/html528/THnSparse.html,https://root.cern,https://root.cern/root/html528/THnSparse.html,3,['reduce'],['reduced']
Energy Efficiency,"sion and speed of the C99 compliant environments ;  mathcoreStatFunc.C Example macro showing some major probability density functions in ROOT ;  mathcoreStatFunc.py Example macro showing some major probability density functions in ROOT ;  mathcoreVectorCollection.C Example showing how to write and read a std vector of ROOT::Math LorentzVector in a ROOT tree ;  mathcoreVectorFloatIO.C Macro illustrating I/O with Lorentz Vectors of floats The dictionary for LorentzVector of float is not in the libMathCore, therefore is generated when parsed the file with CINT ;  mathcoreVectorIO.C Example of I/O of a mathcore Lorentz Vectors in a Tree and comparison with a TLorentzVector ;  mathGammaNormal.C Tutorial illustrating the use of TMath::GammaDist and TMath::LogNormal ;  mathLaplace.C Test the TMath::LaplaceDist and TMath::LaplaceDistI functions ;  mathmoreIntegration.C Example on the usage of the adaptive 1D integration algorithm of MathMore it calculates the numerically cumulative integral of a distribution (like in this case the BreitWigner) to execute the macro type it (you need to compile with AClic) ;  mathStudent.C Tutorial illustrating the use of the Student and F distributions ;  multidimSampling.C Example of sampling a multi-dim distribution using the DistSampler class NOTE: This tutorial must be run with ACLIC ;  normalDist.C Tutorial illustrating the new statistical distributions functions (pdf, cdf and quantile) ;  normalDist.py Tutorial illustrating the new statistical distributions functions (pdf, cdf and quantile) ;  permute.C Tutorial illustrating the use of TMath::Permute can be run with: ;  principal.C Principal Components Analysis (PCA) example ;  principal.py Principal Components Analysis (PCA) example ;  quantiles.C Demo for quantiles ;  quasirandom.C Example of generating quasi-random numbers ;  Rolke.C Example of the usage of the TRolke class The TRolke class computes the profile likelihood confidence limits for 7 different model assumptions on systema",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:133987,adapt,adaptive,133987,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,2,['adapt'],['adaptive']
Energy Efficiency,"sion and speed of the C99 compliant environments ;  mathcoreStatFunc.C Example macro showing some major probability density functions in ROOT ;  mathcoreStatFunc.py Example macro showing some major probability density functions in ROOT ;  mathcoreVectorCollection.C Example showing how to write and read a std vector of ROOT::Math LorentzVector in a ROOT tree ;  mathcoreVectorFloatIO.C Macro illustrating I/O with Lorentz Vectors of floats The dictionary for LorentzVector of float is not in the libMathCore, therefore is generated when parsed the file with CINT ;  mathcoreVectorIO.C Example of I/O of a mathcore Lorentz Vectors in a Tree and comparison with a TLorentzVector ;  mathGammaNormal.C Tutorial illustrating the use of TMath::GammaDist and TMath::LogNormal ;  mathLaplace.C Test the TMath::LaplaceDist and TMath::LaplaceDistI functions ;  mathmoreIntegration.C Example on the usage of the adaptive 1D integration algorithm of MathMore it calculates the numerically cumulative integral of a distribution (like in this case the BreitWigner) to execute the macro type it (you need to compile with AClic) ;  mathStudent.C Tutorial illustrating the use of the Student and F distributions ;  multidimSampling.C Example of sampling a multi-dim distribution using the DistSampler class NOTE: This tutorial must be run with ACLIC ;  normalDist.C Tutorial illustrating the new statistical distributions functions (pdf, cdf and quantile) ;  permute.C Tutorial illustrating the use of TMath::Permute can be run with: ;  principal.C Principal Components Analysis (PCA) example ;  quantiles.C Demo for quantiles ;  quasirandom.C Example of generating quasi-random numbers ;  Rolke.C Example of the usage of the TRolke class The TRolke class computes the profile likelihood confidence limits for 7 different model assumptions on systematic/statistical uncertainties ;  testrandom.C Performance test of all the ROOT random generator (TRandom, TRandom1, TRandom2 and TRandom3) Tests the generator TRandom3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:131661,adapt,adaptive,131661,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['adapt'],['adaptive']
Energy Efficiency,"sion, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column. ; [in]columnsNames of the columns/branches in input to the producer function (excluding slot and entry). . Returnsthe first node of the computation graph for which the new quantity is defined.; The old value of the column can be used as an input for the expression. An exception is thrown in case the column to re-define does not already exist.; See DefineSlotEntry() for more information. ; Definition at line 598 of file RInterface.hxx. ◆ Reduce() [1/2]. template<typename Proxied , typename DataSource = void> . template<typename F , typename T = typename TTraits::CallableTraits<F>::ret_type> . RResultPtr< T > ROOT::RDF::RInterface< Proxied, DataSource >::Reduce ; (; F ; f, . std::string_view ; columnName, . const T & ; redIdentity . ). inline . Execute a user-defined reduce operation on the values of a column. ; Template Parameters. FThe type of the reduce callable. Automatically deduced. ; TThe type of the column to apply the reduction to. Automatically deduced. . Parameters. [in]fA callable with signature T(T,T) ; [in]columnNameThe column to be reduced. If omitted, the first default column is used instead. ; [in]redIdentityThe reduced object of each thread is initialized to this value. . Returnsthe reduced quantity wrapped in a RResultPtr. Example usage:; auto sumOfIntColWithOffset = d.Reduce([](int x, int y) { return x + y; }, ""intCol"", 42);; See the description of the first Reduce overload for more information. ; Definition at line 1711 of file RInterface.hxx. ◆ Reduce() [2/2]. template<typename Proxied , typename DataSource = void> . template<typename F , typename T = typename TTraits::CallableTraits<F>::ret_type> . RResultPtr< T > ROOT::RDF::RInterface< Proxied, DataSource >::Reduce ; (; F ; f, . std::string_view ; columnName = """" . ). inline . Execute a user-defined reduce operation on the values of a column. ; Template Pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:119409,reduce,reduce,119409,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['reduce'],['reduce']
Energy Efficiency,"sion; 2615/// deficiency friendly and perceptually uniform colour maps specially designed; 2616/// in https://doi.org/10.5281/zenodo.4491293, namely the .txt files stored; 2617/// in the subfolders of ScientificColourMaps7.zip, e.g. batlow/batlow.txt; 2618///; 2619/// \param fileName: Name of a .txt file (ASCII) containing three floats per; 2620/// line, separated by spaces, namely the r g b fractions of the color, each; 2621/// value being in the range [0,1].; 2622/// \param alpha the global opacity for all colors within this palette; 2623/// \return a positive value on success and -1 on error.; 2624/// \author Fernando Hueso-González; 2625Int_t TColor::CreateColorTableFromFile(TString fileName, Float_t alpha); 2626{; 2627 std::ifstream f(fileName.Data());; 2628 if (!f.good()) {; 2629 ::Error(""TColor::CreateColorPalette(const TString)"", ""%s does not exist or cannot be opened"", fileName.Data());; 2630 return -1;; 2631 }; 2632 ; 2633 Int_t nLines = 0;; 2634 Float_t r, g, b;; 2635 std::vector<Float_t> reds, greens, blues;; 2636 while (f >> r >> g >> b) {; 2637 nLines++;; 2638 if (r < 0. || r > 1.) {; 2639 ::Error(""TColor::CreateColorPalette(const TString)"", ""Red value %f outside [0,1] on line %d of %s "", r,; 2640 nLines, fileName.Data());; 2641 f.close();; 2642 return -1;; 2643 }; 2644 if (g < 0. || g > 1.) {; 2645 ::Error(""TColor::CreateColorPalette(const TString)"", ""Green value %f outside [0,1] on line %d of %s "", g,; 2646 nLines, fileName.Data());; 2647 f.close();; 2648 return -1;; 2649 }; 2650 if (b < 0. || b > 1.) {; 2651 ::Error(""TColor::CreateColorPalette(const TString)"", ""Blue value %f outside [0,1] on line %d of %s "", b,; 2652 nLines, fileName.Data());; 2653 f.close();; 2654 return -1;; 2655 }; 2656 reds.emplace_back(r);; 2657 greens.emplace_back(g);; 2658 blues.emplace_back(b);; 2659 }; 2660 f.close();; 2661 if (nLines < 2) {; 2662 ::Error(""TColor::CreateColorPalette(const TString)"", ""Found insufficient color lines (%d) on %s"", nLines,; 2663 fileName.Data());",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:95737,green,greens,95737,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['greens']
Energy Efficiency,"sion_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttFill; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAtt3D; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions;  TTUBE (const TTUBE &);  Table of cos(fPhi1) .... cos(fPhil+fDphi1) ;  ; virtual void MakeTableOfCoSin () const;  Make table of sine and cosine. ;  ; TTUBE & operator= (const TTUBE &);  assignment operator ;  ; void SetPoints (Double_t *points) const override;  Create TUBE points. ;  ; virtual void SetSegsAndPols (TBuffer3D &buffer) const;  Set segments and polygons. ;  ;  Protected Member Functions inherited from TShape; virtual void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections) const;  We have to set kRawSize (unless already done) to allocate buffer space before kRaw can be filled. ;  ; Int_t GetBasicColor () const;  Get basic color. ;  ; Int_t ShapeDistancetoPrimitive (Int_t numPoints, Int_t px, Int_t py);  Distance to primitive. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Float_t fAspectRatio;  ; Double_t * fCoTab;  Table of sin(fPhi1) .... sin(fPhil+fDphi1) ;  ; Float_t fDz;  ; Int_t fNdiv;  ; Float_t fRmax;  ; Float_t fRmin;  ; Double_t * fSiTab;  ;  Protected Attributes inherited from TShape; TMaterial * fMaterial;  ; Int_t fNumber;  ; Int_t fVisibility;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTUBE.html:16054,allocate,allocate,16054,doc/master/classTTUBE.html,https://root.cern,https://root.cern/doc/master/classTTUBE.html,1,['allocate'],['allocate']
Energy Efficiency,"sis.py File ReferenceTutorials » Dataframe tutorials. Detailed Description; Show how NanoAOD files can be processed with RDataFrame. ; This tutorial illustrates how NanoAOD files can be processed with ROOT dataframes. The NanoAOD-like input files are filled with 66 mio. events from CMS OpenData containing muon candidates part of 2012 dataset (DOI: 10.7483/OPENDATA.CMS.YLIC.86ZZ and DOI: 10.7483/OPENDATA.CMS.M5AD.Y3V3). The macro matches muon pairs and produces an histogram of the dimuon mass spectrum showing resonances up to the Z mass. Note that the bump at 30 GeV is not a resonance but a trigger effect.; More details about the dataset can be found on the CERN Open Data portal. ; import ROOT; ; # Enable multi-threading; ROOT.ROOT.EnableImplicitMT(); ; # Create dataframe from NanoAOD files; df = ROOT.RDataFrame(""Events"", ""root://eospublic.cern.ch//eos/opendata/cms/derived-data/AOD2NanoAODOutreachTool/Run2012BC_DoubleMuParked_Muons.root""); ; # For simplicity, select only events with exactly two muons and require opposite charge; df_2mu = df.Filter(""nMuon == 2"", ""Events with exactly two muons""); df_os = df_2mu.Filter(""Muon_charge[0] != Muon_charge[1]"", ""Muons with opposite charge""); ; # Compute invariant mass of the dimuon system; df_mass = df_os.Define(""Dimuon_mass"", ""InvariantMass(Muon_pt, Muon_eta, Muon_phi, Muon_mass)""); ; # Make histogram of dimuon mass spectrum. Note how we can set titles and axis labels in one go.; h = df_mass.Histo1D((""Dimuon_mass"", ""Dimuon mass;m_{#mu#mu} (GeV);N_{Events}"", 30000, 0.25, 300), ""Dimuon_mass""); ; # Request cut-flow report; report = df_mass.Report(); ; # Produce plot; ROOT.gStyle.SetOptStat(0); ROOT.gStyle.SetTextFont(42); c = ROOT.TCanvas(""c"", """", 800, 700); c.SetLogx(); c.SetLogy(); ; h.SetTitle(""""); h.GetXaxis().SetTitleSize(0.04); h.GetYaxis().SetTitleSize(0.04); h.Draw(); ; label = ROOT.TLatex(); label.SetNDC(True); label.DrawLatex(0.175, 0.740, ""#eta""); label.DrawLatex(0.205, 0.775, ""#rho,#omega""); label.DrawLatex(0.270, 0.7",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8py.html:1229,charge,charge,1229,doc/master/df102__NanoAODDimuonAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8py.html,1,['charge'],['charge']
Energy Efficiency,"size /* = 32000 */, Int_t splitlevel /* = 99 */); 2023{; 2024 if (fgBranchStyle == 1) {; 2025 return Bronch(name, classname, addobj, bufsize, splitlevel);; 2026 } else {; 2027 if (splitlevel < 0) {; 2028 splitlevel = 0;; 2029 }; 2030 return BranchOld(name, classname, addobj, bufsize, splitlevel);; 2031 }; 2032}; 2033 ; 2034////////////////////////////////////////////////////////////////////////////////; 2035/// Create a new TTree BranchObject.; 2036///; 2037/// Build a TBranchObject for an object of class classname.; 2038/// addobj is the address of a pointer to an object of class classname.; 2039/// IMPORTANT: classname must derive from TObject.; 2040/// The class dictionary must be available (ClassDef in class header).; 2041///; 2042/// This option requires access to the library where the corresponding class; 2043/// is defined. Accessing one single data member in the object implies; 2044/// reading the full object.; 2045/// See the next Branch constructor for a more efficient storage; 2046/// in case the entry consists of arrays of identical objects.; 2047///; 2048/// By default the branch buffers are stored in the same file as the Tree.; 2049/// use TBranch::SetFile to specify a different file; 2050///; 2051/// IMPORTANT NOTE about branch names:; 2052///; 2053/// And in general, in case two or more master branches contain subbranches; 2054/// with identical names, one must add a ""."" (dot) character at the end; 2055/// of the master branch name. This will force the name of the subbranches; 2056/// to be of the form `master.subbranch` instead of simply `subbranch`.; 2057/// This situation happens when the top level object; 2058/// has two or more members referencing the same class.; 2059/// For example, if a Tree has two branches B1 and B2 corresponding; 2060/// to objects of the same class MyClass, one can do:; 2061/// ~~~ {.cpp}; 2062/// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; 2063/// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; 2064/// ~~~; 2065/// if MyClass ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:81256,efficient,efficient,81256,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['efficient'],['efficient']
Energy Efficiency,"size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetModel(const RooStats::ModelConfig& model); Set ModelConfig. {fModel = model;}. void SetData(RooAbsData& data); Set the DataSet. { fData = data; }. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. void SetParameters(const RooArgSet& ); specify the parameters of interest in the interval. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. ConfidenceBelt* GetConfidenceBelt(); get confidence belt. {return fConfBelt;}. void UseAdaptiveSampling(bool flag = true); adaptive sampling algorithm to speed up interval caculation. {fAdaptiveSampling=flag;}. void AdditionalNToysFactor(double fact); give user ability to ask for more toys. {fAdditionalNToysFactor = fact;}. void SaveBeltToFile(bool flag = true); save teh confidence belt to a file. void CreateConfBelt(bool flag = true); should create confidence belt. {fCreateBelt = flag;}. TestStatSampler* GetTestStatSampler(void); Returns instance of TestStatSampler. Use to change properties of; TestStatSampler, e.g. GetTestStatSampler.SetTestSize(Double_t size);. { return fTestStatSampler; }. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: NeymanConstruction.h 37403 2010-12-08 15:59:22Z moneta $ » Last generated: 2010-12-08 17:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__NeymanConstruction.html:6964,adapt,adaptive,6964,root/html528/RooStats__NeymanConstruction.html,https://root.cern,https://root.cern/root/html528/RooStats__NeymanConstruction.html,1,['adapt'],['adaptive']
Energy Efficiency,"size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetModel(const RooStats::ModelConfig& model); Set ModelConfig. {fModel = model;}. void SetData(RooAbsData& data); Set the DataSet. { fData = data; }. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. void SetParameters(const RooArgSet& ); specify the parameters of interest in the interval. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. ConfidenceBelt* GetConfidenceBelt(); get confidence belt. {return fConfBelt;}. void UseAdaptiveSampling(bool flag = true); adaptive sampling algorithm to speed up interval caculation. {fAdaptiveSampling=flag;}. void AdditionalNToysFactor(double fact); give user ability to ask for more toys. {fAdditionalNToysFactor = fact;}. void SaveBeltToFile(bool flag = true); save teh confidence belt to a file. void CreateConfBelt(bool flag = true); should create confidence belt. {fCreateBelt = flag;}. TestStatSampler* GetTestStatSampler(void); Returns instance of TestStatSampler. Use to change properties of; TestStatSampler, e.g. GetTestStatSampler.SetTestSize(Double_t size);. { return fTestStatSampler; }. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: NeymanConstruction.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__NeymanConstruction.html:6964,adapt,adaptive,6964,root/html530/RooStats__NeymanConstruction.html,https://root.cern,https://root.cern/root/html530/RooStats__NeymanConstruction.html,1,['adapt'],['adaptive']
Energy Efficiency,"size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetModel(const RooStats::ModelConfig& model); Set ModelConfig. {fModel = model;}. void SetData(RooAbsData& data); Set the DataSet. { fData = data; }. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. void SetParameters(const RooArgSet& ); specify the parameters of interest in the interval. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. ConfidenceBelt* GetConfidenceBelt(); get confidence belt. {return fConfBelt;}. void UseAdaptiveSampling(bool flag = true); adaptive sampling algorithm to speed up interval caculation. {fAdaptiveSampling=flag;}. void AdditionalNToysFactor(double fact); give user ability to ask for more toys. {fAdditionalNToysFactor = fact;}. void SaveBeltToFile(bool flag = true); save teh confidence belt to a file. void CreateConfBelt(bool flag = true); should create confidence belt. {fCreateBelt = flag;}. TestStatSampler* GetTestStatSampler(void); Returns instance of TestStatSampler. Use to change properties of; TestStatSampler, e.g. GetTestStatSampler.SetTestSize(Double_t size);. { return fTestStatSampler; }. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: NeymanConstruction.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__NeymanConstruction.html:6964,adapt,adaptive,6964,root/html532/RooStats__NeymanConstruction.html,https://root.cern,https://root.cern/root/html532/RooStats__NeymanConstruction.html,1,['adapt'],['adaptive']
Energy Efficiency,"size> allocated; GetTableSize() = newsize;; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void ReAlloc(Int_t newsize); The table is reallocated if it is an owner of the internal array. Char_t * Create(); Allocate a space for the new table, if any; Sleep for a while if space is not available and try again. void Browse(TBrowser* b); Wrap each table coulumn with TColumnView object to browse. void Clear(Option_t* opt = """"); Deletes the internal array of this class; if this object does own its internal table. void Delete(Option_t* opt = """"). Delete the internal array and free the memory it occupied; if this object did own this array. Then perform TDataSet::Delete(opt). TClass * GetRowClass() const; to be documented. Long_t GetNRows() const; Returns the number of the used rows for the wrapped table. Long_t GetRowSize() const; Returns the size (in bytes) of one table row. Long_t GetTableSize() const; Returns the number of the allocated rows. void Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0); Fit a projected item(s) from a TTable*-; *-* =======================================. formula is a TF1 expression. See TTable::Draw for explanations of the other parameters. By default the temporary histogram created is called htemp.; If varexp contains >>hnew , the new histogram created is called hnew; and it is kept in the current directory.; Example:; table.Fit(pol4,""sqrt(x)>>hsqrt"",""y>0""); will fit sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. const Char_t * GetType() const; Returns the type of the wrapped C-structure kept as the TNamed title. Bool_t IsFolder() const; return Folder flag to be used by TBrowse object; The table is a folder if; - it has sub-dataset; or; - GetNRows > 0. Int_t NaN(). return the total number of the NaN for float/double cel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTable.html:27803,allocate,allocated,27803,root/html528/TTable.html,https://root.cern,https://root.cern/root/html528/TTable.html,6,['allocate'],['allocated']
Energy Efficiency,"size_t sz); void*TObject::operator new[](size_t sz, void* vp); TSpectrum2Fit&operator=(const TSpectrum2Fit&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetBackgroundParameters(Double_t a0Init, Bool_t fixA0, Double_t axInit, Bool_t fixAx, Double_t ayInit, Bool_t fixAy); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFitParameters(Int_t xmin, Int_t xmax, Int_t ymin, Int_t ymax, Int_t numberIterations, Double_t alpha, Int_t statisticType, Int_t alphaOptim, Int_t power, Int_t fitTaylor); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetPeakParameters(Double_t sigmaX, Bool_t fixSigmaX, Double_t sigmaY, Bool_t fixSigmaY, Double_t ro, Bool_t fixRo, const Double_t* positionInitX, const Bool_t* fixPositionX, const Double_t* positionInitY, const Bool_t* fixPositionY, const Double_t* positionInitX1, const Bool_t* fixPositionX1, const Double_t* positionInitY1, const Bool_t* fixPositionY1, const Double_t* ampInit, const Bool_t* fixAmp, const Double_t* ampInitX1, const Bool_t* fixAmpX1, const Double_t* ampInitY1, const Bool_t* fixAmpY1); voidSetTailParameters(Double_t tInitXY, Bool_t fixTxy, Double_t tInitX, Bool_t fixTx, Double_t tInitY, Bool_t fixTy, Double_t bInitX, Bool_t fixBx, Double_t bInitY, Bool_t fixBy, Double_t sInitXY, Bool_t fixSxy, Double_t sInitX, Bool_t fixSx, Double_t sInitY, Bool_t fixSy); virtual voidTNamed::Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum2Fit.html:6196,power,power,6196,root/html602/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html602/TSpectrum2Fit.html,2,['power'],['power']
Energy Efficiency,"size_t sz); void*TObject::operator new[](size_t sz, void* vp); TSpectrum2Fit&operator=(const TSpectrum2Fit&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetBackgroundParameters(Double_t a0Init, Bool_t fixA0, Double_t axInit, Bool_t fixAx, Double_t ayInit, Bool_t fixAy); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFitParameters(Int_t xmin, Int_t xmax, Int_t ymin, Int_t ymax, Int_t numberIterations, Double_t alpha, Int_t statisticType, Int_t alphaOptim, Int_t power, Int_t fitTaylor); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetPeakParameters(Double_t sigmaX, Bool_t fixSigmaX, Double_t sigmaY, Bool_t fixSigmaY, Double_t ro, Bool_t fixRo, const Float_t* positionInitX, const Bool_t* fixPositionX, const Float_t* positionInitY, const Bool_t* fixPositionY, const Float_t* positionInitX1, const Bool_t* fixPositionX1, const Float_t* positionInitY1, const Bool_t* fixPositionY1, const Float_t* ampInit, const Bool_t* fixAmp, const Float_t* ampInitX1, const Bool_t* fixAmpX1, const Float_t* ampInitY1, const Bool_t* fixAmpY1); voidSetTailParameters(Double_t tInitXY, Bool_t fixTxy, Double_t tInitX, Bool_t fixTx, Double_t tInitY, Bool_t fixTy, Double_t bInitX, Bool_t fixBx, Double_t bInitY, Bool_t fixBy, Double_t sInitXY, Bool_t fixSxy, Double_t sInitX, Bool_t fixSx, Double_t sInitY, Bool_t fixSy); virtual voidTNamed::SetTitle(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSpectrum2Fit.html:6270,power,power,6270,root/html530/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html530/TSpectrum2Fit.html,3,['power'],['power']
Energy Efficiency,"sociated with each node ;  CRooListProxyRooListProxy is the concrete proxy for RooArgList objects ;  CRooLognormalRooFit Lognormal PDF ;  CRooMapCatEntry;  ►CRooMappedCategory;  CEntry;  CRooMath;  CRooMathCoreReg;  CRooMathMoreReg;  CRooMCIntegratorRooMCIntegrator implements an adaptive multi-dimensional Monte Carlo numerical integration, following the VEGAS algorithm originally described in G ;  CRooMCStudyRooMCStudy is a help class to facilitate Monte Carlo studies such as 'goodness-of-fit' studies, that involve fitting a PDF to multiple toy Monte Carlo sets generated from the same PDF or another PDF ;  CRooMinimizerRooMinimizer is a wrapper class around ROOT::Fit:Fitter that provides a seamless interface between the minimizer functionality and the native RooFit interface ;  CRooMinimizerFcn;  CRooMinuitRooMinuit is a wrapper class around TFitter/TMinuit that provides a seamless interface between the MINUIT functionality and the native RooFit interface ;  CRooMomentRooMoment represents the first, second, or third order derivative of any RooAbsReal as calculated (numerically) by the MathCore Richardson derivator class ;  ►CRooMomentMorph;  CCacheElem;  CRooMPSentinelRooMPSentinel is a singleton class that keeps track of all parellel execution processes for goodness-of-fit calculations ;  ►CRooMsgServiceSingleton class that organizes informational, debugging, warning and errors messages generated by the RooFit core code ;  CStreamConfig;  CRooMultiBinomialRooMultiBinomial is an efficiency function which makes all combinations of efficiencies given as input different effiency functions for different categories ;  CRooMultiCategoryRooMultiCategory consolidates several RooAbsCategory objects into a single category ;  CRooMultiCatIterRooMultiCatIter iterators over all state permutations of a list of categories ;  CRooMultiGenFunctionLightweight interface adaptor that exports a RooAbsReal as a ROOT::Math::IMultiGenFunction ;  ►CRooMultiVarGaussianMultivariate Gaussian p.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:96559,adapt,adaptor,96559,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['adapt'],['adaptor']
Energy Efficiency,"socket; 12423 * message queue.; 12424 * The original websocket upgrade request is never removed, so the queue; 12425 * begins after it. */; 12426 unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;; 12427 int n, error, exit_by_callback;; 12428 int ret;; 12429 ; 12430 /* body_len is the length of the entire queue in bytes; 12431 * len is the length of the current message; 12432 * data_len is the length of the current message's data payload; 12433 * header_len is the length of the current message's header */; 12434 size_t i, len, mask_len = 0, header_len, body_len;; 12435 uint64_t data_len = 0;; 12436 ; 12437 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12438 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12439 */; 12440 unsigned char mask[4];; 12441 ; 12442 /* data points to the place where the message is stored when passed to; 12443 * the websocket_data callback. This is either mem on the stack, or a; 12444 * dynamically allocated buffer if it is too large. */; 12445 unsigned char mem[4096];; 12446 unsigned char mop; /* mask flag and opcode */; 12447 ; 12448 ; 12449 /* Variables used for connection monitoring */; 12450 double timeout = -1.0;; 12451 int enable_ping_pong = 0;; 12452 int ping_count = 0;; 12453 ; 12454 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12455 enable_ping_pong =; 12456 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12457 ""yes"");; 12458 }; 12459 ; 12460 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12461 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12462 }; 12463 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12464 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12465 }; 12466 if (timeout <= 0.0) {; 12467 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12468 }; 12469 ; 12470 /* Enter data processing loop */; 12471 DEBUG_TRACE(""Websocket connection ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:360757,allocate,allocated,360757,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['allocate'],['allocated']
Energy Efficiency,"socket; 12424 * message queue.; 12425 * The original websocket upgrade request is never removed, so the queue; 12426 * begins after it. */; 12427 unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;; 12428 int n, error, exit_by_callback;; 12429 int ret;; 12430 ; 12431 /* body_len is the length of the entire queue in bytes; 12432 * len is the length of the current message; 12433 * data_len is the length of the current message's data payload; 12434 * header_len is the length of the current message's header */; 12435 size_t i, len, mask_len = 0, header_len, body_len;; 12436 uint64_t data_len = 0;; 12437 ; 12438 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12439 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:360790,allocate,allocated,360790,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['allocate'],['allocated']
Energy Efficiency,"sp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLTransManip(); TGLTransManip(TGLPhysicalShape* shape); TGLTransManip(const TGLTransManip&). protected:. voidTGLManip::CalcDrawScale(const TGLBoundingBox& box, const TGLCamera& camera, Double_t& base, TGLVector3[3] axis) const; const UChar_t*TGLManip::ColorFor(UInt_t widget) const. Data Members; protected:. Bool_tTGLManip::fActive! manipulator is active?; TPointTGLManip::fFirstMouse! first (start) mouse position (in WINDOW coords); TPointTGLManip::fLastMouse! last (latest) mouse position (in WINDOW coords); UInt_tTGLManip::fSelectedWidget! active width (axis) component; TGLPhysicalShape*TGLManip::fShape! manipulated shape. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLTransManip(); Construct translation manipulator not bound to any physical shape. TGLTransManip(TGLPhysicalShape* shape); Construct translation manipulator, attached to supplied TGLViewer; 'viewer', bound to TGLPhysicalShape 'shape'. ~TGLTransManip(); Destory the translation manipulator. void Draw(const TGLCamera& camera) const; Draw translation manipulator - tubes with arrow heads, in local axes of; attached shape, in red(X), green(Y) and blue(Z), with white center sphere.; If selected widget (mouse over) this is drawn in active colour (yellow). Bool_t HandleMotion(const Event_t& event, const TGLCamera& camera); Handle mouse motion over manipulator - if active (selected; widget) translate physical along selected widget (axis) of the; manipulator, so it tracks mouse action. Returns kTRUE if redraw; required kFALSE otherwise. TGLTransManip(). » Author: Richard Maunder 16/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-02 15:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLTransManip.html:2583,green,green,2583,root/html604/TGLTransManip.html,https://root.cern,https://root.cern/root/html604/TGLTransManip.html,1,['green'],['green']
Energy Efficiency,"sp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLTransManip(); TGLTransManip(TGLPhysicalShape* shape); TGLTransManip(const TGLTransManip&). protected:. voidTGLManip::CalcDrawScale(const TGLBoundingBox& box, const TGLCamera& camera, Double_t& base, TGLVector3[3] axis) const; const UChar_t*TGLManip::ColorFor(UInt_t widget) const. Data Members; protected:. Bool_tTGLManip::fActive! manipulator is active?; TPointTGLManip::fFirstMouse! first (start) mouse position (in WINDOW coords); TPointTGLManip::fLastMouse! last (latest) mouse position (in WINDOW coords); UInt_tTGLManip::fSelectedWidget! active width (axis) component; TGLPhysicalShape*TGLManip::fShape! manipulated shape. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLTransManip(); Construct translation manipulator not bound to any physical shape. TGLTransManip(TGLPhysicalShape* shape); Construct translation manipulator, attached to supplied TGLViewer; 'viewer', bound to TGLPhysicalShape 'shape'. ~TGLTransManip(); Destory the translation manipulator. void Draw(const TGLCamera& camera) const; Draw translation manipulator - tubes with arrow heads, in local axes of; attached shape, in red(X), green(Y) and blue(Z), with white center sphere.; If selected widget (mouse over) this is drawn in active colour (yellow). Bool_t HandleMotion(const Event_t& event, const TGLCamera& camera); Handle mouse motion over manipulator - if active (selected; widget) translate physical along selected widget (axis) of the; manipulator, so it tracks mouse action. Returns kTRUE if redraw; required kFALSE otherwise. TGLTransManip(). » Author: Richard Maunder 16/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:54; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLTransManip.html:2583,green,green,2583,root/html602/TGLTransManip.html,https://root.cern,https://root.cern/root/html602/TGLTransManip.html,1,['green'],['green']
Energy Efficiency,"sp;1"");�� ; �� TCanvas *Deconvolution =; new TCanvas(""Deconvolution"",""Deconvolution of 3-dimensional; spectra"",10,10,1000,700);; �� TSpectrum3 *s = new; TSpectrum3();; �� for (i = 0; i < nbinsx;; i++){; ���� for (j = 0; j <; nbinsy; j++){; ���� ���������� ��for (k = 0;; k < nbinsz; k++){; �� ������������ �������source[i][j][k]; = decon_in->GetBinContent(i + 1,j + 1,k + 1);; �� ������������ �������resp[i][j][k]; = decon_resp->GetBinContent(i + 1,j + 1,k + 1);�� ������������� �������; �� ������������ ����} ; �� ������������ �}; �� }; ��; s->Deconvolution(source,resp,nbinsx,nbinsy,nbinsz,100,1,1);; �� for (i = 0; i < nbinsx;; i++){; ���� for (j = 0; j <; nbinsy; j++){; ������� for (k = 0; k <; nbinsz; k++){; ����������; decon_in->SetBinContent(i + 1,j + 1,k + 1, source[i][j][k]);; ������� }��� ; ���� }; �� }; �� decon_in->Draw("""");� ; };  ; Example 2 � script Decon_hr.c :; This example illustrates repeated; Gold deconvolution with boosting. After every 10 iterations we apply power; function with exponent = 2 to the spectrum given in Fig. 2.;  . Fig. 4 Spectrum from Fig. 2; after boosted deconvolution (10 iterations repeated 10 times). It decomposes; completely cluster of peaks from Fig 2.;  ; Script:; // Example to illustrate the; Gold deconvolution (class TSpectrum3).; // To execute this example,; do; // root > .x Decon3_hr.C; void Decon3_hr() {; �� Int_t i, j, k;; �� Int_t nbinsx = 32;; �� Int_t nbinsy = 32;; �� Int_t nbinsz =; 32;�� ; �� Int_t xmin� = 0;; �� Int_t xmax� =; nbinsx;; �� Int_t ymin� = 0;; �� Int_t ymax� =; nbinsy;�� ; �� Int_t zmin� = 0;; �� Int_t zmax� = nbinsz;����� ; �� Double_t*** source = new; Double_t**[nbinsx];; �� Double_t*** resp = new Double_t; **[nbinsx];����� ; �� for(i=0;i<nbinsx;i++){; ����� source[i]=new Double_t*; [nbinsy];; �����; for(j=0;j<nbinsy;j++); �������� source[i][j]=new; Double_t[nbinsz];; �� }�� ������� ; �� for(i=0;i<nbinsx;i++){; ����� resp[i]=new Double_t*; [nbinsy];; �����; for(j=0;j<nbinsy;j++); �������� resp[i][j]=new Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum3.html:28253,power,power,28253,root/html602/TSpectrum3.html,https://root.cern,https://root.cern/root/html602/TSpectrum3.html,2,['power'],['power']
Energy Efficiency,"sp;1"");�� ; �� TCanvas *Deconvolution =; new TCanvas(""Deconvolution"",""Deconvolution of 3-dimensional; spectra"",10,10,1000,700);; �� TSpectrum3 *s = new; TSpectrum3();; �� for (i = 0; i < nbinsx;; i++){; ���� for (j = 0; j <; nbinsy; j++){; ���� ���������� ��for (k = 0;; k < nbinsz; k++){; �� ������������ �������source[i][j][k]; = decon_in->GetBinContent(i + 1,j + 1,k + 1);; �� ������������ �������resp[i][j][k]; = decon_resp->GetBinContent(i + 1,j + 1,k + 1);�� ������������� �������; �� ������������ ����} ; �� ������������ �}; �� }; ��; s->Deconvolution(source,resp,nbinsx,nbinsy,nbinsz,100,1,1);; �� for (i = 0; i < nbinsx;; i++){; ���� for (j = 0; j <; nbinsy; j++){; ������� for (k = 0; k <; nbinsz; k++){; ����������; decon_in->SetBinContent(i + 1,j + 1,k + 1, source[i][j][k]);; ������� }��� ; ���� }; �� }; �� decon_in->Draw("""");� ; };  ; Example 2 � script Decon_hr.c :; This example illustrates repeated; Gold deconvolution with boosting. After every 10 iterations we apply power; function with exponent = 2 to the spectrum given in Fig. 2.;  . Fig. 4 Spectrum from Fig. 2; after boosted deconvolution (10 iterations repeated 10 times). It decomposes; completely cluster of peaks from Fig 2.;  ; Script:; // Example to illustrate the; Gold deconvolution (class TSpectrum3).; // To execute this example,; do; // root > .x Decon3_hr.C; void Decon3_hr() {; �� Int_t i, j, k;; �� Int_t nbinsx = 32;; �� Int_t nbinsy = 32;; �� Int_t nbinsz =; 32;�� ; �� Int_t xmin� = 0;; �� Int_t xmax� =; nbinsx;; �� Int_t ymin� = 0;; �� Int_t ymax� =; nbinsy;�� ; �� Int_t zmin� = 0;; �� Int_t zmax� = nbinsz;����� ; �� float *** source = new; float **[nbinsx];; �� float *** resp = new float; **[nbinsx];����� ; �� for(i=0;i<nbinsx;i++){; ����� source[i]=new float*; [nbinsy];; �����; for(j=0;j<nbinsy;j++); �������� source[i][j]=new; float [nbinsz];; �� }�� ������� ; �� for(i=0;i<nbinsx;i++){; ����� resp[i]=new float*; [nbinsy];; �����; for(j=0;j<nbinsy;j++); �������� resp[i][j]=new float; [nbinsz];; �",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum3.html:27432,power,power,27432,root/html528/TSpectrum3.html,https://root.cern,https://root.cern/root/html528/TSpectrum3.html,4,['power'],['power']
Energy Efficiency,"space  CholeskyDecompHelpers;  helpers for CholeskyDecomp ;  ; namespace  detail;  ; namespace  GenAlgoOptUtil;  ; namespace  GenVector;  ; namespace  GenVector_detail;  ; namespace  GSLRootHelper;  Helper functions to test convergence of Root-Finding algorithms. ;  ; namespace  GSLSimAn;  ; namespace  gv_detail;  ; namespace  Impl;  ; namespace  IntegMultiDim;  ; namespace  IntegOneDim;  ; namespace  IntegOptionsUtil;  ; namespace  Integration;  ; namespace  IntegrationMultiDim;  ; namespace  IntegrationOneDim;  ; namespace  Internal;  ; namespace  internal;  ; namespace  Interpolation;  ; namespace  MCIntegration;  ; namespace  Minim;  ; namespace  Minim1D;  ; namespace  Roots;  Root-Finding Algorithms. ;  ; namespace  rowOffsetsUtils;  ; namespace  Sampler;  ; namespace  Util;  namespace defining Utility functions needed by mathcore ;  ; namespace  VectorUtil;  Global Helper functions for generic Vector classes. ;  . Classes; class  AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  AddOp;  Addition Operation Class. More...;  ; struct  AddPolicy;  matrix addition policy More...;  ; struct  AddPolicy< T, D1, D2, MatRepSym< T, D1 >, MatRepSym< T, D1 > >;  ; struct  Assign;  Structure to assign from an expression based to general matrix to general matrix. More...;  ; struct  Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >;  Dummy Structure which flags an error to avoid assignment from expression based on a general matrix to a symmetric matrix. More...;  ; struct  Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >;  Structure to assign from an expression based to symmetric matrix to symmetric matrix. More...;  ; struct  AssignItr;  Structure for assignment to a general matrix from iterator. More...;  ; struct  AssignItr< T, D1, D2, MatRepSym< T, D1 > >;  Specialized structure for assignment to a symmetrix matrix from iterator. More...;  ; struct  Assig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:1459,adapt,adaptive,1459,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['adapt'],['adaptive']
Energy Efficiency,"specific class, method and parameters. ; The parameter string has the form: ""\""aap\"", 3, 4.35"". To execute the method call TMethodCall::Execute(object,...). This two step method is much more efficient than calling for every invocation TInterpreter::Execute(...). ; Definition at line 62 of file TMethodCall.cxx. ◆ TMethodCall() [4/6]. TMethodCall::TMethodCall ; (; const char * ; function, . const char * ; params . ). Create a global function invocation environment. ; The parameter string has the form: ""\""aap\"", 3, 4,35"". To execute the function call TMethodCall::Execute(...). This two step method is much more efficient than calling for every invocation TInterpreter::Execute(...). ; Definition at line 75 of file TMethodCall.cxx. ◆ TMethodCall() [5/6]. TMethodCall::TMethodCall ; (; const TFunction * ; func). Create a global function invocation environment base on a TFunction object. ; To execute the function call TMethodCall::Execute(...). This two step method is much more efficient than calling for every invocation TInterpreter::Execute(...). ; Definition at line 87 of file TMethodCall.cxx. ◆ TMethodCall() [6/6]. TMethodCall::TMethodCall ; (; const TMethodCall & ; org). Copy ctor. ; Definition at line 95 of file TMethodCall.cxx. ◆ ~TMethodCall(). TMethodCall::~TMethodCall ; (; ). TMethodCall dtor. ; Definition at line 130 of file TMethodCall.cxx. Member Function Documentation. ◆ CallDtorOnly(). void TMethodCall::CallDtorOnly ; (; Bool_t ; set = kTRUE). inline . Definition at line 87 of file TMethodCall.h. ◆ Class(). static TClass * TMethodCall::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMethodCall::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMethodCall::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 128 of file TMethodCall.h. ◆ Clone(). TObject * TMethodCall::Clone ; (; const char * ; newname = """"); const. ov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMethodCall.html:17463,efficient,efficient,17463,doc/master/classTMethodCall.html,https://root.cern,https://root.cern/doc/master/classTMethodCall.html,1,['efficient'],['efficient']
Energy Efficiency,"specified (2-36).; 2082/// Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; 2083/// http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2084/// Usage: the following statement produce the same output, namely ""1111""; 2085/// ~~~ {.cpp}; 2086/// std::cout << TString::Itoa(15,2) ;; 2087/// std::cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; 2088/// std::cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; 2089/// ~~~; 2090/// In case of error returns the ""!"" string.; 2091 ; 2092TString TString::Itoa(Int_t value, Int_t base); 2093{; 2094 std::string buf;; 2095 // check that the base if valid; 2096 if (base < 2 || base > 36) {; 2097 Error(""TString::Itoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base) ;; 2098 return (TString(""!""));; 2099 }; 2100 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2101 Int_t quotient = value;; 2102 // Translating number to string with base:; 2103 do {; 2104 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ TMath::Abs(quotient % base) ];; 2105 quotient /= base;; 2106 } while (quotient);; 2107 // Append the negative sign; 2108 if (value < 0) buf += '-';; 2109 std::reverse(buf.begin(), buf.end());; 2110 return (TString(buf.data()));; 2111}; 2112 ; 2113////////////////////////////////////////////////////////////////////////////////; 2114/// Converts a UInt_t (twice the range of an Int_t) to a TString with respect; 2115/// to the base specified (2-36). Thus it is an enhanced version of sprintf; 2116/// (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2117/// In case of error returns the ""!"" string.; 2118 ; 2119TString TString::UItoa(UInt_t value, Int_t base); 2120{; 2121 std::string buf;; 2122 // check that the base if valid; 2123 if (base < 2 || base > 36) {; 2124 Error(""TString::UItoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2125 return (TString(""!""));; 2126 }; 2127 buf.reserve(35); // Pre-allocate enough space (35=k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:65836,allocate,allocate,65836,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"sponding to current coordinates. ;  ; std::vector< Int_t > getBins (RooFit::EvalContext &ctx) const;  Compute bin numbers corresponding to all coordinates in evalData. ;  ; bool getCdfBoundaries () const;  If true, special boundary conditions for c.d.f.s are used. ;  ; RooArgSet const & getHistObsList () const;  ; Int_t getInterpolationOrder () const;  Return histogram interpolation order. ;  ; Int_t getMaxVal (const RooArgSet &vars) const override;  Only handle case of maximum in all variables. ;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &) const override;  Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ;  ; double maxVal (Int_t code) const override;  Return maximum value for set of observables identified by code assigned in getMaxVal. ;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const override;  Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ;  ; void setCdfBoundaries (bool flag);  Set use of special boundary conditions for c.d.f.s. ;  ; void setInterpolationOrder (Int_t order);  Set histogram interpolation order. ;  ; void Streamer (TBuffer &) override;  Stream an object of class RooHistFunc. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; double totVolume () const;  Get total bin volume spanned by this hist function. ;  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ; RooArgSet const & variables () const;  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *uni",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistFunc.html:3759,efficient,efficiently,3759,doc/master/classRooHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooHistFunc.html,1,['efficient'],['efficiently']
Energy Efficiency,"ss Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualViewer3D. class TVirtualViewer3D: public TObject. TVirtualViewer3D. Abstract 3D shapes viewer. The concrete implementations are:. TViewerX3D : X3d viewer; TGLViewer : OpenGL viewer. ; 3D Viewer Infrastructure Overview; The 3D Viewer infrastructure consists of:. TVirtualViewer3D interface: An abstract handle to the viewer, allowing; client to test preferences, add objects, control the viewer via scripting; (to be added) etc.; TBuffer3D class hierarchy: Used to describe 3D objects; (""shapes""); - filled /added by negotiation with viewer via TVirtualViewer3D. Together these allow clients to publish objects to any one of the 3D viewers; (currently OpenGL/x3d,TPad), free of viewer specific drawing code. They allow; our simple x3d viewer, and considerably more sophisticated OpenGL one to both; work with both geometry libraries (g3d and geom) efficiently.; Publishing to a viewer consists of the following steps:. Create / obtain viewer handle; Begin scene on viewer; Fill mandatory parts of TBuffer3D describing object; Add to viewer; Fill optional parts of TBuffer3D if requested by viewer, and add again; ... repeat 3/4/5; as required; End scene on viewer. Creating / Obtaining Viewer; Create/obtain the viewer handle via local/global pad - the viewer is always; bound to a TPad object at present [This may be removed as a restriction in; the future] . You should perform the publishing to the viewer described below; in the Paint() method of the object you attach to the pad (via Draw()); TVirtualViewer3D * v = gPad->GetViewer3D(""xxxx"");; "" xxxx"" is viewer type: OpenGL ""ogl"", X3D ""x3d"" or; Pad ""pad"" (default). The viewer is created via the plugin manager,; attached to pad, and the interface returned.; Begin / End Scene; Objects must be added to viewer between BeginScene",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualViewer3D.html:1130,efficient,efficiently,1130,root/html602/TVirtualViewer3D.html,https://root.cern,https://root.cern/root/html602/TVirtualViewer3D.html,2,['efficient'],['efficiently']
Energy Efficiency,"ss descriptor. void CopySet(TTable& array); to be documented. const Char_t * GetColumnComment(Int_t columnIndex) const; Get a comment from the table descriptor. Long_t AppendRows(const void* row, UInt_t nRows); Append nRows row of the array ""row"" to the table; return; - the new table size (# of table rows); - 0 if the object doesn't own the internal array and can not expand it. Long_t InsertRows(const void* rows, Long_t indx, UInt_t nRows = 1); void InsertRows(cons void *row, Long_t indx, UInt_t nRows). Insert one or several rows into the table at ""indx"" position; The rest table stuff is shifted down. cons void - a pointer to the array of rows to be inserted; Long_t indx = The position these rows will be inserted to; Int_t nRows - the total number of rows to be inserted; = 1 ""by default; return:; The number of the rows has been shifted to accomodate; the new rows. void * ReAllocate(); Reallocate this table leaving only (used rows)+1 allocated; GetTableSize() = GetNRows() + 1; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void * ReAllocate(Int_t newsize); Reallocate this table leaving only <newsize> allocated; GetTableSize() = newsize;; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void ReAlloc(Int_t newsize); The table is reallocated if it is an owner of the internal array. Char_t * Create(); Allocate a space for the new table, if any; Sleep for a while if space is not available and try again. void Browse(TBrowser* b); Wrap each table coulumn with TColumnView object to browse. void Clear(Option_t* opt = """"); Deletes the internal array of this class; if this object does own its internal table. void Delete(Option_t* opt = """"). Delete the internal array and free the memory it occupied; if this object did own this array. Then perform TDataSet::Delete(opt). TClass * GetRowClass() const; to be docum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTable.html:26531,allocate,allocated,26531,root/html528/TTable.html,https://root.cern,https://root.cern/root/html528/TTable.html,6,['allocate'],['allocated']
Energy Efficiency,"ss for RooProdPdf that calculates a general normalized projection of a product of non-factorizing PDFs, e.g ;  CRooGExpModelClass RooGExpModel is a RooResolutionModel implementation that models a resolution function that is the convolution of a Gaussian with a one-sided exponential ;  CRooGlobalFunc;  CRooGridRooGrid is a utility class for RooMCIntegrator which implements an adaptive multi-dimensional Monte Carlo numerical integration, following the VEGAS algorithm ;  CRooHashTableRooHashTable implements a hash table for TObjects ;  CRooHistA RooHist is a graphical representation of binned data based on the TGraphAsymmErrors class ;  CRooHistConstraint;  ►CRooHistErrorRooHistError is a singleton class used to calculate the error bars for each bin of a RooHist object ;  CBinomialSumAsym;  CBinomialSumEff;  CPoissonSum;  CRooHistFuncRooHistFunc implements a real-valued function sampled from a multidimensional histogram ;  CRooHistPdfRooHistPdf implements a probablity density function sampled from a multidimensional histogram ;  CRooImproperIntegrator1DSpecial numeric integrator that can handle integrals over open domains ;  CRooIntRooInt is a minimal implementation of a TObject holding a Int_t value ;  ►CRooIntegralMorph;  CMorphCacheElem;  CRooIntegrator1DRooIntegrator1D implements an adaptive one-dimensional numerical integration algorithm ;  CRooIntegrator2DRooIntegrator2D implements a numeric two-dimensiona integrator in terms of a recursive application of RooIntegrator1D ;  CRooIntegratorBindingFunction binding representing the output of a RooAbsIntegrator ;  CRooInvTransformLightweight function binding that returns the inverse of an input function binding Apply the change of variables transformation x -> 1/x to the input function and its range ;  CRooJeffreysPriorRooJeffreysPrior ;  CRooKeysPdfClass RooKeysPdf implements a one-dimensional kernel estimation p.d.f which model the distribution of an arbitrary input dataset as a superposition of Gaussian kernels, one",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:92306,adapt,adaptive,92306,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,2,['adapt'],['adaptive']
Energy Efficiency,"ss of the Configurations ;  CTConfiguredAction;  CTLoopConfigurationBase class of the Configurations for the member wise looping routines ;  ►Nvdt;  ►Ndetails;  Cieee754Used to switch between different type of interpretations of the data (64 bits) ;  ►Nwriter;  Cwriter;  C_root_std_complex;  C_Ulp_ExponentVector;  C_Ulp_ExponentVector< Vc::sfloat_v >;  C_UnitTest_Compare;  C_UnitTest_Failure;  C_UnitTest_Global_Object;  C_x3d_data_;  C_x3d_sizeof_;  CADD_PASS;  CAnyCollectionProxy;  CAnyCollectionStreamer;  CApplicationWindowMain Qt&Root Application Window: ;  ►CBaker;  COptions;  CBalancerInfo;  CBaseSelectionRule;  Cbasic_string_view;  ►CBidirMMapPipeBidirMMapPipe creates a bidirectional channel between the current process and a child it forks ;  CPollEntryFor poll() interface ;  CBinaryOpPolicy;  CBinomialNeymanInterval;  CBinomialProbHelper;  CClassSelectionRule;  CClusterD;  CColorStruct_t;  CCompareAsc;  CcompareBAasc;  CcompareBAdesc;  CCompareDesc;  CContDistFree functions adapter needed by UNURAN for onedimensional continuous distributions ;  CContextSmall helper to keep current directory context ;  CCpuInfo_t;  CDiscrDistFree functions adapter needed by UNURAN for one-dimensional discrete distribution ;  Cdrr_func_cache;  Cdrr_func_entry;  CDUMMY;  CEditor;  CEvent_t;  CExceptionContext_t;  CexponentToDivisor;  CexponentToDivisor< 1, center >;  CexponentToDivisor< 1024, center >;  CexponentToDivisor< 128, center >;  CexponentToDivisor< 256, center >;  CexponentToDivisor< 384, center >;  CexponentToDivisor< 512, center >;  CexponentToDivisor< 640, center >;  CexponentToDivisor< 768, center >;  CexponentToDivisor< 896, center >;  CexponentToDivisor< center, center >;  CexponentToMultiplier;  CexponentToMultiplier< -1, center >;  CexponentToMultiplier< -128, center >;  CexponentToMultiplier< -256, center >;  CexponentToMultiplier< -384, center >;  CexponentToMultiplier< -512, center >;  CexponentToMultiplier< -640, center >;  CexponentToMultiplier< -768, cent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:76696,adapt,adapter,76696,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['adapt'],['adapter']
Energy Efficiency,"ss to basic X11 graphics, pixmap, text and font handling routines.; The companion class for Win32 is TGWin32.; The file G11Gui.cxx contains the implementation of the GUI methods of the TGX11 class. Most of the methods are used by the machine independent GUI classes (libGUI.so).; This code was initially developed in the context of HIGZ and PAW by Olivier Couet (package X11INT). ; Definition at line 80 of file TGX11.h. Public Member Functions;  TGX11 ();  Default constructor. ;  ;  TGX11 (const char *name, const char *title);  Normal Constructor. ;  ;  TGX11 (const TGX11 &org);  Copy constructor. Currently only used by TGX11TTF. ;  ;  ~TGX11 () override;  Destructor. ;  ; Int_t AddPixmap (ULong_t pixid, UInt_t w, UInt_t h) override;  Register pixmap created by gVirtualGL. ;  ; Int_t AddWindow (ULong_t qwid, UInt_t w, UInt_t h) override;  Register a window created by Qt as a ROOT window (like InitWindow()). ;  ; Bool_t AllocColor (Colormap_t cmap, ColorStruct_t &color) override;  Find and allocate a color cell according to the color values specified in the ColorStruct_t. ;  ; void Bell (Int_t percent) override;  Sound bell. Percent is loudness from -100% .. 100%. ;  ; void ChangeActivePointerGrab (Window_t, UInt_t, Cursor_t) override;  Changes the specified dynamic parameters if the pointer is actively grabbed by the client. ;  ; void ChangeGC (GContext_t gc, GCValues_t *gval) override;  Change entries in an existing graphics context, gc, by values from gval. ;  ; void ChangeProperties (Window_t id, Atom_t property, Atom_t type, Int_t format, UChar_t *data, Int_t len) override;  This function alters the property for the specified window and causes the X server to generate a PropertyNotify event on that window. ;  ; void ChangeProperty (Window_t id, Atom_t property, Atom_t type, UChar_t *data, Int_t len) override;  This function alters the property for the specified window and causes the X server to generate a PropertyNotify event on that window. ;  ; void ChangeWindowAt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGX11.html:1541,allocate,allocate,1541,doc/master/classTGX11.html,https://root.cern,https://root.cern/doc/master/classTGX11.html,1,['allocate'],['allocate']
Energy Efficiency,"ss(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. Definition at line 4978 of file TClass.cxx. ◆ New() [2/2]. void * TClass::New ; (; void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5091 of file TClass.cxx. ◆ NewArray() [1/2]. void * TClass::NewArray ; (; Long_t ; nElements, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated array of objects of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5193 of file TClass.cxx. ◆ NewArray() [2/2]. void * TClass::NewArray ; (; Long_t ; nElements, . void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5295 of file TClass.cxx. ◆ NewObject() [1/2]. TClass::ObjectPtr TClass::NewObject ; (; ENewType ; defConstructor = kClassNew, . Bool_t ; quiet = kFALSE . ); const. Definition at line 4992 of file TClass.cxx. ◆ NewObject() [2/2]. TClass::ObjectPtr TClass::NewObject ; (; void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5106 of file TClass.cxx. ◆ NewObjectArray() [1/2]. TClass::ObjectPtr TClass::NewObjectArray ; (; Long_t ; nElements, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated array of objects of this class. ; The class must have a default constructor. For meaning of defConstructor, see TC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:107034,allocate,allocated,107034,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['allocate'],['allocated']
Energy Efficiency,"ss(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. Definition at line 5045 of file TClass.cxx. ◆ New() [2/2]. void * TClass::New ; (; void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5158 of file TClass.cxx. ◆ NewArray() [1/2]. void * TClass::NewArray ; (; Long_t ; nElements, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated array of objects of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5260 of file TClass.cxx. ◆ NewArray() [2/2]. void * TClass::NewArray ; (; Long_t ; nElements, . void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5362 of file TClass.cxx. ◆ NewObject() [1/2]. TClass::ObjectPtr TClass::NewObject ; (; ENewType ; defConstructor = kClassNew, . Bool_t ; quiet = kFALSE . ); const. Definition at line 5059 of file TClass.cxx. ◆ NewObject() [2/2]. TClass::ObjectPtr TClass::NewObject ; (; void * ; arena, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated object of this class. ; The class must have a default constructor. For meaning of defConstructor, see TClass::IsCallingNew(). ; Definition at line 5173 of file TClass.cxx. ◆ NewObjectArray() [1/2]. TClass::ObjectPtr TClass::NewObjectArray ; (; Long_t ; nElements, . ENewType ; defConstructor = kClassNew . ); const. Return a pointer to a newly allocated array of objects of this class. ; The class must have a default constructor. For meaning of defConstructor, see TC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:107035,allocate,allocated,107035,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['allocate'],['allocated']
Energy Efficiency,"ss(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(RooCmdArg arg1, RooCmdArg arg2 = RooCmdArg(), RooCmdArg arg3 = RooCmdArg(), RooCmdArg arg4 = RooCmdArg(), RooCmdArg arg5 = RooCmdArg(), RooCmdArg arg6 = RooCmdArg(), RooCmdArg arg7 = RooCmdArg(), RooCmdArg arg8 = RooCmdArg()); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTreeData.html:8308,reduce,reduce,8308,root/html526/RooTreeData.html,https://root.cern,https://root.cern/root/html526/RooTreeData.html,2,['reduce'],['reduce']
Energy Efficiency,"ss(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooTreeData.html:8627,reduce,reduce,8627,root/html530/RooTreeData.html,https://root.cern,https://root.cern/root/html530/RooTreeData.html,1,['reduce'],['reduce']
Energy Efficiency,"ss(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; RooTreeData(); RooTreeData(const RooTreeData&); RooTreeData(RooTreeData&&); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsData::setDefaultStorageType(RooAbsData::St",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTreeData.html:8864,reduce,reduce,8864,root/html602/RooTreeData.html,https://root.cern,https://root.cern/root/html602/RooTreeData.html,2,['reduce'],['reduce']
Energy Efficiency,"ss(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsData::setDefaultStorageType(RooAbsData::StorageType s); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooTreeData.html:8847,reduce,reduce,8847,root/html534/RooTreeData.html,https://root.cern,https://root.cern/root/html534/RooTreeData.html,1,['reduce'],['reduce']
Energy Efficiency,"ss(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooTreeData.html:8723,reduce,reduce,8723,root/html532/RooTreeData.html,https://root.cern,https://root.cern/root/html532/RooTreeData.html,1,['reduce'],['reduce']
Energy Efficiency,"ss_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAtt3D; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; void SetPoints (Double_t *points) const override;  Create CONS points. ;  ;  Protected Member Functions inherited from TTUBS; void MakeTableOfCoSin () const override;  Make table of sine and cosine. ;  ; void SetPoints (Double_t *points) const override;  Create TUBS points. ;  ;  Protected Member Functions inherited from TTUBE;  TTUBE (const TTUBE &);  Table of cos(fPhi1) .... cos(fPhil+fDphi1) ;  ; TTUBE & operator= (const TTUBE &);  assignment operator ;  ; virtual void SetSegsAndPols (TBuffer3D &buffer) const;  Set segments and polygons. ;  ;  Protected Member Functions inherited from TShape; virtual void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections) const;  We have to set kRawSize (unless already done) to allocate buffer space before kRaw can be filled. ;  ; Int_t GetBasicColor () const;  Get basic color. ;  ; Int_t ShapeDistancetoPrimitive (Int_t numPoints, Int_t px, Int_t py);  Distance to primitive. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Float_t fRmax2;  ; Float_t fRmin2;  ;  Protected Attributes inherited from TTUBS; Float_t fPhi1;  ; Float_t fPhi2;  ;  Protected Attributes inherited from TTUBE; Float_t fAspectRatio;  ; Double_t * fCoTab;  Table of sin(fPhi1) .... sin(fPhil+fDphi1) ;  ; Float_t fDz;  ; Int_t fNdiv;  ; Float_t fRmax;  ; Float_t fRmin;  ; Double_t * fSiTab;  ;  Protected Attributes inherited from TShape; TMaterial * fMaterial;  ; Int_t fNumber;  ; Int_t fVisibility;  ;  Protected Attributes inherited from TNa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCONS.html:18361,allocate,allocate,18361,doc/master/classTCONS.html,https://root.cern,https://root.cern/doc/master/classTCONS.html,1,['allocate'],['allocate']
Energy Efficiency,"ss_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAtt3D; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; void SetPoints (Double_t *points) const override;  Create TUBS points. ;  ;  Protected Member Functions inherited from TTUBS; void MakeTableOfCoSin () const override;  Make table of sine and cosine. ;  ; void SetPoints (Double_t *points) const override;  Create TUBS points. ;  ;  Protected Member Functions inherited from TTUBE;  TTUBE (const TTUBE &);  Table of cos(fPhi1) .... cos(fPhil+fDphi1) ;  ; TTUBE & operator= (const TTUBE &);  assignment operator ;  ; virtual void SetSegsAndPols (TBuffer3D &buffer) const;  Set segments and polygons. ;  ;  Protected Member Functions inherited from TShape; virtual void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections) const;  We have to set kRawSize (unless already done) to allocate buffer space before kRaw can be filled. ;  ; Int_t GetBasicColor () const;  Get basic color. ;  ; Int_t ShapeDistancetoPrimitive (Int_t numPoints, Int_t px, Int_t py);  Distance to primitive. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Float_t fCosHigh [3];  ; Float_t fCosLow [3];  ;  Protected Attributes inherited from TTUBS; Float_t fPhi1;  ; Float_t fPhi2;  ;  Protected Attributes inherited from TTUBE; Float_t fAspectRatio;  ; Double_t * fCoTab;  Table of sin(fPhi1) .... sin(fPhil+fDphi1) ;  ; Float_t fDz;  ; Int_t fNdiv;  ; Float_t fRmax;  ; Float_t fRmin;  ; Double_t * fSiTab;  ;  Protected Attributes inherited from TShape; TMaterial * fMaterial;  ; Int_t fNumber;  ; Int_t fVisibility;  ;  Protected Attributes inherit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCTUB.html:18559,allocate,allocate,18559,doc/master/classTCTUB.html,https://root.cern,https://root.cern/doc/master/classTCTUB.html,1,['allocate'],['allocate']
Energy Efficiency,"st = (TList*)contours->At(i);. Where i is a contour number, and list contains a list of; TGraph objects.; For one given contour, more than one disjoint polyline may be generated.; The number of TGraphs per contour is given by:. list->GetSize();. To access the first graph in the list one should do:. TGraph *gr1 = (TGraph*)list->First();. The following example shows how to use this functionality. Picture; Source. // Getting Contours From TH2D; // Author: Josh de Bever; // CSI Medical Physics Group; // The University of Western Ontario; // London, Ontario, Canada; // Date: Oct. 22, 2004; // Modified by O.Couet (Nov. 26, 2004). Double_t SawTooth(Double_t x, Double_t WaveLen);. TCanvas *ContourList(){. const Double_t PI = TMath::Pi();. TCanvas* c = new TCanvas(""c"",""Contour List"",0,0,600,600);; c->SetRightMargin(0.15);; c->SetTopMargin(0.15);. Int_t i, j;. Int_t nZsamples = 80;; Int_t nPhiSamples = 80;. Double_t HofZwavelength = 4.0; // 4 meters; Double_t dZ = HofZwavelength/(Double_t)(nZsamples - 1);; Double_t dPhi = 2*PI/(Double_t)(nPhiSamples - 1);. TArrayD z(nZsamples);; TArrayD HofZ(nZsamples);; TArrayD phi(nPhiSamples);; TArrayD FofPhi(nPhiSamples);. // Discretized Z and Phi Values; for ( i = 0; i < nZsamples; i++) {; z[i] = (i)*dZ - HofZwavelength/2.0;; HofZ[i] = SawTooth(z[i], HofZwavelength);; }. for(Int_t i=0; i < nPhiSamples; i++){; phi[i] = (i)*dPhi;; FofPhi[i] = sin(phi[i]);; }. // Create Histogram; TH2D *HistStreamFn = new TH2D(""HstreamFn"",; ""#splitline{Histogram with negative and positive contents. Six contours are defined.}{It is plotted with options CONT LIST to retrieve the contours points in TGraphs}"",; nZsamples, z[0], z[nZsamples-1], nPhiSamples, phi[0], phi[nPhiSamples-1]);. // Load Histogram Data; for (Int_t i = 0; i < nZsamples; i++) {; for(Int_t j = 0; j < nPhiSamples; j++){; HistStreamFn->SetBinContent(i,j, HofZ[i]*FofPhi[j]);; }; }. gStyle->SetPalette(1);; gStyle->SetOptStat(0);; gStyle->SetTitleW(0.99);; gStyle->SetTitleH(0.08);. Double_t contou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THistPainter.html:41299,meter,meters,41299,root/html602/THistPainter.html,https://root.cern,https://root.cern/root/html602/THistPainter.html,2,['meter'],['meters']
Energy Efficiency,"st RooArgList &vars, const TH1 &histo, double initWgt, bool doDensityCorrection);  Import data from given TH1/2/3 into this RooDataHist. ;  ; void importTH1Set (const RooArgList &vars, RooCategory &indexCat, std::map< std::string, TH1 * > hmap, double initWgt, bool doDensityCorrection);  Import data from given set of TH1/2/3 into this RooDataHist. ;  ; void initialize (const char *binningName=nullptr, bool fillTree=true);  Initialization procedure: allocate weights array, calculate multipliers needed for N-space to 1-dim array jump table, and fill the internal tree with all bin center coordinates. ;  ; double interpolateDim (int iDim, double xval, size_t centralIdx, int intOrder, bool correctForBinSize, bool cdfBoundaries);  Perform boundary safe 'intOrder'-th interpolation of weights in dimension 'dim' at current value 'xval'. ;  ; std::unique_ptr< RooAbsData > reduceEng (const RooArgSet &varSubset, const RooFormulaVar *cutVar, const char *cutRange=nullptr, std::size_t nStart=0, std::size_t nStop=std::numeric_limits< std::size_t >::max()) const override;  Implementation of RooAbsData virtual method that drives the RooAbsData::reduce() methods. ;  ;  Protected Member Functions inherited from RooAbsData; bool allClientsCached (RooAbsArg *, const RooArgSet &);  Utility function that determines if all clients of object 'var' appear in given list of cached nodes. ;  ; virtual void attachCache (const RooAbsArg *newOwner, const RooArgSet &cachedVars);  Internal method – Attach dataset copied with cache contents to copied instances of functions. ;  ; virtual void cacheArgs (const RooAbsArg *owner, RooArgSet &varSet, const RooArgSet *nset=nullptr, bool skipZeroWeights=false);  Internal method – Cache given set of functions with data. ;  ; double corrcov (const RooRealVar &x, const RooRealVar &y, const char *cutSpec, const char *cutRange, bool corr) const;  Internal method to calculate single correlation and covariance elements. ;  ; RooFit::OwningPtr< TMatrixDSym > corrcovMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:35331,reduce,reduceEng,35331,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,2,['reduce'],"['reduce', 'reduceEng']"
Energy Efficiency,"st RooLinkedList &cmdList) const;  Plot dataset on specified frame. ;  ; void Print (Option_t *options=nullptr) const override;  This method must be overridden when a class wants to print itself. ;  ; void printClassName (std::ostream &os) const override;  Print class name of dataset. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Interface for detailed printing of object. ;  ; void printName (std::ostream &os) const override;  Print name of dataset. ;  ; void printTitle (std::ostream &os) const override;  Print title of dataset. ;  ; void RecursiveRemove (TObject *obj) override;  If one of the TObject we have a referenced to is deleted, remove the reference. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const char *cut) const;  Create a subset of the data set by applying the given cut on the data points. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooArgSet &varSubset, const char *cut=nullptr) const;  Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooArgSet &varSubset, const RooFormulaVar &cutVar) const;  Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  Create a reduced copy of this dataset. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooFormulaVar &cutVar) const;  Create a subset of the data set by applying the given cut on the data points. ;  ; virtual void reset ();  ; void resetBuffers ();  ; RooRealVar * rmsVar (const RooRealVar &var, const char *cutSpec=nullptr, const char *cutRange=nullptr) const;  Create a RooRealVar co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeData.html:7652,reduce,reduce,7652,doc/master/classRooTreeData.html,https://root.cern,https://root.cern/doc/master/classRooTreeData.html,2,['reduce'],['reduce']
Energy Efficiency,"st char * GetBinLabel(Int_t bin) constReturn label for bin.Definition TAxis.cxx:440; TAxis::GetBinLowEdgevirtual Double_t GetBinLowEdge(Int_t bin) constReturn low edge of bin.Definition TAxis.cxx:518; TAxis::FindFixBinvirtual Int_t FindFixBin(Double_t x) constFind bin number corresponding to abscissa x.Definition TAxis.cxx:419; TAxis::GetXminDouble_t GetXmin() constDefinition TAxis.h:139; TAxis::GetNbinsInt_t GetNbins() constDefinition TAxis.h:125; TAxis::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width.Definition TAxis.cxx:540; TAxis::GetLabelsTHashList * GetLabels() constDefinition TAxis.h:121; TBinomialEfficiencyFitterBinomial fitter for the division of two histograms.Definition TBinomialEfficiencyFitter.h:42; TBinomialEfficiencyFitter::FitTFitResultPtr Fit(TF1 *f1, Option_t *option="""")Carry out the fit of the given function to the given histograms.Definition TBinomialEfficiencyFitter.cxx:195; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::IsEmptyvirtual Bool_t IsEmpty() constDefinition TCollection.h:188; TDirectory::TContextTDirectory::TContext keeps track and restore the current directory.Definition TDirectory.h:89; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::Appendvirtual void Append(TObject *obj, Bool_t replace=kFALSE)Append object to this directory.Definition TDirectory.cxx:199; TDirectory::Removevirtual TObject * Remove(TObject *)Remove an object from the in-memory list.Definition TDirectory.cxx:1212; TEfficiencyClass to handle efficiency histograms.Definition TEfficiency.h:29; TEfficiency::FillGraph2Dvoid FillGraph2D(TGraph2DAsymmErrors *graph, Option_t *opt) constFill the graph to be painted with information from TEfficiency Internal method called by TEfficiency:...Definition TEfficien",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEfficiency_8cxx_source.html:160872,allocate,allocated,160872,doc/master/TEfficiency_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"st char *datamember) constReturn pointer to datamember object with name ""datamember"".Definition TClass.cxx:3439; TClass::fIsATVirtualIsAProxy * fIsADefinition TClass.h:229; TClass::GetListOfUsingDataMembersTList * GetListOfUsingDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of using declarations of a class.Definition TClass.cxx:3786; TClass::ForceReloadvoid ForceReload(TClass *oldcl)we found at least one equivalent.Definition TClass.cxx:1336; TClass::fDeleteArrayROOT::DelArrFunc_t fDeleteArrayDefinition TClass.h:238; TClass::CanSplitBool_t CanSplit() constReturn true if the data member of this TClass can be saved separately.Definition TClass.cxx:2319; TClass::fStreamerTClassStreamer * fStreamerDefinition TClass.h:226; TClass::SetDirectoryAutoAddvoid SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc)Install a new wrapper around the directory auto add function.Definition TClass.cxx:7028; TClass::NewArrayvoid * NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5193; TClass::fNoInfoOrEmuOrFwdDeclNameRegistrystatic TDeclNameRegistry fNoInfoOrEmuOrFwdDeclNameRegistryDefinition TClass.h:328; TClass::TGenericClassInfofriend class ROOT::TGenericClassInfoDefinition TClass.h:85; TClass::fFuncTemplateTListOfFunctionTemplates * fFuncTemplateDefinition TClass.h:206; TClass::fStreamerFuncClassStreamerFunc_t fStreamerFuncDefinition TClass.h:241; TClass::AdoptReferenceProxyvoid AdoptReferenceProxy(TVirtualRefProxy *proxy)Adopt the Reference proxy pointer to indicate that this class represents a reference.Definition TClass.cxx:6685; TClass::GetClassMethodTMethod * GetClassMethod(Longptr_t faddr)Look for a method in this class that has the interface function address faddr.Definition TClass.cxx:4483; TClass::DetermineCurrentStreamerInfoTVirtualStreamerInfo * DetermineCurrentStreamerInfo()Determine and set pointer to current TVirtualStreamerInfo.Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:42832,allocate,allocated,42832,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,1,['allocate'],['allocated']
Energy Efficiency,"st char *datamember) constReturn pointer to datamember object with name ""datamember"".Definition TClass.cxx:3439; TClass::fIsATVirtualIsAProxy * fIsADefinition TClass.h:229; TClass::GetListOfUsingDataMembersTList * GetListOfUsingDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of using declarations of a class.Definition TClass.cxx:3786; TClass::ForceReloadvoid ForceReload(TClass *oldcl)we found at least one equivalent.Definition TClass.cxx:1336; TClass::fDeleteArrayROOT::DelArrFunc_t fDeleteArrayDefinition TClass.h:238; TClass::CanSplitBool_t CanSplit() constReturn true if the data member of this TClass can be saved separately.Definition TClass.cxx:2319; TClass::fStreamerTClassStreamer * fStreamerDefinition TClass.h:226; TClass::SetDirectoryAutoAddvoid SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc)Install a new wrapper around the directory auto add function.Definition TClass.cxx:7028; TClass::NewArrayvoid * NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5193; TClass::fNoInfoOrEmuOrFwdDeclNameRegistrystatic TDeclNameRegistry fNoInfoOrEmuOrFwdDeclNameRegistryDefinition TClass.h:328; TClass::fFuncTemplateTListOfFunctionTemplates * fFuncTemplateDefinition TClass.h:206; TClass::fStreamerFuncClassStreamerFunc_t fStreamerFuncDefinition TClass.h:241; TClass::AdoptReferenceProxyvoid AdoptReferenceProxy(TVirtualRefProxy *proxy)Adopt the Reference proxy pointer to indicate that this class represents a reference.Definition TClass.cxx:6685; TClass::GetClassMethodTMethod * GetClassMethod(Longptr_t faddr)Look for a method in this class that has the interface function address faddr.Definition TClass.cxx:4483; TClass::DetermineCurrentStreamerInfoTVirtualStreamerInfo * DetermineCurrentStreamerInfo()Determine and set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5684; TClass::Browsevoid Browse(TBrowser *b) overrideThis method is call",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:309191,allocate,allocated,309191,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"st char *datamember) constReturn pointer to datamember object with name ""datamember"".Definition TClass.cxx:3506; TClass::fIsATVirtualIsAProxy * fIsADefinition TClass.h:229; TClass::GetListOfUsingDataMembersTList * GetListOfUsingDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of using declarations of a class.Definition TClass.cxx:3853; TClass::ForceReloadvoid ForceReload(TClass *oldcl)we found at least one equivalent.Definition TClass.cxx:1403; TClass::fDeleteArrayROOT::DelArrFunc_t fDeleteArrayDefinition TClass.h:238; TClass::CanSplitBool_t CanSplit() constReturn true if the data member of this TClass can be saved separately.Definition TClass.cxx:2386; TClass::fStreamerTClassStreamer * fStreamerDefinition TClass.h:226; TClass::SetDirectoryAutoAddvoid SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc)Install a new wrapper around the directory auto add function.Definition TClass.cxx:7095; TClass::NewArrayvoid * NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5260; TClass::fNoInfoOrEmuOrFwdDeclNameRegistrystatic TDeclNameRegistry fNoInfoOrEmuOrFwdDeclNameRegistryDefinition TClass.h:328; TClass::TGenericClassInfofriend class ROOT::TGenericClassInfoDefinition TClass.h:85; TClass::fFuncTemplateTListOfFunctionTemplates * fFuncTemplateDefinition TClass.h:206; TClass::fStreamerFuncClassStreamerFunc_t fStreamerFuncDefinition TClass.h:241; TClass::AdoptReferenceProxyvoid AdoptReferenceProxy(TVirtualRefProxy *proxy)Adopt the Reference proxy pointer to indicate that this class represents a reference.Definition TClass.cxx:6752; TClass::GetClassMethodTMethod * GetClassMethod(Longptr_t faddr)Look for a method in this class that has the interface function address faddr.Definition TClass.cxx:4550; TClass::DetermineCurrentStreamerInfoTVirtualStreamerInfo * DetermineCurrentStreamerInfo()Determine and set pointer to current TVirtualStreamerInfo.Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:42660,allocate,allocated,42660,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,1,['allocate'],['allocated']
Energy Efficiency,"st char *datamember) constReturn pointer to datamember object with name ""datamember"".Definition TClass.cxx:3506; TClass::fIsATVirtualIsAProxy * fIsADefinition TClass.h:229; TClass::GetListOfUsingDataMembersTList * GetListOfUsingDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of using declarations of a class.Definition TClass.cxx:3853; TClass::ForceReloadvoid ForceReload(TClass *oldcl)we found at least one equivalent.Definition TClass.cxx:1403; TClass::fDeleteArrayROOT::DelArrFunc_t fDeleteArrayDefinition TClass.h:238; TClass::CanSplitBool_t CanSplit() constReturn true if the data member of this TClass can be saved separately.Definition TClass.cxx:2386; TClass::fStreamerTClassStreamer * fStreamerDefinition TClass.h:226; TClass::SetDirectoryAutoAddvoid SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc)Install a new wrapper around the directory auto add function.Definition TClass.cxx:7095; TClass::NewArrayvoid * NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5260; TClass::fNoInfoOrEmuOrFwdDeclNameRegistrystatic TDeclNameRegistry fNoInfoOrEmuOrFwdDeclNameRegistryDefinition TClass.h:328; TClass::fFuncTemplateTListOfFunctionTemplates * fFuncTemplateDefinition TClass.h:206; TClass::fStreamerFuncClassStreamerFunc_t fStreamerFuncDefinition TClass.h:241; TClass::AdoptReferenceProxyvoid AdoptReferenceProxy(TVirtualRefProxy *proxy)Adopt the Reference proxy pointer to indicate that this class represents a reference.Definition TClass.cxx:6752; TClass::GetClassMethodTMethod * GetClassMethod(Longptr_t faddr)Look for a method in this class that has the interface function address faddr.Definition TClass.cxx:4550; TClass::DetermineCurrentStreamerInfoTVirtualStreamerInfo * DetermineCurrentStreamerInfo()Determine and set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5751; TClass::Browsevoid Browse(TBrowser *b) overrideThis method is call",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:311829,allocate,allocated,311829,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"st char* title, RooDataSet* ntuple, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, int nStart, int nStop, Bool_t copyCache, const char* wgtVarName = 0); RooArgSetaddWgtVar(const RooArgSet& origVars, const RooAbsArg* wgtVar); Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); voidRooDirItem::appendToDir(TObject* obj, Bool_t forceMemoryResident = kFALSE); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidinitialize(const char* wgtVarName); voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); voidRooDirItem::removeFromDir(TObject* obj); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataSet.html:15430,reduce,reduceEng,15430,root/html526/RooDataSet.html,https://root.cern,https://root.cern/root/html526/RooDataSet.html,2,['reduce'],['reduceEng']
Energy Efficiency,"st char*TTable::fgTypeName[13]. protected:. TTableDescriptor*fColDescriptors; TSeqCollection*TDataSet::fListList of the the the objects included into this dataset; Long_tTTable::fMaxIndexThe used capacity of this array; Int_tTTable::fNNumber of array elements; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; Long_tTTable::fSizeSize of the one element (row) of the table; Char_t*TTable::fTableArray of (fN*fSize) longs; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenericTable(const TTableDescriptor& dsc, const char* name). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object. TGenericTable(const TTableDescriptor& dsc, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - ""TGenericTable""; n - The initial number of allocated rows. TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGenericTable.html:16663,allocate,allocated,16663,root/html528/TGenericTable.html,https://root.cern,https://root.cern/root/html528/TGenericTable.html,4,['allocate'],['allocated']
Energy Efficiency,"st double* x). construct from an interface of a multi-dimensional function. GSLSimAnFunc(const ROOT::Math::IMultiGenFunction& func, const double* x, const double* scale). construct from an interface of a multi-dimensional function; Use optionally a scale factor (for each coordinate) which can be used to scale the step sizes; (this is used for example by the minimization algorithm). GSLSimAnFunc(). derived classes might need to re-define completely the class. {}. virtual ~GSLSimAnFunc(); virtual distructor (no operations). { }. GSLSimAnFunc & FastCopy(const ROOT::Math::GSLSimAnFunc& f). fast copy method called by GSL simuated annealing internally; copy only the things which have been changed; must be re-implemented by derived classes if needed. GSLSimAnFunc * Clone() const. clone method. Needs to be re-implemented by the derived classes for deep copying. return new GSLSimAnFunc(const ROOT::Math::GSLSimAnFunc& ). double Energy() const. evaluate the energy ( objective function value); re-implement by derived classes if needed to be modified. void Step(const ROOT::Math::GSLRandomEngine& r, double maxstep). change the x[i] value using a random value urndm generated between [0,1]; up to a maximum value maxstep; re-implement by derived classes if needed to be modified. double Distance(const ROOT::Math::GSLSimAnFunc& func) const. calculate the distance (metric) between this one and another configuration; Presently a cartesian metric is used.; re-implement by derived classes if needed to be modified. void Print(). print the position in the standard output ostream; GSL prints in addition n iteration, n function calls, temperature and energy; re-implement by derived classes if necessary. void SetX(const double* x). change the x values (used by sim annealing to take a step). void SetX(unsigned int i, double x). unsigned int NDim() const; { return fX.size(); }. double X(unsigned int i) const; { return fX[i]; }. const std::vector<double> & X() const; { return fX; }. double Scale(u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__GSLSimAnFunc.html:2835,energy,energy,2835,root/html534/ROOT__Math__GSLSimAnFunc.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLSimAnFunc.html,1,['energy'],['energy']
Energy Efficiency,"st double* x). construct from an interface of a multi-dimensional function. GSLSimAnFunc(const ROOT::Math::IMultiGenFunction& func, const double* x, const double* scale). construct from an interface of a multi-dimensional function; Use optionally a scale factor (for each coordinate) which can be used to scale the step sizes; (this is used for example by the minimization algorithm). GSLSimAnFunc(). derived classes might need to re-define completely the class. {}. virtual ~GSLSimAnFunc(); virtual distructor (no operations). { }. GSLSimAnFunc & FastCopy(const ROOT::Math::GSLSimAnFunc& f). fast copy method called by GSL simuated annealing internally; copy only the things which have been changed; must be re-implemented by derived classes if needed. GSLSimAnFunc * Clone() const. clone method. Needs to be re-implemented by the derived classes for deep copying. return new GSLSimAnFunc(const ROOT::Math::GSLSimAnFunc& ). double Energy() const. evaluate the energy ( objective function value); re-implement by derived classes if needed to be modified. void Step(const ROOT::Math::GSLRandomEngine& r, double maxstep). change the x[i] value using a random value urndm generated between [0,1]; up to a maximum value maxstep; re-implement by derived classes if needed to be modified. double Distance(const ROOT::Math::GSLSimAnFunc& func) const. calculate the distance (metric) between this one and another configuration; Presently a cartesian metric is used.; re-implement by derived classes if needed to be modified. void Print(). print the position in the standard output std::ostream; GSL prints in addition n iteration, n function calls, temperature and energy; re-implement by derived classes if necessary. void SetX(const double* x). change the x values (used by sim annealing to take a step). void SetX(unsigned int i, double x). unsigned int NDim() const; { return fX.size(); }. double X(unsigned int i) const; { return fX[i]; }. const std::vector<double> & X() const; { return fX; }. double Sc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__GSLSimAnFunc.html:2904,energy,energy,2904,root/html602/ROOT__Math__GSLSimAnFunc.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__GSLSimAnFunc.html,2,['energy'],['energy']
Energy Efficiency,"st of all members ; ROOT::Math::GSLDerivator Class ReferenceMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Differentiation. ; Class for computing numerical derivative of a function based on the GSL numerical algorithm This class is implemented using the numerical derivatives algorithms provided by GSL (see GSL Online Manual ). ; Definition at line 62 of file GSLDerivator.h. Public Member Functions;  GSLDerivator ();  Default Constructor of a GSLDerivator class based on GSL numerical differentiation algorithms. ;  ; virtual ~GSLDerivator ();  destructor (no operations) ;  ; double EvalBackward (double x, double h);  Computes the numerical derivative at a point x using an adaptive backward difference algorithm with a step size h. ;  ; double EvalCentral (double x, double h);  Computes the numerical derivative at a point x using an adaptive central difference algorithm with a step size h. ;  ; double EvalForward (double x, double h);  Computes the numerical derivative at a point x using an adaptive forward difference algorithm with a step size h. ;  ; void SetFunction (const IGenFunction &f);  Set the function for calculating the derivatives. ;  ; void SetFunction (GSLFuncPointer f, void *p=nullptr);  Set the function f for evaluating the derivative using a GSL function pointer type. ;  . — Static methods —; int fStatus;  ; double fResult;  ; double fError;  ; GSLFunctionWrapper fFunction;  ; int Status () const;  return the error status of the last integral calculation ;  ; double Result () const;  return the result of the last derivative calculation ;  ; double Error () const;  return the estimate of the absolute error of the last derivative calculation ;  ; static double EvalCentral (const IGenFunction &f, double x, double h);  Computes the numerical derivative of a function f at a point x using an adaptive central difference algorithm with a step size h. ;  ; static double EvalForward (const IGenFunction &f, double x, double h);  Computes the n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLDerivator.html:1207,adapt,adaptive,1207,doc/master/classROOT_1_1Math_1_1GSLDerivator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLDerivator.html,1,['adapt'],['adaptive']
Energy Efficiency,"st of classes.Definition TClassTree.h:22; It shows all the classes derived from the base class TH1. The TClassTree class uses the services of the class TPaveClass to show the class names. By clicking with the right mouse button in one TPaveClass object, one can invoke the following functions of TClassTree:; ShowLinks(option) with by default option = ""HMR""; Draw(classes). By default the class drawn is the one being pointed; ShowClassesUsedBy(classes) (by default the pointed class); ShowClassesUsing(classes) (by default the pointed class). The following picture has been generated with the following statements TClassTree tc1(""tc1"",""TH1"");; tc1.ShowLinks(""HMR"");. Note that in case of embedded classes or pointers to classes, the corresponding dashed lines or arrows respectively start in the TPaveClass object at an X position reflecting the position in the list of data members. References by data members to other classes are show with a full red line; Multiple inheritance is shown with a dashed blue line; ""Has a"" relation is shown with a dotted cyan line; References from code is shown by a full green line. Use TClassTree::SetSourceDir to specify the search path for source files. By default the search path includes the $ROOTSYS directory, the current directory and the subdirectory src.; The first time TClassTree::Draw is invoked, all the classes in the current application are processed, including the parsing of the code to find all classes referenced by the include statements. This process may take a few seconds. The following commands will be much faster.; A TClassTree object may be saved in a Root file. This object can be processed later by a Root program that ignores the original classes. This interesting possibility allows to send the class structure of an application to a colleague who does not have your classes.; Example: TFile f(""myClasses.root"",""recreate""); TClassTree *ct = new TClassTree(""ct"",""ATLF*""); ct->Write();; f#define f(i)Definition RSha256.hxx:104; TFileA R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassTree.html:3396,green,green,3396,doc/master/classTClassTree.html,https://root.cern,https://root.cern/doc/master/classTClassTree.html,1,['green'],['green']
Energy Efficiency,"st(b);;   b = v.BoostVector();   // b=(x/t,y/t,z/t). Rotations; There are four sets of functions to rotate the TVector3 component; of a TLorentzVector:. rotation around axes;   v.RotateX(TMath::Pi()/2.);;   v.RotateY(.5);;   v.RotateZ(.99);. rotation around an arbitary axis;   v.Rotate(TMath::Pi()/4., v1); // rotation around v1. transformation from rotated frame;   v.RotateUz(direction); //  direction must be a unit TVector3. by TRotation (see TRotation);   TRotation r;;   v.Transform(r);    or    ; v *= r; // Attention v=M*v. Misc. Angle between two vectors;   Double_t a = v1.Angle(v2.Vect());  // get angle between v1 and; v2. Light-cone components; Member functions Plus() and Minus() return the positive; and negative light-cone components:;   Double_t pcone = v.Plus();;   Double_t mcone = v.Minus();; CAVEAT: The values returned are T{+,-}Z. It is known that some authors; find it easier to define these components as (T{+,-}Z)/sqrt(2). Thus; check what definition is used in the physics you're working in and adapt; your code accordingly. Transformation by TLorentzRotation; A general Lorentz transformation see class TLorentzRotation can; be used by the Transform() member function, the *= or; * operator of the TLorentzRotation class:;   TLorentzRotation l;;   v.Transform(l);;   v = l*v;     or    ; v *= l;  // Attention v = l*v. Function Members (Methods); public:. virtual~TLorentzVector(); voidTObject::AbstractMethod(const char* method) const; Double_tAngle(const TVector3& v) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_tBeta() const; voidBoost(const TVector3&); voidBoost(Double_t, Double_t, Double_t); TVector3BoostVector() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TLorentzVector.html:6372,adapt,adapt,6372,root/html602/TLorentzVector.html,https://root.cern,https://root.cern/root/html602/TLorentzVector.html,2,['adapt'],['adapt']
Energy Efficiency,"st(b);;   b = v.BoostVector();   // b=(x/t,y/t,z/t). Rotations; There are four sets of functions to rotate the TVector3 component; of a TLorentzVector:. rotation around axes;   v.RotateX(TMath::Pi()/2.);;   v.RotateY(.5);;   v.RotateZ(.99);. rotation around an arbitary axis;   v.Rotate(TMath::Pi()/4., v1); // rotation around v1. transformation from rotated frame;   v.RotateUz(direction); //  direction must be a unit TVector3. by TRotation (see TRotation);   TRotation r;;   v.Transform(r);    or    ; v *= r; // Attention v=M*v. Misc. Angle between two vectors;   Double_t a = v1.Angle(v2.Vect());  // get angle between v1 and; v2. Light-cone components; Member functions Plus() and Minus() return the positive; and negative light-cone components:;   Double_t pcone = v.Plus();;   Double_t mcone = v.Minus();; CAVEAT: The values returned are T{+,-}Z. It is known that some authors; find it easier to define these components as (T{+,-}Z)/sqrt(2). Thus; check what definition is used in the physics you're working in and adapt; your code accordingly.; . Transformation by TLorentzRotation; A general Lorentz transformation see class TLorentzRotation can; be used by the Transform() member function, the *= or; * operator of the TLorentzRotation class:;   TLorentzRotation l;;   v.Transform(l);;   v = l*v;     or    ; v *= l;  // Attention v = l*v. Function Members (Methods); public:. TLorentzVector(); TLorentzVector(const Double_t* carray); TLorentzVector(const Float_t* carray); TLorentzVector(const TLorentzVector& lorentzvector); TLorentzVector(const TVector3& vector3, Double_t t); TLorentzVector(Double_t x, Double_t y, Double_t z, Double_t t); virtual~TLorentzVector(); voidTObject::AbstractMethod(const char* method) const; Double_tAngle(const TVector3& v) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_tBeta() const; voidBoost(const TVector3& b); voidBoost(Double_t, Double_t, Double_t); TVector3BoostVector() const; virtual voidTObject::Browse(TBrowser* b); static",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TLorentzVector.html:6372,adapt,adapt,6372,root/html534/TLorentzVector.html,https://root.cern,https://root.cern/root/html534/TLorentzVector.html,1,['adapt'],['adapt']
Energy Efficiency,"st(b);;   b = v.BoostVector();   // b=(x/t,y/t,z/t). Rotations; There are four sets of functions to rotate the TVector3 component; of a TLorentzVector:. rotation around axes;   v.RotateX(TMath::Pi()/2.);;   v.RotateY(.5);;   v.RotateZ(.99);. rotation around an arbitary axis;   v.Rotate(TMath::Pi()/4., v1); // rotation around v1. transformation from rotated frame;   v.RotateUz(direction); //  direction must be a unit TVector3. by TRotation (see TRotation);   TRotation r;;   v.Transform(r);    or    ; v *= r; // Attention v=M*v. Misc. Angle between two vectors;   Double_t a = v1.Angle(v2.Vect());  // get angle between v1 and; v2. Light-cone components; Member functions Plus() and Minus() return the positive; and negative light-cone components:;   Double_t pcone = v.Plus();;   Double_t mcone = v.Minus();; CAVEAT: The values returned are T{+,-}Z. It is known that some authors; find it easier to define these components as (T{+,-}Z)/sqrt(2). Thus; check what definition is used in the physics you're working in and adapt; your code accordingly.; . Transformation by TLorentzRotation; A general Lorentz transformation see class TLorentzRotation can; be used by the Transform() member function, the *= or; * operator of the TLorentzRotation class:;   TLorentzRotation l;;   v.Transform(l);;   v = l*v;     or    ; v *= l;  // Attention v = l*v. Function Members (Methods); public:. TLorentzVector(const Double_t* carray); TLorentzVector(const Float_t* carray); TLorentzVector(const TLorentzVector& lorentzvector); TLorentzVector(const TVector3& vector3, Double_t t); TLorentzVector(Double_t x = 0.0, Double_t y = 0.0, Double_t z = 0.0, Double_t t = 0.0); virtual~TLorentzVector(); voidTObject::AbstractMethod(const char* method) const; Double_tAngle(const TVector3& v) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_tBeta() const; voidBoost(const TVector3& b); voidBoost(Double_t, Double_t, Double_t); TVector3BoostVector() const; virtual voidTObject::Browse(TBrowser* b); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLorentzVector.html:6372,adapt,adapt,6372,root/html528/TLorentzVector.html,https://root.cern,https://root.cern/root/html528/TLorentzVector.html,3,['adapt'],['adapt']
Energy Efficiency,"st, . Option_t * ; drawOptions = """", . bool ; invisible = false . ). Add a TH1 histogram object to this plot. ; The specified options will be used to Draw() this object later. ""SAME"" will be added to the options if they are not already present. The caller transfers ownership of the object with this call, and the object will be deleted when its containing plot object is destroyed. ; Definition at line 385 of file RooPlot.cxx. ◆ Browse(). void RooPlot::Browse ; (; TBrowser * ; b). overridevirtual . Plot RooPlot when double-clicked in browser. ; Reimplemented from TObject.; Definition at line 1346 of file RooPlot.cxx. ◆ BuildLegend(). std::unique_ptr< TLegend > RooPlot::BuildLegend ; (; ); const. Build a legend that contains all objects that have been drawn on the plot. ; Definition at line 1412 of file RooPlot.cxx. ◆ chiSquare() [1/2]. double RooPlot::chiSquare ; (; const char * ; curvename, . const char * ; histname, . int ; nFitParam = 0 . ); const. Calculate and return reduced chi-squared between a curve and a histogram. ; Parameters. [in]curvenameName of the curve or nullptr for last curve ; [in]histnameName of the histogram to compare to or nullptr for last added histogram ; [in]nFitParamIf non-zero, reduce the number of degrees of freedom by this number. This means that the curve was fitted to the data with nFitParam floating parameters, which needs to be reflected in the calculation of \(\chi^2 / \mathrm{ndf}\). Returns\( \chi^2 / \mathrm{ndf} \) between the plotted curve and the data.; NoteThe \( \chi^2 \) is calculated between a plot of the original distribution and the data. It therefore has more rounding errors than directly calculating the \( \chi^2 \) from a PDF or function. To do this, use RooAbsReal::createChi2(RooDataHist&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&). ; Definition at line 1068 of file RooPlot.cxx. ◆ chiSquare() [2/2]. double RooPlot::chi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooPlot.html:32453,reduce,reduced,32453,doc/master/classRooPlot.html,https://root.cern,https://root.cern/doc/master/classRooPlot.html,1,['reduce'],['reduced']
Energy Efficiency,"st. TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<float>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<float>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSym_float_.html:17914,efficient,efficient,17914,root/html528/TMatrixTSym_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSym_float_.html,4,['efficient'],['efficient']
Energy Efficiency,"st. inline . some regularization of the DNN is turned on? ; Definition at line 813 of file NeuralNet.h. ◆ repetitions(). int TMVA::DNN::Settings::repetitions ; (; ); const. inline . how many steps have to be gone until the batch is changed ; Definition at line 773 of file NeuralNet.h. ◆ setDropOut(). template<typename Iterator > . void TMVA::DNN::Settings::setDropOut ; (; Iterator ; begin, . Iterator ; end, . size_t ; _dropRepetitions . ). inline . set the drop-out configuration (layer-wise) ; Parameters. beginbegin of an array or vector denoting the drop-out probabilities for each layer ; endend of an array or vector denoting the drop-out probabilities for each layer ; _dropRepetitionsdenotes after how many repetitions the drop-out setting (which nodes are dropped out exactly) is changed . Definition at line 759 of file NeuralNet.h. ◆ setMonitoring(). void TMVA::DNN::Settings::setMonitoring ; (; std::shared_ptr< Monitoring > ; ptrMonitoring). inline . prepared for monitoring ; Definition at line 764 of file NeuralNet.h. ◆ setProgressLimits(). virtual void TMVA::DNN::Settings::setProgressLimits ; (; double ; minProgress = 0, . double ; maxProgress = 100 . ). inlinevirtual . Parameters. maxProgressfor monitoring and logging (set the current ""progress"" limits for the display of the progress); minProgressminimum value; maxProgressmaximum value . Definition at line 790 of file NeuralNet.h. ◆ startTestCycle(). virtual void TMVA::DNN::Settings::startTestCycle ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 804 of file NeuralNet.h. ◆ startTrainCycle(). virtual void TMVA::DNN::Settings::startTrainCycle ; (; ). inlinevirtual . Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 782 of file NeuralNet.h. ◆ startTraining(). virtual void TMVA::DNN::Settings::startTraining ; (; ). inlinevirtual . Definition at line 795 of file NeuralNet.h. ◆ testIteration(). virtual void TMV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:11231,monitor,monitoring,11231,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['monitor'],['monitoring']
Energy Efficiency,"st; apply the principal component analysis; TODO: implementation of inverse transformation; Log() << kFATAL << ""Inverse transformation for PCA transformation not yet implemented. Hence, this transformation cannot be applied together with regression. Please contact the authors if necessary."" << Endl;. void CalculatePrincipalComponents(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); calculate the principal components for the signal and the background data; it uses the MakePrincipal method of ROOT's TPrincipal class. void X2P(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Calculate the principal components from the original data vector; x, and return it in p (function extracted from TPrincipal::X2P); It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). void P2X(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Perform the back-transformation from the principal components; pc, and return x; It's the users responsibility to make sure that both x and pc are; of the right size (i.e., memory must be allocated for p). void WriteTransformationToStream(ostream& ) const; write mean values to stream. void AttachXMLTo(void* parent); create XML description of PCA transformation. void ReadFromXML(void* trfnode); Read the transformation matrices from the xml node. void ReadTransformationFromStream(istream& , const TString& ); Read mean values from input stream. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); creates C++ code fragment of the PCA transform for inclusion in standalone C++ class. VariablePCATransform( DataSetInfo& dsi ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__VariablePCATransform.html:11362,allocate,allocated,11362,root/html534/TMVA__VariablePCATransform.html,https://root.cern,https://root.cern/root/html534/TMVA__VariablePCATransform.html,1,['allocate'],['allocated']
Energy Efficiency,"st; { return Pt(); }. Scalar T() const; { return E(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar M2() const. vector magnitude squared (or mass squared). { Scalar p = P(); return fE*fE - p*p; }. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { Scalar pz = Pz(); return fE*fE - pz*pz; }. Scalar Mt() const. transverse mass. Scalar Et() const. transverse energy. transverse energy. Scalar Et2() const. transverse energy squared. { Scalar et = Et(); return et*et; }. Scalar pi(); { return M_PI; }. void Restrict(). Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar phi). set phi value. void SetE(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar e). set E value. void SetPxPyPzE(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector. void Scale(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PtEtaPhiE4D_Double32_t_.html:7027,energy,energy,7027,root/html526/ROOT__Math__PtEtaPhiE4D_Double32_t_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PtEtaPhiE4D_Double32_t_.html,5,['energy'],['energy']
Energy Efficiency,"st; { return Pt(); }. Scalar T() const; { return E(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar M2() const. vector magnitude squared (or mass squared). { Scalar p = P(); return fE*fE - p*p; }. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { Scalar pz = Pz(); return fE*fE - pz*pz; }. Scalar Mt() const. transverse mass. Scalar Et() const. transverse energy. transverse energy. Scalar Et2() const. transverse energy squared. { Scalar et = Et(); return et*et; }. Scalar pi(); { return M_PI; }. void Restrict(). Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiE4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiE4D<double>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiE4D<double>::Scalar phi). set phi value. void SetE(ROOT::Math::PtEtaPhiE4D<double>::Scalar e). set E value. void SetPxPyPzE(ROOT::Math::PtEtaPhiE4D<double>::Scalar px, ROOT::Math::PtEtaPhiE4D<double>::Scalar py, ROOT::Math::PtEtaPhiE4D<double>::Scalar pz, ROOT::Math::PtEtaPhiE4D<double>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector. void Scale(ROOT::Math::PtEtaPhiE4D<double>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==============",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PtEtaPhiE4D_double_.html:6671,energy,energy,6671,root/html526/ROOT__Math__PtEtaPhiE4D_double_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PtEtaPhiE4D_double_.html,5,['energy'],['energy']
Energy Efficiency,"start a set of slave servers, or; directly starting as master server (if master = """"). For a description; of the arguments see the TProof ctor. Returns the number of started; master or slave servers, returns 0 in case of error, in which case; fValid remains false. Int_t GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); Set the sandbox path from ' Proof.Sandbox' or the alternative var 'rc'.; Use the existing setting or the default if nothing is found.; If 'assert' is kTRUE, make also sure that the path exists.; Return 0 on success, -1 on failure. void ParseConfigField(const char* config); The config file field may contain special instructions which need to be; parsed at the beginning, e.g. for debug runs with valgrind.; Several options can be given separated by a ','. Int_t AssertPath(const char* path, Bool_t writable); Make sure that 'path' exists; if 'writable' is kTRUE, make also sure; that the path is writable. void SetManager(TProofMgr* mgr); Set manager and schedule its destruction after this for clean; operations. Int_t AddWorkers(TList* wrks); Works on the master node only.; It starts workers on the machines in workerList and sets the paths,; packages and macros as on the master.; It is a subbstitute for StartSlaves(...); The code is mostly the master part of StartSlaves,; with the parallel startup removed. Int_t RemoveWorkers(TList* wrks); Used for shuting down the workres after a query is finished.; Sends each of the workers from the workerList, a kPROOF_STOP message.; If the workerList == 0, shutdown all the workers. Bool_t StartSlaves(Bool_t attach = kFALSE); Start up PROOF slaves. void Close(Option_t* option = """"); Close all open slave servers.; Client can decide to shutdown the remote session by passing option is 'S'; or 's'. Default for clients is detach, if supported. Masters always; shutdown the remote counterpart. TSlave * CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); Create a n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:39880,schedul,schedule,39880,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,1,['schedul'],['schedule']
Energy Efficiency,"start a set of slave servers, or; directly starting as master server (if master = """"). For a description; of the arguments see the TProof ctor. Returns the number of started; master or slave servers, returns 0 in case of error, in which case; fValid remains false. Int_t GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); Set the sandbox path from ' Proof.Sandbox' or the alternative var 'rc'.; Use the existing setting or the default if nothing is found.; If 'assert' is kTRUE, make also sure that the path exists.; Return 0 on success, -1 on failure. void ParseConfigField(const char* config); The config file field may contain special instructions which need to be; parsed at the beginning, e.g. for debug runs with valgrind.; Several options can be given separated by a ','. Int_t AssertPath(const char* path, Bool_t writable); Make sure that 'path' exists; if 'writable' is kTRUE, make also sure; that the path is writable. void SetManager(TProofMgr* mgr); Set manager and schedule its destruction after this for clean; operations. Int_t AddWorkers(TList* wrks); Works on the master node only.; It starts workers on the machines in workerList and sets the paths,; packages and macros as on the master.; It is a subbstitute for StartSlaves(...); The code is mostly the master part of StartSlaves,; with the parallel startup removed. void SetupWorkersEnv(TList* wrks, Bool_t increasingpool = kFALSE); Set up packages, loaded macros, include and lib paths ... Int_t RemoveWorkers(TList* wrks); Used for shuting down the workres after a query is finished.; Sends each of the workers from the workerList, a kPROOF_STOP message.; If the workerList == 0, shutdown all the workers. Bool_t StartSlaves(Bool_t attach = kFALSE); Start up PROOF slaves. void Close(Option_t* option = """"); Close all open slave servers.; Client can decide to shutdown the remote session by passing option is 'S'; or 's'. Default for clients is detach, if supported. Masters always; shutdown the remote counte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:37381,schedul,schedule,37381,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,2,['schedul'],['schedule']
Energy Efficiency,"starting point heuristic,; modified to ensure identical steps in the primal and dual variables. void DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); Monitor progress / convergence aat each interior-point iteration. Int_t DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Tests for termination. Unless the user supplies a specific termination; routine, this method calls another method defaultStatus, which returns; a code indicating the current convergence status. Int_t DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Default status method. TQpSolverBase & operator=(const TQpSolverBase& source); Assignment operator. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resids); alternative starting point heuristic: sets the; ""complementary"" variables to a large positive value; (based on the norm of the problem data) and the; remaining variables to zero. void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); perform monitor operation at each interior-point iteration. TQpLinSolverBase * GetLinearSystem(); default method for checking status. May be replaced; by a user-defined method. { return fSys; }. void SetMuTol(Double_t m); { fMutol = m; }. Double_t GetMuTol(); { return fMutol; }. void SetArTol(Double_t ar); { fArtol = ar; }. Double_t GetArTol(); { return fArtol; }. Double_t DataNorm(); { return fDnorm; }. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TQpSolverBase.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQpSolverBase.html:9836,monitor,monitor,9836,root/html528/TQpSolverBase.html,https://root.cern,https://root.cern/root/html528/TQpSolverBase.html,1,['monitor'],['monitor']
Energy Efficiency,"starting point heuristic,; modified to ensure identical steps in the primal and dual variables. void DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); Monitor progress / convergence aat each interior-point iteration. Int_t DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Tests for termination. Unless the user supplies a specific termination; routine, this method calls another method defaultStatus, which returns; a code indicating the current convergence status. Int_t DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Default status method. TQpSolverBase & operator=(const TQpSolverBase& source); Assignment operator. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resids); alternative starting point heuristic: sets the; ""complementary"" variables to a large positive value; (based on the norm of the problem data) and the; remaining variables to zero. void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); perform monitor operation at each interior-point iteration. TQpLinSolverBase * GetLinearSystem(); default method for checking status. May be replaced; by a user-defined method. { return fSys; }. void SetMuTol(Double_t m); { fMutol = m; }. Double_t GetMuTol(); { return fMutol; }. void SetArTol(Double_t ar); { fArtol = ar; }. Double_t GetArTol(); { return fArtol; }. Double_t DataNorm(); { return fDnorm; }. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TQpSolverBase.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TQpSolverBase.html:9905,monitor,monitor,9905,root/html530/TQpSolverBase.html,https://root.cern,https://root.cern/root/html530/TQpSolverBase.html,1,['monitor'],['monitor']
Energy Efficiency,"starting point heuristic,; modified to ensure identical steps in the primal and dual variables. void DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); Monitor progress / convergence aat each interior-point iteration. Int_t DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Tests for termination. Unless the user supplies a specific termination; routine, this method calls another method defaultStatus, which returns; a code indicating the current convergence status. Int_t DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Default status method. TQpSolverBase & operator=(const TQpSolverBase& source); Assignment operator. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resids); alternative starting point heuristic: sets the; ""complementary"" variables to a large positive value; (based on the norm of the problem data) and the; remaining variables to zero. void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); perform monitor operation at each interior-point iteration. TQpLinSolverBase * GetLinearSystem(); default method for checking status. May be replaced; by a user-defined method. { return fSys; }. void SetMuTol(Double_t m); { fMutol = m; }. Double_t GetMuTol(); { return fMutol; }. void SetArTol(Double_t ar); { fArtol = ar; }. Double_t GetArTol(); { return fArtol; }. Double_t DataNorm(); { return fDnorm; }. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TQpSolverBase.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQpSolverBase.html:9905,monitor,monitor,9905,root/html532/TQpSolverBase.html,https://root.cern,https://root.cern/root/html532/TQpSolverBase.html,1,['monitor'],['monitor']
Energy Efficiency,"static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::PDF::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::PDF::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 211 of file PDF.h. ◆ DeclareOptions(). void TMVA::PDF::DeclareOptions ; (; ). define the options (their key words) that can be set in the option string ; know options:; PDFInterpol[ivar] <string> Spline0, Spline1, Spline2 <default>, Spline3, Spline5, KDE used to interpolate reference histograms if no variable index is given, it is valid for ALL the variables. NSmooth <int> how often the input histos are smoothed; MinNSmooth <int> min number of smoothing iterations, for bins with most data; MaxNSmooth <int> max number of smoothing iterations, for bins with least data; NAvEvtPerBin <int> minimum average number of events per PDF bin; TransformOutput <bool> transform (often strongly peaked) likelihood output through sigmoid inversion; fKDEtype <KernelType> type of the Kernel to use (1 is Gaussian); fKDEiter <KerneIter> number of iterations (1 --> ""static KDE"", 2 --> ""adaptive KDE""); fBorderMethod <KernelBorder> the method to take care about ""border"" effects (1=no treatment , 2=kernel renormalization, 3=sample mirroring) . Definition at line 820 of file PDF.cxx. ◆ DeclFileName(). static const char * TMVA::PDF::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 211 of file PDF.h. ◆ FillHistToGraph(). void TMVA::PDF::FillHistToGraph ; (; ). private . Simple conversion. ; Definition at line 514 of file PDF.cxx. ◆ FillSplineToHist(). void TMVA::PDF::FillSplineToHist ; (; ). private . creates high-binned reference histogram to be used instead of the PDF for speed reasons ; Definition at line 523 of file PDF.cxx. ◆ FindBinInverse(). void TMVA::PDF::FindBinInverse ; (; const TH1 * ; histogram, . Int_t & ; lowerBin, . I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PDF.html:22318,adapt,adaptive,22318,doc/master/classTMVA_1_1PDF.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PDF.html,1,['adapt'],['adaptive']
Energy Efficiency,"static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsrelative required FCN accuracy at minimum; Double_tfInitialTemperatureinitial temperature (depends on FCN); TStringfKernelTemperatureSstring just to set fKernelTemperature; Int_tfMaxCallsmax number of FCN calls; Double_tfMinTemperatureminimum temperature before SA quit; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealingFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); declare SA options. void SetParameters(Int_t fMaxCalls, Double_t fInitialTemperature, Double_t fMinTemperature, Double_t fEps, TString fKernelTemperatureS, Double_t fTemperatureScale, Double_t fTemperatureAdaptiveStep, Bool_t fUseDefaultScale, Bool_t fUseDefaultTemperature); set SA configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. SimulatedAnnealing",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__SimulatedAnnealingFitter.html:8384,adapt,adaptive,8384,root/html602/TMVA__SimulatedAnnealingFitter.html,https://root.cern,https://root.cern/root/html602/TMVA__SimulatedAnnealingFitter.html,4,['adapt'],['adaptive']
Energy Efficiency,"static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_t*fAllocSize![fNumPIDs] allocated size of array fParentIDs for each ProcessID; Int_tfDefaultSize!default size for a new PID array; vector<Int_t>fMapPIDtoInternal! cache of pid to index in fProcessGUIDs; Int_t*fN![fNumPIDs] current maximum number of IDs in array fParentIDs for each ProcessID; Int_tfNumPIDs!number of known ProcessIDs; TObject*fOwnerObject owning this TRefTable; Int_tfParentID!current parent ID in fParents (latest call to SetParent); Int_t**fParentIDs![fNumPIDs][fAllocSize] array of Parent IDs; TObjArray*fParentsarray of Parent objects (eg TTree branch) holding the referenced objects; vector<string>fProcessGUIDsUUIDs of TProcessIDs used in fParentIDs; Int_tfSizedummy for backward compatibility; UInt_tfUID!Current uid (set by TRef::GetObject); TProcessID*fUIDContext!TProcessID the current uid is referring to; static TRefTable*fgRefTablePointer to current TRefTable. Class Charts. Inheritance Chart:. TObject. ←; TRefTable. Function documentation; TRefTable(); Default constructor for I/O. TRefTable(TObject* owner, Int_t size); Create a TRefTable with initial size. ~TRefTable(); Destructor. Int_t Add(Int_t uid, TProcessID* context = 0); Add a new uid to the table.; we add a new pair (uid,fparent) to the map; This function is called by TObject::Streamer or TStreamerInfo::WriteBuffer. Int_t AddInternalIdxForPID(TProcessID* procid); Add the internal index for fProcessIDs, fAllocSize, etc given a PID. void Clear(Op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRefTable.html:7855,allocate,allocated,7855,root/html602/TRefTable.html,https://root.cern,https://root.cern/root/html602/TRefTable.html,2,['allocate'],['allocated']
Energy Efficiency,"static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TMonitor::EInterestkRead; static TObject::(anonymous)TObject::kSingleKey; static TMonitor::EInterestkWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMonitor.html:10679,monitor,monitor,10679,root/html602/TMonitor.html,https://root.cern,https://root.cern/root/html602/TMonitor.html,2,['monitor'],['monitor']
Energy Efficiency,"std::string_view name, std::string_view type, ENTupleStructure structure, bool isSimple, std::size_t nRepetitions=0);  The constructor creates the underlying column objects and connects them to either a sink or a source. ;  ; virtual ~RFieldBase ()=default;  ; RSchemaIterator begin ();  ; RConstSchemaIterator begin () const;  ; RValue BindValue (std::shared_ptr< void > objPtr);  Creates a value from a memory location with an already constructed object. ;  ; RConstSchemaIterator cbegin () const;  ; RConstSchemaIterator cend () const;  ; std::unique_ptr< RFieldBase > Clone (std::string_view newName) const;  Copies the field and its sub fields using a possibly new name and a new, unconnected set of columns. ;  ; RBulk CreateBulk ();  The returned bulk is initially empty; RBulk::ReadBulk will construct the array of values. ;  ; template<> ; std::unique_ptr< void, typename RFieldBase::RCreateObjectDeleter< void >::deleter > CreateObject () const;  ; template<typename T > ; std::unique_ptr< T, typename RCreateObjectDeleter< T >::deleter > CreateObject () const;  Generates an object of the field type and allocates new initialized memory according to the type. ;  ; template<> ; std::unique_ptr< void, typename ROOT::Experimental::RFieldBase::RCreateObjectDeleter< void >::deleter > CreateObject () const;  ; RValue CreateValue ();  Generates an object of the field type and wraps the created object in a shared pointer and returns it an RValue connected to the field. ;  ; RSchemaIterator end ();  ; RConstSchemaIterator end () const;  ; RColumnRepresentations::Selection_t GetColumnRepresentatives () const;  Returns the fColumnRepresentative pointee or, if unset, the field's default representative. ;  ; const std::string & GetDescription () const;  Get the field's description. ;  ; const std::string & GetFieldName () const;  ; virtual std::uint32_t GetFieldVersion () const;  Indicates an evolution of the mapping scheme from C++ type to columns. ;  ; std::size_t GetNRepetitions () ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RField.html:2954,allocate,allocates,2954,doc/master/classROOT_1_1Experimental_1_1RField.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RField.html,1,['allocate'],['allocates']
Energy Efficiency,"stogram. Int_t addVarSet(const RooArgList& vars). Int_t addParamSet(const RooArgList& params). Double_t evaluate() const. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implement analytical integrations by doing appropriate weighting from component integrals; functions to integrators of components. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. TObject* clone(const char* newname) const; { return new ParamHistFunc(*this, newname); }. const RooArgList& paramList() const; { return _paramSet ; }. Int_t numBins() const; { return _dataSet.numEntries(); }. const RooArgSet* get(Int_t masterIdx) const; { return _dataSet.get( masterIdx ) ; }. const RooArgSet* get(const RooArgSet& coord) const; { return _dataSet.get( coord ) ; }. double binVolume() const; { return _dataSet.binVolume(); }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; { return kTRUE ; }. Bool_t isBinnedDistribution(const RooArgSet& ) const; {return kTRUE;}. » Author: George Lewis, Kyle Cranmer » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: cranmer $ » Last generated: 2015-03-10 17:09; This page has been automatically generated. For comments or suggestions regarding the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ParamHistFunc.html:39783,efficient,efficiently,39783,root/html534/ParamHistFunc.html,https://root.cern,https://root.cern/root/html534/ParamHistFunc.html,1,['efficient'],['efficiently']
Energy Efficiency,"stogram. Int_t addVarSet(const RooArgList& vars). Int_t addParamSet(const RooArgList& params). Double_t evaluate() const. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implement analytical integrations by doing appropriate weighting from component integrals; functions to integrators of components. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. TObject* clone(const char* newname) const; { return new ParamHistFunc(*this, newname); }. const RooArgList& paramList() const; { return _paramSet ; }. Int_t numBins() const; { return _dataSet.numEntries(); }. const RooArgSet* get(Int_t masterIdx) const; { return _dataSet.get( masterIdx ) ; }. const RooArgSet* get(const RooArgSet& coord) const; { return _dataSet.get( coord ) ; }. double binVolume() const; { return _dataSet.binVolume(); }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; { return kTRUE ; }. Bool_t isBinnedDistribution(const RooArgSet& ) const; {return kTRUE;}. » Author: George Lewis, Kyle Cranmer » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: cranmer $ » Last generated: 2015-06-02 15:18; This page has been automatically generated. For comments or suggestions regarding the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ParamHistFunc.html:41287,efficient,efficiently,41287,root/html604/ParamHistFunc.html,https://root.cern,https://root.cern/root/html604/ParamHistFunc.html,1,['efficient'],['efficiently']
Energy Efficiency,"stogram. Int_t addVarSet(const RooArgList& vars). Int_t addParamSet(const RooArgList& params). Double_t evaluate() const. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implement analytical integrations by doing appropriate weighting from component integrals; functions to integrators of components. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. TObject* clone(const char* newname) const; { return new ParamHistFunc(*this, newname); }. const RooArgList& paramList() const; { return _paramSet ; }. Int_t numBins() const; { return _dataSet.numEntries(); }. const RooArgSet* get(Int_t masterIdx) const; { return _dataSet.get( masterIdx ) ; }. const RooArgSet* get(const RooArgSet& coord) const; { return _dataSet.get( coord ) ; }. double binVolume() const; { return _dataSet.binVolume(); }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; { return kTRUE ; }. Bool_t isBinnedDistribution(const RooArgSet& ) const; {return kTRUE;}. » Author: George Lewis, Kyle Cranmer » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: cranmer $ » Last generated: 2015-06-30 14:21; This page has been automatically generated. For comments or suggestions regarding the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ParamHistFunc.html:41287,efficient,efficiently,41287,root/html602/ParamHistFunc.html,https://root.cern,https://root.cern/root/html602/ParamHistFunc.html,1,['efficient'],['efficiently']
Energy Efficiency,"stom streamer (member function).Definition TClass.cxx:2939; TClass::RemoveStreamerInfovoid RemoveStreamerInfo(Int_t slot)Remove and delete the StreamerInfo in the given slot.Definition TClass.cxx:7320; TClass::SetCanSplitvoid SetCanSplit(Int_t splitmode)Set the splitability of this class:Definition TClass.cxx:5658; TClass::AddInstancevoid AddInstance(Bool_t heap=kFALSE)Definition TClass.h:381; TClass::CreateListOfDataMembersTList * CreateListOfDataMembers(std::atomic< TListOfDataMembers * > &data, TDictionary::EMemberSelection selection, bool load)Create the list containing the TDataMembers (of actual data members or members pulled in through usin...Definition TClass.cxx:3741; TClass::GetStreamerInfoAbstractEmulatedTVirtualStreamerInfo * GetStreamerInfoAbstractEmulated(Int_t version=0) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4709; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:4978; TClass::SetMergevoid SetMerge(ROOT::MergeFunc_t mergeFunc)Install a new wrapper around 'Merge'.Definition TClass.cxx:6969; TClass::fConversionStreamerInfoConvSIMap_t fConversionStreamerInfoDefinition TClass.h:199; TClass::fDirAutoAddROOT::DirAutoAdd_t fDirAutoAddDefinition TClass.h:240; TClass::HasDataMemberInfoBool_t HasDataMemberInfo() constDefinition TClass.h:407; TClass::fRefProxyTVirtualRefProxy * fRefProxycached streamer info used in the last read.Definition TClass.h:280; TClass::GetMenuListTList * GetMenuList() constReturn the list of menu items associated with the class.Definition TClass.cxx:4341; TClass::fMergeROOT::MergeFunc_t fMergesaved info to call a IsA member functionDefinition TClass.h:233; TClass::GetMethodTMethod * GetMethod(const char *method, const char *params, Bool_t objectIsConst=kFALSE)Find the best method (if there is one) matching the parameters.Definition T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:45604,allocate,allocated,45604,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,1,['allocate'],['allocated']
Energy Efficiency,"stom streamer (member function).Definition TClass.cxx:3006; TClass::RemoveStreamerInfovoid RemoveStreamerInfo(Int_t slot)Remove and delete the StreamerInfo in the given slot.Definition TClass.cxx:7387; TClass::SetCanSplitvoid SetCanSplit(Int_t splitmode)Set the splitability of this class:Definition TClass.cxx:5725; TClass::AddInstancevoid AddInstance(Bool_t heap=kFALSE)Definition TClass.h:381; TClass::CreateListOfDataMembersTList * CreateListOfDataMembers(std::atomic< TListOfDataMembers * > &data, TDictionary::EMemberSelection selection, bool load)Create the list containing the TDataMembers (of actual data members or members pulled in through usin...Definition TClass.cxx:3808; TClass::GetStreamerInfoAbstractEmulatedTVirtualStreamerInfo * GetStreamerInfoAbstractEmulated(Int_t version=0) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4776; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::SetMergevoid SetMerge(ROOT::MergeFunc_t mergeFunc)Install a new wrapper around 'Merge'.Definition TClass.cxx:7036; TClass::fConversionStreamerInfoConvSIMap_t fConversionStreamerInfoDefinition TClass.h:199; TClass::fDirAutoAddROOT::DirAutoAdd_t fDirAutoAddDefinition TClass.h:240; TClass::HasDataMemberInfoBool_t HasDataMemberInfo() constDefinition TClass.h:407; TClass::fRefProxyTVirtualRefProxy * fRefProxycached streamer info used in the last read.Definition TClass.h:280; TClass::GetMenuListTList * GetMenuList() constReturn the list of menu items associated with the class.Definition TClass.cxx:4408; TClass::fMergeROOT::MergeFunc_t fMergesaved info to call a IsA member functionDefinition TClass.h:233; TClass::GetMethodTMethod * GetMethod(const char *method, const char *params, Bool_t objectIsConst=kFALSE)Find the best method (if there is one) matching the parameters.Definition T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:45432,allocate,allocated,45432,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,1,['allocate'],['allocated']
Energy Efficiency,"string class.Definition TString.h:139; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; bool; double; int; TGeant4Unit::fine_structure_conststatic constexpr double fine_structure_constDefinition TGeant4PhysicalConstants.h:90; TGeant4Unit::cm2static constexpr double cm2Definition TGeant4SystemOfUnits.h:113; TGeant4Unit::Avogadrostatic constexpr double AvogadroDefinition TGeant4PhysicalConstants.h:43; TGeant4Unit::cmstatic constexpr double cmDefinition TGeant4SystemOfUnits.h:112; TGeoUnit::amustatic constexpr double amuDefinition TGeoPhysicalConstants.h:77; TGeoUnit::cmstatic constexpr double cmDefinition TGeoSystemOfUnits.h:116; TGeoUnit::fine_structure_conststatic constexpr double fine_structure_constDefinition TGeoPhysicalConstants.h:90; TGeoUnit::cm2static constexpr double cm2Definition TGeoSystemOfUnits.h:117; TGeoUnit::Avogadrostatic constexpr double AvogadroDefinition TGeoPhysicalConstants.h:43; TGeoUnit::gstatic constexpr double gDefinition TGeoSystemOfUnits.h:207; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123. geomgeomsrcTGeoMaterial.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html:69581,power,power,69581,doc/master/TGeoMaterial_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html,2,['power'],['power']
Energy Efficiency,"string& func, vector<string>& args). string processCreateVar(string& func, vector<string>& args); Glue function between high-level syntax and low-level factory call to createVariable:; Process a parsed call to create a variable named 'func'. If initial token is non-numeric, a RooCategory will be created, and the args are interpreted; as either state names or 'name=id' assignments. Otherwise a RooRealvar is created and the; arg list is interpreted as follows:; If list has two args, these are interpreted as xmin,xmax; If list has three args, these are interpreted as xinit,xmin,xmax; If list has one arg, this is interpreted as xinit and the variable is set as constant. string processCreateArg(string& func, vector<string>& args); Glue function between high-level syntax and low-level factory call to createArg:; Process a parsed call to create a p.d.f named func. The func arg is interpreted as ClassName::ObjectName and the arglist is passed; verbatim to createArg. The received arglist is expected to be fully reduced (i.e.; all inline object creations must have been compiled). std::string processMetaArg(string& func, vector<string>& args); Concatenate list of args into comma separated string. vector<string> splitFunctionArgs(const char* funcExpr); Allocate and fill work buffer. Bool_t checkSyntax(const char* arg); Perform basic syntax on given factory expression. If function returns; true syntax errors are found. void checkIndex(UInt_t index). RooAbsArg& asARG(const char* ); CINT constructor interface, return constructor string argument #idx as RooAbsArg reference found in workspace. RooAbsReal& asFUNC(const char* ); CINT constructor interface, return constructor string argument #idx as RooAbsReal reference found in workspace. RooAbsRealLValue& asVARLV(const char* ); CINT constructor interface, return constructor string argument #idx as RooAbsRealLValue reference found in workspace. RooRealVar& asVAR(const char* ); CINT constructor interface, return constructor string argum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFactoryWSTool.html:20227,reduce,reduced,20227,root/html602/RooFactoryWSTool.html,https://root.cern,https://root.cern/root/html602/RooFactoryWSTool.html,2,['reduce'],['reduced']
Energy Efficiency,"strings for the MinMax and RMS methods, respectively:; 360 //; 361 // ""!H:!V:VolumeRangeMode=MinMax:DeltaFrac=0.2:KernelEstimator=Gauss:GaussSigma=0.3"" );; 362 // ""!H:!V:VolumeRangeMode=RMS:DeltaFrac=3:KernelEstimator=Gauss:GaussSigma=0.3"" );; 363 if (Use[""PDERS""]); 364 factory->BookMethod( dataloader, TMVA::Types::kPDERS, ""PDERS"",; 365 ""!H:!V:NormTree=T:VolumeRangeMode=Adaptive:KernelEstimator=Gauss:GaussSigma=0.3:NEventsMin=400:NEventsMax=600"" );; 366 ; 367 if (Use[""PDERSD""]); 368 factory->BookMethod( dataloader, TMVA::Types::kPDERS, ""PDERSD"",; 369 ""!H:!V:VolumeRangeMode=Adaptive:KernelEstimator=Gauss:GaussSigma=0.3:NEventsMin=400:NEventsMax=600:VarTransform=Decorrelate"" );; 370 ; 371 if (Use[""PDERSPCA""]); 372 factory->BookMethod( dataloader, TMVA::Types::kPDERS, ""PDERSPCA"",; 373 ""!H:!V:VolumeRangeMode=Adaptive:KernelEstimator=Gauss:GaussSigma=0.3:NEventsMin=400:NEventsMax=600:VarTransform=PCA"" );; 374 ; 375 // Multi-dimensional likelihood estimator using self-adapting phase-space binning; 376 if (Use[""PDEFoam""]); 377 factory->BookMethod( dataloader, TMVA::Types::kPDEFoam, ""PDEFoam"",; 378 ""!H:!V:SigBgSeparate=F:TailCut=0.001:VolFrac=0.0666:nActiveCells=500:nSampl=2000:nBin=5:Nmin=100:Kernel=None:Compress=T"" );; 379 ; 380 if (Use[""PDEFoamBoost""]); 381 factory->BookMethod( dataloader, TMVA::Types::kPDEFoam, ""PDEFoamBoost"",; 382 ""!H:!V:Boost_Num=30:Boost_Transform=linear:SigBgSeparate=F:MaxDepth=4:UseYesNoCell=T:DTLogic=MisClassificationError:FillFoamWithOrigWeights=F:TailCut=0:nActiveCells=500:nBin=20:Nmin=400:Kernel=None:Compress=T"" );; 383 ; 384 // K-Nearest Neighbour classifier (KNN); 385 if (Use[""KNN""]); 386 factory->BookMethod( dataloader, TMVA::Types::kKNN, ""KNN"",; 387 ""H:nkNN=20:ScaleFrac=0.8:SigmaFact=1.0:Kernel=Gaus:UseKernel=F:UseWeight=T:!Trim"" );; 388 ; 389 // H-Matrix (chi2-squared) method; 390 if (Use[""HMatrix""]); 391 factory->BookMethod( dataloader, TMVA::Types::kHMatrix, ""HMatrix"", ""!H:!V:VarTransform=None"" );; 392 ; 393 // Linear discriminant (same a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C_source.html:17762,adapt,adapting,17762,doc/master/TMVAClassification_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C_source.html,1,['adapt'],['adapting']
Energy Efficiency,"structor. ; Definition at line 213 of file TMehrotraSolver.cxx. Member Function Documentation. ◆ Class(). static TClass * TMehrotraSolver::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMehrotraSolver::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMehrotraSolver::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 85 of file TMehrotraSolver.h. ◆ DeclFileName(). static const char * TMehrotraSolver::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 85 of file TMehrotraSolver.h. ◆ DefMonitor(). void TMehrotraSolver::DefMonitor ; (; TQpDataBase * ; data, . TQpVar * ; vars, . TQpResidual * ; resids, . Double_t ; alpha, . Double_t ; sigma, . Int_t ; i, . Double_t ; mu, . Int_t ; status_code, . Int_t ; level . ). overridevirtual . Print information about the optimization process and monitor the convergence status of thye algorithm. ; Implements TQpSolverBase.; Definition at line 171 of file TMehrotraSolver.cxx. ◆ IsA(). TClass * TMehrotraSolver::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 85 of file TMehrotraSolver.h. ◆ operator=(). TMehrotraSolver & TMehrotraSolver::operator= ; (; const TMehrotraSolver & ; source). Assignment operator. ; Definition at line 222 of file TMehrotraSolver.cxx. ◆ Solve(). Int_t TMehrotraSolver::Solve ; (; TQpDataBase * ; prob, . TQpVar * ; iterate, . TQpResidual * ; resid . ). overridevirtual . Solve the quadratic programming problem as formulated through prob, store the final solution in iterate->fX . ; Monitor the residuals during the iterations through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . ; Implements TQpSolverBase.; Definition at line 97 of file TMehrotraSolver.cxx. ◆ Streamer(). void TMehrotraSolver:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMehrotraSolver.html:15411,monitor,monitor,15411,doc/master/classTMehrotraSolver.html,https://root.cern,https://root.cern/doc/master/classTMehrotraSolver.html,1,['monitor'],['monitor']
Energy Efficiency,style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  ;  Static Public Member Functions inherited from TAttText; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Attributes; Float_t fBlue;  Per cent of blue. ;  ; Bool_t fBoundingBox;  True for Encapsulated PostScript. ;  ; Bool_t fClear;  True when page must be cleared. ;  ; Int_t fClip;  Clipping mode. ;  ; Bool_t fClipStatus;  Clipping Indicator. ;  ; Int_t fCurrentColor;  current Postscript color index ;  ; Float_t fDXC;  ; Float_t fDYC;  ; TString fFileName;  PS file name. ;  ; Bool_t fFontEmbed;  True is FontEmbed has been called. ;  ; Float_t fFX;  ; Float_t fFY;  ; Float_t fGreen;  Per cent of green. ;  ; Int_t fIXzone;  Current zone along X. ;  ; Int_t fIYzone;  Current zone along Y. ;  ; Int_t fLastCellBlue;  Last blue value. ;  ; Int_t fLastCellGreen;  Last green value. ;  ; Int_t fLastCellRed;  Last red value. ;  ; Float_t fLineScale;  Line width scale factor. ;  ; Float_t fMarkerSizeCur;  current transformed value of marker size ;  ; Int_t fMaxLines;  Maximum number of lines in a PS array. ;  ; Float_t fMaxsize;  Largest dimension of X and Y. ;  ; Int_t fMode;  PostScript mode. ;  ; Int_t fNbCellLine;  Number of boxes in the current line. ;  ; Int_t fNbCellW;  Number of boxes per line. ;  ; Int_t fNbinCT;  Number of entries in the current Cell Array. ;  ; Int_t fNBSameColorCell;  Number of boxes with the same color. ;  ; Int_t fNpages;  number of pages ;  ; Int_t fNXzone;  Number of zones along X. ;  ; Int_t fNYzone;  Number of zones along Y. ;  ; char fPatterns [32];  Indicate if pattern n is defined. ;  ; Bool_t fRange;  True when a range has been defined. ;  ; Float_t fRed;  Per cent of red. ;  ; Int_t fSave;  Number of gsave for restore. ;  ; Int_t fType;  PostScript workstation type. ;  ; Float_t fX1v;  X bottom left cor,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPostScript.html:32876,green,green,32876,doc/master/classTPostScript.html,https://root.cern,https://root.cern/doc/master/classTPostScript.html,1,['green'],['green']
Energy Efficiency,"sult and relerr contain the values obtainable for the specified value of maxpts.; size is too small for the specified number MAXPTS of function evaluations.; n<2 or n>15. Method:; An integration rule of degree seven is used together with a certain strategy of subdivision. For a more detailed description of the method see References. Notes:; 1..Multi-dimensional integration is time-consuming. For each rectangular subregion, the routine requires function evaluations. Careful programming of the integrand might result in substantial saving of time. 2..Numerical integration usually works best for smooth functions. Some analysis or suitable transformations of the integral prior to numerical work may contribute to numerical efficiency. References:. A.C. Genz and A.A. Malik, Remarks on algorithm 006: An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; A. van Doren and L. de Ridder, An adaptive algorithm for numerical integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. . Definition at line 84 of file AdaptiveIntegratorMultiDim.h. Public Member Functions;  AdaptiveIntegratorMultiDim (const IMultiGenFunction &f, double absTol=0.0, double relTol=1E-9, unsigned int maxcall=100000, unsigned int size=0);  Construct with a reference to the integrand function and given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and size of the working array. ;  ;  AdaptiveIntegratorMultiDim (double absTol=0.0, double relTol=1E-9, unsigned int maxpts=100000, unsigned int size=0);  Construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and size of the working array. ;  ;  ~AdaptiveIntegratorMultiDim () override;  destructor (no operations) ;  ; double Error () const override;  return integration error ;  ; double Integral (const double *xmin, const double *xmax) override;  evaluate the integra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html:2706,adapt,adaptive,2706,doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html,1,['adapt'],['adaptive']
Energy Efficiency,"sum() has three overloads. Two of these overloads accept a sumSet parameter to not sum over all variables. These two overloads previously behaved inconsistently when the correctForBinSize or inverseBinCor flags were set. If you use the RooDataHist::sum() function in you own classes, please check that it can still be used with its new logic. The new and corrected bin correction behaviour is:. correctForBinSize: multiply counts in each bin by the bin volume corresponding to the variables in sumSet; inverseBinCor: divide counts in each bin by the bin volume corresponding to the variables not in sumSet. New fully parametrised Crystal Ball shape class; So far, the Crystal Ball distribution has been represented in RooFit only by the RooCBShape class, which has a Gaussian core and a single power-law tail on one side. This release introduces RooCrystalBall, which implements some common generalizations of the Crystal Ball shape:. symmetric or asymmetric power-law tails on both sides; different width parameters for the left and right sides of the Gaussian core. The new RooCrystalBall class can substitute the RooDSCBShape and RooSDSCBShape, which were passed around in the community.; 2D Graphics Libraries. Add the method AddPointto TGraph(x,y) and TGraph2D(x,y,z), equivalent to SetPoint(g->GetN(),x,y)and SetPoint(g->GetN(),x,y,z); Option E0 draws error bars and markers are drawn for bins with 0 contents. Now, combined with options E1 and E2, it avoids error bars clipping.; Fix TAxis::ChangeLabel for vertical axes and 3D plots. Networking Libraries; Multithreaded support for FastCGI; Now when THttpServer creates FastCGI engine, 10 worker threads used to process requests received via FastCGI channel. This significantly increase a performance, especially when several clients are connected.; Better security for THttpServer with webgui; If THttpServer created for use with webgui widgets (RBrowser, RCanvas, REve), it only will provide access to the widgets via websocket connection - ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:25779,power,power-law,25779,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['power'],['power-law']
Energy Efficiency,"surement:. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y. From simulation:. A: migration matrix (dimension ny x nx). Result. x: unknown underlying distribution (dimension nx); The error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation strength; L: matrix of regularisation conditions (dimension nl x nx); depends on the structure of the input data; x0: bias distribution, from simulation. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. Determination of the unfolding result x:. (a) not constrained: minimisation is performed as a function of x; for fixed lambda=0; or; (b) constrained: stationary point is found as a function of x and lambda. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documentation is available here:; http://www.desy.de/~sschmitt. Note:; For most applications it is better to use the derived class; TUnfoldSys or even better TUnfoldDensity. TUnfoldSys extends the functionality of TUnfold; such that systematic errors are propagated to teh result; and that the unfolding can be done with proper background; subtraction. TUnfoldDensity extends further the functionality of TUnfoldSys; complex binning schemes are supported; The binning of input histograms is handeld consisten",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfold.html:2499,reduce,reduce,2499,root/html534/TUnfold.html,https://root.cern,https://root.cern/root/html534/TUnfold.html,3,['reduce'],['reduce']
Energy Efficiency,"surface; computation of the total track length along a helix . Definition at line 19 of file TGeoHelix.h. Public Types; enum  EGeoHelixTypes { kHelixNeedUpdate = (1ULL << ( 16 )); , kHelixStraight = (1ULL << ( 17 )); , kHelixCircle = (1ULL << ( 18 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TGeoHelix ();  Dummy constructor. ;  ;  TGeoHelix (Double_t curvature, Double_t step, Int_t charge=1);  Normal constructor. ;  ;  ~TGeoHelix () override;  Destructor. ;  ; Double_t ComputeSafeStep (Double_t epsil=1E-6) const;  Compute safe linear step that can be made such that the error between linear-helix extrapolation is less than EPSIL. ;  ; const Double_t * GetCurrentDirection () const;  ; const Double_t * GetCurrentPoint () const;  ; Double_t GetStep () const;  ; Double_t GetTotalCurvature () const;  Compute helix total curvature. ;  ; Double_t GetXYcurvature () const;  ; void InitDirection (Double_t *dir, Bool_t is_normalized=kTRUE);  Initialize particle direction (tangent on the helix in initial point) ;  ; void InitDirection (Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized=kTRUE);  Initialize particle direction (tangent on the helix in initial point) ;  ; void InitPoint (Double_t *point);  Set initial point on the helix. ;  ; void InitPoint (Double_t x0, Double_t y0, Double_t z0);  Initialize coordinates of a point on the helix. ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHelix.html:2616,charge,charge,2616,doc/master/classTGeoHelix.html,https://root.cern,https://root.cern/doc/master/classTGeoHelix.html,1,['charge'],['charge']
Energy Efficiency,"system. void InitializeGraphics(); Initialize the graphics environment. void ClearInputFiles(); Clear list containing macro files passed as program arguments.; This method is called from TRint::Run() to ensure that the macro; files are only executed the first time Run() is called. char * Argv(Int_t index) const; Return specified argument. void GetOptions(Int_t* argc, char** argv); Get and handle command line options. Arguments handled are removed; from the argument array. The following arguments are handled:; -b : run in batch mode without graphics; -x : exit on exception; -n : do not execute logon and logoff macros as specified in .rootrc; -q : exit after processing command line macro files; -l : do not show splash screen; The last three options are only relevant in conjunction with TRint.; The following help and info arguments are supported:; -? : print usage; -h : print usage; --help : print usage; -config : print ./configure options; -memstat : run with memory usage monitoring; In addition to the above options the arguments that are not options,; i.e. they don't start with - or + are treated as follows (and also removed; from the argument array):; <dir> is considered the desired working directory and available; via WorkingDirectory(), if more than one dir is specified the; first one will prevail; <file> if the file exists its added to the InputFiles() list; <file>.root are considered ROOT files and added to the InputFiles() list,; the file may be a remote file url; <macro>.C are considered ROOT macros and also added to the InputFiles() list; In TRint we set the working directory to the <dir>, the ROOT files are; connected, and the macros are executed. If your main TApplication is not; TRint you have to decide yourself what to do whith these options.; All specified arguments (also the ones removed) can always be retrieved; via the TApplication::Argv() method. void HandleIdleTimer(); Handle idle timeout. When this timer expires the registered idle command; will be ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TApplication.html:14559,monitor,monitoring,14559,root/html528/TApplication.html,https://root.cern,https://root.cern/root/html528/TApplication.html,4,['monitor'],['monitoring']
Energy Efficiency,"t (default=fNpoints-1); 1853///; 1854/// based on CERNLIB routine LSQ: Translated to C++ by Rene Brun; 1855 ; 1856void TGraph::LeastSquareFit(Int_t m, Double_t *a, Double_t xmin, Double_t xmax); 1857{; 1858 const Double_t zero = 0.;; 1859 const Double_t one = 1.;; 1860 const Int_t idim = 20;; 1861 ; 1862 Double_t b[400] /* was [20][20] */;; 1863 Int_t i, k, l, ifail;; 1864 Double_t power;; 1865 Double_t da[20], xk, yk;; 1866 Int_t n = fNpoints;; 1867 if (xmax <= xmin) {; 1868 xmin = fX[0];; 1869 xmax = fX[fNpoints-1];; 1870 }; 1871 ; 1872 if (m <= 2) {; 1873 LeastSquareLinearFit(n, a[0], a[1], ifail, xmin, xmax);; 1874 return;; 1875 }; 1876 if (m > idim || m > n) return;; 1877 da[0] = zero;; 1878 for (l = 2; l <= m; ++l) {; 1879 b[l-1] = zero;; 1880 b[m + l*20 - 21] = zero;; 1881 da[l-1] = zero;; 1882 }; 1883 Int_t np = 0;; 1884 for (k = 0; k < fNpoints; ++k) {; 1885 xk = fX[k];; 1886 if (xk < xmin || xk > xmax) continue;; 1887 np++;; 1888 yk = fY[k];; 1889 power = one;; 1890 da[0] += yk;; 1891 for (l = 2; l <= m; ++l) {; 1892 power *= xk;; 1893 b[l-1] += power;; 1894 da[l-1] += power * yk;; 1895 }; 1896 for (l = 2; l <= m; ++l) {; 1897 power *= xk;; 1898 b[m + l*20 - 21] += power;; 1899 }; 1900 }; 1901 b[0] = Double_t(np);; 1902 for (i = 3; i <= m; ++i) {; 1903 for (k = i; k <= m; ++k) {; 1904 b[k - 1 + (i-1)*20 - 21] = b[k + (i-2)*20 - 21];; 1905 }; 1906 }; 1907 H1LeastSquareSeqnd(m, b, idim, ifail, 1, da);; 1908 ; 1909 if (ifail < 0) {; 1910 a[0] = fY[0];; 1911 for (i = 1; i < m; ++i) a[i] = 0;; 1912 return;; 1913 }; 1914 for (i = 0; i < m; ++i) a[i] = da[i];; 1915}; 1916 ; 1917////////////////////////////////////////////////////////////////////////////////; 1918/// Least square linear fit without weights.; 1919///; 1920/// Fit a straight line (a0 + a1*x) to the data in this graph.; 1921///; 1922/// \param [in] ndata if ndata<0, fits the logarithm of the graph (used in InitExpo() to set; 1923/// the initial parameter values for a fit with exponential function.; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:67557,power,power,67557,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,7,['power'],['power']
Energy Efficiency,"t ;  CCpuInfo_t;  CDebuggingSamplerDebuggingSampler is a simple implementation of the DistributionCreator interface used for debugging ;  CDebuggingTestStatDebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging ;  CDiscrDistFree functions adapter needed by UNURAN for one-dimensional discrete distribution ;  CEvent_t;  CExceptionContext_t;  CFeldmanCousinsBinomialInterval;  CFeldmanCousinsSorter;  CFileStat_t;  CFontAttributes_t;  CFontMetrics_t;  CFoption_t;  Cfuncptr_and_voidptr_t;  CGcCache_t;  CGCValues_t;  Cgroup;  Ch1analysis;  Ch1analysisTreeReader;  Chash< std::experimental::basic_string_view< _CharT, _Traits > >;  CHelperOps;  CHEPEVT_DEFHEPEVT common block ;  CHit;  CHoption_tHistogram option structure ;  CHparam_tHistogram parameters structure ;  CJet;  CJetEvent;  CMemInfo_t;  Cmg_callbacks;  Cmg_client_options;  Cmg_form_data_handler;  Cmg_option;  ►Cmg_request_info;  Cmg_header;  Cmg_server_ports;  CMultiDistFree functions adapter needed by UNURAN for multidimensional cont distribution ;  CMYSQL_BIND;  CMYSQL_STMT;  CNuMuToNuE_Oscillation;  ►CParamHistFunc;  CCacheElem;  CPassiveKeyGrab;  Cpasswd;  CPattern;  CPgSQL_Stmt_t;  CPictureAttributes_t;  ►CPiecewiseInterpolation;  CCacheElem;  CPoint_t;  CProcInfo_t;  CProofServEnv_t;  Cpthread_cond_t;  CPybins_tPythia6 common block Pybins ;  CPydat1_tPythia6 common block Pydat1 ;  CPydat2_tPythia6 common block Pydat2 ;  CPydat3_tPythia6 common block Pydat3 ;  CPydat4_tPythia6 common block Pydat4 ;  CPydatr_tPythia6 common block Pydatr ;  CPyint1_tPythia6 common block Pyint1 ;  CPyint2_tPythia6 common block Pyint2 ;  CPyint3_tPythia6 common block Pyint3 ;  CPyint4_tPythia6 common block Pyint4 ;  CPyint5_tPythia6 common block Pyint5 ;  CPyint6_tPythia6 common block Pyint6 ;  CPyint7_tPythia6 common block Pyint7 ;  CPyint8_tPythia6 common block Pyint8 ;  CPyint9_tPythia6 common block Pyint9 ;  CPyints_tPythia6 common block Pyints ;  CPyjets_tPythia6 common block Pyje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:89348,adapt,adapter,89348,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,1,['adapt'],['adapter']
Energy Efficiency,"t = 0) const; boolRunOnePoint(double thisX, bool adaptive = false, double clTarget = -1) const; voidSetAutoScan(); static voidSetCloseProof(Bool_t flag); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData&); voidSetFixedScan(int nBins, double xMin = 1, double xMax = -1, bool scanLog = false); voidSetMaximumToys(int ntoys); virtual voidSetModel(const RooStats::ModelConfig&); voidSetNumErr(double err); virtual voidSetTestSize(Double_t size); boolSetTestStatistic(RooStats::TestStatistic& stat); voidSetVerbose(int level = 1); virtual voidShowMembers(TMemberInspector&); virtual Double_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidUseCLs(bool on = true). protected:. static voidCheckInputModels(const RooStats::HypoTestCalculatorGeneric& hc, const RooRealVar& scanVar); voidCreateResults() const; RooStats::HypoTestResult*Eval(RooStats::HypoTestCalculatorGeneric& hc, bool adaptive, double clsTarget) const; static RooRealVar*GetVariableToScan(const RooStats::HypoTestCalculatorGeneric& hc); RooStats::HypoTestInverterHypoTestInverter(const RooStats::HypoTestInverter& rhs); RooStats::HypoTestInverter&operator=(const RooStats::HypoTestInverter& rhs). Data Members; public:. enum ECalculatorType { kUndefined; kHybrid; kFrequentist; kAsymptotic; };. private:. RooStats::HypoTestInverter::ECalculatorTypefCalcType; RooStats::HypoTestCalculatorGeneric*fCalculator0pointer to the calculator passed in the constructor; auto_ptr<RooStats::HypoTestCalculatorGeneric>fHC; auto_ptr<TGraphErrors>fLimitPlot! plot of limits; intfMaxToysmaximum number of toys to run ; intfNBins; doublefNumErr; RooStats::HypoTestInverterResult*fResultspointer to the result ; boolfScanLog; RooRealVar*fScannedVariablepointer to the constrained variable; doublefSize; intfTotalToysRun; boolfUseCLs; intfVerbose; doublefXmax; doublefXmin; static doublefgAbsAccuracy; static stringfgAlgo; static doublefgCLAccuracy; static boolfgCloseProof",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HypoTestInverter.html:4229,adapt,adaptive,4229,root/html534/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html534/RooStats__HypoTestInverter.html,1,['adapt'],['adaptive']
Energy Efficiency,t = fTensor_18weight.data();; std::vector<float> fTensor_0weight = std::vector<float>(5000);; float * tensor_0weight = fTensor_0weight.data();; std::vector<float> fTensor_10bias = std::vector<float>(50);; float * tensor_10bias = fTensor_10bias.data();; std::vector<float> fTensor_2bias = std::vector<float>(50);; float * tensor_2bias = fTensor_2bias.data();; std::vector<float> fTensor_6weight = std::vector<float>(2500);; float * tensor_6weight = fTensor_6weight.data();; std::vector<float> fTensor_14weight = std::vector<float>(2500);; float * tensor_14weight = fTensor_14weight.data();; std::vector<float> fTensor_16weight = std::vector<float>(2500);; float * tensor_16weight = fTensor_16weight.data();; std::vector<float> fTensor_12weight = std::vector<float>(2500);; float * tensor_12weight = fTensor_12weight.data();; std::vector<float> fTensor_16bias = std::vector<float>(50);; float * tensor_16bias = fTensor_16bias.data();; ; //--- declare and allocate the intermediate tensors; std::vector<float> fTensor_39 = std::vector<float>(160);; float * tensor_39 = fTensor_39.data();; std::vector<float> fTensor_18biasbcast = std::vector<float>(160);; float * tensor_18biasbcast = fTensor_18biasbcast.data();; std::vector<float> fTensor_38 = std::vector<float>(800);; float * tensor_38 = fTensor_38.data();; std::vector<float> fTensor_35 = std::vector<float>(800);; float * tensor_35 = fTensor_35.data();; std::vector<float> fTensor_14biasbcast = std::vector<float>(800);; float * tensor_14biasbcast = fTensor_14biasbcast.data();; std::vector<float> fTensor_34 = std::vector<float>(800);; float * tensor_34 = fTensor_34.data();; std::vector<float> fTensor_33 = std::vector<float>(800);; float * tensor_33 = fTensor_33.data();; std::vector<float> fTensor_36 = std::vector<float>(800);; float * tensor_36 = fTensor_36.data();; std::vector<float> fTensor_12biasbcast = std::vector<float>(800);; float * tensor_12biasbcast = fTensor_12biasbcast.data();; std::vector<float> fTensor_10biasbcast = std::vect,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__ONNX_8C.html:16937,allocate,allocate,16937,doc/master/TMVA__SOFIE__ONNX_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__ONNX_8C.html,1,['allocate'],['allocate']
Energy Efficiency,"t DataSet than the own one. protected:. TMVA::TActivation*fActivationactivation function to be used for hidden layers; TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TH1*>fEpochMonHistBepoch monitoring hitograms for background; vector<TH1*>fEpochMonHistSepoch monitoring hitograms for signal; vector<TH1*>fEpochMonHistWepoch monitoring hitograms for weights; TMVA::MethodANNBase::EEstimatorfEstimator; TH1F*fEstimatorHistTestmonitors convergence of independent test sample; TH1F*fEstimatorHistTrainmonitors convergence of training sample; TStringfEstimatorS; TMVA::TActivation*fIdentityactivation for input and output layers; TMVA::TNeuronInput*fInputCalculatorinput calculator for all neurons; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; TMatrixDfInvHessianzjh; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in representative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TObjArray*fNetworkTObjArray of TObjArrays representing network; TMVA::TActivation*fOutputactivation function to be used for output layers, depending on estimator; Int_tfRandomSeedrandom seed for initial synapse weights; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; vector<Int_t>fRegulatorIdxindex to different priors from every synapses; vector<Double_t>fRegulatorsthe priors as regulator; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class; TObjArray*fSynapsesarray of pointers to synapses, no structural data; boolfUseRegulatorzjh; TRandom3*frgenrandom number generator for various uses. private:. TObjArray*fInputLayercache t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodANNBase.html:15984,monitor,monitoring,15984,root/html528/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodANNBase.html,3,['monitor'],['monitoring']
Energy Efficiency,"t GetN() const; GetN() returns the number of allocated cells if any.; GetN() > 0 shows how many cells; can be available via GetP() method.; GetN() == 0 then GetP() must return 0 as well. Float_t * GetP() const; GetP() returns the pointer to the float point array; of points if available; The number of the available celss can be found via; GetN() method.; GetN() > 0 shows how many cells. Float_t * GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1) const; GetXYZ(Float_t *xyz,Int_t idx,Int_t num=1) fills the buffer supplied; by the calling code with the points information. Input parameters:. Float_t *xyz - an external user supplied floating point array.; Int_t num - the total number of the points to be copied; the dimension of that array the size of the; array is num*sizeof(Float_t) at least; Int_t idx - The index of the first copy to be taken. Return: The pointer to the buffer array supplied. TPoints3DABC(); {;}. virtual ~TPoints3DABC(); {;}. Int_t DistancetoPrimitive(Int_t px, Int_t py). Int_t GetLastPosition() const; GetN() returns the number of allocated cells if any.; GetN() > 0 shows how many cells; can be available via GetP() method.; GetN() == 0 then GetP() must return 0 as well. Float_t GetX(Int_t idx) const. Float_t GetY(Int_t idx) const. Float_t GetZ(Int_t idx) const. Float_t * GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1) const. Option_t * GetOption() const. void PaintPoints(Int_t n, Float_t* p, Option_t* option = """"). Int_t SetLastPosition(Int_t idx). void SetOption(Option_t* option = """"). Int_t SetPoint(Int_t point, Float_t x, Float_t y, Float_t z). Int_t SetPoints(Int_t n, Float_t* p = 0, Option_t* option = """"). Int_t Size() const. » Author: Valery Fine(fine@mail.cern.ch) 24/04/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-06-02 16:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TPoints3DABC.html:9022,allocate,allocated,9022,root/html604/TPoints3DABC.html,https://root.cern,https://root.cern/root/html604/TPoints3DABC.html,1,['allocate'],['allocated']
Energy Efficiency,"t GetN() const; GetN() returns the number of allocated cells if any.; GetN() > 0 shows how many cells; can be available via GetP() method.; GetN() == 0 then GetP() must return 0 as well. Float_t * GetP() const; GetP() returns the pointer to the float point array; of points if available; The number of the available celss can be found via; GetN() method.; GetN() > 0 shows how many cells. Float_t * GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1) const; GetXYZ(Float_t *xyz,Int_t idx,Int_t num=1) fills the buffer supplied; by the calling code with the points information. Input parameters:. Float_t *xyz - an external user supplied floating point array.; Int_t num - the total number of the points to be copied; the dimension of that array the size of the; array is num*sizeof(Float_t) at least; Int_t idx - The index of the first copy to be taken. Return: The pointer to the buffer array supplied. TPoints3DABC(); {;}. virtual ~TPoints3DABC(); {;}. Int_t DistancetoPrimitive(Int_t px, Int_t py). Int_t GetLastPosition() const; GetN() returns the number of allocated cells if any.; GetN() > 0 shows how many cells; can be available via GetP() method.; GetN() == 0 then GetP() must return 0 as well. Float_t GetX(Int_t idx) const. Float_t GetY(Int_t idx) const. Float_t GetZ(Int_t idx) const. Float_t * GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1) const. Option_t * GetOption() const. void PaintPoints(Int_t n, Float_t* p, Option_t* option = """"). Int_t SetLastPosition(Int_t idx). void SetOption(Option_t* option = """"). Int_t SetPoint(Int_t point, Float_t x, Float_t y, Float_t z). Int_t SetPoints(Int_t n, Float_t* p = 0, Option_t* option = """"). Int_t Size() const. » Author: Valery Fine(fine@mail.cern.ch) 24/04/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-06-30 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPoints3DABC.html:9022,allocate,allocated,9022,root/html602/TPoints3DABC.html,https://root.cern,https://root.cern/root/html602/TPoints3DABC.html,1,['allocate'],['allocated']
Energy Efficiency,"t TGCocoa & ; rhs). private . Member Function Documentation. ◆ AddPixmap(). Int_t TGCocoa::AddPixmap ; (; ULong_t ; pixid, . UInt_t ; w, . UInt_t ; h . ). overridevirtual . Registers a pixmap created by TGLManager as a ROOT pixmap. ; Parameters. [in]pixidpixmap identifier ; [in]w,hthe width and height, which define the pixmap size . Reimplemented from TVirtualX.; Definition at line 2549 of file TGCocoa.mm. ◆ AddWindow(). Int_t TGCocoa::AddWindow ; (; ULong_t ; qwid, . UInt_t ; w, . UInt_t ; h . ). overridevirtual . Registers a window created by Qt as a ROOT window. ; Parameters. [in]qwidwindow identifier ; [in]w,hthe width and height, which define the window size . Reimplemented from TVirtualX.; Definition at line 846 of file TGCocoa.mm. ◆ AllocColor(). Bool_t TGCocoa::AllocColor ; (; Colormap_t ; cmap, . ColorStruct_t & ; color . ). overridevirtual . Allocates a read-only colormap entry corresponding to the closest RGB value supported by the hardware. ; If no cell could be allocated it returns kFALSE, otherwise kTRUE.; The pixel value is set to default. Let system think we could allocate color.; Parameters. [in]cmapthe colormap ; [in]colorspecifies and returns the values actually used in the cmap . Reimplemented from TVirtualX.; Definition at line 2917 of file TGCocoa.mm. ◆ Bell(). void TGCocoa::Bell ; (; Int_t ; percent). overridevirtual . Sets the sound bell. Percent is loudness from -100% to 100%. ; Reimplemented from TVirtualX.; Definition at line 4264 of file TGCocoa.mm. ◆ ChangeActivePointerGrab(). void TGCocoa::ChangeActivePointerGrab ; (; Window_t ; , . UInt_t ; , . Cursor_t ;  . ). overridevirtual . Changes the specified dynamic parameters if the pointer is actively grabbed by the client and if the specified time is no earlier than the last-pointer-grab time and no later than the current X server time. ; Reimplemented from TVirtualX.; Definition at line 2699 of file TGCocoa.mm. ◆ ChangeGC(). void TGCocoa::ChangeGC ; (; GContext_t ; gc, . GCValues_t * ; gva",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:53526,allocate,allocated,53526,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['allocate'],['allocated']
Energy Efficiency,"t TMVA::KDEKernel::fFineFactor. private . fine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function ; Definition at line 79 of file KDEKernel.h. ◆ fFirstIterHist. TH1F* TMVA::KDEKernel::fFirstIterHist. private . histogram to be filled in the hidden iteration ; Definition at line 83 of file KDEKernel.h. ◆ fHiddenIteration. Bool_t TMVA::KDEKernel::fHiddenIteration. private . Defines if whats currently running is the. ; Definition at line 85 of file KDEKernel.h. ◆ fHist. TH1F* TMVA::KDEKernel::fHist. private . copy of input histogram ; Definition at line 82 of file KDEKernel.h. ◆ fIter. EKernelIter TMVA::KDEKernel::fIter. private . iteration number ; Definition at line 76 of file KDEKernel.h. ◆ fKDEborder. EKernelBorder TMVA::KDEKernel::fKDEborder. private . The method to take care about ""border"" effects. ; Definition at line 81 of file KDEKernel.h. ◆ fKernel_integ. TF1* TMVA::KDEKernel::fKernel_integ. private . the integral of the Kernel function ; Definition at line 80 of file KDEKernel.h. ◆ fLogger. MsgLogger* TMVA::KDEKernel::fLogger. mutableprivate . ! message logger ; Definition at line 88 of file KDEKernel.h. ◆ fLowerEdge. Float_t TMVA::KDEKernel::fLowerEdge. private . the lower edge of the PDF ; Definition at line 77 of file KDEKernel.h. ◆ fSigma. Float_t TMVA::KDEKernel::fSigma. private . Width of the Kernel function. ; Definition at line 75 of file KDEKernel.h. ◆ fSigmaHist. TH1F* TMVA::KDEKernel::fSigmaHist. private . contains the Sigmas Widths for adaptive KDE ; Definition at line 84 of file KDEKernel.h. ◆ fUpperEdge. Float_t TMVA::KDEKernel::fUpperEdge. private . the upper edge of the PDF ; Definition at line 78 of file KDEKernel.h. Libraries for TMVA::KDEKernel:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/KDEKernel.h; tmva/tmva/src/KDEKernel.cxx. TMVAKDEKernel. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1KDEKernel.html:6574,adapt,adaptive,6574,doc/master/classTMVA_1_1KDEKernel.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1KDEKernel.html,1,['adapt'],['adaptive']
Energy Efficiency,"t TThread::CleanUpPop ; (; Int_t ; exe = 0). static . Static method which pops thread cleanup method off stack. ; Returns 0 in case of success and -1 in case of error. ; Definition at line 697 of file TThread.cxx. ◆ CleanUpPush(). Int_t TThread::CleanUpPush ; (; void * ; free, . void * ; arg = nullptr . ). static . Static method which pushes thread cleanup method on stack. ; Returns 0 in case of success and -1 in case of error. ; Definition at line 685 of file TThread.cxx. ◆ Constructor(). void TThread::Constructor ; (; ). private . Common thread constructor. ; Definition at line 364 of file TThread.cxx. ◆ DeclFileName(). static const char * TThread::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 180 of file TThread.h. ◆ Delete() [1/2]. void TThread::Delete ; (; Option_t * ; option = """"). inlineoverridevirtual . Delete this object. ; Typically called as a command via the interpreter. Normally use ""delete"" operator when object has been allocated on the heap. ; Reimplemented from TObject.; Definition at line 127 of file TThread.h. ◆ Delete() [2/2]. Int_t TThread::Delete ; (; TThread *& ; th). static . Static method to delete the specified thread. ; Returns -1 in case the thread was running and has been killed. Returns 0 in case the thread has been Delete and Cleaned up. The th pointer is not valid anymore in that case. ; Definition at line 416 of file TThread.cxx. ◆ DoError(). void TThread::DoError ; (; Int_t ; level, . const char * ; location, . const char * ; fmt, . va_list ; va . ); const. overrideprivatevirtual . Interface to ErrorHandler. ; User has to specify the class name as part of the location, just like for the global Info(), Warning() and Error() functions. ; Reimplemented from TObject.; Definition at line 1000 of file TThread.cxx. ◆ ErrorHandler(). void TThread::ErrorHandler ; (; int ; level, . const char * ; location, . const char * ; fmt, . va_list ; ap . ); const. private . Thread specif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTThread.html:22145,allocate,allocated,22145,doc/master/classTThread.html,https://root.cern,https://root.cern/doc/master/classTThread.html,1,['allocate'],['allocated']
Energy Efficiency,"t absoulte tolerance; The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied \[; absErr <= max ( epsAbs, epsRel * Integral); \] Where absErr is an estimate of the absolute error (it can be retrieved with GSLIntegrator::Error()) and Integral is the estimate of the function integral (it can be obtained with GSLIntegrator::Result()); The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the GSL users documentation. * ROOT::Math::Integration::kNONADAPTIVE : based on gsl_integration_qng. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions. * ROOT::Math::Integration::kADAPTIVE: based on gsl_integration_qag. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are * Integration::kGAUSS15 : 15 points Gauss-Konrod rule (value = 1) * Integration::kGAUSS21 : 21 points Gauss-Konrod rule (value = 2) * Integration::kGAUSS31 : 31 points Gauss-Konrod rule (value = 3) * Integration::kGAUSS41 : 41 points Gauss-Konrod rule (value = 4) * Integration::kGAUSS51 : 51 points Gauss-Konrod rule (value = 5) * Integration::kGAUSS61 : 61 points Gauss-Konrod rule (value = 6) The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule is passed, the 31 points rule is used as default. ROOT::Math::Integration::kADAPTIVESINGULAR: based on gsl_integration_qags. It is an integration type which can be used in the case of the presence of singula",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:707688,adapt,adaptiva,707688,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['adapt'],['adaptiva']
Energy Efficiency,"t array of 3D points; TPoints3DABC A 3-D Points; TPointsArray3D A 3-D PolyLine; TPolyLine A PolyLine; TPolyLine3D A 3-D polyline; TPolyLineShape The base class to define an abstract 3D shape of STAR ""event"" geometry; TPolyMarker An array of points with the same marker; TPolyMarker3D An array of 3-D points with the same marker; TPosixCondition Posix condition variable; TPosixMutex Posix mutex lock; TPosixThread TPosixThread class; TPosixThreadFactory Posix thread factory; TPostScript PostScript driver; TPrimary TPrimary vertex particle information; TPrincipal Principal Components Analysis; TProcessEventTimer Process pending events at fixed time intervals; TProcessID Process Unique Identifier in time and space; TProcessUUID TProcessID managing UUIDs; TProfile Profile histogram class; TProfile2D Profile2D histogram class; TProfile3D Profile3D histogram class; TProof PROOF control class; TProofChain TChain proxy for running chains on PROOF; TProofCondor PROOF control class for slaves allocated by condor; TProofDebug ; TProofDesc Small class describing a proof session; TProofDraw Tree drawing selector for PROOF; TProofDrawEntryList A Selectoor to fill a TEntryList from TTree::Draw; TProofDrawEventList Tree drawing selector for PROOF; TProofDrawGraph Tree drawing selector for PROOF; TProofDrawHist Tree drawing selector for PROOF; TProofDrawListOfGraphs Tree drawing selector for PROOF; TProofDrawListOfGraphs::Point3D_t ; TProofDrawListOfPolyMarkers3D Tree drawing selector for PROOF; TProofDrawListOfPolyMarkers3D::Point4D_t ; TProofDrawPolyMarker3D Tree drawing selector for PROOF; TProofDrawProfile Tree drawing selector for PROOF; TProofDrawProfile2D Tree drawing selector for PROOF; TProofLimitsFinder Find and communicate best axis limits; TProofLite PROOF control class; TProofLog PROOF session log handler; TProofLogElem PROOF session log element; TProofMgr Abstract PROOF manager interface; TProofMgrLite XrdProofd PROOF manager interface; TProofNodeInfo Class describing a P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:108242,allocate,allocated,108242,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,2,['allocate'],['allocated']
Energy Efficiency,"t array of 3D points; TPoints3DABC A 3-D Points; TPointsArray3D A 3-D PolyLine; TPolyLine A PolyLine; TPolyLine3D A 3-D polyline; TPolyLineShape The base class to define an abstract 3D shape of STAR ""event"" geometry; TPolyMarker An array of points with the same marker; TPolyMarker3D An array of 3-D points with the same marker; TPosixCondition Posix condition variable; TPosixMutex Posix mutex lock; TPosixThread TPosixThread class; TPosixThreadFactory Posix thread factory; TPostScript PostScript driver; TPrimary TPrimary vertex particle information; TPrincipal Principal Components Analysis; TProcessEventTimer Process pending events at fixed time intervals; TProcessID Process Unique Identifier in time and space; TProcessUUID TProcessID managing UUIDs; TProfile Profile histogram class; TProfile2D Profile2D histogram class; TProfile3D Profile3D histogram class; TProof PROOF control class; TProofChain TChain proxy for running chains on PROOF; TProofCondor PROOF control class for slaves allocated by condor; TProofDebug ; TProofDesc Small class describing a proof session; TProofDraw Tree drawing selector for PROOF; TProofDrawEntryList A Selectoor to fill a TEntryList from TTree::Draw; TProofDrawEventList Tree drawing selector for PROOF; TProofDrawGraph Tree drawing selector for PROOF; TProofDrawHist Tree drawing selector for PROOF; TProofDrawListOfGraphs Tree drawing selector for PROOF; TProofDrawListOfGraphs::Point3D_t ; TProofDrawListOfPolyMarkers3D Tree drawing selector for PROOF; TProofDrawListOfPolyMarkers3D::Point4D_t ; TProofDrawPolyMarker3D Tree drawing selector for PROOF; TProofDrawProfile Tree drawing selector for PROOF; TProofDrawProfile2D Tree drawing selector for PROOF; TProofLimitsFinder Find and communicate best axis limits; TProofLite PROOF-Lite control class; TProofLog PROOF session log handler; TProofLogElem PROOF session log element; TProofMgr Abstract PROOF manager interface; TProofMgrLite XrdProofd PROOF manager interface; TProofNodeInfo Class describin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:112955,allocate,allocated,112955,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,1,['allocate'],['allocated']
Energy Efficiency,"t at index 'idx' that is guaranteed to have been constructed. ; It might be either a freshly allocated object or one that had already been allocated (and assumingly used). In the later case, the function Clear will be called and passed the value of 'clear_options'; Tests to see if the destructor has been called on the object. If so, or if the object has never been constructed the class constructor is called using New(). If not, return a pointer to the correct memory location. This explicitly to deal with TObject classes that allocate memory which will be reset (but not deallocated) in their Clear() functions. ; Definition at line 399 of file TClonesArray.cxx. ◆ DeclFileName(). static const char * TClonesArray::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 83 of file TClonesArray.h. ◆ Delete(). void TClonesArray::Delete ; (; Option_t * ; option = """"). overridevirtual . Clear the clones array. ; Use this routine when your objects allocate memory (e.g. objects inheriting from TNamed or containing TStrings allocate memory). If not you better use Clear() since if is faster. ; Implements TCollection.; Definition at line 452 of file TClonesArray.cxx. ◆ Expand(). void TClonesArray::Expand ; (; Int_t ; newSize). overridevirtual . Expand or shrink the array to newSize elements. ; Reimplemented from TObjArray.; Definition at line 480 of file TClonesArray.cxx. ◆ ExpandCreate(). void TClonesArray::ExpandCreate ; (; Int_t ; n). virtual . Expand or shrink the array to n elements and create the clone objects by calling their default ctor. ; If n is less than the current size the array is shrunk and the allocated space is freed. This routine is typically used to create a clonesarray into which one can directly copy object data without going via the ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). ; Definition at line 514 of file TClonesArray.cxx. ◆ ExpandCreateFast(). void TClonesArray::ExpandCreateFa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:35934,allocate,allocate,35934,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['allocate'],['allocate']
Energy Efficiency,"t bin coordinates are larger than 4 bytes) possible. In this case, fBinsContinued contains a chain of linear indexes with the same hash. Iterating through this chain and comparing each bin coordinates with the one passed to GetBin() will retrieve the matching bin. ; Definition at line 37 of file THnSparse.h. Public Member Functions;  ~THnSparse () override;  Destruct a THnSparse. ;  ; void AddBinContent (const Int_t *idx, Double_t v=1.);  Forwards to THnBase::AddBinContent(). ;  ; void AddBinContent (Long64_t bin, Double_t v=1.) override;  Add ""v"" to the content of bin with index ""bin"". ;  ; void AddBinError2 (Long64_t bin, Double_t e2) override;  Add ""e"" to error of bin with index ""bin"", enable errors if needed. ;  ; ROOT::Internal::THnBaseBinIter * CreateIter (Bool_t respectAxisRange) const override;  Create an iterator over all filled bins of a THnSparse. ;  ; Long64_t GetBin (const char *name[]) const override;  ; Long64_t GetBin (const char *name[], Bool_t allocate=kTRUE) override;  Get the bin index for the n dimensional tuple addressed by ""name"", allocate one if it doesn't exist yet and ""allocate"" is true. ;  ; Long64_t GetBin (const Double_t *x) const override;  ; Long64_t GetBin (const Double_t *x, Bool_t allocate=kTRUE) override;  Get the bin index for the n dimensional tuple x, allocate one if it doesn't exist yet and ""allocate"" is true. ;  ; Long64_t GetBin (const Int_t *idx) const override;  ; Long64_t GetBin (const Int_t *idx, Bool_t allocate=kTRUE) override;  Get the bin index for the n dimensional coordinates coord, allocate one if it doesn't exist yet and ""allocate"" is true. ;  ; Double_t GetBinContent (const Int_t *idx) const;  Forwards to THnBase::GetBinContent() overload. ;  ; Double_t GetBinContent (Long64_t bin, Int_t *idx=nullptr) const override;  Return the content of the filled bin number ""idx"". ;  ; Double_t GetBinError2 (Long64_t linidx) const override;  Get square of the error of bin addressed by linidx as \(\sum weight^{2}\) If errors ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnSparse.html:5523,allocate,allocate,5523,doc/master/classTHnSparse.html,https://root.cern,https://root.cern/doc/master/classTHnSparse.html,3,['allocate'],['allocate']
Energy Efficiency,"t char* fmt, va_list va) const; virtual const TMatrixDBase&GetDecompMatrix() const; Int_tTDecompBase::Hager(Double_t& est, Int_t iter = 5); voidTObject::MakeZombie(); voidTDecompBase::ResetStatus(); static voidSortSingular(TMatrixD& v, TMatrixD& u, TVectorD& sDiag). Data Members; public:. enum { kWorkMax; };; enum TDecompBase::EMatrixDecompStat { kInit; kPatternSet; kValuesSet; kMatrixSet; kDecomposed; kDetermined; kCondition; kSingular; };; enum TDecompBase::[unnamed] { kWorkMax; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTDecompBase::fColLwbColumn lower bound of decomposed matrix; Double_tTDecompBase::fConditionmatrix condition number; Double_tTDecompBase::fDet1determinant mantissa; Double_tTDecompBase::fDet2determinant exponent for powers of 2; Int_tTDecompBase::fRowLwbRow lower bound of decomposed matrix; TVectorDfSigdiagonal of diagonal matrix; Double_tTDecompBase::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1; TMatrixDfUorthogonal matrix; TMatrixDfVorthogonal matrix. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecompSVD(Int_t nrows, Int_t ncols); Constructor for (nrows x ncols) matrix. TDecompSVD(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb); Constructor for ([row_lwb..row_upb] x [col_lwb..col_upb]) matrix. TDecompSVD(const TMatrixD& m, Double_t tol = 0.0); Constructor for general matrix A . TDecompSVD(const TDecompSVD& another); Copy constructor. Bool_t Decompose(); SVD decomposition of matrix; If the decomposition succeeds, bit kDecomposed is set , otherwise kSingular. Bool_t Bidiagonalize(TMatrixD& v, TMatrixD& u, TVectorD& sDiag, TVectorD& oDiag); Bidiagonalize the (m x n) - matrix a (stored in v) through a series of Householder; transformat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDecompSVD.html:8172,power,powers,8172,root/html528/TDecompSVD.html,https://root.cern,https://root.cern/root/html528/TDecompSVD.html,4,['power'],['powers']
Energy Efficiency,"t char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. UShort_t*fColorAlpha[fNumPoints] alpha at each anchor point; UShort_t*fColorBlue[fNumPoints] blue color at each anchor point; UShort_t*fColorGreen[fNumPoints] green color at each anchor point; UShort_t*fColorRed[fNumPoints] red color at each anchor point; UInt_tfNumPointsnumber of anchor points; Double_t*fPoints[fNumPoints] value of each anchor point [0..1]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TImagePalette(); Default constructor, sets all pointers to 0. TImagePalette(UInt_t numPoints); Constructor for a palette with numPoints anchor points.; It allocates the memory but does not set any colors. TImagePalette(const TImagePalette& palette); Copy constructor. TImagePalette(Int_t ncolors, Int_t* colors); Creates palette in the same way as TStyle::SetPalette. ~TImagePalette(); Destructor. TImagePalette & operator=(const TImagePalette& palette); Assignment operator. Int_t FindColor(UShort_t r, UShort_t g, UShort_t b); returns an index of the closest color. Int_t * GetRootColors(); Returns a list of ROOT colors. Could be used to set histogram palette.; See also http://root.cern.ch/root/htmldoc/TStyle.html#TStyle:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TImagePalette.html:7733,green,green,7733,root/html528/TImagePalette.html,https://root.cern,https://root.cern/root/html528/TImagePalette.html,4,['green'],['green']
Energy Efficiency,"t filled. If a filled style is selected,; 1912/// also use VLines() to add vertical downward lines at end of curve to ensure proper closure; 1913/// <tr><td> `FillColor(Int_t color)` <td> Select fill color by ROOT color code; 1914/// <tr><td> `Range(const char* name)` <td> Only draw curve in range defined by given name. Multiple comma-separated ranges can be given.; 1915/// An empty string """" or `nullptr` means to use the default range of the variable.; 1916/// <tr><td> `Range(double lo, double hi)` <td> Only draw curve in specified range; 1917/// <tr><td> `VLines()` <td> Add vertical lines to y=0 at end points of curve; 1918/// <tr><td> `Precision(double eps)` <td> Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. A higher precision will; 1919/// result in more and more densely spaced curve points. A negative precision value will disable; 1920/// adaptive point spacing and restrict sampling to the grid point of points defined by the binning; 1921/// of the plotted observable (recommended for expensive functions such as profile likelihoods); 1922/// <tr><td> `Invisible(bool flag)` <td> Add curve to frame, but do not display. Useful in combination AddTo(); 1923/// <tr><td> `VisualizeError(const RooFitResult& fitres, double Z=1, bool linearMethod=true)`; 1924/// <td> Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma.; 1925/// The linear method is fast but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made.; 1926/// Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much) longer to calculate; 1927/// \note To include the uncertainty from the expected number of events,; 1928/// the Normalization() argument with `ScaleType` `RooAbsReal::RelativeExpected` has to be passed, e.g.; 1929/// ```{.cpp}; 1930/// pdf.plotOn(frame, VisualizeError(fitResult), Normalization(1.0, R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:94489,adapt,adaptive,94489,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['adapt'],['adaptive']
Energy Efficiency,"t gPad, requires last mouse position"");; 773 return;; 774 }; 775 ; 776 Int_t px = gPad->GetEventX();; 777 Int_t py = gPad->GetEventY();; 778 ; 779 //localize point to be deleted; 780 Int_t ipoint = -2;; 781 Int_t i;; 782 // start with a small window (in case the mouse is very close to one point); 783 for (i = 0; i < fNpoints; i++) {; 784 Int_t dpx = px - gPad->XtoAbsPixel(gPad->XtoPad(fX[i]));; 785 Int_t dpy = py - gPad->YtoAbsPixel(gPad->YtoPad(fY[i]));; 786 if (dpx * dpx + dpy * dpy < 25) {; 787 ipoint = i;; 788 break;; 789 }; 790 }; 791 if (ipoint == -2) return;; 792 ; 793 fEX[ipoint] = ex;; 794 fEY[ipoint] = ey;; 795 gPad->Modified();; 796}; 797 ; 798 ; 799////////////////////////////////////////////////////////////////////////////////; 800/// Set `ex` and `ey` values for point number i.; 801 ; 802void TGraphErrors::SetPointError(Int_t i, Double_t ex, Double_t ey); 803{; 804 if (i < 0) return;; 805 if (i >= fNpoints) {; 806 // re-allocate the object; 807 TGraphErrors::SetPoint(i, 0, 0);; 808 }; 809 fEX[i] = ex;; 810 fEY[i] = ey;; 811}; 812 ; 813 ; 814////////////////////////////////////////////////////////////////////////////////; 815/// Stream an object of class TGraphErrors.; 816 ; 817void TGraphErrors::Streamer(TBuffer &b); 818{; 819 if (b.IsReading()) {; 820 UInt_t R__s, R__c;; 821 Version_t R__v = b.ReadVersion(&R__s, &R__c);; 822 if (R__v > 2) {; 823 b.ReadClassBuffer(TGraphErrors::Class(), this, R__v, R__s, R__c);; 824 return;; 825 }; 826 //====process old versions before automatic schema evolution; 827 TGraph::Streamer(b);; 828 fEX = new Double_t[fNpoints];; 829 fEY = new Double_t[fNpoints];; 830 if (R__v < 2) {; 831 Float_t *ex = new Float_t[fNpoints];; 832 Float_t *ey = new Float_t[fNpoints];; 833 b.ReadFastArray(ex, fNpoints);; 834 b.ReadFastArray(ey, fNpoints);; 835 for (Int_t i = 0; i < fNpoints; i++) {; 836 fEX[i] = ex[i];; 837 fEY[i] = ey[i];; 838 }; 839 delete [] ey;; 840 delete [] ex;; 841 } else {; 842 b.ReadFastArray(fEX, fNpoints);; 843 b.Read",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:25820,allocate,allocate,25820,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"t identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsData(); Destructor. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(RooCmdArg arg1, RooCmdArg arg2 = RooCmdArg(), RooCmdArg arg3 = RooCmdArg(), RooCmdArg arg4 = RooCmdArg(), RooCmdArg arg5 = RooCmdArg(), RooCmdArg arg6 = RooCmdArg(), RooCmdArg arg7 = RooCmdArg(), RooCmdArg arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsData.html:14656,reduce,reduce,14656,root/html526/RooAbsData.html,https://root.cern,https://root.cern/root/html526/RooAbsData.html,2,['reduce'],"['reduce', 'reduced']"
Energy Efficiency,"t idummy); interface with fortran routine pyr. void Pyrget(int lun, int move); interface with fortran routine pyrget. void Pyrset(int lun, int move); interface with fortran routine pyrset. void Pystat(int flag); interface with fortran routine pystat. void Pytest(int flag); interface with fortran routine pytest. void Pyupda(int mupda, int lun); interface with fortran routine pyupda. double Pymass(int kf); interface with fortran routine pymass. int Pychge(int kf); interface with fortran routine pychge. void Py1ent(Int_t line, Int_t kf, Double_t pe, Double_t theta, Double_t phi); Add one entry to the event record, i.e. either a parton or a; particle. IP: normally line number for the parton/particle. There are two; exceptions:. If IP = 0: line number 1 is used and PYEXEC is called.; If IP < 0: line -IP is used, with status code K(-IP,2)=2; rather than 1; thus a parton system may be built; up by filling all but the last parton of the; system with IP < 0.; KF: parton/particle flavour code (PDG code); PE: parton/particle energy. If PE is smaller than the mass,; the parton/particle is taken to be at rest.; THETA:; PHI: polar and azimuthal angle for the momentum vector of the; parton/particle. void SetupTest(); Exemplary setup of Pythia parameters:; Switches on processes 102,123,124 (Higgs generation) and switches off; interactions, fragmentation, ISR, FSR... TPythia6& operator=(const TPythia6& ). Pyjets_t* GetPyjets(); ****** accessors; FORTRAN indexing in accessing the arrays,; indices start from 1 !!!!!; ****** access to PYTHIA6 common-blocks; ****** /PYJETS. { return fPyjets; }. int GetN(); { return fPyjets->N; }. int GetNPAD(); { return fPyjets->NPAD; }. int GetK(int ip, int i); { return fPyjets->K[i-1][ip-1]; }. double GetP(int ip, int i); { return fPyjets->P[i-1][ip-1]; }. double GetV(int ip, int i); { return fPyjets->V[i-1][ip-1]; }. void SetN(int n); { fPyjets->N = n; }. void SetNPAD(int n); { fPyjets->NPAD = n; }. void SetK(int ip, int i, int k); { fPyjets->K[i-1][",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPythia6.html:17090,energy,energy,17090,root/html532/TPythia6.html,https://root.cern,https://root.cern/root/html532/TPythia6.html,1,['energy'],['energy']
Energy Efficiency,"t internal data into 4 Scalar numbersDefinition LorentzVector.h:205; ROOT::Math::LorentzVector::GammaScalar Gamma() constReturn Gamma scalar value.Definition LorentzVector.h:617; ROOT::Math::LorentzVector::XScalar X() constDefinition LorentzVector.h:280; ROOT::Math::LorentzVector::mt2Scalar mt2() constDefinition LorentzVector.h:660; ROOT::Math::LorentzVector::isSpacelikebool isSpacelike() constDetermine if momentum-energy is spacelike, and represents a tachyon.Definition LorentzVector.h:545; ROOT::Math::LorentzVector::zScalar z() constDefinition LorentzVector.h:644; ROOT::Math::LorentzVector::RScalar R() constreturn the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) )Definition LorentzVector.h:310; ROOT::Math::LorentzVector::ScalarCoordSystem::Scalar ScalarDefinition LorentzVector.h:65; ROOT::Math::LorentzVector::P2Scalar P2() constreturn the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 )Definition LorentzVector.h:315; ROOT::Math::LorentzVector::Et2Scalar Et2() constreturn the transverse energy squaredDefinition LorentzVector.h:343; ROOT::Math::LorentzVector::mag2Scalar mag2() constDefinition LorentzVector.h:657; ROOT::Math::LorentzVector::LorentzVectorLorentzVector()default constructor of an empty vector (Px = Py = Pz = E = 0 )Definition LorentzVector.h:71; ROOT::Math::LorentzVector::energyScalar energy() constDefinition LorentzVector.h:664; ROOT::Math::LorentzVector::mtScalar mt() constDefinition LorentzVector.h:659; ROOT::Math::LorentzVector::isTimelikebool isTimelike() constDetermine if momentum-energy can represent a physical massive particle.Definition LorentzVector.h:528; ROOT::Math::LorentzVector::operator-=LorentzVector & operator-=(const OtherLorentzVector &q)Self subtraction of another Vector from this ( v-= q ) Enable the addition with any other LorentzVect...Definition LorentzVector.h:411; ROOT::Math::LorentzVector::PxScalar Px() constspatial X componentDefinition LorentzVector.h:279; ROOT::Math::LorentzVector::etaScalar eta() constDefin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:35437,energy,energy,35437,doc/master/GenVector_2LorentzVector_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html,1,['energy'],['energy']
Energy Efficiency,"t is slower and worse for serialization than the recommended superior alternative ROOT::Math::LorentzVector. ROOT provides specialisations of the ROOT::Math::LorentzVector template which offer superior runtime performance, i.e.:; ROOT::Math::PtEtaPhiMVector based on pt (rho),eta,phi and M (t) coordinates in double precision; ROOT::Math::PtEtaPhiEVector based on pt (rho),eta,phi and E (t) coordinates in double precision; ROOT::Math::PxPyPzMVector based on px,py,pz and M (mass) coordinates in double precision; ROOT::Math::PxPyPzEVector based on px,py,pz and E (energy) coordinates in double precision; ROOT::Math::XYZTVector based on x,y,z,t coordinates (cartesian) in double precision (same as PxPyPzEVector); ROOT::Math::XYZTVectorF based on x,y,z,t coordinates (cartesian) in float precision (same as PxPyPzEVector but float). More details can be found in the documentation of the Physics Vectors package. . Description; TLorentzVector is a general four-vector class, which can be used either for the description of position and time (x,y,z,t) or momentum and energy (px,py,pz,E). Declaration; TLorentzVector has been implemented as a set a TVector3 and a Double_t variable. By default all components are initialized by zero.; TLorentzVector v1; // initialized by (0., 0., 0., 0.); TLorentzVector v2(1., 1., 1., 1.);; TLorentzVector v3(v1);; TLorentzVector v4(TVector3(1., 2., 3.),4.);; TLorentzVectorDefinition TLorentzVector.h:31; TVector3Definition TVector3.h:22; v2@ v2Definition rootcling_impl.cxx:3702; v4@ v4Definition rootcling_impl.cxx:3704; v3@ v3Definition rootcling_impl.cxx:3703; v1@ v1Definition rootcling_impl.cxx:3701; For backward compatibility there are two constructors from an Double_t and Float_t C array. Access to the components; There are two sets of access functions to the components of a LorentzVector: X(), Y(), Z(), T() and Px(), Py(), Pz() and E(). Both sets return the same values but the first set is more relevant for use where TLorentzVector describes a combin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLorentzVector.html:1439,energy,energy,1439,doc/master/classTLorentzVector.html,https://root.cern,https://root.cern/doc/master/classTLorentzVector.html,1,['energy'],['energy']
Energy Efficiency,"t loop. To reduce the runtime cost of this step, make sure to book all operations for all RDataFrame computation graphs before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs.; Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See Activating RDataFrame execution logs. Memory usage; There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies of the results are destroyed when the final result is produced. Reducing the number of threads or using coarser binning will reduce the memory usage.; Secondly, just-in-time compilation of string expressions or non-templated actions (see the previous paragraph) causes Cling, ROOT's C++ interpreter, to allocate some memory for the generated code that is only released at the end of the application. This commonly results in memory usage creep in long-running applications that create many RDataFrames one after the other. Possible mitigations include creating and running each RDataFrame event loop in a sub-process, or booking all operations for all different RDataFrame computation graphs before the first event loop is triggered, so that the interpreter is invoked only once for all computation graphs:; // assuming df1 and df2 are separate computation graphs, do:; auto h1 = df1.Histo1D(""x"");; auto h2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:51132,consumption,consumption,51132,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['consumption'],['consumption']
Energy Efficiency,"t nStart, int nStop, Bool_t copyCache, const char* wgtVarName = 0); Protected constructor for internal use only. RooArgSet addWgtVar(const RooArgSet& origVars, const RooAbsArg* wgtVar); Helper function for constructor that adds optional weight variable to construct; total set of observables. RooAbsData* cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Return a clone of this dataset containing only the cached variables. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const; Return an empty clone of this dataset. If vars is not null, only the variables in vars; are added to the definition of the empty clone. void initialize(const char* wgtVarName); Initialize the dataset. If wgtVarName is not null, interpret the observable; with that name as event weight. RooAbsData* reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); Implementation of RooAbsData virtual method that drives the RooAbsData::reduce() methods. ~RooDataSet(); Destructor. RooDataHist* binnedClone(const char* newName = 0, const char* newTitle = 0) const; Return binned clone of this dataset. Double_t weight() const; Return event weight of current event. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = SumW2) const. Double_t weightError(RooAbsData::ErrorType etype = SumW2) const. const RooArgSet* get(Int_t index) const; Return RooArgSet with coordinates of event 'index'. Double_t sumEntries() const. Double_t sumEntries(const char* cutSpec, const char* cutRange = 0) const; Return the sum of weights in all entries matching cutSpec (if specified); and in named range cutRange (if specified). Bool_t isWeighted() const; Return true if dataset contains weighted events. Bool_t isNonPoissonWeighted() const; Returns true if histogram contains bins with entries with a non-integer wei",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDataSet.html:25873,reduce,reduceEng,25873,root/html532/RooDataSet.html,https://root.cern,https://root.cern/root/html532/RooDataSet.html,2,['reduce'],"['reduce', 'reduceEng']"
Energy Efficiency,"t nStart, int nStop, Bool_t copyCache, const char* wgtVarName = 0); Protected constructor for internal use only. RooArgSet addWgtVar(const RooArgSet& origVars, const RooAbsArg* wgtVar); Helper function for constructor that adds optional weight variable to construct; total set of observables. RooAbsData* cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Return a clone of this dataset containing only the cached variables. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const; Return an empty clone of this dataset. If vars is not null, only the variables in vars; are added to the definition of the empty clone. void initialize(const char* wgtVarName); Initialize the dataset. If wgtVarName is not null, interpret the observable; with that name as event weight. RooAbsData* reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); Implementation of RooAbsData virtual method that drives the RooAbsData::reduce() methods. ~RooDataSet(); Destructor. RooDataHist* binnedClone(const char* newName = 0, const char* newTitle = 0) const; Return binned clone of this dataset. Double_t weight() const; Return event weight of current event. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = SumW2) const. Double_t weightError(RooAbsData::ErrorType etype = SumW2) const. const RooArgSet* get(Int_t index) const; Return RooArgSet with coordinates of event 'index'. Double_t sumEntries(const char* cutSpec = 0, const char* cutRange = 0) const; Return the sum of weights in all entries matching cutSpec (if specified); and in named range cutRange (if specified). Bool_t isWeighted() const; Return true if dataset contains weighted events. Bool_t isNonPoissonWeighted() const; Returns true if histogram contains bins with entries with a non-integer weight. const RooArgSet* get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataSet.html:24241,reduce,reduceEng,24241,root/html526/RooDataSet.html,https://root.cern,https://root.cern/root/html526/RooDataSet.html,6,['reduce'],"['reduce', 'reduceEng']"
Energy Efficiency,"t of Minos (lower and upper values) for a specific parameter. More...;  ; class  Minuit2Minimizer;  Minuit2Minimizer class implementing the ROOT::Math::Minimizer interface for Minuit2 minimization algorithm. More...;  ; class  MinuitParameter;  class for the individual Minuit Parameter with Name and number; contains the input numbers for the minimization or the output result from minimization; possible interactions: Fix/release, set/remove limits, set Value/error; More...;  ; class  MnApplication;  application interface class for minimizers (migrad, simplex, Minimize, Scan) User normally instantiates the derived class like ROOT::Minuit2::MnMigrad for using Migrad for minimization More...;  ; class  MnContours;  API class for Contours Error analysis (2-dim errors); minimization has to be done before and Minimum must be valid; possibility to ask only for the points or the points and associated Minos errors;. More...;  ; class  MnCovarianceSqueeze;  class to reduce the covariance matrix when a parameter is fixed by removing the corresponding row and index More...;  ; class  MnCross;  ; class  MnEigen;  API class for calculating the eigenvalues of symmetric matrix. More...;  ; class  MnFcn;  Wrapper class to FCNBase interface used internally by Minuit. More...;  ; class  MnFumiliMinimize;  API class for minimization using Fumili technology; allows for user interaction: set/change parameters, do minimization, change parameters, re-do minimization etc.; also used by MnMinos and MnContours;. More...;  ; class  MnFunctionCross;  MnFunctionCross. More...;  ; class  MnGlobalCorrelationCoeff;  class for global correlation coefficient More...;  ; class  MnHesse;  API class for calculating the numerical covariance matrix (== 2x Inverse Hessian == 2x Inverse 2nd derivative); can be used by the user or Minuit itself. More...;  ; class  MnLineSearch;  Implements a 1-dimensional minimization along a given direction (i.e. More...;  ; class  MnMachinePrecision;  Sets the relative float",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html:5980,reduce,reduce,5980,doc/master/namespaceROOT_1_1Minuit2.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html,2,['reduce'],['reduce']
Energy Efficiency,"t of all members ; TFolder Class ReferenceCore ROOT classes » Base ROOT classes. ; Legacy Code TFolder is a legacy interface: there will be no bug fixes nor new developments. Therefore it is not recommended to use it in new long-term production code. But, depending on the context, using TFolder might still be a valid solution. ; A TFolder object is a collection of objects and folders. Folders have a name and a title and are identified in the folder hierarchy by a ""Unix-like"" naming mechanism. The root of all folders is //root. New folders can be dynamically added or removed to/from a folder. The folder hierarchy can be visualized via the TBrowser. The Root folders hierarchy can be seen as a whiteboard where objects are posted. Other classes/tasks can access these objects by specifying only a string pathname. This whiteboard facility greatly improves the modularity of an application, minimizing the class relationship problem that penalizes large applications.; Pointers are efficient to communicate between classes. However, one has interest to minimize direct coupling between classes in the form of direct pointers. One better uses the naming and search service provided by the Root folders hierarchy. This makes the classes loosely coupled and also greatly facilitates I/O operations. In a client/server environment, this mechanism facilitates the access to any kind of object in //root stores running on different processes.; A TFolder is created by invoking the TFolder constructor. It is placed inside an existing folder via the TFolder::AddFolder method. One can search for a folder or an object in a folder using the FindObject method. FindObject analyses the string passed as its argument and searches in the hierarchy until it finds an object or folder matching the name.; When a folder is deleted, its reference from the parent folder and possible other folders is deleted.; If a folder has been declared the owner of its objects/folders via TFolder::SetOwner, then the contai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFolder.html:1240,efficient,efficient,1240,doc/master/classTFolder.html,https://root.cern,https://root.cern/doc/master/classTFolder.html,1,['efficient'],['efficient']
Energy Efficiency,"t sliceDataSet;; 2350 sliceSet.selectCommon(*o.projData->get(), sliceDataSet);; 2351 TString cutString ;; 2352 if (!sliceDataSet.empty()) {; 2353 bool first(true) ;; 2354 for(RooAbsArg * sliceVar : sliceDataSet) {; 2355 if (!first) {; 2356 cutString.Append(""&&"") ;; 2357 } else {; 2358 first=false ;; 2359 }; 2360 ; 2361 RooAbsRealLValue* real ;; 2362 RooAbsCategoryLValue* cat ;; 2363 if ((real = dynamic_cast<RooAbsRealLValue*>(sliceVar))) {; 2364 cutString.Append(Form(""%s==%f"",real->GetName(),real->getVal())) ;; 2365 } else if ((cat = dynamic_cast<RooAbsCategoryLValue*>(sliceVar))) {; 2366 cutString.Append(Form(""%s==%d"",cat->GetName(),cat->getCurrentIndex())) ;; 2367 }; 2368 }; 2369 }; 2370 ; 2371 if (!cutString.IsNull()) {; 2372 coutI(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2373 << "") reducing given projection dataset to entries with "" << cutString << std::endl ;; 2374 }; 2375 projDataSelOwned = std::unique_ptr<RooAbsData>{const_cast<RooAbsData*>(o.projData)->reduce(*projDataNeededVars,cutString.IsNull() ? nullptr : cutString)};; 2376 projDataSel = projDataSelOwned.get();; 2377 coutI(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2378 << "") only the following components of the projection data will be used: "" << *projDataNeededVars << std::endl ;; 2379 }; 2380 ; 2381 ; 2382 // Construct scaled data weighted average; 2383 ScaledDataWeightedAverage scaleBind{funcAsym, *projDataSel, o.scaleFactor, *plotVar};; 2384 ; 2385 // Set default range, if not specified; 2386 if (o.rangeLo==0 && o.rangeHi==0) {; 2387 o.rangeLo = frame->GetXaxis()->GetXmin() ;; 2388 o.rangeHi = frame->GetXaxis()->GetXmax() ;; 2389 }; 2390 ; 2391 // Construct name of curve for data weighed average; 2392 TString curveName(funcAsym.GetName()) ;; 2393 curveName.Append(Form(""_DataAvg[%s]"",projDataSel->get()->contentsString().c_str())) ;; 2394 // Append slice set specification if any; 2395 if (!sliceSet.empty()) {; 2396 curveName.Append(Form(""_Slice[%s]"",sliceSet.contentsString().c_str",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:104220,reduce,reduce,104220,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['reduce'],['reduce']
Energy Efficiency,"t start (cm). See also comments*; float phi0; /* azimuthal angle at start (deg) *; float z0; /* z-coord. at start (cm) *; float psi; /* azimuthal angle of pT vector (deg) *; float tanl; /* tan(dip) =pz/pt at start *; float invpt; /* 1/pt at start (GeV/c)^(-1) *; float curvature; /* Track curvature (1/cm) *; float covar[15]; /* full covariance matrix *; float chisq[2]; /* Chi-square per degree of freedom *; float x_first[3]; /* coord. of first measured point (cm) *; float x_last[3]; /* coord. of last measured point (cm) *; float length; /* from first to last point (cm) *; float impact; /* primary vertex (cm) *; unsigned long map[2]; /* extrap. info. (see preceding comments)*; int id; /* Primary key (see comments) *; int iflag; /* bitmask quality info. (see comments) *; int det_id; /* Detector id information *; int method; /* Track finding/fitting method, packed *; int pid; /* Geant particle ID for assumed mass *; int n_point; /* SVT, TPC, FTPC component #s are packed *; int n_max_point; /* SVT, TPC, FTPC component #s are packed *; int n_fit_point; /* SVT, TPC, FTPC component #s are packed *; int icharge; /* Particle charge in units of |e| *; int id_start_vertex; /* final fit and primary track candidates *; } DST_TRACK_ST;. class St_dst_track : public TTable; {; public:; ClassDefTable(St_dst_track,dst_track_st); ClassDef(St_dst_track,2) //C++ wrapper for <dst_track> StAF table; };; #endif. where the CPP macro defines several convinient methods for the; ""table"" class (see: $ROOTSYS/table/inc/Ttypes.h for details:. #define ClassDefTable(className,structName); protected:; static TTableDescriptor *fgColDescriptors;; virtual TTableDescriptor *GetDescriptorPointer() const { return fgColDescriptors;}; virtual void SetDescriptorPointer(TTableDescriptor *list) const { fgColDescriptors = list;}; public:; typedef structName* iterator;; className() : TTable(_QUOTE_(className),sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name) : TTable(name,sizeof(stru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTable.html:2293,charge,charge,2293,root/html534/TTable.html,https://root.cern,https://root.cern/root/html534/TTable.html,5,['charge'],['charge']
Energy Efficiency,"t store indexes we trust the caller that it does match, see comment in THnSparseCompactBinCoord::GetHash(). ; Definition at line 63 of file THnSparse_Internal.h. ◆ operator=(). THnSparseArrayChunk & THnSparseArrayChunk::operator= ; (; const THnSparseArrayChunk & ; ). privatedelete . ◆ Streamer(). void THnSparseArrayChunk::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void THnSparseArrayChunk::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 67 of file THnSparse_Internal.h. ◆ Sumw2(). void THnSparseArrayChunk::Sumw2 ; (; ). Turn on support of errors. ; Definition at line 480 of file THnSparse.cxx. Member Data Documentation. ◆ fContent. TArray* THnSparseArrayChunk::fContent. Bin content. ; Definition at line 48 of file THnSparse_Internal.h. ◆ fCoordinateAllocationSize. Int_t THnSparseArrayChunk::fCoordinateAllocationSize. ! Size of the allocated coordinate buffer; -1 means none or fCoordinatesSize ; Definition at line 44 of file THnSparse_Internal.h. ◆ fCoordinates. Char_t* THnSparseArrayChunk::fCoordinates. [fCoordinatesSize] compact bin coordinate buffer ; Definition at line 47 of file THnSparse_Internal.h. ◆ fCoordinatesSize. Int_t THnSparseArrayChunk::fCoordinatesSize. Size of the bin coordinate buffer. ; Definition at line 46 of file THnSparse_Internal.h. ◆ fSingleCoordinateSize. Int_t THnSparseArrayChunk::fSingleCoordinateSize. Size of a single bin coordinate. ; Definition at line 45 of file THnSparse_Internal.h. ◆ fSumw2. TArrayD* THnSparseArrayChunk::fSumw2. Bin errors. ; Definition at line 49 of file THnSparse_Internal.h. Libraries for THnSparseArrayChunk:. [legend]; The documentation for this class was generated from the following files:; hist/hist/inc/THnSparse_Internal.h; hist/hist/src/THnSparse.cxx. THnSparseArrayChunk. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:50 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnSparseArrayChunk.html:14709,allocate,allocated,14709,doc/master/classTHnSparseArrayChunk.html,https://root.cern,https://root.cern/doc/master/classTHnSparseArrayChunk.html,1,['allocate'],['allocated']
Energy Efficiency,"t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMultiDimFit&operator=(const TMultiDimFit&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = ""ps"") constMENU ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidSetBinVarX(Int_t nbbinvarx); voidSetBinVarY(Int_t nbbinvary); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMaxAngle(Double_t angle = 0); voidSetMaxFunctions(Int_t n); voidSetMaxPowers(const Int_t* powers); voidSetMaxStudy(Int_t n); voidSetMaxTerms(Int_t terms); voidSetMinAngle(Double_t angle = 1); voidSetMinRelativeError(Double_t error); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetPowerLimit(Double_t limit = 1e-3); virtual voidSetPowers(const Int_t* powers, Int_t terms); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiDimFit.html:19440,power,powers,19440,root/html528/TMultiDimFit.html,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html,1,['power'],['powers']
Energy Efficiency,"t sz); void*TObject::operator new[](size_t sz, void* vp); TSpectrumFit&operator=(const TSpectrumFit&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidSetBackgroundParameters(Double_t a0Init, Bool_t fixA0, Double_t a1Init, Bool_t fixA1, Double_t a2Init, Bool_t fixA2); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFitParameters(Int_t xmin, Int_t xmax, Int_t numberIterations, Double_t alpha, Int_t statisticType, Int_t alphaOptim, Int_t power, Int_t fitTaylor); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetPeakParameters(Double_t sigma, Bool_t fixSigma, const Float_t* positionInit, const Bool_t* fixPosition, const Float_t* ampInit, const Bool_t* fixAmp); voidSetTailParameters(Double_t tInit, Bool_t fixT, Double_t bInit, Bool_t fixB, Double_t sInit, Bool_t fixS); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrumFit.html:5575,power,power,5575,root/html528/TSpectrumFit.html,https://root.cern,https://root.cern/root/html528/TSpectrumFit.html,1,['power'],['power']
Energy Efficiency,"t tolCorr = 1e-4, Bool_t verbose = kTRUE) const; Return true if this fit result is identical to other within tolerance 'tol' on fitted values; and tolerance 'tolCor' on correlation coefficients. RooFitResult* lastMinuitFit(const RooArgList& varList = RooArgList()); Import the results of the last fit performed by gMinuit, interpreting; the fit parameters as the given varList of parameters. void setCovarianceMatrix(TMatrixDSym& V); Store externally provided correlation matrix in his RooFitResult ;. TH2* correlationHist(const char* name = ""correlation_matrix"") const; Return TH2D of correlation matrix. const TMatrixDSym& covarianceMatrix() const; Return covariance matrix. TMatrixDSym reducedCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix (Note that Vred _is_ a simple sub-matrix of V,; row/columns are ordered to matched the convention given in input argument 'params'. TMatrixDSym conditionalCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix, which is calculated as; ___ -1; Vred = V22 = V11 - V12 * V22 * V21. Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; is the Shur complement of V22, calculated as shown above. (Note that Vred is _not_ a simple sub-matrix of V). const TMatrixDSym& correlationMatrix() const; Return correlation matrix ;. RooAbsPdf* createHessePdf(const RooArgSet& params) const; Return a p.d.f that represents the fit result as a multi-variate probability densisty; function on the floating fit parameters, including correlations. void SetName(const char* name); Change name of RooFitResult object. void SetNameTitle(const char* name, const char* title); Change name and title of RooFitResult object. void printName(ostream& os) const; Print name of fit result. void printTitle(ostream& os) const; Print title of fit result. void printClassNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFitResult.html:15092,reduce,reduced,15092,root/html532/RooFitResult.html,https://root.cern,https://root.cern/root/html532/RooFitResult.html,2,['reduce'],['reduced']
Energy Efficiency,"t update_scenes = kTRUE, Bool_t redraw = kFALSE); Element-change notification.; Stamp all tracks as requiring display-list regeneration.; Virtual from TEveElement. void InitTrack(TEveVector& v, Int_t charge); Initialize internal data-members for given particle parameters. void ResetTrack(); Reset cache holding particle trajectory. Bool_t GoToVertex(TEveVector& v, TEveVector& p); Propagate particle with momentum p to vertex v. void GoToBounds(TEveVector& p); Propagate particle to bounds.; Return TRUE if hit bounds. void Update(const TEveVector4& v, const TEveVector& p, Bool_t full_update = kFALSE, Bool_t enforce_max_step = kFALSE); Update helix / B-field projection state. void Step(const TEveVector4& v, const TEveVector& p, TEveVector4& vOut, TEveVector& pOut); Wrapper to step helix. void LoopToBounds(TEveVector& p); Propagate charged particle with momentum p to bounds.; It is expected that Update() with full-update was called before. Bool_t LoopToVertex(TEveVector& v, TEveVector& p); Propagate charged particle with momentum p to vertex v.; It is expected that Update() with full-update was called before. Bool_t LineToVertex(TEveVector& v); Propagate neutral particle to vertex v. void LineToBounds(TEveVector& p); Propagatate neutral particle with momentum p to bounds. Bool_t HelixIntersectPlane(const TEveVector& p, const TEveVector& point, const TEveVector& normal, TEveVector& itsect); Intersect helix with a plane. Current position and argument p define; the helix. Bool_t LineIntersectPlane(const TEveVector& p, const TEveVector& point, const TEveVector& normal, TEveVector& itsect); Intersect line with a plane. Current position and argument p define; the line. Bool_t IntersectPlane(const TEveVector& p, const TEveVector& point, const TEveVector& normal, TEveVector& itsect); Find intersection of currently propagated track with a plane.; Current track position is used as starting point. Args:; p - track momentum to use for extrapolation; point - a point on a plane; normal ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveTrackPropagator.html:26383,charge,charged,26383,root/html528/TEveTrackPropagator.html,https://root.cern,https://root.cern/root/html528/TEveTrackPropagator.html,1,['charge'],['charged']
Energy Efficiency,"t use if size is larger; than old size, use ReAlloc(void *, size_t, size_t) instead. void * ReAlloc(void* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) block of memory. Checks if current size is; equal to oldsize. If not memory was overwritten. char * ReAllocChar(char* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of chars. Size and oldsize are; in number of chars. Int_t * ReAllocInt(Int_t* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of integers. Size and oldsize are; number of integers (not number of bytes). void * ObjectAlloc(size_t size); Used to allocate a TObject on the heap (via TObject::operator new()).; Directly after this routine one can call (in the TObject ctor); TStorage::FilledByObjectAlloc() to find out if the just created object is on; the heap. void * ObjectAlloc(size_t size, void* vp); Used to allocate a TObject on the heap (via TObject::operator new(size_t,void*)); in position vp. vp is already allocated (maybe on heap, maybe on; stack) so just return. void ObjectDealloc(void* vp); Used to deallocate a TObject on the heap (via TObject::operator delete()). void ObjectDealloc(void* vp, void* ptr); Used to deallocate a TObject on the heap (via TObject::operator delete(void*,void*)). void SetFreeHook(FreeHookFun_t func, void* data); Set a free handler. void SetReAllocHooks(ReAllocFun_t func1, ReAllocCFun_t func2); Set a custom ReAlloc handlers. This function is typically; called via a static object in the ROOT libNew.so shared library. void PrintStatistics(); Print memory usage statistics. void EnableStatistics(int size = -1, int ix = -1); Enable memory usage statistics gathering. Size is the size of the memory; block that should be trapped and ix is after how many such allocations; the trap should happen. ULong_t GetHeapBegin(). ULong_t GetHeapEnd(). void * GetFreeHookData(); return static free hook data. Bool_t HasCustomNewDelete(); return the has custom delete flag. void SetCustomNewDelete(); set t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStorage.html:4789,allocate,allocated,4789,root/html534/TStorage.html,https://root.cern,https://root.cern/root/html534/TStorage.html,2,['allocate'],['allocated']
Energy Efficiency,"t variables ;  CVariableTransformBaseLinear interpolation class ;  CVarTransformHandler;  CVolumeVolume for BinarySearchTree ;  ►NTStreamerInfoActions;  ►CTActionSequence;  CSequencePtr;  CTConfigurationBase class of the Configurations ;  CTConfiguredAction;  CTIDNode;  CTLoopConfigurationBase class of the Configurations for the member wise looping routines ;  CTNestedIDs;  ►Nwriter;  Cwriter;  C_x3d_data_;  C_x3d_sizeof_;  CAnyCollectionProxy;  CAnyCollectionStreamer;  CBalancerInfo;  Cbasic_string_view;  CBasicRNNLayerGeneric implementation ;  ►CBidirMMapPipeBidirMMapPipe creates a bidirectional channel between the current process and a child it forks ;  CPollEntryFor poll() interface ;  CBinaryOpPolicy;  CBinomialNeymanInterval;  CBinomialProbHelper;  CClassificationClass to perform two class classification ;  CClassificationResultClass to save the results of the classifier ;  CColorStruct_t;  CCompareAsc;  CcompareBAasc;  CcompareBAdesc;  CCompareDesc;  CContDistFree functions adapter needed by UNURAN for onedimensional continuous distributions ;  CContextSmall helper to keep current directory context ;  CCpuInfo_t;  CDebuggingSamplerDebuggingSampler is a simple implementation of the DistributionCreator interface used for debugging ;  CDebuggingTestStatDebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging ;  CDiscrDistFree functions adapter needed by UNURAN for one-dimensional discrete distribution ;  CEvent_t;  CExceptionContext_t;  CFeldmanCousinsBinomialInterval;  CFeldmanCousinsSorter;  CFileStat_t;  CFontAttributes_t;  CFontMetrics_t;  CFoption_t;  Cfuncptr_and_voidptr_t;  CGcCache_t;  CGCValues_t;  CGraphCreatorHelperHelper class that provides the operation graph nodes ;  CGraphNodeClass used to create the operation graph to be printed in the dot representation ;  Cgroup;  Ch1analysis;  Ch1analysisTreeReader;  Chash< std::experimental::basic_string_view< _CharT, _Traits > >;  CHelperOps;  CHEPEVT_DEFHEPEVT com",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:95059,adapt,adapter,95059,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['adapt'],['adapter']
Energy Efficiency,"t wmax, Int_t ndiv, Option_t *chopt,; 724 Double_t gridlength); 725 : TLine(xmin,ymin,xmax,ymax), TAttText(11,0,1,62,0.040); 726{; 727 ; 728 fWmin = wmin;; 729 fWmax = wmax;; 730 fNdiv = ndiv;; 731 fNModLabs = 0;; 732 fModLabs = nullptr;; 733 fGridLength = gridlength;; 734 fLabelOffset = 0.005;; 735 fLabelSize = 0.040;; 736 fLabelFont = 62;; 737 fLabelColor = 1;; 738 fTickSize = 0.030;; 739 fTitleOffset = 1;; 740 fTitleSize = fLabelSize;; 741 fChopt = chopt;; 742 fName = """";; 743 fTitle = """";; 744 fTimeFormat = """";; 745 fFunctionName= """";; 746 fFunction = nullptr;; 747 fAxis = nullptr;; 748}; 749 ; 750////////////////////////////////////////////////////////////////////////////////; 751/// Constructor with a `TF1` to map axis values.; 752///; 753/// \note The function `func` (with name `funcname`) is not defined in the user's; 754/// coordinate space, but in the new TGaxis space. If `x` is the original axis,; 755/// `w` the new axis, and `w = f(x)` (for example, `f` is a calibration function; 756/// converting ADC channels `x` to energy `w`), then `func` must be supplied as; 757/// `f^{-1}(w)`.; 758 ; 759TGaxis::TGaxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax,; 760 const char *funcname, Int_t ndiv, Option_t *chopt,; 761 Double_t gridlength); 762 : TLine(xmin,ymin,xmax,ymax), TAttText(11,0,1,62,0.040); 763{; 764 ; 765 fFunction = (TF1*)gROOT->GetFunction(funcname);; 766 if (!fFunction) {; 767 Error(""TGaxis"", ""calling constructor with an unknown function: %s"", funcname);; 768 fWmin = 0;; 769 fWmax = 1;; 770 } else {; 771 fWmin = fFunction->GetXmin();; 772 fWmax = fFunction->GetXmax();; 773 }; 774 fFunctionName= funcname;; 775 fNdiv = ndiv;; 776 fNModLabs = 0;; 777 fModLabs = nullptr;; 778 fGridLength = gridlength;; 779 fLabelOffset = 0.005;; 780 fLabelSize = 0.040;; 781 fLabelFont = 62;; 782 fLabelColor = 1;; 783 fTickSize = 0.030;; 784 fTitleOffset = 1;; 785 fTitleSize = fLabelSize;; 786 fChopt = chopt;; 787 fName = """";; 788 fTitle = """";; 789 fTimeFor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGaxis_8cxx_source.html:26642,energy,energy,26642,doc/master/TGaxis_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html,1,['energy'],['energy']
Energy Efficiency,"t xMin = 0., Double_t xMax = 0., const Option_t* option = ""KernelType:Gaussian;Iteration:Adaptive;Mirror:noMirror;Binning:RelaxedBinning"", Double_t rho = 1.); Class constructor. ~TKDE(); Class destructor. void Instantiate(TKDE::KernelFunction_Ptr kernfunc, UInt_t events, const Double_t* data, Double_t xMin, Double_t xMax, const Option_t* option, Double_t rho); Template's constructor surrogate. void SetOptions(const Option_t* option, Double_t rho); Sets User defined construction options. void SetDrawOptions(const Option_t* option, TString& plotOpt, TString& drawOpt); Sets User defined drawing options. void GetOptions(string optionType, string option); Gets User defined KDE construction options. void AssureOptions(); Sets missing construction options to default ones. void CheckOptions(Bool_t isUserDefinedKernel = kFALSE); Sets User global options. void SetKernelType(TKDE::EKernelType kern); Sets User option for the choice of kernel estimator. void SetIteration(TKDE::EIteration iter); Sets User option for fixed or adaptive iteration. void SetMirror(TKDE::EMirror mir); Sets User option for mirroring the data. void SetBinning(TKDE::EBinning ); Sets User option for binning the weights. void SetNBins(UInt_t nbins); Sets User option for number of bins. void SetUseBinsNEvents(UInt_t nEvents); Sets User option for the minimum number of events for allowing automatic binning. void SetTuneFactor(Double_t rho); Factor which can be used to tune the smoothing.; It is used as multiplicative factor for the fixed and adaptive bandwidth.; A value < 1 will reproduce better the tails but oversmooth the peak; while a factor > 1 will overestimate the tail. void SetRange(Double_t xMin, Double_t xMax); Sets minimum range value and maximum range value. void SetUseBins(); Sets User option for using binned weights. void SetMirror(); Sets the mirroring. void SetData(const Double_t* data); Sets the data events input sample or bin centres for binned option and computes basic estimators. void InitF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TKDE.html:12898,adapt,adaptive,12898,root/html602/TKDE.html,https://root.cern,https://root.cern/root/html602/TKDE.html,1,['adapt'],['adaptive']
Energy Efficiency,"t) GetValue(0, 0);; 4641}; 4642 ; 4643////////////////////////////////////////////////////////////////////////////////; 4644/// Read leaves into i/o buffers for this branch.; 4645/// Non TObject, Non collection classes with a custom streamer.; 4646 ; 4647void TBranchElement::ReadLeavesCustomStreamer(TBuffer& b); 4648{; 4649 ValidateAddress();; 4650 if (fObject == nullptr); 4651 {; 4652 // We have nowhere to copy the data (probably because the data member was; 4653 // 'dropped' from the current schema) so let's no copy it in a random place.; 4654 return;; 4655 }; 4656 ; 4657 R__PushCache onfileObject(((TBufferFile&)b),fOnfileObject,1);; 4658 fBranchClass->Streamer(fObject,b);; 4659}; 4660 ; 4661////////////////////////////////////////////////////////////////////////////////; 4662/// Unconfiguration Fill Leave function.; 4663 ; 4664void TBranchElement::FillLeavesImpl(TBuffer&); 4665{; 4666 Fatal(""FillLeaves"",""The FillLeaves function has not been configured for %s"",GetName());; 4667}; 4668 ; 4669////////////////////////////////////////////////////////////////////////////////; 4670/// Delete any object we may have allocated on a previous call to SetAddress.; 4671 ; 4672void TBranchElement::ReleaseObject(); 4673{; 4674 if (fObject && TestBit(kDeleteObject)) {; 4675 if (IsAutoDelete() && fAddress != (char*)&fObject) {; 4676 *((char**) fAddress) = nullptr;; 4677 }; 4678 ResetBit(kDeleteObject);; 4679 if (fType == 3) {; 4680 // -- We are a TClonesArray master branch.; 4681 TClonesArray::Class()->Destructor(fObject);; 4682 fObject = nullptr;; 4683 if ((fStreamerType == TVirtualStreamerInfo::kObjectp) ||; 4684 (fStreamerType == TVirtualStreamerInfo::kObjectP)) {; 4685 // -- We are a pointer to a TClonesArray.; 4686 // We must zero the pointer in the object.; 4687 *((char**) fAddress) = nullptr;; 4688 }; 4689 } else if (fType == 4) {; 4690 // -- We are an STL container master branch.; 4691 TVirtualCollectionProxy* proxy = GetCollectionProxy();; 4692 ; 4693 if (!proxy) {; 4694 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:173029,allocate,allocated,173029,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"t));; 47 if (!points) {; 48 puts (""Unable to allocate memory for points !"");; 49 ret = 0;; 50 }; 51 }; 52 else return (0); /* if there are no points, return back */; 53 ; 54 ; 55 ; 56 /*; 57 * Allocate memory for colors; 58 */; 59 ; 60 colors = (Color *) calloc(28+4, sizeof (Color));; 61 if(!colors) {; 62 puts (""Unable to allocate memory for colors !"");; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/X3DBuffer_8c_source.html:2260,green,green,2260,doc/master/X3DBuffer_8c_source.html,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html,1,['green'],['green']
Energy Efficiency,"t); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TVirtualMonitoringWriter(const TVirtualMonitoringWriter&); TVirtualMonitoringWriter&operator=(const TVirtualMonitoringWriter&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TList*fTmpOpenPhasesTo store open phases when there is not yet an object. private:. Double_tfValuedouble monitor value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualMonitoringWriter(const TVirtualMonitoringWriter& ). TVirtualMonitoringWriter& operator=(const TVirtualMonitoringWriter& ). TVirtualMonitoringWriter(); { }. TVirtualMonitoringWriter(const char* name, Double_t value); { }. virtual ~TVirtualMonitoringWriter(); { if (fTmpOpenPhases) delete fTmpOpenPhases; }. Bool_t SendFileCloseEvent(TFile* ); TFile related info. In general they are gathered and sent only sometimes as summaries. { MayNotUse(""SendFileCloseEvent""); return kFALSE; }. Bool_t SendFileReadProgress(TFile* ); { MayNotUse(""SendFileReadProgress""); return kFALSE; }. Bool_t SendFileWriteProgress(TFile* ); { MayNotUse(""SendFileWriteProgress""); return kFALSE; }. Bool_t SendParameters(TList* , const char* = 0); { MayNotUse(""SendParameters""); return kFALSE; }. Bool_t SendInfoTime(); { MayNotUse(""SendInfoTime""); return kFALSE; }. Bool_t SendInfoUser(const char* = 0); { MayN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMonitoringWriter.html:6354,monitor,monitor,6354,root/html528/TVirtualMonitoringWriter.html,https://root.cern,https://root.cern/root/html528/TVirtualMonitoringWriter.html,4,['monitor'],['monitor']
Energy Efficiency,"t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<float>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1); Set size of the matrix to nrows x ncols with nr_nonzeros non-zero entries; if nr_nonzeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTSparse<Element> &TMatrixTSparse<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSparse_float_.html:20302,allocate,allocated,20302,root/html528/TMatrixTSparse_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_float_.html,1,['allocate'],['allocated']
Energy Efficiency,"t, . RooArgSet const & ; pdfObsList, . RooDataHist & ; dataHist, . bool ; histFuncMode . ). staticprivate . Definition at line 359 of file RooHistPdf.cxx. ◆ analyticalIntegral() [2/2]. double RooHistPdf::analyticalIntegral ; (; Int_t ; code, . const char * ; rangeName = nullptr . ); const. overridevirtual . Return integral identified by 'code'. ; The actual integration is deferred to RooDataHist::sum() which implements partial or complete summation over the histograms contents. ; Reimplemented from RooAbsReal.; Definition at line 434 of file RooHistPdf.cxx. ◆ areIdentical(). bool RooHistPdf::areIdentical ; (; const RooDataHist & ; dh1, . const RooDataHist & ; dh2 . ). protected . Definition at line 590 of file RooHistPdf.cxx. ◆ binBoundaries(). std::list< double > * RooHistPdf::binBoundaries ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ; Reimplemented from RooAbsReal.; Definition at line 523 of file RooHistPdf.cxx. ◆ buildCallToAnalyticIntegral(). std::string RooHistPdf::buildCallToAnalyticIntegral ; (; int ; code, . const char * ; rangeName, . RooFit::Detail::CodeSquashContext & ; ctx . ); const. overridevirtual . This function defines the analytical integral translation for the class. ; Parameters. [in]codeThe code that decides the integrands. ; [in]rangeNameName of the normalization range. ; [in]ctxAn object to manage auxiliary information for code-squashing. ReturnsThe representative code string of the integral for the given object. ; Reimplemented from RooAbsReal.; Definition at line 410 of file RooHistPdf.cxx. ◆ Class(). static TClass * RooHistPdf::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooHistPdf::Class_Name ; (; ). static . ReturnsName of this cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistPdf.html:79989,efficient,efficiently,79989,doc/master/classRooHistPdf.html,https://root.cern,https://root.cern/doc/master/classRooHistPdf.html,1,['efficient'],['efficiently']
Energy Efficiency,"t, map<string,TH1*> hmap, Double_t wgt); Import data from given set of TH1/2/3 into this RooDataHist. The category indexCat labels the sources; in the constructed RooDataHist. The stl map provides the mapping between the indexCat state labels; and the import source. void importDHistSet(const RooArgList& /*vars*/, RooCategory& indexCat, std::map<std::string,RooDataHist*> dmap, Double_t initWgt); Import data from given set of TH1/2/3 into this RooDataHist. The category indexCat labels the sources; in the constructed RooDataHist. The stl map provides the mapping between the indexCat state labels; and the import source. void adjustBinning(const RooArgList& vars, TH1& href, Int_t* offset = 0); Adjust binning specification on first and optionally second and third; observable to binning in given reference TH1. Used by constructors; that import data from an external TH1. void initialize(const char* binningName = 0, Bool_t fillTree = kTRUE); Initialization procedure: allocate weights array, calculate; multipliers needed for N-space to 1-dim array jump table,; and fill the internal tree with all bin center coordinates. RooDataHist(const RooDataHist& other, const char* newname = 0); Copy constructor. RooDataHist(const char* name, const char* title, RooDataHist* h, const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t copyCache); Constructor of a data hist from (part of) an existing data hist. The dimensions; of the data set are defined by the 'vars' RooArgSet, which can be identical; to 'dset' dimensions, or a subset thereof. Reduced dimensions will be projected; in the output data hist. The optional 'cutVar' formula variable can used to; select the subset of bins to be copied. For most uses the RooAbsData::reduce() wrapper function, which uses this constructor,; is the most convenient way to create a subset of an existing data. RooAbsData* cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataHist.html:24613,allocate,allocate,24613,root/html526/RooDataHist.html,https://root.cern,https://root.cern/root/html526/RooDataHist.html,1,['allocate'],['allocate']
Energy Efficiency,"t. In the base-class version we only make sure the new child is not; equal to this. void AddElement(TEveElement* el); Add el to the list of children. void RemoveElement(TEveElement* el); Remove el from the list of children. void RemoveElementLocal(TEveElement* el); Perform additional local removal of el.; Called from RemoveElement() which does whole untangling.; Put into special function as framework-related handling of; element removal should really be common to all classes and; clearing of local structures happens in between removal; of list-tree-items and final removal.; If you override this, you should also override; RemoveElementsLocal(). void RemoveElementsInternal(); Remove all elements. This assumes removing of all elements can; be done more efficiently then looping over them and removing one; by one. This protected function performs the removal on the; level of TEveElement. void RemoveElements(); Remove all elements. This assumes removing of all elements can; be done more efficiently then looping over them and removing; them one by one. void RemoveElementsLocal(); Perform additional local removal of all elements.; See comment to RemoveElementlocal(TEveElement*). void ProjectChild(TEveElement* el, Bool_t same_depth = kTRUE); If this is a projectable, loop over all projected replicas and; add the projected image of child 'el' there. This is supposed to; be called after you add a child to a projectable after it has; already been projected.; You might also want to call RecheckImpliedSelections() on this; element or 'el'. If 'same_depth' flag is true, the same depth as for parent object; is used in every projection. Otherwise current depth of each; relevant projection-manager is used. void ProjectAllChildren(Bool_t same_depth = kTRUE); If this is a projectable, loop over all projected replicas and; add the projected image of all children there. This is supposed; to be called after you destroy all children and then add new; ones after this element has already bee",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveElement.html:24882,efficient,efficiently,24882,root/html528/TEveElement.html,https://root.cern,https://root.cern/root/html528/TEveElement.html,6,['efficient'],['efficiently']
Energy Efficiency,"t. The caller; 4874/// owns the allocated object and is responsible for deleting; 4875/// it when it is no longer needed.; 4876///; 4877/// Example:; 4878/// ~~~ {.cpp}; 4879/// Event* event = 0;; 4880/// branch->SetAddress(&event);; 4881/// ... Do some work.; 4882/// delete event;; 4883/// event = 0;; 4884/// ~~~; 4885/// If addr is not zero and the pointer addr points at is; 4886/// also not zero, then the caller has allocated a branch; 4887/// object and is asking us to use it. The caller owns it; 4888/// and must delete it when it is no longer needed.; 4889///; 4890/// Example:; 4891/// ~~~ {.cpp}; 4892/// Event* event = new Event();; 4893/// branch->SetAddress(&event);; 4894/// ... Do some work.; 4895/// delete event;; 4896/// event = 0;; 4897/// ~~~; 4898/// These rules affect users of TTree::Branch(),; 4899/// TTree::SetBranchAddress(), and TChain::SetBranchAddress(); 4900/// as well because those routines call this one.; 4901///; 4902/// An example of a tree with branches with objects allocated; 4903/// and owned by us:; 4904/// ~~~ {.cpp}; 4905/// TFile* f1 = new TFile(""myfile_original.root"");; 4906/// TTree* t1 = (TTree*) f->Get(""MyTree"");; 4907/// TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; 4908/// TTree* t2 = t1->Clone(0);; 4909/// for (Int_t i = 0; i < 10; ++i) {; 4910/// t1->GetEntry(i);; 4911/// t2->Fill();; 4912/// }; 4913/// t2->Write(); 4914/// delete f2;; 4915/// f2 = 0;; 4916/// delete f1;; 4917/// f1 = 0;; 4918/// ~~~; 4919/// An example of a branch with an object allocated by us,; 4920/// but owned by the caller:; 4921/// ~~~ {.cpp}; 4922/// TFile* f = new TFile(""myfile.root"", ""recreate"");; 4923/// TTree* t = new TTree(""t"", ""A test tree.""); 4924/// Event* event = 0;; 4925/// TBranchElement* br = t->Branch(""event."", &event);; 4926/// for (Int_t i = 0; i < 10; ++i) {; 4927/// ... Fill event with meaningful data in some way.; 4928/// t->Fill();; 4929/// }; 4930/// t->Write();; 4931/// delete event;; 4932/// event = 0;; 4933/// delete f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:181300,allocate,allocated,181300,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"t.CThis program must be compiled and executed with Aclic as follows ;  ► v7;  box.cxxThis ROOT 7 example demonstrates how to create a ROOT 7 canvas (RCanvas) and draw ROOT 7 boxes in it (RBox) ;  concurrentfill.cxx;  draw.cxx;  draw_mt.cxxThis macro demonstrate usage of ROOT7 graphics from many threads Three different canvases in three different threads are started and regularly updated ;  draw_rh1.cxxThis macro generates a small V7 TH1D, fills it and draw it in a V7 canvas ;  draw_subpads.cxx;  draw_v6.cxx;  fitpanel.cxx;  histops.cxx;  line.cxxThis ROOT 7 example demonstrates how to create a ROOT 7 canvas (RCanvas) and draw ROOT 7 lines in it (RLine) ;  lineStyle.cxx;  lineWidth.cxx;  markerStyle.cxx;  pad.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► vecops;  vo001_AdoptOrOwnMemory.C In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo001_AdoptOrOwnMemory.py In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo002_VectorCalculations.C In this tutorial we learn how the RVec class can be used to express easily mathematical operations involving arrays and scalars ;  vo003_LogicalOperations.C In this tutorial we learn how the RVec class can be used to express logical operations ;  vo004_SortAndSelect.C In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo004_SortAndSelect.py In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo005_Combinations.C In this tutorial we learn how combinations of RVecs can be build ;  vo005_Combinations.py In this tutorial we learn how combinations of RVecs can be build ;  vo006_IndexManipulation.C In this tutorial we demonstrate RVec helpers for index manipulation ;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlmo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:172278,allocate,allocate,172278,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['allocate'],['allocate']
Energy Efficiency,"t.h. ◆ fDetailedMonitoring. Bool_t TMVA::MethodBoost::fDetailedMonitoring. private . produce detailed monitoring histograms (boost-wise) ; Definition at line 157 of file MethodBoost.h. ◆ fHistoricBoolOption. Bool_t TMVA::MethodBoost::fHistoricBoolOption. private . historic variable, only needed for ""CompatibilityOptions"" ; Definition at line 195 of file MethodBoost.h. ◆ fHistoricOption. TString TMVA::MethodBoost::fHistoricOption. private . historic variable, only needed for ""CompatibilityOptions"" ; Definition at line 194 of file MethodBoost.h. ◆ fMethodError. Double_t TMVA::MethodBoost::fMethodError. private . estimation of the level error of the classifier ; Definition at line 183 of file MethodBoost.h. ◆ fMonitorBoostedMethod. Bool_t TMVA::MethodBoost::fMonitorBoostedMethod. private . monitor the MVA response of every classifier ; Definition at line 167 of file MethodBoost.h. ◆ fMonitorTree. TTree* TMVA::MethodBoost::fMonitorTree. private . tree to monitor values during the boosting ; Definition at line 181 of file MethodBoost.h. ◆ fMVAvalues. std::vector<Float_t>* TMVA::MethodBoost::fMVAvalues. private . mva values for the last trained method ; Definition at line 191 of file MethodBoost.h. ◆ fOverlap_integral. Double_t TMVA::MethodBoost::fOverlap_integral. private . Definition at line 189 of file MethodBoost.h. ◆ fRandomSeed. UInt_t TMVA::MethodBoost::fRandomSeed. private . seed for random number generator used for bagging ; Definition at line 160 of file MethodBoost.h. ◆ fROC_training. Double_t TMVA::MethodBoost::fROC_training. private . roc integral of last trained method (on training sample) ; Definition at line 185 of file MethodBoost.h. ◆ fTestBgdMVAHist. std::vector< TH1* > TMVA::MethodBoost::fTestBgdMVAHist. private . Definition at line 178 of file MethodBoost.h. ◆ fTestSigMVAHist. std::vector< TH1* > TMVA::MethodBoost::fTestSigMVAHist. private . Definition at line 176 of file MethodBoost.h. ◆ fTrainBgdMVAHist. std::vector< TH1* > TMVA::MethodBoost::fTrainB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBoost.html:44518,monitor,monitor,44518,doc/master/classTMVA_1_1MethodBoost.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBoost.html,1,['monitor'],['monitor']
Energy Efficiency,"t.h:251; TMVA::DNN::Batch::beginconst_iterator begin() constDefinition NeuralNet.h:244; TMVA::DNN::Batch::endconst_iterator end() constDefinition NeuralNet.h:245; TMVA::DNN::Batch::BatchBatch(typename std::vector< Pattern >::const_iterator itBegin, typename std::vector< Pattern >::const_iterator itEnd)Definition NeuralNet.h:239; TMVA::DNN::Batch::sizesize_t size() constDefinition NeuralNet.h:247; TMVA::DNN::Batch::const_iteratorstd::vector< Pattern >::const_iterator const_iteratorDefinition NeuralNet.h:237; TMVA::DNN::Batch::m_itBeginconst_iterator m_itBeginiterator denoting the beginning of the batchDefinition NeuralNet.h:250; TMVA::DNN::ClassificationSettingsSettings for classificationused to distinguish between different function signatures.Definition NeuralNet.h:895; TMVA::DNN::ClassificationSettings::startTrainCyclevoid startTrainCycle()action to be done when the training cycle is started (e.g.Definition NeuralNet.cxx:281; TMVA::DNN::ClassificationSettings::testIterationvoid testIteration()callback for monitoring and logggingDefinition NeuralNet.h:930; TMVA::DNN::ClassificationSettings::endTrainCyclevoid endTrainCycle(double)action to be done when the training cycle is ended (e.g.Definition NeuralNet.cxx:296; TMVA::DNN::ClassificationSettings::endTestCyclevirtual void endTestCycle()action to be done when the training cycle is ended (e.g.Definition NeuralNet.cxx:326; TMVA::DNN::ClassificationSettings::m_pResultPatternContainerstd::vector< Pattern > * m_pResultPatternContainerDefinition NeuralNet.h:1009; TMVA::DNN::ClassificationSettings::setResultComputationvoid setResultComputation(std::string _fileNameNetConfig, std::string _fileNameResult, std::vector< Pattern > *_resultPatternContainer)preparation for monitoring outputDefinition NeuralNet.cxx:520; TMVA::DNN::ClassificationSettings::m_fileNameResultstd::string m_fileNameResultDefinition NeuralNet.h:1010; TMVA::DNN::ClassificationSettings::ClassificationSettingsClassificationSettings(TString name, size_t _conv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:50571,monitor,monitoring,50571,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['monitor'],['monitoring']
Energy Efficiency,"t2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar tolerance = 100 * std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.The",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html:15197,energy,energy,15197,root/html602/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,4,['energy'],['energy']
Energy Efficiency,"t2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar tolerance = 100 * std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.The",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html:15197,energy,energy,15197,root/html602/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,4,['energy'],['energy']
Energy Efficiency,"t::(anonymous)TObject::kZombie. protected:. TTableDescriptor*fColDescriptors; TSeqCollection*TDataSet::fListList of the the the objects included into this dataset; Long_tTTable::fMaxIndexThe used capacity of this array; Int_tTTable::fNNumber of array elements; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; Long_tTTable::fSizeSize of the one element (row) of the table; Char_t*TTable::fTableArray of (fN*fSize) longs; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenericTable(const TTableDescriptor& dsc, const char* name). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object. TGenericTable(const TTableDescriptor& dsc, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - ""TGenericTable""; n - The initial number of allocated rows. TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGenericTable.html:18159,allocate,allocated,18159,root/html602/TGenericTable.html,https://root.cern,https://root.cern/root/html602/TGenericTable.html,2,['allocate'],['allocated']
Energy Efficiency,"t::CheckReferenceCount ""); Check reference count - virtual from TEveElement.; Must also take into account references from TEveRefBackPtr. void ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); Element-change notification.; Stamp all tracks as requiring display-list regeneration.; Virtual from TEveElement. void InitTrack(TEveVector& v, Int_t charge); Initialize internal data-members for given particle parameters. void ResetTrack(); Reset cache holding particle trajectory. Bool_t GoToVertex(TEveVector& v, TEveVector& p); Propagate particle with momentum p to vertex v. void GoToBounds(TEveVector& p); Propagate particle to bounds.; Return TRUE if hit bounds. void Update(const TEveVector4& v, const TEveVector& p, Bool_t full_update = kFALSE, Bool_t enforce_max_step = kFALSE); Update helix / B-field projection state. void Step(const TEveVector4& v, const TEveVector& p, TEveVector4& vOut, TEveVector& pOut); Wrapper to step helix. void LoopToBounds(TEveVector& p); Propagate charged particle with momentum p to bounds.; It is expected that Update() with full-update was called before. Bool_t LoopToVertex(TEveVector& v, TEveVector& p); Propagate charged particle with momentum p to vertex v.; It is expected that Update() with full-update was called before. Bool_t LineToVertex(TEveVector& v); Propagate neutral particle to vertex v. void LineToBounds(TEveVector& p); Propagatate neutral particle with momentum p to bounds. Bool_t HelixIntersectPlane(const TEveVector& p, const TEveVector& point, const TEveVector& normal, TEveVector& itsect); Intersect helix with a plane. Current position and argument p define; the helix. Bool_t LineIntersectPlane(const TEveVector& p, const TEveVector& point, const TEveVector& normal, TEveVector& itsect); Intersect line with a plane. Current position and argument p define; the line. Bool_t IntersectPlane(const TEveVector& p, const TEveVector& point, const TEveVector& normal, TEveVector& itsect); Find intersection of currently propa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveTrackPropagator.html:26212,charge,charged,26212,root/html528/TEveTrackPropagator.html,https://root.cern,https://root.cern/root/html528/TEveTrackPropagator.html,1,['charge'],['charged']
Energy Efficiency,"t::ResetAfterMerge(TFileMergeInfo *info); 4768{; 4769 Int_t nbranches = fBranches.GetEntriesFast();; 4770 for (Int_t i = 0; i < nbranches; ++i) {; 4771 TBranch* branch = (TBranch*) fBranches[i];; 4772 branch->ResetAfterMerge(info);; 4773 }; 4774 TBranch::ResetAfterMerge(info);; 4775}; 4776 ; 4777////////////////////////////////////////////////////////////////////////////////; 4778/// Set branch address to zero and free all allocated memory.; 4779 ; 4780void TBranchElement::ResetAddress(); 4781{; 4782 for (Int_t i = 0; i < fNleaves; ++i) {; 4783 TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(i);; 4784 //if (leaf) leaf->SetAddress(0);; 4785 leaf->SetAddress(nullptr);; 4786 }; 4787 ; 4788 // Note: We *must* do the sub-branches first, otherwise; 4789 // we may delete the object containing the sub-branches; 4790 // before giving them a chance to cleanup.; 4791 Int_t nbranches = fBranches.GetEntriesFast();; 4792 for (Int_t i = 0; i < nbranches; ++i) {; 4793 TBranch* br = (TBranch*) fBranches[i];; 4794 if (br) br->ResetAddress();; 4795 }; 4796 ; 4797 //; 4798 // SetAddress may have allocated an object.; 4799 //; 4800 ; 4801 ReleaseObject();; 4802 ; 4803 ResetBit(kAddressSet);; 4804 fAddress = nullptr;; 4805 fObject = nullptr;; 4806}; 4807 ; 4808////////////////////////////////////////////////////////////////////////////////; 4809/// Release ownership of any allocated objects.; 4810///; 4811/// Note: This interface was added so that clone trees could; 4812/// be told they do not own the allocated objects.; 4813 ; 4814void TBranchElement::ResetDeleteObject(); 4815{; 4816 ResetBit(kDeleteObject);; 4817 Int_t nb = fBranches.GetEntriesFast();; 4818 for (Int_t i = 0; i < nb; ++i) {; 4819 TBranch* br = (TBranch*) fBranches[i];; 4820 if (br->InheritsFrom(TBranchElement::Class())) {; 4821 ((TBranchElement*) br)->ResetDeleteObject();; 4822 }; 4823 }; 4824}; 4825 ; 4826////////////////////////////////////////////////////////////////////////////////; 4827/// \brief Reset offset and Stream",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:177717,allocate,allocated,177717,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"t::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. ULong_tfAllMembersCountNumber of all members (class and its daughters); Bool_tfCollapsedCondition - true if node is collapsed (we don't see dauthers); Float_tfHeightHeight of outlining box; UInt_tfLevelLevel number; UInt_tfMaxLevelNumber of levels displayed when the node is top node on scene; UInt_tfMaxObjectsNumber of objects displayed when the node is top node on scene; TList*fMembersList of daughter nodes; ULong_tfMembersCountNumber of members in class; TStringfNameName of node; ENodeTypefNodeTypeType of node; TStructNode*fParentPointer to parent node, NULL if not exist; void*fPointerPointer to data (address of variable); ULong_tfSizeMemory allocated by class without pointers and list elements; ULong_tfTotalSizeTotal allocated memory; TStringfTypeNameName of type; Bool_tfVisibleCondition - true if node is visible; Float_tfWidthWidth of outlining box; Float_tfXX coordinate in 3D space; Float_tfYY coordinate in 3D space; static EScalingTypefgScalBy. Class Charts. Inheritance Chart:. TObject. ←; TStructNode. Function documentation; TStructNode(TString name, TString typeName, void* pointer, TStructNode* parent, ULong_t size, ENodeType type); Constructs node with name ""name"" of class ""typeName"" and given parent ""parent"" which represents pointer ""pointer"".; Size of node is set to ""size"" and type is set to ""type"". ~TStructNode(); Destructs list of nodes. Int_t Compare(const TObject* obj) const; Overrided method. Compare to objects of TStructNode class. ULong_t G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStructNode.html:7970,allocate,allocated,7970,root/html602/TStructNode.html,https://root.cern,https://root.cern/root/html602/TStructNode.html,4,['allocate'],['allocated']
Energy Efficiency,"t; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This is a simplified version of ExpandCreate used in the TTree mechanism. TObject * RemoveAt(Int_t idx); Remove object at index idx. TObject * Remove(TObject* obj); Remove object from array. void RemoveRange(Int_t idx1, Int_t idx2); Remove objects from index idx1 to idx2 included. void SetClass(const TClass* cl, Int_t size = 1000); Create",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClonesArray.html:18074,allocate,allocated,18074,root/html528/TClonesArray.html,https://root.cern,https://root.cern/root/html528/TClonesArray.html,2,['allocate'],['allocated']
Energy Efficiency,"t; boolRunOnePoint(double thisX, bool adaptive = false, double clTarget = -1) const; voidSetAutoScan(); static voidSetCloseProof(Bool_t flag); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData&); voidSetFixedScan(int nBins, double xMin = 1, double xMax = -1, bool scanLog = false); voidSetMaximumToys(int ntoys); virtual voidSetModel(const RooStats::ModelConfig&); voidSetNumErr(double err); virtual voidSetTestSize(Double_t size); boolSetTestStatistic(RooStats::TestStatistic& stat); voidSetVerbose(int level = 1); virtual voidShowMembers(TMemberInspector& insp) const; virtual Double_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidUseCLs(bool on = true). protected:. static voidCheckInputModels(const RooStats::HypoTestCalculatorGeneric& hc, const RooRealVar& scanVar); voidCreateResults() const; RooStats::HypoTestResult*Eval(RooStats::HypoTestCalculatorGeneric& hc, bool adaptive, double clsTarget) const; static RooRealVar*GetVariableToScan(const RooStats::HypoTestCalculatorGeneric& hc); RooStats::HypoTestInverterHypoTestInverter(const RooStats::HypoTestInverter& rhs); RooStats::HypoTestInverter&operator=(const RooStats::HypoTestInverter& rhs). Data Members; public:. static RooStats::HypoTestInverter::ECalculatorTypekAsymptotic; static RooStats::HypoTestInverter::ECalculatorTypekFrequentist; static RooStats::HypoTestInverter::ECalculatorTypekHybrid; static RooStats::HypoTestInverter::ECalculatorTypekUndefined. private:. RooStats::HypoTestInverter::ECalculatorTypefCalcType; RooStats::HypoTestCalculatorGeneric*fCalculator0pointer to the calculator passed in the constructor; unique_ptr<RooStats::HypoTestCalculatorGeneric>fHC! pointer to the generic hypotest calculator used; unique_ptr<TGraphErrors>fLimitPlot! plot of limits; intfMaxToysmaximum number of toys to run; intfNBins; doublefNumErr; RooStats::HypoTestInverterResult*fResultspointer to the result; boolfScanLog; RooRealVar*fScannedVar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HypoTestInverter.html:4515,adapt,adaptive,4515,root/html602/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html602/RooStats__HypoTestInverter.html,2,['adapt'],['adaptive']
Energy Efficiency,"t; const char*GetStageOpts() const; virtual TMap*TDataSetManager::GetSubDataSets(const char* uri, const char* excludeservers); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTDataSetManager::MonitorUsedSpace(TVirtualMonitoringWriter* monitoring); virtual Bool_tTObject::Notify(); virtual Int_tNotifyUpdate(const char* group, const char* user, const char* dspath, Long_t mtime, const char* checksum = 0); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); static TList*TDataSetManager::ParseDataSetSrvMaps(const TString& srvmaps); virtual voidParseInitOpts(const char* opts); Bool_tTDataSetManager::ParseUri(const char* uri, TString* dsGroup = 0, TString* dsUser = 0, TString* dsName = 0, TString* dsTree = 0, Bool_t onlyCurrent = kFALSE, Bool_t wildcards = kFALSE); virtual voidTObject::Pop(); vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSetManagerFile.html:4378,monitor,monitoring,4378,root/html528/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html528/TDataSetManagerFile.html,1,['monitor'],['monitoring']
Energy Efficiency,"t; const char*GetStageOpts() const; virtual TMap*TDataSetManager::GetSubDataSets(const char* uri, const char* excludeservers); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTDataSetManager::MonitorUsedSpace(TVirtualMonitoringWriter* monitoring); virtual Bool_tTObject::Notify(); virtual Int_tNotifyUpdate(const char* group, const char* user, const char* dspath, Long_t mtime, const char* checksum = 0); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); static TList*TDataSetManager::ParseDataSetSrvMaps(const TString& srvmaps); virtual voidParseInitOpts(const char* opts); Bool_tTDataSetManager::ParseUri(const char* uri, TString* dsGroup = 0, TString* dsUser = 0, TString* dsName = 0, TString*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TDataSetManagerFile.html:4378,monitor,monitoring,4378,root/html530/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html530/TDataSetManagerFile.html,3,['monitor'],['monitoring']
Energy Efficiency,"t; const char*GetStageOpts() const; virtual TMap*TDataSetManager::GetSubDataSets(const char* uri, const char* excludeservers); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTDataSetManager::MonitorUsedSpace(TVirtualMonitoringWriter* monitoring); virtual Bool_tTObject::Notify(); virtual Int_tNotifyUpdate(const char* group, const char* user, const char* dspath, Long_t mtime, const char* checksum = 0); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TDataSetManagerFile&operator=(const TDataSetManagerFile&); virtual voidTObject::Paint(Option_t* option = """"); static TList*TDataSetManager::ParseDataSetSrvMaps(const TString& srvmaps); virtual voidParseInitOpts(const char* opts); Bool_tTDataSetManager::ParseUri(const char* uri, TString* dsGroup = 0, TString* dsUser = 0, TString* dsName = 0, TString* dsTree = 0, Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDataSetManagerFile.html:4506,monitor,monitoring,4506,root/html602/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html602/TDataSetManagerFile.html,2,['monitor'],['monitoring']
Energy Efficiency,"t; more convenient of the other Tokenize method when saving the tokens is not needed. ; Definition at line 310 of file TRegexp.cxx. ◆ ToLower(). void TString::ToLower ; (; ). Change string to lower-case. ; Definition at line 1182 of file TString.cxx. ◆ ToUpper(). void TString::ToUpper ; (; ). Change string to upper case. ; Definition at line 1195 of file TString.cxx. ◆ UItoa(). TString TString::UItoa ; (; UInt_t ; value, . Int_t ; base . ). static . Converts a UInt_t (twice the range of an Int_t) to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). In case of error returns the ""!"" string. ; Definition at line 2119 of file TString.cxx. ◆ ULLtoa(). TString TString::ULLtoa ; (; ULong64_t ; value, . Int_t ; base . ). static . Converts a ULong64_t (twice the range of an Long64_t) to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). In case of error returns the ""!"" string. ; Definition at line 2171 of file TString.cxx. ◆ UnLink(). void TString::UnLink ; (; ); const. inlineprivate . Definition at line 263 of file TString.h. ◆ View(). std::string_view TString::View ; (; ); const. inline . Definition at line 452 of file TString.h. ◆ WriteString(). void TString::WriteString ; (; TBuffer & ; b, . const TString * ; a . ). static . Write TString object to buffer. ; Simplified version of TBuffer::WriteObject (does not keep track of multiple references to the same string). We need to have it here because TBuffer::ReadObject can only handle descendant of TObject ; Definition at line 1428 of file TString.cxx. ◆ Zero(). void TString::Zero ; (; ). inlineprivate . Definition at line 264 of file TString.h. Friends And Related Symbol Documentation. ◆ operator+ [1/11]. TString operator+ ; (; char ; c, . const TString & ; s . ). friend . Add stri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTString.html:56861,adapt,adapted,56861,doc/v632/classTString.html,https://root.cern,https://root.cern/doc/v632/classTString.html,2,['adapt'],['adapted']
Energy Efficiency,"t; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tTDecompBase::fColLwbColumn lower bound of decomposed matrix; Double_tTDecompBase::fConditionmatrix condition number; Double_tTDecompBase::fDet1determinant mantissa; Double_tTDecompBase::fDet2determinant exponent for powers of 2; Int_tTDecompBase::fRowLwbRow lower bound of decomposed matrix; Double_tTDecompBase::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1; TMatrixDfUdecomposed matrix fU so that a = fU^T fU; static TDecompBase::EMatrixDecompStatTDecompBase::kCondition; static TDecompBase::EMatrixDecompStatTDecompBase::kDecomposed; static TDecompBase::EMatrixDecompStatTDecompBase::kDetermined; static TDecompBase::EMatrixDecompStatTDecompBase::kInit; static TDecompBase::EMatrixDecompStatTDecompBase::kMatrixSet; static TDecompBase::EMatrixDecompStatTDecompBase::kPatternSet; static TDecompBase::EMatrixDecompStatTDecompBase::kSingular; static TDecompBase::EMatrixDecompStatTDecompBase::kValuesSet; static TDecompBase::(anonymous)TDecompBase::kWorkMax. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecompChol(Int_t nrows); Constructor for (nrows x nrows) matrix. TDecompChol(Int_t row_lwb, Int_t row_upb); Constructor for ([row_lwb..row_upb] x [row_lwb..row_upb]) matrix. TDecompChol(const TMatrixDSym& a, Double_t tol = 0.); Constructor for symmetric matrix A . Matrix should be positive definite. TDecompChol(const TMatrixD& a, Double_t tol = 0.); Constructor for general matrix A . Matrix should be symmetr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDecompChol.html:7461,power,powers,7461,root/html602/TDecompChol.html,https://root.cern,https://root.cern/root/html602/TDecompChol.html,2,['power'],['powers']
Energy Efficiency,"t; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*RooAbsData::cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooTreeData.html:13874,reduce,reduceEng,13874,root/html532/RooTreeData.html,https://root.cern,https://root.cern/root/html532/RooTreeData.html,1,['reduce'],['reduceEng']
Energy Efficiency,"t; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*RooAbsData::cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTreeData.html:13321,reduce,reduceEng,13321,root/html526/RooTreeData.html,https://root.cern,https://root.cern/root/html526/RooTreeData.html,3,['reduce'],['reduceEng']
Energy Efficiency,"t; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. THnSparseArrayChunk&operator=(const THnSparseArrayChunk&); THnSparseArrayChunk(const THnSparseArrayChunk&). Data Members; public:. TArray*fContentbin content; Int_tfCoordinateAllocationSize! size of the allocated coordinate buffer; -1 means none or fCoordinatesSize; Char_t*fCoordinates[fCoordinatesSize] compact bin coordinate buffer; Int_tfCoordinatesSizesize of the bin coordinate buffer; Int_tfSingleCoordinateSizesize of a single bin coordinate; TArrayD*fSumw2bin errors; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont); (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; and create an ArrayF for errors if ""errors"" is true. ~THnSparseArrayChunk(); Destructor. void AddBin(Int_t idx, const Char_t* idxbuf); Create a new bin in this chunk. void Sumw2(); Turn on support of errors. THnSpar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THnSparseArrayChunk.html:5612,allocate,allocated,5612,root/html602/THnSparseArrayChunk.html,https://root.cern,https://root.cern/root/html602/THnSparseArrayChunk.html,2,['allocate'],['allocated']
Energy Efficiency,"t; voidTObject::MakeZombie(). Data Members; public:. enum EGeoHelixTypes { kHelixNeedUpdate; kHelixStraigth; kHelixCircle; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfB[3]normalized direction for magnetic field; Double_tfCcurvature in XY plane; Double_tfDir[3]direction after a step; Double_tfDirInit[3]normalized initial direction; TGeoHMatrix*fMatrixtransformation of local helix frame to MARS ; Double_tfPhiphi angle; Double_tfPoint[3]point after a step; Double_tfPointInit[3]initial point; Int_tfQright/left-handed (+/- 1) - ""charge""; Double_tfSZ step of the helix / 2*PI; Double_tfStepcurrent step. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHelix(); Dummy constructor. TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); Normal constructor. ~TGeoHelix(); Destructor. Double_t ComputeSafeStep(Double_t epsil = 1E-6) const; Compute safe linear step that can be made such that the error; between linear-helix extrapolation is less than EPSIL. void InitPoint(Double_t x0, Double_t y0, Double_t z0); Initialize coordinates of a point on the helix. void InitPoint(Double_t* point); Set initial point on the helix. void InitDirection(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHelix.html:7607,charge,charge,7607,root/html528/TGeoHelix.html,https://root.cern,https://root.cern/root/html528/TGeoHelix.html,3,['charge'],['charge']
Energy Efficiency,"t;  ; Bool_t IsStyleDefault () const;  check if the visibility and attributes are the default ones ;  ; Bool_t IsTopVolume () const;  True if this is the top volume of the geometry. ;  ; Bool_t IsValid () const;  ; Bool_t IsVisContainers () const;  ; virtual Bool_t IsVisible () const;  ; Bool_t IsVisibleDaughters () const;  ; Bool_t IsVisLeaves () const;  ; Bool_t IsVisOnly () const;  ; Bool_t IsXYZVoxels () const;  ; TH2F * LegoPlot (Int_t ntheta=20, Double_t themin=0., Double_t themax=180., Int_t nphi=60, Double_t phimin=0., Double_t phimax=360., Double_t rmin=0., Double_t rmax=9999999, Option_t *option="""");  Generate a lego plot fot the top volume, according to option. ;  ; void MakeCopyNodes (const TGeoVolume *other);  make a new list of nodes and copy all nodes of other volume inside ;  ; TGeoVolume * MakeReflectedVolume (const char *newname="""") const;  Make a copy of this volume which is reflected with respect to XY plane. ;  ; Bool_t OptimizeVoxels ();  Perform an extensive sampling to find which type of voxelization is most efficient. ;  ; void Paint (Option_t *option="""") override;  paint volume ;  ; void Print (Option_t *option="""") const override;  Print volume info. ;  ; void PrintNodes () const;  print nodes ;  ; void PrintVoxels () const;  Print the voxels for this volume. ;  ; void RandomPoints (Int_t npoints=1000000, Option_t *option="""");  Draw random points in the bounding box of this volume. ;  ; void RandomRays (Int_t nrays=10000, Double_t startx=0, Double_t starty=0, Double_t startz=0, const char *target_vol=nullptr, Bool_t check_norm=kFALSE);  Random raytracing method. ;  ; void Raytrace (Bool_t flag=kTRUE);  Draw this volume with current settings and perform raytracing in the pad. ;  ; void RegisterYourself (Option_t *option="""");  Register the volume and all materials/media/matrices/shapes to the manager. ;  ; void Release ();  ; void RemoveNode (TGeoNode *node);  Remove an existing daughter. ;  ; TGeoNode * ReplaceNode (TGeoNode *nodeorig, TGeoS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolumeMulti.html:16957,efficient,efficient,16957,doc/master/classTGeoVolumeMulti.html,https://root.cern,https://root.cern/doc/master/classTGeoVolumeMulti.html,1,['efficient'],['efficient']
Energy Efficiency,"t;  Return true if the checksum passed as argument is one of the checksum value produced by the older checksum calculation algorithm. ;  ; void Move (void *arenaFrom, void *arenaTo) const;  Register the fact that an object was moved from the memory location 'arenaFrom' to the memory location 'arenaTo'. ;  ; void * New (ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) const;  Return a pointer to a newly allocated object of this class. ;  ; void * New (void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; void * NewArray (Long_t nElements, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated array of objects of this class. ;  ; void * NewArray (Long_t nElements, void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; ObjectPtr NewObject (ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) const;  ; ObjectPtr NewObject (void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; ObjectPtr NewObjectArray (Long_t nElements, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated array of objects of this class. ;  ; ObjectPtr NewObjectArray (Long_t nElements, void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; virtual void PostLoadCheck ();  Do the initialization that can only be done after the CINT dictionary has been fully populated and can not be delayed efficiently. ;  ; Long_t Property () const override;  Returns the properties of the TClass as a bit field stored as a Long_t value. ;  ; Int_t ReadBuffer (TBuffer &b, void *pointer);  Function called by the Streamer functions to deserialize information from buffer b into object at p. ;  ; Int_t ReadBuffer (TBuffer &b, void *pointer, Int_t version, UInt_t start, UInt_t count);  Function called by the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:20697,allocate,allocated,20697,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,3,['allocate'],['allocated']
Energy Efficiency,"tAbsTolerance(double absTol); voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IntegratorMultiDim&); ROOT::Math::IntegratorMultiDim&operator=(const ROOT::Math::IntegratorMultiDim&). Data Members; private:. ROOT::Math::VirtualIntegratorMultiDim*fIntegratorpointer to multi-dimensional integrator base class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). IntegratorMultiDim(const Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IntegratorMultiDim.html:2434,adapt,adaptive,2434,root/html526/ROOT__Math__IntegratorMultiDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IntegratorMultiDim.html,1,['adapt'],['adaptive']
Energy Efficiency,tCgi fastcgi engine for THttpServer; TFeldmanCousins calculate the CL upper limit using the Feldman-Cousins method; TFile ROOT file; TFileCacheRead TFile cache when reading; TFileCacheWrite TFile cache when writing; TFileCollection Collection of TFileInfo objects; TFileDrawMap Draw a 2-d map of the objects in a file; TFileHandler Handles events on file descriptors; TFileInfo Describes generic file info including meta data information; TFileInfoMeta Describes TFileInfo meta data; TFileIter TFile class iterator; TFileMergeInfo ; TFileMerger File copying and merging services; TFilePrefetch File block prefetcher; TFileSet TDataSet class to read the native file system directory structure in; TFileStager ABC defining interface to a stager; TFitEditor Fit Panel interface; TFitParametersDialog Fit function parameters dialog; TFitResult Class holding the result of the fit; TFitResultPtr indirection to TFitResult; TFitter The ROOT standard fitter based on TMinuit; TFoam General purpose self-adapting Monte Carlo event generator; TFoamCell Single cell of FOAM; TFoamIntegrand n-dimensional real positive integrand of FOAM; TFoamMaxwt Controlling of the MC weight (maximum weight); TFoamSampler ; TFoamVect n-dimensional vector with dynamical allocation; TFolder Describe a folder: a list of objects and folders; TFormula ; TFormulaParamOrder ; TFractionFitter Fits MC fractions to data histogram; TFrame Pad graphics frame; TFrameEditor editor of TFrame objects; TFree Description of free segments on a file; TFriendElement A friend element of another TTree; TFumili The FUMILI Minimization package; TFumiliMinimizer Implementation of Minimizer interface using TFumili; TFunction Dictionary for global function; TFunctionParametersDialog Function parameters dialog; TFunctionTemplate Dictionary for function template; TG16ColorSelector 16 color cells; TGApplication GUI application singleton; TGButton Button widget abstract base class; TGButtonGroup Organizes TGButtons in a group; TGCanvas A can,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ClassIndex.html:71964,adapt,adapting,71964,root/html604/ClassIndex.html,https://root.cern,https://root.cern/root/html604/ClassIndex.html,1,['adapt'],['adapting']
Energy Efficiency,"tCgi fastcgi engine for THttpServer; TFeldmanCousins calculate the CL upper limit using the Feldman-Cousins method; TFile ROOT file; TFileCacheRead TFile cache when reading; TFileCacheWrite TFile cache when writing; TFileCollection Collection of TFileInfo objects; TFileDrawMap Draw a 2-d map of the objects in a file; TFileHandler Handles events on file descriptors; TFileInfo Describes generic file info including meta data information; TFileInfoMeta Describes TFileInfo meta data; TFileIter TFile class iterator; TFileMergeInfo ; TFileMerger File copying and merging services; TFilePrefetch File block prefetcher; TFileSet TDataSet class to read the native file system directory structure in; TFileStager ABC defining interface to a stager; TFitEditor Fit Panel interface; TFitParametersDialog Fit function parameters dialog; TFitResult Class holding the result of the fit; TFitResultPtr indirection to TFitResult; TFitter The ROOT standard fitter based on TMinuit; TFoam General purpose self-adapting Monte Carlo event generator; TFoamCell Single cell of FOAM; TFoamIntegrand n-dimensional real positive integrand of FOAM; TFoamMaxwt Controlling of the MC weight (maximum weight); TFoamSampler ; TFoamVect n-dimensional vector with dynamical allocation; TFolder Describe a folder: a list of objects and folders; TFormula The formula base class f(x,y,z,par); TFormulaPrimitive The primitive formula; TFractionFitter Fits MC fractions to data histogram; TFrame Pad graphics frame; TFrameEditor editor of TFrame objects; TFree Description of free segments on a file; TFriendElement A friend element of another TTree; TFumili The FUMILI Minimization package; TFumiliMinimizer Implementation of Minimizer interface using TFumili; TFunction Dictionary for global function; TFunctionParametersDialog Function parameters dialog; TFunctionTemplate Dictionary for function template; TG16ColorSelector 16 color cells; TGApplication GUI application singleton; TGButton Button widget abstract base class; TGBut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:71372,adapt,adapting,71372,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,1,['adapt'],['adapting']
Energy Efficiency,"tCheckSumDefinition TClass.h:117; TClass::kNoRange@ kNoRangeDefinition TClass.h:112; TClass::kCurrentCheckSum@ kCurrentCheckSumDefinition TClass.h:109; TClass::kNoBaseCheckSum@ kNoBaseCheckSumDefinition TClass.h:116; TClass::kReflex@ kReflexDefinition TClass.h:114; TClass::kReflexNoComment@ kReflexNoCommentDefinition TClass.h:111; TClass::kWithTypeDef@ kWithTypeDefDefinition TClass.h:113; TClass::kNoRangeCheck@ kNoRangeCheckDefinition TClass.h:115; TClass::kNoEnum@ kNoEnumDefinition TClass.h:110; TClass::Dumpvoid Dump() const overrideDump contents of object on stdout.Definition TClass.h:398; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4874; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2791; TClass::NewObjectArrayObjectPtr NewObjectArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5209; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2897; TClass::ResetCachesvoid ResetCaches()To clean out all caches.Definition TClass.cxx:4215; TClass::fVersionUsedstd::atomic< Bool_t > fVersionUsedsaved remember if fOffsetStreamer has been set.Definition TClass.h:262; TClass::ClassPropertyLong_t ClassProperty() constReturn the C++ property of this class, eg.Definition TClass.cxx:2396; TClass::SetStreamerImplvoid SetStreamerImpl()Internal routine to set fStreamerImpl based on the value of fStreamerType.Definition TClass.cxx:6215; TClass::GetSharedLibsconst char * GetSharedLibs()Get the list of shared libraries containing the code for class cls.Definition TClass.cxx:3623; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:333397,allocate,allocated,333397,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"tCheckSumDefinition TClass.h:117; TClass::kNoRange@ kNoRangeDefinition TClass.h:112; TClass::kCurrentCheckSum@ kCurrentCheckSumDefinition TClass.h:109; TClass::kNoBaseCheckSum@ kNoBaseCheckSumDefinition TClass.h:116; TClass::kReflex@ kReflexDefinition TClass.h:114; TClass::kReflexNoComment@ kReflexNoCommentDefinition TClass.h:111; TClass::kWithTypeDef@ kWithTypeDefDefinition TClass.h:113; TClass::kNoRangeCheck@ kNoRangeCheckDefinition TClass.h:115; TClass::kNoEnum@ kNoEnumDefinition TClass.h:110; TClass::Dumpvoid Dump() const overrideDump contents of object on stdout.Definition TClass.h:398; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4874; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2791; TClass::NewObjectArrayObjectPtr NewObjectArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5209; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2897; TClass::ResetCachesvoid ResetCaches()To clean out all caches.Definition TClass.cxx:4215; TClass::fVersionUsedstd::atomic< Bool_t > fVersionUsedsaved remember if fOffsetStreamer has been set.Definition TClass.h:262; TClass::GetClassSizeInt_t GetClassSize() constDefinition TClass.h:425; TClass::ClassPropertyLong_t ClassProperty() constReturn the C++ property of this class, eg.Definition TClass.cxx:2396; TClass::SetStreamerImplvoid SetStreamerImpl()Internal routine to set fStreamerImpl based on the value of fStreamerType.Definition TClass.cxx:6215; TClass::GetSharedLibsconst char * GetSharedLibs()Get the list of shared libraries containing the code for class cls.Definition TClass.cxx:3623; TClass::CalculateStreamerO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:68455,allocate,allocated,68455,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,1,['allocate'],['allocated']
Energy Efficiency,"tCheckSumDefinition TClass.h:117; TClass::kNoRange@ kNoRangeDefinition TClass.h:112; TClass::kCurrentCheckSum@ kCurrentCheckSumDefinition TClass.h:109; TClass::kNoBaseCheckSum@ kNoBaseCheckSumDefinition TClass.h:116; TClass::kReflex@ kReflexDefinition TClass.h:114; TClass::kReflexNoComment@ kReflexNoCommentDefinition TClass.h:111; TClass::kWithTypeDef@ kWithTypeDefDefinition TClass.h:113; TClass::kNoRangeCheck@ kNoRangeCheckDefinition TClass.h:115; TClass::kNoEnum@ kNoEnumDefinition TClass.h:110; TClass::Dumpvoid Dump() const overrideDump contents of object on stdout.Definition TClass.h:398; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::NewObjectArrayObjectPtr NewObjectArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5276; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::ResetCachesvoid ResetCaches()To clean out all caches.Definition TClass.cxx:4282; TClass::fVersionUsedstd::atomic< Bool_t > fVersionUsedsaved remember if fOffsetStreamer has been set.Definition TClass.h:262; TClass::ClassPropertyLong_t ClassProperty() constReturn the C++ property of this class, eg.Definition TClass.cxx:2463; TClass::SetStreamerImplvoid SetStreamerImpl()Internal routine to set fStreamerImpl based on the value of fStreamerType.Definition TClass.cxx:6282; TClass::GetSharedLibsconst char * GetSharedLibs()Get the list of shared libraries containing the code for class cls.Definition TClass.cxx:3690; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:336035,allocate,allocated,336035,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"tCheckSumDefinition TClass.h:117; TClass::kNoRange@ kNoRangeDefinition TClass.h:112; TClass::kCurrentCheckSum@ kCurrentCheckSumDefinition TClass.h:109; TClass::kNoBaseCheckSum@ kNoBaseCheckSumDefinition TClass.h:116; TClass::kReflex@ kReflexDefinition TClass.h:114; TClass::kReflexNoComment@ kReflexNoCommentDefinition TClass.h:111; TClass::kWithTypeDef@ kWithTypeDefDefinition TClass.h:113; TClass::kNoRangeCheck@ kNoRangeCheckDefinition TClass.h:115; TClass::kNoEnum@ kNoEnumDefinition TClass.h:110; TClass::Dumpvoid Dump() const overrideDump contents of object on stdout.Definition TClass.h:398; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::NewObjectArrayObjectPtr NewObjectArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5276; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::ResetCachesvoid ResetCaches()To clean out all caches.Definition TClass.cxx:4282; TClass::fVersionUsedstd::atomic< Bool_t > fVersionUsedsaved remember if fOffsetStreamer has been set.Definition TClass.h:262; TClass::GetClassSizeInt_t GetClassSize() constDefinition TClass.h:425; TClass::ClassPropertyLong_t ClassProperty() constReturn the C++ property of this class, eg.Definition TClass.cxx:2463; TClass::SetStreamerImplvoid SetStreamerImpl()Internal routine to set fStreamerImpl based on the value of fStreamerType.Definition TClass.cxx:6282; TClass::GetSharedLibsconst char * GetSharedLibs()Get the list of shared libraries containing the code for class cls.Definition TClass.cxx:3690; TClass::CalculateStreamerO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:68283,allocate,allocated,68283,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,1,['allocate'],['allocated']
Energy Efficiency,"tDecompMatrix() const; Int_tTDecompBase::Hager(Double_t& est, Int_t iter = 5); voidTObject::MakeZombie(); static Bool_tQRH(TMatrixD& q, TVectorD& diagR, TVectorD& up, TVectorD& w, Double_t tol); voidTDecompBase::ResetStatus(). Data Members; public:. enum { kWorkMax; };; enum TDecompBase::EMatrixDecompStat { kInit; kPatternSet; kValuesSet; kMatrixSet; kDecomposed; kDetermined; kCondition; kSingular; };; enum TDecompBase::[unnamed] { kWorkMax; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTDecompBase::fColLwbColumn lower bound of decomposed matrix; Double_tTDecompBase::fConditionmatrix condition number; Double_tTDecompBase::fDet1determinant mantissa; Double_tTDecompBase::fDet2determinant exponent for powers of 2; TMatrixDfQ(m x n) - orthogonal matrix; TMatrixDfR(n x n) - upper triangular matrix; Int_tTDecompBase::fRowLwbRow lower bound of decomposed matrix; Double_tTDecompBase::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1; TVectorDfUp(n) - vector with Householder up's; TVectorDfW(n) - vector with Householder beta's. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecompQRH(Int_t nrows, Int_t ncols); Constructor for (nrows x ncols) matrix. TDecompQRH(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb); Constructor for ([row_lwb..row_upb] x [col_lwb..col_upb]) matrix. TDecompQRH(const TMatrixD& m, Double_t tol = 0.0); Constructor for general matrix A . TDecompQRH(const TDecompQRH& another); Copy constructor. Bool_t Decompose(); QR decomposition of matrix a by Householder transformations,; see Golub & Loan first edition p41 & Sec 6.2.; First fR is returned in upper triang of fQ and diagR. fQ returned in; 'u-form' in lower triang of fQ and fW, the latter containing the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDecompQRH.html:7546,power,powers,7546,root/html528/TDecompQRH.html,https://root.cern,https://root.cern/root/html528/TDecompQRH.html,4,['power'],['powers']
Energy Efficiency,"tDefinition TClass.h:127; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:2968; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TInterpreter::RegisterTClassUpdatevirtual void RegisterTClassUpdate(TClass *oldcl, DictFuncPtr_t dict)=0; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:973; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:403; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:961; TPairCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClassTable_8cxx_source.html:46889,efficient,efficient,46889,doc/v632/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html,1,['efficient'],['efficient']
Energy Efficiency,"tDefinition TClass.h:127; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TInterpreter::RegisterTClassUpdatevirtual void RegisterTClassUpdate(TClass *oldcl, DictFuncPtr_t dict)=0; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPairCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClassTable_8cxx_source.html:46889,efficient,efficient,46889,doc/master/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html,1,['efficient'],['efficient']
Energy Efficiency,"tDouble_t CauchyDist(Double_t x, Double_t t=0, Double_t s=1)Computes the density of Cauchy distribution at point x by default, standard Cauchy distribution is us...Definition TMath.cxx:2175; TMath::ATanDouble_t ATan(Double_t)Returns the principal value of the arc tangent of x, expressed in radians.Definition TMath.h:640; TMath::StruveL1Double_t StruveL1(Double_t x)Modified Struve functions of order 0.Definition TMath.cxx:1970; TMath::Gnconstexpr Double_t Gn()Standard acceleration of gravity in .Definition TMath.h:174; TMath::ASinHDouble_t ASinH(Double_t)Returns the area hyperbolic sine of x.Definition TMath.cxx:67; TMath::LaplaceDistIDouble_t LaplaceDistI(Double_t x, Double_t alpha=0, Double_t beta=1)Computes the cumulative distribution function (lower tail integral) of Laplace distribution at point ...Definition TMath.cxx:2380; TMath::HashULong_t Hash(const void *txt, Int_t ntxt)Calculates hash index from any char string.Definition TMath.cxx:1408; TMath::QeUncertaintyconstexpr Double_t QeUncertainty()Elementary charge uncertainty.Definition TMath.h:346; TMath::Kconstexpr Double_t K()Boltzmann's constant in : .Definition TMath.h:247; TMath::BreitWignerDouble_t BreitWigner(Double_t x, Double_t mean=0, Double_t gamma=1)Calculates a Breit Wigner function with mean and gamma.Definition TMath.cxx:442; TMath::Sqrt2constexpr Double_t Sqrt2()Definition TMath.h:86; TMath::KUncertaintyconstexpr Double_t KUncertainty()Boltzmann's constant uncertainty.Definition TMath.h:261; TMath::Hbarcgsconstexpr Double_t Hbarcgs()Definition TMath.h:218; TMath::LandauDouble_t Landau(Double_t x, Double_t mpv=0, Double_t sigma=1, Bool_t norm=kFALSE)The LANDAU function.Definition TMath.cxx:492; TMath::VoigtDouble_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r=4)Computation of Voigt function (normalised).Definition TMath.cxx:898; TMath::StudentDouble_t Student(Double_t T, Double_t ndf)Computes density function for Student's t- distribution (the probability function (integral of densit..",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:61112,charge,charge,61112,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,1,['charge'],['charge']
Energy Efficiency,"tDrawOptions(Option_t* option, TString& plotOpt, TString& drawOpt); Sets User defined drawing options. void GetOptions(string optionType, string option); Gets User defined KDE construction options. void AssureOptions(); Sets missing construction options to default ones. void CheckOptions(Bool_t isUserDefinedKernel = kFALSE); Sets User global options. void SetKernelType(TKDE::EKernelType kern); Sets User option for the choice of kernel estimator. void SetIteration(TKDE::EIteration iter); Sets User option for fixed or adaptive iteration. void SetMirror(TKDE::EMirror mir); Sets User option for mirroring the data. void SetBinning(TKDE::EBinning ); Sets User option for binning the weights. void SetNBins(UInt_t nbins); Sets User option for number of bins. void SetUseBinsNEvents(UInt_t nEvents); Sets User option for the minimum number of events for allowing automatic binning. void SetTuneFactor(Double_t rho); Factor which can be used to tune the smoothing.; It is used as multiplicative factor for the fixed and adaptive bandwidth.; A value < 1 will reproduce better the tails but oversmooth the peak; while a factor > 1 will overestimate the tail. void SetRange(Double_t xMin, Double_t xMax); Sets minimum range value and maximum range value. void SetUseBins(); Sets User option for using binned weights. void SetMirror(); Sets the mirroring. void SetData(const Double_t* data); Sets the data events input sample or bin centres for binned option and computes basic estimators. void InitFromNewData(); re-initialize when new data have been filled in TKDE; re-compute kernel quantities and mean and sigma. void SetMirroredEvents(); Mirrors the data. void SetMean(); Computes input data's mean. void SetSigma(Double_t R); Computes input data's sigma. void SetKernel(); Sets the kernel density estimator. void SetKernelFunction(TKDE::KernelFunction_Ptr kernfunc = 0); Sets kernel estimator. void SetCanonicalBandwidths(); Sets the canonical bandwidths according to the kernel type. void SetKernelS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKDE.html:12400,adapt,adaptive,12400,root/html528/TKDE.html,https://root.cern,https://root.cern/root/html528/TKDE.html,4,['adapt'],['adaptive']
Energy Efficiency,"tDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttFill; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAtt3D; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; void SetPoints (Double_t *points) const override;  Create BRIK points. ;  ;  Protected Member Functions inherited from TShape; virtual void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections) const;  We have to set kRawSize (unless already done) to allocate buffer space before kRaw can be filled. ;  ; Int_t GetBasicColor () const;  Get basic color. ;  ; Int_t ShapeDistancetoPrimitive (Int_t numPoints, Int_t px, Int_t py);  Distance to primitive. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Float_t fDx;  ; Float_t fDy;  ; Float_t fDz;  ;  Protected Attributes inherited from TShape; TMaterial * fMaterial;  ; Int_t fNumber;  ; Int_t fVisibility;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWidth;  Line width. ;  ;  Protected Attributes inherited from TAttFill; Color_t fFillColor;  Fill area color. ;  ; Styl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBRIK.html:15507,allocate,allocate,15507,doc/master/classTBRIK.html,https://root.cern,https://root.cern/doc/master/classTBRIK.html,1,['allocate'],['allocate']
Energy Efficiency,"tDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttFill; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAtt3D; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; void SetPoints (Double_t *points) const override;  Create GTRA points. ;  ;  Protected Member Functions inherited from TShape; virtual void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections) const;  We have to set kRawSize (unless already done) to allocate buffer space before kRaw can be filled. ;  ; Int_t GetBasicColor () const;  Get basic color. ;  ; Int_t ShapeDistancetoPrimitive (Int_t numPoints, Int_t px, Int_t py);  Distance to primitive. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Float_t fAlpha1;  ; Float_t fAlpha2;  ; Float_t fBl1;  ; Float_t fBl2;  ; Float_t fH1;  ; Float_t fH2;  ; Float_t fTl1;  ; Float_t fTl2;  ; Float_t fTwist;  ;  Protected Attributes inherited from TBRIK; Float_t fDx;  ; Float_t fDy;  ; Float_t fDz;  ;  Protected Attributes inherited from TShape; TMaterial * fMaterial;  ; Int_t fNumber;  ; Int_t fVisibility;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttLine; Color",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTRA.html:18015,allocate,allocate,18015,doc/master/classTGTRA.html,https://root.cern,https://root.cern/doc/master/classTGTRA.html,1,['allocate'],['allocate']
Energy Efficiency,"tDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttFill; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAtt3D; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; void SetPoints (Double_t *points) const override;  Create PARA points. ;  ;  Protected Member Functions inherited from TShape; virtual void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections) const;  We have to set kRawSize (unless already done) to allocate buffer space before kRaw can be filled. ;  ; Int_t GetBasicColor () const;  Get basic color. ;  ; Int_t ShapeDistancetoPrimitive (Int_t numPoints, Int_t px, Int_t py);  Distance to primitive. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Float_t fAlpha;  ; Float_t fPhi;  ; Float_t fTheta;  ;  Protected Attributes inherited from TBRIK; Float_t fDx;  ; Float_t fDy;  ; Float_t fDz;  ;  Protected Attributes inherited from TShape; TMaterial * fMaterial;  ; Int_t fNumber;  ; Int_t fVisibility;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWidth;  Line width. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPARA.html:16433,allocate,allocate,16433,doc/master/classTPARA.html,https://root.cern,https://root.cern/doc/master/classTPARA.html,1,['allocate'],['allocate']
Energy Efficiency,"tDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttFill; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAtt3D; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; void SetPoints (Double_t *points) const override;  Create TRAP points. ;  ;  Protected Member Functions inherited from TShape; virtual void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections) const;  We have to set kRawSize (unless already done) to allocate buffer space before kRaw can be filled. ;  ; Int_t GetBasicColor () const;  Get basic color. ;  ; Int_t ShapeDistancetoPrimitive (Int_t numPoints, Int_t px, Int_t py);  Distance to primitive. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Float_t fAlpha1;  ; Float_t fAlpha2;  ; Float_t fBl1;  ; Float_t fBl2;  ; Float_t fH1;  ; Float_t fH2;  ; Float_t fTl1;  ; Float_t fTl2;  ;  Protected Attributes inherited from TBRIK; Float_t fDx;  ; Float_t fDy;  ; Float_t fDz;  ;  Protected Attributes inherited from TShape; TMaterial * fMaterial;  ; Int_t fNumber;  ; Int_t fVisibility;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTRAP.html:17245,allocate,allocate,17245,doc/master/classTTRAP.html,https://root.cern,https://root.cern/doc/master/classTTRAP.html,1,['allocate'],['allocate']
Energy Efficiency,"tDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttFill; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAtt3D; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; void SetPoints (Double_t *points) const override;  Create TRD1 points. ;  ;  Protected Member Functions inherited from TShape; virtual void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections) const;  We have to set kRawSize (unless already done) to allocate buffer space before kRaw can be filled. ;  ; Int_t GetBasicColor () const;  Get basic color. ;  ; Int_t ShapeDistancetoPrimitive (Int_t numPoints, Int_t px, Int_t py);  Distance to primitive. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Float_t fDx2;  ;  Protected Attributes inherited from TBRIK; Float_t fDx;  ; Float_t fDy;  ; Float_t fDz;  ;  Protected Attributes inherited from TShape; TMaterial * fMaterial;  ; Int_t fNumber;  ; Int_t fVisibility;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWidth;  Line width. ;  ;  Protected Attributes inherited f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTRD1.html:16076,allocate,allocate,16076,doc/master/classTTRD1.html,https://root.cern,https://root.cern/doc/master/classTTRD1.html,1,['allocate'],['allocate']
Energy Efficiency,"tDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttFill; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAtt3D; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; void SetPoints (Double_t *points) const override;  Create TRD2 points. ;  ;  Protected Member Functions inherited from TShape; virtual void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections) const;  We have to set kRawSize (unless already done) to allocate buffer space before kRaw can be filled. ;  ; Int_t GetBasicColor () const;  Get basic color. ;  ; Int_t ShapeDistancetoPrimitive (Int_t numPoints, Int_t px, Int_t py);  Distance to primitive. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Float_t fDx2;  ; Float_t fDy2;  ;  Protected Attributes inherited from TBRIK; Float_t fDx;  ; Float_t fDy;  ; Float_t fDz;  ;  Protected Attributes inherited from TShape; TMaterial * fMaterial;  ; Int_t fNumber;  ; Int_t fVisibility;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWidth;  Line width. ;  ;  Protected Attri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTRD2.html:16206,allocate,allocate,16206,doc/master/classTTRD2.html,https://root.cern,https://root.cern/doc/master/classTTRD2.html,1,['allocate'],['allocate']
Energy Efficiency,"tEtaPhiM4D<double>PtEtaPhiM4D<double>(); ROOT::Math::PtEtaPhiM4D<double>PtEtaPhiM4D<double>(const ROOT::Math::PtEtaPhiM4D<double>& v); ROOT::Math::PtEtaPhiM4D<double>PtEtaPhiM4D<double>(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt, ROOT::Math::PtEtaPhiM4D<double>::Scalar eta, ROOT::Math::PtEtaPhiM4D<double>::Scalar phi, ROOT::Math::PtEtaPhiM4D<double>::Scalar mass); ROOT::Math::PtEtaPhiM4D<double>::ScalarPx() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarPy() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarPz() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarR() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarRho() const; voidScale(ROOT::Math::PtEtaPhiM4D<double>::Scalar a); voidSetCoordinates(const ROOT::Math::PtEtaPhiM4D<double>::Scalar* src); voidSetCoordinates(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt, ROOT::Math::PtEtaPhiM4D<double>::Scalar eta, ROOT::Math::PtEtaPhiM4D<double>::Scalar phi, ROOT::Math::PtEtaPhiM4D<double>::Scalar mass); voidSetE(ROOT::Math::PtEtaPhiM4D<double>::Scalar energy); voidSetEta(ROOT::Math::PtEtaPhiM4D<double>::Scalar eta); voidSetM(ROOT::Math::PtEtaPhiM4D<double>::Scalar mass); voidSetPhi(ROOT::Math::PtEtaPhiM4D<double>::Scalar phi); voidSetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); voidSetPx(ROOT::Math::PtEtaPhiM4D<double>::Scalar px); voidSetPxPyPzE(ROOT::Math::PtEtaPhiM4D<double>::Scalar px, ROOT::Math::PtEtaPhiM4D<double>::Scalar py, ROOT::Math::PtEtaPhiM4D<double>::Scalar pz, ROOT::Math::PtEtaPhiM4D<double>::Scalar e); voidSetPy(ROOT::Math::PtEtaPhiM4D<double>::Scalar py); voidSetPz(ROOT::Math::PtEtaPhiM4D<double>::Scalar pz); ROOT::Math::PtEtaPhiM4D<double>::ScalarT() const; ROOT::Math::PtEtaPhiM4D<double>::Scalart() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarTheta() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarX() const; ROOT::Math::PtEtaPhiM4D<double>::Scalarx() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarY() const; ROOT::Math::PtEtaPhiM4D<double>::Scalary() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarZ() const; ROOT::Math",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_double_.html:3299,energy,energy,3299,root/html526/ROOT__Math__PtEtaPhiM4D_double_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_double_.html,5,['energy'],['energy']
Energy Efficiency,"tHelpMessage ; (; ); const. protectedvirtual . get help message text ; typical length of text line: ""|--------------------------------------------------------------|"" ; Implements TMVA::IMethod.; Definition at line 1209 of file MethodPDERS.cxx. ◆ GetMethodPDERSThreadLocal(). static MethodPDERS *& TMVA::MethodPDERS::GetMethodPDERSThreadLocal ; (; ). inlinestaticprivate . Definition at line 216 of file MethodPDERS.h. ◆ GetMvaValue(). Double_t TMVA::MethodPDERS::GetMvaValue ; (; Double_t * ; err = nullptr, . Double_t * ; errUpper = nullptr . ). virtual . init the size of a volume element using a defined fraction of the volume containing the entire events ; Implements TMVA::MethodBase.; Definition at line 370 of file MethodPDERS.cxx. ◆ GetNormalizedDistance(). Double_t TMVA::MethodPDERS::GetNormalizedDistance ; (; const TMVA::Event & ; base_event, . const BinarySearchTreeNode & ; sample_event, . Double_t * ; dim_normalization . ). protected . We use Euclidian metric here. Might not be best or most efficient. ; Definition at line 1022 of file MethodPDERS.cxx. ◆ GetRegressionValues(). const std::vector< Float_t > & TMVA::MethodPDERS::GetRegressionValues ; (; ). virtual . Reimplemented from TMVA::MethodBase.; Definition at line 390 of file MethodPDERS.cxx. ◆ GetSample(). void TMVA::MethodPDERS::GetSample ; (; const Event & ; e, . std::vector< const BinarySearchTreeNode * > & ; events, . Volume * ; volume . ). private . Definition at line 548 of file MethodPDERS.cxx. ◆ GetVolumeContentForRoot(). Double_t TMVA::MethodPDERS::GetVolumeContentForRoot ; (; Double_t ; scale). count number of events in rescaled volume ; Definition at line 537 of file MethodPDERS.cxx. ◆ HasAnalysisType(). Bool_t TMVA::MethodPDERS::HasAnalysisType ; (; Types::EAnalysisType ; type, . UInt_t ; numberClasses, . UInt_t ; numberTargets . ). virtual . PDERS can handle classification with 2 classes and regression with one or more regression-targets. ; Implements TMVA::IMethod.; Definition at line 166 of fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodPDERS.html:39184,efficient,efficient,39184,doc/master/classTMVA_1_1MethodPDERS.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodPDERS.html,1,['efficient'],['efficient']
Energy Efficiency,"tLastInt_t GetLast() constReturn last bin on the axis i.e.Definition TAxis.cxx:469; TAxis::GetXminDouble_t GetXmin() constDefinition TAxis.h:139; TAxis::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width.Definition TAxis.cxx:540; TAxis::GetFirstInt_t GetFirst() constReturn first bin on the axis i.e.Definition TAxis.cxx:458; TBackCompFitterBackward compatible implementation of TVirtualFitter.Definition TBackCompFitter.h:37; TBackCompFitter::SetMethodCallvirtual void SetMethodCall(TMethodCall *m)For using interpreted function passed by the user.Definition TBackCompFitter.h:88; TBackCompFitter::SetFCNvoid SetFCN(void(*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)) overrideOverride setFCN to use the Adapter to Minuit2 FCN interface To set the address of the minimization fu...Definition TBackCompFitter.cxx:732; TBackCompFitter::kCanDeleteLast@ kCanDeleteLastDefinition TBackCompFitter.h:53; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TF11-Dim function classDefinition TF1.h:233; TF1::GetNumbervirtual Int_t GetNumber() constDefinition TF1.h:526; TF1::GetParLimitsvirtual void GetParLimits(Int_t ipar, Double_t &parmin, Double_t &parmax) constReturn limits for parameter ipar.Definition TF1.cxx:1940; TF1::SetNDFvirtual void SetNDF(Int_t ndf)Set the number of degrees of freedom ndf should be the number of points used in a fit - the number of...Definition TF1.cxx:3419; TF1::GetParErrorvirtual Double_t GetParError(Int_t ipar) constReturn value of parameter number ipar.Definition TF1.cxx:1930; TF1::Classstatic TClass * Class(); TF1::SetChisquarevirtual void SetChisquare(Double_t chi2)Definition TF1.h:640; TF1::SetRangevirtual void SetRange(Double_t xmin, Double_t xmax)Initialize the upper and lower bounds to draw the function.Definition TF1.cxx:3528; TF1::GetNparvirtual Int_t GetNpar() constDefinition TF1.h:509; TF1::SetParE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitImpl_8cxx_source.html:52027,allocate,allocated,52027,doc/master/HFitImpl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitImpl_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"tMarker.h:40; TAttMarker::SetMarkerSizevirtual void SetMarkerSize(Size_t msize=1)Set the marker size.Definition TAttMarker.h:45; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TSpectrum::fPositionXDouble_t * fPositionX[fNPeaks] X position of peaksDefinition TSpectrum.h:28; TSpectrum::SearchHighResInt_t SearchHighRes(Double_t *source, Double_t *destVector, Int_t ssize, Double_t sigma, Double_t threshold, bool backgroundRemove, Int_t deconIterations, bool markov, Int_t averWindow)One-dimensional high-resolution peak search function.Definition TSpectrum.cxx:2119; TSpectrum::fNPeaksInt_t fNPeaksnumber of peaks foundDefinition TSpectrum.h:26; TSpectrum::GetPositionXDouble_t * GetPositionX() constDefinition TSpectrum.h:58; TSpectrum::fPositionYDouble_t * fPositionY[fNPeaks] Y position of peaksDefinition TSpectrum.h:29; . Example 16 - script SearchHR3.C:; Influence of number of iterations (3-red, 10-blue, 100- green, 1000-magenta), sigma=8, smoothing width=3.; ; void SearchHR3() {; Double_t fPositionX[100];; Double_t fPositionY[100];; Int_t fNPeaks = 0;; Int_t i,nfound,bin;; const Int_t nbins = 1024;; Double_t xmin = 0;; Double_t xmax = nbins;; Double_t a;; Double_t source[nbins], dest[nbins];; gROOT->ForceStyle();; ; TString dir = gROOT->GetTutorialDir();; TString file = dir+""/spectrum/TSpectrum.root"";; TFile *f = new TFile(file.Data());; TH1F *h = (TH1F*) f->Get(""back2"");; h->SetTitle(""Influence of # of iterations in deconvolution in peak searching"");; h->GetXaxis()->SetRange(1,nbins);; ; TH1F *d1 = new TH1F(""d1"","""",nbins,xmin,xmax);; TH1F *d2 = new TH1F(""d2"","""",nbins,xmin,xmax);; TH1F *d3 = new TH1F(""d3"","""",nbins,xmin,xmax);; TH1F *d4 = new TH1F(""d4"","""",nbins,xmin,xmax);; ; TSpectrum *s = new TSpectrum();; ; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; nfound = s->SearchHighRes(source, dest, nbins, 8, 2, kTRUE, 3, kTRUE, 3);; ; Double_t *xpeaks = s->GetPositionX();",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum.html:61949,green,green,61949,doc/master/classTSpectrum.html,https://root.cern,https://root.cern/doc/master/classTSpectrum.html,1,['green'],['green']
Energy Efficiency,"tMaxTerms).; However, since there's an infinite number of \( F_l\) to choose from, the user is asked to give the maximum power. \( P_{max,i}\), of each variable \( x_i\) to be considered in the minimization of \( S\) (TMultiDimFit::SetMaxPowers).; One way of obtaining values for the maximum power in variable \( i\), is to perform a regular fit to the dependent quantity \( D\), using a polynomial only in \( x_i\). The maximum power is \( P_{max,i}\) is then the power that does not significantly improve the one-dimensional least-square fit over \( x_i\) to \( D\) 5.; There are still a huge amount of possible choices for \( F_l\); in fact there are \(\prod_{i=1}^{N} (P_{max,i} + 1)\) possible choices. Obviously we need to limit this. To this end, the user is asked to set a power control limit, \( Q\) (TMultiDimFit::SetPowerLimit), and a function \( F_l\) is only accepted if ; \[; Q_l = \sum_{i=1}^{N} \frac{P_{li}}{P_{max,i}} < Q; \]. where \( P_{li}\) is the leading power of variable \( x_i\) in function \( F_l\) (TMultiDimFit::MakeCandidates). So the number of functions increase with \( Q\) (1, 2 is fine, 5 is way out). Gram-Schmidt Orthogonalisation; To further reduce the number of functions in the final expression, only those functions that significantly reduce \( S\) is chosen. What ‘significant’ means, is chosen by the user, and will be discussed below (see 2.3).; The functions \( F_l\) are generally not orthogonal, which means one will have to evaluate all possible \( F_l\)'s over all data-points before finding the most significant 1. We can, however, do better then that. By applying the modified Gram-Schmidt orthogonalisation algorithm [5] [3] to the functions \( F_l\), we can evaluate the contribution to the reduction of \( S\) from each function in turn, and we may delay the actual inversion of the curvature-matrix (TMultiDimFit::MakeGramSchmidt).; So we are let to consider an \( M\times L\) matrix \(\mathsf{F}\), an element of which is given by ; \[; f_{jl} = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:5366,power,power,5366,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['power'],['power']
Energy Efficiency,"tNBins(Int_t bins); virtual voidSetNuisanceParameters(const RooArgSet&); voidSetParameterPointsToTest(RooAbsData& pointsToTest); virtual voidSetParameters(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); voidSetPOIPointsToTest(RooAbsData& poiToTest); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp) const; virtual Double_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidUseAdaptiveSampling(bool flag = true). private:. voidCreateParameterPoints() const; voidCreateTestStatSampler() const. Data Members; private:. Bool_tfAdaptiveSamplingcontrols use of adaptive sampling algorithm; Double_tfAdditionalNToysFactorgive user ability to ask for more toys; RooStats::ConfidenceBelt*fConfBelt; Bool_tfCreateBeltcontrols use if ConfidenceBelt should be saved to a TFile; RooAbsData&fDatadata set; Bool_tfDoProfileConstructioninstead of full construction over nuisance parametrs, do profile; Bool_tfFluctuateDatatell ToyMCSampler to fluctuate number of entries in dataset; RooStats::ModelConfig&fModel; Int_tfNbinsnumber of samples per variable; RooAbsData*fPOIToTestvalue of POI points to perform the construction; RooAbsData*fPointsToTestpoints to perform the construction; Bool_tfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); standard constructor. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. TestStatSampler* GetTestStatSampler() const. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the paramete",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__FeldmanCousins.html:3350,adapt,adaptive,3350,root/html602/RooStats__FeldmanCousins.html,https://root.cern,https://root.cern/root/html602/RooStats__FeldmanCousins.html,2,['adapt'],['adaptive']
Energy Efficiency,"tOn(frame);; kest1.plotOn(frame);; kest2.plotOn(frame, LineStyle(kDashed), LineColor(kRed));; ; // Plot kernel estimation pdfs with regular and increased bandwidth; RooPlot *frame2 = x.frame(Title(""Adaptive kernel estimation pdf with regular, increased bandwidth""));; kest1.plotOn(frame2);; kest3.plotOn(frame2, LineColor(kMagenta));; ; // C r e a t e l o w s t a t s 2 - D d a t a s e t; // -------------------------------------------------------; ; // Construct a 2D toy pdf for sampling; RooRealVar y(""y"", ""y"", 0, 20);; RooPolynomial py(""py"", ""py"", y, RooArgList(0.01, 0.01, -0.0004));; RooProdPdf pxy(""pxy"", ""pxy"", RooArgSet(p, py));; std::unique_ptr<RooDataSet> data2{pxy.generate({x, y}, 1000)};; ; // C r e a t e 2 - D k e r n e l e s t i m a t i o n p d f; // ---------------------------------------------------------------; ; // Create 2D adaptive kernel estimation pdf with mirroring; RooNDKeysPdf kest4(""kest4"", ""kest4"", RooArgSet(x, y), *data2, ""am"");; ; // Create 2D adaptive kernel estimation pdf with mirroring and double bandwidth; RooNDKeysPdf kest5(""kest5"", ""kest5"", RooArgSet(x, y), *data2, ""am"", 2);; ; // Create a histogram of the data; TH1 *hh_data = data2->createHistogram(""hh_data"", x, Binning(10), YVar(y, Binning(10)));; ; // Create histogram of the 2d kernel estimation pdfs; TH1 *hh_pdf = kest4.createHistogram(""hh_pdf"", x, Binning(25), YVar(y, Binning(25)));; TH1 *hh_pdf2 = kest5.createHistogram(""hh_pdf2"", x, Binning(25), YVar(y, Binning(25)));; hh_pdf->SetLineColor(kBlue);; hh_pdf2->SetLineColor(kMagenta);; ; TCanvas *c = new TCanvas(""rf707_kernelestimation"", ""rf707_kernelestimation"", 800, 800);; c->Divide(2, 2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.8);; frame2->Draw();; c->cd(3);; gPad->SetLeftMargin(0.15);; hh_data->GetZaxis()->SetTitleOffset(1.4);; hh_data->Draw(""lego"");; c->cd(4);; gPad->SetLeftMargin(0.20);; hh_pdf->Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf707__kernelestimation_8C.html:2786,adapt,adaptive,2786,doc/master/rf707__kernelestimation_8C.html,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8C.html,2,['adapt'],['adaptive']
Energy Efficiency,"tSize() to get the; number of objects stored in the TMap. void Clear(Option_t* option = """"); Remove all (key,value) pairs from the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool_t DeleteEntry(TObject* key); Remove (key,value) pair with key from the map. Returns true; if the key was found and removed, false otherwise.; The key and value objects are deleted if map is the owner; of keys and values respectively. TObject * FindObject(const char* keyname) const; Check if a (key,value) pair exists with keyname as name of the key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * FindObject(const TObject* key) const; Check if a (key,value) pair exists with key as key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * GetValue(const char* keyname) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMap.html:9925,allocate,allocated,9925,root/html528/TMap.html,https://root.cern,https://root.cern/root/html528/TMap.html,6,['allocate'],['allocated']
Energy Efficiency,"tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGSpeedo(const TGWindow* p = 0, int id = -1); TGSpeedo widget constructor. TGSpeedo(const TGWindow* p, Float_t smin, Float_t smax, const char* lbl1 = """", const char* lbl2 = """", const char* dsp1 = """", const char* dsp2 = """", int id = -1); TGSpeedo widget constructor. void Build(); Build TGSpeedo widget. ~TGSpeedo(); TGSpeedo widget Destructor. TGDimension GetDefaultSize() const; Return default dimension of the widget. void Glow(TGSpeedo::EGlowColor col = kGreen); Make speedo glowing. Bool_t HandleButton(Event_t* event); Handle mouse button event. void SetOdoValue(Int_t val); Set actual value of odo meter. void SetDisplayText(const char* text1, const char* text2 = """"); Set small display text (two lines). void SetLabelText(const char* text1, const char* text2 = """"); Set main label text (two lines). void SetMinMaxScale(Float_t min, Float_t max); Set min and max scale values. void SetScaleValue(Float_t val); Set actual scale (needle position) value. void SetScaleValue(Float_t val, Int_t damping); Set actual scale (needle position) value. void StepScale(Float_t step); Increment/decrement scale (needle position) of ""step"" value. void Translate(Float_t val, Float_t angle, Int_t* x, Int_t* y); Translate distance from center and angle to xy coordinates. void DrawNeedle(); Draw needle in speedo widget. void DrawText(); Draw text in speedo widget. void DoRedraw(); Redraw speedo widget. const TGPicture * GetPicture() const; { return fBase; }. TImage * GetImage() const; { return fImage; }. Float_t GetPeakVal() const; { return fPeakVal; }. Float_t GetScaleMin() const; {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGSpeedo.html:20538,meter,meter,20538,root/html528/TGSpeedo.html,https://root.cern,https://root.cern/root/html528/TGSpeedo.html,4,['meter'],['meter']
Energy Efficiency,"tVars(const RooArgSet& vars) Only retain the listed observables in the output dataset . Cut(const char* expression) Only retain event surviving the given cut expression. . Cut(const RooFormulaVar& expr) Only retain event surviving the given cut formula. . CutRange(const char* name) Only retain events inside range with given name. Multiple CutRange arguments may be given to select multiple ranges. Note that this will also consider the variables that are not selected by SelectVars(). . EventRange(int lo, int hi) Only retain events with given sequential event numbers . Name(const char* name) Give specified name to output dataset . Title(const char* name) Give specified title to output dataset . Definition at line 399 of file RooAbsData.cxx. ◆ reduce() [5/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const RooFormulaVar & ; cutVar); const. Create a subset of the data set by applying the given cut on the data points. ; The 'cutVar' formula variable is used to select the subset of data points to be retained in the reduced data collection. ; Definition at line 485 of file RooAbsData.cxx. ◆ reduceEng(). virtual std::unique_ptr< RooAbsData > RooAbsData::reduceEng ; (; const RooArgSet & ; varSubset, . const RooFormulaVar * ; cutVar, . const char * ; cutRange = nullptr, . std::size_t ; nStart = 0, . std::size_t ; = std::numeric_limits< std::size_t >::max() . ); const. protectedpure virtual . Implemented in RooDataHist, and RooDataSet. ◆ reset(). void RooAbsData::reset ; (; ). virtual . Reimplemented in RooDataHist.; Definition at line 330 of file RooAbsData.cxx. ◆ resetBuffers(). void RooAbsData::resetBuffers ; (; ). Definition at line 2344 of file RooAbsData.cxx. ◆ resetCache(). void RooAbsData::resetCache ; (; ). protectedvirtual . Internal method – Remove cached function values. ; Definition at line 354 of file RooAbsData.cxx. ◆ rmsVar(). RooRealVar * RooAbsData::rmsVar ; (; const RooRealVar & ; var, . const char * ; cutSpec = nullptr, . const char * ; cutRange",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:64885,reduce,reduced,64885,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['reduce'],['reduced']
Energy Efficiency,"tWithPrototype ; (; const char * ; function, . const char * ; proto, . ROOT::EFunctionMatchMode ; mode = ROOT::kConversionMatch . ). Initialize the function invocation environment. ; Necessary input information: the function name and the prototype string of the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(...). This two step method is much more efficient than calling for every invocation TInterpreter::Execute(...). ; Definition at line 363 of file TMethodCall.cxx. ◆ InitWithPrototype() [2/2]. void TMethodCall::InitWithPrototype ; (; TClass * ; cl, . const char * ; method, . const char * ; proto, . Bool_t ; objectIsConst = kFALSE, . ROOT::EFunctionMatchMode ; mode = ROOT::kConversionMatch . ). Initialize the method invocation environment. ; Necessary input information: the class, method name and the prototype string of the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(object,...). This two step method is much more efficient than calling for every invocation TInterpreter::Execute(...). ; Definition at line 342 of file TMethodCall.cxx. ◆ IsA(). TClass * TMethodCall::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 128 of file TMethodCall.h. ◆ IsValid(). Bool_t TMethodCall::IsValid ; (; ); const. Return true if the method call has been properly initialized and is usable. ; Definition at line 376 of file TMethodCall.cxx. ◆ operator=(). TMethodCall & TMethodCall::operator= ; (; const TMethodCall & ; rhs). Assignment operator. ; Definition at line 107 of file TMethodCall.cxx. ◆ ResetParam(). void TMethodCall::ResetParam ; (; ). Reset parameter list. To be used before the first call the SetParam(). ; Definition at line 597 of file TMethodCall.cxx. ◆ ReturnType(). TMethodCall::EReturnType TMethodCall::ReturnType ; (; ). Returns the return type of the method. ; Either (unsigned) long, int, short and char, or float and double or anything ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMethodCall.html:26665,efficient,efficient,26665,doc/master/classTMethodCall.html,https://root.cern,https://root.cern/doc/master/classTMethodCall.html,1,['efficient'],['efficient']
Energy Efficiency,"tWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); Set of functions to iterate easily throught the collection. CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE); typedef void (*CreateIterators_t)(void *collection, void **begin_arena, void **end_arena);; begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. Next_t GetFunctionNext(Bool_t read = kTRUE); typedef void* (*CopyIterator_t)(void **dest, const void *source);; Copy the iterator source, into dest. dest should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator is of that size or less, the iterator will be constructed in place in this location (new with placement); Otherwise the iterator will be allocated via a regular new.; The actual address of the iterator is returned in both case. DeleteIterator_t GetFunctionDeleteIterator(Bool_t read = kTRUE); typedef void* (*Next_t)(void *iter, const void *end);; iter and end should be pointers to respectively an iterator to be incremented and the result of collection.end(); If the iterator has not reached the end of the collection, 'Next' increment the iterator 'iter' and return 0 if; the iterator reached the end.; If the end was not reached, 'Next' returns the address of the content pointed to by the iterator before the; incrementation ; if the collection contains pointers, 'Next' will return the value of the pointer. DeleteTwoIterators_t GetFunctionDeleteTwoIterators(Bool_t read = kTRUE); typedef void (*DeleteIterator_t)(void *iter);; typedef void (*DeleteTwoIterators_t)(void *begin, void *end);; If the size of the iterator is greater than fgIteratorArenaSize, call d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGenCollectionProxy.html:9865,allocate,allocated,9865,root/html534/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html,1,['allocate'],['allocated']
Energy Efficiency,"t[] gPad->SetLogx(1); To reset log in the z direction:; root[] gPad->SetLogz(0); If you have a divided pad, you need to set the scale on each of the sub-pads. Setting it on the containing pad does not automatically propagate to the sub-pads. Here is an example of how to set the log scale for the x-axis on a canvas with four sub-pads:; root[] TCanvas MyCanvas(""MyCanvas"",""My Canvas""); root[] MyCanvas->Divide(2,2); root[] MyCanvas->cd(1); root[] gPad->SetLogx(); root[] MyCanvas->cd(2); root[] gPad->SetLogx(); root[] MyCanvas->cd(3); root[] gPad->SetLogx(); 9.3.8 WaitPrimitive method; When the TPad::WaitPrimitive() method is called with no arguments, it will wait until a double click or any key pressed is executed in the canvas. A call to gSystem->Sleep(10) has been added in the loop to avoid consuming at all the CPU. This new option is convenient when executing a macro. By adding statements like:; canvas->WaitPrimitive();; You can monitor the progress of a running macro, stop it at convenient places with the possibility to interact with the canvas and resume the execution with a double click or a key press.; 9.3.9 Locking the Pad; You can make the TPad non-editable. Then no new objects can be added, and the existing objects and the pad can not be changed with the mouse or programmatically. By default the TPad is editable.; TPad::SetEditable(kFALSE); 9.4 Graphical Objects; In this paragraph, we describe the various simple 2D graphical objects defined in ROOT. Usually, one defines these objects with their constructor and draws them with their Draw() method. Therefore, the examples will be very brief. Most graphical objects have line and fill attributes (color, width) that will be described in “Graphical objects attributes”. If the user wants more information, the class names are given and they may refer to the online developer documentation. This is especially true for functions and methods that set and get internal values of the objects described here. By default 2D gra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:318554,monitor,monitor,318554,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['monitor'],['monitor']
Energy Efficiency,"t_reverse_iterator rend () const noexcept;  ; reverse_iterator rend () noexcept;  ; size_t size () const;  ; size_type size_in_bytes () const;  ;  Public Member Functions inherited from ROOT::Internal::VecOps::SmallVectorBase; size_t capacity () const noexcept;  ; bool empty () const;  ; void set_size (size_t N);  Set the array size to N, which the current array must have enough capacity for. ;  ; size_t size () const;  . Additional Inherited Members;  Protected Member Functions inherited from ROOT::Detail::VecOps::RVecImpl< T >;  RVecImpl (unsigned N);  ;  Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorTemplateBase< T, bool >;  SmallVectorTemplateBase (size_t Size);  ; void grow (size_t MinSize=0);  Grow the allocated memory (without initializing new elements), doubling the size of the allocated memory. ;  ;  Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorTemplateCommon< T >;  SmallVectorTemplateCommon (size_t Size);  ; void grow_pod (size_t MinSize, size_t TSize);  ; bool isSmall () const;  Return true if this is a smallvector which has not had dynamic memory allocated for it. ;  ; void resetToSmall ();  Put this vector in a state of being small. ;  ;  Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorBase;  SmallVectorBase ()=delete;  ;  SmallVectorBase (void *FirstEl, size_t TotalCapacity);  ; void grow_pod (void *FirstEl, size_t MinSize, size_t TSize);  This is an implementation of the grow() method which only works on POD-like data types and is out of line to reduce code duplication. ;  ; bool Owns () const;  If false, the RVec is in ""memory adoption"" mode, i.e. it is acting as a view on a memory buffer it does not own. ;  ;  Static Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorTemplateBase< T, bool >; static void destroy_range (T *S, T *E);  ; template<typename It1 , typename It2 > ; static void uninitialized_copy (It1 I, It1 E, It2 Dest);  Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVecN.html:7333,allocate,allocated,7333,doc/master/classROOT_1_1VecOps_1_1RVecN.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVecN.html,1,['allocate'],['allocated']
Energy Efficiency,"t_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; TCollection::GetCurrentCollectionstatic TCollection * GetCurrentCollection()Return the globally accessible collection.Definition TCollection.cxx:680; TIterDefinition TCollection.h:235. Definition at line 373 of file TCollection.h. Typedef Documentation. ◆ TRangeDynCast. template<typename T > . using TRangeDynCast = ROOT::Detail::TRangeCast<T, true>. TRangeDynCast is an adapter class that allows the typed iteration through a TCollection. ; The typical use is: for(auto bcl : TRangeDynCast<TBaseClass>( *cl->GetListOfBases() )) {; if (!bcl) continue;; ... use bcl as a TBaseClass*; }; for(auto bcl : TRangeDynCast<TBaseClass>( cl->GetListOfBases() )) {; if (!bcl) continue;; ... use bcl as a TBaseClass*; }; a#define a(i)Definition RSha256.hxx:99; ROOT::Detail::TRangeCastDefinition TCollection.h:311; TBaseClassEach class (see TClass) has a linked list of its base class(es).Definition TBaseClass.h:33; Template Parameters. TThe new type to convert to. . Definition at line 358 of file TCollection.h. Variable Documentation. ◆ gCollectionMutex. R__EXTERN TVirtualMutex* gCollectionMutex. Definition at line 45 of file TCollection.h. ◆ kIterBackward. const Bool_t kIterBackward = !kIterForward. Definition at line 43 of file TCollection.h. ◆ kIterForward. const Bool_t kIterForward = kTRUE. Definition at line 42 of file TCollection.h. corecontincTCollection.h. ROOT master - Reference Guide Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8h.html:5861,adapt,adapter,5861,doc/master/TCollection_8h.html,https://root.cern,https://root.cern/doc/master/TCollection_8h.html,1,['adapt'],['adapter']
Energy Efficiency,"t_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSparse_double_.html:18875,allocate,allocated,18875,root/html528/TMatrixTSparse_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_double_.html,1,['allocate'],['allocated']
Energy Efficiency,"t_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMatrixTSparse_double_.html:19060,allocate,allocated,19060,root/html530/TMatrixTSparse_double_.html,https://root.cern,https://root.cern/root/html530/TMatrixTSparse_double_.html,5,['allocate'],['allocated']
Energy Efficiency,"t_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSparse_float_.html:18658,allocate,allocated,18658,root/html528/TMatrixTSparse_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_float_.html,1,['allocate'],['allocated']
Energy Efficiency,"t_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMatrixTSparse_float_.html:18843,allocate,allocated,18843,root/html530/TMatrixTSparse_float_.html,https://root.cern,https://root.cern/root/html530/TMatrixTSparse_float_.html,5,['allocate'],['allocated']
Energy Efficiency,"t_t width, UInt_t height); Scale the original image.; The size of the image on the screen does not change because it is defined; by the size of the pad.; This function can be used to change the size of an image before writing; it into a file. The colors of the new pixels are interpolated.; An image created with the SetImage() functions cannot be modified with; the function SetPalette() any more after a call of this function!. void Slice(UInt_t xStart, UInt_t xEnd, UInt_t yStart, UInt_t yEnd, UInt_t toWidth, UInt_t toHeight); Another method of enlarging images where corners remain unchanged,; but middle part gets tiled. void Tile(UInt_t width, UInt_t height); Tile the original image. void Zoom(UInt_t offX, UInt_t offY, UInt_t width, UInt_t height); The area of an image displayed in a pad is defined by this function.; Note: the size on the screen is defined by the size of the pad.; The original image is not modified by this function.; If width or height is larger than the original image they are reduced to; the width and height of the image.; If the off values are too large (off + width > image width) than the off; values are decreased. For example: offX = image width - width; Note: the parameters are always relative to the original image not to the; size of an already zoomed image. void UnZoom(); Un-zoom the image to original size.; UnZoom() - performs undo for Zoom,Crop,Scale actions. void Flip(Int_t flip = 180); Flip image in place.; Flip is either 90, 180, 270, 180 is default.; This function manipulates the original image and destroys the; scaled and zoomed image which will be recreated at the next call of; the Draw function. If the image is zoomed the zoom - coordinates are; now relative to the new image.; This function cannot be used for images which were created with the; SetImage() functions, because the original pixel values would be; destroyed. void Mirror(Bool_t vert = kTRUE); Mirror image in place.; If vert is true mirror in vertical axis, horizontal other",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TASImage.html:27477,reduce,reduced,27477,root/html526/TASImage.html,https://root.cern,https://root.cern/root/html526/TASImage.html,7,['reduce'],['reduced']
Energy Efficiency,"t_t* iw, Double_t* w, Double_t* rhs, Int_t* iw2, const Int_t nblk, const Int_t latop, Int_t* icntl). Data Members; public:. enum TDecompBase::EMatrixDecompStat { kInit; kPatternSet; kValuesSet; kMatrixSet; kDecomposed; kDetermined; kCondition; kSingular; };; enum TDecompBase::[unnamed] { kWorkMax; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMatrixDSparsefAoriginal matrix; needed for the iterative solving procedure; Double_tfCntl[6]float control numbers; TArrayIfColFact; Int_tTDecompBase::fColLwbColumn lower bound of decomposed matrix; Double_tTDecompBase::fConditionmatrix condition number; Double_tTDecompBase::fDet1determinant mantissa; Double_tTDecompBase::fDet2determinant exponent for powers of 2; TArrayDfFactsize of fFact array; may be increased during the numerical factorization; Double_tfIPessimismamounts by which to increase allocated factorization space when; Int_tfIcntl[31]integer control numbers; TArrayIfIkeeppivot sequence and temporary storage information; Int_tfInfo[21]array used for communication between programs; TArrayIfIw; TArrayIfIw1; TArrayIfIw2; Int_tfMaxfrt; Int_tfNnonZeros; Int_tfNrows; Int_tfNsteps; Double_tfPrecisionprecision we demand from the linear system solver. If it isn't; Double_tfRPessimisminadequate space is detected. fIPessimism is for array ""fIw"",; TArrayIfRowFact; Int_tTDecompBase::fRowLwbRow lower bound of decomposed matrix; Double_tTDecompBase::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1; Int_tfVerbose; TArrayDfWtemporary storage for the factorization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecompSparse(); Default constructor. TDecompSparse(Int_t nRows, Int_t nr_nonZeros, Int_t verbose); Constructor for a matrix with nrows an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDecompSparse.html:10121,power,powers,10121,root/html528/TDecompSparse.html,https://root.cern,https://root.cern/root/html528/TDecompSparse.html,8,"['allocate', 'power']","['allocated', 'powers']"
Energy Efficiency,"t_t>): bin content held by a Float_t,; THnL (typedef for THnT<Long_t>): bin content held by a Long_t,; THnI (typedef for THnT<Int_t>): bin content held by an Int_t,; THnS (typedef for THnT<Short_t>): bin content held by a Short_t,; THnC (typedef for THnT<Char_t>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension; the number of bins, the minimal, and the maximal value on the dimension's; axis. A TH2F h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnF hn(""hn"", ""hn"", 2, bins, min, max);. * Filling; A THn is filled just like a regular histogram, using; THn::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram.; Storage is allocated when the first bin content is stored. * Projections; The dimensionality of a THn can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THn. See the Projection() members. To only project parts of the; histogram, call; hn->GetAxis(12)->SetRange(from_bin, to_bin);. * Conversion from other histogram classes; The static factory function THn::CreateHn() can be used to create a THn; from a TH1, TH2, TH3, THnSparse and (for copying) even from a THn. The; created THn will have compatble storage type, i.e. calling CreateHn() on; a TH2F will create a THnF. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THn(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidAddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidAddBinContent(Long64_t bin, Double_t v = 1.); virtual voidAddBinError2(Long64_t bin, Double_t e2);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THn.html:1819,reduce,reduced,1819,root/html534/THn.html,https://root.cern,https://root.cern/root/html534/THn.html,3,['reduce'],['reduced']
Energy Efficiency,"ta members are null, unless they are marked; 5255 // as preallocated with the ""->"" comment, in which case; 5256 // we default-construct an object to point at).; 5257 ; 5258 // ???BUG??? ???WHY???; 5259 // Do not register any TObject's that we create; 5260 // as a result of creating this object.; 5261 Bool_t statsave = GetObjectStat();; 5262 if(statsave) {; 5263 SetObjectStat(kFALSE);; 5264 }; 5265 ; 5266 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 5267 if (!sinfo) {; 5268 Error(""NewArray"", ""Cannot construct class '%s' version %d, no streamer info available!"", GetName(), fClassVersion);; 5269 return nullptr;; 5270 }; 5271 ; 5272 {; 5273 TClass__GetCallingNewRAII callingNew(defConstructor);; 5274 p = { sinfo->NewArray(nElements), sinfo };; 5275 }; 5276 ; 5277 // ???BUG???; 5278 // Allow TObject's to be registered again.; 5279 if(statsave) {; 5280 SetObjectStat(statsave);; 5281 }; 5282 ; 5283 } else {; 5284 Error(""NewArray"", ""This cannot happen!"");; 5285 }; 5286 ; 5287 return p;; 5288}; 5289 ; 5290////////////////////////////////////////////////////////////////////////////////; 5291/// Return a pointer to a newly allocated object of this class.; 5292/// The class must have a default constructor. For meaning of; 5293/// defConstructor, see TClass::IsCallingNew().; 5294 ; 5295void *TClass::NewArray(Long_t nElements, void *arena, ENewType defConstructor) const; 5296{; 5297 auto obj = NewObjectArray(nElements, arena, defConstructor);; 5298 if (obj.GetPtr() && obj.GetAllocator()) {; 5299 // Register the object for special handling in the destructor.; 5300 RegisterAddressInRepository(""TClass::NewArray with placement"", obj.GetPtr(), this);; 5301 }; 5302 return obj.GetPtr();; 5303}; 5304 ; 5305////////////////////////////////////////////////////////////////////////////////; 5306/// Return a pointer to a newly allocated object of this class.; 5307/// The class must have a default constructor. For meaning of; 5308/// defConstructor, see TClass::IsCallingNew().; 5309 ; 5310",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:201865,allocate,allocated,201865,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"ta members are null, unless they are marked; 5322 // as preallocated with the ""->"" comment, in which case; 5323 // we default-construct an object to point at).; 5324 ; 5325 // ???BUG??? ???WHY???; 5326 // Do not register any TObject's that we create; 5327 // as a result of creating this object.; 5328 Bool_t statsave = GetObjectStat();; 5329 if(statsave) {; 5330 SetObjectStat(kFALSE);; 5331 }; 5332 ; 5333 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 5334 if (!sinfo) {; 5335 Error(""NewArray"", ""Cannot construct class '%s' version %d, no streamer info available!"", GetName(), fClassVersion);; 5336 return nullptr;; 5337 }; 5338 ; 5339 {; 5340 TClass__GetCallingNewRAII callingNew(defConstructor);; 5341 p = { sinfo->NewArray(nElements), sinfo };; 5342 }; 5343 ; 5344 // ???BUG???; 5345 // Allow TObject's to be registered again.; 5346 if(statsave) {; 5347 SetObjectStat(statsave);; 5348 }; 5349 ; 5350 } else {; 5351 Error(""NewArray"", ""This cannot happen!"");; 5352 }; 5353 ; 5354 return p;; 5355}; 5356 ; 5357////////////////////////////////////////////////////////////////////////////////; 5358/// Return a pointer to a newly allocated object of this class.; 5359/// The class must have a default constructor. For meaning of; 5360/// defConstructor, see TClass::IsCallingNew().; 5361 ; 5362void *TClass::NewArray(Long_t nElements, void *arena, ENewType defConstructor) const; 5363{; 5364 auto obj = NewObjectArray(nElements, arena, defConstructor);; 5365 if (obj.GetPtr() && obj.GetAllocator()) {; 5366 // Register the object for special handling in the destructor.; 5367 RegisterAddressInRepository(""TClass::NewArray with placement"", obj.GetPtr(), this);; 5368 }; 5369 return obj.GetPtr();; 5370}; 5371 ; 5372////////////////////////////////////////////////////////////////////////////////; 5373/// Return a pointer to a newly allocated object of this class.; 5374/// The class must have a default constructor. For meaning of; 5375/// defConstructor, see TClass::IsCallingNew().; 5376 ; 5377",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:204616,allocate,allocated,204616,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"ta members to otuput list entries in the output list; and apply it. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE). Long64_t Finalize(TQueryResult* qr); Finalize the results of a query already processed. Bool_t SendSelector(const char* selector_file); Send the selector file(s) to master or worker nodes. void MergeOutput(Bool_t savememvalues = kFALSE); Merge objects in output the lists. void Progress(Long64_t total, Long64_t processed); Progress signal. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Progress signal. void Progress(TProofProgressInfo* pi); Progress signal. void Feedback(TList* objs); Feedback signal. void StopProcess(Bool_t abort, Int_t timeout = -1); Stop process after this event. Int_t AddOutputObject(TObject* obj); Incorporate the received object 'obj' into the output list fOutput.; The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' optimizing the memory; consumption.; Returns -1 in case of error, 1 if the object has been merged into another; one (so that its ownership has not been taken and can be deleted), and 0; otherwise. void RedirectOutput(Bool_t on = kTRUE); Control output redirection to TProof::fLogFileW. void AddOutput(TList* out); Incorporate the content of the received output list 'out' into the final; output list fOutput. The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' limiting the memory; consumption. void NotifyMemory(TObject* obj); Printout the memory record after merging object 'obj'; This record is used by the memory monitor. void SetLastMergingMsg(TObject* obj); Set the message to be notified in case of exception. Int_t Incorporate(TObject* obj, TList* out, Bool_t& merged); Incorporate object 'newobj' in the list 'outlist'.; The object is merged with an object of the same name already existing in; the list, or just added.; The boolean merged is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayerRemote.html:19872,consumption,consumption,19872,root/html534/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html534/TProofPlayerRemote.html,2,['consumption'],['consumption']
Energy Efficiency,"taUnBinData(const DataOptions &opt, const DataRange &range, unsigned int maxpoints=0, unsigned int dim=1, bool isWeighted=false)constructor from options and rangeDefinition UnBinData.h:79; ROOT::Fit::UnBinData::fWeightedbool fWeightedDefinition UnBinData.h:293; ROOT::Fit::UnBinData::Addvoid Add(double x, double y)add 2-dim coordinate data can also be used to add 1-dim data with a weightDefinition UnBinData.h:207; ROOT::Fit::UnBinData::~UnBinData~UnBinData() overridedestructor, delete pointer to internal data or external data wrapperDefinition UnBinData.h:189; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int n, const double *dataX)constructor for 1D external data (data are not copied inside)Definition UnBinData.h:91; ROOT::Fit::UnBinData::Addvoid Add(double x, double y, double z)add 3-dim coordinate data can also be used to add 2-dim data with a weightDefinition UnBinData.h:219; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int maxpoints=0, unsigned int dim=1, bool isWeighted=false)constructor from dimension of point and max number of points (to pre-allocate vector)Definition UnBinData.h:54; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int n, unsigned int dim, Iterator dataItr, bool isWeighted=false)constructor for multi-dim external data (data are not copied inside) Uses as argument an iterator of ...Definition UnBinData.h:127; ROOT::Fit::UnBinData::Addvoid Add(const double *x)add multi-dim coordinate dataDefinition UnBinData.h:230; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int maxpoints, const double *dataX, const double *dataY, const double *dataZ, const DataRange &range, bool isWeighted=false)constructor for 3D data and a range (data are copied inside according to the given range) or a 2D dat...Definition UnBinData.h:161; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int maxpoints, const double *dataX, const double *dataY, const DataRange &range, bool isWeighted=false)constructor for 2D data and a range (data are copied inside according ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/UnBinData_8h_source.html:13021,allocate,allocate,13021,doc/master/UnBinData_8h_source.html,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html,1,['allocate'],['allocate']
Energy Efficiency,"taY, const double* dataZ); ROOT::Fit::UnBinDataUnBinData(unsigned int maxpoints, const double* dataX, const double* dataY, const ROOT::Fit::DataRange& range); ROOT::Fit::UnBinDataUnBinData(unsigned int maxpoints, const double* dataX, const double* dataY, const double* dataZ, const ROOT::Fit::DataRange& range). protected:. voidSetNPoints(unsigned int n). private:. ROOT::Fit::UnBinData&operator=(const ROOT::Fit::UnBinData&); ROOT::Fit::UnBinDataUnBinData(const ROOT::Fit::UnBinData&). Data Members; private:. ROOT::Fit::DataVector*fDataVectorpointer to internal data vector (null for external data); ROOT::Fit::DataWrapper*fDataWrapperpointer to structure wrapping external data (null when data are copied in); unsigned intfDimcoordinate data dimension; unsigned intfNPointsnumer of fit points. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; explicit UnBinData(unsigned int maxpoints = 0, unsigned int dim = 1). constructor from dimension of point and max number of points (to pre-allocate vector). explicit UnBinData(const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1). constructor from range and default option. UnBinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1). constructor from options and range. UnBinData(unsigned int n, const double* dataX). constructor for 1D external data (data are not copied inside). UnBinData(unsigned int n, const double* dataX, const double* dataY). constructor for 2D external data (data are not copied inside). UnBinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ). constructor for 3D external data (data are not copied inside). UnBinData(unsigned int maxpoints, const double* dataX, const ROOT::Fit::DataRange& range). constructor for multi-dim external data (data are not copied inside); Uses as argument an iterator of a list (or vector) containing the const double * of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__UnBinData.html:3829,allocate,allocate,3829,root/html528/ROOT__Fit__UnBinData.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__UnBinData.html,2,['allocate'],['allocate']
Energy Efficiency,"taining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. Recyling TBuffer3D ; Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free to destroy this object, or recycle it for the next; object if suitable. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualViewer3D(); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualViewer3D.html:10268,efficient,efficient,10268,root/html528/TVirtualViewer3D.html,https://root.cern,https://root.cern/root/html528/TVirtualViewer3D.html,6,['efficient'],['efficient']
Energy Efficiency,tal bytes for the IMT flush baskets ; Definition at line 160 of file TTree.h. ◆ fIMTZipBytes. std::atomic<Long64_t> TTree::fIMTZipBytes. mutableprivate . ! Zip bytes for the IMT flush baskets. ; Definition at line 161 of file TTree.h. ◆ fIndex. TArrayI TTree::fIndex. protected . Index of sorted values. ; Definition at line 128 of file TTree.h. ◆ fIndexValues. TArrayD TTree::fIndexValues. protected . Sorted index values. ; Definition at line 127 of file TTree.h. ◆ fIOFeatures. TIOFeatures TTree::fIOFeatures {0}. protected . IO features to define for newly-written baskets and branches. ; Definition at line 114 of file TTree.h. ◆ fLeaves. TObjArray TTree::fLeaves. protected . Direct pointers to individual branch leaves. ; Definition at line 123 of file TTree.h. ◆ fMakeClass. Int_t TTree::fMakeClass. protected . ! not zero when processing code generated by MakeClass ; Definition at line 115 of file TTree.h. ◆ fMaxClusterRange. Int_t TTree::fMaxClusterRange. protected . ! Memory allocated for the cluster range. ; Definition at line 96 of file TTree.h. ◆ fMaxEntries. Long64_t TTree::fMaxEntries. protected . Maximum number of entries in case of circular buffers. ; Definition at line 97 of file TTree.h. ◆ fMaxEntryLoop. Long64_t TTree::fMaxEntryLoop. protected . Maximum number of entries to process. ; Definition at line 98 of file TTree.h. ◆ fMaxVirtualSize. Long64_t TTree::fMaxVirtualSize. protected . Maximum total size of buffers kept in memory. ; Definition at line 99 of file TTree.h. ◆ fNClusterRange. Int_t TTree::fNClusterRange. protected . Number of Cluster range in addition to the one defined by 'AutoFlush'. ; Definition at line 95 of file TTree.h. ◆ fNEntriesSinceSorting. UInt_t TTree::fNEntriesSinceSorting. protected . ! Number of entries processed since the last re-sorting of branches ; Definition at line 143 of file TTree.h. ◆ fNfill. Int_t TTree::fNfill. protected . ! Local for EntryLoop ; Definition at line 110 of file TTree.h. ◆ fNotify. TObject* TTree::fNotif,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:229577,allocate,allocated,229577,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['allocate'],['allocated']
Energy Efficiency,"tal::Internal::RPageSource::UnsealPage ; (; const RSealedPage & ; sealedPage, . const RColumnElementBase & ; element, . DescriptorId_t ; physicalColumnId, . RPageAllocator & ; pageAlloc . ). static . Helper for unstreaming a page. ; This is commonly used in derived, concrete page sources. The implementation currently always makes a memory copy, even if the sealed page is uncompressed and in the final memory layout. The optimization of directly mapping pages is left to the concrete page source implementations. ; Definition at line 487 of file RPageStorage.cxx. ◆ UnzipCluster(). void ROOT::Experimental::Internal::RPageSource::UnzipCluster ; (; RCluster * ; cluster). Parallel decompression and unpacking of the pages in the given cluster. ; The unzipped pages are supposed to be preloaded in a page pool attached to the source. The method is triggered by the cluster pool's unzip thread. It is an optional optimization, the method can safely do nothing. In particular, the actual implementation will only run if a task scheduler is set. In practice, a task scheduler is set if implicit multi-threading is turned on. ; Definition at line 224 of file RPageStorage.cxx. ◆ UnzipClusterImpl(). void ROOT::Experimental::Internal::RPageSource::UnzipClusterImpl ; (; RCluster * ; cluster). protectedvirtual . Definition at line 230 of file RPageStorage.cxx. Member Data Documentation. ◆ fActivePhysicalColumns. RActivePhysicalColumns ROOT::Experimental::Internal::RPageSource::fActivePhysicalColumns. protected . The active columns are implicitly defined by the model fields or views. ; Definition at line 658 of file RPageStorage.hxx. ◆ fCounters. std::unique_ptr<RCounters> ROOT::Experimental::Internal::RPageSource::fCounters. protected . Definition at line 654 of file RPageStorage.hxx. ◆ fDescriptor. RNTupleDescriptor ROOT::Experimental::Internal::RPageSource::fDescriptor. private . Definition at line 603 of file RPageStorage.hxx. ◆ fDescriptorLock. std::shared_mutex ROOT::Experimental::Interna",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html:20509,schedul,scheduler,20509,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,1,['schedul'],['scheduler']
Energy Efficiency,"tat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttFill; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAtt3D; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; virtual void MakeTableOfCoSin () const;  Make table of sine and cosine. ;  ; void SetPoints (Double_t *points) const override;  Create SPHE points. ;  ;  Protected Member Functions inherited from TShape; virtual void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections) const;  We have to set kRawSize (unless already done) to allocate buffer space before kRaw can be filled. ;  ; Int_t GetBasicColor () const;  Get basic color. ;  ; Int_t ShapeDistancetoPrimitive (Int_t numPoints, Int_t px, Int_t py);  Distance to primitive. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Float_t faX;  ; Float_t faY;  ; Float_t faZ;  ; Float_t fPhimax;  ; Float_t fPhimin;  ; Float_t fRmax;  ; Float_t fRmin;  ; Float_t fThemax;  ; Float_t fThemin;  ;  Protected Attributes inherited from TShape; TMaterial * fMaterial;  ; Int_t fNumber;  ; Int_t fVisibility;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSPHE.html:16086,allocate,allocate,16086,doc/master/classTSPHE.html,https://root.cern,https://root.cern/doc/master/classTSPHE.html,1,['allocate'],['allocate']
Energy Efficiency,"tat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EGridJobStatus { kUNKNOWN; kWAITING; kRUNNING; kABORTED; kFAIL; kDONE; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TGridJobStatus(); { }. EGridJobStatus GetStatus() const; These functions reduces the possible job states to the subset given above; in EGridJobStatus, for detailed status information query the specific; implementation. » Author: Jan Fiete Grosse-Oetringhaus 06/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TGridJobStatus.h 23091 2008-04-09 15:04:27Z rdm $ » Last generated: 2010-09-23 20:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGridJobStatus.html:5822,reduce,reduces,5822,root/html528/TGridJobStatus.html,https://root.cern,https://root.cern/root/html528/TGridJobStatus.html,1,['reduce'],['reduces']
Energy Efficiency,"tat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EGridJobStatus { kUNKNOWN; kWAITING; kRUNNING; kABORTED; kFAIL; kDONE; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TGridJobStatus(); { }. EGridJobStatus GetStatus() const; These functions reduces the possible job states to the subset given above; in EGridJobStatus, for detailed status information query the specific; implementation. » Author: Jan Fiete Grosse-Oetringhaus 06/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TGridJobStatus.h 23091 2008-04-09 15:04:27Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGridJobStatus.html:5891,reduce,reduces,5891,root/html530/TGridJobStatus.html,https://root.cern,https://root.cern/root/html530/TGridJobStatus.html,1,['reduce'],['reduces']
Energy Efficiency,"tat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EGridJobStatus { kUNKNOWN; kWAITING; kRUNNING; kABORTED; kFAIL; kDONE; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TGridJobStatus(); { }. EGridJobStatus GetStatus() const; These functions reduces the possible job states to the subset given above; in EGridJobStatus, for detailed status information query the specific; implementation. » Author: Jan Fiete Grosse-Oetringhaus 06/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TGridJobStatus.h 23091 2008-04-09 15:04:27Z rdm $ » Last generated: 2011-11-03 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGridJobStatus.html:5891,reduce,reduces,5891,root/html532/TGridJobStatus.html,https://root.cern,https://root.cern/root/html532/TGridJobStatus.html,1,['reduce'],['reduces']
Energy Efficiency,"tatic FreeHookFun_tfgFreeHookfunction called on free; static void*fgFreeHookDatadata used by this function; static Bool_tfgHasCustomNewDeletetrue if using ROOT's new/delete; static size_tfgMaxBlockSizelargest block allocated; static ReAllocCFun_tfgReAllocCHookcustom ReAlloc with length check; static ReAllocFun_tfgReAllocHookcustom ReAlloc; static const UInt_tkObjectAllocMemValue. Class Charts. Inheritance Chart:. TStorage. Function documentation; void EnterStat(size_t size, void* p); Register a memory allocation operation. If desired one can trap an; allocation of a certain size in case one tries to find a memory; leak of that particular size. This function is only called via; the ROOT custom new operators. void RemoveStat(void* p); Register a memory free operation. This function is only called via; the custom ROOT delete operator. void * Alloc(size_t size); Allocate a block of memory, that later can be resized using; TStorage::ReAlloc(). void Dealloc(void* ptr); De-allocate block of memory, that was allocated via TStorage::Alloc(). void * ReAlloc(void* vp, size_t size); Reallocate (i.e. resize) block of memory. Don't use if size is larger; than old size, use ReAlloc(void *, size_t, size_t) instead. void * ReAlloc(void* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) block of memory. Checks if current size is; equal to oldsize. If not memory was overwritten. char * ReAllocChar(char* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of chars. Size and oldsize are; in number of chars. Int_t * ReAllocInt(Int_t* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of integers. Size and oldsize are; number of integers (not number of bytes). void * ObjectAlloc(size_t size); Used to allocate a TObject on the heap (via TObject::operator new()).; Directly after this routine one can call (in the TObject ctor); TStorage::FilledByObjectAlloc() to find out if the just created object is on; the heap. This technique is necessary as there is on",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TStorage.html:3669,allocate,allocate,3669,root/html604/TStorage.html,https://root.cern,https://root.cern/root/html604/TStorage.html,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"tatic FreeHookFun_tfgFreeHookfunction called on free; static void*fgFreeHookDatadata used by this function; static Bool_tfgHasCustomNewDeletetrue if using ROOT's new/delete; static size_tfgMaxBlockSizelargest block allocated; static ReAllocCFun_tfgReAllocCHookcustom ReAlloc with length check; static ReAllocFun_tfgReAllocHookcustom ReAlloc; static const UInt_tkObjectAllocMemValue. Class Charts. Inheritance Chart:. TStorage. Function documentation; void EnterStat(size_t size, void* p); Register a memory allocation operation. If desired one can trap an; allocation of a certain size in case one tries to find a memory; leak of that particular size. This function is only called via; the ROOT custom new operators. void RemoveStat(void* p); Register a memory free operation. This function is only called via; the custom ROOT delete operator. void * Alloc(size_t size); Allocate a block of memory, that later can be resized using; TStorage::ReAlloc(). void Dealloc(void* ptr); De-allocate block of memory, that was allocated via TStorage::Alloc(). void * ReAlloc(void* vp, size_t size); Reallocate (i.e. resize) block of memory. Don't use if size is larger; than old size, use ReAlloc(void *, size_t, size_t) instead. void * ReAlloc(void* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) block of memory. Checks if current size is; equal to oldsize. If not memory was overwritten. char * ReAllocChar(char* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of chars. Size and oldsize are; in number of chars. Int_t * ReAllocInt(Int_t* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of integers. Size and oldsize are; number of integers (not number of bytes). void * ObjectAlloc(size_t size); Used to allocate a TObject on the heap (via TObject::operator new()).; Directly after this routine one can call (in the TObject ctor); TStorage::FilledByObjectAlloc() to find out if the just created object is on; the heap. void * ObjectAlloc(size_t size, void* vp);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStorage.html:3669,allocate,allocate,3669,root/html602/TStorage.html,https://root.cern,https://root.cern/root/html602/TStorage.html,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"tatic TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAtt3D; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; void SetPoints (Double_t *points) const override;  Create CONE points. ;  ;  Protected Member Functions inherited from TTUBE;  TTUBE (const TTUBE &);  Table of cos(fPhi1) .... cos(fPhil+fDphi1) ;  ; virtual void MakeTableOfCoSin () const;  Make table of sine and cosine. ;  ; TTUBE & operator= (const TTUBE &);  assignment operator ;  ; void SetPoints (Double_t *points) const override;  Create TUBE points. ;  ; virtual void SetSegsAndPols (TBuffer3D &buffer) const;  Set segments and polygons. ;  ;  Protected Member Functions inherited from TShape; virtual void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections) const;  We have to set kRawSize (unless already done) to allocate buffer space before kRaw can be filled. ;  ; Int_t GetBasicColor () const;  Get basic color. ;  ; Int_t ShapeDistancetoPrimitive (Int_t numPoints, Int_t px, Int_t py);  Distance to primitive. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Float_t fRmax2;  ; Float_t fRmin2;  ;  Protected Attributes inherited from TTUBE; Float_t fAspectRatio;  ; Double_t * fCoTab;  Table of sin(fPhi1) .... sin(fPhil+fDphi1) ;  ; Float_t fDz;  ; Int_t fNdiv;  ; Float_t fRmax;  ; Float_t fRmin;  ; Double_t * fSiTab;  ;  Protected Attributes inherited from TShape; TMaterial * fMaterial;  ; Int_t fNumber;  ; Int_t fVisibility;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCONE.html:17215,allocate,allocate,17215,doc/master/classTCONE.html,https://root.cern,https://root.cern/doc/master/classTCONE.html,1,['allocate'],['allocate']
Energy Efficiency,"tatic bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooMultiVarGaussian.h>. Inheritance diagram for RooMultiVarGaussian:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooMultiVarGaussian() [1/6]. RooMultiVarGaussian::RooMultiVarGaussian ; (; ). inline . Definition at line 34 of file RooMultiVarGaussian.h. ◆ RooMultiVarGaussian() [2/6]. RooMultiVarGaussian::RooMultiVarGaussian ; (; const char * ; name, . const char * ; title, . const RooArgList & ; xvec, . const RooArgList & ; mu, . const TMatrixDBase & ; covMatrix . ). Definition at line 44 of file RooMultiVarGaussian.cxx. ◆ RooMultiVarGaussian() [3/6]. RooMultiVarGaussian::RooMultiVarGaussian ; (; const char * ; name, . const char * ; title, . const RooArgList & ; xvec, . const RooFitResult & ; fr, . bool ; reduceToConditional = true . ). Definition at line 77 of file RooMultiVarGaussian.cxx. ◆ RooMultiVarGaussian() [4/6]. RooMultiVarGaussian::RooMultiVarGaussian ; (; const char * ; name, . const char * ; title, . const RooArgList & ; xvec, . const TVectorD & ; mu, . const TMatrixDBase & ; covMatrix . ). Definition at line 136 of file RooMultiVarGaussian.cxx. ◆ RooMultiVarGaussian() [5/6]. RooMultiVarGaussian::RooMultiVarGaussian ; (; const char * ; name, . const char * ; title, . const RooArgList & ; xvec, . const TMatrixDBase & ; covMatrix . ). Definition at line 144 of file RooMultiVarGaussian.cxx. ◆ RooMultiVarGaussian() [6/6]. RooMultiVarGaussian::RooMultiVarGaussian ; (; const RooMultiVarGaussian & ; other, . const char * ; name = nullptr . ). Definition at line 153 of file RooMultiVarGaussian.cxx. Member Function Documentation. ◆ anaIntData(). RooMultiVarGaussian::AnaIntData & RooMultiVarGaussian::anaIntData ; (; Int_t ; code); const. protected . Check if cache entry was previously created. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMultiVarGaussian.html:75328,reduce,reduceToConditional,75328,doc/master/classRooMultiVarGaussian.html,https://root.cern,https://root.cern/doc/master/classRooMultiVarGaussian.html,1,['reduce'],['reduceToConditional']
Energy Efficiency,"tatic const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TMultiDimFit * Instance ();  Return the static instance. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; virtual Double_t EvalControl (const Int_t *powers) const;  PRIVATE METHOD: Calculate the control parameter from the passed powers. ;  ; virtual Double_t EvalFactor (Int_t p, Double_t x) const;  PRIVATE METHOD: Evaluate function with power p at variable value x. ;  ; virtual void MakeCandidates ();  PRIVATE METHOD: Create list of candidate functions for the parameterisation. ;  ; virtual void MakeCoefficientErrors ();  PRIVATE METHOD: Compute the errors on the coefficients. ;  ; virtual void MakeCoefficients ();  PRIVATE METHOD: Invert the model matrix B, and compute final coefficients. ;  ; virtual void MakeCorrelation ();  PRIVATE METHOD: Compute the correlation matrix. ;  ; virtual Double_t MakeGramSchmidt (Int_t function);  PRIVATE METHOD: Make Gram-Schmidt orthogonalisation. ;  ; virtual void MakeNormalized ();  PRIVATE METHOD: Normalize data to the interval [-1;1]. ;  ; virtual void MakeParameterization ();  PRIVATE METHOD: Find the parameterization over the training sample. ;  ; virtual void MakeRealCode (const char *filename, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:33101,power,powers,33101,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,2,['power'],['powers']
Energy Efficiency,"tatic constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttBBox2D; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttText; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; TLegend & operator= (const TLegend &);  Assignment operator. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Float_t fColumnSeparation;  Separation between columns, as a fraction of The space allowed to one column. ;  ; Float_t fEntrySeparation;  Separation between entries, as a fraction of The space allocated to one entry. ;  ; Float_t fMargin;  Fraction of total width used for symbol. ;  ; Int_t fNColumns;  Number of columns in the legend. ;  ; TList * fPrimitives {nullptr};  List of TLegendEntries. ;  ;  Protected Attributes inherited from TPave; Int_t fBorderSize;  window box bordersize in pixels ;  ; Double_t fCornerRadius;  Corner radius in case of option arc. ;  ; Int_t fInit;  (=0 if transformation to NDC not yet done) ;  ; TString fName;  Pave name. ;  ; TString fOption;  Pave style. ;  ; Int_t fShadowColor;  Color of the pave's shadow. ;  ; Double_t fX1NDC;  X1 point in NDC coordinates. ;  ; Double_t fX2NDC;  X2 point in NDC coordinates. ;  ; Double_t fY1NDC;  Y1 point in NDC coordinates. ;  ; Double_t fY2NDC;  Y2 point in NDC coordinates. ;  ;  Protected Attributes inherited from TBox; Bool_t fResizing;  ! True if box is being resized ;  ; Double_t fX1;  X of 1st point. ;  ; Double_t fX2;  X of 2nd point. ;  ; Double_t fY1;  Y of 1st point",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLegend.html:31325,allocate,allocated,31325,doc/master/classTLegend.html,https://root.cern,https://root.cern/doc/master/classTLegend.html,1,['allocate'],['allocated']
Energy Efficiency,"tation(). void TMVA::DNN::ClassificationSettings::setResultComputation ; (; std::string ; _fileNameNetConfig, . std::string ; _fileNameResult, . std::vector< Pattern > * ; _resultPatternContainer . ). preparation for monitoring output ; Definition at line 520 of file NeuralNet.cxx. ◆ setWeightSums(). void TMVA::DNN::ClassificationSettings::setWeightSums ; (; double ; sumOfSigWeights, . double ; sumOfBkgWeights . ). set the weight sums to be scaled to (preparations for monitoring output) ; Definition at line 512 of file NeuralNet.cxx. ◆ startTestCycle(). void TMVA::DNN::ClassificationSettings::startTestCycle ; (; ). virtual . action to be done when the test cycle is started (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 316 of file NeuralNet.cxx. ◆ startTrainCycle(). void TMVA::DNN::ClassificationSettings::startTrainCycle ; (; ). virtual . action to be done when the training cycle is started (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 281 of file NeuralNet.cxx. ◆ testIteration(). void TMVA::DNN::ClassificationSettings::testIteration ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented from TMVA::DNN::Settings.; Definition at line 930 of file NeuralNet.h. ◆ testSample(). void TMVA::DNN::ClassificationSettings::testSample ; (; double ; error, . double ; output, . double ; target, . double ; weight . ). virtual . action to be done after the computation of a test sample (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 304 of file NeuralNet.cxx. Member Data Documentation. ◆ m_ams. std::vector<double> TMVA::DNN::ClassificationSettings::m_ams. Definition at line 1000 of file NeuralNet.h. ◆ m_cutValue. double TMVA::DNN::ClassificationSettings::m_cutValue. Definition at line 1008 of file NeuralNet.h. ◆ m_fileNameNetConfig. std::string TMVA::DNN::ClassificationSettings::m_fileNameNetConfig. Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html:8851,monitor,monitoring,8851,doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,1,['monitor'],['monitoring']
Energy Efficiency,"tation; void ls(Option_t* option) const. const char * GetName() const; Return name of this particle via Pythia. TMCParticle(); {}. TMCParticle(Int_t kS, Int_t kF, Int_t parent, Int_t firstchild, Int_t lastchild, Float_t px, Float_t py, Float_t pz, Float_t energy, Float_t mass, Float_t vx, Float_t vy, Float_t vz, Float_t time, Float_t lifetime); { }. virtual ~TMCParticle(); { }. Int_t GetKS() const; {return fKS;}. Int_t GetKF() const; {return fKF;}. Int_t GetParent() const; {return fParent;}. Int_t GetFirstChild() const; {return fFirstChild;}. Int_t GetLastChild() const; {return fLastChild;}. Float_t GetPx() const; {return fPx;}. Float_t GetPy() const; {return fPy;}. Float_t GetPz() const; {return fPz;}. Float_t GetEnergy() const; {return fEnergy;}. Float_t GetMass() const; {return fMass;}. Float_t GetVx() const; {return fVx;}. Float_t GetVy() const; {return fVy;}. Float_t GetVz() const; {return fVz;}. Float_t GetTime() const; {return fTime;}. Float_t GetLifetime() const; {return fLifetime;}. void SetKS(Int_t kS); {fKS=kS;}. void SetKF(Int_t kF); {fKF=kF;}. void SetParent(Int_t parent); {fParent=parent;}. void SetFirstChild(Int_t first); {fFirstChild=first;}. void SetLastChild(Int_t last); {fLastChild=last;}. void SetPx(Float_t px); {fPx=px;}. void SetPy(Float_t py); {fPy=py;}. void SetPz(Float_t pz); {fPz=pz;}. void SetEnergy(Float_t energy); {fEnergy=energy;}. void SetMass(Float_t mass); {fMass=mass;}. void SetVx(Float_t vx); {fVx=vx;}. void SetVy(Float_t vy); {fVy=vy;}. void SetVz(Float_t vz); {fVz=vz;}. void SetTime(Float_t time); {fTime=time;}. void SetLifetime(Float_t lifetime); {fLifetime=lifetime;}. » Author: Piotr Golonka 17/09/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/pythia6:$Id: TMCParticle.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMCParticle.html:9008,energy,energy,9008,root/html528/TMCParticle.html,https://root.cern,https://root.cern/root/html528/TMCParticle.html,2,['energy'],['energy']
Energy Efficiency,"tation; void ls(Option_t* option) const. const char * GetName() const; Return name of this particle via Pythia. TMCParticle(); {}. TMCParticle(Int_t kS, Int_t kF, Int_t parent, Int_t firstchild, Int_t lastchild, Float_t px, Float_t py, Float_t pz, Float_t energy, Float_t mass, Float_t vx, Float_t vy, Float_t vz, Float_t time, Float_t lifetime); { }. virtual ~TMCParticle(); { }. Int_t GetKS() const; {return fKS;}. Int_t GetKF() const; {return fKF;}. Int_t GetParent() const; {return fParent;}. Int_t GetFirstChild() const; {return fFirstChild;}. Int_t GetLastChild() const; {return fLastChild;}. Float_t GetPx() const; {return fPx;}. Float_t GetPy() const; {return fPy;}. Float_t GetPz() const; {return fPz;}. Float_t GetEnergy() const; {return fEnergy;}. Float_t GetMass() const; {return fMass;}. Float_t GetVx() const; {return fVx;}. Float_t GetVy() const; {return fVy;}. Float_t GetVz() const; {return fVz;}. Float_t GetTime() const; {return fTime;}. Float_t GetLifetime() const; {return fLifetime;}. void SetKS(Int_t kS); {fKS=kS;}. void SetKF(Int_t kF); {fKF=kF;}. void SetParent(Int_t parent); {fParent=parent;}. void SetFirstChild(Int_t first); {fFirstChild=first;}. void SetLastChild(Int_t last); {fLastChild=last;}. void SetPx(Float_t px); {fPx=px;}. void SetPy(Float_t py); {fPy=py;}. void SetPz(Float_t pz); {fPz=pz;}. void SetEnergy(Float_t energy); {fEnergy=energy;}. void SetMass(Float_t mass); {fMass=mass;}. void SetVx(Float_t vx); {fVx=vx;}. void SetVy(Float_t vy); {fVy=vy;}. void SetVz(Float_t vz); {fVz=vz;}. void SetTime(Float_t time); {fTime=time;}. void SetLifetime(Float_t lifetime); {fLifetime=lifetime;}. » Author: Piotr Golonka 17/09/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/pythia6:$Id: TMCParticle.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMCParticle.html:9077,energy,energy,9077,root/html530/TMCParticle.html,https://root.cern,https://root.cern/root/html530/TMCParticle.html,2,['energy'],['energy']
Energy Efficiency,"tation; void ls(Option_t* option) const. const char * GetName() const; Return name of this particle via Pythia. TMCParticle(); {}. TMCParticle(Int_t kS, Int_t kF, Int_t parent, Int_t firstchild, Int_t lastchild, Float_t px, Float_t py, Float_t pz, Float_t energy, Float_t mass, Float_t vx, Float_t vy, Float_t vz, Float_t time, Float_t lifetime); { }. virtual ~TMCParticle(); { }. Int_t GetKS() const; {return fKS;}. Int_t GetKF() const; {return fKF;}. Int_t GetParent() const; {return fParent;}. Int_t GetFirstChild() const; {return fFirstChild;}. Int_t GetLastChild() const; {return fLastChild;}. Float_t GetPx() const; {return fPx;}. Float_t GetPy() const; {return fPy;}. Float_t GetPz() const; {return fPz;}. Float_t GetEnergy() const; {return fEnergy;}. Float_t GetMass() const; {return fMass;}. Float_t GetVx() const; {return fVx;}. Float_t GetVy() const; {return fVy;}. Float_t GetVz() const; {return fVz;}. Float_t GetTime() const; {return fTime;}. Float_t GetLifetime() const; {return fLifetime;}. void SetKS(Int_t kS); {fKS=kS;}. void SetKF(Int_t kF); {fKF=kF;}. void SetParent(Int_t parent); {fParent=parent;}. void SetFirstChild(Int_t first); {fFirstChild=first;}. void SetLastChild(Int_t last); {fLastChild=last;}. void SetPx(Float_t px); {fPx=px;}. void SetPy(Float_t py); {fPy=py;}. void SetPz(Float_t pz); {fPz=pz;}. void SetEnergy(Float_t energy); {fEnergy=energy;}. void SetMass(Float_t mass); {fMass=mass;}. void SetVx(Float_t vx); {fVx=vx;}. void SetVy(Float_t vy); {fVy=vy;}. void SetVz(Float_t vz); {fVz=vz;}. void SetTime(Float_t time); {fTime=time;}. void SetLifetime(Float_t lifetime); {fLifetime=lifetime;}. » Author: Piotr Golonka 17/09/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/pythia6:$Id: TMCParticle.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMCParticle.html:9077,energy,energy,9077,root/html532/TMCParticle.html,https://root.cern,https://root.cern/root/html532/TMCParticle.html,2,['energy'],['energy']
Energy Efficiency,"tats::HypoTestInverter::ECalculatorType type = kFrequentist, double size = 0.050000000000000003); RooStats::IntervalCalculatorRooStats::IntervalCalculator::IntervalCalculator(); RooStats::IntervalCalculatorRooStats::IntervalCalculator::IntervalCalculator(const RooStats::IntervalCalculator&); virtual TClass*IsA() const; RooStats::SamplingDistribution*RebuildDistributions(bool isUpper = true, int nToys = 100, TList* clsDist = 0, TList* clsbDist = 0, TList* clbDist = 0, const char* outputfile = ""HypoTestInverterRebuiltDist.root""); boolRunFixedScan(int nBins, double xMin, double xMax, bool scanLog = false) const; boolRunLimit(double& limit, double& limitErr, double absTol = 0, double relTol = 0, const double* hint = 0) const; boolRunOnePoint(double thisX, bool adaptive = false, double clTarget = -1) const; voidSetAutoScan(); static voidSetCloseProof(Bool_t flag); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData&); voidSetFixedScan(int nBins, double xMin = 1, double xMax = -1, bool scanLog = false); voidSetMaximumToys(int ntoys); virtual voidSetModel(const RooStats::ModelConfig&); voidSetNumErr(double err); virtual voidSetTestSize(Double_t size); boolSetTestStatistic(RooStats::TestStatistic& stat); voidSetVerbose(int level = 1); virtual voidShowMembers(TMemberInspector& insp) const; virtual Double_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidUseCLs(bool on = true). protected:. static voidCheckInputModels(const RooStats::HypoTestCalculatorGeneric& hc, const RooRealVar& scanVar); voidCreateResults() const; RooStats::HypoTestResult*Eval(RooStats::HypoTestCalculatorGeneric& hc, bool adaptive, double clsTarget) const; static RooRealVar*GetVariableToScan(const RooStats::HypoTestCalculatorGeneric& hc); RooStats::HypoTestInverterHypoTestInverter(const RooStats::HypoTestInverter& rhs); RooStats::HypoTestInverter&operator=(const RooStats::HypoTestInverter& rhs). Data Members; public:. stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HypoTestInverter.html:3588,adapt,adaptive,3588,root/html602/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html602/RooStats__HypoTestInverter.html,2,['adapt'],['adaptive']
Energy Efficiency,"tatus of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Types; typedef RooArgList * pRooArgList;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; RooAbsGenContext * genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false) const override;  Return specialized context to efficiently generate toy events from RooAddModels. ;  ; void getCompIntList (const RooArgSet *nset, const RooArgSet *iset, pRooArgList &compIntList, Int_t &code, const char *isetRangeName) const;  Check if this configuration was created before. ;  ; AddCacheElem * getProjCache (const RooArgSet *nset, const RooArgSet *iset=nullptr) const;  Retrieve cache element with for calculation of p.d.f value with normalization set nset and integrated over iset in range 'rangeName'. ;  ; void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false) override;  Interface function used by test statistics to freeze choice of observables for interpretation of fraction coefficients. ;  ; void selectNormalizationRange (const char *rangeName=nullptr, bool force=false) override;  Interface function used by test statistics to freeze choice of range for interpretation of fraction coefficients. ;  ; void update",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:62383,efficient,efficiently,62383,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['efficient'],['efficiently']
Energy Efficiency,"tch a single event.; 1092 ; 1093void TUnixSystem::DispatchOneEvent(Bool_t pendingOnly); 1094{; 1095 Bool_t pollOnce = pendingOnly;; 1096 ; 1097 while (1) {; 1098 // first handle any X11 events; 1099 if (gXDisplay && gXDisplay->Notify()) {; 1100 if (fReadready->IsSet(gXDisplay->GetFd())) {; 1101 fReadready->Clr(gXDisplay->GetFd());; 1102 fNfd--;; 1103 }; 1104 if (!pendingOnly) return;; 1105 }; 1106 ; 1107 // check for file descriptors ready for reading/writing; 1108 if (fNfd > 0 && fFileHandler && fFileHandler->GetSize() > 0); 1109 if (CheckDescriptors()); 1110 if (!pendingOnly) return;; 1111 fNfd = 0;; 1112 fReadready->Zero();; 1113 fWriteready->Zero();; 1114 ; 1115 if (pendingOnly && !pollOnce); 1116 return;; 1117 ; 1118 // check synchronous signals; 1119 if (fSigcnt > 0 && fSignalHandler->GetSize() > 0); 1120 if (CheckSignals(kTRUE)); 1121 if (!pendingOnly) return;; 1122 fSigcnt = 0;; 1123 fSignals->Zero();; 1124 ; 1125 // check synchronous timers; 1126 Long_t nextto;; 1127 if (fTimers && fTimers->GetSize() > 0); 1128 if (DispatchTimers(kTRUE)) {; 1129 // prevent timers from blocking file descriptor monitoring; 1130 nextto = NextTimeOut(kTRUE);; 1131 if (nextto > kItimerResolution || nextto == -1); 1132 return;; 1133 }; 1134 ; 1135 // if in pendingOnly mode poll once file descriptor activity; 1136 nextto = NextTimeOut(kTRUE);; 1137 if (pendingOnly) {; 1138 if (fFileHandler && fFileHandler->GetSize() == 0); 1139 return;; 1140 nextto = 0;; 1141 pollOnce = kFALSE;; 1142 }; 1143 ; 1144 // nothing ready, so setup select call; 1145 *fReadready = *fReadmask;; 1146 *fWriteready = *fWritemask;; 1147 ; 1148 int mxfd = TMath::Max(fMaxrfd, fMaxwfd);; 1149 mxfd++;; 1150 ; 1151 // if nothing to select (socket or timer) return; 1152 if (mxfd == 0 && nextto == -1); 1153 return;; 1154 ; 1155 fNfd = UnixSelect(mxfd, fReadready, fWriteready, nextto);; 1156 if (fNfd < 0 && fNfd != -2) {; 1157 int fd, rc;; 1158 TFdSet t;; 1159 for (fd = 0; fd < mxfd; fd++) {; 1160 t.Set(fd);; 1161 if (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:34727,monitor,monitoring,34727,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['monitor'],['monitoring']
Energy Efficiency,"td::endl;}, {""myIntColumn""});; 1638 /// ~~~; 1639 // clang-format on; 1640 template <typename F>; 1641 void ForeachSlot(F f, const ColumnNames_t &columns = {}); 1642 {; 1643 using ColTypes_t = TypeTraits::RemoveFirstParameter_t<typename TTraits::CallableTraits<F>::arg_types>;; 1644 constexpr auto nColumns = ColTypes_t::list_size;; 1645 ; 1646 const auto validColumnNames = GetValidatedColumnNames(nColumns, columns);; 1647 CheckAndFillDSColumns(validColumnNames, ColTypes_t());; 1648 ; 1649 using Helper_t = RDFInternal::ForeachSlotHelper<F>;; 1650 using Action_t = RDFInternal::RAction<Helper_t, Proxied>;; 1651 ; 1652 auto action = std::make_unique<Action_t>(Helper_t(std::move(f)), validColumnNames, fProxiedPtr, fColRegister);; 1653 ; 1654 fLoopManager->Run();; 1655 }; 1656 ; 1657 // clang-format off; 1658 ////////////////////////////////////////////////////////////////////////////; 1659 /// \brief Execute a user-defined reduce operation on the values of a column.; 1660 /// \tparam F The type of the reduce callable. Automatically deduced.; 1661 /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; 1662 /// \param[in] f A callable with signature `T(T,T)`; 1663 /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; 1664 /// \return the reduced quantity wrapped in a ROOT::RDF:RResultPtr.; 1665 ///; 1666 /// A reduction takes two values of a column and merges them into one (e.g.; 1667 /// by summing them, taking the maximum, etc). This action performs the; 1668 /// specified reduction operation on all processed column values, returning; 1669 /// a single value of the same type. The callable f must satisfy the general; 1670 /// requirements of a *processing function* besides having signature `T(T,T)`; 1671 /// where `T` is the type of column columnName.; 1672 ///; 1673 /// The returned reduced value of each thread (e.g. the initial value of a sum) is initialized to a; 1674 /// default-constr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:92833,reduce,reduce,92833,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['reduce'],['reduce']
Energy Efficiency,"td::size_t ROOT::Experimental::RNTupleWriter::Fill ; (; REntry & ; entry). inline . Multiple entries can have been instantiated from the ntuple model. ; This method will perform a light check whether the entry comes from the ntuple's own model. ReturnsThe number of uncompressed bytes written. ; Definition at line 109 of file RNTupleWriter.hxx. ◆ FillNoFlush(). void ROOT::Experimental::RNTupleWriter::FillNoFlush ; (; REntry & ; entry, . RNTupleFillStatus & ; status . ). inline . Fill an entry into this ntuple, but don't commit the cluster. ; The calling code must pass an RNTupleFillStatus and check RNTupleFillStatus::ShouldFlushCluster. ; Definition at line 112 of file RNTupleWriter.hxx. ◆ FlushCluster(). void ROOT::Experimental::RNTupleWriter::FlushCluster ; (; ). inline . Flush so far filled entries to storage. ; Definition at line 117 of file RNTupleWriter.hxx. ◆ FlushColumns(). void ROOT::Experimental::RNTupleWriter::FlushColumns ; (; ). inline . Flush column data, preparing for CommitCluster or to reduce memory usage. ; This will trigger compression of pages, but not actually write to storage (unless buffered writing is turned off). ; Definition at line 115 of file RNTupleWriter.hxx. ◆ GetLastCommitted(). NTupleSize_t ROOT::Experimental::RNTupleWriter::GetLastCommitted ; (; ); const. inline . Return the entry number that was last committed in a cluster. ; Definition at line 131 of file RNTupleWriter.hxx. ◆ GetLastCommittedClusterGroup(). NTupleSize_t ROOT::Experimental::RNTupleWriter::GetLastCommittedClusterGroup ; (; ); const. inline . Return the entry number that was last committed in a cluster group. ; Definition at line 133 of file RNTupleWriter.hxx. ◆ GetLastFlushed(). NTupleSize_t ROOT::Experimental::RNTupleWriter::GetLastFlushed ; (; ); const. inline . Return the entry number that was last flushed in a cluster. ; Definition at line 129 of file RNTupleWriter.hxx. ◆ GetMetrics(). const Detail::RNTupleMetrics & ROOT::Experimental::RNTupleWriter::GetMetrics ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriter.html:9381,reduce,reduce,9381,doc/master/classROOT_1_1Experimental_1_1RNTupleWriter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriter.html,1,['reduce'],['reduce']
Energy Efficiency,"td::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooListProxy_x; Double_t_z; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const RooArgList& mu, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const RooFitResult& fr, Bool_t reduceToConditional = kTRUE). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TVectorD& mu, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const RooMultiVarGaussian& other, const char* name = 0). void syncMuVec() const. Double_t evaluate() const; Represent observables as vector. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Handle full integral here. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Special case: generate all observables. void initGenerator(Int_t code); Clear the GenData cache as its content is not invariant under changes in; the mu vector. void generateEvent(Int_t code); Retrieve generato",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMultiVarGaussian.html:44386,reduce,reduceToConditional,44386,root/html534/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html534/RooMultiVarGaussian.html,1,['reduce'],['reduceToConditional']
Energy Efficiency,"td::vector< double > & ; , . double ;  . ). inlinevirtual . callback for monitoring and logging ; Definition at line 807 of file NeuralNet.h. ◆ dropFractions(). const std::vector< double > & TMVA::DNN::Settings::dropFractions ; (; ); const. inline . Definition at line 762 of file NeuralNet.h. ◆ dropRepetitions(). size_t TMVA::DNN::Settings::dropRepetitions ; (; ); const. inline . Definition at line 761 of file NeuralNet.h. ◆ endTestCycle(). virtual void TMVA::DNN::Settings::endTestCycle ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 805 of file NeuralNet.h. ◆ endTrainCycle(). virtual void TMVA::DNN::Settings::endTrainCycle ; (; double ; ). inlinevirtual . callback for monitoring and logging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 788 of file NeuralNet.h. ◆ exists(). bool TMVA::DNN::Settings::exists ; (; std::string ; histoName). inline . for monitoring ; Definition at line 825 of file NeuralNet.h. ◆ factorWeightDecay(). double TMVA::DNN::Settings::factorWeightDecay ; (; ); const. inline . get the weight-decay factor ; Definition at line 769 of file NeuralNet.h. ◆ hasConverged(). bool TMVA::DNN::Settings::hasConverged ; (; double ; testError). virtual . has this training converged already? ; check for convergence; Definition at line 485 of file NeuralNet.cxx. ◆ learningRate(). double TMVA::DNN::Settings::learningRate ; (; ); const. inline . get the learning rate ; Definition at line 771 of file NeuralNet.h. ◆ maxConvergenceCount(). size_t TMVA::DNN::Settings::maxConvergenceCount ; (; ); const. inline . returns the max convergence count so far ; Definition at line 828 of file NeuralNet.h. ◆ minError(). size_t TMVA::DNN::Settings::minError ; (; ); const. inline . returns the smallest error so far ; Definition at line 829 of file NeuralNet.h. ◆ minimizerType(). MinimizerType TMVA::DNN::Settings::minimizerType ; (; ); const. inline . which minimizer sh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:8573,monitor,monitoring,8573,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['monitor'],['monitoring']
Energy Efficiency,"te Attributes |; List of all members ; ROOT::Math::GSLMinimizer1D Class ReferenceMath » MathCore | Math » MathMore » Numerical Algorithms » One-dimensional Minimization. ; Minimizer for arbitrary one dimensional functions. ; Implemented using GSL, for detailed description see: GSL online doc; The algorithms uspported are only bracketing algorithm which do not use derivatives information. The algorithms which can be chosen at construction time are GOLDENSECTION, which is the simplest method but the slowest and BRENT (the default one) which combines the golden section with a parabolic interpolation.; This class does not support copying ; Definition at line 81 of file GSLMinimizer1D.h. Public Member Functions;  GSLMinimizer1D (const GSLMinimizer1D &)=delete;  ;  GSLMinimizer1D (GSLMinimizer1D &&)=delete;  ;  GSLMinimizer1D (Minim1D::Type type=Minim1D::kBRENT);  Construct the minimizer passing the minimizer type using the Minim1D::Algorithm enumeration. ;  ;  ~GSLMinimizer1D () override;  Destructor: free allocated resources. ;  ; double FValLower () const override;  Return function value at current lower bound of the minimization interval. ;  ; double FValMinimum () const override;  Return function value at current estimate of the minimum. ;  ; double FValUpper () const override;  Return function value at current upper bound of the minimization interval. ;  ; int Iterate ();  Perform a minimizer iteration and if an unexpected problem occurs then an error code will be returned. ;  ; int Iterations () const override;  Return number of iteration used to find minimum. ;  ; bool Minimize (int maxIter, double absTol, double relTol) override;  Find minimum position iterating until convergence specified by the absolute and relative tolerance or the maximum number of iteration is reached Return true is result is successful @param maxIter maximum number of iteration @param absTol desired absolute error in the minimum position @param absTol desired relative error in the minimum p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMinimizer1D.html:1239,allocate,allocated,1239,doc/master/classROOT_1_1Math_1_1GSLMinimizer1D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMinimizer1D.html,1,['allocate'],['allocated']
Energy Efficiency,"te this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; Float_t fFrontPower;  ; UInt_t fLightState;  ; Float_t fSidePower;  power of the front lamp ;  ; Float_t fSpecularPower;  power of the side lamps ;  ; Bool_t fUseSpecular;  light states (on/off) mask ;  . Private Member Functions;  TGLLightSet (const TGLLightSet &)=delete;  ; TGLLightSet & operator= (const TGLLightSet &)=delete;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TGLLightSet.h>. Inheritance diagram for TGLLightSet:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ ELight. enum TGLLightSet::ELight. EnumeratorkLightFront ; kLightTop ; kLightBottom ; kLightLeft ; kLightRight ; kLightMask ; kLightSpecular . Definition at line 24 of file TGLLightSet.h. Constructor & Destructor Documentation. ◆ TGL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLLightSet.html:10521,power,power,10521,doc/master/classTGLLightSet.html,https://root.cern,https://root.cern/doc/master/classTGLLightSet.html,2,['power'],['power']
Energy Efficiency,"teFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressMemoryPlot(TProofProgressDialog* d, Int_t w = 700, Int_t h = 300); Main constructor. ~TProofProgressMemoryPlot(); Destructor. TGListBox* BuildLogList(TGFrame* parent); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void Clear(Option_t* = 0); Clear the canvases. void DoPlot(); Draw the plot from the logs. TGraph * DoAveragePlot(Int_t& max_el, Int_t& min_el); Create the average plots. Int_t ParseLine(TString l, Long64_t& v, Long64_t& r, Long64_t& e); Extract from line 'l' the virtual memory 'v', the resident memory 'r' and the; number of events 'e'.; The line is assumed to be in the form; ""... Memory 130868 virtual 31540 ... event 5550""; The fields are only filled if >= 0 .; Return 0 on success, -1 if any of the values coudl not be filled (the output; fields are not touched in such a case). TGraph * DoWorkerPlot(TProofLogElem* ple); Make a memory consumption graph for a worker. TGraph * DoMasterPlot(TProofLogElem* ple); a master or submaster log; display without meaningful labels for now. void Select(Int_t id); actions of select all/clear all button. TGraph* DoAveragePlotOld(Int_t& max_el, Int_t& min_el). » Author: Anna Kreshuk 18/07/2008 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-03-14 16:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofProgressMemoryPlot.html:23629,consumption,consumption,23629,root/html534/TProofProgressMemoryPlot.html,https://root.cern,https://root.cern/root/html534/TProofProgressMemoryPlot.html,1,['consumption'],['consumption']
Energy Efficiency,"teItems(int nElements, TBuffer& b); voidWriteMap(UInt_t nElements, TBuffer& b). private:. TEmulatedMapProxy&operator=(const TEmulatedMapProxy& rhs). Data Members; public:. enum TGenCollectionProxy::[unnamed] { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; void*TGenCollectionProxy::fCollectMethod to collect objects from container; void*TGenCollectionProxy::fConstructContainer accessors: block construct; map<std::string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; void*TGenCollectionProxy::fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*TGenCollectionProxy::fEnvAddress of the currently proxied object; void*TGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; void*TGenCollectionProxy::fFunctionCopyIterator; void*TGenCollectionProxy::fFunctionCreateIterators; void*TGenCollectionProxy::fFunctionDeleteIterator; void*TGenCollectionProxy::fFunctionDeleteTwoIterators; void*TGenCollectionProxy::fFunctionNextIterator; TGenCollectionProxy::Value*TGenCollectionProxy::fKeyDescriptor of the key_type; stringTGenCollectionProxy::fNameName of the class being proxied.; TGenCollectionProxy::MethodTGenCollectionProxy::fNextContainer accessors: generic iteration: next; TClass*TGenCollectionProxy::fOnFileClassOn file class; Bool_tTGenCollectionProxy::fPointersFlag to indi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEmulatedMapProxy.html:5123,allocate,allocate,5123,root/html534/TEmulatedMapProxy.html,https://root.cern,https://root.cern/root/html534/TEmulatedMapProxy.html,1,['allocate'],['allocate']
Energy Efficiency,"tected . General matrix multiplication. ; Replace this matrix with C such that C = A * B'. Note, matrix C is allocated for constr=1. ; Definition at line 662 of file TMatrixTSparse.cxx. ◆ AMultBt() [3/3]. template<class Element > . void TMatrixTSparse< Element >::AMultBt ; (; const TMatrixTSparse< Element > & ; a, . const TMatrixTSparse< Element > & ; b, . Int_t ; constr = 0 . ). inlineprotected . Definition at line 57 of file TMatrixTSparse.h. ◆ APlusB() [1/3]. template<class Element > . void TMatrixTSparse< Element >::APlusB ; (; const TMatrixT< Element > & ; a, . const TMatrixTSparse< Element > & ; b, . Int_t ; constr = 0 . ). inlineprotected . Definition at line 67 of file TMatrixTSparse.h. ◆ APlusB() [2/3]. template<class Element > . void TMatrixTSparse< Element >::APlusB ; (; const TMatrixTSparse< Element > & ; a, . const TMatrixT< Element > & ; b, . Int_t ; constr = 0 . ). protected . General matrix addition. ; Replace this matrix with C such that C = A + B. Note, matrix C is allocated for constr=1. ; Definition at line 927 of file TMatrixTSparse.cxx. ◆ APlusB() [3/3]. template<class Element > . void TMatrixTSparse< Element >::APlusB ; (; const TMatrixTSparse< Element > & ; a, . const TMatrixTSparse< Element > & ; b, . Int_t ; constr = 0 . ). protected . General matrix addition. ; Replace this matrix with C such that C = A + B. Note, matrix C is allocated for constr=1. ; Definition at line 845 of file TMatrixTSparse.cxx. ◆ Class() [1/2]. template<class Element > . static TClass * TMatrixTSparse< Element >::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class() [2/2]. TClass * TMatrixTSparse< double >::Class ; (; ). ◆ Class_Name(). template<class Element > . static const char * TMatrixTSparse< Element >::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). template<class Element > . static constexpr Version_t TMatrixTSparse< Element >::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixTSparse.html:37003,allocate,allocated,37003,doc/master/classTMatrixTSparse.html,https://root.cern,https://root.cern/doc/master/classTMatrixTSparse.html,1,['allocate'],['allocated']
Energy Efficiency,"ted . Definition at line 51 of file TMatrixTSparse.h. ◆ AMultB() [3/3]. template<class Element > . void TMatrixTSparse< Element >::AMultB ; (; const TMatrixTSparse< Element > & ; a, . const TMatrixTSparse< Element > & ; b, . Int_t ; constr = 0 . ). inlineprotected . Definition at line 48 of file TMatrixTSparse.h. ◆ AMultBt() [1/3]. template<class Element > . void TMatrixTSparse< Element >::AMultBt ; (; const TMatrixT< Element > & ; a, . const TMatrixTSparse< Element > & ; b, . Int_t ; constr = 0 . ). protected . General matrix multiplication. ; Replace this matrix with C such that C = A * B'. Note, matrix C is allocated for constr=1. ; Definition at line 753 of file TMatrixTSparse.cxx. ◆ AMultBt() [2/3]. template<class Element > . void TMatrixTSparse< Element >::AMultBt ; (; const TMatrixTSparse< Element > & ; a, . const TMatrixT< Element > & ; b, . Int_t ; constr = 0 . ). protected . General matrix multiplication. ; Replace this matrix with C such that C = A * B'. Note, matrix C is allocated for constr=1. ; Definition at line 662 of file TMatrixTSparse.cxx. ◆ AMultBt() [3/3]. template<class Element > . void TMatrixTSparse< Element >::AMultBt ; (; const TMatrixTSparse< Element > & ; a, . const TMatrixTSparse< Element > & ; b, . Int_t ; constr = 0 . ). inlineprotected . Definition at line 57 of file TMatrixTSparse.h. ◆ APlusB() [1/3]. template<class Element > . void TMatrixTSparse< Element >::APlusB ; (; const TMatrixT< Element > & ; a, . const TMatrixTSparse< Element > & ; b, . Int_t ; constr = 0 . ). inlineprotected . Definition at line 67 of file TMatrixTSparse.h. ◆ APlusB() [2/3]. template<class Element > . void TMatrixTSparse< Element >::APlusB ; (; const TMatrixTSparse< Element > & ; a, . const TMatrixT< Element > & ; b, . Int_t ; constr = 0 . ). protected . General matrix addition. ; Replace this matrix with C such that C = A + B. Note, matrix C is allocated for constr=1. ; Definition at line 927 of file TMatrixTSparse.cxx. ◆ APlusB() [3/3]. template<class Ele",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixTSparse.html:36114,allocate,allocated,36114,doc/master/classTMatrixTSparse.html,https://root.cern,https://root.cern/doc/master/classTMatrixTSparse.html,1,['allocate'],['allocated']
Energy Efficiency,"ted . Set the sequence of actions needed to read the data out of the buffer. ; Definition at line 5628 of file TBranchElement.cxx. ◆ SetAddress(). void TBranchElement::SetAddress ; (; void * ; addr). overridevirtual . Point this branch at an object. ; For a sub-branch, addr is a pointer to the branch object.; For a top-level branch the meaning of addr is as follows:; If addr is zero, then we allocate a branch object internally and the branch is the owner of the allocated object, not the caller. However the caller may obtain a pointer to the branch object with GetObject(). The pointer is reset to zero (nullptr) when the relevant branch object is destroyed.; Example: branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work.; EventDefinition collection_proxies.C:172; If addr is not zero, but the pointer addr points at is zero, then we allocate a branch object and set the passed pointer to point at the allocated object. The caller owns the allocated object and is responsible for deleting it when it is no longer needed.; Example: Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;; If addr is not zero and the pointer addr points at is also not zero, then the caller has allocated a branch object and is asking us to use it. The caller owns it and must delete it when it is no longer needed.; Example: Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;; These rules affect users of TTree::Branch(), TTree::SetBranchAddress(), and TChain::SetBranchAddress() as well because those routines call this one.; An example of a tree with branches with objects allocated and owned by us: TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;; f#",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:66983,allocate,allocated,66983,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,1,['allocate'],['allocated']
Energy Efficiency,"ted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TArrayI; Int_t * fArray;  ;  Public Attributes inherited from TArray; Int_t fN;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TH3; static TH1D * DoProject1D (const TH3 &h, const char *name, const char *title, const TAxis *projX, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 1D histogram ;  ; static TH2D * DoProject2D (const TH3 &h, const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 2D histogram ;  ;  Static Protected Member Functions inherited from TH1; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2);  Ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3I.html:57286,power,power,57286,doc/master/classTH3I.html,https://root.cern,https://root.cern/doc/master/classTH3I.html,1,['power'],['power']
Energy Efficiency,"ted Attributes |; Private Types |; Private Member Functions |; Static Private Member Functions |; Private Attributes |; List of all members ; TMVA::MethodPDERS Class ReferenceTMVA. ; This is a generalization of the above Likelihood methods to \( N_{var} \) dimensions, where \( N_{var} \) is the number of input variables used in the MVA. ; If the multi-dimensional probability density functions (PDFs) for signal and background were known, this method contains the entire physical information, and is therefore optimal. Usually, kernel estimation methods are used to approximate the PDFs using the events from the training sample.; A very simple probability density estimator (PDE) has been suggested in hep-ex/0211019. The PDE for a given test event is obtained from counting the (normalized) number of signal and background (training) events that occur in the ""vicinity"" of the test event. The volume that describes ""vicinity"" is user-defined. A search method based on binary-trees is used to effectively reduce the selection time for the range search. Three different volume definitions are optional:. MinMax: the volume is defined in each dimension with respect to the full variable range found in the training sample.; RMS: the volume is defined in each dimensions with respect to the RMS estimated from the training sample.; Adaptive: a volume element is defined in each dimensions with respect to the RMS estimated from the training sample. The overall scale of the volume element is then determined for each event so that the total number of events confined in the volume be within a user-defined range. The adaptive range search is used by default. ; Definition at line 61 of file MethodPDERS.h. Public Member Functions;  MethodPDERS (const TString &jobName, const TString &methodTitle, DataSetInfo &theData, const TString &theOption);  standard constructor for the PDERS method ;  ;  MethodPDERS (DataSetInfo &theData, const TString &theWeightFile);  construct MethodPDERS through from file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodPDERS.html:1252,reduce,reduce,1252,doc/master/classTMVA_1_1MethodPDERS.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodPDERS.html,1,['reduce'],['reduce']
Energy Efficiency,"ted from TEveProjectable; ProjList_t fProjectedList;  ;  Protected Attributes inherited from TAttBBox; Float_t * fBBox;  ;  Protected Attributes inherited from TEveProjected; Float_t fDepth;  ; TEveProjectionManager * fManager;  ; TEveProjectable * fProjectable;  . Private Member Functions;  TEvePolygonSetProjected (const TEvePolygonSetProjected &)=delete;  ; Float_t AddPolygon (std::list< Int_t, std::allocator< Int_t > > &pp, std::list< Polygon_t, std::allocator< Polygon_t > > &p);  Check if polygon has dimensions above TEveProjection::fgEps and add it to a list if it is not a duplicate. ;  ; Bool_t IsFirstIdxHead (Int_t s0, Int_t s1);  Compare the two segments and check if the first index of first segment is starting. ;  ; Float_t MakePolygonsFromBP (Int_t *idxMap);  Build polygons from list of buffer polygons. ;  ; Float_t MakePolygonsFromBS (Int_t *idxMap);  Build polygons from the set of buffer segments. ;  ; TEvePolygonSetProjected & operator= (const TEvePolygonSetProjected &)=delete;  ; Int_t * ProjectAndReducePoints ();  Project and reduce buffer points. ;  . Private Attributes; TBuffer3D * fBuff;  . Friends; class TEvePolygonSetProjectedEditor;  ; class TEvePolygonSetProjectedGL;  . Additional Inherited Members;  Public Types inherited from TEveShape; typedef std::vector< TEveVector2 >::iterator vVector2_i;  ; typedef std::vector< TEveVector2 > vVector2_t;  ;  Public Types inherited from TEveElement; enum  EChangeBits { kCBColorSelection = (1ULL << ( 0 )); , kCBTransBBox = (1ULL << ( 1 )); , kCBObjProps = (1ULL << ( 2 )); , kCBVisibility = (1ULL << ( 3 )); };  ; typedef void(TEveElement::* ImplySelect_foo) ();  ; typedef List_t::const_iterator List_ci;  ; typedef List_t::iterator List_i;  ; typedef std::list< TEveElement * > List_t;  ; typedef void(TEveElement::* Select_foo) (Bool_t);  ; typedef Set_t::const_iterator Set_ci;  ; typedef Set_t::iterator Set_i;  ; typedef std::set< TEveElement * > Set_t;  ; typedef sLTI_t::iterator sLTI_i;  ; typedef sLTI_t::r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEvePolygonSetProjected.html:38094,reduce,reduce,38094,doc/master/classTEvePolygonSetProjected.html,https://root.cern,https://root.cern/doc/master/classTEvePolygonSetProjected.html,1,['reduce'],['reduce']
Energy Efficiency,"ted, neither is removal of atoms.; The structure can be Refit() to occupy a single contiguous array. Function Members (Methods); public:. virtual~TEveChunkManager(); Char_t*Atom(Int_t idx) const; Int_tCapacity() const; Char_t*Chunk(Int_t chk) const; static TClass*Class(); virtual TClass*IsA() const; Int_tN() const; Int_tNAtoms(Int_t chk) const; Char_t*NewAtom(); Char_t*NewChunk(); voidRefit(); voidReset(Int_t atom_size, Int_t chunk_size); Int_tS() const; virtual voidShowMembers(TMemberInspector& insp) const; Int_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TEveChunkManager(); TEveChunkManager(Int_t atom_size, Int_t chunk_size); Int_tVecSize() const. protected:. voidReleaseChunks(). private:. TEveChunkManager&operator=(const TEveChunkManager&); TEveChunkManager(const TEveChunkManager&). Data Members; protected:. Int_tfCapacityAvailable capacity within the chunks; vector<TArrayC*>fChunksMemory blocks; Int_tfNNumber of atoms in a chunk; Int_tfSSize of atom; Int_tfSizeSize of container, number of atoms; Int_tfVecSizeNumber of allocated chunks. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ReleaseChunks(); Release all memory chunks. TEveChunkManager(); Default constructor.; Call reset for initialization. TEveChunkManager(Int_t atom_size, Int_t chunk_size); Constructor. ~TEveChunkManager(); Destructor. void Reset(Int_t atom_size, Int_t chunk_size); Empty the container and reset it with given atom and chunk sizes. void Refit(); Refit the container so that all current data fits into a single; chunk. Char_t* NewChunk(); Allocate a new memory chunk and register it. Char_t* NewAtom(). TEveChunkManager(const TEveChunkManager& ). TEveChunkManager& operator=(const TEveChunkManager& ). Int_t S() const; { return fS; }. Int_t N() const; { return fN; }. Int_t Size() const; { return fSize; }. Int_t VecSize() const; { return fVecSize; }. Int_t Capacity() const; { return fCapac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveChunkManager.html:1629,allocate,allocated,1629,root/html602/TEveChunkManager.html,https://root.cern,https://root.cern/root/html602/TEveChunkManager.html,2,['allocate'],['allocated']
Energy Efficiency,"temTag> . template<class ForeignVector > . DisplacementVector2D & ROOT::Math::DisplacementVector2D< CoordSystem, Tag >::operator= ; (; const ForeignVector & ; v). inline . Assignment from a foreign 2D vector type, for example, Hep2Vector Precondition: v must implement methods x() and y() ; Definition at line 141 of file DisplacementVector2D.h. ◆ operator=() [4/5]. template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . template<class OtherCoords , class OtherTag > . DisplacementVector2D & ROOT::Math::DisplacementVector2D< CoordSystem, Tag >::operator= ; (; const PositionVector2D< OtherCoords, OtherTag > & ; ). private . ◆ operator=() [5/5]. template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . template<class OtherCoords > . DisplacementVector2D & ROOT::Math::DisplacementVector2D< CoordSystem, Tag >::operator= ; (; const PositionVector2D< OtherCoords, Tag > & ; rhs). inline . Assignment operator from a position vector (not necessarily efficient unless one or the other is Cartesian) ; Definition at line 129 of file DisplacementVector2D.h. ◆ operator==(). template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . bool ROOT::Math::DisplacementVector2D< CoordSystem, Tag >::operator== ; (; const DisplacementVector2D< CoordSystem, Tag > & ; rhs); const. inline . Exact equality. ; Definition at line 189 of file DisplacementVector2D.h. ◆ Phi(). template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . Scalar ROOT::Math::DisplacementVector2D< CoordSystem, Tag >::Phi ; (; ); const. inline . Polar phi, converting if necessary from internal coordinate system. ; Definition at line 223 of file DisplacementVector2D.h. ◆ phi(). template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . Scalar ROOT::Math::DisplacementVector2D< CoordSystem, Tag >::phi ; (; ); const. inline . Definition at line 387 of file DisplacementVector2D.h. ◆ R(). template<class CoordSystem , class Tag = DefaultCoordinateSystemTag> . Scalar ROOT:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1DisplacementVector2D.html:19141,efficient,efficient,19141,doc/master/classROOT_1_1Math_1_1DisplacementVector2D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1DisplacementVector2D.html,1,['efficient'],['efficient']
Energy Efficiency,"tems and display them. A snapshot of running server can be seen on the demo page.; One could also specify similar URL parameters to configure the displayed items and drawing options.; It is also possible to display one single item from the THttpServer server like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz; 1.10 Data monitoring with JSROOT; 1.10.1 Monitoring with http server; The best possibility to organize the monitoring of data from a running application is to use THttpServer. In such case the client can always access the latest changes and request only the items currently displayed in the browser. To enable monitoring, one should activate the appropriate checkbox or provide monitoring parameter in the URL string like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hprof/draw.htm?monitoring=1000; The parameter value is the update interval in milliseconds.; 1.10.2 JSON file-based monitoring; Solid file-based monitoring (without integration of THttpServer into application) can be implemented in JSON format. There is the TBufferJSON class, which is capable to convert any (beside TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser.; There is a demonstration page showing such functionality: https://root.cern/js/latest/demo/update_draw.htm. This demo page reads in cycle 20 json files and displays them.; If one has a web server which already provides such JSON file, one could specify the URL to this file like:; https://root.cern/js/latest/demo/update_draw.htm?addr=../httpserver.C/Canvases/c1/root.json.gz; Here the same problem with Cross-Origin Request can appear. If the web server configuration cannot be changed, just copy JSROOT to the web server itself.; 1.10.3 Binary file-based monitoring (not recommended)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:19884,monitor,monitoring,19884,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,2,['monitor'],['monitoring']
Energy Efficiency,"ten so that a 'missing' collection; appears to be an empty collection. void Print(Option_t* option = """") const; Print branch parameters. void PrintValue(Int_t i) const; -- Prints values of leaves. void ReadLeaves(TBuffer& b); -- Read leaves into i/o buffers for this branch. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); -- Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBranchElement.html:23897,allocate,allocate,23897,root/html526/TBranchElement.html,https://root.cern,https://root.cern/root/html526/TBranchElement.html,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"tension of the ToyMCSampler for Importance Sampling ;  CToyMCPayload;  CToyMCSamplerToyMCSampler is an implementation of the TestStatSampler interface ;  CToyMCStudyToyMCStudy is an implementation of RooAbsStudy for toy Monte Carlo sampling ;  CUniformProposalUniformProposal is a concrete implementation of the ProposalFunction interface for use with a Markov Chain Monte Carlo algorithm ;  CUpperLimitMCSModuleThis class allow to compute in the ToyMcStudy framework the ProfileLikelihood upper limit for each toy-MC sample generated ;  ►NROOTNamespace for new ROOT classes and functions ;  NCocoaTutorials;  ►NDetail;  ►NRDF;  ►NCustomColExtraArgs;  CNone;  CSlot;  CSlotAndEntry;  CRCustomColumn;  CRCustomColumnBase;  CRFilter;  CRFilterBase;  CRJittedCustomColumnA wrapper around a concrete RCustomColumn, which forwards all calls to it RJittedCustomColumn is a placeholder that is put in the collection of custom columns in place of a RCustomColumn that will be just-in-time compiled ;  CRJittedFilterA wrapper around a concrete RFilter, which forwards all calls to it RJittedFilter is the type of the node returned by jitted Filter calls: the concrete filter can be created and set at a later time, from jitted code ;  ►CRLoopManagerThe head node of a RDF computation graph ;  CTCallback;  CTOneTimeCallback;  CRNodeBaseBase class for non-leaf nodes of the computational graph ;  CRRange;  CRRangeBase;  ►NVecOps;  ►CRAdoptAllocatorRAdoptAllocator can provide a view on already allocated memory ;  Crebind;  ►CRAdoptAllocator< bool >;  Crebind;  C__integer_sequence;  C__make;  C__make< 0 >;  C__make< 1 >;  C__make< 2 >;  C__make< 3 >;  C__make< 4 >;  C__make< 5 >;  C__make< 6 >;  C__make< 7 >;  C__parity;  ►C__parity< 0 >;  C__pmake;  ►C__parity< 1 >;  C__pmake;  ►C__parity< 2 >;  C__pmake;  ►C__parity< 3 >;  C__pmake;  ►C__parity< 4 >;  C__pmake;  ►C__parity< 5 >;  C__pmake;  ►C__parity< 6 >;  C__pmake;  ►C__parity< 7 >;  C__pmake;  C__repeat;  C__repeat< __integer_sequence< _Tp, _Np.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/namespaces.html:17564,allocate,allocated,17564,doc/v616/namespaces.html,https://root.cern,https://root.cern/doc/v616/namespaces.html,1,['allocate'],['allocated']
Energy Efficiency,"ter in the comments of the field:; Int_t fTempValue; //! temporary state value; 15.5.1 The LinkDef.h File; Step 3: The LinkDef.h file tells rootcling which classes should be added to the dictionary.; #ifdef __CLING__; #pragma link C++ class SClass;; #endif; Three options can trail the class name:. - : tells rootcling not to generate the Streamer method for this class. This is necessary for those classes that need a customized Streamer method. #pragma link C++ class SClass-; // no streamer. ! : tells rootcling not to generate the operator>>(TBuffer &b,MyClass *&obj) method for this class. This is necessary to be able to write pointers to objects of classes not inheriting from TObject. #pragma link C++ class SClass!; // no >> operator; // or; #pragma link C++ class SClass-!; // no streamer, no >> operator. + : in ROOT version 1 and 2 tells rootcling to generate a Streamer with extra byte count information. This adds an integer to each object in the output buffer, but it allows for powerful error correction in case a Streamer method is out of sync with data in the file. The + option is mutual exclusive with both the - and ! options. IMPORTANT NOTE: In ROOT Version 3 and later, a “+” after the class name tells rootcling to use the new I/O system. The byte count check is always added. The new I/O system has many advantages including support automatic schema evolution, full support for STL collections and better run-time performance. We strongly recommend using it.; #pragma link C++ class SClass+; // add byte count; For information on Streamers see “Input/Output”. To get help on rootcling type on the UNIX command line: rootcling -h; 15.5.1.1 The Order Matters; When using template classes, the order of the pragma statements matters. For example, here is a template class Tmpl and a normal class Norm, which holds a specialized instance of a Tmpl:; class Norm {; private:; Tmpl<int>* fIntTmpl;; public:; ...; };; Then in Linkdef.h, the pragma statements must be ordered by listi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:825357,power,powerful,825357,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['power'],['powerful']
Energy Efficiency,"ter which to send the latest value; TStopwatchfStopwatchcpu and time measurement for job and proc status; TStringfSubJobId! sub job id; Bool_tfVerboseverbocity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonaLisaWriter(const char* monserver, const char* montag, const char* monid = 0, const char* monsubid = 0, const char* option = """"); Create MonaLisa write object. void Init(const char* monserver, const char* montag, const char* monid, const char* monsubid, const char* option); Creates a TMonaLisaWriter object to send monitoring information to a; MonaLisa server using the MonaLisa ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.0.6.tar.gz. The ROOT implementation is primary optimized for process/job monitoring,; although all other generic MonaLisa ApMon functionality can be exploited; through the ApMon class directly (gMonitoringWriter->GetApMon()). Monitoring information in MonaLisa is structured in the following tree; structure:; <farmname>; |; ---> <nodename1>; |; ---> <key1> - <value1>; ---> <key2> - <value2>; ---> <nodename2>; |; ---> <key3> - <value3>; ---> <key4> - <value4>. The parameter monid is equivalent to the MonaLisa node name, for the; case of process monitoring it can be just an identifier to classify; the type of jobs e.g. ""PROOF_PROCESSING"".; If monid is not specified, TMonaLisaWriter tries to set it in this order; from environement variables:; - PROOF_JOB_ID; - GRID_JOB_ID; - LCG_JOB_ID; - ALIEN_MASTERJOB_ID; - ALIEN_PROC_ID. The parameter montag is equivalent to the MonaLisa farm name, for the; case of process monitoring it can be a process identifier e.g. a PROOF; session ID. The parameter monserver specifies the server to whom to send the; monitoring UDP packets. If not specified, the hostname (the port",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMonaLisaWriter.html:9861,monitor,monitoring,9861,root/html530/TMonaLisaWriter.html,https://root.cern,https://root.cern/root/html530/TMonaLisaWriter.html,2,['monitor'],['monitoring']
Energy Efficiency,"terator_t) (void *dest, const void *source). Copy the iterator source into dest. ; dest should contain the location of a memory arena of size fgIteratorArenaSize. If iterator-specific information is of that size or less, the iterators will be constructed in place in the given locations. Otherwise, iterators will be allocated via new and their address returned by modifying the value of *begin_arena and *end_arena. The actual address of the iterator is returned in any case. ; Definition at line 227 of file TVirtualCollectionProxy.h. ◆ CreateIterators_t. typedef void(* TVirtualCollectionProxy::CreateIterators_t) (void *collection, void **begin_arena, void **end_arena, TVirtualCollectionProxy *proxy). *begin_arena and *end_arena should contain the location of a memory arena of size fgIteratorArenaSize. ; If iterator-specific information is of that size or less, the iterators will be constructed in place in the given locations. Otherwise, iterators will be allocated via new and their address returned by modifying the value of *begin_arena and *end_arena. As a special case, given that iterators for array-backed containers are just pointers, the required information will be directly stored in *(begin|end)_arena. ; Definition at line 215 of file TVirtualCollectionProxy.h. ◆ DeleteIterator_t. typedef void(* TVirtualCollectionProxy::DeleteIterator_t) (void *iter). If the size of the iterator is greater than fgIteratorArenaSize, call delete on the addresses; otherwise, just call the iterator's destructor. ; Definition at line 244 of file TVirtualCollectionProxy.h. ◆ DeleteTwoIterators_t. typedef void(* TVirtualCollectionProxy::DeleteTwoIterators_t) (void *begin, void *end). Definition at line 245 of file TVirtualCollectionProxy.h. ◆ Next_t. typedef void *(* TVirtualCollectionProxy::Next_t) (void *iter, const void *end). iter and end should be pointers to an iterator to be incremented and an iterator that points to the end of the collection, respectively. ; If iter has not reach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualCollectionProxy.html:8845,allocate,allocated,8845,doc/master/classTVirtualCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTVirtualCollectionProxy.html,1,['allocate'],['allocated']
Energy Efficiency,"ternal (MnUserParameterState) representation available For the parameters at the Minimum ;  CMnAboveMaxEdm;  CMnReachedCallLimit;  ►CBasicMinimumErrorInternal Class containing the error information on the estimated minimum : Error matrix + dcovar + additional flags for quality and validity checks ;  CMnHesseFailed;  CMnInvertFailed;  CMnMadePosDef;  CMnNotPosDef;  CBasicMinimumParameters;  CBasicMinimumSeed;  CBasicMinimumState;  CBFGSErrorUpdatorUpdate of the covariance matrix for the Variable Metric minimizer (MIGRAD) ;  CBFGSMinimizerType;  CCombinedMinimizerCombined minimizer: combination of Migrad and Simplex ;  CCombinedMinimumBuilder;  CContoursError;  CDavidonErrorUpdatorUpdate of the covariance matrix for the Variable Metric minimizer (MIGRAD) ;  CFCNAdapterTemplate wrapped class for adapting to FCNBase signature ;  CFCNBaseInterface (abstract class) defining the function to be minimized, which has to be implemented by the user ;  CFCNGradAdapterTemplate wrapped class for adapting to FCNBase signature a IGradFunction ;  CFCNGradientBaseExtension of the FCNBase for providing the analytical Gradient of the function ;  CFumiliBuilderBuilds the FunctionMinimum using the Fumili method ;  CFumiliChi2FCNExtension of the FCNBase for the Fumili method ;  CFumiliErrorUpdatorIn the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives ;  CFumiliFCNAdapterTemplate wrapped class for adapting to FumiliFCNBase signature ;  CFumiliFCNBaseExtension of the FCNBase for the Fumili method ;  CFumiliGradientCalculator;  CFumiliMaximumLikelihoodFCNExtension of the FCNBase for the Fumili method ;  CFumiliMinimizerInstantiates the seed generator and Minimum builder for the Fumili minimization method ;  CFumiliStandardChi2FCNClass implementing the standard chi square function, which is the sum of the squares of the figures-of-merit cal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:63087,adapt,adapting,63087,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,3,['adapt'],['adapting']
Energy Efficiency,"ter data () const noexcept;  Return a pointer to the vector's buffer, even if empty(). ;  ; pointer data () noexcept;  Return a pointer to the vector's buffer, even if empty(). ;  ; bool empty () const;  ; const_iterator end () const noexcept;  ; iterator end () noexcept;  ; reference front ();  ; const_reference front () const;  ; size_type max_size () const noexcept;  ; const_reverse_iterator rbegin () const noexcept;  ; reverse_iterator rbegin () noexcept;  ; const_reverse_iterator rend () const noexcept;  ; reverse_iterator rend () noexcept;  ; size_t size () const;  ; size_type size_in_bytes () const;  ;  Public Member Functions inherited from ROOT::Internal::VecOps::SmallVectorBase; size_t capacity () const noexcept;  ; bool empty () const;  ; void set_size (size_t N);  Set the array size to N, which the current array must have enough capacity for. ;  ; size_t size () const;  . Protected Member Functions;  SmallVectorTemplateBase (size_t Size);  ; void grow (size_t MinSize=0);  Grow the allocated memory (without initializing new elements), doubling the size of the allocated memory. ;  ;  Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorTemplateCommon< T >;  SmallVectorTemplateCommon (size_t Size);  ; void grow_pod (size_t MinSize, size_t TSize);  ; bool isSmall () const;  Return true if this is a smallvector which has not had dynamic memory allocated for it. ;  ; void resetToSmall ();  Put this vector in a state of being small. ;  ;  Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorBase;  SmallVectorBase ()=delete;  ;  SmallVectorBase (void *FirstEl, size_t TotalCapacity);  ; void grow_pod (void *FirstEl, size_t MinSize, size_t TSize);  This is an implementation of the grow() method which only works on POD-like data types and is out of line to reduce code duplication. ;  ; bool Owns () const;  If false, the RVec is in ""memory adoption"" mode, i.e. it is acting as a view on a memory buffer it does not own. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1VecOps_1_1SmallVectorTemplateBase.html:2768,allocate,allocated,2768,doc/master/classROOT_1_1Internal_1_1VecOps_1_1SmallVectorTemplateBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1VecOps_1_1SmallVectorTemplateBase.html,2,['allocate'],['allocated']
Energy Efficiency,"tes (color, appearance,; thickness) see TAttMarkerEditor. /*. */. This Tab has two different layouts. One is for a histogram which; is not drawn from an ntuple. The other one is available for a; histogram which is drawn from an ntuple. In this case the rebin; algorithm can create a rebinned histogram from the original data; i.e. the ntuple.; To see te differences do:; TFile f(""hsimple.root"");; hpx->Draw(""BAR1""); // non ntuple histogram; ntuple->Draw(""px""); // ntuple histogram; Non ntuple histogram:; 'Rebin': with the Slider the number of bins (shown in the field; below the Slider) can be changed to any number which; divides the number of bins of the original histogram.; Pushing 'Apply' will delete the origin histogram and; replace it by the rebinned one on the screen; Pushing 'Ignore' the origin histogram will be restored; Histogram drawn from an ntuple:; 'Rebin' with the slider the number of bins can be enlarged by; a factor of 2,3,4,5 (moving to the right) or reduced; by a factor of 1/2, 1/3, 1/4, 1/5; 'BinOffset': with the BinOffset slider the origin of the; histogram can be changed within one binwidth; Using this slider the effect of binning the data into; bins can be made visible => statistical fluctuations; 'Axis Range': with the DoubleSlider it is possible to zoom into; the specified axis range. It is also possible to set; the upper and lower limit in fields below the slider; 'Delayed drawing': all the Binning sliders can set to delay; draw mode. Then the changes on the histogram are only; updated, when the Slider is released. This should be; activated if the redrawing of the histogram is too; time consuming. /*. */. /*. */. Function Members (Methods); public:. TH1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TH1Editor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAcceptModel(TObject* model); virtual voidTGFrame::Activate(Bool_t);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1Editor.html:3287,reduce,reduced,3287,root/html528/TH1Editor.html,https://root.cern,https://root.cern/root/html528/TH1Editor.html,4,['reduce'],['reduced']
Energy Efficiency,"tes (color, appearance,; thickness) see TAttMarkerEditor. /*. */. This Tab has two different layouts. One is for a histogram which; is not drawn from an ntuple. The other one is available for a; histogram which is drawn from an ntuple. In this case the rebin; algorithm can create a rebinned histogram from the original data; i.e. the ntuple.; To see te differences do:; TFile f(""hsimple.root"");; hpx->Draw(""BAR1""); // non ntuple histogram; ntuple->Draw(""px""); // ntuple histogram; Non ntuple histogram:; 'Rebin': with the Slider the number of bins (shown in the field; below the Slider) can be changed to any number which; divides the number of bins of the original histogram.; Pushing 'Apply' will delete the origin histogram and; replace it by the rebinned one on the screen; Pushing 'Ignore' the origin histogram will be restored; Histogram drawn from an ntuple:; 'Rebin' with the slider the number of bins can be enlarged by; a factor of 2,3,4,5 (moving to the right) or reduced; by a factor of 1/2, 1/3, 1/4, 1/5; 'BinOffset': with the BinOffset slider the origin of the; histogram can be changed within one binwidth; Using this slider the effect of binning the data into; bins can be made visible => statistical fluctuations; 'Axis Range': with the DoubleSlider it is possible to zoom into; the specified axis range. It is also possible to set; the upper and lower limit in fields below the slider; 'Delayed drawing': all the Binning sliders can set to delay; draw mode. Then the changes on the histogram are only; updated, when the Slider is released. This should be; activated if the redrawing of the histogram is too; time consuming. /*. */. /*. */. Function Members (Methods); public:. virtual~TH1Editor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAcceptModel(TObject* model); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1Editor.html:3287,reduce,reduced,3287,root/html602/TH1Editor.html,https://root.cern,https://root.cern/root/html602/TH1Editor.html,2,['reduce'],['reduced']
Energy Efficiency,"tes.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html:15822,energy,energy,15822,root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,1,['energy'],['energy']
Energy Efficiency,"tes.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html:15822,energy,energy,15822,root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,1,['energy'],['energy']
Energy Efficiency,"texpr . ReturnsVersion of this class ; Definition at line 51 of file RooGamma.h. ◆ clone(). TObject * RooGamma::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 26 of file RooGamma.h. ◆ DeclFileName(). static const char * RooGamma::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 51 of file RooGamma.h. ◆ doEval(). void RooGamma::doEval ; (; RooFit::EvalContext & ; ctx); const. overrideprotectedvirtual . Compute multiple values of Gamma PDF. ; Reimplemented from RooAbsReal.; Definition at line 97 of file RooGamma.cxx. ◆ evaluate(). double RooGamma::evaluate ; (; ); const. overrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 83 of file RooGamma.cxx. ◆ generateEvent(). void RooGamma::generateEvent ; (; Int_t ; code). overridevirtual . algorithm adapted from code example in: Marsaglia, G. ; and Tsang, W. W. A Simple Method for Generating Gamma Variables ACM Transactions on Mathematical Software, Vol. 26, No. 3, September 2000; The speed of this algorithm depends on the speed of generating normal variates. The algorithm is limited to \( \gamma \geq 0 \) ! ; Reimplemented from RooAbsPdf.; Definition at line 182 of file RooGamma.cxx. ◆ getAnalyticalIntegral(). Int_t RooGamma::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGamma.html:77153,adapt,adapted,77153,doc/master/classRooGamma.html,https://root.cern,https://root.cern/doc/master/classRooGamma.html,1,['adapt'],['adapted']
Energy Efficiency,"text::output ; (; ). inline . Definition at line 112 of file EvalContext.h. ◆ resetVectorBuffers(). void RooFit::EvalContext::resetVectorBuffers ; (; ). inline . Definition at line 111 of file EvalContext.h. ◆ resize(). void RooFit::EvalContext::resize ; (; std::size_t ; n). Definition at line 82 of file EvalContext.cxx. ◆ set(). void RooFit::EvalContext::set ; (; RooAbsArg const * ; arg, . std::span< const double > const & ; span . ). inline . Definition at line 91 of file EvalContext.h. ◆ setConfig(). void RooFit::EvalContext::setConfig ; (; RooAbsArg const * ; arg, . RooBatchCompute::Config const & ; config . ). Definition at line 65 of file EvalContext.cxx. ◆ setOutputWithOffset(). void RooFit::EvalContext::setOutputWithOffset ; (; RooAbsArg const * ; arg, . ROOT::Math::KahanSum< double > ; val, . ROOT::Math::KahanSum< double > const & ; offset . ). Sets the output value with an offset. ; This function sets the output value with an offset for the given argument. It should only be used in reducer nodes. Depending on the current OffsetMode, the result will either be just the value, the value minus the offset, of just the offset.; Parameters. argPointer to the RooAbsArg object. ; valThe value to be set. ; offsetThe offset value. Exceptions. std::runtime_errorif the argument is not a reducer node. . Definition at line 100 of file EvalContext.cxx. ◆ size(). auto RooFit::EvalContext::size ; (; ); const. inline . Definition at line 88 of file EvalContext.h. Friends And Related Symbol Documentation. ◆ Evaluator. friend class Evaluator. friend . Definition at line 118 of file EvalContext.h. Member Data Documentation. ◆ _bufferIdx. std::size_t RooFit::EvalContext::_bufferIdx = 0. private . Definition at line 125 of file EvalContext.h. ◆ _buffers. std::vector<std::vector<double> > RooFit::EvalContext::_buffers. private . Definition at line 124 of file EvalContext.h. ◆ _cfgs. std::vector<RooBatchCompute::Config> RooFit::EvalContext::_cfgs. private . Definition at line 126 of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFit_1_1EvalContext.html:3525,reduce,reducer,3525,doc/master/classRooFit_1_1EvalContext.html,https://root.cern,https://root.cern/doc/master/classRooFit_1_1EvalContext.html,1,['reduce'],['reducer']
Energy Efficiency,"tfEnergyEnergy [GeV] ( LUJETS P[4] ); Int_tfFirstChildid of first child ( LUJETS K[4] ); Int_tfKFKF flavour code ( LUJETS K[2] ); Int_tfKSstatus of particle ( LUJETS K[1] ); Int_tfLastChildid of last child ( LUJETS K[5] ); Float_tfLifetimeproper lifetime [mm/c] ( LUJETS V[5] ); Float_tfMassMass [Gev/c^2] ( LUJETS P[5] ); Int_tfParentparrent's id ( LUJETS K[3] ); Float_tfPxX momenta [GeV/c] ( LUJETS P[1] ); Float_tfPyY momenta [GeV/c] ( LUJETS P[2] ); Float_tfPzZ momenta [GeV/c] ( LUJETS P[3] ); Float_tfTimetime of procuction [mm/c]( LUJETS V[4] ); Float_tfVxX vertex [mm] ( LUJETS V[1] ); Float_tfVyY vertex [mm] ( LUJETS V[2] ); Float_tfVzZ vertex [mm] ( LUJETS V[3] ). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ls(Option_t* option) const. const char * GetName() const; Return name of this particle via Pythia. TMCParticle(); {}. TMCParticle(Int_t kS, Int_t kF, Int_t parent, Int_t firstchild, Int_t lastchild, Float_t px, Float_t py, Float_t pz, Float_t energy, Float_t mass, Float_t vx, Float_t vy, Float_t vz, Float_t time, Float_t lifetime); { }. virtual ~TMCParticle(); { }. Int_t GetKS() const; {return fKS;}. Int_t GetKF() const; {return fKF;}. Int_t GetParent() const; {return fParent;}. Int_t GetFirstChild() const; {return fFirstChild;}. Int_t GetLastChild() const; {return fLastChild;}. Float_t GetPx() const; {return fPx;}. Float_t GetPy() const; {return fPy;}. Float_t GetPz() const; {return fPz;}. Float_t GetEnergy() const; {return fEnergy;}. Float_t GetMass() const; {return fMass;}. Float_t GetVx() const; {return fVx;}. Float_t GetVy() const; {return fVy;}. Float_t GetVz() const; {return fVz;}. Float_t GetTime() const; {return fTime;}. Float_t GetLifetime() const; {return fLifetime;}. void SetKS(Int_t kS); {fKS=kS;}. void SetKF(Int_t kF); {fKF=kF;}. void SetParent(Int_t parent); {fParent=parent;}. void SetFirstChild(Int_t first); {fFirstChild=first;}. void SetLastChild(Int_t last); {fLastChild=last;}. void SetPx(Fl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMCParticle.html:7908,energy,energy,7908,root/html528/TMCParticle.html,https://root.cern,https://root.cern/root/html528/TMCParticle.html,3,['energy'],['energy']
Energy Efficiency,"th ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This is a simplified version of ExpandCreate used in the TTree mechanism. TObject * RemoveAt(Int_t idx); Remove object at index idx. TObject * Remove(TObject* obj); Remove object from array. void RemoveRange(Int_t idx1, Int_t idx2); Remove objects from index idx1 to idx2 included. void SetClass(const TClass* cl, Int_t size = 1000); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument s indicates an approximate number of objects; that will be entered in the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClonesArray.html:18490,allocate,allocated,18490,root/html528/TClonesArray.html,https://root.cern,https://root.cern/root/html528/TClonesArray.html,2,['allocate'],['allocated']
Energy Efficiency,"th background) we obtain the result shown in Figure 5.5. Now the fitted function corresponds much better to experimental values. Fit of the original experimental spectrum (with background). We have implemented also the fitting function with matrix inversion based on Stiefel-Hestens method of the solution of the system of linear equations. The form of the function is as follows; char *Fit1Stiefel(float *source,; TSpectrumOneDimFit* p,; int size);; This function fits the source spectrum. The calling program should fill in input parameters of the one_dim_fit structure The fitted parameters are written into structure pointed by one_dim_fit structure pointer and fitted data are written into source spectrum.; Function parameters:. source pointer to the vector of source spectrum; p pointer to the one_dim_fit structure pointer; size length of source spectrum. The structure one_dim_fit is the same as in awmi function. The parameters power, fit_taylor are not applicable for this function; The results for small number of fitted parameters are the same as with awmi function. However it converges faster. The example for data given in Figure 5.1 is given in the following table:. # of iterationsi; Chi awmi; Chi-Stiefel. 1; 924; 89.042. 5; 773.15; 0.96242. 10; 38.13; 0.77041. 50; 0.90293; 0.76873. 100; 0.76886; 0.76873. 500; 0.76873; 0.76873. 5.2 2-DIMENSIONAL SPECTRA; it is straightforward that for two dimensional spectra one can write; \[; \Delta a_k^{(t+1)}=\alpha^{(t)}; \frac; {\sum_{i_1=1}^{N_1}\sum_{i_2=1}^{N_2}\frac{e_{i_1,i_2}^{(t)}}{y_{i_1,i_2}}; \frac{\partial f(i_1,i_2,a^{(t)})}{\partial a_k}}; {\sum_{i_1=1}^{N_1}\sum_{i_2=1}^{N_2}; \left[\frac{\partial f(i_1,i_2,a^{(t)})}{\partial a_k} \right]^2; \frac{1}{y_{i_1,i_2}}}; \]; analogously for two dimensional peaks we have chosen the peak shape function of the following form; \[; f(i_1,i_2,a) = \sum_{j=1}^{M}\left\{; \begin{array}{l}; A_{xy}(j) exp\left\{-\frac{1}{2(1-\rho^2)}\left[; \frac{(i_1-p_x(j))^2}{\sigma_x^2}; -\frac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:43351,power,power,43351,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,1,['power'],['power']
Energy Efficiency,"th entries (data) and writes them to storage.Definition RNTupleWriter.hxx:60; ROOT::Experimental::RNTupleWriter::FlushClustervoid FlushCluster()Flush so far filled entries to storage.Definition RNTupleWriter.hxx:117; ROOT::Experimental::RNTupleWriter::CreateModelUpdaterstd::unique_ptr< RNTupleModel::RUpdater > CreateModelUpdater()Get a RNTupleModel::RUpdater that provides limited support for incremental updates to the underlying ...Definition RNTupleWriter.hxx:161; ROOT::Experimental::RNTupleWriter::GetSinkInternal::RPageSink & GetSink()Definition RNTupleWriter.hxx:77; ROOT::Experimental::RNTupleWriter::GetMetricsconst Detail::RNTupleMetrics & GetMetrics() constDefinition RNTupleWriter.hxx:138; ROOT::Experimental::RNTupleWriter::GetLastCommittedClusterGroupNTupleSize_t GetLastCommittedClusterGroup() constReturn the entry number that was last committed in a cluster group.Definition RNTupleWriter.hxx:133; ROOT::Experimental::RNTupleWriter::fZipTasksstd::unique_ptr< Internal::RPageStorage::RTaskScheduler > fZipTasksThe page sink's parallel page compression scheduler if IMT is on.Definition RNTupleWriter.hxx:68; ROOT::Experimental::RNTupleWriter::FillNoFlushvoid FillNoFlush(REntry &entry, RNTupleFillStatus &status)Fill an entry into this ntuple, but don't commit the cluster.Definition RNTupleWriter.hxx:112; ROOT::Experimental::RNTupleWriter::GetModelconst RNTupleModel & GetModel() constDefinition RNTupleWriter.hxx:140; ROOT::Experimental::RNTupleWriter::FlushColumnsvoid FlushColumns()Flush column data, preparing for CommitCluster or to reduce memory usage.Definition RNTupleWriter.hxx:115; ROOT::Experimental::RNTupleWriter::Fillstd::size_t Fill()The simplest user interface if the default entry that comes with the ntuple model is used.Definition RNTupleWriter.hxx:105; ROOT::Experimental::RNTupleWriter::GetLastFlushedNTupleSize_t GetLastFlushed() constReturn the entry number that was last flushed in a cluster.Definition RNTupleWriter.hxx:129; ROOT::Experimental::RNTupleWrit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleWriter_8hxx_source.html:12018,schedul,scheduler,12018,doc/master/RNTupleWriter_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleWriter_8hxx_source.html,1,['schedul'],['scheduler']
Energy Efficiency,"th menubar and drawing area; TRootContextMenu ROOT native GUI context sensitive popup menu; TRootControlBar ROOT native GUI implementation of TControlBar; TRootDialog Native GUI method argument prompt dialog box; TRootEmbeddedCanvas A ROOT TCanvas that can be embedded in a TGFrame; TRootGuiBuilder ROOT GUI Builder; TRootGuiFactory Factory for ROOT GUI components; TRootHelpDialog Dialog to display help text; TRootSecContext Class providing host specific authentication information; TRotMatrix Rotation Matrix for 3-D geometry objects; TRotation Rotations of TVector3 objects; TRuby Ruby/ROOT interface; TSAXParser SAX Parser; TSPHE SPHE shape; TSPlot class to disentangle signal from background; TSQLClassColumnInfo Keeps information about single column in class table; TSQLClassInfo Keeps the table information relevant for one class ; TSQLColumnData Single SQL column data.; TSQLColumnInfo Summury information about column from SQL table; TSQLFile ROOT TFile interface to SQL database; TSQLMonitoringWriter Sending monitoring data to a SQL DB; TSQLObjectData Keeps the data requested from the SQL server for an object.; TSQLObjectDataPool XML object keeper class ; TSQLObjectInfo Info (classname, version) about object in database ; TSQLResult SQL query result; TSQLRow One row of an SQL query result; TSQLServer Connection to SQL server; TSQLStatement SQL statement; TSQLStructure Table/structure description used internally by YBufferSQL.; TSQLTableData Collection of columns data for single SQL table; TSQLTableInfo Summury information about SQL table; TSVG SVG driver; TSecContext Class providing host specific authentication information; TSecContextCleanup Update the remote authentication table; TSelector A utility class for tree and object processing; TSelectorCint A utility class for tree and object processing (interpreted version); TSelectorDraw A specialized TSelector for TTree::Draw; TSelectorEntries A specialized TSelector for TTree::GetEntries(selection); TSelectorList Special ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:115833,monitor,monitoring,115833,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['monitor'],['monitoring']
Energy Efficiency,"th:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kMISER; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kPLAIN; ROOT::Math:::GSLMCIntegrator. The control parameters for the integration algorithms can be specified using the ROOT::Math::IntegratorMultiDimOptions class. Static methods are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, or when using it via the ROOT::Math::IntegratorMultiDim interface, can be defined using the ROOT::Math::IntegratorMultiDimOptions.; 13.9 Function Derivation; Th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:712273,adapt,adaptive,712273,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['adapt'],['adaptive']
Energy Efficiency,"th::BoostY::kLZX@ kLZXDefinition BoostY.h:48; ROOT::Math::BoostY::kLZT@ kLZTDefinition BoostY.h:48; ROOT::Math::BoostY::kLYY@ kLYYDefinition BoostY.h:47; ROOT::Math::BoostY::kLTX@ kLTXDefinition BoostY.h:49; ROOT::Math::BoostY::kLZZ@ kLZZDefinition BoostY.h:48; ROOT::Math::BoostY::kLZY@ kLZYDefinition BoostY.h:48; ROOT::Math::BoostY::kLTZ@ kLTZDefinition BoostY.h:49; ROOT::Math::BoostY::kLXZ@ kLXZDefinition BoostY.h:46; ROOT::Math::BoostY::fBetaScalar fBetaDefinition BoostY.h:193; ROOT::Math::BoostY::GetLorentzRotationvoid GetLorentzRotation(Scalar r[]) constGet elements of internal 4x4 symmetric representation, into a data array suitable for direct use as t...Definition BoostY.cxx:55; ROOT::Math::BoostY::Rectifyvoid Rectify()Re-adjust components to eliminate small deviations from a perfect orthosyplectic matrix.Definition BoostY.cxx:63; ROOT::Math::DisplacementVector3DClass describing a generic displacement vector in 3 dimensions.Definition DisplacementVector3D.h:58; ROOT::Math::LorentzVectorClass describing a generic LorentzVector in the 4D space-time, using the specified coordinate system ...Definition LorentzVector.h:59; ROOT::Math::PxPyPzE4DClass describing a 4D cartesian coordinate system (x, y, z, t coordinates) or momentum-energy vectors...Definition PxPyPzE4D.h:44; double; ROOT::Math::betadouble beta(double x, double y)Calculates the beta function.Definition SpecFuncMathCore.cxx:111; yDouble_t y[n]Definition legend1.C:17; MathNamespace for new Math classes and functions.; ROOT::Math::GenVector::Throwvoid Throw(const char *)function throwing exception, by creating internally a GenVector_exception only when neededDefinition GenVector_exception.h:80; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; v@ vDefinition rootcling_impl.cxx:3699. mathgenvectorsrcBoostY.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:39 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BoostY_8cxx_source.html:6546,energy,energy,6546,doc/master/BoostY_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BoostY_8cxx_source.html,1,['energy'],['energy']
Energy Efficiency,"th::IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). IntegratorMultiDim(const Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000); Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). virtual ~IntegratorMultiDim(); destructor. IntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. double Result() const; return result of last integration. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const; return integration error. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const; return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IntegratorMultiDim.html:3714,adapt,adaptive,3714,root/html526/ROOT__Math__IntegratorMultiDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IntegratorMultiDim.html,1,['adapt'],['adaptive']
Energy Efficiency,"th::IntegratorOneDim&operator=(const ROOT::Math::IntegratorOneDim&). Data Members; private:. ROOT::Math::VirtualIntegratorOneDim*fIntegratorpointer to integrator interface class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetFunction(const Function & f). double Integral(const ROOT::Math::IGenFunction& f, double a, double b). double Integral(const Function & f). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). double IntegralUp(const ROOT::Math::IGenFunction& f, double a). double Integral(const Function & f, const std::vector<double> & pts). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). IntegratorOneDim(ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int size = 1000, unsigned int rule = 3); constructors. Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int size = 1000, int rule = 3). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IntegratorOneDim.html:4594,adapt,adaptive,4594,root/html526/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IntegratorOneDim.html,2,['adapt'],['adaptive']
Energy Efficiency,"th::PxPyPzM4D<Double32_t>::ScalarPx() const; ROOT::Math::PxPyPzM4D<Double32_t>PxPyPzM4D<Double32_t>(); ROOT::Math::PxPyPzM4D<Double32_t>PxPyPzM4D<Double32_t>(const ROOT::Math::PxPyPzM4D<Double32_t>& v); ROOT::Math::PxPyPzM4D<Double32_t>PxPyPzM4D<Double32_t>(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m); ROOT::Math::PxPyPzM4D<Double32_t>::ScalarPy() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarPz() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarR() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarRho() const; voidScale(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& a); voidSetCoordinates(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar* src); voidSetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m); voidSetE(Double32_t energy); voidSetEta(Double32_t eta); voidSetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m); voidSetPhi(Double32_t phi); voidSetPt(Double32_t pt); voidSetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); voidSetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e); voidSetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py); voidSetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz); ROOT::Math::PxPyPzM4D<Double32_t>::ScalarT() const; ROOT::Math::PxPyPzM4D<Double32_t>::Scalart() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarTheta() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarX() const; ROOT::Math::PxPyPzM4D<Double32_t>::Scalarx() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarY() const; ROOT::Math::PxPyPzM4D<Double32_t>::Scalary() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarZ() const; ROOT::Math::PxPyPzM4D<Double32_t>::Scalarz() const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html:3480,energy,energy,3480,root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html,5,['energy'],['energy']
Energy Efficiency,"thLock.cxx. ◆ GetLast(). Int_t TListOfEnumsWithLock::GetLast ; (; ); const. overridevirtual . Returns index of last object in collection. ; Returns -1 when no objects in collection. ; Reimplemented from TSeqCollection.; Definition at line 293 of file TListOfEnumsWithLock.cxx. ◆ GetObject(). TEnum * TListOfEnumsWithLock::GetObject ; (; const char * ; name); const. overridevirtual . Return an object from the list of enums if and only if is has already been loaded in the list. ; This is an internal routine. ; Reimplemented from TListOfEnums.; Definition at line 175 of file TListOfEnumsWithLock.cxx. ◆ GetObjectRef(). TObject ** TListOfEnumsWithLock::GetObjectRef ; (; const TObject * ; obj); const. overridevirtual . Return address of pointer to obj. ; Reimplemented from TList.; Definition at line 268 of file TListOfEnumsWithLock.cxx. ◆ GetSize(). Int_t TListOfEnumsWithLock::GetSize ; (; ); const. overridevirtual . Return the capacity of the collection, i.e. ; the current total amount of space that has been allocated so far. Same as Capacity. Use GetEntries to get the number of elements currently in the collection. ; Reimplemented from TCollection.; Definition at line 310 of file TListOfEnumsWithLock.cxx. ◆ IndexOf(). Int_t TListOfEnumsWithLock::IndexOf ; (; const TObject * ; obj); const. overridevirtual . Return index of object in collection. ; Returns -1 when object not found. Uses member IsEqual() to find object. ; Reimplemented from TSeqCollection.; Definition at line 301 of file TListOfEnumsWithLock.cxx. ◆ IsA(). TClass * TListOfEnumsWithLock::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TListOfEnums.; Definition at line 80 of file TListOfEnumsWithLock.h. ◆ Last(). TObject * TListOfEnumsWithLock::Last ; (; ); const. overridevirtual . Return the last object in the list. Returns 0 when list is empty. ; Reimplemented from TList.; Definition at line 276 of file TListOfEnumsWithLock.cxx. ◆ LastLink(). TObjLink * T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnumsWithLock.html:30020,allocate,allocated,30020,doc/master/classTListOfEnumsWithLock.html,https://root.cern,https://root.cern/doc/master/classTListOfEnumsWithLock.html,1,['allocate'],['allocated']
Energy Efficiency,"that we create; 5048 // as a result of creating this object.; 5049 // FIXME: Why do we do this?; 5050 // FIXME: Partial Answer: Is this because we may never actually deregister them???; 5051 ; 5052 Bool_t statsave = GetObjectStat();; 5053 if(statsave) {; 5054 SetObjectStat(kFALSE);; 5055 }; 5056 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 5057 if (!sinfo) {; 5058 if (!quiet); 5059 Error(""New"", ""Cannot construct class '%s' version %d, no streamer info available!"", GetName(), fClassVersion);; 5060 return nullptr;; 5061 }; 5062 ; 5063 {; 5064 TClass__GetCallingNewRAII callingNew(defConstructor);; 5065 p = { sinfo->New(), sinfo};; 5066 }; 5067 ; 5068 // FIXME: Mistake? See note above at the GetObjectStat() call.; 5069 // Allow TObject's to be registered again.; 5070 if(statsave) {; 5071 SetObjectStat(statsave);; 5072 }; 5073 ; 5074 if (!p) {; 5075 Error(""New"", ""Failed to construct class '%s' using streamer info"", GetName());; 5076 }; 5077 ; 5078 return p;; 5079 } else {; 5080 Fatal(""New"", ""This cannot happen!"");; 5081 }; 5082 ; 5083 return p;; 5084}; 5085 ; 5086////////////////////////////////////////////////////////////////////////////////; 5087/// Return a pointer to a newly allocated object of this class.; 5088/// The class must have a default constructor. For meaning of; 5089/// defConstructor, see TClass::IsCallingNew().; 5090 ; 5091void *TClass::New(void *arena, ENewType defConstructor) const; 5092{; 5093 auto obj = NewObject(arena, defConstructor);; 5094 if (obj.GetPtr() && obj.GetAllocator()) {; 5095 // Register the object for special handling in the destructor.; 5096 RegisterAddressInRepository(""TClass::New with placement"", obj.GetPtr(), this);; 5097 }; 5098 return obj.GetPtr();; 5099}; 5100 ; 5101////////////////////////////////////////////////////////////////////////////////; 5102/// Return a pointer to a newly allocated object of this class.; 5103/// The class must have a default constructor. For meaning of; 5104/// defConstructor, see TClass::IsCalling",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:193894,allocate,allocated,193894,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"that we create; 5115 // as a result of creating this object.; 5116 // FIXME: Why do we do this?; 5117 // FIXME: Partial Answer: Is this because we may never actually deregister them???; 5118 ; 5119 Bool_t statsave = GetObjectStat();; 5120 if(statsave) {; 5121 SetObjectStat(kFALSE);; 5122 }; 5123 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 5124 if (!sinfo) {; 5125 if (!quiet); 5126 Error(""New"", ""Cannot construct class '%s' version %d, no streamer info available!"", GetName(), fClassVersion);; 5127 return nullptr;; 5128 }; 5129 ; 5130 {; 5131 TClass__GetCallingNewRAII callingNew(defConstructor);; 5132 p = { sinfo->New(), sinfo};; 5133 }; 5134 ; 5135 // FIXME: Mistake? See note above at the GetObjectStat() call.; 5136 // Allow TObject's to be registered again.; 5137 if(statsave) {; 5138 SetObjectStat(statsave);; 5139 }; 5140 ; 5141 if (!p) {; 5142 Error(""New"", ""Failed to construct class '%s' using streamer info"", GetName());; 5143 }; 5144 ; 5145 return p;; 5146 } else {; 5147 Fatal(""New"", ""This cannot happen!"");; 5148 }; 5149 ; 5150 return p;; 5151}; 5152 ; 5153////////////////////////////////////////////////////////////////////////////////; 5154/// Return a pointer to a newly allocated object of this class.; 5155/// The class must have a default constructor. For meaning of; 5156/// defConstructor, see TClass::IsCallingNew().; 5157 ; 5158void *TClass::New(void *arena, ENewType defConstructor) const; 5159{; 5160 auto obj = NewObject(arena, defConstructor);; 5161 if (obj.GetPtr() && obj.GetAllocator()) {; 5162 // Register the object for special handling in the destructor.; 5163 RegisterAddressInRepository(""TClass::New with placement"", obj.GetPtr(), this);; 5164 }; 5165 return obj.GetPtr();; 5166}; 5167 ; 5168////////////////////////////////////////////////////////////////////////////////; 5169/// Return a pointer to a newly allocated object of this class.; 5170/// The class must have a default constructor. For meaning of; 5171/// defConstructor, see TClass::IsCalling",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:196645,allocate,allocated,196645,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"the actual stage status on selected files. 'process' field:; N, noaction: do nothing on the selected files; P, fullproc: open the selected files and extract the meta information; L, locateonly: only locate the selected files; S, stageonly: issue a stage request for the selected files not yet staged. 'auxilliary' field; V, verbose: notify the actions. Returns 0 on success, -1 if any failure occurs. Int_t ScanDataSet(const char* uri, UInt_t option = kReopen|kDebug); Scans the dataset indicated by <uri> and returns the number of missing files.; Returns -1 if any failure occurs.; For more details, see documentation of; ScanDataSet(TFileCollection *dataset, const char *option). void GetQuota(const char* group, const char* user, const char* dsName, TFileCollection* dataset). Gets quota information from this dataset. void ShowQuota(const char* opt); Display quota information. void PrintUsedSpace(). Prints the quota. void MonitorUsedSpace(TVirtualMonitoringWriter* monitoring). Log info to the monitoring server. Long64_t GetGroupUsed(const char* group). Returns the used space of that group. Long64_t GetGroupQuota(const char* group). returns the quota a group is allowed to have. void UpdateUsedSpace(); updates the used space maps. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings, if needed.; Returns 0 on success, -1 on failure. Int_t NotifyUpdate(const char* group = 0, const char* user = 0, const char* dspath = 0, Long_t mtime = 0, const char* checksum = 0); Save into the <datasetdir>/dataset.list file the name of the last updated; or created or modified dataset; Returns 0 on success, -1 on error. Int_t ClearCache(const char* uri); Clear cached information matching uri. Int_t ShowCache(const char* uri); Show cached information matching uri. TString CreateUri(const char* dsGroup = 0, const char* dsUser = 0, const char* dsName = 0, const char* dsTree = 0); Creates URI for the dataset manger in the fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSetManager.html:13416,monitor,monitoring,13416,root/html528/TDataSetManager.html,https://root.cern,https://root.cern/root/html528/TDataSetManager.html,3,['monitor'],['monitoring']
Energy Efficiency,"the case of an exponential function, the bias that you get by; // evaluating the pdf only at the bin centers is a constant scale factor in; // each bin. Here, we can do a trick to get rid of the bias: we also; // evaluate the normalization integral for the pdf the same way, i.e.,; // summing the values of the unnormalized pdf at the bin centers. Like this; // the bias cancels out. You can achieve this by customizing the way how the; // pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins());; std::unique_ptr<RooFitResult> fit2{expo.fitTo(*expoData, Save(), PrintLevel(-1), SumW2Error(false))};; fit2->Print();; disableBinIntegrator(expo);; ; // Power law example; // -----------------; ; // Let's not look at another example: a power law \f[x^a\f].; RooRealVar a{""a"", ""a"", -0.3, -5.0, 5.0};; RooPowerSum powerlaw{""powerlaw"", ""powerlaw"", x, RooConst(1.0), a};; std::unique_ptr<RooAbsData> powerlawData{generateBinnedAsimov(powerlaw, x, 10000)};; ; // Again, if you do a vanilla fit, you'll get a bias; std::unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins());; std::unique_ptr<RooFitResult> fit4{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit4->Print();; disableBinIntegrator(powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:4331,power,powerlawData,4331,doc/master/rf614__binned__fit__problems_8C.html,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html,3,['power'],"['powerlaw', 'powerlawData']"
Energy Efficiency,"the data type is the pair<key,value>. void Commit(void* env); Commit the change. void PushProxy(void* objstart); Add an object. void PopProxy(); Remove the last object. void DeleteItem(Bool_t force, void* ptr) const; Call to delete/destruct individual item. void ReadBuffer(TBuffer& b, void* obj, const TClass* onfileClass). void ReadBuffer(TBuffer& b, void* obj). void Streamer(TBuffer& refBuffer); Streamer Function. void Streamer(TBuffer& refBuffer, void* pObject, int siz); Streamer I/O overload. void operator()(TBuffer& refBuffer, void* pObject); TClassStreamer IO overload. TVirtualCollectionProxy::CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); See typedef void (*CreateIterators_t)(void *collection, void *&begin_arena, void *&end_arena);; begin_arena and end_arena should contain the location of memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. TVirtualCollectionProxy::CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE); See typedef void (*CopyIterator_t)(void *&dest, const void *source);; Copy the iterator source, into dest. dest should contain should contain the location of memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterator will be constructed in place in this location (new with placement); Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest. TVirtualCollectionProxy::Next_t GetFunctionNext(Bool_t read = kTRUE); See typedef void* (*Next_t)(void *iter, void *end);; iter and end should be pointer to respectively an iterator to be incremented and the result of colleciton.end(); 'Next' will increment the iterator 'iter' and return 0 if the iterator reached the end.; If t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGenCollectionProxy.html:9940,allocate,allocated,9940,root/html602/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html602/TGenCollectionProxy.html,2,['allocate'],['allocated']
Energy Efficiency,"the given tagName.; 902 * <tr><td> `Verbose(bool flag)` <td> Controls RooFit informational messages in likelihood construction; 903 * <tr><td> `CloneData(bool flag)` <td> Use clone of dataset in NLL (default is true).; 904 * \warning Deprecated option that is ignored. It is up to the implementation of the NLL creation method if the data is cloned or not.; 905 * <tr><td> `Offset(std::string const& mode)` <td> Likelihood offsetting mode. Can be either:; 906 * <table>; 907 * <tr><th> Mode <th> Description; 908 * <tr><td> **none** - *default* <td> No offsetting.; 909 * <tr><td> **initial** <td> Offset likelihood by initial value (so that starting value of FCN in minuit is zero).; 910 * This can improve numeric stability in simultaneous fits with components with large likelihood values.; 911 * <tr><td> **bin** <td> Offset likelihood bin-by-bin with a template histogram model based on the obersved data.; 912 * This results in per-bin values that are all in the same order of magnitude, which reduces precision loss in the sum,; 913 * which can drastically improve numeric stability.; 914 * Furthermore, \f$2\cdot \text{NLL}\f$ defined like this is approximately chi-square distributed, allowing for goodness-of-fit tests.; 915 * </table>; 916 * <tr><td> `IntegrateBins(double precision)` <td> In binned fits, integrate the PDF over the bins instead of using the probability density at the bin centre.; 917 * This can reduce the bias observed when fitting functions with high curvature to binned data.; 918 * - precision > 0: Activate bin integration everywhere. Use precision between 0.01 and 1.E-6, depending on binning.; 919 * Note that a low precision such as 0.01 might yield identical results to 1.E-4, since the integrator might reach 1.E-4 already in its first; 920 * integration step. If lower precision is desired (more speed), a RooBinSamplingPdf has to be created manually, and its integrator; 921 * has to be manipulated directly.; 922 * - precision = 0: Activate bin integration ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:41303,reduce,reduces,41303,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['reduce'],['reduces']
Energy Efficiency,"the list of names of the packages available. TList * GetListOfEnabledPackages(); Get from the master the list of names of the packages enabled. void PrintProgress(Long64_t total, Long64_t processed, Float_t procTime = -1., Long64_t bytesread = -1); Print a progress bar on stderr. Used in batch mode. void Progress(Long64_t total, Long64_t processed); Get query progress information. Connect a slot to this signal; to track progress. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Get query progress information. Connect a slot to this signal; to track progress. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); Get query progress information. Connect a slot to this signal; to track progress. void Feedback(TList* objs); Get list of feedback objects. Connect a slot to this signal; to monitor the feedback object. void CloseProgressDialog(); Close progress dialog. void ResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); Reset progress dialog. void StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total); Send startup message. void DataSetStatus(const char* msg, Bool_t status, Int_t done, Int_t total); Send dataset preparation status. void SendDataSetStatus(const char* msg, UInt_t n, UInt_t tot, Bool_t st); Send or notify data set status. void QueryResultReady(const char* ref); Notify availability of a query result. void ValidateDSet(TDSet* dset); Validate a TDSet. void AddInputData(TObject* obj, Bool_t push = kFALSE); Add data objects that might be needed during the processing of; the selector (see Process()). This object can be very large, so they; are distributed in an optimized way using a dedicated file.; If push is TRUE the input data are sent over even if no apparent change; occured to the list. void ClearInputData(TObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:70531,monitor,monitor,70531,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,6,['monitor'],['monitor']
Energy Efficiency,"the negative sign; 2160 if (value < 0) buf += '-';; 2161 std::reverse(buf.begin(), buf.end());; 2162 return (TString(buf.data()));; 2163}; 2164 ; 2165////////////////////////////////////////////////////////////////////////////////; 2166/// Converts a ULong64_t (twice the range of an Long64_t) to a TString with; 2167/// respect to the base specified (2-36). Thus it is an enhanced version of; 2168/// sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2169/// In case of error returns the ""!"" string.; 2170 ; 2171TString TString::ULLtoa(ULong64_t value, Int_t base); 2172{; 2173 std::string buf;; 2174 // check that the base if valid; 2175 if (base < 2 || base > 36) {; 2176 Error(""TString::ULLtoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2177 return (TString(""!""));; 2178 }; 2179 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2180 ULong64_t quotient = value;; 2181 // Translating number to string with base:; 2182 do {; 2183 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ quotient % base ];; 2184 quotient /= base;; 2185 } while (quotient);; 2186 std::reverse(buf.begin(), buf.end());; 2187 return (TString(buf.data()));; 2188}; 2189 ; 2190////////////////////////////////////////////////////////////////////////////////; 2191/// Converts string from base base_in to base base_out. Supported bases; 2192/// are 2-36. At most 64 bit data can be converted.; 2193 ; 2194TString TString::BaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); 2195{; 2196 TString s_out = ""!"" ; // return value in case of issue; 2197 // checking base range; 2198 if (base_in < 2 || base_in > 36 || base_out < 2 || base_out > 36) {; 2199 Error(""TString::BaseConvert"", ""only bases 2-36 are supported (base_in=%d, base_out=%d)."", base_in, base_out);; 2200 return (s_out);; 2201 }; 2202 // cleaning s_in; 2203 TString s_in_ = s_in;; 2204 Bool_t isSigned = kFALSE;; 2205 if (s_in_[0] == '-') {; 2206 isSigned = kTRUE;; 2207 s_in_.Rem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:69163,allocate,allocate,69163,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,the number of floats read. If argument is a 0 pointer then space will be allocated for the array. ; Implements TBuffer.; Definition at line 901 of file TBufferFile.cxx. ◆ ReadArray() [5/13]. Int_t TBufferFile::ReadArray ; (; Int_t *& ; ii). overridevirtual . Read array of ints from the I/O buffer. ; Returns the number of ints read. If argument is a 0 pointer then space will be allocated for the array. ; Implements TBuffer.; Definition at line 814 of file TBufferFile.cxx. ◆ ReadArray() [6/13]. Int_t TBufferFile::ReadArray ; (; Long64_t *& ; ll). overridevirtual . Read array of long longs from the I/O buffer. ; Returns the number of long longs read. If argument is a 0 pointer then space will be allocated for the array. ; Implements TBuffer.; Definition at line 873 of file TBufferFile.cxx. ◆ ReadArray() [7/13]. Int_t TBufferFile::ReadArray ; (; Long_t *& ; ll). overridevirtual . Read array of longs from the I/O buffer. ; Returns the number of longs read. If argument is a 0 pointer then space will be allocated for the array. ; Implements TBuffer.; Definition at line 847 of file TBufferFile.cxx. ◆ ReadArray() [8/13]. Int_t TBufferFile::ReadArray ; (; Short_t *& ; h). overridevirtual . Read array of shorts from the I/O buffer. ; Returns the number of shorts read. If argument is a 0 pointer then space will be allocated for the array. ; Implements TBuffer.; Definition at line 781 of file TBufferFile.cxx. ◆ ReadArray() [9/13]. Int_t TBufferFile::ReadArray ; (; UChar_t *& ; c). inlineoverridevirtual . Implements TBuffer.; Definition at line 456 of file TBufferFile.h. ◆ ReadArray() [10/13]. Int_t TBufferFile::ReadArray ; (; UInt_t *& ; i). inlineoverridevirtual . Implements TBuffer.; Definition at line 462 of file TBufferFile.h. ◆ ReadArray() [11/13]. Int_t TBufferFile::ReadArray ; (; ULong64_t *& ; l). inlineoverridevirtual . Implements TBuffer.; Definition at line 468 of file TBufferFile.h. ◆ ReadArray() [12/13]. Int_t TBufferFile::ReadArray ; (; ULong_t *& ; l). inlineoverri,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:48046,allocate,allocated,48046,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['allocate'],['allocated']
Energy Efficiency,"the old array to the new. This can be costly if done too often. If possible, set initial size close to expected final size. Index validity is always checked (if you are 100% sure and maximum performance is needed you can use UnCheckedAt() instead of At() or operator[]). If the stored objects are sort able the array can be sorted using Sort(). Once sorted, efficient searching is possible via the BinarySearch() method. The figure shows the internal data structure of a TObjArray:. The internal data structure of a TObjArray. Iterating can be done using a TIter iterator or via a simple for loop:; for (int i = 0; i <= fArr.GetLast(); i++); if ((track = (TTrack*)fArr[i])) // or fArr.At(i); track->Draw();; Main features of TObjArray are simple, well-known array semantics. Overhead per element: none, except possible over sizing of fCont.; 16.8 TClonesArray An Array of Identical Objects; A TClonesArray is an array of identical (clone) objects. The memory for the objects stored in the array is allocated only once in the lifetime of the clones array. All objects must be of the same class. For the rest this class has the same properties as a TObjArray. The internal data structure of a TClonesArray. The figure above shows the internal data structure of a TClonesArray. The class is specially designed for repetitive data analysis tasks, where in a loop many times the same objects, are created and deleted. The only supported way to add objects to a TClonesArray is via the new with placement method. The different Add() methods of TObjArray and its base classes are not supported.; 16.8.1 The Idea Behind TClonesArray; To reduce the very large number of new and delete calls in large loops like this (O(100000) x O(10000) times new/delete):; TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); a[i] = new TTrack(x,y,z,...);; ...; }; ...; a.Delete();; }; You better use a TClonesArray which reduces the number of new/de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:853931,allocate,allocated,853931,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['allocate'],['allocated']
Energy Efficiency,"the pad will be used for ref. ; Definition at line 132 of file TAxis.cxx. ◆ Class(). static TClass * TAxis::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TAxis::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TAxis::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 177 of file TAxis.h. ◆ Copy(). void TAxis::Copy ; (; TObject & ; axis); const. overridevirtual . Copy axis structure to another axis. ; Reimplemented from TObject.; Definition at line 216 of file TAxis.cxx. ◆ DeclFileName(). static const char * TAxis::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 177 of file TAxis.h. ◆ Delete(). void TAxis::Delete ; (; Option_t * ; option = """"). inlineoverridevirtual . Delete this object. ; Typically called as a command via the interpreter. Normally use ""delete"" operator when object has been allocated on the heap. ; Reimplemented from TObject.; Definition at line 102 of file TAxis.h. ◆ DistancetoPrimitive(). Int_t TAxis::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Compute distance from point px,py to an axis. ; Reimplemented from TObject.; Definition at line 265 of file TAxis.cxx. ◆ DrawClone(). TObject * TAxis::DrawClone ; (; Option_t * ; option = """"); const. inlineoverridevirtual . Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ; If pad was not selected - gPad will be used. ; Reimplemented from TObject.; Definition at line 104 of file TAxis.h. ◆ ExecuteEvent(). void TAxis::ExecuteEvent ; (; Int_t ; event, . Int_t ; px, . Int_t ; py . ). overridevirtual . Execute action corresponding to one event. ; This member function is called when an axis is clicked with the locator. The axis range is set between the position where the mouse is pressed and the position where it is released. If the mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAxis.html:28066,allocate,allocated,28066,doc/master/classTAxis.html,https://root.cern,https://root.cern/doc/master/classTAxis.html,1,['allocate'],['allocated']
Energy Efficiency,"the powers PLUS ONE. For example, to De select the function f = x1^2 * x2^4 * x3^5, this method should return kFALSE if given the argument { 3, 4, 6 } ; Definition at line 2365 of file TMultiDimFit.cxx. ◆ SetBinVarX(). void TMultiDimFit::SetBinVarX ; (; Int_t ; nbbinvarx). inline . Definition at line 195 of file TMultiDimFit.h. ◆ SetBinVarY(). void TMultiDimFit::SetBinVarY ; (; Int_t ; nbbinvary). inline . Definition at line 196 of file TMultiDimFit.h. ◆ SetMaxAngle(). void TMultiDimFit::SetMaxAngle ; (; Double_t ; ang = 0). Set the max angle (in degrees) between the initial data vector to be fitted, and the new candidate function to be included in the fit. ; By default it is 0, which automatically chooses another selection criteria. See also class description ; Definition at line 2377 of file TMultiDimFit.cxx. ◆ SetMaxFunctions(). void TMultiDimFit::SetMaxFunctions ; (; Int_t ; n). inline . Definition at line 198 of file TMultiDimFit.h. ◆ SetMaxPowers(). void TMultiDimFit::SetMaxPowers ; (; const Int_t * ; powers). Set the maximum power to be considered in the fit for each variable. ; See also class description ; Definition at line 2443 of file TMultiDimFit.cxx. ◆ SetMaxStudy(). void TMultiDimFit::SetMaxStudy ; (; Int_t ; n). inline . Definition at line 200 of file TMultiDimFit.h. ◆ SetMaxTerms(). void TMultiDimFit::SetMaxTerms ; (; Int_t ; terms). inline . Definition at line 201 of file TMultiDimFit.h. ◆ SetMinAngle(). void TMultiDimFit::SetMinAngle ; (; Double_t ; ang = 1). Set the min angle (in degrees) between a new candidate function and the subspace spanned by the previously accepted functions. ; See also class description ; Definition at line 2393 of file TMultiDimFit.cxx. ◆ SetMinRelativeError(). void TMultiDimFit::SetMinRelativeError ; (; Double_t ; error). Set the acceptable relative error for when sum of square residuals is considered minimized. ; For a full account, refer to the class description ; Definition at line 2458 of file TMultiDimFit.cxx. ◆ Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:58396,power,powers,58396,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['power'],['powers']
Energy Efficiency,"the source spectrum; p: pointer to the two_dim_fit structure pointer, see manual; sizex: length x of the source spectrum; sizey: length y of the source spectrum. The two_dim_fit structure has the form of; class TSpectrumTwoDimFit{. public:. int number_of_peaks; // input parameter, should be>0; int number_of_iterations; // input parameter, should be >0; int xmin; // first fitted channel in x direction; int xmax; // last fitted channel in x direction; int ymin; // first fitted channel in y direction; int ymax; // last fitted channel in y direction; double alpha; // convergence coefficient, input parameter, it should be a positive number and <=1; double chi; // here the function returns resulting chi square; int statistic_type; // type of statistics, possible values are:; // FIT2_OPTIM_CHI_COUNTS (chi square statistics with counts as weighting coefficients),; // FIT2_OPTIM_CHI_FUNC_VALUES (chi square statistics with function values as weighting coefficients),; // FIT2_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values are:; // FIT2_ALPHA_HALVING, FIT2_ALPHA_OPTIMAL; int power; // possible values are: FIT21_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values are:; // FIT2_TAYLOR_ORDER_FIRST,; // FIT2_TAYLOR_ORDER_SECOND; double position_init_x[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 2D peaks, input parameters; double position_calc_x[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 2D peaks, output parameters; double position_err_x[MAX_NUMBER_OF_PEAKS2]; // x position errors of 2D peaks; bool fix_position_x[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate x positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_y[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 2D peaks, input parameters; double position_calc_y[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:47180,power,power,47180,root/htmldoc/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html,1,['power'],['power']
Energy Efficiency,"the sum simplifies to \( \frac{1}{2}\). The Fisher discriminant then reads. \[; X_{Fi} = F_0 + \sum_{i=1}^{N_{SB}} F_i X_i; \]. The offset \( F_0 \) centers the sample mean of \( x_{Fi} \) at zero. Instead of using the within-class matrix, the Mahalanobis variant determines the Fisher coefficients as follows:. \[; F_i = \frac{\sqrt{N_s N_b}}{N_s + N_b} \sum_{j=1}^{N_{SB}} (W + B)_{ij}^{-1} (\bar{X}_{Sj} - \bar{X}_{Bj}); \]. with resulting \( x_{Ma} \) that are very similar to the \( x_{Fi} \).; TMVA provides two outputs for the ranking of the input variables:. Fisher test: the Fisher analysis aims at simultaneously maximising the between-class separation, while minimising the within-class dispersion. A useful measure of the discrimination power of a variable is hence given by the diagonal quantity: \( \frac{B_{ii}}{W_{ii}} \) .; Discrimination power: the value of the Fisher coefficient is a measure of the discriminating power of a variable. The discrimination power of set of input variables can therefore be measured by the scalar. \[; \lambda = \frac{\sqrt{N_s N_b}}{N_s + N_b} \sum_{j=1}^{N_{SB}} F_i (\bar{X}_{Sj} - \bar{X}_{Bj}); \]. The corresponding numbers are printed on standard output. ; Definition at line 54 of file MethodFisher.h. Public Types; enum  EFisherMethod { kFisher; , kMahalanobis; };  ;  Public Types inherited from TMVA::MethodBase; enum  EWeightFileType { kROOT =0; , kTEXT; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodFisher.html:2920,power,power,2920,doc/master/classTMVA_1_1MethodFisher.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodFisher.html,1,['power'],['power']
Energy Efficiency,"the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when; . Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class.; . Limiting the Number of Terms; . As always when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms).; ; However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers).; ; One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5].; ; There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if; . where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out).; . Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see 2.3).; ; The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-poin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiDimFit.html:4050,power,power,4050,root/html534/TMultiDimFit.html,https://root.cern,https://root.cern/root/html534/TMultiDimFit.html,3,['power'],['power']
Energy Efficiency,"ther linear algebra packages, just set the tolerance; with SetTol to an arbitrary small number . The tolerance number is used by each decomposition method to decide; whether the matrix is near singular, except of course SVD which can; handle singular matrices .; For each decomposition this will be checked in a different way; in LU; the matrix is considered singular when, at some point in the; decomposition, a diagonal element < fTol . Therefore, we had to set in; the example above of the (10x10) Hilbert, which is near singular, the; tolerance on 10e-12 . (The fact that we have to set the tolerance <; sqrt(epsilon) is a clear indication that we are losing precision .). If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices/vectors that are; invalid . The observant reader will notice that by scaling the complete matrix; by some small number the decomposition will detect a singular matrix .; In this case the user will have to reduce the tolerance number by this; factor . (For CPU time saving we decided not to make this an automatic; procedure) . Code for this could look as follows:; const Double_t max_abs = Abs(a).Max();; const Double_t scale = TMath::Min(max_abs,1.);; a.SetTol(a.GetTol()*scale);. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TDecompBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tCondition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDecompBase.html:3750,reduce,reduce,3750,root/html528/TDecompBase.html,https://root.cern,https://root.cern/root/html528/TDecompBase.html,6,['reduce'],['reduce']
Energy Efficiency,"ther signals have no other behavior then that to call any registered TSignalHandler::Notify().; When building in interactive application the use of the TRint object handles the kSigInterrupt signal. It causes the printing of the message: *** Break *** keyboard interruptand makes a long jump back to the ROOT command prompt. If no TRint object is created, there will be no kSigInterrupt handling. All signals can be reset to their default UNIX behavior via the call of TSytem::ResetSignal(). All signals can be ignored via TSytem::IgnoreSignal(). The TSytem::IgnoreInterrupt() is a method to toggle the handling of the interrupt signal. Typically it is called to prevent a SIGINT to interrupt some important call (like writing to a ROOT file).; If TRint is used and the default ROOT interrupt handler is not desired, you should use GetSignalHandler() of TApplication to get the interrupt handler and to remove it by RemoveSignalHandler()of TSystem .; 23.5 Glossary; The following glossary is adapted from the description of the Rogue Wave Threads.h++ package.; A process is a program that is loaded into memory and prepared for execution. Each process has a private address space. Processes begin with a single thread.; A thread is a sequence of instructions being executed in a program. A thread has a program counter and a private stack to keep track of local variables and return addresses. A multithreaded process is associated with one or more threads. Threads execute independently. All threads in a given process share the private address space of that process.; Concurrency exists when at least two threads are in progress at the same time. A system with only a single processor can support concurrency by switching execution contexts among multiple threads.; Parallelism arises when at least two threads are executing simultaneously. This requires a system with multiple processors. Parallelism implies concurrency, but not vice-versa.; A function is reentrant if it will behave correctly eve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1119352,adapt,adapted,1119352,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['adapt'],['adapted']
Energy Efficiency,"these are just the extreme points of the contour (use the MnContours::contour(…) method in order to get the points of the contour and the ones of the \(\mbox{MINOS}\) errors). MnContours::operator() returns a std::vector\(<\)std::pair\(<\)double,double\(> >\) of (x,y) points. Using MnPlot::operator() will generate a text graphics plot in the terminal.; 3 M installation; 3.1 M releases; To follow the current release process the user is referred to the M homepage @bib-C++MINUIT.; M was re–implemented in from 2002–2004, but the functionality is largely compatible with the one of the version. The usage is different in the sense that the re–write from to was done by its signification and not literally (with minor exceptions). Applications such as \(\mbox{MIGRAD}\) have a corresponding class MnMigrad, M “commands” became classes or methods of classes according to their purpose. Users familiar with the version of M , who have not yet used releases from the version, should however read this manual, in order to adapt to the changes as well as to discover the new features and easier ways of using old features.; 3.2 Install M using autoconf/make; For each release of M a tar.gz file is provided for downloading from the M homepage @bib-C++MINUIT. For non-UNIX platforms please refer to the M homepage.; The necessary steps to follow are:. download the tar.gz by clicking on it from the release page; unzip it:; $ unzip Minuit-x.x.x.tar.gz; untar it:; $ tar xvf Minuit-x.x.x.tar; step down to the created Minuit-x.x.x directory:; $ cd Minuit-x.x.x/; run the “configure” script:; $ ./configure; run “make” to compile the source code:; $ make; run “make check” to create the executable example:; $ make check; run the executable example:; $ tests/MnTutorial/Quad4FMain.C. The output should look like that:; Minuit did successfully converge. # of function calls: 74; minimum function value: 1.12392e-09; minimum edm: 1.12392e-09; minimum internal state vector: LAVector parameters:. -1.82079e-05; -",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:27425,adapt,adapt,27425,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['adapt'],['adapt']
Energy Efficiency,"this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 112 of file RooRealSumFunc.cxx. ◆ forceAnalyticalInt(). bool RooRealSumFunc::forceAnalyticalInt ; (; const RooAbsArg & ; arg); const. inlineoverridevirtual . Reimplemented from RooAbsReal.; Definition at line 39 of file RooRealSumFunc.h. ◆ funcList(). const RooArgList & RooRealSumFunc::funcList ; (; ); const. inline . Definition at line 44 of file RooRealSumFunc.h. ◆ getAnalyticalIntegralWN(). Int_t RooRealSumFunc::getAnalyticalIntegralWN ; (; RooArgSet & ; allDeps, . RooArgSet & ; analDeps, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Variant of getAnalyticalIntegral that is also passed the normalization set that should be applied to the integrand of which the integral is requested. ; For certain operator p.d.f it is useful to overload this function rather than analyticalIntegralWN() as the additional normalization information may be useful in determining a more efficient decomposition of the requested integral. ; Reimplemented from RooAbsReal.; Definition at line 129 of file RooRealSumFunc.cxx. ◆ getFloor(). bool RooRealSumFunc::getFloor ; (; ); const. inline . Definition at line 54 of file RooRealSumFunc.h. ◆ getFloorGlobal(). static bool RooRealSumFunc::getFloorGlobal ; (; ). inlinestatic . Definition at line 56 of file RooRealSumFunc.h. ◆ IsA(). TClass * RooRealSumFunc::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsReal.; Definition at line 78 of file RooRealSumFunc.h. ◆ isBinnedDistribution(). bool RooRealSumFunc::isBinnedDistribution ; (; const RooArgSet & ; ); const. overridevirtual . Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ; Reimplemented from RooAbsReal.; Definition at line 148 of file RooRealSumFunc.cxx. ◆ plotSamplingHint(). std::list< double > * RooRealSum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumFunc.html:66602,efficient,efficient,66602,doc/v632/classRooRealSumFunc.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumFunc.html,2,['efficient'],['efficient']
Energy Efficiency,"this call. If match is found, function returns position of element. If no match found, function gives nearest element smaller than value. ; Definition at line 347 of file TMathBase.h. ◆ Binomial(). Double_t TMath::Binomial ; (; Int_t ; n, . Int_t ; k . ). Calculates the binomial coefficient n over k. ; Definition at line 2111 of file TMath.cxx. ◆ BinomialI(). Double_t TMath::BinomialI ; (; Double_t ; p, . Int_t ; n, . Int_t ; k . ). Suppose an event occurs with probability p per trial Then the probability P of its occurring k or more times in n trials is termed a cumulative binomial probability the formula is: ; P = sum_from_j=k_to_n(TMath::Binomial (n, j)**TMath::Power (p, j)*TMath::Power (1-p, n-j); pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; nconst Int_t nDefinition legend1.C:16; TMath::BinomialDouble_t Binomial(Int_t n, Int_t k)Calculates the binomial coefficient n over k.Definition TMath.cxx:2111; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; For n larger than 12 BetaIncomplete is a much better way to evaluate the sum than would be the straightforward sum calculation for n smaller than 12 either method is acceptable (""Numerical Recipes""); Note this function is not exactly implementing the cumulative or the complement of the cumulative of the Binomial distrinution. It is equivalent to ROOT::Math::binomial_cdf_c(k-1,p,n); AuthorAnna Kreshuk ; Definition at line 2141 of file TMath.cxx. ◆ BreitWigner(). Double_t TMath::BreitWigner ; (; Double_t ; x, . Double_t ; mean = 0, . Double_t ; gamma = 1 . ). Calculates a Breit Wigner function with mean and gamma. ; Definition at line 442 of file TMath.cxx. ◆ BreitWignerRelativistic(). Double_t TMath::BreitWignerRelativistic ; (; Double_t ; x, . Double_t ; median = 0, . Double_t ; gamma = 1 . ). Calculates a Relativistic Breit Wigner function with median and gamma. ; Definition at line 452 of file TMath.cxx. ◆ Bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:33371,power,power,33371,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['power'],['power']
Energy Efficiency,"thodPDERS through from file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); PDERS can handle classification with 2 classes and regression with one or more regression-targets. void Init( void ); default initialisation routine called by all constructors. ~MethodPDERS( void ); destructor. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; VolumeRangeMode <string> Method to determine volume range; available values are: MinMax; Unscaled; RMS; kNN; Adaptive <default>. KernelEstimator <string> Kernel estimation function; available values are: Box <default>; Sphere; Teepee; Gauss; Sinc3; Sinc5; Sinc7; Sinc9; Sinc11; Lanczos2; Lanczos3; Lanczos5; Lanczos8; Trim. DeltaFrac <float> Ratio of #EventsMin/#EventsMax for MinMax and RMS volume range; NEventsMin <int> Minimum number of events for adaptive volume range; NEventsMax <int> Maximum number of events for adaptive volume range; MaxVIterations <int> Maximum number of iterations for adaptive volume range; InitialScale <float> Initial scale for adaptive volume range; GaussSigma <float> Width with respect to the volume size of Gaussian kernel estimator. void ProcessOptions(); process the options specified by the user. void Train( void ); this is a dummy training: the preparation work to do is the construction; of the binary tree as a pointer chain. It is easier to directly save the; trainingTree in the weight file, and to rebuild the binary tree in the; test phase from scratch. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); init the size of a volume element using a defined fraction of the; volume containing the entire events. const std::vector< Float_t >& GetRegressionValues(). void CalcAverages(); compute also average RMS values required for adaptive Gaussian. void CreateBinarySearchTree(TMVA::Types::ETreeType type); create binary search trees for signal and background. void SetVolumeElement( voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodPDERS.html:21058,adapt,adaptive,21058,root/html528/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDERS.html,24,['adapt'],['adaptive']
Energy Efficiency,"thout mirroring over data; frame = x.frame(Title=""Adaptive kernel estimation pdf with and w/o mirroring"", Bins=20); data1.plotOn(frame); kest1.plotOn(frame); kest2.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Plot kernel estimation pdfs with regular and increased bandwidth; frame2 = x.frame(Title=""Adaptive kernel estimation pdf with regular, bandwidth""); kest1.plotOn(frame2); kest3.plotOn(frame2, LineColor=""m""); ; # Create low status 2D dataset; # -------------------------------------------------------; ; # Construct a 2D toy pdf for sampleing; y = ROOT.RooRealVar(""y"", ""y"", 0, 20); py = ROOT.RooPolynomial(; ""py"",; ""py"",; y,; [0.01, 0.01, -0.0004],; ); pxy = ROOT.RooProdPdf(""pxy"", ""pxy"", [p, py]); data2 = pxy.generate({x, y}, 1000); ; # Create 2D kernel estimation pdf; # ---------------------------------------------------------------; ; # Create 2D adaptive kernel estimation pdf with mirroring; kest4 = ROOT.RooNDKeysPdf(""kest4"", ""kest4"", [x, y], data2, ""am""); ; # Create 2D adaptive kernel estimation pdf with mirroring and double; # bandwidth; kest5 = ROOT.RooNDKeysPdf(""kest5"", ""kest5"", [x, y], data2, ""am"", 2); ; # Create a histogram of the data; hh_data = data2.createHistogram(""hh_data"", x, Binning=10, YVar=dict(var=y, Binning=10)); ; # Create histogram of the 2d kernel estimation pdfs; hh_pdf = kest4.createHistogram(""hh_pdf"", x, Binning=25, YVar=dict(var=y, Binning=25)); hh_pdf2 = kest5.createHistogram(""hh_pdf2"", x, Binning=25, YVar=dict(var=y, Binning=25)); hh_pdf.SetLineColor(ROOT.kBlue); hh_pdf2.SetLineColor(ROOT.kMagenta); ; c = ROOT.TCanvas(""rf707_kernelestimation"", ""rf707_kernelestimation"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.8); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); hh_data.GetZaxis().SetTitleOffset(1.4); hh_data.Draw(""lego""); c.cd(4); ROOT.gPad.SetLeftMargin(0.20); hh_pdf.GetZaxis()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf707__kernelestimation_8py.html:2445,adapt,adaptive,2445,doc/master/rf707__kernelestimation_8py.html,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8py.html,1,['adapt'],['adaptive']
Energy Efficiency,"thow many steps until training is deemed to have convergedDefinition NeuralNet.h:766; TMVA::DNN::Settings::factorWeightDecaydouble factorWeightDecay() constget the weight-decay factorDefinition NeuralNet.h:769; TMVA::DNN::Settings::maxConvergenceCountsize_t maxConvergenceCount() constreturns the max convergence count so farDefinition NeuralNet.h:828; TMVA::DNN::Settings::padsvoid pads(int numPads)preparation for monitoringDefinition NeuralNet.h:818; TMVA::DNN::Settings::batchSizesize_t batchSize() constmini-batch sizeDefinition NeuralNet.h:767; TMVA::DNN::Settings::computeResultvirtual void computeResult(const Net &, std::vector< double > &)callback for monitoring and loggingDefinition NeuralNet.h:809; TMVA::DNN::Settings::dropRepetitionssize_t dropRepetitions() constDefinition NeuralNet.h:761; TMVA::DNN::Settings::createvoid create(std::string histoName, int bins, double min, double max)for monitoringDefinition NeuralNet.h:819; TMVA::DNN::Settings::startTestCyclevirtual void startTestCycle()callback for monitoring and logggingDefinition NeuralNet.h:804; TMVA::DNN::Steepest::m_repetitionssize_t m_repetitionsDefinition NeuralNet.h:337; TMVA::DNN::Steepest::m_betadouble m_betainternal parameter (momentum)Definition NeuralNet.h:372; TMVA::DNN::Steepest::m_localGradientsstd::vector< double > m_localGradientslocal gradients for reuse in thread.Definition NeuralNet.h:376; TMVA::DNN::Steepest::m_prevGradientsstd::vector< double > m_prevGradientsvector remembers the gradients of the previous stepDefinition NeuralNet.h:373; TMVA::DNN::Steepest::m_alphadouble m_alphainternal parameter (learningRate)Definition NeuralNet.h:371; TMVA::DNN::Steepest::m_localWeightsstd::vector< double > m_localWeightslocal weights for reuse in thread.Definition NeuralNet.h:375; TMVA::DNN::Steepest::operator()double operator()(Function &fitnessFunction, Weights &weights, PassThrough &passThrough)operator to call the steepest gradient descent algorithmDefinition NeuralNet.icc:271; TMVA::IPythonInter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:69721,monitor,monitoring,69721,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['monitor'],['monitoring']
Energy Efficiency,"th” is now composed of these sources in order:. ROOT_LIBRARY_PATH environment variable; System specific shared linker environment variables like LD_LIBRARY_PATH, LIBPATH, or PATH.; Setting from rootrc; ROOT’s builtin library directory. Interpreter. cling’s LLVM is upgraded to version 9.0; New interface to enable/disable optional cling features. Currently, it can be used to enable/disable support for redefinitions. See this issue for more information. Multithreading. Fix an uninitialized variable in global read-write lock which could have caused deadlocks or crashes in some rare cases.; Default global read-write lock transitioned to new implementation based on TBB thread local storage when TBB is available on supported platforms (all except Windows). This gives an O(10%) performance improvement for some typical RDataFrame scenarios with 256 threads due to reduced lock contention. I/O Libraries. Exclusive use of the global lock is reduced or migrated to finer grained read and write locks in a few hotspots that occur during file opening/closing or task initialization in RDataFrame. This can lead to O(100x) improvements for some typical RDataFrame scenarios with 256 threads due to massively reduced lock contention. TTree Libraries. TTree now supports the inclusion of leaves of types long and unsigned long (and therefore also std::size_t on most systems) also for branches in “leaflist mode”. The corresponding leaflist letters are ‘G’ and ‘g’.; when looping over a TTree with a friend with a larger number of entries, TTreeReader now ends the event loop when the entries in the main TTree are exhausted, consistently with other interfaces. See #6518 for more details.; TTreeProcessorMT::SetMaxTasksPerFilePerWorker is now deprecated in favor of the more flexible and newly introduced TTreeProcessorMT::SetTasksPerWorkerHint. See the relevant entries in our reference guide for more information.; The name of the sub-branches of a split collection no longer have 2 consecutive dots if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:5505,reduce,reduced,5505,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['reduce'],['reduced']
Energy Efficiency,"tiDim*fIntegratorpointer to multi-dimensional integrator base class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). IntegratorMultiDim(const Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000); Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). virtual ~IntegratorMultiDim(); destructor. IntegratorMultiDim & operator",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IntegratorMultiDim.html:3000,adapt,adaptive,3000,root/html526/ROOT__Math__IntegratorMultiDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IntegratorMultiDim.html,1,['adapt'],['adaptive']
Energy Efficiency,"tibility The array will be filled as x1,y1,z1,....x2,y2,z2,... ;  ; bool Skip (unsigned int n);  skip the next n number and jumb directly to the current state + n ;  ; std::string Type () const;  Return the type (name) of the used generator. ;  . Private Attributes; Engine fEngine;  . #include <Math/QuasiRandom.h>; Constructor & Destructor Documentation. ◆ QuasiRandom() [1/2]. template<class Engine > . ROOT::Math::QuasiRandom< Engine >::QuasiRandom ; (; unsigned int ; dimension = 1). inline . Create a QuasiRandom generator. ; Use default engine constructor. Engine will be initialized via Initialize() function in order to allocate resources ; Definition at line 70 of file QuasiRandom.h. ◆ QuasiRandom() [2/2]. template<class Engine > . ROOT::Math::QuasiRandom< Engine >::QuasiRandom ; (; const Engine & ; e, . unsigned int ; dimension = 1 . ). inlineexplicit . Create a QuasiRandom generator based on a provided generic engine. ; Engine will be initialized via Initialize() function in order to allocate resources ; Definition at line 80 of file QuasiRandom.h. ◆ ~QuasiRandom(). template<class Engine > . ROOT::Math::QuasiRandom< Engine >::~QuasiRandom ; (; ). inline . Destructor: call Terminate() function of engine to free any allocated resource. ; Definition at line 88 of file QuasiRandom.h. Member Function Documentation. ◆ EngineSize(). template<class Engine > . unsigned int ROOT::Math::QuasiRandom< Engine >::EngineSize ; (; ); const. inline . Return the size of the generator state. ; Definition at line 140 of file QuasiRandom.h. ◆ Name(). template<class Engine > . std::string ROOT::Math::QuasiRandom< Engine >::Name ; (; ); const. inline . Return the name of the generator. ; Definition at line 154 of file QuasiRandom.h. ◆ NDim(). template<class Engine > . unsigned int ROOT::Math::QuasiRandom< Engine >::NDim ; (; ); const. inline . Return the dimension of the generator. ; Definition at line 147 of file QuasiRandom.h. ◆ Next() [1/2]. template<class Engine > . double ROOT::Mat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1QuasiRandom.html:2806,allocate,allocate,2806,doc/master/classROOT_1_1Math_1_1QuasiRandom.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1QuasiRandom.html,1,['allocate'],['allocate']
Energy Efficiency,"tic . Return the globally accessible collection. ; Definition at line 680 of file TCollection.cxx. ◆ GetEntries(). virtual Int_t TCollection::GetEntries ; (; ); const. inlinevirtual . Reimplemented in TObjArray, and TRefArray.; Definition at line 179 of file TCollection.h. ◆ GetName(). const char * TCollection::GetName ; (; ); const. overridevirtual . Return name of this collection. ; if no name, return the collection class name. ; Reimplemented from TObject.; Reimplemented in TQCommand, and TQConnection.; Definition at line 351 of file TCollection.cxx. ◆ GetObjectRef(). virtual TObject ** TCollection::GetObjectRef ; (; const TObject * ; obj); const. pure virtual . Implemented in TBtree, THashTable, TList, TMap, TObjArray, TOrdCollection, TRefArray, TListOfEnumsWithLock, TListOfFunctions, TViewPubDataMembers, and TViewPubFunctions. ◆ GetSize(). virtual Int_t TCollection::GetSize ; (; ); const. inlinevirtual . Return the capacity of the collection, i.e. ; the current total amount of space that has been allocated so far. Same as Capacity. Use GetEntries to get the number of elements currently in the collection. ; Reimplemented in THashTable, TListOfEnumsWithLock, TListOfFunctions, TViewPubDataMembers, and TViewPubFunctions.; Definition at line 184 of file TCollection.h. ◆ GrowBy(). Int_t TCollection::GrowBy ; (; Int_t ; delta); const. virtual . Increase the collection's capacity by delta slots. ; Definition at line 360 of file TCollection.cxx. ◆ Hash(). ULong_t TCollection::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the trans",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCollection.html:22789,allocate,allocated,22789,doc/v632/classTCollection.html,https://root.cern,https://root.cern/doc/v632/classTCollection.html,2,['allocate'],['allocated']
Energy Efficiency,"tic TMonitor::EInterestkWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMonitor.html:10840,monitor,monitor,10840,root/html602/TMonitor.html,https://root.cern,https://root.cern/root/html602/TMonitor.html,2,['monitor'],['monitor']
Energy Efficiency,"tic TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TDecompQRH::(anonymous)kWorkMax; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tTDecompBase::fColLwbColumn lower bound of decomposed matrix; Double_tTDecompBase::fConditionmatrix condition number; Double_tTDecompBase::fDet1determinant mantissa; Double_tTDecompBase::fDet2determinant exponent for powers of 2; TMatrixDfQ(m x n) - orthogonal matrix; TMatrixDfR(n x n) - upper triangular matrix; Int_tTDecompBase::fRowLwbRow lower bound of decomposed matrix; Double_tTDecompBase::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1; TVectorDfUp(n) - vector with Householder up's; TVectorDfW(n) - vector with Householder beta's; static TDecompBase::EMatrixDecompStatTDecompBase::kCondition; static TDecompBase::EMatrixDecompStatTDecompBase::kDecomposed; static TDecompBase::EMatrixDecompStatTDecompBase::kDetermined; static TDecompBase::EMatrixDecompStatTDecompBase::kInit; static TDecompBase::EMatrixDecompStatTDecompBase::kMatrixSet; static TDecompBase::EMatrixDecompStatTDecompBase::kPatternSet; static TDecompBase::EMatrixDecompStatTDecompBase::kSingular; static TDecompBase::EMatrixDecompStatTDecompBase::kValuesSet; static TDecompBase::(anonymous)TDecompBase::kWorkMax. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecompQRH(Int_t nrows, Int_t ncols); Constructor for (nrows x ncols) matrix. TDecompQRH(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb); Constructor for ([row_lwb..row_upb] x [col_lwb..col_upb]) matrix. TDecompQRH(const TMatrixD& m, Double_t tol = 0.); Constructor for general matrix A . TDecompQRH(const TDecompQRH& another); Copy con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDecompQRH.html:7931,power,powers,7931,root/html602/TDecompQRH.html,https://root.cern,https://root.cern/root/html602/TDecompQRH.html,2,['power'],['powers']
Energy Efficiency,"tic TObject::EStatusBitskCannotPick; static TObject::EStatusBitskHasUUID; static TObject::EStatusBitskInvalidObject; static TObject::(anonymous)kIsOnHeap; static TObject::EStatusBitskIsReferenced; static TObject::EStatusBitskMustCleanup; static TObject::EStatusBitskNoContextMenu; static TObject::(anonymous)kNotDeleted; static TObject::EStatusBitskObjInCanvas; static TObject::(anonymous)kOverwrite; static TObject::(anonymous)kSingleKey; static TObject::(anonymous)kWriteDelete; static TObject::(anonymous)kZombie. private:. UInt_tfBitsbit field status word; UInt_tfUniqueIDobject unique identifier; static Long_tfgDtorOnlyobject for which to call dtor only (i.e. no delete); static Bool_tfgObjectStatif true keep track of objects in TObjectTable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TObject(); TObject constructor. It sets the two data words of TObject to their; initial values. The unique ID is set to 0 and the status word is; set depending if the object is created on the stack or allocated; on the heap. Depending on the ROOT environment variable ""Root.MemStat""; (see TEnv) the object is added to the global TObjectTable for; bookkeeping. TObject(const TObject& object); TObject copy ctor. TObject& operator=(const TObject& rhs); TObject assignment operator. void Copy(TObject& object) const; Copy this to obj. ~TObject(); TObject destructor. Removes object from all canvases and object browsers; if observer bit is on and remove from the global object table. void AppendPad(Option_t* option = """"); Append graphics object to current pad. In case no current pad is set; yet, create a default canvas with the name ""c1"". void Browse(TBrowser* b); Browse object. May be overridden for another default action. const char * ClassName() const; Returns name of class to which the object belongs. TObject * Clone(const char* newname = """") const; Make a clone of an object using the Streamer facility.; If the object derives from TNamed, this functi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TObject.html:5696,allocate,allocated,5696,root/html602/TObject.html,https://root.cern,https://root.cern/root/html602/TObject.html,2,['allocate'],['allocated']
Energy Efficiency,"tility function for plotOn() that constructs the set of observables to project when plotting ourselv...Definition RooAbsReal.cxx:2903; RooAbsReal::getMaxValvirtual Int_t getMaxVal(const RooArgSet &vars) constAdvertise capability to determine maximum value of function for given set of observables.Definition RooAbsReal.cxx:3386; RooAbsReal::_plotMindouble _plotMinMinimum of plot range.Definition RooAbsReal.h:533; RooAbsReal::meanRooAbsMoment * mean(RooRealVar &obs, const RooArgSet &nset)Definition RooAbsReal.h:360; RooAbsReal::createChi2virtual RooFit::OwningPtr< RooAbsReal > createChi2(RooDataHist &data, const RooLinkedList &cmdList)Definition RooAbsReal.cxx:4200; RooAbsReal::offsetvirtual double offset() constDefinition RooAbsReal.h:371; RooAbsReal::sigmaRooAbsMoment * sigma(RooRealVar &obs)Definition RooAbsReal.h:361; RooAbsReal::_globalSelectCompstatic bool _globalSelectCompDefinition RooAbsReal.h:545; RooAddHelpersDefinition RooAddHelpers.h:56; RooAddModelRooAddModel is an efficient implementation of a sum of PDFs of the form.Definition RooAddModel.h:27; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgProxyAbstract interface for RooAbsArg proxy classes.Definition RooArgProxy.h:24; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooCmdArgNamed container for two doubles, two integers two object points and three string pointers that can be...Definition RooCmdArg.h:26; RooCurve::WingModeWingModeDefinition RooCurve.h:39; RooCurve::Extended@ ExtendedDefinition RooCurve.h:39; RooDataHistContainer class to hold N-dimensional binned data.Definition RooDataHist.h:40; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDerivativeRepresents the first, second, or third order derivative of any RooAbsReal as calculated (numerically)...",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8h_source.html:54894,efficient,efficient,54894,doc/master/RooAbsReal_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html,1,['efficient'],['efficient']
Energy Efficiency,"tination data, its size should be sizex*sizey except for direct FOURIER, FOUR-WALSh, FOUR-HAAR. These need sizex*2*sizey length to store real and imaginary coefficients; sizex,sizey basic dimensions of source and dest spectra; type type of transform. TRANSFORM2_HAAR; TRANSFORM2_WALSH; TRANSFORM2_COS; TRANSFORM2_SIN; TRANSFORM2_FOURIER; TRANSFORM2_HARTLEY; TRANSFORM2_FOURIER_WALSH; TRANSFORM2_FOURIER_HAAR; TRANSFORM2_WALSH_HAAR; TRANSFORM2_COS_WALSH; TRANSFORM2_COS_HAAR; TRANSFORM2_SIN_WALSH; TRANSFORM2_SIN_HAAR. direction transform direction (forward, inverse); degree applies only for mixed transforms. An example of the 2-dimensional Cosine transform of data from Figure 5.6 is given in Figure 6.7. One can notice that the data are concentrated again around the beginning of the coordinate system. This allows to apply filtration, enhancement and compression techniques in the transform domain. 2-dimensional Cosine transform of data from Figure 5.6. In some cases when the spectrum is smooth the cosine transforms are very efficient. In Figures 6.8, 6.9 we show original spectrum and transformed coefficients using Cosine transform, respectively. Original spectrum. Transformed coefficients using Cosine transform. Analogously to 1-dimensional case we have implemented also the functions for zonal filtration, Gauss filtration and enhancement. The zonal filtration function using classic transforms has the form; char *Filter2Zonal(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int degree,; int xmin,; int xmax,; int ymin,; int ymax,; float filter-coeff);; This function transforms the source spectrum. The calling program should fill in input parameters. Then it sets transformed coefficients in the given region to the given filter_coeff and transforms it back Filtered data are written into dest spectrum.; Function parameters:. source pointer to the matrix of source spectrum, its size should be sizex*sizey; dest pointer to the matrix of destination data, its",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:62800,efficient,efficient,62800,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,1,['efficient'],['efficient']
Energy Efficiency,"tion (1D interface). It is copied inside ; typeintegration type (adaptive, non-adaptive, etc..) ; absToldesired absolute tolerance. The algorithm will stop when either the absolute OR the relative tolerance are satisfied. ; relToldesired relative tolerance ; sizemaximum number of sub-intervals ; ruleGauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When no values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions ; Definition at line 142 of file Integrator.h. ◆ IntegratorOneDim() [3/4]. template<class Function > . ROOT::Math::IntegratorOneDim::IntegratorOneDim ; (; Function & ; f, . IntegrationOneDim::Type ; type = IntegrationOneDim::kDEFAULT, . double ; absTol = -1, . double ; relTol = -1, . unsigned int ; size = 0, . int ; rule = 0 . ). inlineexplicit . Template Constructor of one dimensional Integrator passing a generic function object. ; Parameters. fintegration function (any C++ callable object implementing operator()(double x) ; typeintegration type (adaptive, non-adaptive, etc..) ; absToldesired absolute tolerance. The algorithm will stop when either the absolute OR the relative tolerance are satisfied. ; relToldesired relative tolerance ; sizemaximum number of sub-intervals ; ruleGauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When no values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions ; Definition at line 165 of file Integrator.h. ◆ ~IntegratorOneDim(). virtual ROOT::Math::IntegratorOneDim::~IntegratorOneDim ; (; ). inlinevirtual . destructor (will delete contained pointers) ; Definition at line 173 of file Integrator.h. ◆ IntegratorOneDim() [4/4]. ROOT::Math::IntegratorOneDim::IntegratorOneDim ; (; const IntegratorOneDim & ; ). inlineprivate . Definition at line 181 of file Integrator.h. Member Function Documentation. ◆ CreateIntegrator(). VirtualIntegratorOneDim * ROOT::Math::IntegratorOneDim::CreateIntegrator ; (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html:10151,adapt,adaptive,10151,doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html,2,['adapt'],['adaptive']
Energy Efficiency,"tion TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TMVA::ReaderThe Reader class serves to use the MVAs in a specific analysis context.Definition Reader.h:64; TMVA::Reader::EvaluateMVADouble_t EvaluateMVA(const std::vector< Float_t > &, const TString &methodTag, Double_t aux=0)Evaluate a std::vector<float> of input data for a given method The parameter aux is obligatory for th...Definition Reader.cxx:468; TMVA::Reader::BookMVAIMethod * BookMVA(const TString &methodTag, const TString &weightfile)read method name from weight fileDefinition Reader.cxx:368; TMVA::Reader::AddSpectatorvoid AddSpectator(const TString &expression, Float_t *)Add a float spectator or expression to the reader.Definition Reader.cxx:321; TMVA::Reader::AddVariablevoid AddVariable(const TString &expression, Float_t *)Add a float variable or expression to the reader.Definition Reader.cxx:303; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TStringBasic string class.Definition TString.h:139; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; TMVA_SOFIE_GNN_Parser.treetreeDefinition TMVA_SOFIE_GNN_Parser.py:169; Factory.h; AuthorKim Albertsson (adapted from code originally by Andreas Hoecker) ; Definition in file TMVACrossValidationApplication.C. tutorialstmvaTMVACrossValidationApplication.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidationApplication_8C.html:9714,adapt,adapted,9714,doc/master/TMVACrossValidationApplication_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidationApplication_8C.html,1,['adapt'],['adapted']
Energy Efficiency,"tion TLegend.cxx:388; TLegend::AddEntryTLegendEntry * AddEntry(const TObject *obj, const char *label="""", Option_t *option=""lpf"")Add a new entry to this legend.Definition TLegend.cxx:320; TLegend::SetNColumnsvoid SetNColumns(Int_t nColumns)Set the number of columns for the legend.Definition TLegend.cxx:606; TLegend::SetHeadervirtual void SetHeader(const char *header="""", Option_t *option="""")Sets the header, which is the ""title"" that appears at the top of the legend.Definition TLegend.cxx:1085; TLegend::DeleteEntryvirtual void DeleteEntry()Delete entry at the mouse position.Definition TLegend.cxx:413; TLegend::GetEntryTLegendEntry * GetEntry() constGet entry pointed to by the mouse.Definition TLegend.cxx:478; TLegend::GetColumnSeparationFloat_t GetColumnSeparation() constDefinition TLegend.h:46; TLegend::Clearvoid Clear(Option_t *option="""") overrideClear all entries in this legend, including the header.Definition TLegend.cxx:379; TLegend::fEntrySeparationFloat_t fEntrySeparationSeparation between entries, as a fraction of The space allocated to one entry.Definition TLegend.h:74; TLegend::SetEntrySeparationvoid SetEntrySeparation(Float_t entryseparation)Definition TLegend.h:66; TLegend::EditEntryAttMarkervirtual void EditEntryAttMarker()Edit the marker attributes for the entry pointed by the mouse.Definition TLegend.cxx:455; TLegend::GetListOfPrimitivesTList * GetListOfPrimitives() constDefinition TLegend.h:50; TLegend::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave this legend as C++ statements on output stream out to be used with the SaveAs ....Definition TLegend.cxx:1035; TLegend::EditEntryAttTextvirtual void EditEntryAttText()Edit the text attributes for the entry pointed by the mouse.Definition TLegend.cxx:466; TLegend::Paintvoid Paint(Option_t *option="""") overridePaint this legend with its current attributes.Definition TLegend.cxx:561; TLegend::GetNColumnsInt_t GetNColumns() constDefinition TLegend.h:52; TLegend::SetDefaultsvo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLegend_8h_source.html:6058,allocate,allocated,6058,doc/master/TLegend_8h_source.html,https://root.cern,https://root.cern/doc/master/TLegend_8h_source.html,1,['allocate'],['allocated']
Energy Efficiency,"tion at line 1416 of file TColor.cxx. ◆ CreateGradientColorTable(). Int_t TColor::CreateGradientColorTable ; (; UInt_t ; Number, . Double_t * ; Stops, . Double_t * ; Red, . Double_t * ; Green, . Double_t * ; Blue, . UInt_t ; NColors, . Float_t ; alpha = 1., . Bool_t ; setPalette = kTRUE . ). static . Static function creating a color table with several connected linear gradients. . Number: The number of end point colors that will form the gradients. Must be at least 2.; Stops: Where in the whole table the end point colors should lie. Each entry must be on [0, 1], each entry must be greater than the previous entry.; Red, Green, Blue: The end point color values. Each entry must be on [0, 1]; NColors: Total number of colors in the table. Must be at least 1.; alpha: the opacity factor, between 0 and 1. Default is no transparency (1).; setPalette: activate the newly created palette (true by default). If false, the caller is in charge of calling TColor::SetPalette using the return value of the function (first palette color index) and reconstructing the Int_t palette[NColors+1] array. Returns a positive value (the index of the first color of the palette) on success and -1 on error.; The table is constructed by tracing lines between the given points in RGB space. Each color value may have a value between 0 and 1. The difference between consecutive ""Stops"" values gives the fraction of space in the whole table that should be used for the interval between the corresponding color values.; Normally the first element of Stops should be 0 and the last should be 1. If this is not true, fewer than NColors will be used in proportion with the total interval between the first and last elements of Stops.; This definition is similar to the povray-definition of gradient color tables.; For instance: UInt_t Number = 3;; Double_t Red[3] = { 0.0, 1.0, 1.0 };; Double_t Green[3] = { 0.0, 0.0, 1.0 };; Double_t Blue[3] = { 1.0, 0.0, 1.0 };; Double_t Stops[3] = { 0.0, 0.4, 1.0 };; unsigned int; Thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTColor.html:48439,charge,charge,48439,doc/master/classTColor.html,https://root.cern,https://root.cern/doc/master/classTColor.html,1,['charge'],['charge']
Energy Efficiency,"tion at line 44 of file PxPyPzE4D.h. Public Types; typedef ScalarType Scalar;  . Public Member Functions;  PxPyPzE4D ();  Default constructor with x=y=z=t=0. ;  ; template<class CoordSystem > ; constexpr PxPyPzE4D (const CoordSystem &v);  construct from any vector or coordinate system class implementing x(), y() and z() and t() ;  ;  PxPyPzE4D (const PxPyPzE4D &v);  copy constructor ;  ;  PxPyPzE4D (Scalar px, Scalar py, Scalar pz, Scalar e);  Constructor from x, y , z , t values. ;  ; Scalar E () const;  ; Scalar Et () const;  transverse energy ;  ; Scalar Et2 () const;  transverse energy squared ;  ; Scalar Eta () const;  pseudorapidity ;  ; void GetCoordinates (Scalar &px, Scalar &py, Scalar &pz, Scalar &e) const;  get internal data into 4 Scalar numbers ;  ; void GetCoordinates (Scalar dest[]) const;  get internal data into an array of 4 Scalar numbers ;  ; Scalar M () const;  invariant mass ;  ; Scalar M2 () const;  vector magnitude squared (or mass squared) ;  ; Scalar Mag () const;  ; Scalar Mag2 () const;  ; Scalar Mt () const;  transverse mass ;  ; Scalar Mt2 () const;  transverse mass squared ;  ; void Negate ();  negate the 4-vector ;  ; bool operator!= (const PxPyPzE4D &rhs) const;  ; template<class AnyCoordSystem > ; PxPyPzE4D & operator= (const AnyCoordSystem &v);  Assignment from a generic coordinate system implementing x(), y(), z() and t() ;  ; PxPyPzE4D & operator= (const PxPyPzE4D &v);  assignment operator ;  ; bool operator== (const PxPyPzE4D &rhs) const;  Exact equality. ;  ; Scalar P () const;  magnitude of spatial components (magnitude of 3-momentum) ;  ; Scalar P2 () const;  squared magnitude of spatial components ;  ; Scalar Perp () const;  ; Scalar Perp2 () const;  ; Scalar Phi () const;  azimuthal angle ;  ; Scalar Pt () const;  Transverse spatial component (P_perp or rho) ;  ; Scalar Pt2 () const;  transverse spatial component squared ;  ; Scalar Px () const;  ; Scalar Py () const;  ; Scalar Pz () const;  ; Scalar R () const;  ; Scalar Rho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1PxPyPzE4D.html:1214,energy,energy,1214,doc/master/classROOT_1_1Math_1_1PxPyPzE4D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1PxPyPzE4D.html,2,['energy'],['energy']
Energy Efficiency,tion at line 58 of file TPostScript.h. ◆ fDXC. Float_t TPostScript::fDXC. protected . Definition at line 31 of file TPostScript.h. ◆ fDYC. Float_t TPostScript::fDYC. protected . Definition at line 32 of file TPostScript.h. ◆ fFileName. TString TPostScript::fFileName. protected . PS file name. ; Definition at line 77 of file TPostScript.h. ◆ fFontEmbed. Bool_t TPostScript::fFontEmbed. protected . True is FontEmbed has been called. ; Definition at line 78 of file TPostScript.h. ◆ fFX. Float_t TPostScript::fFX. protected . Definition at line 35 of file TPostScript.h. ◆ fFY. Float_t TPostScript::fFY. protected . Definition at line 36 of file TPostScript.h. ◆ fgLineCap. Int_t TPostScript::fgLineCap = 0. staticprotected . Appearance of line caps. ; Definition at line 81 of file TPostScript.h. ◆ fgLineJoin. Int_t TPostScript::fgLineJoin = 0. staticprotected . Appearance of joining lines. ; Definition at line 80 of file TPostScript.h. ◆ fGreen. Float_t TPostScript::fGreen. protected . Per cent of green. ; Definition at line 49 of file TPostScript.h. ◆ fIXzone. Int_t TPostScript::fIXzone. protected . Current zone along X. ; Definition at line 55 of file TPostScript.h. ◆ fIYzone. Int_t TPostScript::fIYzone. protected . Current zone along Y. ; Definition at line 56 of file TPostScript.h. ◆ fLastCellBlue. Int_t TPostScript::fLastCellBlue. protected . Last blue value. ; Definition at line 75 of file TPostScript.h. ◆ fLastCellGreen. Int_t TPostScript::fLastCellGreen. protected . Last green value. ; Definition at line 74 of file TPostScript.h. ◆ fLastCellRed. Int_t TPostScript::fLastCellRed. protected . Last red value. ; Definition at line 73 of file TPostScript.h. ◆ fLineScale. Float_t TPostScript::fLineScale. protected . Line width scale factor. ; Definition at line 51 of file TPostScript.h. ◆ fMarkerSizeCur. Float_t TPostScript::fMarkerSizeCur. protected . current transformed value of marker size ; Definition at line 57 of file TPostScript.h. ◆ fMaxLines. Int_t TPostScript::fMax,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPostScript.html:54433,green,green,54433,doc/master/classTPostScript.html,https://root.cern,https://root.cern/doc/master/classTPostScript.html,1,['green'],['green']
Energy Efficiency,"tion between classes. void GetCov_Full( void ); compute full covariance matrix from sum of within and between matrices. void GetFisherCoeff( void ); Fisher = Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description of Fisher classifier. void ReadWeightsFromXML(void* wghtnode); read Fisher coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". EFisherMethod GetFisherMethod( void ); { return fFisherMethod; }. » Author: Andreas Hoecker, Xavier Prudent, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodFisher.html:21641,power,power,21641,root/html534/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodFisher.html,1,['power'],['power']
Energy Efficiency,"tion code valid for RooAddPdf. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral defined by given scenario code. Double_t expectedEvents(const RooArgSet* nset); Return the number of expected events, which is either the sum of all coefficients; or the sum of the components extended terms, multiplied with the fraction that; is in the current range w.r.t the reference range. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fraction coefficients. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized context to efficiently generate toy events from RooAddPdfs; return RooAbsPdf::genContext(vars,prototype,auxProto,verbose) ; // WVE DEBUG. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Loop over components for plot sampling hints and merge them if there are multiple. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooAddPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooAddPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. Bool_t selfNormalized() const; P.d.f is self normalized. ExtendMode extendMode() const; Return extended mode capabilities. Double_t expectedEvents(const RooArgSet* nset). const RooArgList& pdfList() const; Return list of component p.d.fs. const RooArgList& coefList() const; Return list of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddPdf.html:46642,efficient,efficiently,46642,root/html526/RooAddPdf.html,https://root.cern,https://root.cern/root/html526/RooAddPdf.html,1,['efficient'],['efficiently']
Energy Efficiency,"tion f to all the data points f may be a 2-D function TF2 or 3-d function TF3 The Z values of the 2D graph are replaced by the new values computed using the function. ; Definition at line 658 of file TGraph2D.cxx. ◆ Browse(). void TGraph2D::Browse ; (; TBrowser * ; ). overridevirtual . Browse. ; Reimplemented from TObject.; Definition at line 671 of file TGraph2D.cxx. ◆ Build(). void TGraph2D::Build ; (; Int_t ; n). protected . Creates the 2D graph basic data structure. ; Definition at line 602 of file TGraph2D.cxx. ◆ Class(). static TClass * TGraph2D::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGraph2D::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGraph2D::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 171 of file TGraph2D.h. ◆ Clear(). void TGraph2D::Clear ; (; Option_t * ; option = """"). overridevirtual . Free all memory allocated by this object. ; Reimplemented from TObject.; Definition at line 681 of file TGraph2D.cxx. ◆ CreateInterpolator(). void TGraph2D::CreateInterpolator ; (; Bool_t ; oldInterp). private . Add a TGraphDelaunay in the list of the fHistogram's functions. ; Definition at line 968 of file TGraph2D.cxx. ◆ DeclFileName(). static const char * TGraph2D::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 171 of file TGraph2D.h. ◆ DirectoryAutoAdd(). void TGraph2D::DirectoryAutoAdd ; (; TDirectory * ; dir). virtual . Perform the automatic addition of the graph to the given directory. ; Note this function is called in place when the semantic requires this object to be added to a directory (I.e. when being read from a TKey or being Cloned) ; Definition at line 715 of file TGraph2D.cxx. ◆ DistancetoPrimitive(). Int_t TGraph2D::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Computes distance from point px,py ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph2D.html:39362,allocate,allocated,39362,doc/master/classTGraph2D.html,https://root.cern,https://root.cern/doc/master/classTGraph2D.html,1,['allocate'],['allocated']
Energy Efficiency,"tion for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:60997,efficient,efficiently,60997,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,7,['efficient'],['efficiently']
Energy Efficiency,"tion from a string ;  . Protected Member Functions; VirtualIntegratorOneDim * CreateIntegrator (IntegrationOneDim::Type type, double absTol, double relTol, unsigned int size, int rule);  . Private Member Functions;  IntegratorOneDim (const IntegratorOneDim &);  ; IntegratorOneDim & operator= (const IntegratorOneDim &);  . Private Attributes; IGenFunction * fFunc;  pointer to owned function ;  ; VirtualIntegratorOneDim * fIntegrator;  pointer to integrator interface class ;  . #include <Math/Integrator.h>; Member Typedef Documentation. ◆ Type. typedef IntegrationOneDim::Type ROOT::Math::IntegratorOneDim::Type. Definition at line 102 of file Integrator.h. Constructor & Destructor Documentation. ◆ IntegratorOneDim() [1/4]. ROOT::Math::IntegratorOneDim::IntegratorOneDim ; (; IntegrationOneDim::Type ; type = IntegrationOneDim::kDEFAULT, . double ; absTol = -1, . double ; relTol = -1, . unsigned int ; size = 0, . unsigned int ; rule = 0 . ). inlineexplicit . Constructor of one dimensional Integrator, default type is adaptive. ; Parameters. typeintegration type (adaptive, non-adaptive, etc..) ; absToldesired absolute Error ; relToldesired relative Error ; sizemaximum number of sub-intervals ; ruleGauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL) Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6) lower rules are indicated for singular functions while higher for smooth functions to get better accuracies; NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions ; Definition at line 123 of file Integrator.h. ◆ IntegratorOneDim() [2/4]. ROOT::Math::IntegratorOneDim::IntegratorOneDim ; (; const IGenFunction & ; f, . IntegrationOneDim::Type ; type = IntegrationOneDim::kDEFAULT, . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html:7922,adapt,adaptive,7922,doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html,1,['adapt'],['adaptive']
Energy Efficiency,"tion is required, compute; corresponding square-root matrices; the reference histograms require the correct boundaries. Since in Likelihood classification; the transformations are applied using both classes, also the corresponding boundaries; need to take this into account. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns the likelihood estimator for signal; fill a new Likelihood branch into the testTree. Double_t TransformLikelihoodOutput(Double_t ps, Double_t pb) const; returns transformed or non-transformed output. void WriteOptionsToStream(ostream& o, const TString& prefix) const; write options to stream. void AddWeightsXMLTo(void* parent) const; write weights to XML. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void WriteWeightsToStream(TFile& rf) const; write reference PDFs to ROOT file. void ReadWeightsFromXML(void* wghtnode); read weights from XML. void ReadWeightsFromStream(istream& istr); read weight info from file; nothing to do for this method. void ReadWeightsFromStream(TFile& istr); read reference PDF from ROOT file. void WriteMonitoringHistosToFile( void ); write histograms and PDFs to file for monitoring purposes. void MakeClassSpecificHeader(ostream& , const TString& = """") const; write specific header of the classifier (mostly include files). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Peter Speckmayer, Eckhard von Toerne, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id: MethodLikelihood.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodLikelihood.html:21923,monitor,monitoring,21923,root/html530/TMVA__MethodLikelihood.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodLikelihood.html,1,['monitor'],['monitoring']
Energy Efficiency,"tion lists the contents of a class on stdout. ;  ; void MakeCustomMenuList ();  Makes a customizable version of the popup menu list, i.e. ;  ; Bool_t MatchLegacyCheckSum (UInt_t checksum) const;  Return true if the checksum passed as argument is one of the checksum value produced by the older checksum calculation algorithm. ;  ; void Move (void *arenaFrom, void *arenaTo) const;  Register the fact that an object was moved from the memory location 'arenaFrom' to the memory location 'arenaTo'. ;  ; void * New (ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) const;  Return a pointer to a newly allocated object of this class. ;  ; void * New (void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; void * NewArray (Long_t nElements, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated array of objects of this class. ;  ; void * NewArray (Long_t nElements, void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; ObjectPtr NewObject (ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) const;  ; ObjectPtr NewObject (void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; ObjectPtr NewObjectArray (Long_t nElements, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated array of objects of this class. ;  ; ObjectPtr NewObjectArray (Long_t nElements, void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; virtual void PostLoadCheck ();  Do the initialization that can only be done after the CINT dictionary has been fully populated and can not be delayed efficiently. ;  ; Long_t Property () const override;  Returns the properties of the TClass as a bit field stored as a Long_t value. ;  ; Int_t ReadBuffer (TBuffer &b, void *pointer);  Function called by the Str",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:20468,allocate,allocated,20468,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,3,['allocate'],['allocated']
Energy Efficiency,"tion name; Integrator class. ROOT::Math::IntegratorMultiDim::kADAPTIVE; ROOT::Math::AdaptiveIntegratorMultiDim. ROOT::Math::IntegratorMultiDim::kVEGAS; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kMISER; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kPLAIN; ROOT::Math:::GSLMCIntegrator. The control parameters for the integration algorithms can be specified using the ROOT::Math::IntegratorMultiDimOptions class. Static methods are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:712150,adapt,adaptive,712150,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['adapt'],['adaptive']
Energy Efficiency,"tion of inverse transformation; Log() << kFATAL << ""Inverse transformation for PCA transformation not yet implemented. Hence, this transformation cannot be applied together with regression. Please contact the authors if necessary."" << Endl;. void CalculatePrincipalComponents(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); calculate the principal components for the signal and the background data; it uses the MakePrincipal method of ROOT's TPrincipal class. void X2P(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Calculate the principal components from the original data vector; x, and return it in p (function extracted from TPrincipal::X2P); It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). void P2X(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Perform the back-transformation from the principal components; pc, and return x; It's the users responsibility to make sure that both x and pc are; of the right size (i.e., memory must be allocated for p). void WriteTransformationToStream(ostream& ) const; write mean values to stream. void AttachXMLTo(void* parent); create XML description of PCA transformation. void ReadFromXML(void* trfnode); Read the transformation matrices from the xml node. void ReadTransformationFromStream(istream& , const TString& ); Read mean values from input stream. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); creates C++ code fragment of the PCA transform for inclusion in standalone C++ class. VariablePCATransform( DataSetInfo& dsi ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: VariablePCATransform.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__VariablePCATransform.html:11331,allocate,allocated,11331,root/html532/TMVA__VariablePCATransform.html,https://root.cern,https://root.cern/root/html532/TMVA__VariablePCATransform.html,1,['allocate'],['allocated']
Energy Efficiency,"tion of std::uninitialized_value_construct; 529template <typename ForwardIt>; 530void UninitializedValueConstruct(ForwardIt first, ForwardIt last); 531{; 532#if __cplusplus < 201703L; 533 for (; first != last; ++first); 534 new (static_cast<void *>(std::addressof(*first))) typename std::iterator_traits<ForwardIt>::value_type();; 535#else; 536 std::uninitialized_value_construct(first, last);; 537#endif; 538}; 539 ; 540/// An unsafe function to reset the buffer for which this RVec is acting as a view.; 541///; 542/// \note This is a low-level method that _must_ be called on RVecs that are already non-owning:; 543/// - it does not put the RVec in ""non-owning mode"" (fCapacity == -1); 544/// - it does not free any owned buffer; 545template <typename T>; 546void ResetView(RVec<T> &v, T* addr, std::size_t sz); 547{; 548 v.fBeginX = addr;; 549 v.fSize = sz;; 550}; 551 ; 552} // namespace VecOps; 553} // namespace Internal; 554 ; 555namespace Detail {; 556namespace VecOps {; 557 ; 558/// This class consists of common code factored out of the SmallVector class to; 559/// reduce code duplication based on the SmallVector 'N' template parameter.; 560template <typename T>; 561class R__CLING_PTRCHECK(off) RVecImpl : public Internal::VecOps::SmallVectorTemplateBase<T> {; 562 using SuperClass = Internal::VecOps::SmallVectorTemplateBase<T>;; 563 ; 564public:; 565 using iterator = typename SuperClass::iterator;; 566 using const_iterator = typename SuperClass::const_iterator;; 567 using reference = typename SuperClass::reference;; 568 using size_type = typename SuperClass::size_type;; 569 ; 570protected:; 571 // Default ctor - Initialize to empty.; 572 explicit RVecImpl(unsigned N) : ROOT::Internal::VecOps::SmallVectorTemplateBase<T>(N) {}; 573 ; 574public:; 575 RVecImpl(const RVecImpl &) = delete;; 576 ; 577 ~RVecImpl(); 578 {; 579 // Subclass has already destructed this vector's elements.; 580 // If this wasn't grown from the inline copy, deallocate the old space.; 581 if (!this->isS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:20594,reduce,reduce,20594,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['reduce'],['reduce']
Energy Efficiency,"tion& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int size = 1000, int rule = 3). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int size = 1000, int rule = 3). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IntegratorOneDim.html:6292,adapt,adaptive,6292,root/html526/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IntegratorOneDim.html,2,['adapt'],['adaptive']
Energy Efficiency,"tion) const;  ; virtual TH1D * DoProjection (bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) const;  Internal (protected) method for performing projection on the X or Y axis called by ProjectionX or ProjectionY. ;  ; virtual TH1D * DoQuantiles (bool onX, const char *name, Double_t prob) const;  Implementation of quantiles for x or y. ;  ;  Protected Member Functions inherited from TH1;  TH1 ();  Histogram default constructor. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins);  Constructor for variable bin size histograms using an input array of type double. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Float_t *xbins);  Constructor for variable bin size histograms using an input array of type float. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup);  Constructor for fix bin size histograms. ;  ; virtual Int_t AutoP2FindLimits (Double_t min, Double_t max);  Buffer-based estimate of the histogram range using the power of 2 algorithm. ;  ; Int_t AxisChoice (Option_t *axis) const;  Choose an axis according to ""axis"". ;  ; virtual void DoFillN (Int_t ntimes, const Double_t *x, const Double_t *w, Int_t stride=1);  Internal method to fill histogram content from a vector called directly by TH1::BufferEmpty. ;  ; virtual Double_t DoIntegral (Int_t ix1, Int_t ix2, Int_t iy1, Int_t iy2, Int_t iz1, Int_t iz2, Double_t &err, Option_t *opt, Bool_t doerr=kFALSE) const;  Internal function compute integral and optionally the error between the limits specified by the bin number values working for all histograms (1D, 2D and 3D) ;  ; virtual Bool_t FindNewAxisLimits (const TAxis *axis, const Double_t point, Double_t &newMin, Double_t &newMax);  finds new limits for the axis so that point is within the range and the limits are compatible with the previous ones (see TH1::Merge). ;  ; UInt_t GetAxisLabelStatus () const;  Internal function used in TH1::Fill to see ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2Poly.html:57017,power,power,57017,doc/master/classTH2Poly.html,https://root.cern,https://root.cern/doc/master/classTH2Poly.html,2,['power'],['power']
Energy Efficiency,"tion, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TGHtmlUri.h>. Inheritance diagram for TGHtmlUri:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGHtmlUri() [1/3]. TGHtmlUri::TGHtmlUri ; (; const TGHtmlUri & ; ). privatedelete . ◆ TGHtmlUri() [2/3]. TGHtmlUri::TGHtmlUri ; (; const char * ; zUri = nullptr). Parse a text URI into an HtmlUri structure. ; Definition at line 54 of file TGHtmlUri.cxx. ◆ TGHtmlUri() [3/3]. TGHtmlUri::TGHtmlUri ; (; const TGHtmlUri * ; uri). Html uri copy constructor. ; Definition at line 92 of file TGHtmlUri.cxx. ◆ ~TGHtmlUri(). TGHtmlUri::~TGHtmlUri ; (; ). override . Html uri destructor. ; Definition at line 108 of file TGHtmlUri.cxx. Member Function Documentation. ◆ BuildUri(). char * TGHtmlUri::BuildUri ; (; ). Create a string to hold the given URI. ; Memory to hold the string is allocated with new[] and must be freed by the calling function. ; Definition at line 204 of file TGHtmlUri.cxx. ◆ ComponentLength(). int TGHtmlUri::ComponentLength ; (; const char * ; z, . const char * ; zInit, . const char * ; zTerm . ). Return the length of the next component of the URL in z[] given that the component starts at z[0]. ; The initial sequence of the component must be zInit[]. The component is terminated by any character in zTerm[]. The length returned is 0 if the component doesn't exist. The length includes the zInit[] string, but not the termination character. Component zInit zTerm; ---------- ------- -------; scheme """" "":/?#""; authority ""//"" ""/?#""; path ""/"" ""?#""; query ""?"" ""#""; fragment ""#"" """" . Definition at line 183 of file TGHtmlUri.cxx. ◆ EqualsUri(). int TGHtmlUri::EqualsUri ; (; const TGHtmlUri * ; uri, . int ; field_mask = ( (1<<0)  |  (1<<1)  |    (1<<2)  |  (1<<3)  |    (1<<4) ) . ). Compare another uri with given field mask. ; Definition at line 120 of file TGHtmlUri.cxx. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtmlUri.html:11197,allocate,allocated,11197,doc/master/classTGHtmlUri.html,https://root.cern,https://root.cern/doc/master/classTGHtmlUri.html,1,['allocate'],['allocated']
Energy Efficiency,"tion, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Double_tPDK(Double_t a, Double_t b, Double_t c). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Double_tfBeta[3]betas of decaying particle; TLorentzVectorfDecPro[18]kinematics of the generated particles; Double_tfMass[18]masses of particles; Int_tfNtnumber of decay particles; Double_tfTeCmTmtotal energy in the C.M. minus the total mass; Double_tfWtMaxmaximum weigth. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t PDK(Double_t a, Double_t b, Double_t c); the PDK function. TGenPhaseSpace(const TGenPhaseSpace& gen); copy constructor. TGenPhaseSpace& operator=(const TGenPhaseSpace& gen); Assignment operator. Double_t Generate(); Generate a random final state.; The function returns the weigth of the current event.; The TLorentzVector of each decay product can be obtained using GetDecay(n). Note that Momentum, Energy units are Gev/C, GeV. TLorentzVector * GetDecay(Int_t n); return Lorentz vector corresponding to decay n. Bool_t SetDecay(TLorentzVector& P, Int_t nt, const Double_t* mass, Option_t* opt = """"); input:; TLorentzVector &P: decay particle (Momentum, Energy units are Gev/C, GeV); Int_t nt: number of decay products; Double_t *mass: a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGenPhaseSpace.html:6569,energy,energy,6569,root/html602/TGenPhaseSpace.html,https://root.cern,https://root.cern/root/html602/TGenPhaseSpace.html,2,['energy'],['energy']
Energy Efficiency,"tion; TVirtualX(const char* name, const char* title); Ctor of ABC. TVirtualX *& Instance(); Returns gVirtualX global. void GetWindowAttributes(Window_t id, WindowAttributes_t& attr); The WindowAttributes_t structure is set to default. Bool_t ParseColor(Colormap_t cmap, const char* cname, ColorStruct_t& color); Looks up the string name of a color ""cname"" with respect to the screen; associated with the specified colormap. It returns the exact color value.; If the color name is not in the Host Portable Character Encoding,; the result is implementation dependent. cmap - the colormap; cname - the color name string; use of uppercase or lowercase; does not matter; color - returns the exact color value for later use. The ColorStruct_t structure is set to default. Let system think we; could parse color. Bool_t AllocColor(Colormap_t cmap, ColorStruct_t& color); Allocates a read-only colormap entry corresponding to the closest RGB; value supported by the hardware. If no cell could be allocated it; returns kFALSE, otherwise kTRUE. The pixel value is set to default. Let system think we could allocate; color. cmap - the colormap; color - specifies and returns the values actually used in the cmap. void QueryColor(Colormap_t cmap, ColorStruct_t& color); Returns the current RGB value for the pixel in the ""color"" structure. The color components are set to default. cmap - the colormap; color - specifies and returns the RGB values for the pixel specified; in the structure. void NextEvent(Event_t& event); The ""event"" is set to default event.; This method however, should never be called. void GetPasteBuffer(Window_t id, Atom_t atom, TString& text, Int_t& nchar, Bool_t del); Gets contents of the paste buffer ""atom"" into the string ""text"".; (nchar = number of characters) If ""del"" is true deletes the paste; buffer afterwards. Bool_t Init(void* display = 0); Initializes the X system. Returns kFALSE in case of failure.; It is implementation dependent. void ClearWindow(); Clears the entire area",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualX.html:22264,allocate,allocated,22264,root/html528/TVirtualX.html,https://root.cern,https://root.cern/root/html528/TVirtualX.html,6,['allocate'],['allocated']
Energy Efficiency,"tionCuts(). Double_t TMVA::MethodBDT::ApplyPreselectionCuts ; (; const Event * ; ev). private . Apply the preselection cuts before even bothering about any Decision Trees in the GetMVA . ; . --> -1 for background +1 for Signal ; Definition at line 3132 of file MethodBDT.cxx. ◆ Bagging(). Double_t TMVA::MethodBDT::Bagging ; (; ). private . Call it boot-strapping, re-sampling or whatever you like, in the end it is nothing else but applying ""random"" poisson weights to each event. ; Definition at line 2139 of file MethodBDT.cxx. ◆ Boost(). Double_t TMVA::MethodBDT::Boost ; (; std::vector< const TMVA::Event * > & ; eventSample, . DecisionTree * ; dt, . UInt_t ; cls = 0 . ). Apply the boosting algorithm (the algorithm is selecte via the ""option"" given in the constructor. ; The return value is the boosting weight. ; Definition at line 1717 of file MethodBDT.cxx. ◆ BoostMonitor(). void TMVA::MethodBDT::BoostMonitor ; (; Int_t ; iTree). private . Fills the ROCIntegral vs Itree from the testSample for the monitoring plots during the training . ; . but using the testing events ; Definition at line 1751 of file MethodBDT.cxx. ◆ Class(). static TClass * TMVA::MethodBDT::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::MethodBDT::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::MethodBDT::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 305 of file MethodBDT.h. ◆ CreateRanking(). const TMVA::Ranking * TMVA::MethodBDT::CreateRanking ; (; ). virtual . Compute ranking of input variables. ; Implements TMVA::MethodBase.; Definition at line 2682 of file MethodBDT.cxx. ◆ DeclareCompatibilityOptions(). void TMVA::MethodBDT::DeclareCompatibilityOptions ; (; ). protectedvirtual . Options that are used ONLY for the READER to ensure backward compatibility. ; Reimplemented from TMVA::MethodBase.; Definition at line 454 of file MethodBD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:44973,monitor,monitoring,44973,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['monitor'],['monitoring']
Energy Efficiency,"tions away from the mean. ; nLExponent of power-law tail on the left. ; alphaRLocation of transition to a power law on the right, in standard deviations away from the mean. ; nRExponent of power-law tail on the right. . Definition at line 102 of file RooCrystalBall.cxx. ◆ RooCrystalBall() [4/5]. RooCrystalBall::RooCrystalBall ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; x, . RooAbsReal & ; x0, . RooAbsReal & ; sigmaLR, . RooAbsReal & ; alpha, . RooAbsReal & ; n, . bool ; doubleSided = false . ). Create a crystal ball shape with symmetric Gaussian core and only a tail on one side (just like RooCBShape) or two symmetric tails (like RooSDSCBShape). ; Parameters. nameName that identifies the PDF in computations. ; titleTitle for plotting. ; xThe variable of the PDF. ; x0Location parameter of the Gaussian component. ; sigmaLRWidth parameter of the Gaussian component. ; alphaLocation of transition to a power law, in standard deviations away from the mean. ; nExponent of power-law tail. ; doubleSidedWhether the tail is only on one side or on both sides . Definition at line 129 of file RooCrystalBall.cxx. ◆ RooCrystalBall() [5/5]. RooCrystalBall::RooCrystalBall ; (; const RooCrystalBall & ; other, . const char * ; name = nullptr . ). Copy a RooCrystalBall. ; Definition at line 150 of file RooCrystalBall.cxx. Member Function Documentation. ◆ analyticalIntegral(). double RooCrystalBall::analyticalIntegral ; (; Int_t ; code, . const char * ; rangeName = nullptr . ); const. overridevirtual . Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ; This functions will only be called with codes returned by getAnalyticalIntegral, except code zero. ; Reimplemented from RooAbsReal.; Definition at line 241 of file RooCrystalBall.cxx. ◆ Class(). static TClass * RooCrystalBall::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooCrystalBall::Class_Name ; (; ). static . ReturnsName of this cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCrystalBall.html:78064,power,power-law,78064,doc/master/classRooCrystalBall.html,https://root.cern,https://root.cern/doc/master/classRooCrystalBall.html,1,['power'],['power-law']
Energy Efficiency,"tions inside \(\mbox{FCN}\) will be performed approximately to the same accuracy.; The accuracy M expects is called machine precision (MnMachinePrecision, see [api:epsmac]) and can be printed on demand using std::cout. If the user fools M by making internal \(\mbox{FCN}\) computations in single precision, M will interpret roundoff noise as significant and will usually either fail to find a minimum, or give incorrect values for the parameter errors.; It is therefore recommended to make sure that all computations in \(\mbox{FCN}\), as well as all methods and functions called by \(\mbox{FCN}\), are done in double precision. If for some reason the computations cannot be done to a precision comparable with that expected by M , the user must inform M of this situation with setting a different machine precision via the MnMachinePrecision::setPrecision(double) method.; With reduced precision, the user may find that certain features sensitive to first and second differences (\(\mbox{HESSE}\), \(\mbox{MINOS}\), \(\mbox{CONTOURS}\)) do not work properly, in which case the calculations must be performed in higher precision.; 4 How to use M; [howto:howto]; 4.1 The \(\mbox{FCN}\) Function; [howto:fcn]; The user must always implement a derived class of FCNBase (the “\(\mbox{FCN}\)”) which calculates the function value to be minimized or analyzed. Note that when M is being used through an intermediate package such as HippoDraw @bib-HippoDraw, then the user’s \(\mbox{FCN}\) may be supplied by the this package.; The name of the user’s class to implement the FCNBase interface may be chosen freely (in documentation we give it the generic name \(\mbox{FCN}\)).; 4.1.1 FCNBase::operator()(const std::vector\(<\)double\(>\)&); The meaning of the vector of parameters std::vector\(<\)double\(>\) in the argument of FCNBase::operator() are of course defined by the user, who uses the values of those parameters to calculate his function value. The order and the position of these parameters is stri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:33119,reduce,reduced,33119,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['reduce'],['reduced']
Energy Efficiency,"tions inside \(\mbox{FCN}\) will be performed approximately to the same accuracy.; The accuracy M expects is called machine precision (MnMachinePrecision, see [api:epsmac]) and can be printed on demand using std::cout. If the user fools M by making internal \(\mbox{FCN}\) computations in single precision, M will interpret roundoff noise as significant and will usually either fail to find a minimum, or give incorrect values for the parameter errors.; It is therefore recommended to make sure that all computations in \(\mbox{FCN}\), as well as all methods and functions called by \(\mbox{FCN}\), are done in double precision. If for some reason the computations cannot be done to a precision comparable with that expected by M , the user must inform M of this situation with setting a different machine precision via the MnMachinePrecision::setPrecision(double) method.; With reduced precision, the user may find that certain features sensitive to first and second differences (\(\mbox{HESSE}\), \(\mbox{MINOS}\), \(\mbox{CONTOURS}\)) do not work properly, in which case the calculations must be performed in higher precision.; 4 How to use M; [howto:howto]; 4.1 The \(\mbox{FCN}\) Function; [howto:fcn]; The user must always implement a derived class of FCNBase (the “\(\mbox{FCN}\)”) which calculates the function value to be minimized or analyzed. Note that when M is being used through an intermediate package such as HippoDraw @bib-HippoDraw, then the user’s \(\mbox{FCN}\) may be supplied by the this package.; The name of the user’s class to implement the FCNBase interface may be chosen freely (in documentation we give it the generic name \(\mbox{FCN}\)).; 4.1.1 FCNBase::operator()(const std::vector\(<\)double\(>\)&); The meaning of the vector of parameters std::vector\(<\)double\(>\) in the argument of FCNBase::operator() are of course defined by the user, who uses the values of those parameters to calculate their function value. The order and the position of these parameters is st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:29095,reduce,reduced,29095,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,1,['reduce'],['reduced']
Energy Efficiency,"tions |; Protected Attributes |; List of all members ; TClonesArray Class ReferenceCore ROOT classes » Containers. ; An array of clone (identical) objects. ; Memory for the objects stored in the array is allocated only once in the lifetime of the clones array. All objects must be of the same class. For the rest this class has the same properties as TObjArray.; To reduce the very large number of new and delete calls in large loops like this (O(100000) x O(10000) times new/delete): TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);; ...; ...; }; ...; a.Delete();; }; a#define a(i)Definition RSha256.hxx:99; TObjArrayAn array of TObjects.Definition TObjArray.h:31; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; One better uses a TClonesArray which reduces the number of new/delete calls to only O(10000): TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);; ...; ...; }; ...; a.Delete(); // or a.Clear() or a.Clear(""C""); }; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; To reduce the number of call to the constructor (especially useful if the user class requires memory allocation), the object can be added (and constructed when needed) using ConstructedAt which only calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);; ...; ...; }; ...; a.Clear(); // or a.Clear(""C"");; }; Note: the only supported way to add objects to a TClonesArray is via the new with placement method or the ConstructedAt method. The other Add() methods ofTObjArray and its base classes are not a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:1114,reduce,reduces,1114,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['reduce'],['reduces']
Energy Efficiency,"tions). TH1 * Rebin(Int_t ngroup = 2, const char* newname = """", const Double_t* xbins = 0); Rebin this histogram. -case 1 xbins=0; If newname is blank (default), the current histogram is modified and; a pointer to it is returned. If newname is not blank, the current histogram is not modified, and a; new histogram is returned which is a Clone of the current histogram; with its name set to newname. The parameter ngroup indicates how many bins of this have to be merged; into one bin of the result. If the original histogram has errors stored (via Sumw2), the resulting; histograms has new errors correctly calculated. examples: if h1 is an existing TH1F histogram with 100 bins; h1->Rebin(); //merges two bins in one in h1: previous contents of h1 are lost; h1->Rebin(5); //merges five bins in one in h1; TH1F *hnew = h1->Rebin(5,""hnew""); // creates a new histogram hnew; // merging 5 bins of h1 in one bin. NOTE: If ngroup is not an exact divider of the number of bins,; the top limit of the rebinned histogram is reduced; to the upper edge of the last bin that can make a complete; group. The remaining bins are added to the overflow bin.; Statistics will be recomputed from the new bin contents. -case 2 xbins!=0; A new histogram is created (you should specify newname).; The parameter ngroup is the number of variable size bins in the created histogram.; The array xbins must contain ngroup+1 elements that represent the low-edges; of the bins.; If the original histogram has errors stored (via Sumw2), the resulting; histograms has new errors correctly calculated. NOTE: The bin edges specified in xbins should correspond to bin edges; in the original histogram. If a bin edge in the new histogram is; in the middle of a bin in the original histogram, all entries in; the split bin in the original histogram will be transfered to the; lower of the two possible bins in the new histogram. This is; probably not what you want. examples: if h1 is an existing TH1F histogram with 100 bins; Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH1.html:97173,reduce,reduced,97173,root/html532/TH1.html,https://root.cern,https://root.cern/root/html532/TH1.html,4,['reduce'],['reduced']
Energy Efficiency,"tions*-*-*-*-*-*. See class TFitPanel for example. TH1 * GetAsymmetry(TH1* h2, Double_t c2 = 1, Double_t dc2 = 0); return an histogram containing the asymmetry of this histogram with h2,; where the asymmetry is defined as:. Asymmetry = (h1 - h2)/(h1 + h2) where h1 = this. works for 1D, 2D, etc. histograms; c2 is an optional argument that gives a relative weight between the two; histograms, and dc2 is the error on this weight. This is useful, for example,; when forming an asymmetry between two histograms from 2 different data sets that; need to be normalized to each other in some way. The function calculates; the errors asumming Poisson statistics on h1 and h2 (that is, dh = sqrt(h)). example: assuming 'h1' and 'h2' are already filled. h3 = h1->GetAsymmetry(h2). then 'h3' is created and filled with the asymmetry between 'h1' and 'h2';; h1 and h2 are left intact. Note that it is the user's responsibility to manage the created histogram. code proposed by Jason Seely (seely@mit.edu) and adapted by R.Brun. clone the histograms so top and bottom will have the; correct dimensions:; Sumw2 just makes sure the errors will be computed properly; when we form sums and ratios below. Int_t GetDefaultBufferSize(); static function; return the default buffer size for automatic histograms; the parameter fgBufferSize may be changed via SetDefaultBufferSize. Bool_t GetDefaultSumw2(); static function; return kTRUE if TH1::Sumw2 must be called when creating new histograms.; see TH1::SetDefaultSumw2. Double_t GetEntries() const; return the current number of entries. Double_t GetEffectiveEntries() const; number of effective entries of the histogram,; i.e. the number of unweighted entries a histogram would need to; have the same statistical power as this histogram with possibly; weighted entries (i.e. <= TH1::GetEntries()). char * GetObjectInfo(Int_t px, Int_t py) const; Redefines TObject::GetObjectInfo.; Displays the histogram info (bin number, contents, integral up to bin; corresponding to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:82868,adapt,adapted,82868,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,3,['adapt'],['adapted']
